{
    "projects": [
        {
            "name": "Lang",
            "bugs": [
                {
                    "bug_id": 1,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.math.NumberUtilsTest.TestLang747",
                            "test_body": "250: public void TestLang747() {\n251: assertEquals(Integer.valueOf(0x8000),      NumberUtils.createNumber(\"0x8000\"));\n252: assertEquals(Integer.valueOf(0x80000),     NumberUtils.createNumber(\"0x80000\"));\n253: assertEquals(Integer.valueOf(0x800000),    NumberUtils.createNumber(\"0x800000\"));\n254: assertEquals(Integer.valueOf(0x8000000),   NumberUtils.createNumber(\"0x8000000\"));\n255: assertEquals(Integer.valueOf(0x7FFFFFFF),  NumberUtils.createNumber(\"0x7FFFFFFF\"));\n256: assertEquals(Long.valueOf(0x80000000L),    NumberUtils.createNumber(\"0x80000000\"));\n257: assertEquals(Long.valueOf(0xFFFFFFFFL),    NumberUtils.createNumber(\"0xFFFFFFFF\"));\n258: 259: // Leading zero tests\n260: assertEquals(Integer.valueOf(0x8000000),   NumberUtils.createNumber(\"0x08000000\"));\n261: assertEquals(Integer.valueOf(0x7FFFFFFF),  NumberUtils.createNumber(\"0x007FFFFFFF\"));\n262: assertEquals(Long.valueOf(0x80000000L),    NumberUtils.createNumber(\"0x080000000\"));\n263: assertEquals(Long.valueOf(0xFFFFFFFFL),    NumberUtils.createNumber(\"0x00FFFFFFFF\"));\n264: 265: assertEquals(Long.valueOf(0x800000000L),        NumberUtils.createNumber(\"0x800000000\"));\n266: assertEquals(Long.valueOf(0x8000000000L),       NumberUtils.createNumber(\"0x8000000000\"));\n267: assertEquals(Long.valueOf(0x80000000000L),      NumberUtils.createNumber(\"0x80000000000\"));\n268: assertEquals(Long.valueOf(0x800000000000L),     NumberUtils.createNumber(\"0x800000000000\"));\n269: assertEquals(Long.valueOf(0x8000000000000L),    NumberUtils.createNumber(\"0x8000000000000\"));\n270: assertEquals(Long.valueOf(0x80000000000000L),   NumberUtils.createNumber(\"0x80000000000000\"));\n271: assertEquals(Long.valueOf(0x800000000000000L),  NumberUtils.createNumber(\"0x800000000000000\"));\n272: assertEquals(Long.valueOf(0x7FFFFFFFFFFFFFFFL), NumberUtils.createNumber(\"0x7FFFFFFFFFFFFFFF\"));\n273: // N.B. Cannot use a hex constant such as 0x8000000000000000L here as that is interpreted as a negative long\n274: assertEquals(new BigInteger(\"8000000000000000\", 16), NumberUtils.createNumber(\"0x8000000000000000\"));\n275: assertEquals(new BigInteger(\"FFFFFFFFFFFFFFFF\", 16), NumberUtils.createNumber(\"0xFFFFFFFFFFFFFFFF\"));\n276: 277: // Leading zero tests\n278: assertEquals(Long.valueOf(0x80000000000000L),   NumberUtils.createNumber(\"0x00080000000000000\"));\n279: assertEquals(Long.valueOf(0x800000000000000L),  NumberUtils.createNumber(\"0x0800000000000000\"));\n280: assertEquals(Long.valueOf(0x7FFFFFFFFFFFFFFFL), NumberUtils.createNumber(\"0x07FFFFFFFFFFFFFFF\"));\n281: // N.B. Cannot use a hex constant such as 0x8000000000000000L here as that is interpreted as a negative long\n282: assertEquals(new BigInteger(\"8000000000000000\", 16), NumberUtils.createNumber(\"0x00008000000000000000\"));\n283: assertEquals(new BigInteger(\"FFFFFFFFFFFFFFFF\", 16), NumberUtils.createNumber(\"0x0FFFFFFFFFFFFFFFF\"));\n284: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:<clinit>()V",
                                    "method_body": "public static final String EMPTY = \"\";\n\n/**\n* A String for linefeed LF (\"\\n\").\n*\n* @see <a href=\"http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.6\">JLF: Escape Sequences\n*      for Character and String Literals</a>\n* @since 3.2\n*/\npublic static final String LF = \"\\n\";\n\n/**\n* A String for carriage return CR (\"\\r\").\n*\n* @see <a href=\"http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.6\">JLF: Escape Sequences\n*      for Character and String Literals</a>\n* @since 3.2\n*/\npublic static final String CR = \"\\r\";\n\n/**\n* Represents a failed index search.\n* @since 2.1\n*/\npublic static final int INDEX_NOT_FOUND = -1;\n\n/**\n* <p>The maximum size to which the padding constant(s) can expand.</p>\n*/\nprivate static final int PAD_LIMIT = 8192;\n\n/**\n* A regex pattern for recognizing blocks of whitespace characters.\n* The apparent convolutedness of the pattern serves the purpose of\n* ignoring \"blocks\" consisting of only a single space:  the pattern\n* is used only to normalize whitespace, condensing \"blocks\" down to a\n* single space, thus matching the same would likely cause a great\n* many noop replacements.\n*/\nprivate static final Pattern WHITESPACE_PATTERN = Pattern.compile(\"(?: \\\\s|[\\\\s&&[^ ]])\\\\s*\");\n\n/**\n* <p>{@code StringUtils} instances should NOT be constructed in"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:isBlank(Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean isBlank(final CharSequence cs) {\nint strLen;\nif (cs == null || (strLen = cs.length()) == 0) {\nreturn true;\n}\nfor (int i = 0; i < strLen; i++) {\nif (Character.isWhitespace(cs.charAt(i)) == false) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:<clinit>()V",
                                    "method_body": "public static final Long LONG_ZERO = Long.valueOf(0L);\n/** Reusable Long constant for one. */\npublic static final Long LONG_ONE = Long.valueOf(1L);\n/** Reusable Long constant for minus one. */\npublic static final Long LONG_MINUS_ONE = Long.valueOf(-1L);\n/** Reusable Integer constant for zero. */\npublic static final Integer INTEGER_ZERO = Integer.valueOf(0);\n/** Reusable Integer constant for one. */\npublic static final Integer INTEGER_ONE = Integer.valueOf(1);\n/** Reusable Integer constant for minus one. */\npublic static final Integer INTEGER_MINUS_ONE = Integer.valueOf(-1);\n/** Reusable Short constant for zero. */\npublic static final Short SHORT_ZERO = Short.valueOf((short) 0);\n/** Reusable Short constant for one. */\npublic static final Short SHORT_ONE = Short.valueOf((short) 1);\n/** Reusable Short constant for minus one. */\npublic static final Short SHORT_MINUS_ONE = Short.valueOf((short) -1);\n/** Reusable Byte constant for zero. */\npublic static final Byte BYTE_ZERO = Byte.valueOf((byte) 0);\n/** Reusable Byte constant for one. */\npublic static final Byte BYTE_ONE = Byte.valueOf((byte) 1);\n/** Reusable Byte constant for minus one. */\npublic static final Byte BYTE_MINUS_ONE = Byte.valueOf((byte) -1);\n/** Reusable Double constant for zero. */\npublic static final Double DOUBLE_ZERO = Double.valueOf(0.0d);\n/** Reusable Double constant for one. */\npublic static final Double DOUBLE_ONE = Double.valueOf(1.0d);\n/** Reusable Double constant for minus one. */\npublic static final Double DOUBLE_MINUS_ONE = Double.valueOf(-1.0d);\n/** Reusable Float constant for zero. */\npublic static final Float FLOAT_ZERO = Float.valueOf(0.0f);\n/** Reusable Float constant for one. */\npublic static final Float FLOAT_ONE = Float.valueOf(1.0f);\n/** Reusable Float constant for minus one. */\npublic static final Float FLOAT_MINUS_ONE = Float.valueOf(-1.0f);\n\n/**\n* <p><code>NumberUtils</code> instances should NOT be constructed in standard programming.\n* Instead, the class should be used as <code>NumberUtils.toInt(\"6\");</code>.</p>\n*\n* <p>This constructor is public to permit tools that require a JavaBean instance\n* to operate.</p>\n*/\npublic NumberUtils() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createNumber(Ljava/lang/String;)Ljava/lang/Number;",
                                    "method_body": "public static Number createNumber(final String str) throws NumberFormatException {\nif (str == null) {\nreturn null;\n}\nif (StringUtils.isBlank(str)) {\nthrow new NumberFormatException(\"A blank string is not a valid number\");\n}\n// Need to deal with all possible hex prefixes here\nfinal String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\nint pfxLen = 0;\nfor(final String pfx : hex_prefixes) {\nif (str.startsWith(pfx)) {\npfxLen += pfx.length();\nbreak;\n}\n}\nif (pfxLen > 0) { // we have a hex number\nfinal int hexDigits = str.length() - pfxLen;\nif (hexDigits > 16) { // too many for Long\nreturn createBigInteger(str);\n}\nif (hexDigits > 8) { // too many for an int\nreturn createLong(str);\n}\nreturn createInteger(str);\n}\nfinal char lastChar = str.charAt(str.length() - 1);\nString mant;\nString dec;\nString exp;\nfinal int decPos = str.indexOf('.');\nfinal int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n// if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n// and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\nint numDecimals = 0; // Check required precision (LANG-693)\nif (decPos > -1) { // there is a decimal point\n\nif (expPos > -1) { // there is an exponent\nif (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\nthrow new NumberFormatException(str + \" is not a valid number.\");\n}\ndec = str.substring(decPos + 1, expPos);\n} else {\ndec = str.substring(decPos + 1);\n}\nmant = str.substring(0, decPos);\nnumDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n} else {\nif (expPos > -1) {\nif (expPos > str.length()) { // prevents double exponent causing IOOBE\nthrow new NumberFormatException(str + \" is not a valid number.\");\n}\nmant = str.substring(0, expPos);\n} else {\nmant = str;\n}\ndec = null;\n}\nif (!Character.isDigit(lastChar) && lastChar != '.') {\nif (expPos > -1 && expPos < str.length() - 1) {\nexp = str.substring(expPos + 1, str.length() - 1);\n} else {\nexp = null;\n}\n//Requesting a specific type..\nfinal String numeric = str.substring(0, str.length() - 1);\nfinal boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\nswitch (lastChar) {\ncase 'l' :\ncase 'L' :\nif (dec == null\n&& exp == null\n&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\ntry {\nreturn createLong(numeric);\n} catch (final NumberFormatException nfe) { // NOPMD\n// Too big for a long\n}\nreturn createBigInteger(numeric);\n\n}\nthrow new NumberFormatException(str + \" is not a valid number.\");\ncase 'f' :\ncase 'F' :\ntry {\nfinal Float f = NumberUtils.createFloat(numeric);\nif (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n//If it's too big for a float or the float value = 0 and the string\n//has non-zeros in it, then float does not have the precision we want\nreturn f;\n}\n\n} catch (final NumberFormatException nfe) { // NOPMD\n// ignore the bad number\n}\n//$FALL-THROUGH$\ncase 'd' :\ncase 'D' :\ntry {\nfinal Double d = NumberUtils.createDouble(numeric);\nif (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\nreturn d;\n}\n} catch (final NumberFormatException nfe) { // NOPMD\n// ignore the bad number\n}\ntry {\nreturn createBigDecimal(numeric);\n} catch (final NumberFormatException e) { // NOPMD\n// ignore the bad number\n}\n//$FALL-THROUGH$\ndefault :\nthrow new NumberFormatException(str + \" is not a valid number.\");\n\n}\n}\n//User doesn't have a preference on the return type, so let's start\n//small and go from there...\nif (expPos > -1 && expPos < str.length() - 1) {\nexp = str.substring(expPos + 1, str.length());\n} else {\nexp = null;\n}\nif (dec == null && exp == null) { // no decimal point and no exponent\n//Must be an Integer, Long, Biginteger\ntry {\nreturn createInteger(str);\n} catch (final NumberFormatException nfe) { // NOPMD\n// ignore the bad number\n}\ntry {\nreturn createLong(str);\n} catch (final NumberFormatException nfe) { // NOPMD\n// ignore the bad number\n}\nreturn createBigInteger(str);\n}\n\n//Must be a Float, Double, BigDecimal\nfinal boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\ntry {\nif(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float\nfinal Float f = createFloat(str);\nif (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\nreturn f;\n}\n}\n} catch (final NumberFormatException nfe) { // NOPMD\n// ignore the bad number\n}\ntry {\nif(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double\nfinal Double d = createDouble(str);\nif (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\nreturn d;\n}\n}\n} catch (final NumberFormatException nfe) { // NOPMD\n// ignore the bad number\n}\n\nreturn createBigDecimal(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createInteger(Ljava/lang/String;)Ljava/lang/Integer;",
                                    "method_body": "public static Integer createInteger(final String str) {\nif (str == null) {\nreturn null;\n}\n// decode() handles 0xAABD and 0777 (hex and octal) as well.\nreturn Integer.decode(str);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 3,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.math.NumberUtilsTest.testStringCreateNumberEnsureNoPrecisionLoss",
                            "test_body": "123: public void testStringCreateNumberEnsureNoPrecisionLoss(){\n124: String shouldBeFloat = \"1.23\";\n125: String shouldBeDouble = \"3.40282354e+38\";\n126: String shouldBeBigDecimal = \"1.797693134862315759e+308\";\n127: 128: assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float);\n129: assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double);\n130: assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal);\n131: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:<clinit>()V",
                                    "method_body": "public static final String EMPTY = \"\";\n\n/**\n* A String for linefeed LF (\"\\n\").\n*\n* @see <a href=\"http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.6\">JLF: Escape Sequences\n*      for Character and String Literals</a>\n* @since 3.2\n*/\npublic static final String LF = \"\\n\";\n\n/**\n* A String for carriage return CR (\"\\r\").\n*\n* @see <a href=\"http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.6\">JLF: Escape Sequences\n*      for Character and String Literals</a>\n* @since 3.2\n*/\npublic static final String CR = \"\\r\";\n\n/**\n* Represents a failed index search.\n* @since 2.1\n*/\npublic static final int INDEX_NOT_FOUND = -1;\n\n/**\n* <p>The maximum size to which the padding constant(s) can expand.</p>\n*/\nprivate static final int PAD_LIMIT = 8192;\n\n/**\n* A regex pattern for recognizing blocks of whitespace characters.\n* The apparent convolutedness of the pattern serves the purpose of\n* ignoring \"blocks\" consisting of only a single space:  the pattern\n* is used only to normalize whitespace, condensing \"blocks\" down to a\n* single space, thus matching the same would likely cause a great\n* many noop replacements.\n*/\nprivate static final Pattern WHITESPACE_PATTERN = Pattern.compile(\"(?: \\\\s|[\\\\s&&[^ ]])\\\\s*\");\n\n/**\n* <p>{@code StringUtils} instances should NOT be constructed in"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:isBlank(Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean isBlank(final CharSequence cs) {\nint strLen;\nif (cs == null || (strLen = cs.length()) == 0) {\nreturn true;\n}\nfor (int i = 0; i < strLen; i++) {\nif (Character.isWhitespace(cs.charAt(i)) == false) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:<clinit>()V",
                                    "method_body": "public static final Long LONG_ZERO = Long.valueOf(0L);\n/** Reusable Long constant for one. */\npublic static final Long LONG_ONE = Long.valueOf(1L);\n/** Reusable Long constant for minus one. */\npublic static final Long LONG_MINUS_ONE = Long.valueOf(-1L);\n/** Reusable Integer constant for zero. */\npublic static final Integer INTEGER_ZERO = Integer.valueOf(0);\n/** Reusable Integer constant for one. */\npublic static final Integer INTEGER_ONE = Integer.valueOf(1);\n/** Reusable Integer constant for minus one. */\npublic static final Integer INTEGER_MINUS_ONE = Integer.valueOf(-1);\n/** Reusable Short constant for zero. */\npublic static final Short SHORT_ZERO = Short.valueOf((short) 0);\n/** Reusable Short constant for one. */\npublic static final Short SHORT_ONE = Short.valueOf((short) 1);\n/** Reusable Short constant for minus one. */\npublic static final Short SHORT_MINUS_ONE = Short.valueOf((short) -1);\n/** Reusable Byte constant for zero. */\npublic static final Byte BYTE_ZERO = Byte.valueOf((byte) 0);\n/** Reusable Byte constant for one. */\npublic static final Byte BYTE_ONE = Byte.valueOf((byte) 1);\n/** Reusable Byte constant for minus one. */\npublic static final Byte BYTE_MINUS_ONE = Byte.valueOf((byte) -1);\n/** Reusable Double constant for zero. */\npublic static final Double DOUBLE_ZERO = Double.valueOf(0.0d);\n/** Reusable Double constant for one. */\npublic static final Double DOUBLE_ONE = Double.valueOf(1.0d);\n/** Reusable Double constant for minus one. */\npublic static final Double DOUBLE_MINUS_ONE = Double.valueOf(-1.0d);\n/** Reusable Float constant for zero. */\npublic static final Float FLOAT_ZERO = Float.valueOf(0.0f);\n/** Reusable Float constant for one. */\npublic static final Float FLOAT_ONE = Float.valueOf(1.0f);\n/** Reusable Float constant for minus one. */\npublic static final Float FLOAT_MINUS_ONE = Float.valueOf(-1.0f);\n\n/**\n* <p><code>NumberUtils</code> instances should NOT be constructed in standard programming.\n* Instead, the class should be used as <code>NumberUtils.toInt(\"6\");</code>.</p>\n*\n* <p>This constructor is public to permit tools that require a JavaBean instance\n* to operate.</p>\n*/\npublic NumberUtils() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createNumber(Ljava/lang/String;)Ljava/lang/Number;",
                                    "method_body": "public static Number createNumber(final String str) throws NumberFormatException {\nif (str == null) {\nreturn null;\n}\nif (StringUtils.isBlank(str)) {\nthrow new NumberFormatException(\"A blank string is not a valid number\");\n}\n// Need to deal with all possible hex prefixes here\nfinal String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\nint pfxLen = 0;\nfor(final String pfx : hex_prefixes) {\nif (str.startsWith(pfx)) {\npfxLen += pfx.length();\nbreak;\n}\n}\nif (pfxLen > 0) { // we have a hex number\nfinal int hexDigits = str.length() - pfxLen;\nif (hexDigits > 16) { // too many for Long\nreturn createBigInteger(str);\n}\nif (hexDigits > 8) { // too many for an int\nreturn createLong(str);\n}\nreturn createInteger(str);\n}\nfinal char lastChar = str.charAt(str.length() - 1);\nString mant;\nString dec;\nString exp;\nfinal int decPos = str.indexOf('.');\nfinal int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n// if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n// and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\nint numDecimals = 0; // Check required precision (LANG-693)\nif (decPos > -1) { // there is a decimal point\n\nif (expPos > -1) { // there is an exponent\nif (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\nthrow new NumberFormatException(str + \" is not a valid number.\");\n}\ndec = str.substring(decPos + 1, expPos);\n} else {\ndec = str.substring(decPos + 1);\n}\nmant = str.substring(0, decPos);\nnumDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n} else {\nif (expPos > -1) {\nif (expPos > str.length()) { // prevents double exponent causing IOOBE\nthrow new NumberFormatException(str + \" is not a valid number.\");\n}\nmant = str.substring(0, expPos);\n} else {\nmant = str;\n}\ndec = null;\n}\nif (!Character.isDigit(lastChar) && lastChar != '.') {\nif (expPos > -1 && expPos < str.length() - 1) {\nexp = str.substring(expPos + 1, str.length() - 1);\n} else {\nexp = null;\n}\n//Requesting a specific type..\nfinal String numeric = str.substring(0, str.length() - 1);\nfinal boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\nswitch (lastChar) {\ncase 'l' :\ncase 'L' :\nif (dec == null\n&& exp == null\n&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\ntry {\nreturn createLong(numeric);\n} catch (final NumberFormatException nfe) { // NOPMD\n// Too big for a long\n}\nreturn createBigInteger(numeric);\n\n}\nthrow new NumberFormatException(str + \" is not a valid number.\");\ncase 'f' :\ncase 'F' :\ntry {\nfinal Float f = NumberUtils.createFloat(numeric);\nif (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n//If it's too big for a float or the float value = 0 and the string\n//has non-zeros in it, then float does not have the precision we want\nreturn f;\n}\n\n} catch (final NumberFormatException nfe) { // NOPMD\n// ignore the bad number\n}\n//$FALL-THROUGH$\ncase 'd' :\ncase 'D' :\ntry {\nfinal Double d = NumberUtils.createDouble(numeric);\nif (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\nreturn d;\n}\n} catch (final NumberFormatException nfe) { // NOPMD\n// ignore the bad number\n}\ntry {\nreturn createBigDecimal(numeric);\n} catch (final NumberFormatException e) { // NOPMD\n// ignore the bad number\n}\n//$FALL-THROUGH$\ndefault :\nthrow new NumberFormatException(str + \" is not a valid number.\");\n\n}\n}\n//User doesn't have a preference on the return type, so let's start\n//small and go from there...\nif (expPos > -1 && expPos < str.length() - 1) {\nexp = str.substring(expPos + 1, str.length());\n} else {\nexp = null;\n}\nif (dec == null && exp == null) { // no decimal point and no exponent\n//Must be an Integer, Long, Biginteger\ntry {\nreturn createInteger(str);\n} catch (final NumberFormatException nfe) { // NOPMD\n// ignore the bad number\n}\ntry {\nreturn createLong(str);\n} catch (final NumberFormatException nfe) { // NOPMD\n// ignore the bad number\n}\nreturn createBigInteger(str);\n}\n\n//Must be a Float, Double, BigDecimal\nfinal boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\ntry {\nfinal Float f = createFloat(str);\nif (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\nreturn f;\n}\n} catch (final NumberFormatException nfe) { // NOPMD\n// ignore the bad number\n}\ntry {\nfinal Double d = createDouble(str);\nif (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\nreturn d;\n}\n} catch (final NumberFormatException nfe) { // NOPMD\n// ignore the bad number\n}\n\nreturn createBigDecimal(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:isAllZeros(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean isAllZeros(final String str) {\nif (str == null) {\nreturn true;\n}\nfor (int i = str.length() - 1; i >= 0; i--) {\nif (str.charAt(i) != '0') {\nreturn false;\n}\n}\nreturn str.length() > 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createFloat(Ljava/lang/String;)Ljava/lang/Float;",
                                    "method_body": "public static Float createFloat(final String str) {\nif (str == null) {\nreturn null;\n}\nreturn Float.valueOf(str);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 4,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.text.translate.LookupTranslatorTest.testLang882",
                            "test_body": "44: public void testLang882() throws IOException {\n45: final LookupTranslator lt = new LookupTranslator(new CharSequence[][] { { new StringBuffer(\"one\"), new StringBuffer(\"two\") } });\n46: final StringWriter out = new StringWriter();\n47: final int result = lt.translate(new StringBuffer(\"one\"), 0, out);\n48: assertEquals(\"Incorrect codepoint consumption\", 3, result);\n49: assertEquals(\"Incorrect value\", \"two\", out.toString());\n50: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.LookupTranslator:<init>([[Ljava/lang/CharSequence;)V",
                                    "method_body": "public LookupTranslator(final CharSequence[]... lookup) {\nlookupMap = new HashMap<CharSequence, CharSequence>();\nint _shortest = Integer.MAX_VALUE;\nint _longest = 0;\nif (lookup != null) {\nfor (final CharSequence[] seq : lookup) {\nthis.lookupMap.put(seq[0], seq[1]);\nfinal int sz = seq[0].length();\nif (sz < _shortest) {\n_shortest = sz;\n}\nif (sz > _longest) {\n_longest = sz;\n}\n}\n}\nshortest = _shortest;\nlongest = _longest;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.LookupTranslator:translate(Ljava/lang/CharSequence;ILjava/io/Writer;)I",
                                    "method_body": "public int translate(final CharSequence input, final int index, final Writer out) throws IOException {\nint max = longest;\nif (index + longest > input.length()) {\nmax = input.length() - index;\n}\n// descend so as to get a greedy algorithm\nfor (int i = max; i >= shortest; i--) {\nfinal CharSequence subSeq = input.subSequence(index, index + i);\nfinal CharSequence result = lookupMap.get(subSeq);\nif (result != null) {\nout.write(result.toString());\nreturn i;\n}\n}\nreturn 0;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 5,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.LocaleUtilsTest.testLang865",
                            "test_body": "504: public void testLang865() {\n505: assertValidToLocale(\"_GB\", \"\", \"GB\", \"\");\n506: assertValidToLocale(\"_GB_P\", \"\", \"GB\", \"P\");\n507: assertValidToLocale(\"_GB_POSIX\", \"\", \"GB\", \"POSIX\");\n508: try {\n509: LocaleUtils.toLocale(\"_G\");\n510: fail(\"Must be at least 3 chars if starts with underscore\");\n511: } catch (final IllegalArgumentException iae) {\n512: }\n513: try {\n514: LocaleUtils.toLocale(\"_Gb\");\n515: fail(\"Must be uppercase if starts with underscore\");\n516: } catch (final IllegalArgumentException iae) {\n517: }\n518: try {\n519: LocaleUtils.toLocale(\"_gB\");\n520: fail(\"Must be uppercase if starts with underscore\");\n521: } catch (final IllegalArgumentException iae) {\n522: }\n523: try {\n524: LocaleUtils.toLocale(\"_1B\");\n525: fail(\"Must be letter if starts with underscore\");\n526: } catch (final IllegalArgumentException iae) {\n527: }\n528: try {\n529: LocaleUtils.toLocale(\"_G1\");\n530: fail(\"Must be letter if starts with underscore\");\n531: } catch (final IllegalArgumentException iae) {\n532: }\n533: try {\n534: LocaleUtils.toLocale(\"_GB_\");\n535: fail(\"Must be at least 5 chars if starts with underscore\");\n536: } catch (final IllegalArgumentException iae) {\n537: }\n538: try {\n539: LocaleUtils.toLocale(\"_GBAP\");\n540: fail(\"Must have underscore after the country if starts with underscore and is at least 5 chars\");\n541: } catch (final IllegalArgumentException iae) {\n542: }\n543: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.LocaleUtils:<clinit>()V",
                                    "method_body": "private static final ConcurrentMap<String, List<Locale>> cLanguagesByCountry =\nnew ConcurrentHashMap<String, List<Locale>>();\n\n/** Concurrent map of country locales by language. */\nprivate static final ConcurrentMap<String, List<Locale>> cCountriesByLanguage =\nnew ConcurrentHashMap<String, List<Locale>>();\n\n/**\n* <p>{@code LocaleUtils} instances should NOT be constructed in standard programming."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.LocaleUtils:toLocale(Ljava/lang/String;)Ljava/util/Locale;",
                                    "method_body": "public static Locale toLocale(final String str) {\nif (str == null) {\nreturn null;\n}\nfinal int len = str.length();\nif (len < 2) {\nthrow new IllegalArgumentException(\"Invalid locale format: \" + str);\n}\nfinal char ch0 = str.charAt(0);\nfinal char ch1 = str.charAt(1);\nif (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\nthrow new IllegalArgumentException(\"Invalid locale format: \" + str);\n}\nif (len == 2) {\nreturn new Locale(str);\n}\nif (len < 5) {\nthrow new IllegalArgumentException(\"Invalid locale format: \" + str);\n}\nif (str.charAt(2) != '_') {\nthrow new IllegalArgumentException(\"Invalid locale format: \" + str);\n}\nfinal char ch3 = str.charAt(3);\nif (ch3 == '_') {\nreturn new Locale(str.substring(0, 2), \"\", str.substring(4));\n}\nfinal char ch4 = str.charAt(4);\nif (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\nthrow new IllegalArgumentException(\"Invalid locale format: \" + str);\n}\nif (len == 5) {\nreturn new Locale(str.substring(0, 2), str.substring(3, 5));\n}\nif (len < 7) {\nthrow new IllegalArgumentException(\"Invalid locale format: \" + str);\n}\nif (str.charAt(5) != '_') {\nthrow new IllegalArgumentException(\"Invalid locale format: \" + str);\n}\nreturn new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.LocaleUtils:availableLocaleList()Ljava/util/List;",
                                    "method_body": "public static List<Locale> availableLocaleList() {\nreturn SyncAvoid.AVAILABLE_LOCALE_LIST;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.LocaleUtils:isAvailableLocale(Ljava/util/Locale;)Z",
                                    "method_body": "public static boolean isAvailableLocale(Locale locale) {\nreturn availableLocaleList().contains(locale);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.LocaleUtils$SyncAvoid:<clinit>()V",
                                    "method_body": "private static final List<Locale> AVAILABLE_LOCALE_LIST;\n/** Unmodifiable set of available locales. */\nprivate static final Set<Locale> AVAILABLE_LOCALE_SET;\n\nstatic {\nList<Locale> list = new ArrayList<Locale>(Arrays.asList(Locale.getAvailableLocales()));  // extra safe\nAVAILABLE_LOCALE_LIST = Collections.unmodifiableList(list);\nAVAILABLE_LOCALE_SET = Collections.unmodifiableSet(new HashSet<Locale>(list));\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 6,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.StringUtilsTest.testEscapeSurrogatePairs",
                            "test_body": "2186: public void testEscapeSurrogatePairs() throws Exception {\n2187: assertEquals(\"\\uD83D\\uDE30\", StringEscapeUtils.escapeCsv(\"\\uD83D\\uDE30\"));\n2188: // Examples from https://en.wikipedia.org/wiki/UTF-16\n2189: assertEquals(\"\\uD800\\uDC00\", StringEscapeUtils.escapeCsv(\"\\uD800\\uDC00\"));\n2190: assertEquals(\"\\uD834\\uDD1E\", StringEscapeUtils.escapeCsv(\"\\uD834\\uDD1E\"));\n2191: assertEquals(\"\\uDBFF\\uDFFD\", StringEscapeUtils.escapeCsv(\"\\uDBFF\\uDFFD\"));\n2192: 2193: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:<clinit>()V",
                                    "method_body": "public static final String EMPTY = \"\";\n\n/**\n* Represents a failed index search.\n* @since 2.1\n*/\npublic static final int INDEX_NOT_FOUND = -1;\n\n/**\n* <p>The maximum size to which the padding constant(s) can expand.</p>\n*/\nprivate static final int PAD_LIMIT = 8192;\n\n/**\n* A regex pattern for recognizing blocks of whitespace characters.\n* The apparent convolutedness of the pattern serves the purpose of\n* ignoring \"blocks\" consisting of only a single space:  the pattern\n* is used only to normalize whitespace, condensing \"blocks\" down to a\n* single space, thus matching the same would likely cause a great\n* many noop replacements.\n*/\nprivate static final Pattern WHITESPACE_PATTERN = Pattern.compile(\"(?: \\\\s|[\\\\s&&[^ ]])\\\\s*\");\n\n/**\n* <p>{@code StringUtils} instances should NOT be constructed in"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:containsNone(Ljava/lang/CharSequence;[C)Z",
                                    "method_body": "public static boolean containsNone(CharSequence cs, char... searchChars) {\nif (cs == null || searchChars == null) {\nreturn true;\n}\nint csLen = cs.length();\nint csLast = csLen - 1;\nint searchLen = searchChars.length;\nint searchLast = searchLen - 1;\nfor (int i = 0; i < csLen; i++) {\nchar ch = cs.charAt(i);\nfor (int j = 0; j < searchLen; j++) {\nif (searchChars[j] == ch) {\nif (Character.isHighSurrogate(ch)) {\nif (j == searchLast) {\n// missing low surrogate, fine, like String.indexOf(String)\nreturn false;\n}\nif (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {\nreturn false;\n}\n} else {\n// ch is in the Basic Multilingual Plane\nreturn false;\n}\n}\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:<clinit>()V",
                                    "method_body": "public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n/**\n* An empty immutable {@code Class} array."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:clone([Ljava/lang/Object;)[Ljava/lang/Object;",
                                    "method_body": "public static <T> T[] clone(T[] array) {\nif (array == null) {\nreturn null;\n}\nreturn array.clone();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringEscapeUtils:<clinit>()V",
                                    "method_body": "public static final CharSequenceTranslator ESCAPE_JAVA =\nnew LookupTranslator(\nnew String[][] {\n{\"\\\"\", \"\\\\\\\"\"},\n{\"\\\\\", \"\\\\\\\\\"},\n}).with("
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringEscapeUtils:escapeCsv(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public static final String escapeCsv(String input) {\nreturn ESCAPE_CSV.translate(input);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.CharSequenceTranslator:translate(Ljava/lang/CharSequence;)Ljava/lang/String;",
                                    "method_body": "public abstract int translate(CharSequence input, int index, Writer out) throws IOException;\n\n/**\n* Helper for non-Writer usage.\n* @param input CharSequence to be translated\n* @return String output of translation\n*/\npublic final String translate(CharSequence input) {\nif (input == null) {\nreturn null;\n}\ntry {\nStringWriter writer = new StringWriter(input.length() * 2);\ntranslate(input, writer);\nreturn writer.toString();\n} catch (IOException ioe) {\n// this should never ever happen while writing to a StringWriter\nthrow new RuntimeException(ioe);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.CharSequenceTranslator:translate(Ljava/lang/CharSequence;Ljava/io/Writer;)V",
                                    "method_body": "public final void translate(CharSequence input, Writer out) throws IOException {\nif (out == null) {\nthrow new IllegalArgumentException(\"The Writer must not be null\");\n}\nif (input == null) {\nreturn;\n}\nint pos = 0;\nint len = input.length();\nwhile (pos < len) {\nint consumed = translate(input, pos, out);\nif (consumed == 0) {\nchar[] c = Character.toChars(Character.codePointAt(input, pos));\nout.write(c);\npos+= c.length;\ncontinue;\n}\n//          // contract with translators is that they have to understand codepoints\n//          // and they just took care of a surrogate pair\nfor (int pt = 0; pt < consumed; pt++) {\npos += Character.charCount(Character.codePointAt(input, pos));\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.CharSequenceTranslator:with([Lorg/apache/commons/lang3/text/translate/CharSequenceTranslator;)Lorg/apache/commons/lang3/text/translate/CharSequenceTranslator;",
                                    "method_body": "public final CharSequenceTranslator with(CharSequenceTranslator... translators) {\nCharSequenceTranslator[] newArray = new CharSequenceTranslator[translators.length + 1];\nnewArray[0] = this;\nSystem.arraycopy(translators, 0, newArray, 1, translators.length);\nreturn new AggregateTranslator(newArray);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.LookupTranslator:<init>([[Ljava/lang/CharSequence;)V",
                                    "method_body": "public LookupTranslator(CharSequence[]... lookup) {\nlookupMap = new HashMap<CharSequence, CharSequence>();\nint _shortest = Integer.MAX_VALUE;\nint _longest = 0;\nif (lookup != null) {\nfor (CharSequence[] seq : lookup) {\nthis.lookupMap.put(seq[0], seq[1]);\nint sz = seq[0].length();\nif (sz < _shortest) {\n_shortest = sz;\n}\nif (sz > _longest) {\n_longest = sz;\n}\n}\n}\nshortest = _shortest;\nlongest = _longest;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:<clinit>()V",
                                    "method_body": "private static final String[][] ISO8859_1_ESCAPE = {\n{\"\\u00A0\", \"&nbsp;\"}, // non-breaking space\n{\"\\u00A1\", \"&iexcl;\"}, // inverted exclamation mark\n{\"\\u00A2\", \"&cent;\"}, // cent sign\n{\"\\u00A3\", \"&pound;\"}, // pound sign\n{\"\\u00A4\", \"&curren;\"}, // currency sign\n{\"\\u00A5\", \"&yen;\"}, // yen sign = yuan sign\n{\"\\u00A6\", \"&brvbar;\"}, // broken bar = broken vertical bar\n{\"\\u00A7\", \"&sect;\"}, // section sign\n{\"\\u00A8\", \"&uml;\"}, // diaeresis = spacing diaeresis\n{\"\\u00A9\", \"&copy;\"}, // \u00a9 - copyright sign\n{\"\\u00AA\", \"&ordf;\"}, // feminine ordinal indicator\n{\"\\u00AB\", \"&laquo;\"}, // left-pointing double angle quotation mark = left pointing guillemet\n{\"\\u00AC\", \"&not;\"}, // not sign\n{\"\\u00AD\", \"&shy;\"}, // soft hyphen = discretionary hyphen\n{\"\\u00AE\", \"&reg;\"}, // \u00ae - registered trademark sign\n{\"\\u00AF\", \"&macr;\"}, // macron = spacing macron = overline = APL overbar\n{\"\\u00B0\", \"&deg;\"}, // degree sign\n{\"\\u00B1\", \"&plusmn;\"}, // plus-minus sign = plus-or-minus sign\n{\"\\u00B2\", \"&sup2;\"}, // superscript two = superscript digit two = squared\n{\"\\u00B3\", \"&sup3;\"}, // superscript three = superscript digit three = cubed\n{\"\\u00B4\", \"&acute;\"}, // acute accent = spacing acute\n{\"\\u00B5\", \"&micro;\"}, // micro sign\n{\"\\u00B6\", \"&para;\"}, // pilcrow sign = paragraph sign\n{\"\\u00B7\", \"&middot;\"}, // middle dot = Georgian comma = Greek middle dot\n{\"\\u00B8\", \"&cedil;\"}, // cedilla = spacing cedilla\n{\"\\u00B9\", \"&sup1;\"}, // superscript one = superscript digit one\n{\"\\u00BA\", \"&ordm;\"}, // masculine ordinal indicator\n{\"\\u00BB\", \"&raquo;\"}, // right-pointing double angle quotation mark = right pointing guillemet\n{\"\\u00BC\", \"&frac14;\"}, // vulgar fraction one quarter = fraction one quarter\n{\"\\u00BD\", \"&frac12;\"}, // vulgar fraction one half = fraction one half\n{\"\\u00BE\", \"&frac34;\"}, // vulgar fraction three quarters = fraction three quarters\n{\"\\u00BF\", \"&iquest;\"}, // inverted question mark = turned question mark\n{\"\\u00C0\", \"&Agrave;\"}, // \u00c0 - uppercase A, grave accent\n{\"\\u00C1\", \"&Aacute;\"}, // \u00c1 - uppercase A, acute accent\n{\"\\u00C2\", \"&Acirc;\"}, // \u00c2 - uppercase A, circumflex accent\n{\"\\u00C3\", \"&Atilde;\"}, // \u00c3 - uppercase A, tilde\n{\"\\u00C4\", \"&Auml;\"}, // \u00c4 - uppercase A, umlaut\n{\"\\u00C5\", \"&Aring;\"}, // \u00c5 - uppercase A, ring\n{\"\\u00C6\", \"&AElig;\"}, // \u00c6 - uppercase AE\n{\"\\u00C7\", \"&Ccedil;\"}, // \u00c7 - uppercase C, cedilla\n{\"\\u00C8\", \"&Egrave;\"}, // \u00c8 - uppercase E, grave accent\n{\"\\u00C9\", \"&Eacute;\"}, // \u00c9 - uppercase E, acute accent\n{\"\\u00CA\", \"&Ecirc;\"}, // \u00ca - uppercase E, circumflex accent\n{\"\\u00CB\", \"&Euml;\"}, // \u00cb - uppercase E, umlaut\n{\"\\u00CC\", \"&Igrave;\"}, // \u00cc - uppercase I, grave accent\n{\"\\u00CD\", \"&Iacute;\"}, // \u00cd - uppercase I, acute accent\n{\"\\u00CE\", \"&Icirc;\"}, // \u00ce - uppercase I, circumflex accent\n{\"\\u00CF\", \"&Iuml;\"}, // \u00cf - uppercase I, umlaut\n{\"\\u00D0\", \"&ETH;\"}, // \u00d0 - uppercase Eth, Icelandic\n{\"\\u00D1\", \"&Ntilde;\"}, // \u00d1 - uppercase N, tilde\n{\"\\u00D2\", \"&Ograve;\"}, // \u00d2 - uppercase O, grave accent\n{\"\\u00D3\", \"&Oacute;\"}, // \u00d3 - uppercase O, acute accent\n{\"\\u00D4\", \"&Ocirc;\"}, // \u00d4 - uppercase O, circumflex accent\n{\"\\u00D5\", \"&Otilde;\"}, // \u00d5 - uppercase O, tilde\n{\"\\u00D6\", \"&Ouml;\"}, // \u00d6 - uppercase O, umlaut\n{\"\\u00D7\", \"&times;\"}, // multiplication sign\n{\"\\u00D8\", \"&Oslash;\"}, // \u00d8 - uppercase O, slash\n{\"\\u00D9\", \"&Ugrave;\"}, // \u00d9 - uppercase U, grave accent\n{\"\\u00DA\", \"&Uacute;\"}, // \u00da - uppercase U, acute accent\n{\"\\u00DB\", \"&Ucirc;\"}, // \u00db - uppercase U, circumflex accent\n{\"\\u00DC\", \"&Uuml;\"}, // \u00dc - uppercase U, umlaut\n{\"\\u00DD\", \"&Yacute;\"}, // \u00dd - uppercase Y, acute accent\n{\"\\u00DE\", \"&THORN;\"}, // \u00de - uppercase THORN, Icelandic\n{\"\\u00DF\", \"&szlig;\"}, // \u00df - lowercase sharps, German\n{\"\\u00E0\", \"&agrave;\"}, // \u00e0 - lowercase a, grave accent\n{\"\\u00E1\", \"&aacute;\"}, // \u00e1 - lowercase a, acute accent\n{\"\\u00E2\", \"&acirc;\"}, // \u00e2 - lowercase a, circumflex accent\n{\"\\u00E3\", \"&atilde;\"}, // \u00e3 - lowercase a, tilde\n{\"\\u00E4\", \"&auml;\"}, // \u00e4 - lowercase a, umlaut\n{\"\\u00E5\", \"&aring;\"}, // \u00e5 - lowercase a, ring\n{\"\\u00E6\", \"&aelig;\"}, // \u00e6 - lowercase ae\n{\"\\u00E7\", \"&ccedil;\"}, // \u00e7 - lowercase c, cedilla\n{\"\\u00E8\", \"&egrave;\"}, // \u00e8 - lowercase e, grave accent\n{\"\\u00E9\", \"&eacute;\"}, // \u00e9 - lowercase e, acute accent\n{\"\\u00EA\", \"&ecirc;\"}, // \u00ea - lowercase e, circumflex accent\n{\"\\u00EB\", \"&euml;\"}, // \u00eb - lowercase e, umlaut\n{\"\\u00EC\", \"&igrave;\"}, // \u00ec - lowercase i, grave accent\n{\"\\u00ED\", \"&iacute;\"}, // \u00ed - lowercase i, acute accent\n{\"\\u00EE\", \"&icirc;\"}, // \u00ee - lowercase i, circumflex accent\n{\"\\u00EF\", \"&iuml;\"}, // \u00ef - lowercase i, umlaut\n{\"\\u00F0\", \"&eth;\"}, // \u00f0 - lowercase eth, Icelandic\n{\"\\u00F1\", \"&ntilde;\"}, // \u00f1 - lowercase n, tilde\n{\"\\u00F2\", \"&ograve;\"}, // \u00f2 - lowercase o, grave accent\n{\"\\u00F3\", \"&oacute;\"}, // \u00f3 - lowercase o, acute accent\n{\"\\u00F4\", \"&ocirc;\"}, // \u00f4 - lowercase o, circumflex accent\n{\"\\u00F5\", \"&otilde;\"}, // \u00f5 - lowercase o, tilde\n{\"\\u00F6\", \"&ouml;\"}, // \u00f6 - lowercase o, umlaut\n{\"\\u00F7\", \"&divide;\"}, // division sign\n{\"\\u00F8\", \"&oslash;\"}, // \u00f8 - lowercase o, slash\n{\"\\u00F9\", \"&ugrave;\"}, // \u00f9 - lowercase u, grave accent\n{\"\\u00FA\", \"&uacute;\"}, // \u00fa - lowercase u, acute accent\n{\"\\u00FB\", \"&ucirc;\"}, // \u00fb - lowercase u, circumflex accent\n{\"\\u00FC\", \"&uuml;\"}, // \u00fc - lowercase u, umlaut\n{\"\\u00FD\", \"&yacute;\"}, // \u00fd - lowercase y, acute accent\n{\"\\u00FE\", \"&thorn;\"}, // \u00fe - lowercase thorn, Icelandic\n{\"\\u00FF\", \"&yuml;\"}, // \u00ff - lowercase y, umlaut\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:ISO8859_1_ESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] ISO8859_1_ESCAPE() { return ISO8859_1_ESCAPE.clone(); }\npublic static String[][] ISO8859_1_ESCAPE() { return ISO8859_1_ESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:ISO8859_1_UNESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] ISO8859_1_UNESCAPE() { return ISO8859_1_UNESCAPE.clone(); }\npublic static String[][] ISO8859_1_UNESCAPE() { return ISO8859_1_UNESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:HTML40_EXTENDED_ESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] HTML40_EXTENDED_ESCAPE() { return HTML40_EXTENDED_ESCAPE.clone(); }\npublic static String[][] HTML40_EXTENDED_ESCAPE() { return HTML40_EXTENDED_ESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:HTML40_EXTENDED_UNESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] HTML40_EXTENDED_UNESCAPE() { return HTML40_EXTENDED_UNESCAPE.clone(); }\npublic static String[][] HTML40_EXTENDED_UNESCAPE() { return HTML40_EXTENDED_UNESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:BASIC_ESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] BASIC_ESCAPE() { return BASIC_ESCAPE.clone(); }\npublic static String[][] BASIC_ESCAPE() { return BASIC_ESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:BASIC_UNESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] BASIC_UNESCAPE() { return BASIC_UNESCAPE.clone(); }\npublic static String[][] BASIC_UNESCAPE() { return BASIC_UNESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:APOS_ESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] APOS_ESCAPE() { return APOS_ESCAPE.clone(); }\npublic static String[][] APOS_ESCAPE() { return APOS_ESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:APOS_UNESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] APOS_UNESCAPE() { return APOS_UNESCAPE.clone(); }\npublic static String[][] APOS_UNESCAPE() { return APOS_UNESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:JAVA_CTRL_CHARS_ESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] JAVA_CTRL_CHARS_ESCAPE() { return JAVA_CTRL_CHARS_ESCAPE.clone(); }\npublic static String[][] JAVA_CTRL_CHARS_ESCAPE() { return JAVA_CTRL_CHARS_ESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:JAVA_CTRL_CHARS_UNESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] JAVA_CTRL_CHARS_UNESCAPE() { return JAVA_CTRL_CHARS_UNESCAPE.clone(); }\npublic static String[][] JAVA_CTRL_CHARS_UNESCAPE() { return JAVA_CTRL_CHARS_UNESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:invert([[Ljava/lang/String;)[[Ljava/lang/String;",
                                    "method_body": "public static String[][] invert(String[][] array) {\nString[][] newarray = new String[array.length][2];\nfor(int i = 0; i<array.length; i++) {\nnewarray[i][0] = array[i][1];\nnewarray[i][1] = array[i][0];\n}\nreturn newarray;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.AggregateTranslator:<init>([Lorg/apache/commons/lang3/text/translate/CharSequenceTranslator;)V",
                                    "method_body": "public AggregateTranslator(CharSequenceTranslator... translators) {\nthis.translators = ArrayUtils.clone(translators);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.UnicodeEscaper:<init>(IIZ)V",
                                    "method_body": "private UnicodeEscaper(int below, int above, boolean between) {\nthis.below = below;\nthis.above = above;\nthis.between = between;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.UnicodeEscaper:outsideOf(II)Lorg/apache/commons/lang3/text/translate/UnicodeEscaper;",
                                    "method_body": "public static UnicodeEscaper outsideOf(int codepointLow, int codepointHigh) {\nreturn new UnicodeEscaper(codepointLow, codepointHigh, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringEscapeUtils$CsvEscaper:<init>()V",
                                    "method_body": "public static final CharSequenceTranslator ESCAPE_CSV = new CsvEscaper();\n\n// TODO: Create a parent class - 'SinglePassTranslator' ?\n//       It would handle the index checking + length returning,\n//       and could also have an optimization check method.\nstatic class CsvEscaper extends CharSequenceTranslator {\n\nprivate static final char CSV_DELIMITER = ',';\nprivate static final char CSV_QUOTE = '\"';\nprivate static final String CSV_QUOTE_STR = String.valueOf(CSV_QUOTE);\nprivate static final char[] CSV_SEARCH_CHARS =\nnew char[] {CSV_DELIMITER, CSV_QUOTE, CharUtils.CR, CharUtils.LF};\n\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n\nif(index != 0) {\nthrow new IllegalStateException(\"CsvEscaper should never reach the [1] index\");\n}\n\nif (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) {\nout.write(input.toString());\n} else {\nout.write(CSV_QUOTE);\nout.write(StringUtils.replace(input.toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\nout.write(CSV_QUOTE);\n}\nreturn input.length();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringEscapeUtils$CsvEscaper:<clinit>()V",
                                    "method_body": "public static final CharSequenceTranslator ESCAPE_CSV = new CsvEscaper();\n\n// TODO: Create a parent class - 'SinglePassTranslator' ?\n//       It would handle the index checking + length returning,\n//       and could also have an optimization check method.\nstatic class CsvEscaper extends CharSequenceTranslator {\n\nprivate static final char CSV_DELIMITER = ',';\nprivate static final char CSV_QUOTE = '\"';\nprivate static final String CSV_QUOTE_STR = String.valueOf(CSV_QUOTE);\nprivate static final char[] CSV_SEARCH_CHARS =\nnew char[] {CSV_DELIMITER, CSV_QUOTE, CharUtils.CR, CharUtils.LF};\n\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n\nif(index != 0) {\nthrow new IllegalStateException(\"CsvEscaper should never reach the [1] index\");\n}\n\nif (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) {\nout.write(input.toString());\n} else {\nout.write(CSV_QUOTE);\nout.write(StringUtils.replace(input.toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\nout.write(CSV_QUOTE);\n}\nreturn input.length();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringEscapeUtils$CsvEscaper:translate(Ljava/lang/CharSequence;ILjava/io/Writer;)I",
                                    "method_body": "public int translate(CharSequence input, int index, Writer out) throws IOException {\n\nif(index != 0) {\nthrow new IllegalStateException(\"CsvEscaper should never reach the [1] index\");\n}\n\nif (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) {\nout.write(input.toString());\n} else {\nout.write(CSV_QUOTE);\nout.write(StringUtils.replace(input.toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\nout.write(CSV_QUOTE);\n}\nreturn input.length();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.OctalUnescaper:<clinit>()V",
                                    "method_body": "private static int OCTAL_MAX = 377;\n\n/**\n* {@inheritDoc}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.NumericEntityUnescaper:<init>([Lorg/apache/commons/lang3/text/translate/NumericEntityUnescaper$OPTION;)V",
                                    "method_body": "public NumericEntityUnescaper(OPTION... options) {\nif(options.length > 0) {\nthis.options = EnumSet.copyOf(Arrays.asList(options));\n} else {\nthis.options = EnumSet.copyOf(Arrays.asList(new OPTION[] { OPTION.semiColonRequired }));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringEscapeUtils$CsvUnescaper:<init>()V",
                                    "method_body": "public static final CharSequenceTranslator UNESCAPE_CSV = new CsvUnescaper();\n\nstatic class CsvUnescaper extends CharSequenceTranslator {\n\nprivate static final char CSV_DELIMITER = ',';\nprivate static final char CSV_QUOTE = '\"';\nprivate static final String CSV_QUOTE_STR = String.valueOf(CSV_QUOTE);\nprivate static final char[] CSV_SEARCH_CHARS =\nnew char[] {CSV_DELIMITER, CSV_QUOTE, CharUtils.CR, CharUtils.LF};\n\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n\nif(index != 0) {\nthrow new IllegalStateException(\"CsvUnescaper should never reach the [1] index\");\n}\n\nif ( input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE ) {\nout.write(input.toString());\nreturn input.length();\n}\n\n// strip quotes\nString quoteless = input.subSequence(1, input.length() - 1).toString();\n\nif ( StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS) ) {\n// deal with escaped quotes; ie) \"\"\nout.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n} else {\nout.write(input.toString());\n}\nreturn input.length();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringEscapeUtils$CsvUnescaper:<clinit>()V",
                                    "method_body": "public static final CharSequenceTranslator UNESCAPE_CSV = new CsvUnescaper();\n\nstatic class CsvUnescaper extends CharSequenceTranslator {\n\nprivate static final char CSV_DELIMITER = ',';\nprivate static final char CSV_QUOTE = '\"';\nprivate static final String CSV_QUOTE_STR = String.valueOf(CSV_QUOTE);\nprivate static final char[] CSV_SEARCH_CHARS =\nnew char[] {CSV_DELIMITER, CSV_QUOTE, CharUtils.CR, CharUtils.LF};\n\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n\nif(index != 0) {\nthrow new IllegalStateException(\"CsvUnescaper should never reach the [1] index\");\n}\n\nif ( input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE ) {\nout.write(input.toString());\nreturn input.length();\n}\n\n// strip quotes\nString quoteless = input.subSequence(1, input.length() - 1).toString();\n\nif ( StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS) ) {\n// deal with escaped quotes; ie) \"\"\nout.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n} else {\nout.write(input.toString());\n}\nreturn input.length();\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 7,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.math.NumberUtilsTest.testCreateNumber",
                            "test_body": "185: public void testCreateNumber() {\n186: // a lot of things can go wrong\n187: assertEquals(\"createNumber(String) 1 failed\", Float.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5\"));\n188: assertEquals(\"createNumber(String) 2 failed\", Integer.valueOf(\"12345\"), NumberUtils.createNumber(\"12345\"));\n189: assertEquals(\"createNumber(String) 3 failed\", Double.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5D\"));\n190: assertEquals(\"createNumber(String) 3 failed\", Double.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5d\"));\n191: assertEquals(\"createNumber(String) 4 failed\", Float.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5F\"));\n192: assertEquals(\"createNumber(String) 4 failed\", Float.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5f\"));\n193: assertEquals(\"createNumber(String) 5 failed\", Long.valueOf(Integer.MAX_VALUE + 1L), NumberUtils.createNumber(\"\"\n194: + (Integer.MAX_VALUE + 1L)));\n195: assertEquals(\"createNumber(String) 6 failed\", Long.valueOf(12345), NumberUtils.createNumber(\"12345L\"));\n196: assertEquals(\"createNumber(String) 6 failed\", Long.valueOf(12345), NumberUtils.createNumber(\"12345l\"));\n197: assertEquals(\"createNumber(String) 7 failed\", Float.valueOf(\"-1234.5\"), NumberUtils.createNumber(\"-1234.5\"));\n198: assertEquals(\"createNumber(String) 8 failed\", Integer.valueOf(\"-12345\"), NumberUtils.createNumber(\"-12345\"));\n199: assertTrue(\"createNumber(String) 9a failed\", 0xFADE == NumberUtils.createNumber(\"0xFADE\").intValue());\n200: assertTrue(\"createNumber(String) 9b failed\", 0xFADE == NumberUtils.createNumber(\"0Xfade\").intValue());\n201: assertTrue(\"createNumber(String) 10a failed\", -0xFADE == NumberUtils.createNumber(\"-0xFADE\").intValue());\n202: assertTrue(\"createNumber(String) 10b failed\", -0xFADE == NumberUtils.createNumber(\"-0Xfade\").intValue());\n203: assertEquals(\"createNumber(String) 11 failed\", Double.valueOf(\"1.1E200\"), NumberUtils.createNumber(\"1.1E200\"));\n204: assertEquals(\"createNumber(String) 12 failed\", Float.valueOf(\"1.1E20\"), NumberUtils.createNumber(\"1.1E20\"));\n205: assertEquals(\"createNumber(String) 13 failed\", Double.valueOf(\"-1.1E200\"), NumberUtils.createNumber(\"-1.1E200\"));\n206: assertEquals(\"createNumber(String) 14 failed\", Double.valueOf(\"1.1E-200\"), NumberUtils.createNumber(\"1.1E-200\"));\n207: assertEquals(\"createNumber(null) failed\", null, NumberUtils.createNumber(null));\n208: assertEquals(\"createNumber(String) failed\", new BigInteger(\"12345678901234567890\"), NumberUtils\n209: .createNumber(\"12345678901234567890L\"));\n210: 211: // jdk 1.2 doesn't support this. unsure about jdk 1.2.2\n212: if (SystemUtils.isJavaVersionAtLeast(JAVA_1_3)) {\n213: assertEquals(\"createNumber(String) 15 failed\", new BigDecimal(\"1.1E-700\"), NumberUtils\n214: .createNumber(\"1.1E-700F\"));\n215: }\n216: assertEquals(\"createNumber(String) 16 failed\", Long.valueOf(\"10\" + Integer.MAX_VALUE), NumberUtils\n217: .createNumber(\"10\" + Integer.MAX_VALUE + \"L\"));\n218: assertEquals(\"createNumber(String) 17 failed\", Long.valueOf(\"10\" + Integer.MAX_VALUE), NumberUtils\n219: .createNumber(\"10\" + Integer.MAX_VALUE));\n220: assertEquals(\"createNumber(String) 18 failed\", new BigInteger(\"10\" + Long.MAX_VALUE), NumberUtils\n221: .createNumber(\"10\" + Long.MAX_VALUE));\n222: 223: // LANG-521\n224: assertEquals(\"createNumber(String) LANG-521 failed\", Float.valueOf(\"2.\"), NumberUtils.createNumber(\"2.\"));\n225: 226: // LANG-638\n227: assertFalse(\"createNumber(String) succeeded\", checkCreateNumber(\"1eE\"));\n228: 229: // LANG-693\n230: assertEquals(\"createNumber(String) LANG-693 failed\", Double.valueOf(Double.MAX_VALUE), NumberUtils\n231: .createNumber(\"\" + Double.MAX_VALUE));\n232: 233: // LANG-822\n234: // ensure that the underlying negative number would create a BigDecimal\n235: final Number bigNum = NumberUtils.createNumber(\"-1.1E-700F\");\n236: assertEquals(BigDecimal.class,bigNum.getClass());\n237: assertNotNull(bigNum);\n238: 239: // Check that the code fails to create a valid number when preceeded by -- rather than -\n240: try {\n241: NumberUtils.createNumber(\"--1.1E-700F\");\n242: fail(\"Expected NumberFormatException\");\n243: } catch (NumberFormatException nfe) {\n244: // expected\n245: }\n246: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:<clinit>()V",
                                    "method_body": "public static final String EMPTY = \"\";\n\n/**\n* Represents a failed index search.\n* @since 2.1\n*/\npublic static final int INDEX_NOT_FOUND = -1;\n\n/**\n* <p>The maximum size to which the padding constant(s) can expand.</p>\n*/\nprivate static final int PAD_LIMIT = 8192;\n\n/**\n* A regex pattern for recognizing blocks of whitespace characters.\n* The apparent convolutedness of the pattern serves the purpose of\n* ignoring \"blocks\" consisting of only a single space:  the pattern\n* is used only to normalize whitespace, condensing \"blocks\" down to a\n* single space, thus matching the same would likely cause a great\n* many noop replacements.\n*/\nprivate static final Pattern WHITESPACE_PATTERN = Pattern.compile(\"(?: \\\\s|[\\\\s&&[^ ]])\\\\s*\");\n\n/**\n* <p>{@code StringUtils} instances should NOT be constructed in"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:isEmpty(Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean isEmpty(CharSequence cs) {\nreturn cs == null || cs.length() == 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:isBlank(Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean isBlank(CharSequence cs) {\nint strLen;\nif (cs == null || (strLen = cs.length()) == 0) {\nreturn true;\n}\nfor (int i = 0; i < strLen; i++) {\nif (Character.isWhitespace(cs.charAt(i)) == false) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.JavaVersion:<init>(Ljava/lang/String;IFLjava/lang/String;)V",
                                    "method_body": "JavaVersion(final float value, final String name) {\nthis.value = value;\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.JavaVersion:atLeast(Lorg/apache/commons/lang3/JavaVersion;)Z",
                                    "method_body": "public boolean atLeast(JavaVersion requiredVersion) {\nreturn this.value >= requiredVersion.value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.JavaVersion:get(Ljava/lang/String;)Lorg/apache/commons/lang3/JavaVersion;",
                                    "method_body": "static JavaVersion get(final String nom) {\nif (\"0.9\".equals(nom)) {\nreturn JAVA_0_9;\n} else if (\"1.1\".equals(nom)) {\nreturn JAVA_1_1;\n} else if (\"1.2\".equals(nom)) {\nreturn JAVA_1_2;\n} else if (\"1.3\".equals(nom)) {\nreturn JAVA_1_3;\n} else if (\"1.4\".equals(nom)) {\nreturn JAVA_1_4;\n} else if (\"1.5\".equals(nom)) {\nreturn JAVA_1_5;\n} else if (\"1.6\".equals(nom)) {\nreturn JAVA_1_6;\n} else if (\"1.7\".equals(nom)) {\nreturn JAVA_1_7;\n} else if (\"1.8\".equals(nom)) {\nreturn JAVA_1_8;\n} else {\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>\n* The {@code file.encoding} System Property."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nreturn isJavaVersionMatch(JAVA_SPECIFICATION_VERSION, versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nreturn isOSMatch(OS_NAME, OS_VERSION, osNamePrefix, osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatchesName(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatchesName(String osNamePrefix) {\nreturn isOSNameMatch(OS_NAME, osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\");\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:isJavaVersionAtLeast(Lorg/apache/commons/lang3/JavaVersion;)Z",
                                    "method_body": "public static boolean isJavaVersionAtLeast(JavaVersion requiredVersion) {\nreturn JAVA_SPECIFICATION_VERSION_AS_ENUM.atLeast(requiredVersion);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:isJavaVersionMatch(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "static boolean isJavaVersionMatch(String version, String versionPrefix) {\nif (version == null) {\nreturn false;\n}\nreturn version.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:isOSMatch(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "static boolean isOSMatch(String osName, String osVersion, String osNamePrefix, String osVersionPrefix) {\nif (osName == null || osVersion == null) {\nreturn false;\n}\nreturn osName.startsWith(osNamePrefix) && osVersion.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:isOSNameMatch(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "static boolean isOSNameMatch(String osName, String osNamePrefix) {\nif (osName == null) {\nreturn false;\n}\nreturn osName.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:<clinit>()V",
                                    "method_body": "public static final Long LONG_ZERO = Long.valueOf(0L);\n/** Reusable Long constant for one. */\npublic static final Long LONG_ONE = Long.valueOf(1L);\n/** Reusable Long constant for minus one. */\npublic static final Long LONG_MINUS_ONE = Long.valueOf(-1L);\n/** Reusable Integer constant for zero. */\npublic static final Integer INTEGER_ZERO = Integer.valueOf(0);\n/** Reusable Integer constant for one. */\npublic static final Integer INTEGER_ONE = Integer.valueOf(1);\n/** Reusable Integer constant for minus one. */\npublic static final Integer INTEGER_MINUS_ONE = Integer.valueOf(-1);\n/** Reusable Short constant for zero. */\npublic static final Short SHORT_ZERO = Short.valueOf((short) 0);\n/** Reusable Short constant for one. */\npublic static final Short SHORT_ONE = Short.valueOf((short) 1);\n/** Reusable Short constant for minus one. */\npublic static final Short SHORT_MINUS_ONE = Short.valueOf((short) -1);\n/** Reusable Byte constant for zero. */\npublic static final Byte BYTE_ZERO = Byte.valueOf((byte) 0);\n/** Reusable Byte constant for one. */\npublic static final Byte BYTE_ONE = Byte.valueOf((byte) 1);\n/** Reusable Byte constant for minus one. */\npublic static final Byte BYTE_MINUS_ONE = Byte.valueOf((byte) -1);\n/** Reusable Double constant for zero. */\npublic static final Double DOUBLE_ZERO = Double.valueOf(0.0d);\n/** Reusable Double constant for one. */\npublic static final Double DOUBLE_ONE = Double.valueOf(1.0d);\n/** Reusable Double constant for minus one. */\npublic static final Double DOUBLE_MINUS_ONE = Double.valueOf(-1.0d);\n/** Reusable Float constant for zero. */\npublic static final Float FLOAT_ZERO = Float.valueOf(0.0f);\n/** Reusable Float constant for one. */\npublic static final Float FLOAT_ONE = Float.valueOf(1.0f);\n/** Reusable Float constant for minus one. */\npublic static final Float FLOAT_MINUS_ONE = Float.valueOf(-1.0f);\n\n/**\n* <p><code>NumberUtils</code> instances should NOT be constructed in standard programming.\n* Instead, the class should be used as <code>NumberUtils.toInt(\"6\");</code>.</p>\n*\n* <p>This constructor is public to permit tools that require a JavaBean instance\n* to operate.</p>\n*/\npublic NumberUtils() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createNumber(Ljava/lang/String;)Ljava/lang/Number;",
                                    "method_body": "public static Number createNumber(String str) throws NumberFormatException {\nif (str == null) {\nreturn null;\n}\nif (StringUtils.isBlank(str)) {\nthrow new NumberFormatException(\"A blank string is not a valid number\");\n}\nif (str.startsWith(\"--\")) {\nreturn null;\n}\nif (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\nint hexDigits = str.length() - 2; // drop 0x\nif (str.startsWith(\"-\")) { // drop -\nhexDigits--;\n}\nif (hexDigits > 8) { // too many for an int\nreturn createLong(str);\n}\nreturn createInteger(str);\n}\nchar lastChar = str.charAt(str.length() - 1);\nString mant;\nString dec;\nString exp;\nint decPos = str.indexOf('.');\nint expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\nif (decPos > -1) {\n\nif (expPos > -1) {\nif (expPos < decPos || expPos > str.length()) {\nthrow new NumberFormatException(str + \" is not a valid number.\");\n}\ndec = str.substring(decPos + 1, expPos);\n} else {\ndec = str.substring(decPos + 1);\n}\nmant = str.substring(0, decPos);\n} else {\nif (expPos > -1) {\nif (expPos > str.length()) {\nthrow new NumberFormatException(str + \" is not a valid number.\");\n}\nmant = str.substring(0, expPos);\n} else {\nmant = str;\n}\ndec = null;\n}\nif (!Character.isDigit(lastChar) && lastChar != '.') {\nif (expPos > -1 && expPos < str.length() - 1) {\nexp = str.substring(expPos + 1, str.length() - 1);\n} else {\nexp = null;\n}\n//Requesting a specific type..\nString numeric = str.substring(0, str.length() - 1);\nboolean allZeros = isAllZeros(mant) && isAllZeros(exp);\nswitch (lastChar) {\ncase 'l' :\ncase 'L' :\nif (dec == null\n&& exp == null\n&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\ntry {\nreturn createLong(numeric);\n} catch (NumberFormatException nfe) { // NOPMD\n// Too big for a long\n}\nreturn createBigInteger(numeric);\n\n}\nthrow new NumberFormatException(str + \" is not a valid number.\");\ncase 'f' :\ncase 'F' :\ntry {\nFloat f = NumberUtils.createFloat(numeric);\nif (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n//If it's too big for a float or the float value = 0 and the string\n//has non-zeros in it, then float does not have the precision we want\nreturn f;\n}\n\n} catch (NumberFormatException nfe) { // NOPMD\n// ignore the bad number\n}\n//$FALL-THROUGH$\ncase 'd' :\ncase 'D' :\ntry {\nDouble d = NumberUtils.createDouble(numeric);\nif (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\nreturn d;\n}\n} catch (NumberFormatException nfe) { // NOPMD\n// ignore the bad number\n}\ntry {\nreturn createBigDecimal(numeric);\n} catch (NumberFormatException e) { // NOPMD\n// ignore the bad number\n}\n//$FALL-THROUGH$\ndefault :\nthrow new NumberFormatException(str + \" is not a valid number.\");\n\n}\n} else {\n//User doesn't have a preference on the return type, so let's start\n//small and go from there...\nif (expPos > -1 && expPos < str.length() - 1) {\nexp = str.substring(expPos + 1, str.length());\n} else {\nexp = null;\n}\nif (dec == null && exp == null) {\n//Must be an int,long,bigint\ntry {\nreturn createInteger(str);\n} catch (NumberFormatException nfe) { // NOPMD\n// ignore the bad number\n}\ntry {\nreturn createLong(str);\n} catch (NumberFormatException nfe) { // NOPMD\n// ignore the bad number\n}\nreturn createBigInteger(str);\n\n} else {\n//Must be a float,double,BigDec\nboolean allZeros = isAllZeros(mant) && isAllZeros(exp);\ntry {\nFloat f = createFloat(str);\nif (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\nreturn f;\n}\n} catch (NumberFormatException nfe) { // NOPMD\n// ignore the bad number\n}\ntry {\nDouble d = createDouble(str);\nif (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\nreturn d;\n}\n} catch (NumberFormatException nfe) { // NOPMD\n// ignore the bad number\n}\n\nreturn createBigDecimal(str);\n\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:isAllZeros(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean isAllZeros(String str) {\nif (str == null) {\nreturn true;\n}\nfor (int i = str.length() - 1; i >= 0; i--) {\nif (str.charAt(i) != '0') {\nreturn false;\n}\n}\nreturn str.length() > 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createFloat(Ljava/lang/String;)Ljava/lang/Float;",
                                    "method_body": "public static Float createFloat(String str) {\nif (str == null) {\nreturn null;\n}\nreturn Float.valueOf(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createDouble(Ljava/lang/String;)Ljava/lang/Double;",
                                    "method_body": "public static Double createDouble(String str) {\nif (str == null) {\nreturn null;\n}\nreturn Double.valueOf(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createInteger(Ljava/lang/String;)Ljava/lang/Integer;",
                                    "method_body": "public static Integer createInteger(String str) {\nif (str == null) {\nreturn null;\n}\n// decode() handles 0xAABD and 0777 (hex and octal) as well.\nreturn Integer.decode(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createLong(Ljava/lang/String;)Ljava/lang/Long;",
                                    "method_body": "public static Long createLong(String str) {\nif (str == null) {\nreturn null;\n}\nreturn Long.decode(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createBigInteger(Ljava/lang/String;)Ljava/math/BigInteger;",
                                    "method_body": "public static BigInteger createBigInteger(String str) {\nif (str == null) {\nreturn null;\n}\nreturn new BigInteger(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createBigDecimal(Ljava/lang/String;)Ljava/math/BigDecimal;",
                                    "method_body": "public static BigDecimal createBigDecimal(String str) {\nif (str == null) {\nreturn null;\n}\n// handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\nif (StringUtils.isBlank(str)) {\nthrow new NumberFormatException(\"A blank string is not a valid number\");\n}\n// this is protection for poorness in java.lang.BigDecimal.\n// it accepts this as a legal value, but it does not appear\n// to be in specification of class. OS X Java parses it to\n// a wrong value.\nreturn new BigDecimal(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:isDigits(Ljava/lang/String;)Z",
                                    "method_body": "public static boolean isDigits(String str) {\nif (StringUtils.isEmpty(str)) {\nreturn false;\n}\nfor (int i = 0; i < str.length(); i++) {\nif (!Character.isDigit(str.charAt(i))) {\nreturn false;\n}\n}\nreturn true;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 8,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.time.FastDateFormat_PrinterTest.testCalendarTimezoneRespected",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:<init>(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)V",
                                    "method_body": "protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {\nprinter= new FastDatePrinter(pattern, timeZone, locale);\nparser= new FastDateParser(pattern, timeZone, locale);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 2L;\n\n/**\n* FULL locale dependent date or time style.\n*/\npublic static final int FULL = DateFormat.FULL;\n/**\n* LONG locale dependent date or time style.\n*/\npublic static final int LONG = DateFormat.LONG;\n/**\n* MEDIUM locale dependent date or time style.\n*/\npublic static final int MEDIUM = DateFormat.MEDIUM;\n/**\n* SHORT locale dependent date or time style.\n*/\npublic static final int SHORT = DateFormat.SHORT;\n\nprivate static final FormatCache<FastDateFormat> cache= new FormatCache<FastDateFormat>() {\n@Override\nprotected FastDateFormat createInstance(String pattern, TimeZone timeZone, Locale locale) {\nreturn new FastDateFormat(pattern, timeZone, locale);\n}\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:getInstance(Ljava/lang/String;)Lorg/apache/commons/lang3/time/FastDateFormat;",
                                    "method_body": "public static FastDateFormat getInstance(String pattern) {\nreturn cache.getInstance(pattern, null, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:format(Ljava/util/Calendar;)Ljava/lang/String;",
                                    "method_body": "public String format(Calendar calendar) {\nreturn printer.format(calendar);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FormatCache:<clinit>()V",
                                    "method_body": "static final int NONE= -1;\n\nprivate final ConcurrentMap<MultipartKey, F> cInstanceCache\n= new ConcurrentHashMap<MultipartKey, F>(7);\n\nprivate static final ConcurrentMap<MultipartKey, String> cDateTimeInstanceCache\n= new ConcurrentHashMap<MultipartKey, String>(7);\n\n/**\n* <p>Gets a formatter instance using the default pattern in the\n* default timezone and locale.</p>\n*\n* @return a date/time formatter\n*/\npublic F getInstance() {\nreturn getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, TimeZone.getDefault(), Locale.getDefault());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FormatCache:getInstance(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)Ljava/text/Format;",
                                    "method_body": "public F getInstance(String pattern, TimeZone timeZone, Locale locale) {\nif (pattern == null) {\nthrow new NullPointerException(\"pattern must not be null\");\n}\nif (timeZone == null) {\ntimeZone = TimeZone.getDefault();\n}\nif (locale == null) {\nlocale = Locale.getDefault();\n}\nMultipartKey key = new MultipartKey(pattern, timeZone, locale);\nF format = cInstanceCache.get(key);\nif (format == null) {\nformat = createInstance(pattern, timeZone, locale);\nF previousValue= cInstanceCache.putIfAbsent(key, format);\nif (previousValue != null) {\n// another thread snuck in and did the same work\n// we should return the instance that is in ConcurrentMap\nformat= previousValue;\n}\n}\nreturn format;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$1:createInstance(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)Lorg/apache/commons/lang3/time/FastDateFormat;",
                                    "method_body": "protected FastDateFormat createInstance(String pattern, TimeZone timeZone, Locale locale) {\nreturn new FastDateFormat(pattern, timeZone, locale);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FormatCache$MultipartKey:<init>([Ljava/lang/Object;)V",
                                    "method_body": "public MultipartKey(Object... keys) {\nthis.keys = keys;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FormatCache$MultipartKey:hashCode()I",
                                    "method_body": "public int hashCode() {\nif(hashCode==0) {\nint rc= 0;\nfor(Object key : keys) {\nif(key!=null) {\nrc= rc*7 + key.hashCode();\n}\n}\nhashCode= rc;\n}\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:<init>(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)V",
                                    "method_body": "protected FastDatePrinter(String pattern, TimeZone timeZone, Locale locale) {\nmPattern = pattern;\nmTimeZone = timeZone;\nmLocale = locale;\n\ninit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:<clinit>()V",
                                    "method_body": "private static ConcurrentMap<TimeZoneDisplayKey, String> cTimeZoneDisplayCache =\nnew ConcurrentHashMap<TimeZoneDisplayKey, String>(7);\n/**\n* <p>Gets the time zone display name, using a cache for performance.</p>\n*\n* @param tz  the zone to query\n* @param daylight  true if daylight savings\n* @param style  the style to use {@code TimeZone.LONG} or {@code TimeZone.SHORT}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:init()V",
                                    "method_body": "private void init() {\nList<Rule> rulesList = parsePattern();\nmRules = rulesList.toArray(new Rule[rulesList.size()]);\n\nint len = 0;\nfor (int i=mRules.length; --i >= 0; ) {\nlen += mRules[i].estimateLength();\n}\n\nmMaxLengthEstimate = len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:parsePattern()Ljava/util/List;",
                                    "method_body": "protected List<Rule> parsePattern() {\nDateFormatSymbols symbols = new DateFormatSymbols(mLocale);\nList<Rule> rules = new ArrayList<Rule>();\n\nString[] ERAs = symbols.getEras();\nString[] months = symbols.getMonths();\nString[] shortMonths = symbols.getShortMonths();\nString[] weekdays = symbols.getWeekdays();\nString[] shortWeekdays = symbols.getShortWeekdays();\nString[] AmPmStrings = symbols.getAmPmStrings();\n\nint length = mPattern.length();\nint[] indexRef = new int[1];\n\nfor (int i = 0; i < length; i++) {\nindexRef[0] = i;\nString token = parseToken(mPattern, indexRef);\ni = indexRef[0];\n\nint tokenLen = token.length();\nif (tokenLen == 0) {\nbreak;\n}\n\nRule rule;\nchar c = token.charAt(0);\n\nswitch (c) {\ncase 'G': // era designator (text)\nrule = new TextField(Calendar.ERA, ERAs);\nbreak;\ncase 'y': // year (number)\nif (tokenLen == 2) {\nrule = TwoDigitYearField.INSTANCE;\n} else {\nrule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);\n}\nbreak;\ncase 'M': // month in year (text and number)\nif (tokenLen >= 4) {\nrule = new TextField(Calendar.MONTH, months);\n} else if (tokenLen == 3) {\nrule = new TextField(Calendar.MONTH, shortMonths);\n} else if (tokenLen == 2) {\nrule = TwoDigitMonthField.INSTANCE;\n} else {\nrule = UnpaddedMonthField.INSTANCE;\n}\nbreak;\ncase 'd': // day in month (number)\nrule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\nbreak;\ncase 'h': // hour in am/pm (number, 1..12)\nrule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\nbreak;\ncase 'H': // hour in day (number, 0..23)\nrule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\nbreak;\ncase 'm': // minute in hour (number)\nrule = selectNumberRule(Calendar.MINUTE, tokenLen);\nbreak;\ncase 's': // second in minute (number)\nrule = selectNumberRule(Calendar.SECOND, tokenLen);\nbreak;\ncase 'S': // millisecond (number)\nrule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\nbreak;\ncase 'E': // day in week (text)\nrule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\nbreak;\ncase 'D': // day in year (number)\nrule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\nbreak;\ncase 'F': // day of week in month (number)\nrule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\nbreak;\ncase 'w': // week in year (number)\nrule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\nbreak;\ncase 'W': // week in month (number)\nrule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\nbreak;\ncase 'a': // am/pm marker (text)\nrule = new TextField(Calendar.AM_PM, AmPmStrings);\nbreak;\ncase 'k': // hour in day (1..24)\nrule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\nbreak;\ncase 'K': // hour in am/pm (0..11)\nrule = selectNumberRule(Calendar.HOUR, tokenLen);\nbreak;\ncase 'z': // time zone (text)\nif (tokenLen >= 4) {\nrule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n} else {\nrule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n}\nbreak;\ncase 'Z': // time zone (value)\nif (tokenLen == 1) {\nrule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n} else {\nrule = TimeZoneNumberRule.INSTANCE_COLON;\n}\nbreak;\ncase '\\'': // literal text\nString sub = token.substring(1);\nif (sub.length() == 1) {\nrule = new CharacterLiteral(sub.charAt(0));\n} else {\nrule = new StringLiteral(sub);\n}\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"Illegal pattern component: \" + token);\n}\n\nrules.add(rule);\n}\n\nreturn rules;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
                                    "method_body": "protected String parseToken(String pattern, int[] indexRef) {\nStringBuilder buf = new StringBuilder();\n\nint i = indexRef[0];\nint length = pattern.length();\n\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n// Scan a run of the same character, which indicates a time\n// pattern.\nbuf.append(c);\n\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append(c);\ni++;\n} else {\nbreak;\n}\n}\n} else {\n// This will identify token as text.\nbuf.append('\\'');\n\nboolean inLiteral = false;\n\nfor (; i < length; i++) {\nc = pattern.charAt(i);\n\nif (c == '\\'') {\nif (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n// '' is treated as escaped '\ni++;\nbuf.append(c);\n} else {\ninLiteral = !inLiteral;\n}\n} else if (!inLiteral &&\n(c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\ni--;\nbreak;\n} else {\nbuf.append(c);\n}\n}\n}\n\nindexRef[0] = i;\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:selectNumberRule(II)Lorg/apache/commons/lang3/time/FastDatePrinter$NumberRule;",
                                    "method_body": "protected NumberRule selectNumberRule(int field, int padding) {\nswitch (padding) {\ncase 1:\nreturn new UnpaddedNumberField(field);\ncase 2:\nreturn new TwoDigitNumberField(field);\ndefault:\nreturn new PaddedNumberField(field, padding);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:format(Ljava/util/Calendar;)Ljava/lang/String;",
                                    "method_body": "public String format(Calendar calendar) {\nreturn format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:format(Ljava/util/Calendar;Ljava/lang/StringBuffer;)Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer format(Calendar calendar, StringBuffer buf) {\nreturn applyRules(calendar, buf);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:applyRules(Ljava/util/Calendar;Ljava/lang/StringBuffer;)Ljava/lang/StringBuffer;",
                                    "method_body": "protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\nfor (Rule rule : mRules) {\nrule.appendTo(buf, calendar);\n}\nreturn buf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:getTimeZoneDisplay(Ljava/util/TimeZone;ZILjava/util/Locale;)Ljava/lang/String;",
                                    "method_body": "static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {\nTimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\nString value = cTimeZoneDisplayCache.get(key);\nif (value == null) {\n// This is a very slow call, so cache the results.\nvalue = tz.getDisplayName(daylight, style, locale);\nString prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\nif (prior != null) {\nvalue= prior;\n}\n}\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$CharacterLiteral:<init>(C)V",
                                    "method_body": "void appendTo(StringBuffer buffer, int value);\n}\n\n/**\n* <p>Inner class to output a constant single character.</p>\n*/\nprivate static class CharacterLiteral implements Rule {\nprivate final char mValue;\n\n/**\n* Constructs a new instance of {@code CharacterLiteral}\n* to hold the specified value.\n*\n* @param value the character literal\n*/\nCharacterLiteral(char value) {\nmValue = value;\n}\n\n/**\n* {@inheritDoc}\n*/\n@Override\npublic int estimateLength() {\nreturn 1;\n}\n\n/**\n* {@inheritDoc}\n*/\n@Override\npublic void appendTo(StringBuffer buffer, Calendar calendar) {\nbuffer.append(mValue);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$CharacterLiteral:estimateLength()I",
                                    "method_body": "void appendTo(StringBuffer buffer, int value);\n}\n\n/**\n* <p>Inner class to output a constant single character.</p>\n*/\nprivate static class CharacterLiteral implements Rule {\nprivate final char mValue;\n\n/**\n* Constructs a new instance of {@code CharacterLiteral}\n* to hold the specified value.\n*\n* @param value the character literal\n*/\nCharacterLiteral(char value) {\nmValue = value;\n}\n\n/**\n* {@inheritDoc}\n*/\n@Override\npublic int estimateLength() {\nreturn 1;\n}\n\n/**\n* {@inheritDoc}\n*/\n@Override\npublic void appendTo(StringBuffer buffer, Calendar calendar) {\nbuffer.append(mValue);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$CharacterLiteral:appendTo(Ljava/lang/StringBuffer;Ljava/util/Calendar;)V",
                                    "method_body": "void appendTo(StringBuffer buffer, int value);\n}\n\n/**\n* <p>Inner class to output a constant single character.</p>\n*/\nprivate static class CharacterLiteral implements Rule {\nprivate final char mValue;\n\n/**\n* Constructs a new instance of {@code CharacterLiteral}\n* to hold the specified value.\n*\n* @param value the character literal\n*/\nCharacterLiteral(char value) {\nmValue = value;\n}\n\n/**\n* {@inheritDoc}\n*/\n@Override\npublic int estimateLength() {\nreturn 1;\n}\n\n/**\n* {@inheritDoc}\n*/\n@Override\npublic void appendTo(StringBuffer buffer, Calendar calendar) {\nbuffer.append(mValue);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TwoDigitNumberField:<init>(I)V",
                                    "method_body": "TwoDigitNumberField(int field) {\nmField = field;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TwoDigitNumberField:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nreturn 2;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TwoDigitNumberField:appendTo(Ljava/lang/StringBuffer;Ljava/util/Calendar;)V",
                                    "method_body": "public void appendTo(StringBuffer buffer, Calendar calendar) {\nappendTo(buffer, calendar.get(mField));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TwoDigitNumberField:appendTo(Ljava/lang/StringBuffer;I)V",
                                    "method_body": "public final void appendTo(StringBuffer buffer, int value) {\nif (value < 100) {\nbuffer.append((char)(value / 10 + '0'));\nbuffer.append((char)(value % 10 + '0'));\n} else {\nbuffer.append(Integer.toString(value));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:<init>(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)V",
                                    "method_body": "protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\nthis.pattern = pattern;\nthis.timeZone = timeZone;\nthis.locale = locale;\ninit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\nstatic final Locale JAPANESE_IMPERIAL = new Locale(\"ja\",\"JP\",\"JP\");\n\n// defining fields\nprivate final String pattern;\nprivate final TimeZone timeZone;\nprivate final Locale locale;\n\n// derived fields\nprivate transient Pattern parsePattern;\nprivate transient Strategy[] strategies;\nprivate transient int thisYear;\n\n// dynamic fields to communicate with Strategy\nprivate transient String currentFormatField;\nprivate transient Strategy nextStrategy;\n\n/**\n* <p>Constructs a new FastDateParser.</p>\n*\n* @param pattern non-null {@link java.text.SimpleDateFormat} compatible"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:init()V",
                                    "method_body": "private void init() {\nCalendar definingCalendar = Calendar.getInstance(timeZone, locale);\nthisYear= definingCalendar.get(Calendar.YEAR);\n\nStringBuilder regex= new StringBuilder();\nList<Strategy> collector = new ArrayList<Strategy>();\n\nMatcher patternMatcher= formatPattern.matcher(pattern);\nif(!patternMatcher.lookingAt()) {\nthrow new IllegalArgumentException(\n\"Illegal pattern character '\" + pattern.charAt(patternMatcher.regionStart()) + \"'\");\n}\n\ncurrentFormatField= patternMatcher.group();\nStrategy currentStrategy= getStrategy(currentFormatField, definingCalendar);\nfor(;;) {\npatternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\nif(!patternMatcher.lookingAt()) {\nnextStrategy = null;\nbreak;\n}\nString nextFormatField= patternMatcher.group();\nnextStrategy = getStrategy(nextFormatField, definingCalendar);\nif(currentStrategy.addRegex(this, regex)) {\ncollector.add(currentStrategy);\n}\ncurrentFormatField= nextFormatField;\ncurrentStrategy= nextStrategy;\n}\nif (patternMatcher.regionStart() != patternMatcher.regionEnd()) {\nthrow new IllegalArgumentException(\"Failed to parse \\\"\"+pattern+\"\\\" ; gave up at index \"+patternMatcher.regionStart());\n}\nif(currentStrategy.addRegex(this, regex)) {\ncollector.add(currentStrategy);\n}\ncurrentFormatField= null;\nstrategies= collector.toArray(new Strategy[collector.size()]);\nparsePattern= Pattern.compile(regex.toString());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:escapeRegex(Ljava/lang/StringBuilder;Ljava/lang/String;Z)Ljava/lang/StringBuilder;",
                                    "method_body": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\nregex.append(\"\\\\Q\");\nfor(int i= 0; i<value.length(); ++i) {\nchar c= value.charAt(i);\nswitch(c) {\ncase '\\'':\nif(unquote) {\nif(++i==value.length()) {\nreturn regex;\n}\nc= value.charAt(i);\n}\nbreak;\ncase '\\\\':\nif(++i==value.length()) {\nbreak;\n}\n/*\n* If we have found \\E, we replace it with \\E\\\\E\\Q, i.e. we stop the quoting,\n* quote the \\ in \\E, then restart the quoting.\n*\n* Otherwise we just output the two characters.\n* In each case the initial \\ needs to be output and the final char is done at the end\n*/\nregex.append(c); // we always want the original \\\nc = value.charAt(i); // Is it followed by E ?\nif (c == 'E') { // \\E detected\nregex.append(\"E\\\\\\\\E\\\\\"); // see comment above\nc = 'Q'; // appended below\n}\nbreak;\n}\nregex.append(c);\n}\nregex.append(\"\\\\E\");\nreturn regex;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:getDisplayNames(ILjava/util/Calendar;Ljava/util/Locale;)Ljava/util/Map;",
                                    "method_body": "private static Map<String, Integer> getDisplayNames(int field, Calendar definingCalendar, Locale locale) {\nreturn definingCalendar.getDisplayNames(field, Calendar.ALL_STYLES, locale);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:isNextNumber()Z",
                                    "method_body": "boolean isNextNumber() {\nreturn nextStrategy!=null && nextStrategy.isNumber();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:getStrategy(Ljava/lang/String;Ljava/util/Calendar;)Lorg/apache/commons/lang3/time/FastDateParser$Strategy;",
                                    "method_body": "boolean isNumber();\n/**\n* Set the Calendar with the parsed field\n* @param parser The parser calling this strategy\n* @param cal The <code>Calendar</code> to set\n* @param value The parsed field to translate and set in cal\n*/\nvoid setCalendar(FastDateParser parser, Calendar cal, String value);\n/**\n* Generate a <code>Pattern</code> regular expression to the <code>StringBuilder</code>\n* which will accept this field\n* @param parser The parser calling this strategy\n* @param regex The <code>StringBuilder</code> to append to\n* @param Calendar The calendar this strategy must parse\n* @return true, if this field will set the calendar;\n* false, if this field is a constant value\n*/\nboolean addRegex(FastDateParser parser, StringBuilder regex);\n}\n\n/**\n* A <code>Pattern</code> to parse the user supplied SimpleDateFormat pattern\n*/\nprivate static final Pattern formatPattern= Pattern.compile(\n\"D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++\");\n\n/**\n* Obtain a Strategy given a field from a SimpleDateFormat pattern\n* @param formatField A sub-sequence of the SimpleDateFormat pattern\n* @param definingCalendar The calendar to obtain the short and long values\n* @return The Strategy that will handle parsing for the field\n*/\nprivate Strategy getStrategy(String formatField, Calendar definingCalendar) {\nswitch(formatField.charAt(0)) {\ncase '\\'':\nif(formatField.length()>2) {\nformatField= formatField.substring(1, formatField.length()-1);\n}\n//$FALL-THROUGH$\ndefault:\nreturn new CopyQuotedStrategy(formatField);\ncase 'D':\nreturn DAY_OF_YEAR_STRATEGY;\ncase 'E':\nreturn getLocaleSpecificStrategy(Calendar.DAY_OF_WEEK, definingCalendar);\ncase 'F':\nreturn DAY_OF_WEEK_IN_MONTH_STRATEGY;\ncase 'G':\nreturn getLocaleSpecificStrategy(Calendar.ERA, definingCalendar);\ncase 'H':\nreturn MODULO_HOUR_OF_DAY_STRATEGY;\ncase 'K':\nreturn HOUR_STRATEGY;\ncase 'M':\nreturn formatField.length()>=3 ?getLocaleSpecificStrategy(Calendar.MONTH, definingCalendar) :NUMBER_MONTH_STRATEGY;\ncase 'S':\nreturn MILLISECOND_STRATEGY;\ncase 'W':\nreturn WEEK_OF_MONTH_STRATEGY;\ncase 'a':\nreturn getLocaleSpecificStrategy(Calendar.AM_PM, definingCalendar);\ncase 'd':\nreturn DAY_OF_MONTH_STRATEGY;\ncase 'h':\nreturn MODULO_HOUR_STRATEGY;\ncase 'k':\nreturn HOUR_OF_DAY_STRATEGY;\ncase 'm':\nreturn MINUTE_STRATEGY;\ncase 's':\nreturn SECOND_STRATEGY;\ncase 'w':\nreturn WEEK_OF_YEAR_STRATEGY;\ncase 'y':\nreturn formatField.length()>2 ?LITERAL_YEAR_STRATEGY :ABBREVIATED_YEAR_STRATEGY;\ncase 'Z':\ncase 'z':\nreturn getLocaleSpecificStrategy(Calendar.ZONE_OFFSET, definingCalendar);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:getCache(I)Ljava/util/concurrent/ConcurrentMap;",
                                    "method_body": "private static ConcurrentMap<Locale, Strategy> getCache(int field) {\nsynchronized(caches) {\nif(caches[field]==null) {\ncaches[field]= new ConcurrentHashMap<Locale,Strategy>(3);\n}\nreturn caches[field];\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:getLocaleSpecificStrategy(ILjava/util/Calendar;)Lorg/apache/commons/lang3/time/FastDateParser$Strategy;",
                                    "method_body": "private Strategy getLocaleSpecificStrategy(int field, Calendar definingCalendar) {\nConcurrentMap<Locale,Strategy> cache = getCache(field);\nStrategy strategy= cache.get(Integer.valueOf(field));\nif(strategy==null) {\nstrategy= field==Calendar.ZONE_OFFSET\n? new TimeZoneStrategy(locale)\n: new TextStrategy(field, definingCalendar, locale);\nStrategy inCache= cache.putIfAbsent(locale, strategy);\nif(inCache!=null) {\nreturn inCache;\n}\n}\nreturn strategy;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$NumberStrategy:<init>(I)V",
                                    "method_body": "NumberStrategy(int field) {\nthis.field= field;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$NumberStrategy:addRegex(Lorg/apache/commons/lang3/time/FastDateParser;Ljava/lang/StringBuilder;)Z",
                                    "method_body": "public boolean addRegex(FastDateParser parser, StringBuilder regex) {\nif(parser.isNextNumber()) {\nregex.append(\"(\\\\p{IsNd}{\").append(parser.getFieldWidth()).append(\"}+)\");\n}\nelse {\nregex.append(\"(\\\\p{IsNd}++)\");\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$CopyQuotedStrategy:<init>(Ljava/lang/String;)V",
                                    "method_body": "CopyQuotedStrategy(String formatField) {\nthis.formatField= formatField;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$CopyQuotedStrategy:isNumber()Z",
                                    "method_body": "public boolean isNumber() {\nchar c= formatField.charAt(0);\nif(c=='\\'') {\nc= formatField.charAt(1);\n}\nreturn Character.isDigit(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$CopyQuotedStrategy:addRegex(Lorg/apache/commons/lang3/time/FastDateParser;Ljava/lang/StringBuilder;)Z",
                                    "method_body": "public boolean addRegex(FastDateParser parser, StringBuilder regex) {\nescapeRegex(regex, formatField, true);\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$UnpaddedNumberField:<init>(I)V",
                                    "method_body": "UnpaddedNumberField(int field) {\nmField = field;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$UnpaddedNumberField:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nreturn 4;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$UnpaddedNumberField:appendTo(Ljava/lang/StringBuffer;I)V",
                                    "method_body": "public final void appendTo(StringBuffer buffer, int value) {\nif (value < 10) {\nbuffer.append((char)(value + '0'));\n} else if (value < 100) {\nbuffer.append((char)(value / 10 + '0'));\nbuffer.append((char)(value % 10 + '0'));\n} else {\nbuffer.append(Integer.toString(value));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TwelveHourField:<init>(Lorg/apache/commons/lang3/time/FastDatePrinter$NumberRule;)V",
                                    "method_body": "TwelveHourField(NumberRule rule) {\nmRule = rule;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TwelveHourField:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nreturn mRule.estimateLength();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TwelveHourField:appendTo(Ljava/lang/StringBuffer;Ljava/util/Calendar;)V",
                                    "method_body": "public void appendTo(StringBuffer buffer, Calendar calendar) {\nint value = calendar.get(Calendar.HOUR);\nif (value == 0) {\nvalue = calendar.getLeastMaximum(Calendar.HOUR) + 1;\n}\nmRule.appendTo(buffer, value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TextField:<init>(I[Ljava/lang/String;)V",
                                    "method_body": "TextField(int field, String[] values) {\nmField = field;\nmValues = values;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TextField:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nint max = 0;\nfor (int i=mValues.length; --i >= 0; ) {\nint len = mValues[i].length();\nif (len > max) {\nmax = len;\n}\n}\nreturn max;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TextField:appendTo(Ljava/lang/StringBuffer;Ljava/util/Calendar;)V",
                                    "method_body": "public void appendTo(StringBuffer buffer, Calendar calendar) {\nbuffer.append(mValues[calendar.get(mField)]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TimeZoneNameRule:<init>(Ljava/util/TimeZone;Ljava/util/Locale;I)V",
                                    "method_body": "TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {\nmLocale = locale;\nmStyle = style;\nzone = timeZone;\n\nmStandard = getTimeZoneDisplay(timeZone, false, style, locale);\nmDaylight = getTimeZoneDisplay(timeZone, true, style, locale);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TimeZoneNameRule:estimateLength()I",
                                    "method_body": "public int estimateLength() {\n// We have no access to the Calendar object that will be passed to\n// appendTo so base estimate on the TimeZone passed to the\n// constructor\nreturn Math.max(mStandard.length(), mDaylight.length());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TimeZoneNameRule:appendTo(Ljava/lang/StringBuffer;Ljava/util/Calendar;)V",
                                    "method_body": "public void appendTo(StringBuffer buffer, Calendar calendar) {\nif (zone.useDaylightTime()\n&& calendar.get(Calendar.DST_OFFSET) != 0) {\nbuffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));\n} else {\nbuffer.append(getTimeZoneDisplay(zone, false, mStyle, mLocale));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TimeZoneDisplayKey:<init>(Ljava/util/TimeZone;ZILjava/util/Locale;)V",
                                    "method_body": "TimeZoneDisplayKey(TimeZone timeZone,\nboolean daylight, int style, Locale locale) {\nmTimeZone = timeZone;\nif (daylight) {\nstyle |= 0x80000000;\n}\nmStyle = style;\nmLocale = locale;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TimeZoneDisplayKey:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn (mStyle * 31 + mLocale.hashCode() ) * 31 + mTimeZone.hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TimeZoneDisplayKey:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object obj) {\nif (this == obj) {\nreturn true;\n}\nif (obj instanceof TimeZoneDisplayKey) {\nTimeZoneDisplayKey other = (TimeZoneDisplayKey)obj;\nreturn\nmTimeZone.equals(other.mTimeZone) &&\nmStyle == other.mStyle &&\nmLocale.equals(other.mLocale);\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$TextStrategy:<init>(ILjava/util/Calendar;Ljava/util/Locale;)V",
                                    "method_body": "TextStrategy(int field, Calendar definingCalendar, Locale locale) {\nthis.field= field;\nthis.keyValues= getDisplayNames(field, definingCalendar, locale);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$TextStrategy:isNumber()Z",
                                    "method_body": "public boolean isNumber() {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$TextStrategy:addRegex(Lorg/apache/commons/lang3/time/FastDateParser;Ljava/lang/StringBuilder;)Z",
                                    "method_body": "public boolean addRegex(FastDateParser parser, StringBuilder regex) {\nregex.append('(');\nfor(String textKeyValue : keyValues.keySet()) {\nescapeRegex(regex, textKeyValue, false).append('|');\n}\nregex.setCharAt(regex.length()-1, ')');\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$TimeZoneStrategy:<init>(Ljava/util/Locale;)V",
                                    "method_body": "TimeZoneStrategy(Locale locale) {\nfor(String id : TimeZone.getAvailableIDs()) {\nif(id.startsWith(\"GMT\")) {\ncontinue;\n}\nTimeZone tz= TimeZone.getTimeZone(id);\ntzNames.put(tz.getDisplayName(false, TimeZone.SHORT, locale), tz);\ntzNames.put(tz.getDisplayName(false, TimeZone.LONG, locale), tz);\nif(tz.useDaylightTime()) {\ntzNames.put(tz.getDisplayName(true, TimeZone.SHORT, locale), tz);\ntzNames.put(tz.getDisplayName(true, TimeZone.LONG, locale), tz);\n}\n}\nStringBuilder sb= new StringBuilder();\nsb.append(\"(GMT[+\\\\-]\\\\d{0,1}\\\\d{2}|[+\\\\-]\\\\d{2}:?\\\\d{2}|\");\nfor(String id : tzNames.keySet()) {\nescapeRegex(sb, id, false).append('|');\n}\nsb.setCharAt(sb.length()-1, ')');\nvalidTimeZoneChars= sb.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$TimeZoneStrategy:addRegex(Lorg/apache/commons/lang3/time/FastDateParser;Ljava/lang/StringBuilder;)Z",
                                    "method_body": "public boolean addRegex(FastDateParser parser, StringBuilder regex) {\nregex.append(validTimeZoneChars);\nreturn true;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.time.FastDatePrinterTest.testCalendarTimezoneRespected",
                            "test_body": "266: public void testCalendarTimezoneRespected() {\n267: String[] availableZones = TimeZone.getAvailableIDs();\n268: TimeZone currentZone = TimeZone.getDefault();\n269: 270: TimeZone anotherZone = null;\n271: for (String zone : availableZones) {\n272: if (!zone.equals(currentZone.getID())) {\n273: anotherZone = TimeZone.getTimeZone(zone);\n274: }\n275: }\n276: 277: assertNotNull(\"Cannot find another timezone\", anotherZone);\n278: 279: final String pattern = \"h:mma z\";\n280: final Calendar cal = Calendar.getInstance(anotherZone);\n281: 282: SimpleDateFormat sdf = new SimpleDateFormat(pattern);\n283: sdf.setTimeZone(anotherZone);\n284: String expectedValue = sdf.format(cal.getTime());\n285: String actualValue = FastDateFormat.getInstance(pattern).format(cal);\n286: assertEquals(expectedValue, actualValue);\n287: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:<init>(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)V",
                                    "method_body": "protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {\nprinter= new FastDatePrinter(pattern, timeZone, locale);\nparser= new FastDateParser(pattern, timeZone, locale);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 2L;\n\n/**\n* FULL locale dependent date or time style.\n*/\npublic static final int FULL = DateFormat.FULL;\n/**\n* LONG locale dependent date or time style.\n*/\npublic static final int LONG = DateFormat.LONG;\n/**\n* MEDIUM locale dependent date or time style.\n*/\npublic static final int MEDIUM = DateFormat.MEDIUM;\n/**\n* SHORT locale dependent date or time style.\n*/\npublic static final int SHORT = DateFormat.SHORT;\n\nprivate static final FormatCache<FastDateFormat> cache= new FormatCache<FastDateFormat>() {\n@Override\nprotected FastDateFormat createInstance(String pattern, TimeZone timeZone, Locale locale) {\nreturn new FastDateFormat(pattern, timeZone, locale);\n}\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:getInstance(Ljava/lang/String;)Lorg/apache/commons/lang3/time/FastDateFormat;",
                                    "method_body": "public static FastDateFormat getInstance(String pattern) {\nreturn cache.getInstance(pattern, null, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:format(Ljava/util/Calendar;)Ljava/lang/String;",
                                    "method_body": "public String format(Calendar calendar) {\nreturn printer.format(calendar);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FormatCache:<clinit>()V",
                                    "method_body": "static final int NONE= -1;\n\nprivate final ConcurrentMap<MultipartKey, F> cInstanceCache\n= new ConcurrentHashMap<MultipartKey, F>(7);\n\nprivate static final ConcurrentMap<MultipartKey, String> cDateTimeInstanceCache\n= new ConcurrentHashMap<MultipartKey, String>(7);\n\n/**\n* <p>Gets a formatter instance using the default pattern in the\n* default timezone and locale.</p>\n*\n* @return a date/time formatter\n*/\npublic F getInstance() {\nreturn getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, TimeZone.getDefault(), Locale.getDefault());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FormatCache:getInstance(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)Ljava/text/Format;",
                                    "method_body": "public F getInstance(String pattern, TimeZone timeZone, Locale locale) {\nif (pattern == null) {\nthrow new NullPointerException(\"pattern must not be null\");\n}\nif (timeZone == null) {\ntimeZone = TimeZone.getDefault();\n}\nif (locale == null) {\nlocale = Locale.getDefault();\n}\nMultipartKey key = new MultipartKey(pattern, timeZone, locale);\nF format = cInstanceCache.get(key);\nif (format == null) {\nformat = createInstance(pattern, timeZone, locale);\nF previousValue= cInstanceCache.putIfAbsent(key, format);\nif (previousValue != null) {\n// another thread snuck in and did the same work\n// we should return the instance that is in ConcurrentMap\nformat= previousValue;\n}\n}\nreturn format;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$1:createInstance(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)Lorg/apache/commons/lang3/time/FastDateFormat;",
                                    "method_body": "protected FastDateFormat createInstance(String pattern, TimeZone timeZone, Locale locale) {\nreturn new FastDateFormat(pattern, timeZone, locale);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FormatCache$MultipartKey:<init>([Ljava/lang/Object;)V",
                                    "method_body": "public MultipartKey(Object... keys) {\nthis.keys = keys;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FormatCache$MultipartKey:hashCode()I",
                                    "method_body": "public int hashCode() {\nif(hashCode==0) {\nint rc= 0;\nfor(Object key : keys) {\nif(key!=null) {\nrc= rc*7 + key.hashCode();\n}\n}\nhashCode= rc;\n}\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:<init>(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)V",
                                    "method_body": "protected FastDatePrinter(String pattern, TimeZone timeZone, Locale locale) {\nmPattern = pattern;\nmTimeZone = timeZone;\nmLocale = locale;\n\ninit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:<clinit>()V",
                                    "method_body": "private static ConcurrentMap<TimeZoneDisplayKey, String> cTimeZoneDisplayCache =\nnew ConcurrentHashMap<TimeZoneDisplayKey, String>(7);\n/**\n* <p>Gets the time zone display name, using a cache for performance.</p>\n*\n* @param tz  the zone to query\n* @param daylight  true if daylight savings\n* @param style  the style to use {@code TimeZone.LONG} or {@code TimeZone.SHORT}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:init()V",
                                    "method_body": "private void init() {\nList<Rule> rulesList = parsePattern();\nmRules = rulesList.toArray(new Rule[rulesList.size()]);\n\nint len = 0;\nfor (int i=mRules.length; --i >= 0; ) {\nlen += mRules[i].estimateLength();\n}\n\nmMaxLengthEstimate = len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:parsePattern()Ljava/util/List;",
                                    "method_body": "protected List<Rule> parsePattern() {\nDateFormatSymbols symbols = new DateFormatSymbols(mLocale);\nList<Rule> rules = new ArrayList<Rule>();\n\nString[] ERAs = symbols.getEras();\nString[] months = symbols.getMonths();\nString[] shortMonths = symbols.getShortMonths();\nString[] weekdays = symbols.getWeekdays();\nString[] shortWeekdays = symbols.getShortWeekdays();\nString[] AmPmStrings = symbols.getAmPmStrings();\n\nint length = mPattern.length();\nint[] indexRef = new int[1];\n\nfor (int i = 0; i < length; i++) {\nindexRef[0] = i;\nString token = parseToken(mPattern, indexRef);\ni = indexRef[0];\n\nint tokenLen = token.length();\nif (tokenLen == 0) {\nbreak;\n}\n\nRule rule;\nchar c = token.charAt(0);\n\nswitch (c) {\ncase 'G': // era designator (text)\nrule = new TextField(Calendar.ERA, ERAs);\nbreak;\ncase 'y': // year (number)\nif (tokenLen == 2) {\nrule = TwoDigitYearField.INSTANCE;\n} else {\nrule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);\n}\nbreak;\ncase 'M': // month in year (text and number)\nif (tokenLen >= 4) {\nrule = new TextField(Calendar.MONTH, months);\n} else if (tokenLen == 3) {\nrule = new TextField(Calendar.MONTH, shortMonths);\n} else if (tokenLen == 2) {\nrule = TwoDigitMonthField.INSTANCE;\n} else {\nrule = UnpaddedMonthField.INSTANCE;\n}\nbreak;\ncase 'd': // day in month (number)\nrule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\nbreak;\ncase 'h': // hour in am/pm (number, 1..12)\nrule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\nbreak;\ncase 'H': // hour in day (number, 0..23)\nrule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\nbreak;\ncase 'm': // minute in hour (number)\nrule = selectNumberRule(Calendar.MINUTE, tokenLen);\nbreak;\ncase 's': // second in minute (number)\nrule = selectNumberRule(Calendar.SECOND, tokenLen);\nbreak;\ncase 'S': // millisecond (number)\nrule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\nbreak;\ncase 'E': // day in week (text)\nrule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\nbreak;\ncase 'D': // day in year (number)\nrule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\nbreak;\ncase 'F': // day of week in month (number)\nrule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\nbreak;\ncase 'w': // week in year (number)\nrule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\nbreak;\ncase 'W': // week in month (number)\nrule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\nbreak;\ncase 'a': // am/pm marker (text)\nrule = new TextField(Calendar.AM_PM, AmPmStrings);\nbreak;\ncase 'k': // hour in day (1..24)\nrule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\nbreak;\ncase 'K': // hour in am/pm (0..11)\nrule = selectNumberRule(Calendar.HOUR, tokenLen);\nbreak;\ncase 'z': // time zone (text)\nif (tokenLen >= 4) {\nrule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n} else {\nrule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n}\nbreak;\ncase 'Z': // time zone (value)\nif (tokenLen == 1) {\nrule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n} else {\nrule = TimeZoneNumberRule.INSTANCE_COLON;\n}\nbreak;\ncase '\\'': // literal text\nString sub = token.substring(1);\nif (sub.length() == 1) {\nrule = new CharacterLiteral(sub.charAt(0));\n} else {\nrule = new StringLiteral(sub);\n}\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"Illegal pattern component: \" + token);\n}\n\nrules.add(rule);\n}\n\nreturn rules;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
                                    "method_body": "protected String parseToken(String pattern, int[] indexRef) {\nStringBuilder buf = new StringBuilder();\n\nint i = indexRef[0];\nint length = pattern.length();\n\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n// Scan a run of the same character, which indicates a time\n// pattern.\nbuf.append(c);\n\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append(c);\ni++;\n} else {\nbreak;\n}\n}\n} else {\n// This will identify token as text.\nbuf.append('\\'');\n\nboolean inLiteral = false;\n\nfor (; i < length; i++) {\nc = pattern.charAt(i);\n\nif (c == '\\'') {\nif (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n// '' is treated as escaped '\ni++;\nbuf.append(c);\n} else {\ninLiteral = !inLiteral;\n}\n} else if (!inLiteral &&\n(c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\ni--;\nbreak;\n} else {\nbuf.append(c);\n}\n}\n}\n\nindexRef[0] = i;\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:selectNumberRule(II)Lorg/apache/commons/lang3/time/FastDatePrinter$NumberRule;",
                                    "method_body": "protected NumberRule selectNumberRule(int field, int padding) {\nswitch (padding) {\ncase 1:\nreturn new UnpaddedNumberField(field);\ncase 2:\nreturn new TwoDigitNumberField(field);\ndefault:\nreturn new PaddedNumberField(field, padding);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:format(Ljava/util/Calendar;)Ljava/lang/String;",
                                    "method_body": "public String format(Calendar calendar) {\nreturn format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:format(Ljava/util/Calendar;Ljava/lang/StringBuffer;)Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer format(Calendar calendar, StringBuffer buf) {\nreturn applyRules(calendar, buf);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:applyRules(Ljava/util/Calendar;Ljava/lang/StringBuffer;)Ljava/lang/StringBuffer;",
                                    "method_body": "protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\nfor (Rule rule : mRules) {\nrule.appendTo(buf, calendar);\n}\nreturn buf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:getTimeZoneDisplay(Ljava/util/TimeZone;ZILjava/util/Locale;)Ljava/lang/String;",
                                    "method_body": "static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {\nTimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\nString value = cTimeZoneDisplayCache.get(key);\nif (value == null) {\n// This is a very slow call, so cache the results.\nvalue = tz.getDisplayName(daylight, style, locale);\nString prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\nif (prior != null) {\nvalue= prior;\n}\n}\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$CharacterLiteral:<init>(C)V",
                                    "method_body": "void appendTo(StringBuffer buffer, int value);\n}\n\n/**\n* <p>Inner class to output a constant single character.</p>\n*/\nprivate static class CharacterLiteral implements Rule {\nprivate final char mValue;\n\n/**\n* Constructs a new instance of {@code CharacterLiteral}\n* to hold the specified value.\n*\n* @param value the character literal\n*/\nCharacterLiteral(char value) {\nmValue = value;\n}\n\n/**\n* {@inheritDoc}\n*/\n@Override\npublic int estimateLength() {\nreturn 1;\n}\n\n/**\n* {@inheritDoc}\n*/\n@Override\npublic void appendTo(StringBuffer buffer, Calendar calendar) {\nbuffer.append(mValue);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$CharacterLiteral:estimateLength()I",
                                    "method_body": "void appendTo(StringBuffer buffer, int value);\n}\n\n/**\n* <p>Inner class to output a constant single character.</p>\n*/\nprivate static class CharacterLiteral implements Rule {\nprivate final char mValue;\n\n/**\n* Constructs a new instance of {@code CharacterLiteral}\n* to hold the specified value.\n*\n* @param value the character literal\n*/\nCharacterLiteral(char value) {\nmValue = value;\n}\n\n/**\n* {@inheritDoc}\n*/\n@Override\npublic int estimateLength() {\nreturn 1;\n}\n\n/**\n* {@inheritDoc}\n*/\n@Override\npublic void appendTo(StringBuffer buffer, Calendar calendar) {\nbuffer.append(mValue);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$CharacterLiteral:appendTo(Ljava/lang/StringBuffer;Ljava/util/Calendar;)V",
                                    "method_body": "void appendTo(StringBuffer buffer, int value);\n}\n\n/**\n* <p>Inner class to output a constant single character.</p>\n*/\nprivate static class CharacterLiteral implements Rule {\nprivate final char mValue;\n\n/**\n* Constructs a new instance of {@code CharacterLiteral}\n* to hold the specified value.\n*\n* @param value the character literal\n*/\nCharacterLiteral(char value) {\nmValue = value;\n}\n\n/**\n* {@inheritDoc}\n*/\n@Override\npublic int estimateLength() {\nreturn 1;\n}\n\n/**\n* {@inheritDoc}\n*/\n@Override\npublic void appendTo(StringBuffer buffer, Calendar calendar) {\nbuffer.append(mValue);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TwoDigitNumberField:<init>(I)V",
                                    "method_body": "TwoDigitNumberField(int field) {\nmField = field;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TwoDigitNumberField:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nreturn 2;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TwoDigitNumberField:appendTo(Ljava/lang/StringBuffer;Ljava/util/Calendar;)V",
                                    "method_body": "public void appendTo(StringBuffer buffer, Calendar calendar) {\nappendTo(buffer, calendar.get(mField));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TwoDigitNumberField:appendTo(Ljava/lang/StringBuffer;I)V",
                                    "method_body": "public final void appendTo(StringBuffer buffer, int value) {\nif (value < 100) {\nbuffer.append((char)(value / 10 + '0'));\nbuffer.append((char)(value % 10 + '0'));\n} else {\nbuffer.append(Integer.toString(value));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:<init>(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)V",
                                    "method_body": "protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\nthis.pattern = pattern;\nthis.timeZone = timeZone;\nthis.locale = locale;\ninit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\nstatic final Locale JAPANESE_IMPERIAL = new Locale(\"ja\",\"JP\",\"JP\");\n\n// defining fields\nprivate final String pattern;\nprivate final TimeZone timeZone;\nprivate final Locale locale;\n\n// derived fields\nprivate transient Pattern parsePattern;\nprivate transient Strategy[] strategies;\nprivate transient int thisYear;\n\n// dynamic fields to communicate with Strategy\nprivate transient String currentFormatField;\nprivate transient Strategy nextStrategy;\n\n/**\n* <p>Constructs a new FastDateParser.</p>\n*\n* @param pattern non-null {@link java.text.SimpleDateFormat} compatible"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:init()V",
                                    "method_body": "private void init() {\nCalendar definingCalendar = Calendar.getInstance(timeZone, locale);\nthisYear= definingCalendar.get(Calendar.YEAR);\n\nStringBuilder regex= new StringBuilder();\nList<Strategy> collector = new ArrayList<Strategy>();\n\nMatcher patternMatcher= formatPattern.matcher(pattern);\nif(!patternMatcher.lookingAt()) {\nthrow new IllegalArgumentException(\n\"Illegal pattern character '\" + pattern.charAt(patternMatcher.regionStart()) + \"'\");\n}\n\ncurrentFormatField= patternMatcher.group();\nStrategy currentStrategy= getStrategy(currentFormatField, definingCalendar);\nfor(;;) {\npatternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\nif(!patternMatcher.lookingAt()) {\nnextStrategy = null;\nbreak;\n}\nString nextFormatField= patternMatcher.group();\nnextStrategy = getStrategy(nextFormatField, definingCalendar);\nif(currentStrategy.addRegex(this, regex)) {\ncollector.add(currentStrategy);\n}\ncurrentFormatField= nextFormatField;\ncurrentStrategy= nextStrategy;\n}\nif (patternMatcher.regionStart() != patternMatcher.regionEnd()) {\nthrow new IllegalArgumentException(\"Failed to parse \\\"\"+pattern+\"\\\" ; gave up at index \"+patternMatcher.regionStart());\n}\nif(currentStrategy.addRegex(this, regex)) {\ncollector.add(currentStrategy);\n}\ncurrentFormatField= null;\nstrategies= collector.toArray(new Strategy[collector.size()]);\nparsePattern= Pattern.compile(regex.toString());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:escapeRegex(Ljava/lang/StringBuilder;Ljava/lang/String;Z)Ljava/lang/StringBuilder;",
                                    "method_body": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\nregex.append(\"\\\\Q\");\nfor(int i= 0; i<value.length(); ++i) {\nchar c= value.charAt(i);\nswitch(c) {\ncase '\\'':\nif(unquote) {\nif(++i==value.length()) {\nreturn regex;\n}\nc= value.charAt(i);\n}\nbreak;\ncase '\\\\':\nif(++i==value.length()) {\nbreak;\n}\n/*\n* If we have found \\E, we replace it with \\E\\\\E\\Q, i.e. we stop the quoting,\n* quote the \\ in \\E, then restart the quoting.\n*\n* Otherwise we just output the two characters.\n* In each case the initial \\ needs to be output and the final char is done at the end\n*/\nregex.append(c); // we always want the original \\\nc = value.charAt(i); // Is it followed by E ?\nif (c == 'E') { // \\E detected\nregex.append(\"E\\\\\\\\E\\\\\"); // see comment above\nc = 'Q'; // appended below\n}\nbreak;\n}\nregex.append(c);\n}\nregex.append(\"\\\\E\");\nreturn regex;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:getDisplayNames(ILjava/util/Calendar;Ljava/util/Locale;)Ljava/util/Map;",
                                    "method_body": "private static Map<String, Integer> getDisplayNames(int field, Calendar definingCalendar, Locale locale) {\nreturn definingCalendar.getDisplayNames(field, Calendar.ALL_STYLES, locale);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:isNextNumber()Z",
                                    "method_body": "boolean isNextNumber() {\nreturn nextStrategy!=null && nextStrategy.isNumber();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:getStrategy(Ljava/lang/String;Ljava/util/Calendar;)Lorg/apache/commons/lang3/time/FastDateParser$Strategy;",
                                    "method_body": "boolean isNumber();\n/**\n* Set the Calendar with the parsed field\n* @param parser The parser calling this strategy\n* @param cal The <code>Calendar</code> to set\n* @param value The parsed field to translate and set in cal\n*/\nvoid setCalendar(FastDateParser parser, Calendar cal, String value);\n/**\n* Generate a <code>Pattern</code> regular expression to the <code>StringBuilder</code>\n* which will accept this field\n* @param parser The parser calling this strategy\n* @param regex The <code>StringBuilder</code> to append to\n* @param Calendar The calendar this strategy must parse\n* @return true, if this field will set the calendar;\n* false, if this field is a constant value\n*/\nboolean addRegex(FastDateParser parser, StringBuilder regex);\n}\n\n/**\n* A <code>Pattern</code> to parse the user supplied SimpleDateFormat pattern\n*/\nprivate static final Pattern formatPattern= Pattern.compile(\n\"D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++\");\n\n/**\n* Obtain a Strategy given a field from a SimpleDateFormat pattern\n* @param formatField A sub-sequence of the SimpleDateFormat pattern\n* @param definingCalendar The calendar to obtain the short and long values\n* @return The Strategy that will handle parsing for the field\n*/\nprivate Strategy getStrategy(String formatField, Calendar definingCalendar) {\nswitch(formatField.charAt(0)) {\ncase '\\'':\nif(formatField.length()>2) {\nformatField= formatField.substring(1, formatField.length()-1);\n}\n//$FALL-THROUGH$\ndefault:\nreturn new CopyQuotedStrategy(formatField);\ncase 'D':\nreturn DAY_OF_YEAR_STRATEGY;\ncase 'E':\nreturn getLocaleSpecificStrategy(Calendar.DAY_OF_WEEK, definingCalendar);\ncase 'F':\nreturn DAY_OF_WEEK_IN_MONTH_STRATEGY;\ncase 'G':\nreturn getLocaleSpecificStrategy(Calendar.ERA, definingCalendar);\ncase 'H':\nreturn MODULO_HOUR_OF_DAY_STRATEGY;\ncase 'K':\nreturn HOUR_STRATEGY;\ncase 'M':\nreturn formatField.length()>=3 ?getLocaleSpecificStrategy(Calendar.MONTH, definingCalendar) :NUMBER_MONTH_STRATEGY;\ncase 'S':\nreturn MILLISECOND_STRATEGY;\ncase 'W':\nreturn WEEK_OF_MONTH_STRATEGY;\ncase 'a':\nreturn getLocaleSpecificStrategy(Calendar.AM_PM, definingCalendar);\ncase 'd':\nreturn DAY_OF_MONTH_STRATEGY;\ncase 'h':\nreturn MODULO_HOUR_STRATEGY;\ncase 'k':\nreturn HOUR_OF_DAY_STRATEGY;\ncase 'm':\nreturn MINUTE_STRATEGY;\ncase 's':\nreturn SECOND_STRATEGY;\ncase 'w':\nreturn WEEK_OF_YEAR_STRATEGY;\ncase 'y':\nreturn formatField.length()>2 ?LITERAL_YEAR_STRATEGY :ABBREVIATED_YEAR_STRATEGY;\ncase 'Z':\ncase 'z':\nreturn getLocaleSpecificStrategy(Calendar.ZONE_OFFSET, definingCalendar);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:getCache(I)Ljava/util/concurrent/ConcurrentMap;",
                                    "method_body": "private static ConcurrentMap<Locale, Strategy> getCache(int field) {\nsynchronized(caches) {\nif(caches[field]==null) {\ncaches[field]= new ConcurrentHashMap<Locale,Strategy>(3);\n}\nreturn caches[field];\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:getLocaleSpecificStrategy(ILjava/util/Calendar;)Lorg/apache/commons/lang3/time/FastDateParser$Strategy;",
                                    "method_body": "private Strategy getLocaleSpecificStrategy(int field, Calendar definingCalendar) {\nConcurrentMap<Locale,Strategy> cache = getCache(field);\nStrategy strategy= cache.get(Integer.valueOf(field));\nif(strategy==null) {\nstrategy= field==Calendar.ZONE_OFFSET\n? new TimeZoneStrategy(locale)\n: new TextStrategy(field, definingCalendar, locale);\nStrategy inCache= cache.putIfAbsent(locale, strategy);\nif(inCache!=null) {\nreturn inCache;\n}\n}\nreturn strategy;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$NumberStrategy:<init>(I)V",
                                    "method_body": "NumberStrategy(int field) {\nthis.field= field;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$NumberStrategy:addRegex(Lorg/apache/commons/lang3/time/FastDateParser;Ljava/lang/StringBuilder;)Z",
                                    "method_body": "public boolean addRegex(FastDateParser parser, StringBuilder regex) {\nif(parser.isNextNumber()) {\nregex.append(\"(\\\\p{IsNd}{\").append(parser.getFieldWidth()).append(\"}+)\");\n}\nelse {\nregex.append(\"(\\\\p{IsNd}++)\");\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$CopyQuotedStrategy:<init>(Ljava/lang/String;)V",
                                    "method_body": "CopyQuotedStrategy(String formatField) {\nthis.formatField= formatField;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$CopyQuotedStrategy:isNumber()Z",
                                    "method_body": "public boolean isNumber() {\nchar c= formatField.charAt(0);\nif(c=='\\'') {\nc= formatField.charAt(1);\n}\nreturn Character.isDigit(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$CopyQuotedStrategy:addRegex(Lorg/apache/commons/lang3/time/FastDateParser;Ljava/lang/StringBuilder;)Z",
                                    "method_body": "public boolean addRegex(FastDateParser parser, StringBuilder regex) {\nescapeRegex(regex, formatField, true);\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$UnpaddedNumberField:<init>(I)V",
                                    "method_body": "UnpaddedNumberField(int field) {\nmField = field;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$UnpaddedNumberField:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nreturn 4;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$UnpaddedNumberField:appendTo(Ljava/lang/StringBuffer;I)V",
                                    "method_body": "public final void appendTo(StringBuffer buffer, int value) {\nif (value < 10) {\nbuffer.append((char)(value + '0'));\n} else if (value < 100) {\nbuffer.append((char)(value / 10 + '0'));\nbuffer.append((char)(value % 10 + '0'));\n} else {\nbuffer.append(Integer.toString(value));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TwelveHourField:<init>(Lorg/apache/commons/lang3/time/FastDatePrinter$NumberRule;)V",
                                    "method_body": "TwelveHourField(NumberRule rule) {\nmRule = rule;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TwelveHourField:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nreturn mRule.estimateLength();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TwelveHourField:appendTo(Ljava/lang/StringBuffer;Ljava/util/Calendar;)V",
                                    "method_body": "public void appendTo(StringBuffer buffer, Calendar calendar) {\nint value = calendar.get(Calendar.HOUR);\nif (value == 0) {\nvalue = calendar.getLeastMaximum(Calendar.HOUR) + 1;\n}\nmRule.appendTo(buffer, value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TextField:<init>(I[Ljava/lang/String;)V",
                                    "method_body": "TextField(int field, String[] values) {\nmField = field;\nmValues = values;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TextField:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nint max = 0;\nfor (int i=mValues.length; --i >= 0; ) {\nint len = mValues[i].length();\nif (len > max) {\nmax = len;\n}\n}\nreturn max;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TextField:appendTo(Ljava/lang/StringBuffer;Ljava/util/Calendar;)V",
                                    "method_body": "public void appendTo(StringBuffer buffer, Calendar calendar) {\nbuffer.append(mValues[calendar.get(mField)]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TimeZoneNameRule:<init>(Ljava/util/TimeZone;Ljava/util/Locale;I)V",
                                    "method_body": "TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {\nmLocale = locale;\nmStyle = style;\nzone = timeZone;\n\nmStandard = getTimeZoneDisplay(timeZone, false, style, locale);\nmDaylight = getTimeZoneDisplay(timeZone, true, style, locale);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TimeZoneNameRule:estimateLength()I",
                                    "method_body": "public int estimateLength() {\n// We have no access to the Calendar object that will be passed to\n// appendTo so base estimate on the TimeZone passed to the\n// constructor\nreturn Math.max(mStandard.length(), mDaylight.length());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TimeZoneNameRule:appendTo(Ljava/lang/StringBuffer;Ljava/util/Calendar;)V",
                                    "method_body": "public void appendTo(StringBuffer buffer, Calendar calendar) {\nif (zone.useDaylightTime()\n&& calendar.get(Calendar.DST_OFFSET) != 0) {\nbuffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));\n} else {\nbuffer.append(getTimeZoneDisplay(zone, false, mStyle, mLocale));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TimeZoneDisplayKey:<init>(Ljava/util/TimeZone;ZILjava/util/Locale;)V",
                                    "method_body": "TimeZoneDisplayKey(TimeZone timeZone,\nboolean daylight, int style, Locale locale) {\nmTimeZone = timeZone;\nif (daylight) {\nstyle |= 0x80000000;\n}\nmStyle = style;\nmLocale = locale;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TimeZoneDisplayKey:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn (mStyle * 31 + mLocale.hashCode() ) * 31 + mTimeZone.hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TimeZoneDisplayKey:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object obj) {\nif (this == obj) {\nreturn true;\n}\nif (obj instanceof TimeZoneDisplayKey) {\nTimeZoneDisplayKey other = (TimeZoneDisplayKey)obj;\nreturn\nmTimeZone.equals(other.mTimeZone) &&\nmStyle == other.mStyle &&\nmLocale.equals(other.mLocale);\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$TextStrategy:<init>(ILjava/util/Calendar;Ljava/util/Locale;)V",
                                    "method_body": "TextStrategy(int field, Calendar definingCalendar, Locale locale) {\nthis.field= field;\nthis.keyValues= getDisplayNames(field, definingCalendar, locale);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$TextStrategy:isNumber()Z",
                                    "method_body": "public boolean isNumber() {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$TextStrategy:addRegex(Lorg/apache/commons/lang3/time/FastDateParser;Ljava/lang/StringBuilder;)Z",
                                    "method_body": "public boolean addRegex(FastDateParser parser, StringBuilder regex) {\nregex.append('(');\nfor(String textKeyValue : keyValues.keySet()) {\nescapeRegex(regex, textKeyValue, false).append('|');\n}\nregex.setCharAt(regex.length()-1, ')');\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$TimeZoneStrategy:<init>(Ljava/util/Locale;)V",
                                    "method_body": "TimeZoneStrategy(Locale locale) {\nfor(String id : TimeZone.getAvailableIDs()) {\nif(id.startsWith(\"GMT\")) {\ncontinue;\n}\nTimeZone tz= TimeZone.getTimeZone(id);\ntzNames.put(tz.getDisplayName(false, TimeZone.SHORT, locale), tz);\ntzNames.put(tz.getDisplayName(false, TimeZone.LONG, locale), tz);\nif(tz.useDaylightTime()) {\ntzNames.put(tz.getDisplayName(true, TimeZone.SHORT, locale), tz);\ntzNames.put(tz.getDisplayName(true, TimeZone.LONG, locale), tz);\n}\n}\nStringBuilder sb= new StringBuilder();\nsb.append(\"(GMT[+\\\\-]\\\\d{0,1}\\\\d{2}|[+\\\\-]\\\\d{2}:?\\\\d{2}|\");\nfor(String id : tzNames.keySet()) {\nescapeRegex(sb, id, false).append('|');\n}\nsb.setCharAt(sb.length()-1, ')');\nvalidTimeZoneChars= sb.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$TimeZoneStrategy:addRegex(Lorg/apache/commons/lang3/time/FastDateParser;Ljava/lang/StringBuilder;)Z",
                                    "method_body": "public boolean addRegex(FastDateParser parser, StringBuilder regex) {\nregex.append(validTimeZoneChars);\nreturn true;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 9,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.time.FastDateParserTest.testLANG_832",
                            "test_body": "346: public void testLANG_832() throws Exception {\n347: testSdfAndFdp(\"'d'd\" ,\"d3\", false); // OK\n348: testSdfAndFdp(\"'d'd'\",\"d3\", true); // should fail (unterminated quote)\n349: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:<init>(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)V",
                                    "method_body": "protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\nthis.pattern = pattern;\nthis.timeZone = timeZone;\nthis.locale = locale;\ninit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\nprivate static final ConcurrentMap<Locale,TimeZoneStrategy> tzsCache=\nnew ConcurrentHashMap<Locale,TimeZoneStrategy>(3);\n\nstatic final Locale JAPANESE_IMPERIAL = new Locale(\"ja\",\"JP\",\"JP\");\n\n// defining fields\nprivate final String pattern;\nprivate final TimeZone timeZone;\nprivate final Locale locale;\n\n// derived fields\nprivate transient Pattern parsePattern;\nprivate transient Strategy[] strategies;\nprivate transient int thisYear;\nprivate transient ConcurrentMap<Integer, KeyValue[]> nameValues;\n\n// dynamic fields to communicate with Strategy\nprivate transient String currentFormatField;\nprivate transient Strategy nextStrategy;\n\n/**\n* <p>Constructs a new FastDateParser.</p>\n*\n* @param pattern non-null {@link java.text.SimpleDateFormat} compatible"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:init()V",
                                    "method_body": "private void init() {\nthisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n\nnameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n\nStringBuilder regex= new StringBuilder();\nList<Strategy> collector = new ArrayList<Strategy>();\n\nMatcher patternMatcher= formatPattern.matcher(pattern);\nif(!patternMatcher.lookingAt()) {\nthrow new IllegalArgumentException(\"Invalid pattern\");\n}\n\ncurrentFormatField= patternMatcher.group();\nStrategy currentStrategy= getStrategy(currentFormatField);\nfor(;;) {\npatternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\nif(!patternMatcher.lookingAt()) {\nnextStrategy = null;\nbreak;\n}\nString nextFormatField= patternMatcher.group();\nnextStrategy = getStrategy(nextFormatField);\nif(currentStrategy.addRegex(this, regex)) {\ncollector.add(currentStrategy);\n}\ncurrentFormatField= nextFormatField;\ncurrentStrategy= nextStrategy;\n}\nif(currentStrategy.addRegex(this, regex)) {\ncollector.add(currentStrategy);\n}\ncurrentFormatField= null;\nstrategies= collector.toArray(new Strategy[collector.size()]);\nparsePattern= Pattern.compile(regex.toString());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:getParsePattern()Ljava/util/regex/Pattern;",
                                    "method_body": "Pattern getParsePattern() {\nreturn parsePattern;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:parse(Ljava/lang/String;)Ljava/util/Date;",
                                    "method_body": "public Date parse(String source) throws ParseException {\nDate date= parse(source, new ParsePosition(0));\nif(date==null) {\n// Add a note re supported date range\nif (locale.equals(JAPANESE_IMPERIAL)) {\nthrow new ParseException(\n\"(The \" +locale + \" locale does not support dates before 1868 AD)\\n\" +\n\"Unparseable date: \\\"\"+source+\"\\\" does not match \"+parsePattern.pattern(), 0);\n}\nthrow new ParseException(\"Unparseable date: \\\"\"+source+\"\\\" does not match \"+parsePattern.pattern(), 0);\n}\nreturn date;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:parse(Ljava/lang/String;Ljava/text/ParsePosition;)Ljava/util/Date;",
                                    "method_body": "public Date parse(String source, ParsePosition pos) {\nint offset= pos.getIndex();\nMatcher matcher= parsePattern.matcher(source.substring(offset));\nif(!matcher.lookingAt()) {\nreturn null;\n}\n// timing tests indicate getting new instance is 19% faster than cloning\nCalendar cal= Calendar.getInstance(timeZone, locale);\ncal.clear();\n\nfor(int i=0; i<strategies.length;) {\nStrategy strategy= strategies[i++];\nstrategy.setCalendar(this, cal, matcher.group(i));\n}\npos.setIndex(offset+matcher.end());\nreturn cal.getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:escapeRegex(Ljava/lang/StringBuilder;Ljava/lang/String;Z)Ljava/lang/StringBuilder;",
                                    "method_body": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\nfor(int i= 0; i<value.length(); ++i) {\nchar c= value.charAt(i);\nswitch(c) {\ncase '\\'':\nif(unquote) {\nif(++i==value.length()) {\nreturn regex;\n}\nc= value.charAt(i);\n}\nbreak;\ncase '?':\ncase '[':\ncase ']':\ncase '(':\ncase ')':\ncase '{':\ncase '}':\ncase '\\\\':\ncase '|':\ncase '*':\ncase '+':\ncase '^':\ncase '$':\ncase '.':\nregex.append('\\\\');\n}\nregex.append(c);\n}\nreturn regex;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:isNextNumber()Z",
                                    "method_body": "boolean isNextNumber() {\nreturn nextStrategy!=null && nextStrategy.isNumber();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:getStrategy(Ljava/lang/String;)Lorg/apache/commons/lang3/time/FastDateParser$Strategy;",
                                    "method_body": "boolean isNumber();\n/**\n* Set the Calendar with the parsed field\n* @param parser The parser calling this strategy\n* @param cal The <code>Calendar</code> to set\n* @param value The parsed field to translate and set in cal\n*/\nvoid setCalendar(FastDateParser parser, Calendar cal, String value);\n/**\n* Generate a <code>Pattern</code> regular expression to the <code>StringBuilder</code>\n* which will accept this field\n* @param parser The parser calling this strategy\n* @param regex The <code>StringBuilder</code> to append to\n* @return true, if this field will set the calendar;\n* false, if this field is a constant value\n*/\nboolean addRegex(FastDateParser parser, StringBuilder regex);\n}\n\n/**\n* A <code>Pattern</code> to parse the user supplied SimpleDateFormat pattern\n*/\nprivate static final Pattern formatPattern= Pattern.compile(\n\"D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++\");\n\n/**\n* Obtain a Strategy given a field from a SimpleDateFormat pattern\n* @param formatField A sub-sequence of the SimpleDateFormat pattern\n* @return The Strategy that will handle parsing for the field\n*/\nprivate Strategy getStrategy(String formatField) {\nswitch(formatField.charAt(0)) {\ncase '\\'':\nif(formatField.length()>2) {\nformatField= formatField.substring(1, formatField.length()-1);\n}\n//$FALL-THROUGH$\ndefault:\nreturn new CopyQuotedStrategy(formatField);\ncase 'D':\nreturn DAY_OF_YEAR_STRATEGY;\ncase 'E':\nreturn DAY_OF_WEEK_STRATEGY;\ncase 'F':\nreturn DAY_OF_WEEK_IN_MONTH_STRATEGY;\ncase 'G':\nreturn ERA_STRATEGY;\ncase 'H':\nreturn MODULO_HOUR_OF_DAY_STRATEGY;\ncase 'K':\nreturn HOUR_STRATEGY;\ncase 'M':\nreturn formatField.length()>=3 ?TEXT_MONTH_STRATEGY :NUMBER_MONTH_STRATEGY;\ncase 'S':\nreturn MILLISECOND_STRATEGY;\ncase 'W':\nreturn WEEK_OF_MONTH_STRATEGY;\ncase 'Z':\nbreak;\ncase 'a':\nreturn AM_PM_STRATEGY;\ncase 'd':\nreturn DAY_OF_MONTH_STRATEGY;\ncase 'h':\nreturn MODULO_HOUR_STRATEGY;\ncase 'k':\nreturn HOUR_OF_DAY_STRATEGY;\ncase 'm':\nreturn MINUTE_STRATEGY;\ncase 's':\nreturn SECOND_STRATEGY;\ncase 'w':\nreturn WEEK_OF_YEAR_STRATEGY;\ncase 'y':\nreturn formatField.length()>2 ?LITERAL_YEAR_STRATEGY :ABBREVIATED_YEAR_STRATEGY;\ncase 'z':\nbreak;\n}\nTimeZoneStrategy tzs= tzsCache.get(locale);\nif(tzs==null) {\ntzs= new TimeZoneStrategy(locale);\nTimeZoneStrategy inCache= tzsCache.putIfAbsent(locale, tzs);\nif(inCache!=null) {\nreturn inCache;\n}\n}\nreturn tzs;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$NumberStrategy:<init>(I)V",
                                    "method_body": "NumberStrategy(int field) {\nthis.field= field;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$NumberStrategy:addRegex(Lorg/apache/commons/lang3/time/FastDateParser;Ljava/lang/StringBuilder;)Z",
                                    "method_body": "public boolean addRegex(FastDateParser parser, StringBuilder regex) {\nif(parser.isNextNumber()) {\nregex.append(\"(\\\\p{IsNd}{\").append(parser.getFieldWidth()).append(\"}+)\");\n}\nelse {\nregex.append(\"(\\\\p{IsNd}++)\");\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$NumberStrategy:setCalendar(Lorg/apache/commons/lang3/time/FastDateParser;Ljava/util/Calendar;Ljava/lang/String;)V",
                                    "method_body": "public void setCalendar(FastDateParser parser, Calendar cal, String value) {\ncal.set(field, modify(Integer.parseInt(value)));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$NumberStrategy:modify(I)I",
                                    "method_body": "public int modify(int iValue) {\nreturn iValue;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$TextStrategy:<init>(I)V",
                                    "method_body": "TextStrategy(int field) {\nthis.field= field;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$CopyQuotedStrategy:<init>(Ljava/lang/String;)V",
                                    "method_body": "CopyQuotedStrategy(String formatField) {\nthis.formatField= formatField;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$CopyQuotedStrategy:addRegex(Lorg/apache/commons/lang3/time/FastDateParser;Ljava/lang/StringBuilder;)Z",
                                    "method_body": "public boolean addRegex(FastDateParser parser, StringBuilder regex) {\nescapeRegex(regex, formatField, true);\nreturn false;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.time.FastDateFormat_ParserTest.testLANG_832",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:<init>(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)V",
                                    "method_body": "protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\nthis.pattern = pattern;\nthis.timeZone = timeZone;\nthis.locale = locale;\ninit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\nprivate static final ConcurrentMap<Locale,TimeZoneStrategy> tzsCache=\nnew ConcurrentHashMap<Locale,TimeZoneStrategy>(3);\n\nstatic final Locale JAPANESE_IMPERIAL = new Locale(\"ja\",\"JP\",\"JP\");\n\n// defining fields\nprivate final String pattern;\nprivate final TimeZone timeZone;\nprivate final Locale locale;\n\n// derived fields\nprivate transient Pattern parsePattern;\nprivate transient Strategy[] strategies;\nprivate transient int thisYear;\nprivate transient ConcurrentMap<Integer, KeyValue[]> nameValues;\n\n// dynamic fields to communicate with Strategy\nprivate transient String currentFormatField;\nprivate transient Strategy nextStrategy;\n\n/**\n* <p>Constructs a new FastDateParser.</p>\n*\n* @param pattern non-null {@link java.text.SimpleDateFormat} compatible"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:init()V",
                                    "method_body": "private void init() {\nthisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n\nnameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n\nStringBuilder regex= new StringBuilder();\nList<Strategy> collector = new ArrayList<Strategy>();\n\nMatcher patternMatcher= formatPattern.matcher(pattern);\nif(!patternMatcher.lookingAt()) {\nthrow new IllegalArgumentException(\"Invalid pattern\");\n}\n\ncurrentFormatField= patternMatcher.group();\nStrategy currentStrategy= getStrategy(currentFormatField);\nfor(;;) {\npatternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\nif(!patternMatcher.lookingAt()) {\nnextStrategy = null;\nbreak;\n}\nString nextFormatField= patternMatcher.group();\nnextStrategy = getStrategy(nextFormatField);\nif(currentStrategy.addRegex(this, regex)) {\ncollector.add(currentStrategy);\n}\ncurrentFormatField= nextFormatField;\ncurrentStrategy= nextStrategy;\n}\nif(currentStrategy.addRegex(this, regex)) {\ncollector.add(currentStrategy);\n}\ncurrentFormatField= null;\nstrategies= collector.toArray(new Strategy[collector.size()]);\nparsePattern= Pattern.compile(regex.toString());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:parse(Ljava/lang/String;)Ljava/util/Date;",
                                    "method_body": "public Date parse(String source) throws ParseException {\nDate date= parse(source, new ParsePosition(0));\nif(date==null) {\n// Add a note re supported date range\nif (locale.equals(JAPANESE_IMPERIAL)) {\nthrow new ParseException(\n\"(The \" +locale + \" locale does not support dates before 1868 AD)\\n\" +\n\"Unparseable date: \\\"\"+source+\"\\\" does not match \"+parsePattern.pattern(), 0);\n}\nthrow new ParseException(\"Unparseable date: \\\"\"+source+\"\\\" does not match \"+parsePattern.pattern(), 0);\n}\nreturn date;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:parse(Ljava/lang/String;Ljava/text/ParsePosition;)Ljava/util/Date;",
                                    "method_body": "public Date parse(String source, ParsePosition pos) {\nint offset= pos.getIndex();\nMatcher matcher= parsePattern.matcher(source.substring(offset));\nif(!matcher.lookingAt()) {\nreturn null;\n}\n// timing tests indicate getting new instance is 19% faster than cloning\nCalendar cal= Calendar.getInstance(timeZone, locale);\ncal.clear();\n\nfor(int i=0; i<strategies.length;) {\nStrategy strategy= strategies[i++];\nstrategy.setCalendar(this, cal, matcher.group(i));\n}\npos.setIndex(offset+matcher.end());\nreturn cal.getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:escapeRegex(Ljava/lang/StringBuilder;Ljava/lang/String;Z)Ljava/lang/StringBuilder;",
                                    "method_body": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\nfor(int i= 0; i<value.length(); ++i) {\nchar c= value.charAt(i);\nswitch(c) {\ncase '\\'':\nif(unquote) {\nif(++i==value.length()) {\nreturn regex;\n}\nc= value.charAt(i);\n}\nbreak;\ncase '?':\ncase '[':\ncase ']':\ncase '(':\ncase ')':\ncase '{':\ncase '}':\ncase '\\\\':\ncase '|':\ncase '*':\ncase '+':\ncase '^':\ncase '$':\ncase '.':\nregex.append('\\\\');\n}\nregex.append(c);\n}\nreturn regex;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:isNextNumber()Z",
                                    "method_body": "boolean isNextNumber() {\nreturn nextStrategy!=null && nextStrategy.isNumber();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:getStrategy(Ljava/lang/String;)Lorg/apache/commons/lang3/time/FastDateParser$Strategy;",
                                    "method_body": "boolean isNumber();\n/**\n* Set the Calendar with the parsed field\n* @param parser The parser calling this strategy\n* @param cal The <code>Calendar</code> to set\n* @param value The parsed field to translate and set in cal\n*/\nvoid setCalendar(FastDateParser parser, Calendar cal, String value);\n/**\n* Generate a <code>Pattern</code> regular expression to the <code>StringBuilder</code>\n* which will accept this field\n* @param parser The parser calling this strategy\n* @param regex The <code>StringBuilder</code> to append to\n* @return true, if this field will set the calendar;\n* false, if this field is a constant value\n*/\nboolean addRegex(FastDateParser parser, StringBuilder regex);\n}\n\n/**\n* A <code>Pattern</code> to parse the user supplied SimpleDateFormat pattern\n*/\nprivate static final Pattern formatPattern= Pattern.compile(\n\"D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++\");\n\n/**\n* Obtain a Strategy given a field from a SimpleDateFormat pattern\n* @param formatField A sub-sequence of the SimpleDateFormat pattern\n* @return The Strategy that will handle parsing for the field\n*/\nprivate Strategy getStrategy(String formatField) {\nswitch(formatField.charAt(0)) {\ncase '\\'':\nif(formatField.length()>2) {\nformatField= formatField.substring(1, formatField.length()-1);\n}\n//$FALL-THROUGH$\ndefault:\nreturn new CopyQuotedStrategy(formatField);\ncase 'D':\nreturn DAY_OF_YEAR_STRATEGY;\ncase 'E':\nreturn DAY_OF_WEEK_STRATEGY;\ncase 'F':\nreturn DAY_OF_WEEK_IN_MONTH_STRATEGY;\ncase 'G':\nreturn ERA_STRATEGY;\ncase 'H':\nreturn MODULO_HOUR_OF_DAY_STRATEGY;\ncase 'K':\nreturn HOUR_STRATEGY;\ncase 'M':\nreturn formatField.length()>=3 ?TEXT_MONTH_STRATEGY :NUMBER_MONTH_STRATEGY;\ncase 'S':\nreturn MILLISECOND_STRATEGY;\ncase 'W':\nreturn WEEK_OF_MONTH_STRATEGY;\ncase 'Z':\nbreak;\ncase 'a':\nreturn AM_PM_STRATEGY;\ncase 'd':\nreturn DAY_OF_MONTH_STRATEGY;\ncase 'h':\nreturn MODULO_HOUR_STRATEGY;\ncase 'k':\nreturn HOUR_OF_DAY_STRATEGY;\ncase 'm':\nreturn MINUTE_STRATEGY;\ncase 's':\nreturn SECOND_STRATEGY;\ncase 'w':\nreturn WEEK_OF_YEAR_STRATEGY;\ncase 'y':\nreturn formatField.length()>2 ?LITERAL_YEAR_STRATEGY :ABBREVIATED_YEAR_STRATEGY;\ncase 'z':\nbreak;\n}\nTimeZoneStrategy tzs= tzsCache.get(locale);\nif(tzs==null) {\ntzs= new TimeZoneStrategy(locale);\nTimeZoneStrategy inCache= tzsCache.putIfAbsent(locale, tzs);\nif(inCache!=null) {\nreturn inCache;\n}\n}\nreturn tzs;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$NumberStrategy:<init>(I)V",
                                    "method_body": "NumberStrategy(int field) {\nthis.field= field;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$NumberStrategy:addRegex(Lorg/apache/commons/lang3/time/FastDateParser;Ljava/lang/StringBuilder;)Z",
                                    "method_body": "public boolean addRegex(FastDateParser parser, StringBuilder regex) {\nif(parser.isNextNumber()) {\nregex.append(\"(\\\\p{IsNd}{\").append(parser.getFieldWidth()).append(\"}+)\");\n}\nelse {\nregex.append(\"(\\\\p{IsNd}++)\");\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$NumberStrategy:setCalendar(Lorg/apache/commons/lang3/time/FastDateParser;Ljava/util/Calendar;Ljava/lang/String;)V",
                                    "method_body": "public void setCalendar(FastDateParser parser, Calendar cal, String value) {\ncal.set(field, modify(Integer.parseInt(value)));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$NumberStrategy:modify(I)I",
                                    "method_body": "public int modify(int iValue) {\nreturn iValue;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$TextStrategy:<init>(I)V",
                                    "method_body": "TextStrategy(int field) {\nthis.field= field;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$CopyQuotedStrategy:<init>(Ljava/lang/String;)V",
                                    "method_body": "CopyQuotedStrategy(String formatField) {\nthis.formatField= formatField;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$CopyQuotedStrategy:addRegex(Lorg/apache/commons/lang3/time/FastDateParser;Ljava/lang/StringBuilder;)Z",
                                    "method_body": "public boolean addRegex(FastDateParser parser, StringBuilder regex) {\nescapeRegex(regex, formatField, true);\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:<init>(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)V",
                                    "method_body": "protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {\nprinter= new FastDatePrinter(pattern, timeZone, locale);\nparser= new FastDateParser(pattern, timeZone, locale);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 2L;\n\n/**\n* FULL locale dependent date or time style.\n*/\npublic static final int FULL = DateFormat.FULL;\n/**\n* LONG locale dependent date or time style.\n*/\npublic static final int LONG = DateFormat.LONG;\n/**\n* MEDIUM locale dependent date or time style.\n*/\npublic static final int MEDIUM = DateFormat.MEDIUM;\n/**\n* SHORT locale dependent date or time style.\n*/\npublic static final int SHORT = DateFormat.SHORT;\n\nprivate static final FormatCache<FastDateFormat> cache= new FormatCache<FastDateFormat>() {\n@Override\nprotected FastDateFormat createInstance(String pattern, TimeZone timeZone, Locale locale) {\nreturn new FastDateFormat(pattern, timeZone, locale);\n}\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:getInstance(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)Lorg/apache/commons/lang3/time/FastDateFormat;",
                                    "method_body": "public static FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {\nreturn cache.getInstance(pattern, timeZone, locale);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:parse(Ljava/lang/String;)Ljava/util/Date;",
                                    "method_body": "public Date parse(String source) throws ParseException {\nreturn parser.parse(source);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FormatCache:<clinit>()V",
                                    "method_body": "static final int NONE= -1;\n\nprivate final ConcurrentMap<MultipartKey, F> cInstanceCache\n= new ConcurrentHashMap<MultipartKey, F>(7);\n\nprivate static final ConcurrentMap<MultipartKey, String> cDateTimeInstanceCache\n= new ConcurrentHashMap<MultipartKey, String>(7);\n\n/**\n* <p>Gets a formatter instance using the default pattern in the\n* default timezone and locale.</p>\n*\n* @return a date/time formatter\n*/\npublic F getInstance() {\nreturn getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, TimeZone.getDefault(), Locale.getDefault());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FormatCache:getInstance(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)Ljava/text/Format;",
                                    "method_body": "public F getInstance(String pattern, TimeZone timeZone, Locale locale) {\nif (pattern == null) {\nthrow new NullPointerException(\"pattern must not be null\");\n}\nif (timeZone == null) {\ntimeZone = TimeZone.getDefault();\n}\nif (locale == null) {\nlocale = Locale.getDefault();\n}\nMultipartKey key = new MultipartKey(pattern, timeZone, locale);\nF format = cInstanceCache.get(key);\nif (format == null) {\nformat = createInstance(pattern, timeZone, locale);\nF previousValue= cInstanceCache.putIfAbsent(key, format);\nif (previousValue != null) {\n// another thread snuck in and did the same work\n// we should return the instance that is in ConcurrentMap\nformat= previousValue;\n}\n}\nreturn format;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$1:createInstance(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)Lorg/apache/commons/lang3/time/FastDateFormat;",
                                    "method_body": "protected FastDateFormat createInstance(String pattern, TimeZone timeZone, Locale locale) {\nreturn new FastDateFormat(pattern, timeZone, locale);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FormatCache$MultipartKey:<init>([Ljava/lang/Object;)V",
                                    "method_body": "public MultipartKey(Object... keys) {\nthis.keys = keys;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FormatCache$MultipartKey:hashCode()I",
                                    "method_body": "public int hashCode() {\nif(hashCode==0) {\nint rc= 0;\nfor(Object key : keys) {\nif(key!=null) {\nrc= rc*7 + key.hashCode();\n}\n}\nhashCode= rc;\n}\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:<init>(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)V",
                                    "method_body": "protected FastDatePrinter(String pattern, TimeZone timeZone, Locale locale) {\nmPattern = pattern;\nmTimeZone = timeZone;\nmLocale = locale;\n\ninit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:<clinit>()V",
                                    "method_body": "private static ConcurrentMap<TimeZoneDisplayKey, String> cTimeZoneDisplayCache =\nnew ConcurrentHashMap<TimeZoneDisplayKey, String>(7);\n/**\n* <p>Gets the time zone display name, using a cache for performance.</p>\n*\n* @param tz  the zone to query\n* @param daylight  true if daylight savings\n* @param style  the style to use {@code TimeZone.LONG} or {@code TimeZone.SHORT}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:init()V",
                                    "method_body": "private void init() {\nList<Rule> rulesList = parsePattern();\nmRules = rulesList.toArray(new Rule[rulesList.size()]);\n\nint len = 0;\nfor (int i=mRules.length; --i >= 0; ) {\nlen += mRules[i].estimateLength();\n}\n\nmMaxLengthEstimate = len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:parsePattern()Ljava/util/List;",
                                    "method_body": "protected List<Rule> parsePattern() {\nDateFormatSymbols symbols = new DateFormatSymbols(mLocale);\nList<Rule> rules = new ArrayList<Rule>();\n\nString[] ERAs = symbols.getEras();\nString[] months = symbols.getMonths();\nString[] shortMonths = symbols.getShortMonths();\nString[] weekdays = symbols.getWeekdays();\nString[] shortWeekdays = symbols.getShortWeekdays();\nString[] AmPmStrings = symbols.getAmPmStrings();\n\nint length = mPattern.length();\nint[] indexRef = new int[1];\n\nfor (int i = 0; i < length; i++) {\nindexRef[0] = i;\nString token = parseToken(mPattern, indexRef);\ni = indexRef[0];\n\nint tokenLen = token.length();\nif (tokenLen == 0) {\nbreak;\n}\n\nRule rule;\nchar c = token.charAt(0);\n\nswitch (c) {\ncase 'G': // era designator (text)\nrule = new TextField(Calendar.ERA, ERAs);\nbreak;\ncase 'y': // year (number)\nif (tokenLen == 2) {\nrule = TwoDigitYearField.INSTANCE;\n} else {\nrule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);\n}\nbreak;\ncase 'M': // month in year (text and number)\nif (tokenLen >= 4) {\nrule = new TextField(Calendar.MONTH, months);\n} else if (tokenLen == 3) {\nrule = new TextField(Calendar.MONTH, shortMonths);\n} else if (tokenLen == 2) {\nrule = TwoDigitMonthField.INSTANCE;\n} else {\nrule = UnpaddedMonthField.INSTANCE;\n}\nbreak;\ncase 'd': // day in month (number)\nrule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\nbreak;\ncase 'h': // hour in am/pm (number, 1..12)\nrule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\nbreak;\ncase 'H': // hour in day (number, 0..23)\nrule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\nbreak;\ncase 'm': // minute in hour (number)\nrule = selectNumberRule(Calendar.MINUTE, tokenLen);\nbreak;\ncase 's': // second in minute (number)\nrule = selectNumberRule(Calendar.SECOND, tokenLen);\nbreak;\ncase 'S': // millisecond (number)\nrule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\nbreak;\ncase 'E': // day in week (text)\nrule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\nbreak;\ncase 'D': // day in year (number)\nrule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\nbreak;\ncase 'F': // day of week in month (number)\nrule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\nbreak;\ncase 'w': // week in year (number)\nrule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\nbreak;\ncase 'W': // week in month (number)\nrule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\nbreak;\ncase 'a': // am/pm marker (text)\nrule = new TextField(Calendar.AM_PM, AmPmStrings);\nbreak;\ncase 'k': // hour in day (1..24)\nrule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\nbreak;\ncase 'K': // hour in am/pm (0..11)\nrule = selectNumberRule(Calendar.HOUR, tokenLen);\nbreak;\ncase 'z': // time zone (text)\nif (tokenLen >= 4) {\nrule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n} else {\nrule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n}\nbreak;\ncase 'Z': // time zone (value)\nif (tokenLen == 1) {\nrule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n} else {\nrule = TimeZoneNumberRule.INSTANCE_COLON;\n}\nbreak;\ncase '\\'': // literal text\nString sub = token.substring(1);\nif (sub.length() == 1) {\nrule = new CharacterLiteral(sub.charAt(0));\n} else {\nrule = new StringLiteral(sub);\n}\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"Illegal pattern component: \" + token);\n}\n\nrules.add(rule);\n}\n\nreturn rules;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
                                    "method_body": "protected String parseToken(String pattern, int[] indexRef) {\nStringBuilder buf = new StringBuilder();\n\nint i = indexRef[0];\nint length = pattern.length();\n\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n// Scan a run of the same character, which indicates a time\n// pattern.\nbuf.append(c);\n\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append(c);\ni++;\n} else {\nbreak;\n}\n}\n} else {\n// This will identify token as text.\nbuf.append('\\'');\n\nboolean inLiteral = false;\n\nfor (; i < length; i++) {\nc = pattern.charAt(i);\n\nif (c == '\\'') {\nif (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n// '' is treated as escaped '\ni++;\nbuf.append(c);\n} else {\ninLiteral = !inLiteral;\n}\n} else if (!inLiteral &&\n(c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\ni--;\nbreak;\n} else {\nbuf.append(c);\n}\n}\n}\n\nindexRef[0] = i;\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:selectNumberRule(II)Lorg/apache/commons/lang3/time/FastDatePrinter$NumberRule;",
                                    "method_body": "protected NumberRule selectNumberRule(int field, int padding) {\nswitch (padding) {\ncase 1:\nreturn new UnpaddedNumberField(field);\ncase 2:\nreturn new TwoDigitNumberField(field);\ndefault:\nreturn new PaddedNumberField(field, padding);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$CharacterLiteral:<init>(C)V",
                                    "method_body": "void appendTo(StringBuffer buffer, int value);\n}\n\n/**\n* <p>Inner class to output a constant single character.</p>\n*/\nprivate static class CharacterLiteral implements Rule {\nprivate final char mValue;\n\n/**\n* Constructs a new instance of {@code CharacterLiteral}\n* to hold the specified value.\n*\n* @param value the character literal\n*/\nCharacterLiteral(char value) {\nmValue = value;\n}\n\n/**\n* {@inheritDoc}\n*/\n@Override\npublic int estimateLength() {\nreturn 1;\n}\n\n/**\n* {@inheritDoc}\n*/\n@Override\npublic void appendTo(StringBuffer buffer, Calendar calendar) {\nbuffer.append(mValue);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$CharacterLiteral:estimateLength()I",
                                    "method_body": "void appendTo(StringBuffer buffer, int value);\n}\n\n/**\n* <p>Inner class to output a constant single character.</p>\n*/\nprivate static class CharacterLiteral implements Rule {\nprivate final char mValue;\n\n/**\n* Constructs a new instance of {@code CharacterLiteral}\n* to hold the specified value.\n*\n* @param value the character literal\n*/\nCharacterLiteral(char value) {\nmValue = value;\n}\n\n/**\n* {@inheritDoc}\n*/\n@Override\npublic int estimateLength() {\nreturn 1;\n}\n\n/**\n* {@inheritDoc}\n*/\n@Override\npublic void appendTo(StringBuffer buffer, Calendar calendar) {\nbuffer.append(mValue);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$UnpaddedNumberField:<init>(I)V",
                                    "method_body": "UnpaddedNumberField(int field) {\nmField = field;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$UnpaddedNumberField:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nreturn 4;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$StringLiteral:<init>(Ljava/lang/String;)V",
                                    "method_body": "StringLiteral(String value) {\nmValue = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$StringLiteral:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nreturn mValue.length();\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 10,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.time.FastDateParserTest.testLANG_831",
                            "test_body": "347: public void testLANG_831() throws Exception {\n348: testSdfAndFdp(\"M E\",\"3  Tue\", true);\n349: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:<init>(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)V",
                                    "method_body": "protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\nthis.pattern = pattern;\nthis.timeZone = timeZone;\nthis.locale = locale;\ninit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\nprivate static final ConcurrentMap<Locale,TimeZoneStrategy> tzsCache=\nnew ConcurrentHashMap<Locale,TimeZoneStrategy>(3);\n\nstatic final Locale JAPANESE_IMPERIAL = new Locale(\"ja\",\"JP\",\"JP\");\n\n// defining fields\nprivate final String pattern;\nprivate final TimeZone timeZone;\nprivate final Locale locale;\n\n// derived fields\nprivate transient Pattern parsePattern;\nprivate transient Strategy[] strategies;\nprivate transient int thisYear;\nprivate transient ConcurrentMap<Integer, KeyValue[]> nameValues;\n\n// dynamic fields to communicate with Strategy\nprivate transient String currentFormatField;\nprivate transient Strategy nextStrategy;\n\n/**\n* <p>Constructs a new FastDateParser.</p>\n*\n* @param pattern non-null {@link java.text.SimpleDateFormat} compatible"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:init()V",
                                    "method_body": "private void init() {\nthisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n\nnameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n\nStringBuilder regex= new StringBuilder();\nList<Strategy> collector = new ArrayList<Strategy>();\n\nMatcher patternMatcher= formatPattern.matcher(pattern);\nif(!patternMatcher.lookingAt()) {\nthrow new IllegalArgumentException(\"Invalid pattern\");\n}\n\ncurrentFormatField= patternMatcher.group();\nStrategy currentStrategy= getStrategy(currentFormatField);\nfor(;;) {\npatternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\nif(!patternMatcher.lookingAt()) {\nnextStrategy = null;\nbreak;\n}\nString nextFormatField= patternMatcher.group();\nnextStrategy = getStrategy(nextFormatField);\nif(currentStrategy.addRegex(this, regex)) {\ncollector.add(currentStrategy);\n}\ncurrentFormatField= nextFormatField;\ncurrentStrategy= nextStrategy;\n}\nif(currentStrategy.addRegex(this, regex)) {\ncollector.add(currentStrategy);\n}\ncurrentFormatField= null;\nstrategies= collector.toArray(new Strategy[collector.size()]);\nparsePattern= Pattern.compile(regex.toString());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:getParsePattern()Ljava/util/regex/Pattern;",
                                    "method_body": "Pattern getParsePattern() {\nreturn parsePattern;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:parse(Ljava/lang/String;)Ljava/util/Date;",
                                    "method_body": "public Date parse(String source) throws ParseException {\nDate date= parse(source, new ParsePosition(0));\nif(date==null) {\n// Add a note re supported date range\nif (locale.equals(JAPANESE_IMPERIAL)) {\nthrow new ParseException(\n\"(The \" +locale + \" locale does not support dates before 1868 AD)\\n\" +\n\"Unparseable date: \\\"\"+source+\"\\\" does not match \"+parsePattern.pattern(), 0);\n}\nthrow new ParseException(\"Unparseable date: \\\"\"+source+\"\\\" does not match \"+parsePattern.pattern(), 0);\n}\nreturn date;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:parse(Ljava/lang/String;Ljava/text/ParsePosition;)Ljava/util/Date;",
                                    "method_body": "public Date parse(String source, ParsePosition pos) {\nint offset= pos.getIndex();\nMatcher matcher= parsePattern.matcher(source.substring(offset));\nif(!matcher.lookingAt()) {\nreturn null;\n}\n// timing tests indicate getting new instance is 19% faster than cloning\nCalendar cal= Calendar.getInstance(timeZone, locale);\ncal.clear();\n\nfor(int i=0; i<strategies.length;) {\nStrategy strategy= strategies[i++];\nstrategy.setCalendar(this, cal, matcher.group(i));\n}\npos.setIndex(offset+matcher.end());\nreturn cal.getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:escapeRegex(Ljava/lang/StringBuilder;Ljava/lang/String;Z)Ljava/lang/StringBuilder;",
                                    "method_body": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\nboolean wasWhite= false;\nfor(int i= 0; i<value.length(); ++i) {\nchar c= value.charAt(i);\nif(Character.isWhitespace(c)) {\nif(!wasWhite) {\nwasWhite= true;\nregex.append(\"\\\\s*+\");\n}\ncontinue;\n}\nwasWhite= false;\nswitch(c) {\ncase '\\'':\nif(unquote) {\nif(++i==value.length()) {\nreturn regex;\n}\nc= value.charAt(i);\n}\nbreak;\ncase '?':\ncase '[':\ncase ']':\ncase '(':\ncase ')':\ncase '{':\ncase '}':\ncase '\\\\':\ncase '|':\ncase '*':\ncase '+':\ncase '^':\ncase '$':\ncase '.':\nregex.append('\\\\');\n}\nregex.append(c);\n}\nreturn regex;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:getDisplayNames(I)[Lorg/apache/commons/lang3/time/FastDateParser$KeyValue;",
                                    "method_body": "KeyValue[] getDisplayNames(int field) {\nInteger fieldInt = Integer.valueOf(field);\nKeyValue[] fieldKeyValues= nameValues.get(fieldInt);\nif(fieldKeyValues==null) {\nDateFormatSymbols symbols= DateFormatSymbols.getInstance(locale);\nswitch(field) {\ncase Calendar.ERA:\n// DateFormatSymbols#getEras() only returns AD/BC or translations\n// It does not work for the Thai Buddhist or Japanese Imperial calendars.\n// see: https://issues.apache.org/jira/browse/TRINIDAD-2126\nCalendar c = Calendar.getInstance(locale);\n// N.B. Some calendars have different short and long symbols, e.g. ja_JP_JP\nString[] shortEras = toArray(c.getDisplayNames(Calendar.ERA, Calendar.SHORT, locale));\nString[] longEras = toArray(c.getDisplayNames(Calendar.ERA, Calendar.LONG, locale));\nfieldKeyValues= createKeyValues(longEras, shortEras);\nbreak;\ncase Calendar.DAY_OF_WEEK:\nfieldKeyValues= createKeyValues(symbols.getWeekdays(), symbols.getShortWeekdays());\nbreak;\ncase Calendar.AM_PM:\nfieldKeyValues= createKeyValues(symbols.getAmPmStrings(), null);\nbreak;\ncase Calendar.MONTH:\nfieldKeyValues= createKeyValues(symbols.getMonths(), symbols.getShortMonths());\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"Invalid field value \"+field);\n}\nKeyValue[] prior = nameValues.putIfAbsent(fieldInt, fieldKeyValues);\nif(prior!=null) {\nfieldKeyValues= prior;\n}\n}\nreturn fieldKeyValues;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:createKeyValues([Ljava/lang/String;[Ljava/lang/String;)[Lorg/apache/commons/lang3/time/FastDateParser$KeyValue;",
                                    "method_body": "private static KeyValue[] createKeyValues(String[] longValues, String[] shortValues) {\nKeyValue[] fieldKeyValues= new KeyValue[count(longValues)+count(shortValues)];\ncopy(fieldKeyValues, copy(fieldKeyValues, 0, longValues), shortValues);\nArrays.sort(fieldKeyValues, IGNORE_CASE_COMPARATOR);\nreturn fieldKeyValues;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:count([Ljava/lang/String;)I",
                                    "method_body": "private static int count(String[] values) {\nint count= 0;\nif(values!=null) {\nfor(String value : values) {\nif(value.length()>0) {\n++count;\n}\n}\n}\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:copy([Lorg/apache/commons/lang3/time/FastDateParser$KeyValue;I[Ljava/lang/String;)I",
                                    "method_body": "private static int copy(KeyValue[] fieldKeyValues, int offset, String[] values) {\nif(values!=null) {\nfor(int i= 0; i<values.length; ++i) {\nString value= values[i];\nif(value.length()>0) {\nfieldKeyValues[offset++]= new KeyValue(value, i);\n}\n}\n}\nreturn offset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:isNextNumber()Z",
                                    "method_body": "boolean isNextNumber() {\nreturn nextStrategy!=null && nextStrategy.isNumber();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:getStrategy(Ljava/lang/String;)Lorg/apache/commons/lang3/time/FastDateParser$Strategy;",
                                    "method_body": "boolean isNumber();\n/**\n* Set the Calendar with the parsed field\n* @param parser The parser calling this strategy\n* @param cal The <code>Calendar</code> to set\n* @param value The parsed field to translate and set in cal\n*/\nvoid setCalendar(FastDateParser parser, Calendar cal, String value);\n/**\n* Generate a <code>Pattern</code> regular expression to the <code>StringBuilder</code>\n* which will accept this field\n* @param parser The parser calling this strategy\n* @param regex The <code>StringBuilder</code> to append to\n* @return true, if this field will set the calendar;\n* false, if this field is a constant value\n*/\nboolean addRegex(FastDateParser parser, StringBuilder regex);\n}\n\n/**\n* A <code>Pattern</code> to parse the user supplied SimpleDateFormat pattern\n*/\nprivate static final Pattern formatPattern= Pattern.compile(\n\"D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++\");\n\n/**\n* Obtain a Strategy given a field from a SimpleDateFormat pattern\n* @param formatField A sub-sequence of the SimpleDateFormat pattern\n* @return The Strategy that will handle parsing for the field\n*/\nprivate Strategy getStrategy(String formatField) {\nswitch(formatField.charAt(0)) {\ncase '\\'':\nif(formatField.length()>2) {\nformatField= formatField.substring(1, formatField.length()-1);\n}\n//$FALL-THROUGH$\ndefault:\nreturn new CopyQuotedStrategy(formatField);\ncase 'D':\nreturn DAY_OF_YEAR_STRATEGY;\ncase 'E':\nreturn DAY_OF_WEEK_STRATEGY;\ncase 'F':\nreturn DAY_OF_WEEK_IN_MONTH_STRATEGY;\ncase 'G':\nreturn ERA_STRATEGY;\ncase 'H':\nreturn MODULO_HOUR_OF_DAY_STRATEGY;\ncase 'K':\nreturn HOUR_STRATEGY;\ncase 'M':\nreturn formatField.length()>=3 ?TEXT_MONTH_STRATEGY :NUMBER_MONTH_STRATEGY;\ncase 'S':\nreturn MILLISECOND_STRATEGY;\ncase 'W':\nreturn WEEK_OF_MONTH_STRATEGY;\ncase 'Z':\nbreak;\ncase 'a':\nreturn AM_PM_STRATEGY;\ncase 'd':\nreturn DAY_OF_MONTH_STRATEGY;\ncase 'h':\nreturn MODULO_HOUR_STRATEGY;\ncase 'k':\nreturn HOUR_OF_DAY_STRATEGY;\ncase 'm':\nreturn MINUTE_STRATEGY;\ncase 's':\nreturn SECOND_STRATEGY;\ncase 'w':\nreturn WEEK_OF_YEAR_STRATEGY;\ncase 'y':\nreturn formatField.length()>2 ?LITERAL_YEAR_STRATEGY :ABBREVIATED_YEAR_STRATEGY;\ncase 'z':\nbreak;\n}\nTimeZoneStrategy tzs= tzsCache.get(locale);\nif(tzs==null) {\ntzs= new TimeZoneStrategy(locale);\nTimeZoneStrategy inCache= tzsCache.putIfAbsent(locale, tzs);\nif(inCache!=null) {\nreturn inCache;\n}\n}\nreturn tzs;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$1:compare(Lorg/apache/commons/lang3/time/FastDateParser$KeyValue;Lorg/apache/commons/lang3/time/FastDateParser$KeyValue;)I",
                                    "method_body": "public int compare(KeyValue left, KeyValue right) {\nreturn left.key.compareToIgnoreCase(right.key);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$NumberStrategy:<init>(I)V",
                                    "method_body": "NumberStrategy(int field) {\nthis.field= field;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$NumberStrategy:addRegex(Lorg/apache/commons/lang3/time/FastDateParser;Ljava/lang/StringBuilder;)Z",
                                    "method_body": "public boolean addRegex(FastDateParser parser, StringBuilder regex) {\nif(parser.isNextNumber()) {\nregex.append(\"(\\\\p{IsNd}{\").append(parser.getFieldWidth()).append(\"}+)\");\n}\nelse {\nregex.append(\"(\\\\p{IsNd}++)\");\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$NumberStrategy:setCalendar(Lorg/apache/commons/lang3/time/FastDateParser;Ljava/util/Calendar;Ljava/lang/String;)V",
                                    "method_body": "public void setCalendar(FastDateParser parser, Calendar cal, String value) {\ncal.set(field, modify(Integer.parseInt(value)));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$TextStrategy:<init>(I)V",
                                    "method_body": "TextStrategy(int field) {\nthis.field= field;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$TextStrategy:addRegex(Lorg/apache/commons/lang3/time/FastDateParser;Ljava/lang/StringBuilder;)Z",
                                    "method_body": "public boolean addRegex(FastDateParser parser, StringBuilder regex) {\nregex.append('(');\nfor(KeyValue textKeyValue : parser.getDisplayNames(field)) {\nescapeRegex(regex, textKeyValue.key, false).append('|');\n}\nregex.setCharAt(regex.length()-1, ')');\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$TextStrategy:setCalendar(Lorg/apache/commons/lang3/time/FastDateParser;Ljava/util/Calendar;Ljava/lang/String;)V",
                                    "method_body": "public void setCalendar(FastDateParser parser, Calendar cal, String value) {\nKeyValue[] textKeyValues= parser.getDisplayNames(field);\nint idx= Arrays.binarySearch(textKeyValues, new KeyValue(value, -1), IGNORE_CASE_COMPARATOR);\nif(idx<0) {\nStringBuilder sb= new StringBuilder(value);\nsb.append(\" not in (\");\nfor(KeyValue textKeyValue : textKeyValues) {\nsb.append(textKeyValue.key).append(' ');\n}\nsb.setCharAt(sb.length()-1, ')');\nthrow new IllegalArgumentException(sb.toString());\n}\ncal.set(field, textKeyValues[idx].value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$3:modify(I)I",
                                    "method_body": "public int modify(int iValue) {\nreturn iValue-1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$CopyQuotedStrategy:<init>(Ljava/lang/String;)V",
                                    "method_body": "CopyQuotedStrategy(String formatField) {\nthis.formatField= formatField;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$CopyQuotedStrategy:isNumber()Z",
                                    "method_body": "public boolean isNumber() {\nchar c= formatField.charAt(0);\nif(c=='\\'') {\nc= formatField.charAt(1);\n}\nreturn Character.isDigit(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$CopyQuotedStrategy:addRegex(Lorg/apache/commons/lang3/time/FastDateParser;Ljava/lang/StringBuilder;)Z",
                                    "method_body": "public boolean addRegex(FastDateParser parser, StringBuilder regex) {\nescapeRegex(regex, formatField, true);\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$KeyValue:<init>(Ljava/lang/String;I)V",
                                    "method_body": "public KeyValue(String key, int value) {\nthis.key= key;\nthis.value= value;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.time.FastDateFormat_ParserTest.testLANG_831",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:<init>(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)V",
                                    "method_body": "protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\nthis.pattern = pattern;\nthis.timeZone = timeZone;\nthis.locale = locale;\ninit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\nprivate static final ConcurrentMap<Locale,TimeZoneStrategy> tzsCache=\nnew ConcurrentHashMap<Locale,TimeZoneStrategy>(3);\n\nstatic final Locale JAPANESE_IMPERIAL = new Locale(\"ja\",\"JP\",\"JP\");\n\n// defining fields\nprivate final String pattern;\nprivate final TimeZone timeZone;\nprivate final Locale locale;\n\n// derived fields\nprivate transient Pattern parsePattern;\nprivate transient Strategy[] strategies;\nprivate transient int thisYear;\nprivate transient ConcurrentMap<Integer, KeyValue[]> nameValues;\n\n// dynamic fields to communicate with Strategy\nprivate transient String currentFormatField;\nprivate transient Strategy nextStrategy;\n\n/**\n* <p>Constructs a new FastDateParser.</p>\n*\n* @param pattern non-null {@link java.text.SimpleDateFormat} compatible"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:init()V",
                                    "method_body": "private void init() {\nthisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n\nnameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n\nStringBuilder regex= new StringBuilder();\nList<Strategy> collector = new ArrayList<Strategy>();\n\nMatcher patternMatcher= formatPattern.matcher(pattern);\nif(!patternMatcher.lookingAt()) {\nthrow new IllegalArgumentException(\"Invalid pattern\");\n}\n\ncurrentFormatField= patternMatcher.group();\nStrategy currentStrategy= getStrategy(currentFormatField);\nfor(;;) {\npatternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\nif(!patternMatcher.lookingAt()) {\nnextStrategy = null;\nbreak;\n}\nString nextFormatField= patternMatcher.group();\nnextStrategy = getStrategy(nextFormatField);\nif(currentStrategy.addRegex(this, regex)) {\ncollector.add(currentStrategy);\n}\ncurrentFormatField= nextFormatField;\ncurrentStrategy= nextStrategy;\n}\nif(currentStrategy.addRegex(this, regex)) {\ncollector.add(currentStrategy);\n}\ncurrentFormatField= null;\nstrategies= collector.toArray(new Strategy[collector.size()]);\nparsePattern= Pattern.compile(regex.toString());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:parse(Ljava/lang/String;)Ljava/util/Date;",
                                    "method_body": "public Date parse(String source) throws ParseException {\nDate date= parse(source, new ParsePosition(0));\nif(date==null) {\n// Add a note re supported date range\nif (locale.equals(JAPANESE_IMPERIAL)) {\nthrow new ParseException(\n\"(The \" +locale + \" locale does not support dates before 1868 AD)\\n\" +\n\"Unparseable date: \\\"\"+source+\"\\\" does not match \"+parsePattern.pattern(), 0);\n}\nthrow new ParseException(\"Unparseable date: \\\"\"+source+\"\\\" does not match \"+parsePattern.pattern(), 0);\n}\nreturn date;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:parse(Ljava/lang/String;Ljava/text/ParsePosition;)Ljava/util/Date;",
                                    "method_body": "public Date parse(String source, ParsePosition pos) {\nint offset= pos.getIndex();\nMatcher matcher= parsePattern.matcher(source.substring(offset));\nif(!matcher.lookingAt()) {\nreturn null;\n}\n// timing tests indicate getting new instance is 19% faster than cloning\nCalendar cal= Calendar.getInstance(timeZone, locale);\ncal.clear();\n\nfor(int i=0; i<strategies.length;) {\nStrategy strategy= strategies[i++];\nstrategy.setCalendar(this, cal, matcher.group(i));\n}\npos.setIndex(offset+matcher.end());\nreturn cal.getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:escapeRegex(Ljava/lang/StringBuilder;Ljava/lang/String;Z)Ljava/lang/StringBuilder;",
                                    "method_body": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\nboolean wasWhite= false;\nfor(int i= 0; i<value.length(); ++i) {\nchar c= value.charAt(i);\nif(Character.isWhitespace(c)) {\nif(!wasWhite) {\nwasWhite= true;\nregex.append(\"\\\\s*+\");\n}\ncontinue;\n}\nwasWhite= false;\nswitch(c) {\ncase '\\'':\nif(unquote) {\nif(++i==value.length()) {\nreturn regex;\n}\nc= value.charAt(i);\n}\nbreak;\ncase '?':\ncase '[':\ncase ']':\ncase '(':\ncase ')':\ncase '{':\ncase '}':\ncase '\\\\':\ncase '|':\ncase '*':\ncase '+':\ncase '^':\ncase '$':\ncase '.':\nregex.append('\\\\');\n}\nregex.append(c);\n}\nreturn regex;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:getDisplayNames(I)[Lorg/apache/commons/lang3/time/FastDateParser$KeyValue;",
                                    "method_body": "KeyValue[] getDisplayNames(int field) {\nInteger fieldInt = Integer.valueOf(field);\nKeyValue[] fieldKeyValues= nameValues.get(fieldInt);\nif(fieldKeyValues==null) {\nDateFormatSymbols symbols= DateFormatSymbols.getInstance(locale);\nswitch(field) {\ncase Calendar.ERA:\n// DateFormatSymbols#getEras() only returns AD/BC or translations\n// It does not work for the Thai Buddhist or Japanese Imperial calendars.\n// see: https://issues.apache.org/jira/browse/TRINIDAD-2126\nCalendar c = Calendar.getInstance(locale);\n// N.B. Some calendars have different short and long symbols, e.g. ja_JP_JP\nString[] shortEras = toArray(c.getDisplayNames(Calendar.ERA, Calendar.SHORT, locale));\nString[] longEras = toArray(c.getDisplayNames(Calendar.ERA, Calendar.LONG, locale));\nfieldKeyValues= createKeyValues(longEras, shortEras);\nbreak;\ncase Calendar.DAY_OF_WEEK:\nfieldKeyValues= createKeyValues(symbols.getWeekdays(), symbols.getShortWeekdays());\nbreak;\ncase Calendar.AM_PM:\nfieldKeyValues= createKeyValues(symbols.getAmPmStrings(), null);\nbreak;\ncase Calendar.MONTH:\nfieldKeyValues= createKeyValues(symbols.getMonths(), symbols.getShortMonths());\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"Invalid field value \"+field);\n}\nKeyValue[] prior = nameValues.putIfAbsent(fieldInt, fieldKeyValues);\nif(prior!=null) {\nfieldKeyValues= prior;\n}\n}\nreturn fieldKeyValues;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:createKeyValues([Ljava/lang/String;[Ljava/lang/String;)[Lorg/apache/commons/lang3/time/FastDateParser$KeyValue;",
                                    "method_body": "private static KeyValue[] createKeyValues(String[] longValues, String[] shortValues) {\nKeyValue[] fieldKeyValues= new KeyValue[count(longValues)+count(shortValues)];\ncopy(fieldKeyValues, copy(fieldKeyValues, 0, longValues), shortValues);\nArrays.sort(fieldKeyValues, IGNORE_CASE_COMPARATOR);\nreturn fieldKeyValues;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:count([Ljava/lang/String;)I",
                                    "method_body": "private static int count(String[] values) {\nint count= 0;\nif(values!=null) {\nfor(String value : values) {\nif(value.length()>0) {\n++count;\n}\n}\n}\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:copy([Lorg/apache/commons/lang3/time/FastDateParser$KeyValue;I[Ljava/lang/String;)I",
                                    "method_body": "private static int copy(KeyValue[] fieldKeyValues, int offset, String[] values) {\nif(values!=null) {\nfor(int i= 0; i<values.length; ++i) {\nString value= values[i];\nif(value.length()>0) {\nfieldKeyValues[offset++]= new KeyValue(value, i);\n}\n}\n}\nreturn offset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:isNextNumber()Z",
                                    "method_body": "boolean isNextNumber() {\nreturn nextStrategy!=null && nextStrategy.isNumber();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser:getStrategy(Ljava/lang/String;)Lorg/apache/commons/lang3/time/FastDateParser$Strategy;",
                                    "method_body": "boolean isNumber();\n/**\n* Set the Calendar with the parsed field\n* @param parser The parser calling this strategy\n* @param cal The <code>Calendar</code> to set\n* @param value The parsed field to translate and set in cal\n*/\nvoid setCalendar(FastDateParser parser, Calendar cal, String value);\n/**\n* Generate a <code>Pattern</code> regular expression to the <code>StringBuilder</code>\n* which will accept this field\n* @param parser The parser calling this strategy\n* @param regex The <code>StringBuilder</code> to append to\n* @return true, if this field will set the calendar;\n* false, if this field is a constant value\n*/\nboolean addRegex(FastDateParser parser, StringBuilder regex);\n}\n\n/**\n* A <code>Pattern</code> to parse the user supplied SimpleDateFormat pattern\n*/\nprivate static final Pattern formatPattern= Pattern.compile(\n\"D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++\");\n\n/**\n* Obtain a Strategy given a field from a SimpleDateFormat pattern\n* @param formatField A sub-sequence of the SimpleDateFormat pattern\n* @return The Strategy that will handle parsing for the field\n*/\nprivate Strategy getStrategy(String formatField) {\nswitch(formatField.charAt(0)) {\ncase '\\'':\nif(formatField.length()>2) {\nformatField= formatField.substring(1, formatField.length()-1);\n}\n//$FALL-THROUGH$\ndefault:\nreturn new CopyQuotedStrategy(formatField);\ncase 'D':\nreturn DAY_OF_YEAR_STRATEGY;\ncase 'E':\nreturn DAY_OF_WEEK_STRATEGY;\ncase 'F':\nreturn DAY_OF_WEEK_IN_MONTH_STRATEGY;\ncase 'G':\nreturn ERA_STRATEGY;\ncase 'H':\nreturn MODULO_HOUR_OF_DAY_STRATEGY;\ncase 'K':\nreturn HOUR_STRATEGY;\ncase 'M':\nreturn formatField.length()>=3 ?TEXT_MONTH_STRATEGY :NUMBER_MONTH_STRATEGY;\ncase 'S':\nreturn MILLISECOND_STRATEGY;\ncase 'W':\nreturn WEEK_OF_MONTH_STRATEGY;\ncase 'Z':\nbreak;\ncase 'a':\nreturn AM_PM_STRATEGY;\ncase 'd':\nreturn DAY_OF_MONTH_STRATEGY;\ncase 'h':\nreturn MODULO_HOUR_STRATEGY;\ncase 'k':\nreturn HOUR_OF_DAY_STRATEGY;\ncase 'm':\nreturn MINUTE_STRATEGY;\ncase 's':\nreturn SECOND_STRATEGY;\ncase 'w':\nreturn WEEK_OF_YEAR_STRATEGY;\ncase 'y':\nreturn formatField.length()>2 ?LITERAL_YEAR_STRATEGY :ABBREVIATED_YEAR_STRATEGY;\ncase 'z':\nbreak;\n}\nTimeZoneStrategy tzs= tzsCache.get(locale);\nif(tzs==null) {\ntzs= new TimeZoneStrategy(locale);\nTimeZoneStrategy inCache= tzsCache.putIfAbsent(locale, tzs);\nif(inCache!=null) {\nreturn inCache;\n}\n}\nreturn tzs;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$1:compare(Lorg/apache/commons/lang3/time/FastDateParser$KeyValue;Lorg/apache/commons/lang3/time/FastDateParser$KeyValue;)I",
                                    "method_body": "public int compare(KeyValue left, KeyValue right) {\nreturn left.key.compareToIgnoreCase(right.key);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$NumberStrategy:<init>(I)V",
                                    "method_body": "NumberStrategy(int field) {\nthis.field= field;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$NumberStrategy:addRegex(Lorg/apache/commons/lang3/time/FastDateParser;Ljava/lang/StringBuilder;)Z",
                                    "method_body": "public boolean addRegex(FastDateParser parser, StringBuilder regex) {\nif(parser.isNextNumber()) {\nregex.append(\"(\\\\p{IsNd}{\").append(parser.getFieldWidth()).append(\"}+)\");\n}\nelse {\nregex.append(\"(\\\\p{IsNd}++)\");\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$NumberStrategy:setCalendar(Lorg/apache/commons/lang3/time/FastDateParser;Ljava/util/Calendar;Ljava/lang/String;)V",
                                    "method_body": "public void setCalendar(FastDateParser parser, Calendar cal, String value) {\ncal.set(field, modify(Integer.parseInt(value)));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$TextStrategy:<init>(I)V",
                                    "method_body": "TextStrategy(int field) {\nthis.field= field;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$TextStrategy:addRegex(Lorg/apache/commons/lang3/time/FastDateParser;Ljava/lang/StringBuilder;)Z",
                                    "method_body": "public boolean addRegex(FastDateParser parser, StringBuilder regex) {\nregex.append('(');\nfor(KeyValue textKeyValue : parser.getDisplayNames(field)) {\nescapeRegex(regex, textKeyValue.key, false).append('|');\n}\nregex.setCharAt(regex.length()-1, ')');\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$TextStrategy:setCalendar(Lorg/apache/commons/lang3/time/FastDateParser;Ljava/util/Calendar;Ljava/lang/String;)V",
                                    "method_body": "public void setCalendar(FastDateParser parser, Calendar cal, String value) {\nKeyValue[] textKeyValues= parser.getDisplayNames(field);\nint idx= Arrays.binarySearch(textKeyValues, new KeyValue(value, -1), IGNORE_CASE_COMPARATOR);\nif(idx<0) {\nStringBuilder sb= new StringBuilder(value);\nsb.append(\" not in (\");\nfor(KeyValue textKeyValue : textKeyValues) {\nsb.append(textKeyValue.key).append(' ');\n}\nsb.setCharAt(sb.length()-1, ')');\nthrow new IllegalArgumentException(sb.toString());\n}\ncal.set(field, textKeyValues[idx].value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$3:modify(I)I",
                                    "method_body": "public int modify(int iValue) {\nreturn iValue-1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$CopyQuotedStrategy:<init>(Ljava/lang/String;)V",
                                    "method_body": "CopyQuotedStrategy(String formatField) {\nthis.formatField= formatField;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$CopyQuotedStrategy:isNumber()Z",
                                    "method_body": "public boolean isNumber() {\nchar c= formatField.charAt(0);\nif(c=='\\'') {\nc= formatField.charAt(1);\n}\nreturn Character.isDigit(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$CopyQuotedStrategy:addRegex(Lorg/apache/commons/lang3/time/FastDateParser;Ljava/lang/StringBuilder;)Z",
                                    "method_body": "public boolean addRegex(FastDateParser parser, StringBuilder regex) {\nescapeRegex(regex, formatField, true);\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateParser$KeyValue:<init>(Ljava/lang/String;I)V",
                                    "method_body": "public KeyValue(String key, int value) {\nthis.key= key;\nthis.value= value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:<init>(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)V",
                                    "method_body": "protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {\nprinter= new FastDatePrinter(pattern, timeZone, locale);\nparser= new FastDateParser(pattern, timeZone, locale);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 2L;\n\n/**\n* FULL locale dependent date or time style.\n*/\npublic static final int FULL = DateFormat.FULL;\n/**\n* LONG locale dependent date or time style.\n*/\npublic static final int LONG = DateFormat.LONG;\n/**\n* MEDIUM locale dependent date or time style.\n*/\npublic static final int MEDIUM = DateFormat.MEDIUM;\n/**\n* SHORT locale dependent date or time style.\n*/\npublic static final int SHORT = DateFormat.SHORT;\n\nprivate static final FormatCache<FastDateFormat> cache= new FormatCache<FastDateFormat>() {\n@Override\nprotected FastDateFormat createInstance(String pattern, TimeZone timeZone, Locale locale) {\nreturn new FastDateFormat(pattern, timeZone, locale);\n}\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:getInstance(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)Lorg/apache/commons/lang3/time/FastDateFormat;",
                                    "method_body": "public static FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {\nreturn cache.getInstance(pattern, timeZone, locale);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:parse(Ljava/lang/String;)Ljava/util/Date;",
                                    "method_body": "public Date parse(String source) throws ParseException {\nreturn parser.parse(source);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FormatCache:<clinit>()V",
                                    "method_body": "static final int NONE= -1;\n\nprivate final ConcurrentMap<MultipartKey, F> cInstanceCache\n= new ConcurrentHashMap<MultipartKey, F>(7);\n\nprivate static final ConcurrentMap<MultipartKey, String> cDateTimeInstanceCache\n= new ConcurrentHashMap<MultipartKey, String>(7);\n\n/**\n* <p>Gets a formatter instance using the default pattern in the\n* default timezone and locale.</p>\n*\n* @return a date/time formatter\n*/\npublic F getInstance() {\nreturn getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, TimeZone.getDefault(), Locale.getDefault());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FormatCache:getInstance(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)Ljava/text/Format;",
                                    "method_body": "public F getInstance(String pattern, TimeZone timeZone, Locale locale) {\nif (pattern == null) {\nthrow new NullPointerException(\"pattern must not be null\");\n}\nif (timeZone == null) {\ntimeZone = TimeZone.getDefault();\n}\nif (locale == null) {\nlocale = Locale.getDefault();\n}\nMultipartKey key = new MultipartKey(pattern, timeZone, locale);\nF format = cInstanceCache.get(key);\nif (format == null) {\nformat = createInstance(pattern, timeZone, locale);\nF previousValue= cInstanceCache.putIfAbsent(key, format);\nif (previousValue != null) {\n// another thread snuck in and did the same work\n// we should return the instance that is in ConcurrentMap\nformat= previousValue;\n}\n}\nreturn format;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$1:createInstance(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)Lorg/apache/commons/lang3/time/FastDateFormat;",
                                    "method_body": "protected FastDateFormat createInstance(String pattern, TimeZone timeZone, Locale locale) {\nreturn new FastDateFormat(pattern, timeZone, locale);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FormatCache$MultipartKey:<init>([Ljava/lang/Object;)V",
                                    "method_body": "public MultipartKey(Object... keys) {\nthis.keys = keys;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FormatCache$MultipartKey:hashCode()I",
                                    "method_body": "public int hashCode() {\nif(hashCode==0) {\nint rc= 0;\nfor(Object key : keys) {\nif(key!=null) {\nrc= rc*7 + key.hashCode();\n}\n}\nhashCode= rc;\n}\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:<init>(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)V",
                                    "method_body": "protected FastDatePrinter(String pattern, TimeZone timeZone, Locale locale) {\nmPattern = pattern;\nmTimeZone = timeZone;\nmLocale = locale;\n\ninit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:<clinit>()V",
                                    "method_body": "private static ConcurrentMap<TimeZoneDisplayKey, String> cTimeZoneDisplayCache =\nnew ConcurrentHashMap<TimeZoneDisplayKey, String>(7);\n/**\n* <p>Gets the time zone display name, using a cache for performance.</p>\n*\n* @param tz  the zone to query\n* @param daylight  true if daylight savings\n* @param style  the style to use {@code TimeZone.LONG} or {@code TimeZone.SHORT}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:init()V",
                                    "method_body": "private void init() {\nList<Rule> rulesList = parsePattern();\nmRules = rulesList.toArray(new Rule[rulesList.size()]);\n\nint len = 0;\nfor (int i=mRules.length; --i >= 0; ) {\nlen += mRules[i].estimateLength();\n}\n\nmMaxLengthEstimate = len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:parsePattern()Ljava/util/List;",
                                    "method_body": "protected List<Rule> parsePattern() {\nDateFormatSymbols symbols = new DateFormatSymbols(mLocale);\nList<Rule> rules = new ArrayList<Rule>();\n\nString[] ERAs = symbols.getEras();\nString[] months = symbols.getMonths();\nString[] shortMonths = symbols.getShortMonths();\nString[] weekdays = symbols.getWeekdays();\nString[] shortWeekdays = symbols.getShortWeekdays();\nString[] AmPmStrings = symbols.getAmPmStrings();\n\nint length = mPattern.length();\nint[] indexRef = new int[1];\n\nfor (int i = 0; i < length; i++) {\nindexRef[0] = i;\nString token = parseToken(mPattern, indexRef);\ni = indexRef[0];\n\nint tokenLen = token.length();\nif (tokenLen == 0) {\nbreak;\n}\n\nRule rule;\nchar c = token.charAt(0);\n\nswitch (c) {\ncase 'G': // era designator (text)\nrule = new TextField(Calendar.ERA, ERAs);\nbreak;\ncase 'y': // year (number)\nif (tokenLen == 2) {\nrule = TwoDigitYearField.INSTANCE;\n} else {\nrule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);\n}\nbreak;\ncase 'M': // month in year (text and number)\nif (tokenLen >= 4) {\nrule = new TextField(Calendar.MONTH, months);\n} else if (tokenLen == 3) {\nrule = new TextField(Calendar.MONTH, shortMonths);\n} else if (tokenLen == 2) {\nrule = TwoDigitMonthField.INSTANCE;\n} else {\nrule = UnpaddedMonthField.INSTANCE;\n}\nbreak;\ncase 'd': // day in month (number)\nrule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\nbreak;\ncase 'h': // hour in am/pm (number, 1..12)\nrule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\nbreak;\ncase 'H': // hour in day (number, 0..23)\nrule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\nbreak;\ncase 'm': // minute in hour (number)\nrule = selectNumberRule(Calendar.MINUTE, tokenLen);\nbreak;\ncase 's': // second in minute (number)\nrule = selectNumberRule(Calendar.SECOND, tokenLen);\nbreak;\ncase 'S': // millisecond (number)\nrule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\nbreak;\ncase 'E': // day in week (text)\nrule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\nbreak;\ncase 'D': // day in year (number)\nrule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\nbreak;\ncase 'F': // day of week in month (number)\nrule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\nbreak;\ncase 'w': // week in year (number)\nrule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\nbreak;\ncase 'W': // week in month (number)\nrule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\nbreak;\ncase 'a': // am/pm marker (text)\nrule = new TextField(Calendar.AM_PM, AmPmStrings);\nbreak;\ncase 'k': // hour in day (1..24)\nrule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\nbreak;\ncase 'K': // hour in am/pm (0..11)\nrule = selectNumberRule(Calendar.HOUR, tokenLen);\nbreak;\ncase 'z': // time zone (text)\nif (tokenLen >= 4) {\nrule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n} else {\nrule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n}\nbreak;\ncase 'Z': // time zone (value)\nif (tokenLen == 1) {\nrule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n} else {\nrule = TimeZoneNumberRule.INSTANCE_COLON;\n}\nbreak;\ncase '\\'': // literal text\nString sub = token.substring(1);\nif (sub.length() == 1) {\nrule = new CharacterLiteral(sub.charAt(0));\n} else {\nrule = new StringLiteral(sub);\n}\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"Illegal pattern component: \" + token);\n}\n\nrules.add(rule);\n}\n\nreturn rules;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
                                    "method_body": "protected String parseToken(String pattern, int[] indexRef) {\nStringBuilder buf = new StringBuilder();\n\nint i = indexRef[0];\nint length = pattern.length();\n\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n// Scan a run of the same character, which indicates a time\n// pattern.\nbuf.append(c);\n\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append(c);\ni++;\n} else {\nbreak;\n}\n}\n} else {\n// This will identify token as text.\nbuf.append('\\'');\n\nboolean inLiteral = false;\n\nfor (; i < length; i++) {\nc = pattern.charAt(i);\n\nif (c == '\\'') {\nif (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n// '' is treated as escaped '\ni++;\nbuf.append(c);\n} else {\ninLiteral = !inLiteral;\n}\n} else if (!inLiteral &&\n(c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\ni--;\nbreak;\n} else {\nbuf.append(c);\n}\n}\n}\n\nindexRef[0] = i;\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$CharacterLiteral:<init>(C)V",
                                    "method_body": "void appendTo(StringBuffer buffer, int value);\n}\n\n/**\n* <p>Inner class to output a constant single character.</p>\n*/\nprivate static class CharacterLiteral implements Rule {\nprivate final char mValue;\n\n/**\n* Constructs a new instance of {@code CharacterLiteral}\n* to hold the specified value.\n*\n* @param value the character literal\n*/\nCharacterLiteral(char value) {\nmValue = value;\n}\n\n/**\n* {@inheritDoc}\n*/\n@Override\npublic int estimateLength() {\nreturn 1;\n}\n\n/**\n* {@inheritDoc}\n*/\n@Override\npublic void appendTo(StringBuffer buffer, Calendar calendar) {\nbuffer.append(mValue);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$CharacterLiteral:estimateLength()I",
                                    "method_body": "void appendTo(StringBuffer buffer, int value);\n}\n\n/**\n* <p>Inner class to output a constant single character.</p>\n*/\nprivate static class CharacterLiteral implements Rule {\nprivate final char mValue;\n\n/**\n* Constructs a new instance of {@code CharacterLiteral}\n* to hold the specified value.\n*\n* @param value the character literal\n*/\nCharacterLiteral(char value) {\nmValue = value;\n}\n\n/**\n* {@inheritDoc}\n*/\n@Override\npublic int estimateLength() {\nreturn 1;\n}\n\n/**\n* {@inheritDoc}\n*/\n@Override\npublic void appendTo(StringBuffer buffer, Calendar calendar) {\nbuffer.append(mValue);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$UnpaddedMonthField:<init>()V",
                                    "method_body": "UnpaddedMonthField() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$UnpaddedMonthField:<clinit>()V",
                                    "method_body": "static final UnpaddedMonthField INSTANCE = new UnpaddedMonthField();\n\n/**\n* Constructs an instance of {@code UnpaddedMonthField}."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$UnpaddedMonthField:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nreturn 2;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TextField:<init>(I[Ljava/lang/String;)V",
                                    "method_body": "TextField(int field, String[] values) {\nmField = field;\nmValues = values;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDatePrinter$TextField:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nint max = 0;\nfor (int i=mValues.length; --i >= 0; ) {\nint len = mValues[i].length();\nif (len > max) {\nmax = len;\n}\n}\nreturn max;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 11,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.RandomStringUtilsTest.testLANG807",
                            "test_body": "133: public void testLANG807() {\n134: try {\n135: RandomStringUtils.random(3,5,5,false,false);\n136: fail(\"Expected IllegalArgumentException\");\n137: } catch (IllegalArgumentException ex) { // distinguish from Random#nextInt message\n138: final String msg = ex.getMessage();\n139: assertTrue(\"Message (\" + msg + \") must contain 'start'\", msg.contains(\"start\"));\n140: assertTrue(\"Message (\" + msg + \") must contain 'end'\", msg.contains(\"end\"));\n141: }\n142: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.RandomStringUtils:<clinit>()V",
                                    "method_body": "private static final Random RANDOM = new Random();\n\n/**\n* <p>{@code RandomStringUtils} instances should NOT be constructed in"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.RandomStringUtils:random(IIIZZ)Ljava/lang/String;",
                                    "method_body": "public static String random(int count, int start, int end, boolean letters, boolean numbers) {\nreturn random(count, start, end, letters, numbers, null, RANDOM);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.RandomStringUtils:random(IIIZZ[CLjava/util/Random;)Ljava/lang/String;",
                                    "method_body": "public static String random(int count, int start, int end, boolean letters, boolean numbers,\nchar[] chars, Random random) {\nif (count == 0) {\nreturn \"\";\n} else if (count < 0) {\nthrow new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n}\nif (chars != null && chars.length == 0) {\nthrow new IllegalArgumentException(\"The chars array must not be empty\");\n}\n\nif (start == 0 && end == 0) {\nif (chars != null) {\nend = chars.length;\n} else {\nif (!letters && !numbers) {\nend = Integer.MAX_VALUE;\n} else {\nend = 'z' + 1;\nstart = ' ';\n}\n}\n}\n\nchar[] buffer = new char[count];\nint gap = end - start;\n\nwhile (count-- != 0) {\nchar ch;\nif (chars == null) {\nch = (char) (random.nextInt(gap) + start);\n} else {\nch = chars[random.nextInt(gap) + start];\n}\nif (letters && Character.isLetter(ch)\n|| numbers && Character.isDigit(ch)\n|| !letters && !numbers) {\nif(ch >= 56320 && ch <= 57343) {\nif(count == 0) {\ncount++;\n} else {\n// low surrogate, insert high surrogate after putting it in\nbuffer[count] = ch;\ncount--;\nbuffer[count] = (char) (55296 + random.nextInt(128));\n}\n} else if(ch >= 55296 && ch <= 56191) {\nif(count == 0) {\ncount++;\n} else {\n// high surrogate, insert low surrogate before putting it in\nbuffer[count] = (char) (56320 + random.nextInt(128));\ncount--;\nbuffer[count] = ch;\n}\n} else if(ch >= 56192 && ch <= 56319) {\n// private high surrogate, no effing clue, so skip it\ncount++;\n} else {\nbuffer[count] = ch;\n}\n} else {\ncount++;\n}\n}\nreturn new String(buffer);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 12,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.RandomStringUtilsTest.testLANG805",
                            "test_body": "128: public void testLANG805() {\n129: long seed = System.currentTimeMillis();\n130: assertEquals(\"aaa\", RandomStringUtils.random(3,0,0,false,false,new char[]{'a'},new Random(seed)));\n131: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.RandomStringUtils:<clinit>()V",
                                    "method_body": "private static final Random RANDOM = new Random();\n\n/**\n* <p>{@code RandomStringUtils} instances should NOT be constructed in"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.RandomStringUtils:random(IIIZZ[CLjava/util/Random;)Ljava/lang/String;",
                                    "method_body": "public static String random(int count, int start, int end, boolean letters, boolean numbers,\nchar[] chars, Random random) {\nif (count == 0) {\nreturn \"\";\n} else if (count < 0) {\nthrow new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n}\n\nif (start == 0 && end == 0) {\nif (!letters && !numbers) {\nend = Integer.MAX_VALUE;\n} else {\nend = 'z' + 1;\nstart = ' ';\n}\n}\n\nchar[] buffer = new char[count];\nint gap = end - start;\n\nwhile (count-- != 0) {\nchar ch;\nif (chars == null) {\nch = (char) (random.nextInt(gap) + start);\n} else {\nch = chars[random.nextInt(gap) + start];\n}\nif (letters && Character.isLetter(ch)\n|| numbers && Character.isDigit(ch)\n|| !letters && !numbers) {\nif(ch >= 56320 && ch <= 57343) {\nif(count == 0) {\ncount++;\n} else {\n// low surrogate, insert high surrogate after putting it in\nbuffer[count] = ch;\ncount--;\nbuffer[count] = (char) (55296 + random.nextInt(128));\n}\n} else if(ch >= 55296 && ch <= 56191) {\nif(count == 0) {\ncount++;\n} else {\n// high surrogate, insert low surrogate before putting it in\nbuffer[count] = (char) (56320 + random.nextInt(128));\ncount--;\nbuffer[count] = ch;\n}\n} else if(ch >= 56192 && ch <= 56319) {\n// private high surrogate, no effing clue, so skip it\ncount++;\n} else {\nbuffer[count] = ch;\n}\n} else {\ncount++;\n}\n}\nreturn new String(buffer);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.RandomStringUtilsTest.testExceptions",
                            "test_body": "133: public void testExceptions() {\n134: final char[] DUMMY = new char[]{'a'}; // valid char array\n135: try {\n136: RandomStringUtils.random(-1);\n137: fail();\n138: } catch (IllegalArgumentException ex) {}\n139: try {\n140: RandomStringUtils.random(-1, true, true);\n141: fail();\n142: } catch (IllegalArgumentException ex) {}\n143: try {\n144: RandomStringUtils.random(-1, DUMMY);\n145: fail();\n146: } catch (IllegalArgumentException ex) {}\n147: try {\n148: RandomStringUtils.random(1, new char[0]); // must not provide empty array => IAE\n149: fail();\n150: } catch (IllegalArgumentException ex) {}\n151: try {\n152: RandomStringUtils.random(-1, \"\");\n153: fail();\n154: } catch (IllegalArgumentException ex) {}\n155: try {\n156: RandomStringUtils.random(-1, (String)null);\n157: fail();\n158: } catch (IllegalArgumentException ex) {}\n159: try {\n160: RandomStringUtils.random(-1, 'a', 'z', false, false);\n161: fail();\n162: } catch (IllegalArgumentException ex) {}\n163: try {\n164: RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY);\n165: fail();\n166: } catch (IllegalArgumentException ex) {}\n167: try {\n168: RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY, new Random());\n169: fail();\n170: } catch (IllegalArgumentException ex) {}\n171: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.RandomStringUtils:<clinit>()V",
                                    "method_body": "private static final Random RANDOM = new Random();\n\n/**\n* <p>{@code RandomStringUtils} instances should NOT be constructed in"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.RandomStringUtils:random(I)Ljava/lang/String;",
                                    "method_body": "public static String random(int count) {\nreturn random(count, false, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.RandomStringUtils:random(IZZ)Ljava/lang/String;",
                                    "method_body": "public static String random(int count, boolean letters, boolean numbers) {\nreturn random(count, 0, 0, letters, numbers);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.RandomStringUtils:random(IIIZZ)Ljava/lang/String;",
                                    "method_body": "public static String random(int count, int start, int end, boolean letters, boolean numbers) {\nreturn random(count, start, end, letters, numbers, null, RANDOM);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.RandomStringUtils:random(IIIZZ[CLjava/util/Random;)Ljava/lang/String;",
                                    "method_body": "public static String random(int count, int start, int end, boolean letters, boolean numbers,\nchar[] chars, Random random) {\nif (count == 0) {\nreturn \"\";\n} else if (count < 0) {\nthrow new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n}\n\nif (start == 0 && end == 0) {\nif (!letters && !numbers) {\nend = Integer.MAX_VALUE;\n} else {\nend = 'z' + 1;\nstart = ' ';\n}\n}\n\nchar[] buffer = new char[count];\nint gap = end - start;\n\nwhile (count-- != 0) {\nchar ch;\nif (chars == null) {\nch = (char) (random.nextInt(gap) + start);\n} else {\nch = chars[random.nextInt(gap) + start];\n}\nif (letters && Character.isLetter(ch)\n|| numbers && Character.isDigit(ch)\n|| !letters && !numbers) {\nif(ch >= 56320 && ch <= 57343) {\nif(count == 0) {\ncount++;\n} else {\n// low surrogate, insert high surrogate after putting it in\nbuffer[count] = ch;\ncount--;\nbuffer[count] = (char) (55296 + random.nextInt(128));\n}\n} else if(ch >= 55296 && ch <= 56191) {\nif(count == 0) {\ncount++;\n} else {\n// high surrogate, insert low surrogate before putting it in\nbuffer[count] = (char) (56320 + random.nextInt(128));\ncount--;\nbuffer[count] = ch;\n}\n} else if(ch >= 56192 && ch <= 56319) {\n// private high surrogate, no effing clue, so skip it\ncount++;\n} else {\nbuffer[count] = ch;\n}\n} else {\ncount++;\n}\n}\nreturn new String(buffer);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.RandomStringUtils:random(I[C)Ljava/lang/String;",
                                    "method_body": "public static String random(int count, char... chars) {\nif (chars == null) {\nreturn random(count, 0, 0, false, false, null, RANDOM);\n}\nreturn random(count, 0, chars.length, false, false, chars, RANDOM);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 13,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.SerializationUtilsTest.testPrimitiveTypeClassSerialization",
                            "test_body": "368: public void testPrimitiveTypeClassSerialization() {\n369: Class<?>[] primitiveTypes = { byte.class, short.class, int.class, long.class, float.class, double.class,\n370: boolean.class, char.class, void.class };\n371: 372: for (Class<?> primitiveType : primitiveTypes) {\n373: Class<?> clone = SerializationUtils.clone(primitiveType);\n374: assertEquals(primitiveType, clone);\n375: }\n376: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SerializationException:<init>(Ljava/lang/String;Ljava/lang/Throwable;)V",
                                    "method_body": "public SerializationException(String msg, Throwable cause) {\nsuper(msg, cause);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SerializationUtils:clone(Ljava/io/Serializable;)Ljava/io/Serializable;",
                                    "method_body": "public static <T extends Serializable> T clone(T object) {\nif (object == null) {\nreturn null;\n}\nbyte[] objectData = serialize(object);\nByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n\nClassLoaderAwareObjectInputStream in = null;\ntry {\n// stream closed in the finally\nin = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader());\n/*\n* when we serialize and deserialize an object,\n* it is reasonable to assume the deserialized object\n* is of the same type as the original serialized object\n*/\n@SuppressWarnings(\"unchecked\") // see above\nT readObject = (T) in.readObject();\nreturn readObject;\n\n} catch (ClassNotFoundException ex) {\nthrow new SerializationException(\"ClassNotFoundException while reading cloned object data\", ex);\n} catch (IOException ex) {\nthrow new SerializationException(\"IOException while reading cloned object data\", ex);\n} finally {\ntry {\nif (in != null) {\nin.close();\n}\n} catch (IOException ex) {\nthrow new SerializationException(\"IOException on closing cloned object data InputStream.\", ex);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SerializationUtils:serialize(Ljava/io/Serializable;Ljava/io/OutputStream;)V",
                                    "method_body": "public static void serialize(Serializable obj, OutputStream outputStream) {\nif (outputStream == null) {\nthrow new IllegalArgumentException(\"The OutputStream must not be null\");\n}\nObjectOutputStream out = null;\ntry {\n// stream closed in the finally\nout = new ObjectOutputStream(outputStream);\nout.writeObject(obj);\n\n} catch (IOException ex) {\nthrow new SerializationException(ex);\n} finally {\ntry {\nif (out != null) {\nout.close();\n}\n} catch (IOException ex) { // NOPMD\n// ignore close exception\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SerializationUtils:serialize(Ljava/io/Serializable;)[B",
                                    "method_body": "public static byte[] serialize(Serializable obj) {\nByteArrayOutputStream baos = new ByteArrayOutputStream(512);\nserialize(obj, baos);\nreturn baos.toByteArray();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SerializationUtils$ClassLoaderAwareObjectInputStream:<init>(Ljava/io/InputStream;Ljava/lang/ClassLoader;)V",
                                    "method_body": "public ClassLoaderAwareObjectInputStream(InputStream in, ClassLoader classLoader) throws IOException {\nsuper(in);\nthis.classLoader = classLoader;\n\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SerializationUtils$ClassLoaderAwareObjectInputStream:resolveClass(Ljava/io/ObjectStreamClass;)Ljava/lang/Class;",
                                    "method_body": "protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\nString name = desc.getName();\ntry {\nreturn Class.forName(name, false, classLoader);\n} catch (ClassNotFoundException ex) {\nreturn Class.forName(name, false, Thread.currentThread().getContextClassLoader());\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 14,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest.testEquals",
                            "test_body": "486: public void testEquals() {\n487: final CharSequence fooCs = FOO, barCs = BAR, foobarCs = FOOBAR;\n488: assertTrue(StringUtils.equals(null, null));\n489: assertTrue(StringUtils.equals(fooCs, fooCs));\n490: assertTrue(StringUtils.equals(fooCs, (CharSequence) new StringBuilder(FOO)));\n491: assertTrue(StringUtils.equals(fooCs, (CharSequence) new String(new char[] { 'f', 'o', 'o' })));\n492: assertTrue(StringUtils.equals(fooCs, (CharSequence) new CustomCharSequence(FOO)));\n493: assertTrue(StringUtils.equals((CharSequence) new CustomCharSequence(FOO), fooCs));\n494: assertFalse(StringUtils.equals(fooCs, (CharSequence) new String(new char[] { 'f', 'O', 'O' })));\n495: assertFalse(StringUtils.equals(fooCs, barCs));\n496: assertFalse(StringUtils.equals(fooCs, null));\n497: assertFalse(StringUtils.equals(null, fooCs));\n498: assertFalse(StringUtils.equals(fooCs, foobarCs));\n499: assertFalse(StringUtils.equals(foobarCs, fooCs));\n500: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:<clinit>()V",
                                    "method_body": "public static final String EMPTY = \"\";\n\n/**\n* Represents a failed index search.\n* @since 2.1\n*/\npublic static final int INDEX_NOT_FOUND = -1;\n\n/**\n* <p>The maximum size to which the padding constant(s) can expand.</p>\n*/\nprivate static final int PAD_LIMIT = 8192;\n\n/**\n* A regex pattern for recognizing blocks of whitespace characters.\n*/\nprivate static final Pattern WHITESPACE_BLOCK = Pattern.compile(\"\\\\s+\");\n\n/**\n* <p>{@code StringUtils} instances should NOT be constructed in"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:equals(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean equals(CharSequence cs1, CharSequence cs2) {\nif (cs1 == cs2) {\nreturn true;\n}\nif (cs1 == null || cs2 == null) {\nreturn false;\n}\nreturn cs1.equals(cs2);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 15,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.reflect.TypeUtilsTest.testGetTypeArguments",
                            "test_body": "472: public void testGetTypeArguments() {\n473: Map<TypeVariable<?>, Type> typeVarAssigns;\n474: TypeVariable<?> treeSetTypeVar;\n475: Type typeArg;\n476: 477: typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class);\n478: treeSetTypeVar = Comparable.class.getTypeParameters()[0];\n479: Assert.assertTrue(\"Type var assigns for Comparable from Integer: \" + typeVarAssigns,\n480: typeVarAssigns.containsKey(treeSetTypeVar));\n481: typeArg = typeVarAssigns.get(treeSetTypeVar);\n482: Assert.assertEquals(\"Type argument of Comparable from Integer: \" + typeArg, Integer.class,\n483: typeVarAssigns.get(treeSetTypeVar));\n484: 485: typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class);\n486: treeSetTypeVar = Comparable.class.getTypeParameters()[0];\n487: Assert.assertTrue(\"Type var assigns for Comparable from int: \" + typeVarAssigns,\n488: typeVarAssigns.containsKey(treeSetTypeVar));\n489: typeArg = typeVarAssigns.get(treeSetTypeVar);\n490: Assert.assertEquals(\"Type argument of Comparable from int: \" + typeArg, Integer.class,\n491: typeVarAssigns.get(treeSetTypeVar));\n492: 493: Collection<Integer> col = Arrays.asList(new Integer[0]);\n494: typeVarAssigns = TypeUtils.getTypeArguments(List.class, Collection.class);\n495: treeSetTypeVar = Comparable.class.getTypeParameters()[0];\n496: Assert.assertFalse(\"Type var assigns for Collection from List: \" + typeVarAssigns,\n497: typeVarAssigns.containsKey(treeSetTypeVar));\n498: 499: typeVarAssigns = TypeUtils.getTypeArguments(AAAClass.BBBClass.class, AAClass.BBClass.class);\n500: Assert.assertTrue(typeVarAssigns.size() == 2);\n501: Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.class.getTypeParameters()[0]));\n502: Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.BBClass.class.getTypeParameters()[0]));\n503: 504: typeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class);\n505: Assert.assertEquals(2, typeVarAssigns.size());\n506: Assert.assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0]));\n507: Assert.assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1]));\n508: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.JavaVersion:<init>(Ljava/lang/String;IFLjava/lang/String;)V",
                                    "method_body": "JavaVersion(final float value, final String name) {\nthis.value = value;\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.JavaVersion:atLeast(Lorg/apache/commons/lang3/JavaVersion;)Z",
                                    "method_body": "public boolean atLeast(JavaVersion requiredVersion) {\nreturn this.value >= requiredVersion.value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.JavaVersion:get(Ljava/lang/String;)Lorg/apache/commons/lang3/JavaVersion;",
                                    "method_body": "static JavaVersion get(final String nom) {\nif (\"0.9\".equals(nom)) {\nreturn JAVA_0_9;\n} else if (\"1.1\".equals(nom)) {\nreturn JAVA_1_1;\n} else if (\"1.2\".equals(nom)) {\nreturn JAVA_1_2;\n} else if (\"1.3\".equals(nom)) {\nreturn JAVA_1_3;\n} else if (\"1.4\".equals(nom)) {\nreturn JAVA_1_4;\n} else if (\"1.5\".equals(nom)) {\nreturn JAVA_1_5;\n} else if (\"1.6\".equals(nom)) {\nreturn JAVA_1_6;\n} else if (\"1.7\".equals(nom)) {\nreturn JAVA_1_7;\n} else if (\"1.8\".equals(nom)) {\nreturn JAVA_1_8;\n} else {\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>\n* The {@code file.encoding} System Property."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nreturn isJavaVersionMatch(JAVA_SPECIFICATION_VERSION, versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nreturn isOSMatch(OS_NAME, OS_VERSION, osNamePrefix, osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatchesName(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatchesName(String osNamePrefix) {\nreturn isOSNameMatch(OS_NAME, osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\");\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:isJavaVersionAtLeast(Lorg/apache/commons/lang3/JavaVersion;)Z",
                                    "method_body": "public static boolean isJavaVersionAtLeast(JavaVersion requiredVersion) {\nreturn JAVA_SPECIFICATION_VERSION_AS_ENUM.atLeast(requiredVersion);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:isJavaVersionMatch(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "static boolean isJavaVersionMatch(String version, String versionPrefix) {\nif (version == null) {\nreturn false;\n}\nreturn version.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:isOSMatch(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "static boolean isOSMatch(String osName, String osVersion, String osNamePrefix, String osVersionPrefix) {\nif (osName == null || osVersion == null) {\nreturn false;\n}\nreturn osName.startsWith(osNamePrefix) && osVersion.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:isOSNameMatch(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "static boolean isOSNameMatch(String osName, String osNamePrefix) {\nif (osName == null) {\nreturn false;\n}\nreturn osName.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ClassUtils:<clinit>()V",
                                    "method_body": "public static final char PACKAGE_SEPARATOR_CHAR = '.';\n\n/**\n* <p>The package separator String: <code>\"&#x2e;\"</code>.</p>\n*/\npublic static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR);\n\n/**\n* <p>The inner class separator character: <code>'$' == {@value}</code>.</p>"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ClassUtils:addAbbreviation(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "private static void addAbbreviation(String primitive, String abbreviation) {\nabbreviationMap.put(primitive, abbreviation);\nreverseAbbreviationMap.put(abbreviation, primitive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ClassUtils:isAssignable(Ljava/lang/Class;Ljava/lang/Class;)Z",
                                    "method_body": "public static boolean isAssignable(Class<?> cls, Class<?> toClass) {\nreturn isAssignable(cls, toClass, SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_5));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ClassUtils:isAssignable(Ljava/lang/Class;Ljava/lang/Class;Z)Z",
                                    "method_body": "public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {\nif (toClass == null) {\nreturn false;\n}\n// have to check for null, as isAssignableFrom doesn't\nif (cls == null) {\nreturn !toClass.isPrimitive();\n}\n//autoboxing:\nif (autoboxing) {\nif (cls.isPrimitive() && !toClass.isPrimitive()) {\ncls = primitiveToWrapper(cls);\nif (cls == null) {\nreturn false;\n}\n}\nif (toClass.isPrimitive() && !cls.isPrimitive()) {\ncls = wrapperToPrimitive(cls);\nif (cls == null) {\nreturn false;\n}\n}\n}\nif (cls.equals(toClass)) {\nreturn true;\n}\nif (cls.isPrimitive()) {\nif (toClass.isPrimitive() == false) {\nreturn false;\n}\nif (Integer.TYPE.equals(cls)) {\nreturn Long.TYPE.equals(toClass)\n|| Float.TYPE.equals(toClass)\n|| Double.TYPE.equals(toClass);\n}\nif (Long.TYPE.equals(cls)) {\nreturn Float.TYPE.equals(toClass)\n|| Double.TYPE.equals(toClass);\n}\nif (Boolean.TYPE.equals(cls)) {\nreturn false;\n}\nif (Double.TYPE.equals(cls)) {\nreturn false;\n}\nif (Float.TYPE.equals(cls)) {\nreturn Double.TYPE.equals(toClass);\n}\nif (Character.TYPE.equals(cls)) {\nreturn Integer.TYPE.equals(toClass)\n|| Long.TYPE.equals(toClass)\n|| Float.TYPE.equals(toClass)\n|| Double.TYPE.equals(toClass);\n}\nif (Short.TYPE.equals(cls)) {\nreturn Integer.TYPE.equals(toClass)\n|| Long.TYPE.equals(toClass)\n|| Float.TYPE.equals(toClass)\n|| Double.TYPE.equals(toClass);\n}\nif (Byte.TYPE.equals(cls)) {\nreturn Short.TYPE.equals(toClass)\n|| Integer.TYPE.equals(toClass)\n|| Long.TYPE.equals(toClass)\n|| Float.TYPE.equals(toClass)\n|| Double.TYPE.equals(toClass);\n}\n// should never get here\nreturn false;\n}\nreturn toClass.isAssignableFrom(cls);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ClassUtils:primitiveToWrapper(Ljava/lang/Class;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> primitiveToWrapper(Class<?> cls) {\nClass<?> convertedClass = cls;\nif (cls != null && cls.isPrimitive()) {\nconvertedClass = primitiveWrapperMap.get(cls);\n}\nreturn convertedClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:isAssignable(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public static boolean isAssignable(Type type, Type toType) {\nreturn isAssignable(type, toType, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:isAssignable(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;Ljava/util/Map;)Z",
                                    "method_body": "private static boolean isAssignable(Type type, Type toType,\nMap<TypeVariable<?>, Type> typeVarAssigns) {\nif (toType == null || toType instanceof Class<?>) {\nreturn isAssignable(type, (Class<?>) toType);\n}\n\nif (toType instanceof ParameterizedType) {\nreturn isAssignable(type, (ParameterizedType) toType, typeVarAssigns);\n}\n\nif (toType instanceof GenericArrayType) {\nreturn isAssignable(type, (GenericArrayType) toType, typeVarAssigns);\n}\n\nif (toType instanceof WildcardType) {\nreturn isAssignable(type, (WildcardType) toType, typeVarAssigns);\n}\n\n// *\nif (toType instanceof TypeVariable<?>) {\nreturn isAssignable(type, (TypeVariable<?>) toType, typeVarAssigns);\n}\n// */\n\nthrow new IllegalStateException(\"found an unhandled type: \" + toType);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:isAssignable(Ljava/lang/reflect/Type;Ljava/lang/Class;)Z",
                                    "method_body": "private static boolean isAssignable(Type type, Class<?> toClass) {\nif (type == null) {\n// consistency with ClassUtils.isAssignable() behavior\nreturn toClass == null || !toClass.isPrimitive();\n}\n\n// only a null type can be assigned to null type which\n// would have cause the previous to return true\nif (toClass == null) {\nreturn false;\n}\n\n// all types are assignable to themselves\nif (toClass.equals(type)) {\nreturn true;\n}\n\nif (type instanceof Class<?>) {\n// just comparing two classes\nreturn ClassUtils.isAssignable((Class<?>) type, toClass);\n}\n\nif (type instanceof ParameterizedType) {\n// only have to compare the raw type to the class\nreturn isAssignable(getRawType((ParameterizedType) type), toClass);\n}\n\n// *\nif (type instanceof TypeVariable<?>) {\n// if any of the bounds are assignable to the class, then the\n// type is assignable to the class.\nfor (Type bound : ((TypeVariable<?>) type).getBounds()) {\nif (isAssignable(bound, toClass)) {\nreturn true;\n}\n}\n\nreturn false;\n}\n\n// the only classes to which a generic array type can be assigned\n// are class Object and array classes\nif (type instanceof GenericArrayType) {\nreturn toClass.equals(Object.class)\n|| toClass.isArray()\n&& isAssignable(((GenericArrayType) type).getGenericComponentType(), toClass\n.getComponentType());\n}\n\n// wildcard types are not assignable to a class (though one would think\n// \"? super Object\" would be assignable to Object)\nif (type instanceof WildcardType) {\nreturn false;\n}\n\nthrow new IllegalStateException(\"found an unhandled type: \" + type);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:getTypeArguments(Ljava/lang/reflect/Type;Ljava/lang/Class;)Ljava/util/Map;",
                                    "method_body": "public static Map<TypeVariable<?>, Type> getTypeArguments(Type type, Class<?> toClass) {\nreturn getTypeArguments(type, toClass, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:getTypeArguments(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/util/Map;)Ljava/util/Map;",
                                    "method_body": "private static Map<TypeVariable<?>, Type> getTypeArguments(Type type, Class<?> toClass,\nMap<TypeVariable<?>, Type> subtypeVarAssigns) {\nif (type instanceof Class<?>) {\nreturn getTypeArguments((Class<?>) type, toClass, subtypeVarAssigns);\n}\n\nif (type instanceof ParameterizedType) {\nreturn getTypeArguments((ParameterizedType) type, toClass, subtypeVarAssigns);\n}\n\nif (type instanceof GenericArrayType) {\nreturn getTypeArguments(((GenericArrayType) type).getGenericComponentType(), toClass\n.isArray() ? toClass.getComponentType() : toClass, subtypeVarAssigns);\n}\n\n// since wildcard types are not assignable to classes, should this just\n// return null?\nif (type instanceof WildcardType) {\nfor (Type bound : getImplicitUpperBounds((WildcardType) type)) {\n// find the first bound that is assignable to the target class\nif (isAssignable(bound, toClass)) {\nreturn getTypeArguments(bound, toClass, subtypeVarAssigns);\n}\n}\n\nreturn null;\n}\n\n// *\nif (type instanceof TypeVariable<?>) {\nfor (Type bound : getImplicitBounds((TypeVariable<?>) type)) {\n// find the first bound that is assignable to the target class\nif (isAssignable(bound, toClass)) {\nreturn getTypeArguments(bound, toClass, subtypeVarAssigns);\n}\n}\n\nreturn null;\n}\n// */\n\nthrow new IllegalStateException(\"found an unhandled type: \" + type);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:getTypeArguments(Ljava/lang/reflect/ParameterizedType;Ljava/lang/Class;Ljava/util/Map;)Ljava/util/Map;",
                                    "method_body": "private static Map<TypeVariable<?>, Type> getTypeArguments(\nParameterizedType parameterizedType, Class<?> toClass,\nMap<TypeVariable<?>, Type> subtypeVarAssigns) {\nClass<?> cls = getRawType(parameterizedType);\n\n// make sure they're assignable\nif (!isAssignable(cls, toClass)) {\nreturn null;\n}\n\nType ownerType = parameterizedType.getOwnerType();\nMap<TypeVariable<?>, Type> typeVarAssigns;\n\nif (ownerType instanceof ParameterizedType) {\n// get the owner type arguments first\nParameterizedType parameterizedOwnerType = (ParameterizedType) ownerType;\ntypeVarAssigns = getTypeArguments(parameterizedOwnerType,\ngetRawType(parameterizedOwnerType), subtypeVarAssigns);\n} else {\n// no owner, prep the type variable assignments map\ntypeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>()\n: new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n}\n\n// get the subject parameterized type's arguments\nType[] typeArgs = parameterizedType.getActualTypeArguments();\n// and get the corresponding type variables from the raw class\nTypeVariable<?>[] typeParams = cls.getTypeParameters();\n\n// map the arguments to their respective type variables\nfor (int i = 0; i < typeParams.length; i++) {\nType typeArg = typeArgs[i];\ntypeVarAssigns.put(typeParams[i], typeVarAssigns.containsKey(typeArg) ? typeVarAssigns\n.get(typeArg) : typeArg);\n}\n\nif (toClass.equals(cls)) {\n// target class has been reached. Done.\nreturn typeVarAssigns;\n}\n\n// walk the inheritance hierarchy until the target class is reached\nreturn getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:getTypeArguments(Ljava/lang/Class;Ljava/lang/Class;Ljava/util/Map;)Ljava/util/Map;",
                                    "method_body": "private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, Class<?> toClass,\nMap<TypeVariable<?>, Type> subtypeVarAssigns) {\n// make sure they're assignable\nif (!isAssignable(cls, toClass)) {\nreturn null;\n}\n\n// can't work with primitives\nif (cls.isPrimitive()) {\n// both classes are primitives?\nif (toClass.isPrimitive()) {\n// dealing with widening here. No type arguments to be\n// harvested with these two types.\nreturn new HashMap<TypeVariable<?>, Type>();\n}\n\n// work with wrapper the wrapper class instead of the primitive\ncls = ClassUtils.primitiveToWrapper(cls);\n}\n\n// create a copy of the incoming map, or an empty one if it's null\nHashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>()\n: new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n\n// has target class been reached?\nif (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {\nreturn typeVarAssigns;\n}\n\n// walk the inheritance hierarchy until the target class is reached\nreturn getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:getClosestParentType(Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "private static Type getClosestParentType(Class<?> cls, Class<?> superClass) {\n// only look at the interfaces if the super class is also an interface\nif (superClass.isInterface()) {\n// get the generic interfaces of the subject class\nType[] interfaceTypes = cls.getGenericInterfaces();\n// will hold the best generic interface match found\nType genericInterface = null;\n\n// find the interface closest to the super class\nfor (Type midType : interfaceTypes) {\nClass<?> midClass = null;\n\nif (midType instanceof ParameterizedType) {\nmidClass = getRawType((ParameterizedType) midType);\n} else if (midType instanceof Class<?>) {\nmidClass = (Class<?>) midType;\n} else {\nthrow new IllegalStateException(\"Unexpected generic\"\n+ \" interface type found: \" + midType);\n}\n\n// check if this interface is further up the inheritance chain\n// than the previously found match\nif (isAssignable(midClass, superClass)\n&& isAssignable(genericInterface, (Type) midClass)) {\ngenericInterface = midType;\n}\n}\n\n// found a match?\nif (genericInterface != null) {\nreturn genericInterface;\n}\n}\n\n// none of the interfaces were descendants of the target class, so the\n// super class has to be one, instead\nreturn cls.getGenericSuperclass();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:getRawType(Ljava/lang/reflect/ParameterizedType;)Ljava/lang/Class;",
                                    "method_body": "private static Class<?> getRawType(ParameterizedType parameterizedType) {\nType rawType = parameterizedType.getRawType();\n\n// check if raw type is a Class object\n// not currently necessary, but since the return type is Type instead of\n// Class, there's enough reason to believe that future versions of Java\n// may return other Type implementations. And type-safety checking is\n// rarely a bad idea.\nif (!(rawType instanceof Class<?>)) {\nthrow new IllegalStateException(\"Wait... What!? Type of rawType: \" + rawType);\n}\n\nreturn (Class<?>) rawType;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.reflect.TypeUtilsTest.testIsAssignable",
                            "test_body": "108: public void testIsAssignable() throws SecurityException, NoSuchMethodException,\n109: NoSuchFieldException {\n110: List list0 = null;\n111: List<Object> list1 = null;\n112: List<?> list2 = null;\n113: List<? super Object> list3 = null;\n114: List<String> list4 = null;\n115: List<? extends String> list5 = null;\n116: List<? super String> list6 = null;\n117: List[] list7 = null;\n118: List<Object>[] list8 = null;\n119: List<?>[] list9 = null;\n120: List<? super Object>[] list10 = null;\n121: List<String>[] list11 = null;\n122: List<? extends String>[] list12 = null;\n123: List<? super String>[] list13;\n124: Class<?> clazz = getClass();\n125: Method method = clazz.getMethod(\"dummyMethod\", List.class, List.class, List.class,\n126: List.class, List.class, List.class, List.class, List[].class, List[].class,\n127: List[].class, List[].class, List[].class, List[].class, List[].class);\n128: Type[] types = method.getGenericParameterTypes();\n129: //        list0 = list0;\n130: delegateBooleanAssertion(types, 0, 0, true);\n131: list1 = list0;\n132: delegateBooleanAssertion(types, 0, 1, true);\n133: list0 = list1;\n134: delegateBooleanAssertion(types, 1, 0, true);\n135: list2 = list0;\n136: delegateBooleanAssertion(types, 0, 2, true);\n137: list0 = list2;\n138: delegateBooleanAssertion(types, 2, 0, true);\n139: list3 = list0;\n140: delegateBooleanAssertion(types, 0, 3, true);\n141: list0 = list3;\n142: delegateBooleanAssertion(types, 3, 0, true);\n143: list4 = list0;\n144: delegateBooleanAssertion(types, 0, 4, true);\n145: list0 = list4;\n146: delegateBooleanAssertion(types, 4, 0, true);\n147: list5 = list0;\n148: delegateBooleanAssertion(types, 0, 5, true);\n149: list0 = list5;\n150: delegateBooleanAssertion(types, 5, 0, true);\n151: list6 = list0;\n152: delegateBooleanAssertion(types, 0, 6, true);\n153: list0 = list6;\n154: delegateBooleanAssertion(types, 6, 0, true);\n155: //        list1 = list1;\n156: delegateBooleanAssertion(types, 1, 1, true);\n157: list2 = list1;\n158: delegateBooleanAssertion(types, 1, 2, true);\n159: list1 = (List<Object>) list2;\n160: delegateBooleanAssertion(types, 2, 1, false);\n161: list3 = list1;\n162: delegateBooleanAssertion(types, 1, 3, true);\n163: list1 = (List<Object>) list3;\n164: delegateBooleanAssertion(types, 3, 1, false);\n165: // list4 = list1;\n166: delegateBooleanAssertion(types, 1, 4, false);\n167: // list1 = list4;\n168: delegateBooleanAssertion(types, 4, 1, false);\n169: // list5 = list1;\n170: delegateBooleanAssertion(types, 1, 5, false);\n171: // list1 = list5;\n172: delegateBooleanAssertion(types, 5, 1, false);\n173: list6 = list1;\n174: delegateBooleanAssertion(types, 1, 6, true);\n175: list1 = (List<Object>) list6;\n176: delegateBooleanAssertion(types, 6, 1, false);\n177: //        list2 = list2;\n178: delegateBooleanAssertion(types, 2, 2, true);\n179: list2 = list3;\n180: delegateBooleanAssertion(types, 2, 3, false);\n181: list2 = list4;\n182: delegateBooleanAssertion(types, 3, 2, true);\n183: list3 = (List<? super Object>) list2;\n184: delegateBooleanAssertion(types, 2, 4, false);\n185: list2 = list5;\n186: delegateBooleanAssertion(types, 4, 2, true);\n187: list4 = (List<String>) list2;\n188: delegateBooleanAssertion(types, 2, 5, false);\n189: list2 = list6;\n190: delegateBooleanAssertion(types, 5, 2, true);\n191: list5 = (List<? extends String>) list2;\n192: delegateBooleanAssertion(types, 2, 6, false);\n193: //        list3 = list3;\n194: delegateBooleanAssertion(types, 6, 2, true);\n195: list6 = (List<? super String>) list2;\n196: delegateBooleanAssertion(types, 3, 3, true);\n197: // list4 = list3;\n198: delegateBooleanAssertion(types, 3, 4, false);\n199: // list3 = list4;\n200: delegateBooleanAssertion(types, 4, 3, false);\n201: // list5 = list3;\n202: delegateBooleanAssertion(types, 3, 5, false);\n203: // list3 = list5;\n204: delegateBooleanAssertion(types, 5, 3, false);\n205: list6 = list3;\n206: delegateBooleanAssertion(types, 3, 6, true);\n207: list3 = (List<? super Object>) list6;\n208: delegateBooleanAssertion(types, 6, 3, false);\n209: //        list4 = list4;\n210: delegateBooleanAssertion(types, 4, 4, true);\n211: list5 = list4;\n212: delegateBooleanAssertion(types, 4, 5, true);\n213: list4 = (List<String>) list5;\n214: delegateBooleanAssertion(types, 5, 4, false);\n215: list6 = list4;\n216: delegateBooleanAssertion(types, 4, 6, true);\n217: list4 = (List<String>) list6;\n218: delegateBooleanAssertion(types, 6, 4, false);\n219: //        list5 = list5;\n220: delegateBooleanAssertion(types, 5, 5, true);\n221: list6 = (List<? super String>) list5;\n222: delegateBooleanAssertion(types, 5, 6, false);\n223: list5 = (List<? extends String>) list6;\n224: delegateBooleanAssertion(types, 6, 5, false);\n225: //        list6 = list6;\n226: delegateBooleanAssertion(types, 6, 6, true);\n227: 228: //        list7 = list7;\n229: delegateBooleanAssertion(types, 7, 7, true);\n230: list8 = list7;\n231: delegateBooleanAssertion(types, 7, 8, true);\n232: list7 = list8;\n233: delegateBooleanAssertion(types, 8, 7, true);\n234: list9 = list7;\n235: delegateBooleanAssertion(types, 7, 9, true);\n236: list7 = list9;\n237: delegateBooleanAssertion(types, 9, 7, true);\n238: list10 = list7;\n239: delegateBooleanAssertion(types, 7, 10, true);\n240: list7 = list10;\n241: delegateBooleanAssertion(types, 10, 7, true);\n242: list11 = list7;\n243: delegateBooleanAssertion(types, 7, 11, true);\n244: list7 = list11;\n245: delegateBooleanAssertion(types, 11, 7, true);\n246: list12 = list7;\n247: delegateBooleanAssertion(types, 7, 12, true);\n248: list7 = list12;\n249: delegateBooleanAssertion(types, 12, 7, true);\n250: list13 = list7;\n251: delegateBooleanAssertion(types, 7, 13, true);\n252: list7 = list13;\n253: delegateBooleanAssertion(types, 13, 7, true);\n254: //        list8 = list8;\n255: delegateBooleanAssertion(types, 8, 8, true);\n256: list9 = list8;\n257: delegateBooleanAssertion(types, 8, 9, true);\n258: list8 = (List<Object>[]) list9;\n259: delegateBooleanAssertion(types, 9, 8, false);\n260: list10 = list8;\n261: delegateBooleanAssertion(types, 8, 10, true);\n262: list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse\n263: delegateBooleanAssertion(types, 10, 8, false);\n264: // list11 = list8;\n265: delegateBooleanAssertion(types, 8, 11, false);\n266: // list8 = list11;\n267: delegateBooleanAssertion(types, 11, 8, false);\n268: // list12 = list8;\n269: delegateBooleanAssertion(types, 8, 12, false);\n270: // list8 = list12;\n271: delegateBooleanAssertion(types, 12, 8, false);\n272: list13 = list8;\n273: delegateBooleanAssertion(types, 8, 13, true);\n274: list8 = (List<Object>[]) list13;\n275: delegateBooleanAssertion(types, 13, 8, false);\n276: //        list9 = list9;\n277: delegateBooleanAssertion(types, 9, 9, true);\n278: list10 = (List<? super Object>[]) list9;\n279: delegateBooleanAssertion(types, 9, 10, false);\n280: list9 = list10;\n281: delegateBooleanAssertion(types, 10, 9, true);\n282: list11 = (List<String>[]) list9;\n283: delegateBooleanAssertion(types, 9, 11, false);\n284: list9 = list11;\n285: delegateBooleanAssertion(types, 11, 9, true);\n286: list12 = (List<? extends String>[]) list9;\n287: delegateBooleanAssertion(types, 9, 12, false);\n288: list9 = list12;\n289: delegateBooleanAssertion(types, 12, 9, true);\n290: list13 = (List<? super String>[]) list9;\n291: delegateBooleanAssertion(types, 9, 13, false);\n292: list9 = list13;\n293: delegateBooleanAssertion(types, 13, 9, true);\n294: //        list10 = list10;\n295: delegateBooleanAssertion(types, 10, 10, true);\n296: // list11 = list10;\n297: delegateBooleanAssertion(types, 10, 11, false);\n298: // list10 = list11;\n299: delegateBooleanAssertion(types, 11, 10, false);\n300: // list12 = list10;\n301: delegateBooleanAssertion(types, 10, 12, false);\n302: // list10 = list12;\n303: delegateBooleanAssertion(types, 12, 10, false);\n304: list13 = list10;\n305: delegateBooleanAssertion(types, 10, 13, true);\n306: list10 = (List<? super Object>[]) list13;\n307: delegateBooleanAssertion(types, 13, 10, false);\n308: //        list11 = list11;\n309: delegateBooleanAssertion(types, 11, 11, true);\n310: list12 = list11;\n311: delegateBooleanAssertion(types, 11, 12, true);\n312: list11 = (List<String>[]) list12;\n313: delegateBooleanAssertion(types, 12, 11, false);\n314: list13 = list11;\n315: delegateBooleanAssertion(types, 11, 13, true);\n316: list11 = (List<String>[]) list13;\n317: delegateBooleanAssertion(types, 13, 11, false);\n318: //        list12 = list12;\n319: delegateBooleanAssertion(types, 12, 12, true);\n320: list13 = (List<? super String>[]) list12;\n321: delegateBooleanAssertion(types, 12, 13, false);\n322: list12 = (List<? extends String>[]) list13;\n323: delegateBooleanAssertion(types, 13, 12, false);\n324: //        list13 = list13;\n325: delegateBooleanAssertion(types, 13, 13, true);\n326: Type disType = getClass().getField(\"dis\").getGenericType();\n327: // Reporter.log( ( ( ParameterizedType ) disType\n328: // ).getOwnerType().getClass().toString() );\n329: Type datType = getClass().getField(\"dat\").getGenericType();\n330: Type daType = getClass().getField(\"da\").getGenericType();\n331: Type uhderType = getClass().getField(\"uhder\").getGenericType();\n332: Type dingType = getClass().getField(\"ding\").getGenericType();\n333: Type testerType = getClass().getField(\"tester\").getGenericType();\n334: Type tester2Type = getClass().getField(\"tester2\").getGenericType();\n335: Type dat2Type = getClass().getField(\"dat2\").getGenericType();\n336: Type dat3Type = getClass().getField(\"dat3\").getGenericType();\n337: dis = dat;\n338: Assert.assertTrue(TypeUtils.isAssignable(datType, disType));\n339: // dis = da;\n340: Assert.assertFalse(TypeUtils.isAssignable(daType, disType));\n341: dis = uhder;\n342: Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType));\n343: dis = ding;\n344: Assert.assertFalse(String.format(\"type %s not assignable to %s!\", dingType, disType),\n345: TypeUtils.isAssignable(dingType, disType));\n346: dis = tester;\n347: Assert.assertTrue(TypeUtils.isAssignable(testerType, disType));\n348: // dis = tester2;\n349: Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType));\n350: // dat = dat2;\n351: Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType));\n352: // dat2 = dat;\n353: Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type));\n354: // dat = dat3;\n355: Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType));\n356: char ch = 0;\n357: boolean bo = false;\n358: byte by = 0;\n359: short sh = 0;\n360: int in = 0;\n361: long lo = 0;\n362: float fl = 0;\n363: double du = 0;\n364: du = ch;\n365: Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class));\n366: du = by;\n367: Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class));\n368: du = sh;\n369: Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class));\n370: du = in;\n371: Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class));\n372: du = lo;\n373: Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class));\n374: du = fl;\n375: Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class));\n376: lo = in;\n377: Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class));\n378: lo = Integer.valueOf(0);\n379: Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class));\n380: // Long lngW = 1;\n381: Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class));\n382: // lngW = Integer.valueOf( 0 );\n383: Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class));\n384: in = Integer.valueOf(0);\n385: Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class));\n386: Integer inte = in;\n387: Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class));\n388: Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class));\n389: Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class));\n390: Type intComparableType = getClass().getField(\"intComparable\").getGenericType();\n391: intComparable = 1;\n392: Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType));\n393: Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class));\n394: Serializable ser = 1;\n395: Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class));\n396: Type longComparableType = getClass().getField(\"longComparable\").getGenericType();\n397: // longComparable = 1;\n398: Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType));\n399: // longComparable = Integer.valueOf( 0 );\n400: Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType));\n401: // int[] ia;\n402: // long[] la = ia;\n403: Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class));\n404: Integer[] ia = null;\n405: Type caType = getClass().getField(\"intWildcardComparable\").getGenericType();\n406: intWildcardComparable = ia;\n407: Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType));\n408: // int[] ina = ia;\n409: Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class));\n410: int[] ina = null;\n411: Object[] oa;\n412: // oa = ina;\n413: Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class));\n414: oa = new Integer[0];\n415: Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class));\n416: Type bClassType = AClass.class.getField(\"bClass\").getGenericType();\n417: Type cClassType = AClass.class.getField(\"cClass\").getGenericType();\n418: Type dClassType = AClass.class.getField(\"dClass\").getGenericType();\n419: Type eClassType = AClass.class.getField(\"eClass\").getGenericType();\n420: Type fClassType = AClass.class.getField(\"fClass\").getGenericType();\n421: AClass aClass = new AClass(new AAClass<String>());\n422: aClass.bClass = aClass.cClass;\n423: Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType));\n424: aClass.bClass = aClass.dClass;\n425: Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType));\n426: aClass.bClass = aClass.eClass;\n427: Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType));\n428: aClass.bClass = aClass.fClass;\n429: Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType));\n430: aClass.cClass = aClass.dClass;\n431: Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType));\n432: aClass.cClass = aClass.eClass;\n433: Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType));\n434: aClass.cClass = aClass.fClass;\n435: Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType));\n436: aClass.dClass = aClass.eClass;\n437: Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType));\n438: aClass.dClass = aClass.fClass;\n439: Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType));\n440: aClass.eClass = aClass.fClass;\n441: Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType));\n442: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.JavaVersion:<init>(Ljava/lang/String;IFLjava/lang/String;)V",
                                    "method_body": "JavaVersion(final float value, final String name) {\nthis.value = value;\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.JavaVersion:atLeast(Lorg/apache/commons/lang3/JavaVersion;)Z",
                                    "method_body": "public boolean atLeast(JavaVersion requiredVersion) {\nreturn this.value >= requiredVersion.value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.JavaVersion:get(Ljava/lang/String;)Lorg/apache/commons/lang3/JavaVersion;",
                                    "method_body": "static JavaVersion get(final String nom) {\nif (\"0.9\".equals(nom)) {\nreturn JAVA_0_9;\n} else if (\"1.1\".equals(nom)) {\nreturn JAVA_1_1;\n} else if (\"1.2\".equals(nom)) {\nreturn JAVA_1_2;\n} else if (\"1.3\".equals(nom)) {\nreturn JAVA_1_3;\n} else if (\"1.4\".equals(nom)) {\nreturn JAVA_1_4;\n} else if (\"1.5\".equals(nom)) {\nreturn JAVA_1_5;\n} else if (\"1.6\".equals(nom)) {\nreturn JAVA_1_6;\n} else if (\"1.7\".equals(nom)) {\nreturn JAVA_1_7;\n} else if (\"1.8\".equals(nom)) {\nreturn JAVA_1_8;\n} else {\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>\n* The {@code file.encoding} System Property."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nreturn isJavaVersionMatch(JAVA_SPECIFICATION_VERSION, versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nreturn isOSMatch(OS_NAME, OS_VERSION, osNamePrefix, osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatchesName(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatchesName(String osNamePrefix) {\nreturn isOSNameMatch(OS_NAME, osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\");\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:isJavaVersionAtLeast(Lorg/apache/commons/lang3/JavaVersion;)Z",
                                    "method_body": "public static boolean isJavaVersionAtLeast(JavaVersion requiredVersion) {\nreturn JAVA_SPECIFICATION_VERSION_AS_ENUM.atLeast(requiredVersion);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:isJavaVersionMatch(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "static boolean isJavaVersionMatch(String version, String versionPrefix) {\nif (version == null) {\nreturn false;\n}\nreturn version.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:isOSMatch(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "static boolean isOSMatch(String osName, String osVersion, String osNamePrefix, String osVersionPrefix) {\nif (osName == null || osVersion == null) {\nreturn false;\n}\nreturn osName.startsWith(osNamePrefix) && osVersion.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:isOSNameMatch(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "static boolean isOSNameMatch(String osName, String osNamePrefix) {\nif (osName == null) {\nreturn false;\n}\nreturn osName.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ClassUtils:<clinit>()V",
                                    "method_body": "public static final char PACKAGE_SEPARATOR_CHAR = '.';\n\n/**\n* <p>The package separator String: <code>\"&#x2e;\"</code>.</p>\n*/\npublic static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR);\n\n/**\n* <p>The inner class separator character: <code>'$' == {@value}</code>.</p>"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ClassUtils:addAbbreviation(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "private static void addAbbreviation(String primitive, String abbreviation) {\nabbreviationMap.put(primitive, abbreviation);\nreverseAbbreviationMap.put(abbreviation, primitive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ClassUtils:isAssignable(Ljava/lang/Class;Ljava/lang/Class;)Z",
                                    "method_body": "public static boolean isAssignable(Class<?> cls, Class<?> toClass) {\nreturn isAssignable(cls, toClass, SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_5));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ClassUtils:isAssignable(Ljava/lang/Class;Ljava/lang/Class;Z)Z",
                                    "method_body": "public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {\nif (toClass == null) {\nreturn false;\n}\n// have to check for null, as isAssignableFrom doesn't\nif (cls == null) {\nreturn !toClass.isPrimitive();\n}\n//autoboxing:\nif (autoboxing) {\nif (cls.isPrimitive() && !toClass.isPrimitive()) {\ncls = primitiveToWrapper(cls);\nif (cls == null) {\nreturn false;\n}\n}\nif (toClass.isPrimitive() && !cls.isPrimitive()) {\ncls = wrapperToPrimitive(cls);\nif (cls == null) {\nreturn false;\n}\n}\n}\nif (cls.equals(toClass)) {\nreturn true;\n}\nif (cls.isPrimitive()) {\nif (toClass.isPrimitive() == false) {\nreturn false;\n}\nif (Integer.TYPE.equals(cls)) {\nreturn Long.TYPE.equals(toClass)\n|| Float.TYPE.equals(toClass)\n|| Double.TYPE.equals(toClass);\n}\nif (Long.TYPE.equals(cls)) {\nreturn Float.TYPE.equals(toClass)\n|| Double.TYPE.equals(toClass);\n}\nif (Boolean.TYPE.equals(cls)) {\nreturn false;\n}\nif (Double.TYPE.equals(cls)) {\nreturn false;\n}\nif (Float.TYPE.equals(cls)) {\nreturn Double.TYPE.equals(toClass);\n}\nif (Character.TYPE.equals(cls)) {\nreturn Integer.TYPE.equals(toClass)\n|| Long.TYPE.equals(toClass)\n|| Float.TYPE.equals(toClass)\n|| Double.TYPE.equals(toClass);\n}\nif (Short.TYPE.equals(cls)) {\nreturn Integer.TYPE.equals(toClass)\n|| Long.TYPE.equals(toClass)\n|| Float.TYPE.equals(toClass)\n|| Double.TYPE.equals(toClass);\n}\nif (Byte.TYPE.equals(cls)) {\nreturn Short.TYPE.equals(toClass)\n|| Integer.TYPE.equals(toClass)\n|| Long.TYPE.equals(toClass)\n|| Float.TYPE.equals(toClass)\n|| Double.TYPE.equals(toClass);\n}\n// should never get here\nreturn false;\n}\nreturn toClass.isAssignableFrom(cls);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:isAssignable(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public static boolean isAssignable(Type type, Type toType) {\nreturn isAssignable(type, toType, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:isAssignable(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;Ljava/util/Map;)Z",
                                    "method_body": "private static boolean isAssignable(Type type, Type toType,\nMap<TypeVariable<?>, Type> typeVarAssigns) {\nif (toType == null || toType instanceof Class<?>) {\nreturn isAssignable(type, (Class<?>) toType);\n}\n\nif (toType instanceof ParameterizedType) {\nreturn isAssignable(type, (ParameterizedType) toType, typeVarAssigns);\n}\n\nif (toType instanceof GenericArrayType) {\nreturn isAssignable(type, (GenericArrayType) toType, typeVarAssigns);\n}\n\nif (toType instanceof WildcardType) {\nreturn isAssignable(type, (WildcardType) toType, typeVarAssigns);\n}\n\n// *\nif (toType instanceof TypeVariable<?>) {\nreturn isAssignable(type, (TypeVariable<?>) toType, typeVarAssigns);\n}\n// */\n\nthrow new IllegalStateException(\"found an unhandled type: \" + toType);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:isAssignable(Ljava/lang/reflect/Type;Ljava/lang/Class;)Z",
                                    "method_body": "private static boolean isAssignable(Type type, Class<?> toClass) {\nif (type == null) {\n// consistency with ClassUtils.isAssignable() behavior\nreturn toClass == null || !toClass.isPrimitive();\n}\n\n// only a null type can be assigned to null type which\n// would have cause the previous to return true\nif (toClass == null) {\nreturn false;\n}\n\n// all types are assignable to themselves\nif (toClass.equals(type)) {\nreturn true;\n}\n\nif (type instanceof Class<?>) {\n// just comparing two classes\nreturn ClassUtils.isAssignable((Class<?>) type, toClass);\n}\n\nif (type instanceof ParameterizedType) {\n// only have to compare the raw type to the class\nreturn isAssignable(getRawType((ParameterizedType) type), toClass);\n}\n\n// *\nif (type instanceof TypeVariable<?>) {\n// if any of the bounds are assignable to the class, then the\n// type is assignable to the class.\nfor (Type bound : ((TypeVariable<?>) type).getBounds()) {\nif (isAssignable(bound, toClass)) {\nreturn true;\n}\n}\n\nreturn false;\n}\n\n// the only classes to which a generic array type can be assigned\n// are class Object and array classes\nif (type instanceof GenericArrayType) {\nreturn toClass.equals(Object.class)\n|| toClass.isArray()\n&& isAssignable(((GenericArrayType) type).getGenericComponentType(), toClass\n.getComponentType());\n}\n\n// wildcard types are not assignable to a class (though one would think\n// \"? super Object\" would be assignable to Object)\nif (type instanceof WildcardType) {\nreturn false;\n}\n\nthrow new IllegalStateException(\"found an unhandled type: \" + type);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:getTypeArguments(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/util/Map;)Ljava/util/Map;",
                                    "method_body": "private static Map<TypeVariable<?>, Type> getTypeArguments(Type type, Class<?> toClass,\nMap<TypeVariable<?>, Type> subtypeVarAssigns) {\nif (type instanceof Class<?>) {\nreturn getTypeArguments((Class<?>) type, toClass, subtypeVarAssigns);\n}\n\nif (type instanceof ParameterizedType) {\nreturn getTypeArguments((ParameterizedType) type, toClass, subtypeVarAssigns);\n}\n\nif (type instanceof GenericArrayType) {\nreturn getTypeArguments(((GenericArrayType) type).getGenericComponentType(), toClass\n.isArray() ? toClass.getComponentType() : toClass, subtypeVarAssigns);\n}\n\n// since wildcard types are not assignable to classes, should this just\n// return null?\nif (type instanceof WildcardType) {\nfor (Type bound : getImplicitUpperBounds((WildcardType) type)) {\n// find the first bound that is assignable to the target class\nif (isAssignable(bound, toClass)) {\nreturn getTypeArguments(bound, toClass, subtypeVarAssigns);\n}\n}\n\nreturn null;\n}\n\n// *\nif (type instanceof TypeVariable<?>) {\nfor (Type bound : getImplicitBounds((TypeVariable<?>) type)) {\n// find the first bound that is assignable to the target class\nif (isAssignable(bound, toClass)) {\nreturn getTypeArguments(bound, toClass, subtypeVarAssigns);\n}\n}\n\nreturn null;\n}\n// */\n\nthrow new IllegalStateException(\"found an unhandled type: \" + type);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:getTypeArguments(Ljava/lang/reflect/ParameterizedType;Ljava/lang/Class;Ljava/util/Map;)Ljava/util/Map;",
                                    "method_body": "private static Map<TypeVariable<?>, Type> getTypeArguments(\nParameterizedType parameterizedType, Class<?> toClass,\nMap<TypeVariable<?>, Type> subtypeVarAssigns) {\nClass<?> cls = getRawType(parameterizedType);\n\n// make sure they're assignable\nif (!isAssignable(cls, toClass)) {\nreturn null;\n}\n\nType ownerType = parameterizedType.getOwnerType();\nMap<TypeVariable<?>, Type> typeVarAssigns;\n\nif (ownerType instanceof ParameterizedType) {\n// get the owner type arguments first\nParameterizedType parameterizedOwnerType = (ParameterizedType) ownerType;\ntypeVarAssigns = getTypeArguments(parameterizedOwnerType,\ngetRawType(parameterizedOwnerType), subtypeVarAssigns);\n} else {\n// no owner, prep the type variable assignments map\ntypeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>()\n: new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n}\n\n// get the subject parameterized type's arguments\nType[] typeArgs = parameterizedType.getActualTypeArguments();\n// and get the corresponding type variables from the raw class\nTypeVariable<?>[] typeParams = cls.getTypeParameters();\n\n// map the arguments to their respective type variables\nfor (int i = 0; i < typeParams.length; i++) {\nType typeArg = typeArgs[i];\ntypeVarAssigns.put(typeParams[i], typeVarAssigns.containsKey(typeArg) ? typeVarAssigns\n.get(typeArg) : typeArg);\n}\n\nif (toClass.equals(cls)) {\n// target class has been reached. Done.\nreturn typeVarAssigns;\n}\n\n// walk the inheritance hierarchy until the target class is reached\nreturn getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:getTypeArguments(Ljava/lang/Class;Ljava/lang/Class;Ljava/util/Map;)Ljava/util/Map;",
                                    "method_body": "private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, Class<?> toClass,\nMap<TypeVariable<?>, Type> subtypeVarAssigns) {\n// make sure they're assignable\nif (!isAssignable(cls, toClass)) {\nreturn null;\n}\n\n// can't work with primitives\nif (cls.isPrimitive()) {\n// both classes are primitives?\nif (toClass.isPrimitive()) {\n// dealing with widening here. No type arguments to be\n// harvested with these two types.\nreturn new HashMap<TypeVariable<?>, Type>();\n}\n\n// work with wrapper the wrapper class instead of the primitive\ncls = ClassUtils.primitiveToWrapper(cls);\n}\n\n// create a copy of the incoming map, or an empty one if it's null\nHashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>()\n: new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n\n// has target class been reached?\nif (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {\nreturn typeVarAssigns;\n}\n\n// walk the inheritance hierarchy until the target class is reached\nreturn getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:getClosestParentType(Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "private static Type getClosestParentType(Class<?> cls, Class<?> superClass) {\n// only look at the interfaces if the super class is also an interface\nif (superClass.isInterface()) {\n// get the generic interfaces of the subject class\nType[] interfaceTypes = cls.getGenericInterfaces();\n// will hold the best generic interface match found\nType genericInterface = null;\n\n// find the interface closest to the super class\nfor (Type midType : interfaceTypes) {\nClass<?> midClass = null;\n\nif (midType instanceof ParameterizedType) {\nmidClass = getRawType((ParameterizedType) midType);\n} else if (midType instanceof Class<?>) {\nmidClass = (Class<?>) midType;\n} else {\nthrow new IllegalStateException(\"Unexpected generic\"\n+ \" interface type found: \" + midType);\n}\n\n// check if this interface is further up the inheritance chain\n// than the previously found match\nif (isAssignable(midClass, superClass)\n&& isAssignable(genericInterface, (Type) midClass)) {\ngenericInterface = midType;\n}\n}\n\n// found a match?\nif (genericInterface != null) {\nreturn genericInterface;\n}\n}\n\n// none of the interfaces were descendants of the target class, so the\n// super class has to be one, instead\nreturn cls.getGenericSuperclass();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:getRawType(Ljava/lang/reflect/ParameterizedType;)Ljava/lang/Class;",
                                    "method_body": "private static Class<?> getRawType(ParameterizedType parameterizedType) {\nType rawType = parameterizedType.getRawType();\n\n// check if raw type is a Class object\n// not currently necessary, but since the return type is Type instead of\n// Class, there's enough reason to believe that future versions of Java\n// may return other Type implementations. And type-safety checking is\n// rarely a bad idea.\nif (!(rawType instanceof Class<?>)) {\nthrow new IllegalStateException(\"Wait... What!? Type of rawType: \" + rawType);\n}\n\nreturn (Class<?>) rawType;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:<clinit>()V",
                                    "method_body": "public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n/**\n* An empty immutable {@code Class} array."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:clone([Ljava/lang/Object;)[Ljava/lang/Object;",
                                    "method_body": "public static <T> T[] clone(T[] array) {\nif (array == null) {\nreturn null;\n}\nreturn array.clone();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:isAssignable(Ljava/lang/reflect/Type;Ljava/lang/reflect/ParameterizedType;Ljava/util/Map;)Z",
                                    "method_body": "private static boolean isAssignable(Type type, ParameterizedType toParameterizedType,\nMap<TypeVariable<?>, Type> typeVarAssigns) {\nif (type == null) {\nreturn true;\n}\n\n// only a null type can be assigned to null type which\n// would have cause the previous to return true\nif (toParameterizedType == null) {\nreturn false;\n}\n\n// all types are assignable to themselves\nif (toParameterizedType.equals(type)) {\nreturn true;\n}\n\n// get the target type's raw type\nClass<?> toClass = getRawType(toParameterizedType);\n// get the subject type's type arguments including owner type arguments\n// and supertype arguments up to and including the target class.\nMap<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null);\n\n// null means the two types are not compatible\nif (fromTypeVarAssigns == null) {\nreturn false;\n}\n\n// compatible types, but there's no type arguments. this is equivalent\n// to comparing Map< ?, ? > to Map, and raw types are always assignable\n// to parameterized types.\nif (fromTypeVarAssigns.isEmpty()) {\nreturn true;\n}\n\n// get the target type's type arguments including owner type arguments\nMap<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType,\ntoClass, typeVarAssigns);\n\n// now to check each type argument\nfor (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\nType toTypeArg = entry.getValue();\nType fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n\n// parameters must either be absent from the subject type, within\n// the bounds of the wildcard type, or be an exact match to the\n// parameters of the target type.\nif (fromTypeArg != null\n&& !toTypeArg.equals(fromTypeArg)\n&& !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,\ntypeVarAssigns))) {\nreturn false;\n}\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:isAssignable(Ljava/lang/reflect/Type;Ljava/lang/reflect/GenericArrayType;Ljava/util/Map;)Z",
                                    "method_body": "private static boolean isAssignable(Type type, GenericArrayType toGenericArrayType,\nMap<TypeVariable<?>, Type> typeVarAssigns) {\nif (type == null) {\nreturn true;\n}\n\n// only a null type can be assigned to null type which\n// would have cause the previous to return true\nif (toGenericArrayType == null) {\nreturn false;\n}\n\n// all types are assignable to themselves\nif (toGenericArrayType.equals(type)) {\nreturn true;\n}\n\nType toComponentType = toGenericArrayType.getGenericComponentType();\n\nif (type instanceof Class<?>) {\nClass<?> cls = (Class<?>) type;\n\n// compare the component types\nreturn cls.isArray()\n&& isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns);\n}\n\nif (type instanceof GenericArrayType) {\n// compare the component types\nreturn isAssignable(((GenericArrayType) type).getGenericComponentType(),\ntoComponentType, typeVarAssigns);\n}\n\nif (type instanceof WildcardType) {\n// so long as one of the upper bounds is assignable, it's good\nfor (Type bound : getImplicitUpperBounds((WildcardType) type)) {\nif (isAssignable(bound, toGenericArrayType)) {\nreturn true;\n}\n}\n\nreturn false;\n}\n\nif (type instanceof TypeVariable<?>) {\n// probably should remove the following logic and just return false.\n// type variables cannot specify arrays as bounds.\nfor (Type bound : getImplicitBounds((TypeVariable<?>) type)) {\nif (isAssignable(bound, toGenericArrayType)) {\nreturn true;\n}\n}\n\nreturn false;\n}\n\nif (type instanceof ParameterizedType) {\n// the raw type of a parameterized type is never an array or\n// generic array, otherwise the declaration would look like this:\n// Collection[]< ? extends String > collection;\nreturn false;\n}\n\nthrow new IllegalStateException(\"found an unhandled type: \" + type);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:isAssignable(Ljava/lang/reflect/Type;Ljava/lang/reflect/WildcardType;Ljava/util/Map;)Z",
                                    "method_body": "private static boolean isAssignable(Type type, WildcardType toWildcardType,\nMap<TypeVariable<?>, Type> typeVarAssigns) {\nif (type == null) {\nreturn true;\n}\n\n// only a null type can be assigned to null type which\n// would have cause the previous to return true\nif (toWildcardType == null) {\nreturn false;\n}\n\n// all types are assignable to themselves\nif (toWildcardType.equals(type)) {\nreturn true;\n}\n\nType[] toUpperBounds = getImplicitUpperBounds(toWildcardType);\nType[] toLowerBounds = getImplicitLowerBounds(toWildcardType);\n\nif (type instanceof WildcardType) {\nWildcardType wildcardType = (WildcardType) type;\nType[] upperBounds = getImplicitUpperBounds(wildcardType);\nType[] lowerBounds = getImplicitLowerBounds(wildcardType);\n\nfor (Type toBound : toUpperBounds) {\n// if there are assignments for unresolved type variables,\n// now's the time to substitute them.\ntoBound = substituteTypeVariables(toBound, typeVarAssigns);\n\n// each upper bound of the subject type has to be assignable to\n// each\n// upper bound of the target type\nfor (Type bound : upperBounds) {\nif (!isAssignable(bound, toBound, typeVarAssigns)) {\nreturn false;\n}\n}\n}\n\nfor (Type toBound : toLowerBounds) {\n// if there are assignments for unresolved type variables,\n// now's the time to substitute them.\ntoBound = substituteTypeVariables(toBound, typeVarAssigns);\n\n// each lower bound of the target type has to be assignable to\n// each\n// lower bound of the subject type\nfor (Type bound : lowerBounds) {\nif (!isAssignable(toBound, bound, typeVarAssigns)) {\nreturn false;\n}\n}\n}\n\nreturn true;\n}\n\nfor (Type toBound : toUpperBounds) {\n// if there are assignments for unresolved type variables,\n// now's the time to substitute them.\nif (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns),\ntypeVarAssigns)) {\nreturn false;\n}\n}\n\nfor (Type toBound : toLowerBounds) {\n// if there are assignments for unresolved type variables,\n// now's the time to substitute them.\nif (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type,\ntypeVarAssigns)) {\nreturn false;\n}\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:substituteTypeVariables(Ljava/lang/reflect/Type;Ljava/util/Map;)Ljava/lang/reflect/Type;",
                                    "method_body": "private static Type substituteTypeVariables(Type type, Map<TypeVariable<?>, Type> typeVarAssigns) {\nif (type instanceof TypeVariable<?> && typeVarAssigns != null) {\nType replacementType = typeVarAssigns.get(type);\n\nif (replacementType == null) {\nthrow new IllegalArgumentException(\"missing assignment type for type variable \"\n+ type);\n}\n\nreturn replacementType;\n}\n\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:normalizeUpperBounds([Ljava/lang/reflect/Type;)[Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type[] normalizeUpperBounds(Type[] bounds) {\n// don't bother if there's only one (or none) type\nif (bounds.length < 2) {\nreturn bounds;\n}\n\nSet<Type> types = new HashSet<Type>(bounds.length);\n\nfor (Type type1 : bounds) {\nboolean subtypeFound = false;\n\nfor (Type type2 : bounds) {\nif (type1 != type2 && isAssignable(type2, type1, null)) {\nsubtypeFound = true;\nbreak;\n}\n}\n\nif (!subtypeFound) {\ntypes.add(type1);\n}\n}\n\nreturn types.toArray(new Type[types.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:getImplicitUpperBounds(Ljava/lang/reflect/WildcardType;)[Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type[] getImplicitUpperBounds(WildcardType wildcardType) {\nType[] bounds = wildcardType.getUpperBounds();\n\nreturn bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:getImplicitLowerBounds(Ljava/lang/reflect/WildcardType;)[Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type[] getImplicitLowerBounds(WildcardType wildcardType) {\nType[] bounds = wildcardType.getLowerBounds();\n\nreturn bounds.length == 0 ? new Type[] { null } : bounds;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringEscapeUtils:<clinit>()V",
                                    "method_body": "public static final CharSequenceTranslator ESCAPE_JAVA =\nnew LookupTranslator(\nnew String[][] {\n{\"\\\"\", \"\\\\\\\"\"},\n{\"\\\\\", \"\\\\\\\\\"},\n}).with("
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringEscapeUtils:escapeHtml4(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public static final String escapeHtml4(String input) {\nreturn ESCAPE_HTML4.translate(input);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.CharSequenceTranslator:translate(Ljava/lang/CharSequence;)Ljava/lang/String;",
                                    "method_body": "public abstract int translate(CharSequence input, int index, Writer out) throws IOException;\n\n/**\n* Helper for non-Writer usage.\n* @param input CharSequence to be translated\n* @return String output of translation\n*/\npublic final String translate(CharSequence input) {\nif (input == null) {\nreturn null;\n}\ntry {\nStringWriter writer = new StringWriter(input.length() * 2);\ntranslate(input, writer);\nreturn writer.toString();\n} catch (IOException ioe) {\n// this should never ever happen while writing to a StringWriter\nthrow new RuntimeException(ioe);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.CharSequenceTranslator:translate(Ljava/lang/CharSequence;Ljava/io/Writer;)V",
                                    "method_body": "public final void translate(CharSequence input, Writer out) throws IOException {\nif (out == null) {\nthrow new IllegalArgumentException(\"The Writer must not be null\");\n}\nif (input == null) {\nreturn;\n}\nint pos = 0;\nint len = input.length();\nwhile (pos < len) {\nint consumed = translate(input, pos, out);\nif (consumed == 0) {\nchar[] c = Character.toChars(Character.codePointAt(input, pos));\nout.write(c);\npos+= c.length;\ncontinue;\n}\n//          // contract with translators is that they have to understand codepoints\n//          // and they just took care of a surrogate pair\nfor (int pt = 0; pt < consumed; pt++) {\npos += Character.charCount(Character.codePointAt(input, pos));\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.CharSequenceTranslator:with([Lorg/apache/commons/lang3/text/translate/CharSequenceTranslator;)Lorg/apache/commons/lang3/text/translate/CharSequenceTranslator;",
                                    "method_body": "public final CharSequenceTranslator with(CharSequenceTranslator... translators) {\nCharSequenceTranslator[] newArray = new CharSequenceTranslator[translators.length + 1];\nnewArray[0] = this;\nSystem.arraycopy(translators, 0, newArray, 1, translators.length);\nreturn new AggregateTranslator(newArray);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.LookupTranslator:<init>([[Ljava/lang/CharSequence;)V",
                                    "method_body": "public LookupTranslator(CharSequence[]... lookup) {\nlookupMap = new HashMap<CharSequence, CharSequence>();\nint _shortest = Integer.MAX_VALUE;\nint _longest = 0;\nif (lookup != null) {\nfor (CharSequence[] seq : lookup) {\nthis.lookupMap.put(seq[0], seq[1]);\nint sz = seq[0].length();\nif (sz < _shortest) {\n_shortest = sz;\n}\nif (sz > _longest) {\n_longest = sz;\n}\n}\n}\nshortest = _shortest;\nlongest = _longest;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.LookupTranslator:translate(Ljava/lang/CharSequence;ILjava/io/Writer;)I",
                                    "method_body": "public int translate(CharSequence input, int index, Writer out) throws IOException {\nint max = longest;\nif (index + longest > input.length()) {\nmax = input.length() - index;\n}\n// descend so as to get a greedy algorithm\nfor (int i = max; i >= shortest; i--) {\nCharSequence subSeq = input.subSequence(index, index + i);\nCharSequence result = lookupMap.get(subSeq);\nif (result != null) {\nout.write(result.toString());\nreturn i;\n}\n}\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:<clinit>()V",
                                    "method_body": "private static final String[][] ISO8859_1_ESCAPE = {\n{\"\\u00A0\", \"&nbsp;\"}, // non-breaking space\n{\"\\u00A1\", \"&iexcl;\"}, // inverted exclamation mark\n{\"\\u00A2\", \"&cent;\"}, // cent sign\n{\"\\u00A3\", \"&pound;\"}, // pound sign\n{\"\\u00A4\", \"&curren;\"}, // currency sign\n{\"\\u00A5\", \"&yen;\"}, // yen sign = yuan sign\n{\"\\u00A6\", \"&brvbar;\"}, // broken bar = broken vertical bar\n{\"\\u00A7\", \"&sect;\"}, // section sign\n{\"\\u00A8\", \"&uml;\"}, // diaeresis = spacing diaeresis\n{\"\\u00A9\", \"&copy;\"}, // \u00a9 - copyright sign\n{\"\\u00AA\", \"&ordf;\"}, // feminine ordinal indicator\n{\"\\u00AB\", \"&laquo;\"}, // left-pointing double angle quotation mark = left pointing guillemet\n{\"\\u00AC\", \"&not;\"}, // not sign\n{\"\\u00AD\", \"&shy;\"}, // soft hyphen = discretionary hyphen\n{\"\\u00AE\", \"&reg;\"}, // \u00ae - registered trademark sign\n{\"\\u00AF\", \"&macr;\"}, // macron = spacing macron = overline = APL overbar\n{\"\\u00B0\", \"&deg;\"}, // degree sign\n{\"\\u00B1\", \"&plusmn;\"}, // plus-minus sign = plus-or-minus sign\n{\"\\u00B2\", \"&sup2;\"}, // superscript two = superscript digit two = squared\n{\"\\u00B3\", \"&sup3;\"}, // superscript three = superscript digit three = cubed\n{\"\\u00B4\", \"&acute;\"}, // acute accent = spacing acute\n{\"\\u00B5\", \"&micro;\"}, // micro sign\n{\"\\u00B6\", \"&para;\"}, // pilcrow sign = paragraph sign\n{\"\\u00B7\", \"&middot;\"}, // middle dot = Georgian comma = Greek middle dot\n{\"\\u00B8\", \"&cedil;\"}, // cedilla = spacing cedilla\n{\"\\u00B9\", \"&sup1;\"}, // superscript one = superscript digit one\n{\"\\u00BA\", \"&ordm;\"}, // masculine ordinal indicator\n{\"\\u00BB\", \"&raquo;\"}, // right-pointing double angle quotation mark = right pointing guillemet\n{\"\\u00BC\", \"&frac14;\"}, // vulgar fraction one quarter = fraction one quarter\n{\"\\u00BD\", \"&frac12;\"}, // vulgar fraction one half = fraction one half\n{\"\\u00BE\", \"&frac34;\"}, // vulgar fraction three quarters = fraction three quarters\n{\"\\u00BF\", \"&iquest;\"}, // inverted question mark = turned question mark\n{\"\\u00C0\", \"&Agrave;\"}, // \u00c0 - uppercase A, grave accent\n{\"\\u00C1\", \"&Aacute;\"}, // \u00c1 - uppercase A, acute accent\n{\"\\u00C2\", \"&Acirc;\"}, // \u00c2 - uppercase A, circumflex accent\n{\"\\u00C3\", \"&Atilde;\"}, // \u00c3 - uppercase A, tilde\n{\"\\u00C4\", \"&Auml;\"}, // \u00c4 - uppercase A, umlaut\n{\"\\u00C5\", \"&Aring;\"}, // \u00c5 - uppercase A, ring\n{\"\\u00C6\", \"&AElig;\"}, // \u00c6 - uppercase AE\n{\"\\u00C7\", \"&Ccedil;\"}, // \u00c7 - uppercase C, cedilla\n{\"\\u00C8\", \"&Egrave;\"}, // \u00c8 - uppercase E, grave accent\n{\"\\u00C9\", \"&Eacute;\"}, // \u00c9 - uppercase E, acute accent\n{\"\\u00CA\", \"&Ecirc;\"}, // \u00ca - uppercase E, circumflex accent\n{\"\\u00CB\", \"&Euml;\"}, // \u00cb - uppercase E, umlaut\n{\"\\u00CC\", \"&Igrave;\"}, // \u00cc - uppercase I, grave accent\n{\"\\u00CD\", \"&Iacute;\"}, // \u00cd - uppercase I, acute accent\n{\"\\u00CE\", \"&Icirc;\"}, // \u00ce - uppercase I, circumflex accent\n{\"\\u00CF\", \"&Iuml;\"}, // \u00cf - uppercase I, umlaut\n{\"\\u00D0\", \"&ETH;\"}, // \u00d0 - uppercase Eth, Icelandic\n{\"\\u00D1\", \"&Ntilde;\"}, // \u00d1 - uppercase N, tilde\n{\"\\u00D2\", \"&Ograve;\"}, // \u00d2 - uppercase O, grave accent\n{\"\\u00D3\", \"&Oacute;\"}, // \u00d3 - uppercase O, acute accent\n{\"\\u00D4\", \"&Ocirc;\"}, // \u00d4 - uppercase O, circumflex accent\n{\"\\u00D5\", \"&Otilde;\"}, // \u00d5 - uppercase O, tilde\n{\"\\u00D6\", \"&Ouml;\"}, // \u00d6 - uppercase O, umlaut\n{\"\\u00D7\", \"&times;\"}, // multiplication sign\n{\"\\u00D8\", \"&Oslash;\"}, // \u00d8 - uppercase O, slash\n{\"\\u00D9\", \"&Ugrave;\"}, // \u00d9 - uppercase U, grave accent\n{\"\\u00DA\", \"&Uacute;\"}, // \u00da - uppercase U, acute accent\n{\"\\u00DB\", \"&Ucirc;\"}, // \u00db - uppercase U, circumflex accent\n{\"\\u00DC\", \"&Uuml;\"}, // \u00dc - uppercase U, umlaut\n{\"\\u00DD\", \"&Yacute;\"}, // \u00dd - uppercase Y, acute accent\n{\"\\u00DE\", \"&THORN;\"}, // \u00de - uppercase THORN, Icelandic\n{\"\\u00DF\", \"&szlig;\"}, // \u00df - lowercase sharps, German\n{\"\\u00E0\", \"&agrave;\"}, // \u00e0 - lowercase a, grave accent\n{\"\\u00E1\", \"&aacute;\"}, // \u00e1 - lowercase a, acute accent\n{\"\\u00E2\", \"&acirc;\"}, // \u00e2 - lowercase a, circumflex accent\n{\"\\u00E3\", \"&atilde;\"}, // \u00e3 - lowercase a, tilde\n{\"\\u00E4\", \"&auml;\"}, // \u00e4 - lowercase a, umlaut\n{\"\\u00E5\", \"&aring;\"}, // \u00e5 - lowercase a, ring\n{\"\\u00E6\", \"&aelig;\"}, // \u00e6 - lowercase ae\n{\"\\u00E7\", \"&ccedil;\"}, // \u00e7 - lowercase c, cedilla\n{\"\\u00E8\", \"&egrave;\"}, // \u00e8 - lowercase e, grave accent\n{\"\\u00E9\", \"&eacute;\"}, // \u00e9 - lowercase e, acute accent\n{\"\\u00EA\", \"&ecirc;\"}, // \u00ea - lowercase e, circumflex accent\n{\"\\u00EB\", \"&euml;\"}, // \u00eb - lowercase e, umlaut\n{\"\\u00EC\", \"&igrave;\"}, // \u00ec - lowercase i, grave accent\n{\"\\u00ED\", \"&iacute;\"}, // \u00ed - lowercase i, acute accent\n{\"\\u00EE\", \"&icirc;\"}, // \u00ee - lowercase i, circumflex accent\n{\"\\u00EF\", \"&iuml;\"}, // \u00ef - lowercase i, umlaut\n{\"\\u00F0\", \"&eth;\"}, // \u00f0 - lowercase eth, Icelandic\n{\"\\u00F1\", \"&ntilde;\"}, // \u00f1 - lowercase n, tilde\n{\"\\u00F2\", \"&ograve;\"}, // \u00f2 - lowercase o, grave accent\n{\"\\u00F3\", \"&oacute;\"}, // \u00f3 - lowercase o, acute accent\n{\"\\u00F4\", \"&ocirc;\"}, // \u00f4 - lowercase o, circumflex accent\n{\"\\u00F5\", \"&otilde;\"}, // \u00f5 - lowercase o, tilde\n{\"\\u00F6\", \"&ouml;\"}, // \u00f6 - lowercase o, umlaut\n{\"\\u00F7\", \"&divide;\"}, // division sign\n{\"\\u00F8\", \"&oslash;\"}, // \u00f8 - lowercase o, slash\n{\"\\u00F9\", \"&ugrave;\"}, // \u00f9 - lowercase u, grave accent\n{\"\\u00FA\", \"&uacute;\"}, // \u00fa - lowercase u, acute accent\n{\"\\u00FB\", \"&ucirc;\"}, // \u00fb - lowercase u, circumflex accent\n{\"\\u00FC\", \"&uuml;\"}, // \u00fc - lowercase u, umlaut\n{\"\\u00FD\", \"&yacute;\"}, // \u00fd - lowercase y, acute accent\n{\"\\u00FE\", \"&thorn;\"}, // \u00fe - lowercase thorn, Icelandic\n{\"\\u00FF\", \"&yuml;\"}, // \u00ff - lowercase y, umlaut\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:ISO8859_1_ESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] ISO8859_1_ESCAPE() { return ISO8859_1_ESCAPE.clone(); }\npublic static String[][] ISO8859_1_ESCAPE() { return ISO8859_1_ESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:ISO8859_1_UNESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] ISO8859_1_UNESCAPE() { return ISO8859_1_UNESCAPE.clone(); }\npublic static String[][] ISO8859_1_UNESCAPE() { return ISO8859_1_UNESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:HTML40_EXTENDED_ESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] HTML40_EXTENDED_ESCAPE() { return HTML40_EXTENDED_ESCAPE.clone(); }\npublic static String[][] HTML40_EXTENDED_ESCAPE() { return HTML40_EXTENDED_ESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:HTML40_EXTENDED_UNESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] HTML40_EXTENDED_UNESCAPE() { return HTML40_EXTENDED_UNESCAPE.clone(); }\npublic static String[][] HTML40_EXTENDED_UNESCAPE() { return HTML40_EXTENDED_UNESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:BASIC_ESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] BASIC_ESCAPE() { return BASIC_ESCAPE.clone(); }\npublic static String[][] BASIC_ESCAPE() { return BASIC_ESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:BASIC_UNESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] BASIC_UNESCAPE() { return BASIC_UNESCAPE.clone(); }\npublic static String[][] BASIC_UNESCAPE() { return BASIC_UNESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:APOS_ESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] APOS_ESCAPE() { return APOS_ESCAPE.clone(); }\npublic static String[][] APOS_ESCAPE() { return APOS_ESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:APOS_UNESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] APOS_UNESCAPE() { return APOS_UNESCAPE.clone(); }\npublic static String[][] APOS_UNESCAPE() { return APOS_UNESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:JAVA_CTRL_CHARS_ESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] JAVA_CTRL_CHARS_ESCAPE() { return JAVA_CTRL_CHARS_ESCAPE.clone(); }\npublic static String[][] JAVA_CTRL_CHARS_ESCAPE() { return JAVA_CTRL_CHARS_ESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:JAVA_CTRL_CHARS_UNESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] JAVA_CTRL_CHARS_UNESCAPE() { return JAVA_CTRL_CHARS_UNESCAPE.clone(); }\npublic static String[][] JAVA_CTRL_CHARS_UNESCAPE() { return JAVA_CTRL_CHARS_UNESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:invert([[Ljava/lang/String;)[[Ljava/lang/String;",
                                    "method_body": "public static String[][] invert(String[][] array) {\nString[][] newarray = new String[array.length][2];\nfor(int i = 0; i<array.length; i++) {\nnewarray[i][0] = array[i][1];\nnewarray[i][1] = array[i][0];\n}\nreturn newarray;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.AggregateTranslator:<init>([Lorg/apache/commons/lang3/text/translate/CharSequenceTranslator;)V",
                                    "method_body": "public AggregateTranslator(CharSequenceTranslator... translators) {\nthis.translators = ArrayUtils.clone(translators);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.AggregateTranslator:translate(Ljava/lang/CharSequence;ILjava/io/Writer;)I",
                                    "method_body": "public int translate(CharSequence input, int index, Writer out) throws IOException {\nfor (CharSequenceTranslator translator : translators) {\nint consumed = translator.translate(input, index, out);\nif(consumed != 0) {\nreturn consumed;\n}\n}\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.UnicodeEscaper:<init>(IIZ)V",
                                    "method_body": "private UnicodeEscaper(int below, int above, boolean between) {\nthis.below = below;\nthis.above = above;\nthis.between = between;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.UnicodeEscaper:outsideOf(II)Lorg/apache/commons/lang3/text/translate/UnicodeEscaper;",
                                    "method_body": "public static UnicodeEscaper outsideOf(int codepointLow, int codepointHigh) {\nreturn new UnicodeEscaper(codepointLow, codepointHigh, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringEscapeUtils$CsvEscaper:<init>()V",
                                    "method_body": "public static final CharSequenceTranslator ESCAPE_CSV = new CsvEscaper();\n\n// TODO: Create a parent class - 'SinglePassTranslator' ?\n//       It would handle the index checking + length returning,\n//       and could also have an optimization check method.\nstatic class CsvEscaper extends CharSequenceTranslator {\n\nprivate static final char CSV_DELIMITER = ',';\nprivate static final char CSV_QUOTE = '\"';\nprivate static final String CSV_QUOTE_STR = String.valueOf(CSV_QUOTE);\nprivate static final char[] CSV_SEARCH_CHARS =\nnew char[] {CSV_DELIMITER, CSV_QUOTE, CharUtils.CR, CharUtils.LF};\n\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n\nif(index != 0) {\nthrow new IllegalStateException(\"CsvEscaper should never reach the [1] index\");\n}\n\nif (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) {\nout.write(input.toString());\n} else {\nout.write(CSV_QUOTE);\nout.write(StringUtils.replace(input.toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\nout.write(CSV_QUOTE);\n}\nreturn input.length();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringEscapeUtils$CsvEscaper:<clinit>()V",
                                    "method_body": "public static final CharSequenceTranslator ESCAPE_CSV = new CsvEscaper();\n\n// TODO: Create a parent class - 'SinglePassTranslator' ?\n//       It would handle the index checking + length returning,\n//       and could also have an optimization check method.\nstatic class CsvEscaper extends CharSequenceTranslator {\n\nprivate static final char CSV_DELIMITER = ',';\nprivate static final char CSV_QUOTE = '\"';\nprivate static final String CSV_QUOTE_STR = String.valueOf(CSV_QUOTE);\nprivate static final char[] CSV_SEARCH_CHARS =\nnew char[] {CSV_DELIMITER, CSV_QUOTE, CharUtils.CR, CharUtils.LF};\n\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n\nif(index != 0) {\nthrow new IllegalStateException(\"CsvEscaper should never reach the [1] index\");\n}\n\nif (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) {\nout.write(input.toString());\n} else {\nout.write(CSV_QUOTE);\nout.write(StringUtils.replace(input.toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\nout.write(CSV_QUOTE);\n}\nreturn input.length();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.OctalUnescaper:<clinit>()V",
                                    "method_body": "private static int OCTAL_MAX = 377;\n\n/**\n* {@inheritDoc}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.NumericEntityUnescaper:<init>([Lorg/apache/commons/lang3/text/translate/NumericEntityUnescaper$OPTION;)V",
                                    "method_body": "public NumericEntityUnescaper(OPTION... options) {\nif(options.length > 0) {\nthis.options = EnumSet.copyOf(Arrays.asList(options));\n} else {\nthis.options = EnumSet.copyOf(Arrays.asList(new OPTION[] { OPTION.semiColonRequired }));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringEscapeUtils$CsvUnescaper:<init>()V",
                                    "method_body": "public static final CharSequenceTranslator UNESCAPE_CSV = new CsvUnescaper();\n\nstatic class CsvUnescaper extends CharSequenceTranslator {\n\nprivate static final char CSV_DELIMITER = ',';\nprivate static final char CSV_QUOTE = '\"';\nprivate static final String CSV_QUOTE_STR = String.valueOf(CSV_QUOTE);\nprivate static final char[] CSV_SEARCH_CHARS =\nnew char[] {CSV_DELIMITER, CSV_QUOTE, CharUtils.CR, CharUtils.LF};\n\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n\nif(index != 0) {\nthrow new IllegalStateException(\"CsvUnescaper should never reach the [1] index\");\n}\n\nif ( input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE ) {\nout.write(input.toString());\nreturn input.length();\n}\n\n// strip quotes\nString quoteless = input.subSequence(1, input.length() - 1).toString();\n\nif ( StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS) ) {\n// deal with escaped quotes; ie) \"\"\nout.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n} else {\nout.write(input.toString());\n}\nreturn input.length();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringEscapeUtils$CsvUnescaper:<clinit>()V",
                                    "method_body": "public static final CharSequenceTranslator UNESCAPE_CSV = new CsvUnescaper();\n\nstatic class CsvUnescaper extends CharSequenceTranslator {\n\nprivate static final char CSV_DELIMITER = ',';\nprivate static final char CSV_QUOTE = '\"';\nprivate static final String CSV_QUOTE_STR = String.valueOf(CSV_QUOTE);\nprivate static final char[] CSV_SEARCH_CHARS =\nnew char[] {CSV_DELIMITER, CSV_QUOTE, CharUtils.CR, CharUtils.LF};\n\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n\nif(index != 0) {\nthrow new IllegalStateException(\"CsvUnescaper should never reach the [1] index\");\n}\n\nif ( input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE ) {\nout.write(input.toString());\nreturn input.length();\n}\n\n// strip quotes\nString quoteless = input.subSequence(1, input.length() - 1).toString();\n\nif ( StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS) ) {\n// deal with escaped quotes; ie) \"\"\nout.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n} else {\nout.write(input.toString());\n}\nreturn input.length();\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 16,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.math.NumberUtilsTest.testCreateNumber",
                            "test_body": "182: public void testCreateNumber() {\n183: // a lot of things can go wrong\n184: assertEquals(\"createNumber(String) 1 failed\", Float.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5\"));\n185: assertEquals(\"createNumber(String) 2 failed\", Integer.valueOf(\"12345\"), NumberUtils.createNumber(\"12345\"));\n186: assertEquals(\"createNumber(String) 3 failed\", Double.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5D\"));\n187: assertEquals(\"createNumber(String) 3 failed\", Double.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5d\"));\n188: assertEquals(\"createNumber(String) 4 failed\", Float.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5F\"));\n189: assertEquals(\"createNumber(String) 4 failed\", Float.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5f\"));\n190: assertEquals(\"createNumber(String) 5 failed\", Long.valueOf(Integer.MAX_VALUE + 1L), NumberUtils.createNumber(\"\"\n191: + (Integer.MAX_VALUE + 1L)));\n192: assertEquals(\"createNumber(String) 6 failed\", Long.valueOf(12345), NumberUtils.createNumber(\"12345L\"));\n193: assertEquals(\"createNumber(String) 6 failed\", Long.valueOf(12345), NumberUtils.createNumber(\"12345l\"));\n194: assertEquals(\"createNumber(String) 7 failed\", Float.valueOf(\"-1234.5\"), NumberUtils.createNumber(\"-1234.5\"));\n195: assertEquals(\"createNumber(String) 8 failed\", Integer.valueOf(\"-12345\"), NumberUtils.createNumber(\"-12345\"));\n196: assertTrue(\"createNumber(String) 9a failed\", 0xFADE == NumberUtils.createNumber(\"0xFADE\").intValue());\n197: assertTrue(\"createNumber(String) 9b failed\", 0xFADE == NumberUtils.createNumber(\"0Xfade\").intValue());\n198: assertTrue(\"createNumber(String) 10a failed\", -0xFADE == NumberUtils.createNumber(\"-0xFADE\").intValue());\n199: assertTrue(\"createNumber(String) 10b failed\", -0xFADE == NumberUtils.createNumber(\"-0Xfade\").intValue());\n200: assertEquals(\"createNumber(String) 11 failed\", Double.valueOf(\"1.1E200\"), NumberUtils.createNumber(\"1.1E200\"));\n201: assertEquals(\"createNumber(String) 12 failed\", Float.valueOf(\"1.1E20\"), NumberUtils.createNumber(\"1.1E20\"));\n202: assertEquals(\"createNumber(String) 13 failed\", Double.valueOf(\"-1.1E200\"), NumberUtils.createNumber(\"-1.1E200\"));\n203: assertEquals(\"createNumber(String) 14 failed\", Double.valueOf(\"1.1E-200\"), NumberUtils.createNumber(\"1.1E-200\"));\n204: assertEquals(\"createNumber(null) failed\", null, NumberUtils.createNumber(null));\n205: assertEquals(\"createNumber(String) failed\", new BigInteger(\"12345678901234567890\"), NumberUtils\n206: .createNumber(\"12345678901234567890L\"));\n207: 208: // jdk 1.2 doesn't support this. unsure about jdk 1.2.2\n209: if (SystemUtils.isJavaVersionAtLeast(JAVA_1_3)) {\n210: assertEquals(\"createNumber(String) 15 failed\", new BigDecimal(\"1.1E-700\"), NumberUtils\n211: .createNumber(\"1.1E-700F\"));\n212: }\n213: assertEquals(\"createNumber(String) 16 failed\", Long.valueOf(\"10\" + Integer.MAX_VALUE), NumberUtils\n214: .createNumber(\"10\" + Integer.MAX_VALUE + \"L\"));\n215: assertEquals(\"createNumber(String) 17 failed\", Long.valueOf(\"10\" + Integer.MAX_VALUE), NumberUtils\n216: .createNumber(\"10\" + Integer.MAX_VALUE));\n217: assertEquals(\"createNumber(String) 18 failed\", new BigInteger(\"10\" + Long.MAX_VALUE), NumberUtils\n218: .createNumber(\"10\" + Long.MAX_VALUE));\n219: 220: // LANG-521\n221: assertEquals(\"createNumber(String) LANG-521 failed\", Float.valueOf(\"2.\"), NumberUtils.createNumber(\"2.\"));\n222: 223: // LANG-638\n224: assertFalse(\"createNumber(String) succeeded\", checkCreateNumber(\"1eE\"));\n225: 226: // LANG-693\n227: assertEquals(\"createNumber(String) LANG-693 failed\", Double.valueOf(Double.MAX_VALUE), NumberUtils\n228: .createNumber(\"\" + Double.MAX_VALUE));\n229: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:<clinit>()V",
                                    "method_body": "public static final String EMPTY = \"\";\n\n/**\n* Represents a failed index search.\n* @since 2.1\n*/\npublic static final int INDEX_NOT_FOUND = -1;\n\n/**\n* <p>The maximum size to which the padding constant(s) can expand.</p>\n*/\nprivate static final int PAD_LIMIT = 8192;\n\n/**\n* A regex pattern for recognizing blocks of whitespace characters.\n*/\nprivate static final Pattern WHITESPACE_BLOCK = Pattern.compile(\"\\\\s+\");\n\n/**\n* <p>{@code StringUtils} instances should NOT be constructed in"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:isEmpty(Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean isEmpty(CharSequence cs) {\nreturn cs == null || cs.length() == 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:isBlank(Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean isBlank(CharSequence cs) {\nint strLen;\nif (cs == null || (strLen = cs.length()) == 0) {\nreturn true;\n}\nfor (int i = 0; i < strLen; i++) {\nif ((Character.isWhitespace(cs.charAt(i)) == false)) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:<clinit>()V",
                                    "method_body": "public static final Long LONG_ZERO = Long.valueOf(0L);\n/** Reusable Long constant for one. */\npublic static final Long LONG_ONE = Long.valueOf(1L);\n/** Reusable Long constant for minus one. */\npublic static final Long LONG_MINUS_ONE = Long.valueOf(-1L);\n/** Reusable Integer constant for zero. */\npublic static final Integer INTEGER_ZERO = Integer.valueOf(0);\n/** Reusable Integer constant for one. */\npublic static final Integer INTEGER_ONE = Integer.valueOf(1);\n/** Reusable Integer constant for minus one. */\npublic static final Integer INTEGER_MINUS_ONE = Integer.valueOf(-1);\n/** Reusable Short constant for zero. */\npublic static final Short SHORT_ZERO = Short.valueOf((short) 0);\n/** Reusable Short constant for one. */\npublic static final Short SHORT_ONE = Short.valueOf((short) 1);\n/** Reusable Short constant for minus one. */\npublic static final Short SHORT_MINUS_ONE = Short.valueOf((short) -1);\n/** Reusable Byte constant for zero. */\npublic static final Byte BYTE_ZERO = Byte.valueOf((byte) 0);\n/** Reusable Byte constant for one. */\npublic static final Byte BYTE_ONE = Byte.valueOf((byte) 1);\n/** Reusable Byte constant for minus one. */\npublic static final Byte BYTE_MINUS_ONE = Byte.valueOf((byte) -1);\n/** Reusable Double constant for zero. */\npublic static final Double DOUBLE_ZERO = Double.valueOf(0.0d);\n/** Reusable Double constant for one. */\npublic static final Double DOUBLE_ONE = Double.valueOf(1.0d);\n/** Reusable Double constant for minus one. */\npublic static final Double DOUBLE_MINUS_ONE = Double.valueOf(-1.0d);\n/** Reusable Float constant for zero. */\npublic static final Float FLOAT_ZERO = Float.valueOf(0.0f);\n/** Reusable Float constant for one. */\npublic static final Float FLOAT_ONE = Float.valueOf(1.0f);\n/** Reusable Float constant for minus one. */\npublic static final Float FLOAT_MINUS_ONE = Float.valueOf(-1.0f);\n\n/**\n* <p><code>NumberUtils</code> instances should NOT be constructed in standard programming.\n* Instead, the class should be used as <code>NumberUtils.toInt(\"6\");</code>.</p>\n*\n* <p>This constructor is public to permit tools that require a JavaBean instance\n* to operate.</p>\n*/\npublic NumberUtils() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createNumber(Ljava/lang/String;)Ljava/lang/Number;",
                                    "method_body": "public static Number createNumber(String str) throws NumberFormatException {\nif (str == null) {\nreturn null;\n}\nif (StringUtils.isBlank(str)) {\nthrow new NumberFormatException(\"A blank string is not a valid number\");\n}\nif (str.startsWith(\"--\")) {\n// this is protection for poorness in java.lang.BigDecimal.\n// it accepts this as a legal value, but it does not appear\n// to be in specification of class. OS X Java parses it to\n// a wrong value.\nreturn null;\n}\nif (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\nreturn createInteger(str);\n}\nchar lastChar = str.charAt(str.length() - 1);\nString mant;\nString dec;\nString exp;\nint decPos = str.indexOf('.');\nint expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\nif (decPos > -1) {\n\nif (expPos > -1) {\nif (expPos < decPos || expPos > str.length()) {\nthrow new NumberFormatException(str + \" is not a valid number.\");\n}\ndec = str.substring(decPos + 1, expPos);\n} else {\ndec = str.substring(decPos + 1);\n}\nmant = str.substring(0, decPos);\n} else {\nif (expPos > -1) {\nif (expPos > str.length()) {\nthrow new NumberFormatException(str + \" is not a valid number.\");\n}\nmant = str.substring(0, expPos);\n} else {\nmant = str;\n}\ndec = null;\n}\nif (!Character.isDigit(lastChar) && lastChar != '.') {\nif (expPos > -1 && expPos < str.length() - 1) {\nexp = str.substring(expPos + 1, str.length() - 1);\n} else {\nexp = null;\n}\n//Requesting a specific type..\nString numeric = str.substring(0, str.length() - 1);\nboolean allZeros = isAllZeros(mant) && isAllZeros(exp);\nswitch (lastChar) {\ncase 'l' :\ncase 'L' :\nif (dec == null\n&& exp == null\n&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\ntry {\nreturn createLong(numeric);\n} catch (NumberFormatException nfe) { // NOPMD\n// Too big for a long\n}\nreturn createBigInteger(numeric);\n\n}\nthrow new NumberFormatException(str + \" is not a valid number.\");\ncase 'f' :\ncase 'F' :\ntry {\nFloat f = NumberUtils.createFloat(numeric);\nif (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n//If it's too big for a float or the float value = 0 and the string\n//has non-zeros in it, then float does not have the precision we want\nreturn f;\n}\n\n} catch (NumberFormatException nfe) { // NOPMD\n// ignore the bad number\n}\n//$FALL-THROUGH$\ncase 'd' :\ncase 'D' :\ntry {\nDouble d = NumberUtils.createDouble(numeric);\nif (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\nreturn d;\n}\n} catch (NumberFormatException nfe) { // NOPMD\n// ignore the bad number\n}\ntry {\nreturn createBigDecimal(numeric);\n} catch (NumberFormatException e) { // NOPMD\n// ignore the bad number\n}\n//$FALL-THROUGH$\ndefault :\nthrow new NumberFormatException(str + \" is not a valid number.\");\n\n}\n} else {\n//User doesn't have a preference on the return type, so let's start\n//small and go from there...\nif (expPos > -1 && expPos < str.length() - 1) {\nexp = str.substring(expPos + 1, str.length());\n} else {\nexp = null;\n}\nif (dec == null && exp == null) {\n//Must be an int,long,bigint\ntry {\nreturn createInteger(str);\n} catch (NumberFormatException nfe) { // NOPMD\n// ignore the bad number\n}\ntry {\nreturn createLong(str);\n} catch (NumberFormatException nfe) { // NOPMD\n// ignore the bad number\n}\nreturn createBigInteger(str);\n\n} else {\n//Must be a float,double,BigDec\nboolean allZeros = isAllZeros(mant) && isAllZeros(exp);\ntry {\nFloat f = createFloat(str);\nif (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\nreturn f;\n}\n} catch (NumberFormatException nfe) { // NOPMD\n// ignore the bad number\n}\ntry {\nDouble d = createDouble(str);\nif (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\nreturn d;\n}\n} catch (NumberFormatException nfe) { // NOPMD\n// ignore the bad number\n}\n\nreturn createBigDecimal(str);\n\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:isAllZeros(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean isAllZeros(String str) {\nif (str == null) {\nreturn true;\n}\nfor (int i = str.length() - 1; i >= 0; i--) {\nif (str.charAt(i) != '0') {\nreturn false;\n}\n}\nreturn str.length() > 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createFloat(Ljava/lang/String;)Ljava/lang/Float;",
                                    "method_body": "public static Float createFloat(String str) {\nif (str == null) {\nreturn null;\n}\nreturn Float.valueOf(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createDouble(Ljava/lang/String;)Ljava/lang/Double;",
                                    "method_body": "public static Double createDouble(String str) {\nif (str == null) {\nreturn null;\n}\nreturn Double.valueOf(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createInteger(Ljava/lang/String;)Ljava/lang/Integer;",
                                    "method_body": "public static Integer createInteger(String str) {\nif (str == null) {\nreturn null;\n}\n// decode() handles 0xAABD and 0777 (hex and octal) as well.\nreturn Integer.decode(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createLong(Ljava/lang/String;)Ljava/lang/Long;",
                                    "method_body": "public static Long createLong(String str) {\nif (str == null) {\nreturn null;\n}\nreturn Long.valueOf(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:isDigits(Ljava/lang/String;)Z",
                                    "method_body": "public static boolean isDigits(String str) {\nif (StringUtils.isEmpty(str)) {\nreturn false;\n}\nfor (int i = 0; i < str.length(); i++) {\nif (!Character.isDigit(str.charAt(i))) {\nreturn false;\n}\n}\nreturn true;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 17,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.StringEscapeUtilsTest.testLang720",
                            "test_body": "428: public void testLang720() {\n429: String input = new StringBuilder(\"\\ud842\\udfb7\").append(\"A\").toString();\n430: String escaped = StringEscapeUtils.escapeXml(input);\n431: assertEquals(input, escaped);\n432: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:<clinit>()V",
                                    "method_body": "public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n/**\n* An empty immutable {@code Class} array."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:clone([Ljava/lang/Object;)[Ljava/lang/Object;",
                                    "method_body": "public static <T> T[] clone(T[] array) {\nif (array == null) {\nreturn null;\n}\nreturn array.clone();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringEscapeUtils:<clinit>()V",
                                    "method_body": "public static final CharSequenceTranslator ESCAPE_JAVA =\nnew LookupTranslator(\nnew String[][] {\n{\"\\\"\", \"\\\\\\\"\"},\n{\"\\\\\", \"\\\\\\\\\"},\n}).with("
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringEscapeUtils:escapeXml(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public static final String escapeXml(String input) {\nreturn ESCAPE_XML.translate(input);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.CharSequenceTranslator:translate(Ljava/lang/CharSequence;)Ljava/lang/String;",
                                    "method_body": "public abstract int translate(CharSequence input, int index, Writer out) throws IOException;\n\n/**\n* Helper for non-Writer usage.\n* @param input CharSequence to be translated\n* @return String output of translation\n*/\npublic final String translate(CharSequence input) {\nif (input == null) {\nreturn null;\n}\ntry {\nStringWriter writer = new StringWriter(input.length() * 2);\ntranslate(input, writer);\nreturn writer.toString();\n} catch (IOException ioe) {\n// this should never ever happen while writing to a StringWriter\nthrow new RuntimeException(ioe);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.CharSequenceTranslator:translate(Ljava/lang/CharSequence;Ljava/io/Writer;)V",
                                    "method_body": "public final void translate(CharSequence input, Writer out) throws IOException {\nif (out == null) {\nthrow new IllegalArgumentException(\"The Writer must not be null\");\n}\nif (input == null) {\nreturn;\n}\nint pos = 0;\nint len = Character.codePointCount(input, 0, input.length());\nwhile (pos < len) {\nint consumed = translate(input, pos, out);\nif (consumed == 0) {\nchar[] c = Character.toChars(Character.codePointAt(input, pos));\nout.write(c);\n}\nelse {\n//          // contract with translators is that they have to understand codepoints\n//          // and they just took care of a surrogate pair\nfor (int pt = 0; pt < consumed; pt++) {\nif (pos < len - 2) {\npos += Character.charCount(Character.codePointAt(input, pos));\n} else {\npos++;\n}\n}\npos--;\n}\npos++;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.CharSequenceTranslator:with([Lorg/apache/commons/lang3/text/translate/CharSequenceTranslator;)Lorg/apache/commons/lang3/text/translate/CharSequenceTranslator;",
                                    "method_body": "public final CharSequenceTranslator with(CharSequenceTranslator... translators) {\nCharSequenceTranslator[] newArray = new CharSequenceTranslator[translators.length + 1];\nnewArray[0] = this;\nSystem.arraycopy(translators, 0, newArray, 1, translators.length);\nreturn new AggregateTranslator(newArray);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.LookupTranslator:<init>([[Ljava/lang/CharSequence;)V",
                                    "method_body": "public LookupTranslator(CharSequence[]... lookup) {\nlookupMap = new HashMap<CharSequence, CharSequence>();\nint _shortest = Integer.MAX_VALUE;\nint _longest = 0;\nif (lookup != null) {\nfor (CharSequence[] seq : lookup) {\nthis.lookupMap.put(seq[0], seq[1]);\nint sz = seq[0].length();\nif (sz < _shortest) {\n_shortest = sz;\n}\nif (sz > _longest) {\n_longest = sz;\n}\n}\n}\nshortest = _shortest;\nlongest = _longest;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.LookupTranslator:translate(Ljava/lang/CharSequence;ILjava/io/Writer;)I",
                                    "method_body": "public int translate(CharSequence input, int index, Writer out) throws IOException {\nint max = longest;\nif (index + longest > input.length()) {\nmax = input.length() - index;\n}\n// descend so as to get a greedy algorithm\nfor (int i = max; i >= shortest; i--) {\nCharSequence subSeq = input.subSequence(index, index + i);\nCharSequence result = lookupMap.get(subSeq);\nif (result != null) {\nout.write(result.toString());\nreturn i;\n}\n}\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:<clinit>()V",
                                    "method_body": "private static final String[][] ISO8859_1_ESCAPE = {\n{\"\\u00A0\", \"&nbsp;\"}, // non-breaking space\n{\"\\u00A1\", \"&iexcl;\"}, // inverted exclamation mark\n{\"\\u00A2\", \"&cent;\"}, // cent sign\n{\"\\u00A3\", \"&pound;\"}, // pound sign\n{\"\\u00A4\", \"&curren;\"}, // currency sign\n{\"\\u00A5\", \"&yen;\"}, // yen sign = yuan sign\n{\"\\u00A6\", \"&brvbar;\"}, // broken bar = broken vertical bar\n{\"\\u00A7\", \"&sect;\"}, // section sign\n{\"\\u00A8\", \"&uml;\"}, // diaeresis = spacing diaeresis\n{\"\\u00A9\", \"&copy;\"}, // \u00a9 - copyright sign\n{\"\\u00AA\", \"&ordf;\"}, // feminine ordinal indicator\n{\"\\u00AB\", \"&laquo;\"}, // left-pointing double angle quotation mark = left pointing guillemet\n{\"\\u00AC\", \"&not;\"}, // not sign\n{\"\\u00AD\", \"&shy;\"}, // soft hyphen = discretionary hyphen\n{\"\\u00AE\", \"&reg;\"}, // \u00ae - registered trademark sign\n{\"\\u00AF\", \"&macr;\"}, // macron = spacing macron = overline = APL overbar\n{\"\\u00B0\", \"&deg;\"}, // degree sign\n{\"\\u00B1\", \"&plusmn;\"}, // plus-minus sign = plus-or-minus sign\n{\"\\u00B2\", \"&sup2;\"}, // superscript two = superscript digit two = squared\n{\"\\u00B3\", \"&sup3;\"}, // superscript three = superscript digit three = cubed\n{\"\\u00B4\", \"&acute;\"}, // acute accent = spacing acute\n{\"\\u00B5\", \"&micro;\"}, // micro sign\n{\"\\u00B6\", \"&para;\"}, // pilcrow sign = paragraph sign\n{\"\\u00B7\", \"&middot;\"}, // middle dot = Georgian comma = Greek middle dot\n{\"\\u00B8\", \"&cedil;\"}, // cedilla = spacing cedilla\n{\"\\u00B9\", \"&sup1;\"}, // superscript one = superscript digit one\n{\"\\u00BA\", \"&ordm;\"}, // masculine ordinal indicator\n{\"\\u00BB\", \"&raquo;\"}, // right-pointing double angle quotation mark = right pointing guillemet\n{\"\\u00BC\", \"&frac14;\"}, // vulgar fraction one quarter = fraction one quarter\n{\"\\u00BD\", \"&frac12;\"}, // vulgar fraction one half = fraction one half\n{\"\\u00BE\", \"&frac34;\"}, // vulgar fraction three quarters = fraction three quarters\n{\"\\u00BF\", \"&iquest;\"}, // inverted question mark = turned question mark\n{\"\\u00C0\", \"&Agrave;\"}, // \u00c0 - uppercase A, grave accent\n{\"\\u00C1\", \"&Aacute;\"}, // \u00c1 - uppercase A, acute accent\n{\"\\u00C2\", \"&Acirc;\"}, // \u00c2 - uppercase A, circumflex accent\n{\"\\u00C3\", \"&Atilde;\"}, // \u00c3 - uppercase A, tilde\n{\"\\u00C4\", \"&Auml;\"}, // \u00c4 - uppercase A, umlaut\n{\"\\u00C5\", \"&Aring;\"}, // \u00c5 - uppercase A, ring\n{\"\\u00C6\", \"&AElig;\"}, // \u00c6 - uppercase AE\n{\"\\u00C7\", \"&Ccedil;\"}, // \u00c7 - uppercase C, cedilla\n{\"\\u00C8\", \"&Egrave;\"}, // \u00c8 - uppercase E, grave accent\n{\"\\u00C9\", \"&Eacute;\"}, // \u00c9 - uppercase E, acute accent\n{\"\\u00CA\", \"&Ecirc;\"}, // \u00ca - uppercase E, circumflex accent\n{\"\\u00CB\", \"&Euml;\"}, // \u00cb - uppercase E, umlaut\n{\"\\u00CC\", \"&Igrave;\"}, // \u00cc - uppercase I, grave accent\n{\"\\u00CD\", \"&Iacute;\"}, // \u00cd - uppercase I, acute accent\n{\"\\u00CE\", \"&Icirc;\"}, // \u00ce - uppercase I, circumflex accent\n{\"\\u00CF\", \"&Iuml;\"}, // \u00cf - uppercase I, umlaut\n{\"\\u00D0\", \"&ETH;\"}, // \u00d0 - uppercase Eth, Icelandic\n{\"\\u00D1\", \"&Ntilde;\"}, // \u00d1 - uppercase N, tilde\n{\"\\u00D2\", \"&Ograve;\"}, // \u00d2 - uppercase O, grave accent\n{\"\\u00D3\", \"&Oacute;\"}, // \u00d3 - uppercase O, acute accent\n{\"\\u00D4\", \"&Ocirc;\"}, // \u00d4 - uppercase O, circumflex accent\n{\"\\u00D5\", \"&Otilde;\"}, // \u00d5 - uppercase O, tilde\n{\"\\u00D6\", \"&Ouml;\"}, // \u00d6 - uppercase O, umlaut\n{\"\\u00D7\", \"&times;\"}, // multiplication sign\n{\"\\u00D8\", \"&Oslash;\"}, // \u00d8 - uppercase O, slash\n{\"\\u00D9\", \"&Ugrave;\"}, // \u00d9 - uppercase U, grave accent\n{\"\\u00DA\", \"&Uacute;\"}, // \u00da - uppercase U, acute accent\n{\"\\u00DB\", \"&Ucirc;\"}, // \u00db - uppercase U, circumflex accent\n{\"\\u00DC\", \"&Uuml;\"}, // \u00dc - uppercase U, umlaut\n{\"\\u00DD\", \"&Yacute;\"}, // \u00dd - uppercase Y, acute accent\n{\"\\u00DE\", \"&THORN;\"}, // \u00de - uppercase THORN, Icelandic\n{\"\\u00DF\", \"&szlig;\"}, // \u00df - lowercase sharps, German\n{\"\\u00E0\", \"&agrave;\"}, // \u00e0 - lowercase a, grave accent\n{\"\\u00E1\", \"&aacute;\"}, // \u00e1 - lowercase a, acute accent\n{\"\\u00E2\", \"&acirc;\"}, // \u00e2 - lowercase a, circumflex accent\n{\"\\u00E3\", \"&atilde;\"}, // \u00e3 - lowercase a, tilde\n{\"\\u00E4\", \"&auml;\"}, // \u00e4 - lowercase a, umlaut\n{\"\\u00E5\", \"&aring;\"}, // \u00e5 - lowercase a, ring\n{\"\\u00E6\", \"&aelig;\"}, // \u00e6 - lowercase ae\n{\"\\u00E7\", \"&ccedil;\"}, // \u00e7 - lowercase c, cedilla\n{\"\\u00E8\", \"&egrave;\"}, // \u00e8 - lowercase e, grave accent\n{\"\\u00E9\", \"&eacute;\"}, // \u00e9 - lowercase e, acute accent\n{\"\\u00EA\", \"&ecirc;\"}, // \u00ea - lowercase e, circumflex accent\n{\"\\u00EB\", \"&euml;\"}, // \u00eb - lowercase e, umlaut\n{\"\\u00EC\", \"&igrave;\"}, // \u00ec - lowercase i, grave accent\n{\"\\u00ED\", \"&iacute;\"}, // \u00ed - lowercase i, acute accent\n{\"\\u00EE\", \"&icirc;\"}, // \u00ee - lowercase i, circumflex accent\n{\"\\u00EF\", \"&iuml;\"}, // \u00ef - lowercase i, umlaut\n{\"\\u00F0\", \"&eth;\"}, // \u00f0 - lowercase eth, Icelandic\n{\"\\u00F1\", \"&ntilde;\"}, // \u00f1 - lowercase n, tilde\n{\"\\u00F2\", \"&ograve;\"}, // \u00f2 - lowercase o, grave accent\n{\"\\u00F3\", \"&oacute;\"}, // \u00f3 - lowercase o, acute accent\n{\"\\u00F4\", \"&ocirc;\"}, // \u00f4 - lowercase o, circumflex accent\n{\"\\u00F5\", \"&otilde;\"}, // \u00f5 - lowercase o, tilde\n{\"\\u00F6\", \"&ouml;\"}, // \u00f6 - lowercase o, umlaut\n{\"\\u00F7\", \"&divide;\"}, // division sign\n{\"\\u00F8\", \"&oslash;\"}, // \u00f8 - lowercase o, slash\n{\"\\u00F9\", \"&ugrave;\"}, // \u00f9 - lowercase u, grave accent\n{\"\\u00FA\", \"&uacute;\"}, // \u00fa - lowercase u, acute accent\n{\"\\u00FB\", \"&ucirc;\"}, // \u00fb - lowercase u, circumflex accent\n{\"\\u00FC\", \"&uuml;\"}, // \u00fc - lowercase u, umlaut\n{\"\\u00FD\", \"&yacute;\"}, // \u00fd - lowercase y, acute accent\n{\"\\u00FE\", \"&thorn;\"}, // \u00fe - lowercase thorn, Icelandic\n{\"\\u00FF\", \"&yuml;\"}, // \u00ff - lowercase y, umlaut\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:ISO8859_1_ESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] ISO8859_1_ESCAPE() { return ISO8859_1_ESCAPE.clone(); }\npublic static String[][] ISO8859_1_ESCAPE() { return ISO8859_1_ESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:ISO8859_1_UNESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] ISO8859_1_UNESCAPE() { return ISO8859_1_UNESCAPE.clone(); }\npublic static String[][] ISO8859_1_UNESCAPE() { return ISO8859_1_UNESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:HTML40_EXTENDED_ESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] HTML40_EXTENDED_ESCAPE() { return HTML40_EXTENDED_ESCAPE.clone(); }\npublic static String[][] HTML40_EXTENDED_ESCAPE() { return HTML40_EXTENDED_ESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:HTML40_EXTENDED_UNESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] HTML40_EXTENDED_UNESCAPE() { return HTML40_EXTENDED_UNESCAPE.clone(); }\npublic static String[][] HTML40_EXTENDED_UNESCAPE() { return HTML40_EXTENDED_UNESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:BASIC_ESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] BASIC_ESCAPE() { return BASIC_ESCAPE.clone(); }\npublic static String[][] BASIC_ESCAPE() { return BASIC_ESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:BASIC_UNESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] BASIC_UNESCAPE() { return BASIC_UNESCAPE.clone(); }\npublic static String[][] BASIC_UNESCAPE() { return BASIC_UNESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:APOS_ESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] APOS_ESCAPE() { return APOS_ESCAPE.clone(); }\npublic static String[][] APOS_ESCAPE() { return APOS_ESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:APOS_UNESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] APOS_UNESCAPE() { return APOS_UNESCAPE.clone(); }\npublic static String[][] APOS_UNESCAPE() { return APOS_UNESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:JAVA_CTRL_CHARS_ESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] JAVA_CTRL_CHARS_ESCAPE() { return JAVA_CTRL_CHARS_ESCAPE.clone(); }\npublic static String[][] JAVA_CTRL_CHARS_ESCAPE() { return JAVA_CTRL_CHARS_ESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:JAVA_CTRL_CHARS_UNESCAPE()[[Ljava/lang/String;",
                                    "method_body": "public static String[][] JAVA_CTRL_CHARS_UNESCAPE() { return JAVA_CTRL_CHARS_UNESCAPE.clone(); }\npublic static String[][] JAVA_CTRL_CHARS_UNESCAPE() { return JAVA_CTRL_CHARS_UNESCAPE.clone(); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.EntityArrays:invert([[Ljava/lang/String;)[[Ljava/lang/String;",
                                    "method_body": "public static String[][] invert(String[][] array) {\nString[][] newarray = new String[array.length][2];\nfor(int i = 0; i<array.length; i++) {\nnewarray[i][0] = array[i][1];\nnewarray[i][1] = array[i][0];\n}\nreturn newarray;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.AggregateTranslator:<init>([Lorg/apache/commons/lang3/text/translate/CharSequenceTranslator;)V",
                                    "method_body": "public AggregateTranslator(CharSequenceTranslator... translators) {\nthis.translators = ArrayUtils.clone(translators);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.AggregateTranslator:translate(Ljava/lang/CharSequence;ILjava/io/Writer;)I",
                                    "method_body": "public int translate(CharSequence input, int index, Writer out) throws IOException {\nfor (CharSequenceTranslator translator : translators) {\nint consumed = translator.translate(input, index, out);\nif(consumed != 0) {\nreturn consumed;\n}\n}\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.UnicodeEscaper:<init>(IIZ)V",
                                    "method_body": "private UnicodeEscaper(int below, int above, boolean between) {\nthis.below = below;\nthis.above = above;\nthis.between = between;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.UnicodeEscaper:outsideOf(II)Lorg/apache/commons/lang3/text/translate/UnicodeEscaper;",
                                    "method_body": "public static UnicodeEscaper outsideOf(int codepointLow, int codepointHigh) {\nreturn new UnicodeEscaper(codepointLow, codepointHigh, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringEscapeUtils$CsvEscaper:<init>()V",
                                    "method_body": "public static final CharSequenceTranslator ESCAPE_CSV = new CsvEscaper();\n\n// TODO: Create a parent class - 'SinglePassTranslator' ?\n//       It would handle the index checking + length returning,\n//       and could also have an optimization check method.\nstatic class CsvEscaper extends CharSequenceTranslator {\n\nprivate static final char CSV_DELIMITER = ',';\nprivate static final char CSV_QUOTE = '\"';\nprivate static final String CSV_QUOTE_STR = String.valueOf(CSV_QUOTE);\nprivate static final char[] CSV_SEARCH_CHARS =\nnew char[] {CSV_DELIMITER, CSV_QUOTE, CharUtils.CR, CharUtils.LF};\n\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n\nif(index != 0) {\nthrow new IllegalStateException(\"CsvEscaper should never reach the [1] index\");\n}\n\nif (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) {\nout.write(input.toString());\n} else {\nout.write(CSV_QUOTE);\nout.write(StringUtils.replace(input.toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\nout.write(CSV_QUOTE);\n}\nreturn input.length();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringEscapeUtils$CsvEscaper:<clinit>()V",
                                    "method_body": "public static final CharSequenceTranslator ESCAPE_CSV = new CsvEscaper();\n\n// TODO: Create a parent class - 'SinglePassTranslator' ?\n//       It would handle the index checking + length returning,\n//       and could also have an optimization check method.\nstatic class CsvEscaper extends CharSequenceTranslator {\n\nprivate static final char CSV_DELIMITER = ',';\nprivate static final char CSV_QUOTE = '\"';\nprivate static final String CSV_QUOTE_STR = String.valueOf(CSV_QUOTE);\nprivate static final char[] CSV_SEARCH_CHARS =\nnew char[] {CSV_DELIMITER, CSV_QUOTE, CharUtils.CR, CharUtils.LF};\n\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n\nif(index != 0) {\nthrow new IllegalStateException(\"CsvEscaper should never reach the [1] index\");\n}\n\nif (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) {\nout.write(input.toString());\n} else {\nout.write(CSV_QUOTE);\nout.write(StringUtils.replace(input.toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\nout.write(CSV_QUOTE);\n}\nreturn input.length();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.OctalUnescaper:<clinit>()V",
                                    "method_body": "private static int OCTAL_MAX = 377;\n\n/**\n* {@inheritDoc}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.NumericEntityUnescaper:<init>([Lorg/apache/commons/lang3/text/translate/NumericEntityUnescaper$OPTION;)V",
                                    "method_body": "public NumericEntityUnescaper(OPTION... options) {\nif(options.length > 0) {\nthis.options = EnumSet.copyOf(Arrays.asList(options));\n} else {\nthis.options = EnumSet.copyOf(Arrays.asList(new OPTION[] { OPTION.semiColonRequired }));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringEscapeUtils$CsvUnescaper:<init>()V",
                                    "method_body": "public static final CharSequenceTranslator UNESCAPE_CSV = new CsvUnescaper();\n\nstatic class CsvUnescaper extends CharSequenceTranslator {\n\nprivate static final char CSV_DELIMITER = ',';\nprivate static final char CSV_QUOTE = '\"';\nprivate static final String CSV_QUOTE_STR = String.valueOf(CSV_QUOTE);\nprivate static final char[] CSV_SEARCH_CHARS =\nnew char[] {CSV_DELIMITER, CSV_QUOTE, CharUtils.CR, CharUtils.LF};\n\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n\nif(index != 0) {\nthrow new IllegalStateException(\"CsvUnescaper should never reach the [1] index\");\n}\n\nif ( input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE ) {\nout.write(input.toString());\nreturn input.length();\n}\n\n// strip quotes\nString quoteless = input.subSequence(1, input.length() - 1).toString();\n\nif ( StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS) ) {\n// deal with escaped quotes; ie) \"\"\nout.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n} else {\nout.write(input.toString());\n}\nreturn input.length();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringEscapeUtils$CsvUnescaper:<clinit>()V",
                                    "method_body": "public static final CharSequenceTranslator UNESCAPE_CSV = new CsvUnescaper();\n\nstatic class CsvUnescaper extends CharSequenceTranslator {\n\nprivate static final char CSV_DELIMITER = ',';\nprivate static final char CSV_QUOTE = '\"';\nprivate static final String CSV_QUOTE_STR = String.valueOf(CSV_QUOTE);\nprivate static final char[] CSV_SEARCH_CHARS =\nnew char[] {CSV_DELIMITER, CSV_QUOTE, CharUtils.CR, CharUtils.LF};\n\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n\nif(index != 0) {\nthrow new IllegalStateException(\"CsvUnescaper should never reach the [1] index\");\n}\n\nif ( input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE ) {\nout.write(input.toString());\nreturn input.length();\n}\n\n// strip quotes\nString quoteless = input.subSequence(1, input.length() - 1).toString();\n\nif ( StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS) ) {\n// deal with escaped quotes; ie) \"\"\nout.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n} else {\nout.write(input.toString());\n}\nreturn input.length();\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 19,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.text.translate.NumericEntityUnescaperTest.testOutOfBounds",
                            "test_body": "37: public void testOutOfBounds() {\n38: NumericEntityUnescaper neu = new NumericEntityUnescaper();\n39: 40: assertEquals(\"Failed to ignore when last character is &\", \"Test &\", neu.translate(\"Test &\"));\n41: assertEquals(\"Failed to ignore when last character is &\", \"Test &#\", neu.translate(\"Test &#\"));\n42: assertEquals(\"Failed to ignore when last character is &\", \"Test &#x\", neu.translate(\"Test &#x\"));\n43: assertEquals(\"Failed to ignore when last character is &\", \"Test &#X\", neu.translate(\"Test &#X\"));\n44: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.CharSequenceTranslator:translate(Ljava/lang/CharSequence;)Ljava/lang/String;",
                                    "method_body": "public abstract int translate(CharSequence input, int index, Writer out) throws IOException;\n\n/**\n* Helper for non-Writer usage.\n* @param input CharSequence to be translated\n* @return String output of translation\n*/\npublic final String translate(CharSequence input) {\nif (input == null) {\nreturn null;\n}\ntry {\nStringWriter writer = new StringWriter(input.length() * 2);\ntranslate(input, writer);\nreturn writer.toString();\n} catch (IOException ioe) {\n// this should never ever happen while writing to a StringWriter\nthrow new RuntimeException(ioe);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.CharSequenceTranslator:translate(Ljava/lang/CharSequence;Ljava/io/Writer;)V",
                                    "method_body": "public final void translate(CharSequence input, Writer out) throws IOException {\nif (out == null) {\nthrow new IllegalArgumentException(\"The Writer must not be null\");\n}\nif (input == null) {\nreturn;\n}\nint sz = Character.codePointCount(input, 0, input.length());\nfor (int i = 0; i < sz; i++) {\n\n// consumed is the number of codepoints consumed\nint consumed = translate(input, i, out);\n\nif (consumed == 0) {\nout.write(Character.toChars(Character.codePointAt(input, i)));\n} else {\n// contract with translators is that they have to understand codepoints\n// and they just took care of a surrogate pair\nfor (int j = 0; j < consumed; j++) {\nif (i < sz - 2) {\ni += Character.charCount(Character.codePointAt(input, i));\n} else {\n// If the String ends with a high surrogate, just add the 1 and don't worry about such things\ni++;\n}\n}\n// for loop will increment 1 anyway, so remove 1 to account for that\ni--;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.NumericEntityUnescaper:translate(Ljava/lang/CharSequence;ILjava/io/Writer;)I",
                                    "method_body": "public int translate(CharSequence input, int index, Writer out) throws IOException {\nint seqEnd = input.length();\n// Uses -2 to ensure there is something after the &#\nif(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\nint start = index + 2;\nboolean isHex = false;\n\nchar firstChar = input.charAt(start);\nif(firstChar == 'x' || firstChar == 'X') {\nstart++;\nisHex = true;\n\n// Check there's more than just an x after the &#\n}\n\nint end = start;\n// Note that this supports character codes without a ; on the end\nwhile(input.charAt(end) != ';')\n{\nend++;\n}\n\nint entityValue;\ntry {\nif(isHex) {\nentityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n} else {\nentityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n}\n} catch(NumberFormatException nfe) {\nSystem.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start +\"][\"+ end +\"]\");\nreturn 0;\n}\n\nif(entityValue > 0xFFFF) {\nchar[] chrs = Character.toChars(entityValue);\nout.write(chrs[0]);\nout.write(chrs[1]);\n} else {\nout.write(entityValue);\n}\n\n\nreturn 2 + (end - start) + (isHex ? 1 : 0) + 1;\n}\nreturn 0;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.text.translate.NumericEntityUnescaperTest.testUnfinishedEntity",
                            "test_body": "46: public void testUnfinishedEntity() {\n47: NumericEntityUnescaper neu = new NumericEntityUnescaper();\n48: String input = \"Test &#x30 not test\";\n49: String expected = \"Test \\u0030 not test\";\n50: 51: String result = neu.translate(input);\n52: assertEquals(\"Failed to support unfinished entities (i.e. missing semi-colon\", expected, result);\n53: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.CharSequenceTranslator:translate(Ljava/lang/CharSequence;)Ljava/lang/String;",
                                    "method_body": "public abstract int translate(CharSequence input, int index, Writer out) throws IOException;\n\n/**\n* Helper for non-Writer usage.\n* @param input CharSequence to be translated\n* @return String output of translation\n*/\npublic final String translate(CharSequence input) {\nif (input == null) {\nreturn null;\n}\ntry {\nStringWriter writer = new StringWriter(input.length() * 2);\ntranslate(input, writer);\nreturn writer.toString();\n} catch (IOException ioe) {\n// this should never ever happen while writing to a StringWriter\nthrow new RuntimeException(ioe);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.CharSequenceTranslator:translate(Ljava/lang/CharSequence;Ljava/io/Writer;)V",
                                    "method_body": "public final void translate(CharSequence input, Writer out) throws IOException {\nif (out == null) {\nthrow new IllegalArgumentException(\"The Writer must not be null\");\n}\nif (input == null) {\nreturn;\n}\nint sz = Character.codePointCount(input, 0, input.length());\nfor (int i = 0; i < sz; i++) {\n\n// consumed is the number of codepoints consumed\nint consumed = translate(input, i, out);\n\nif (consumed == 0) {\nout.write(Character.toChars(Character.codePointAt(input, i)));\n} else {\n// contract with translators is that they have to understand codepoints\n// and they just took care of a surrogate pair\nfor (int j = 0; j < consumed; j++) {\nif (i < sz - 2) {\ni += Character.charCount(Character.codePointAt(input, i));\n} else {\n// If the String ends with a high surrogate, just add the 1 and don't worry about such things\ni++;\n}\n}\n// for loop will increment 1 anyway, so remove 1 to account for that\ni--;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.NumericEntityUnescaper:translate(Ljava/lang/CharSequence;ILjava/io/Writer;)I",
                                    "method_body": "public int translate(CharSequence input, int index, Writer out) throws IOException {\nint seqEnd = input.length();\n// Uses -2 to ensure there is something after the &#\nif(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\nint start = index + 2;\nboolean isHex = false;\n\nchar firstChar = input.charAt(start);\nif(firstChar == 'x' || firstChar == 'X') {\nstart++;\nisHex = true;\n\n// Check there's more than just an x after the &#\n}\n\nint end = start;\n// Note that this supports character codes without a ; on the end\nwhile(input.charAt(end) != ';')\n{\nend++;\n}\n\nint entityValue;\ntry {\nif(isHex) {\nentityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n} else {\nentityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n}\n} catch(NumberFormatException nfe) {\nSystem.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start +\"][\"+ end +\"]\");\nreturn 0;\n}\n\nif(entityValue > 0xFFFF) {\nchar[] chrs = Character.toChars(entityValue);\nout.write(chrs[0]);\nout.write(chrs[1]);\n} else {\nout.write(entityValue);\n}\n\n\nreturn 2 + (end - start) + (isHex ? 1 : 0) + 1;\n}\nreturn 0;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 20,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.StringUtilsTest.testJoin_Objectarray",
                            "test_body": "184: public void testJoin_Objectarray() {\n185: //        assertEquals(null, StringUtils.join(null)); // generates warning\n186: assertEquals(null, StringUtils.join((Object[]) null)); // equivalent explicit cast\n187: // test additional varargs calls\n188: assertEquals(\"\", StringUtils.join()); // empty array\n189: assertEquals(\"\", StringUtils.join((Object) null)); // => new Object[]{null}\n190: 191: assertEquals(\"\", StringUtils.join(EMPTY_ARRAY_LIST));\n192: assertEquals(\"\", StringUtils.join(NULL_ARRAY_LIST));\n193: assertEquals(\"null\", StringUtils.join(NULL_TO_STRING_LIST));\n194: assertEquals(\"abc\", StringUtils.join(new String[] {\"a\", \"b\", \"c\"}));\n195: assertEquals(\"a\", StringUtils.join(new String[] {null, \"a\", \"\"}));\n196: assertEquals(\"foo\", StringUtils.join(MIXED_ARRAY_LIST));\n197: assertEquals(\"foo2\", StringUtils.join(MIXED_TYPE_LIST));\n198: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:<clinit>()V",
                                    "method_body": "public static final String EMPTY = \"\";\n\n/**\n* Represents a failed index search.\n* @since 2.1\n*/\npublic static final int INDEX_NOT_FOUND = -1;\n\n/**\n* <p>The maximum size to which the padding constant(s) can expand.</p>\n*/\nprivate static final int PAD_LIMIT = 8192;\n\n/**\n* A regex pattern for recognizing blocks of whitespace characters.\n*/\nprivate static final Pattern WHITESPACE_BLOCK = Pattern.compile(\"\\\\s+\");\n\n/**\n* <p>{@code StringUtils} instances should NOT be constructed in"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:join([Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static <T> String join(T... elements) {\nreturn join(elements, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:join([Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public static String join(Object[] array, String separator) {\nif (array == null) {\nreturn null;\n}\nreturn join(array, separator, 0, array.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:join([Ljava/lang/Object;Ljava/lang/String;II)Ljava/lang/String;",
                                    "method_body": "public static String join(Object[] array, String separator, int startIndex, int endIndex) {\nif (array == null) {\nreturn null;\n}\nif (separator == null) {\nseparator = EMPTY;\n}\n\n// endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))\n//           (Assuming that all Strings are roughly equally long)\nint noOfItems = (endIndex - startIndex);\nif (noOfItems <= 0) {\nreturn EMPTY;\n}\n\nStringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());\n\nfor (int i = startIndex; i < endIndex; i++) {\nif (i > startIndex) {\nbuf.append(separator);\n}\nif (array[i] != null) {\nbuf.append(array[i]);\n}\n}\nreturn buf.toString();\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.StringUtilsTest.testJoin_ArrayChar",
                            "test_body": "200: public void testJoin_ArrayChar() {\n201: assertEquals(null, StringUtils.join((Object[]) null, ','));\n202: assertEquals(TEXT_LIST_CHAR, StringUtils.join(ARRAY_LIST, SEPARATOR_CHAR));\n203: assertEquals(\"\", StringUtils.join(EMPTY_ARRAY_LIST, SEPARATOR_CHAR));\n204: assertEquals(\";;foo\", StringUtils.join(MIXED_ARRAY_LIST, SEPARATOR_CHAR));\n205: assertEquals(\"foo;2\", StringUtils.join(MIXED_TYPE_LIST, SEPARATOR_CHAR));\n206: 207: assertEquals(\"/\", StringUtils.join(MIXED_ARRAY_LIST, '/', 0, MIXED_ARRAY_LIST.length-1));\n208: assertEquals(\"foo\", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 1));\n209: assertEquals(\"null\", StringUtils.join(NULL_TO_STRING_LIST,'/', 0, 1));\n210: assertEquals(\"foo/2\", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 2));\n211: assertEquals(\"2\", StringUtils.join(MIXED_TYPE_LIST, '/', 1, 2));\n212: assertEquals(\"\", StringUtils.join(MIXED_TYPE_LIST, '/', 2, 1));\n213: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:<clinit>()V",
                                    "method_body": "public static final String EMPTY = \"\";\n\n/**\n* Represents a failed index search.\n* @since 2.1\n*/\npublic static final int INDEX_NOT_FOUND = -1;\n\n/**\n* <p>The maximum size to which the padding constant(s) can expand.</p>\n*/\nprivate static final int PAD_LIMIT = 8192;\n\n/**\n* A regex pattern for recognizing blocks of whitespace characters.\n*/\nprivate static final Pattern WHITESPACE_BLOCK = Pattern.compile(\"\\\\s+\");\n\n/**\n* <p>{@code StringUtils} instances should NOT be constructed in"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:join([Ljava/lang/Object;C)Ljava/lang/String;",
                                    "method_body": "public static String join(Object[] array, char separator) {\nif (array == null) {\nreturn null;\n}\n\nreturn join(array, separator, 0, array.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:join([Ljava/lang/Object;CII)Ljava/lang/String;",
                                    "method_body": "public static String join(Object[] array, char separator, int startIndex, int endIndex) {\nif (array == null) {\nreturn null;\n}\nint noOfItems = (endIndex - startIndex);\nif (noOfItems <= 0) {\nreturn EMPTY;\n}\n\nStringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n\nfor (int i = startIndex; i < endIndex; i++) {\nif (i > startIndex) {\nbuf.append(separator);\n}\nif (array[i] != null) {\nbuf.append(array[i]);\n}\n}\nreturn buf.toString();\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 21,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.time.DateUtilsTest.testIsSameLocalTime_Cal",
                            "test_body": "222: public void testIsSameLocalTime_Cal() {\n223: GregorianCalendar cal1 = new GregorianCalendar(TimeZone.getTimeZone(\"GMT+1\"));\n224: GregorianCalendar cal2 = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-1\"));\n225: cal1.set(2004, 6, 9, 13, 45, 0);\n226: cal1.set(Calendar.MILLISECOND, 0);\n227: cal2.set(2004, 6, 9, 13, 45, 0);\n228: cal2.set(Calendar.MILLISECOND, 0);\n229: assertEquals(true, DateUtils.isSameLocalTime(cal1, cal2));\n230: 231: Calendar cal3 = Calendar.getInstance();\n232: Calendar cal4 = Calendar.getInstance();\n233: cal3.set(2004, 6, 9, 4,  0, 0);\n234: cal4.set(2004, 6, 9, 16, 0, 0);\n235: cal3.set(Calendar.MILLISECOND, 0);\n236: cal4.set(Calendar.MILLISECOND, 0);\n237: assertFalse(\"LANG-677\", DateUtils.isSameLocalTime(cal3, cal4));\n238: 239: cal2.set(2004, 6, 9, 11, 45, 0);\n240: assertEquals(false, DateUtils.isSameLocalTime(cal1, cal2));\n241: try {\n242: DateUtils.isSameLocalTime((Calendar) null, (Calendar) null);\n243: fail();\n244: } catch (IllegalArgumentException ex) {}\n245: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.time.DateUtils:<clinit>()V",
                                    "method_body": "public static final TimeZone UTC_TIME_ZONE = TimeZone.getTimeZone(\"GMT\");\n/**\n* Number of milliseconds in a standard second.\n* @since 2.1\n*/\npublic static final long MILLIS_PER_SECOND = 1000;\n/**\n* Number of milliseconds in a standard minute.\n* @since 2.1\n*/\npublic static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n/**\n* Number of milliseconds in a standard hour.\n* @since 2.1\n*/\npublic static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n/**\n* Number of milliseconds in a standard day.\n* @since 2.1\n*/\npublic static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR;\n\n/**\n* This is half a month, so this represents whether a date is in the top\n* or bottom half of the month.\n*/\npublic final static int SEMI_MONTH = 1001;\n\nprivate static final int[][] fields = {\n{Calendar.MILLISECOND},\n{Calendar.SECOND},\n{Calendar.MINUTE},\n{Calendar.HOUR_OF_DAY, Calendar.HOUR},\n{Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM\n/* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */\n},\n{Calendar.MONTH, DateUtils.SEMI_MONTH},\n{Calendar.YEAR},\n{Calendar.ERA}};"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.DateUtils:isSameLocalTime(Ljava/util/Calendar;Ljava/util/Calendar;)Z",
                                    "method_body": "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\nif (cal1 == null || cal2 == null) {\nthrow new IllegalArgumentException(\"The date must not be null\");\n}\nreturn (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\ncal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\ncal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\ncal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\ncal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\ncal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\ncal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\ncal1.getClass() == cal2.getClass());\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 22,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.math.FractionTest.testReduce",
                            "test_body": "610: public void testReduce() {\n611: Fraction f = null;\n612: 613: f = Fraction.getFraction(50, 75);\n614: Fraction result = f.reduce();\n615: assertEquals(2, result.getNumerator());\n616: assertEquals(3, result.getDenominator());\n617: 618: f = Fraction.getFraction(-2, -3);\n619: result = f.reduce();\n620: assertEquals(2, result.getNumerator());\n621: assertEquals(3, result.getDenominator());\n622: 623: f = Fraction.getFraction(2, -3);\n624: result = f.reduce();\n625: assertEquals(-2, result.getNumerator());\n626: assertEquals(3, result.getDenominator());\n627: 628: f = Fraction.getFraction(-2, 3);\n629: result = f.reduce();\n630: assertEquals(-2, result.getNumerator());\n631: assertEquals(3, result.getDenominator());\n632: assertSame(f, result);\n633: 634: f = Fraction.getFraction(2, 3);\n635: result = f.reduce();\n636: assertEquals(2, result.getNumerator());\n637: assertEquals(3, result.getDenominator());\n638: assertSame(f, result);\n639: 640: f = Fraction.getFraction(0, 1);\n641: result = f.reduce();\n642: assertEquals(0, result.getNumerator());\n643: assertEquals(1, result.getDenominator());\n644: assertSame(f, result);\n645: 646: f = Fraction.getFraction(0, 100);\n647: result = f.reduce();\n648: assertEquals(0, result.getNumerator());\n649: assertEquals(1, result.getDenominator());\n650: assertSame(result, Fraction.ZERO);\n651: 652: f = Fraction.getFraction(Integer.MIN_VALUE, 2);\n653: result = f.reduce();\n654: assertEquals(Integer.MIN_VALUE / 2, result.getNumerator());\n655: assertEquals(1, result.getDenominator());\n656: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.math.Fraction:<init>(II)V",
                                    "method_body": "private Fraction(int numerator, int denominator) {\nsuper();\nthis.numerator = numerator;\nthis.denominator = denominator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.Fraction:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 65382027393090L;\n\n/**\n* <code>Fraction</code> representation of 0.\n*/\npublic static final Fraction ZERO = new Fraction(0, 1);\n/**\n* <code>Fraction</code> representation of 1.\n*/\npublic static final Fraction ONE = new Fraction(1, 1);\n/**\n* <code>Fraction</code> representation of 1/2.\n*/\npublic static final Fraction ONE_HALF = new Fraction(1, 2);\n/**\n* <code>Fraction</code> representation of 1/3.\n*/\npublic static final Fraction ONE_THIRD = new Fraction(1, 3);\n/**\n* <code>Fraction</code> representation of 2/3.\n*/\npublic static final Fraction TWO_THIRDS = new Fraction(2, 3);\n/**\n* <code>Fraction</code> representation of 1/4.\n*/\npublic static final Fraction ONE_QUARTER = new Fraction(1, 4);\n/**\n* <code>Fraction</code> representation of 2/4.\n*/\npublic static final Fraction TWO_QUARTERS = new Fraction(2, 4);\n/**\n* <code>Fraction</code> representation of 3/4.\n*/\npublic static final Fraction THREE_QUARTERS = new Fraction(3, 4);\n/**\n* <code>Fraction</code> representation of 1/5.\n*/\npublic static final Fraction ONE_FIFTH = new Fraction(1, 5);\n/**\n* <code>Fraction</code> representation of 2/5.\n*/\npublic static final Fraction TWO_FIFTHS = new Fraction(2, 5);\n/**\n* <code>Fraction</code> representation of 3/5.\n*/\npublic static final Fraction THREE_FIFTHS = new Fraction(3, 5);\n/**\n* <code>Fraction</code> representation of 4/5.\n*/\npublic static final Fraction FOUR_FIFTHS = new Fraction(4, 5);\n\n\n/**\n* The numerator number part of the fraction (the three in three sevenths).\n*/\nprivate final int numerator;\n/**\n* The denominator number part of the fraction (the seven in three sevenths).\n*/\nprivate final int denominator;\n\n/**\n* Cached output hashCode (class is immutable).\n*/\nprivate transient int hashCode = 0;\n/**\n* Cached output toString (class is immutable).\n*/\nprivate transient String toString = null;\n/**\n* Cached output toProperString (class is immutable).\n*/\nprivate transient String toProperString = null;\n\n/**\n* <p>Constructs a <code>Fraction</code> instance with the 2 parts\n* of a fraction Y/Z.</p>\n*\n* @param numerator  the numerator, for example the three in 'three sevenths'\n* @param denominator  the denominator, for example the seven in 'three sevenths'\n*/\nprivate Fraction(int numerator, int denominator) {\nsuper();\nthis.numerator = numerator;\nthis.denominator = denominator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.Fraction:getNumerator()I",
                                    "method_body": "public int getNumerator() {\nreturn numerator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.Fraction:getDenominator()I",
                                    "method_body": "public int getDenominator() {\nreturn denominator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.Fraction:greatestCommonDivisor(II)I",
                                    "method_body": "private static int greatestCommonDivisor(int u, int v) {\n// From Commons Math:\n//if either operand is abs 1, return 1:\nif (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\nreturn 1;\n}\n// keep u and v negative, as negative integers range down to\n// -2^31, while positive numbers can only be as large as 2^31-1\n// (i.e. we can't necessarily negate a negative number without\n// overflow)\nif (u>0) { u=-u; } // make u negative\nif (v>0) { v=-v; } // make v negative\n// B1. [Find power of 2]\nint k=0;\nwhile ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\nu/=2; v/=2; k++; // cast out twos.\n}\nif (k==31) {\nthrow new ArithmeticException(\"overflow: gcd is 2^31\");\n}\n// B2. Initialize: u and v have been divided by 2^k and at least\n//     one is odd.\nint t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n// t negative: u was odd, v may be even (t replaces v)\n// t positive: u was even, v is odd (t replaces u)\ndo {\n/* assert u<0 && v<0; */\n// B4/B3: cast out twos from t.\nwhile ((t&1)==0) { // while t is even..\nt/=2; // cast out twos\n}\n// B5 [reset max(u,v)]\nif (t>0) {\nu = -t;\n} else {\nv = t;\n}\n// B6/B3. at this point both u and v should be odd.\nt = (v - u)/2;\n// |u| larger: t positive (replace u)\n// |v| larger: t negative (replace v)\n} while (t!=0);\nreturn -u*(1<<k); // gcd is u*2^k\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.Fraction:getFraction(II)Lorg/apache/commons/lang3/math/Fraction;",
                                    "method_body": "public static Fraction getFraction(int numerator, int denominator) {\nif (denominator == 0) {\nthrow new ArithmeticException(\"The denominator must not be zero\");\n}\nif (denominator < 0) {\nif (numerator==Integer.MIN_VALUE ||\ndenominator==Integer.MIN_VALUE) {\nthrow new ArithmeticException(\"overflow: can't negate\");\n}\nnumerator = -numerator;\ndenominator = -denominator;\n}\nreturn new Fraction(numerator, denominator);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.Fraction:reduce()Lorg/apache/commons/lang3/math/Fraction;",
                                    "method_body": "public Fraction reduce() {\nif (numerator == 0) {\nreturn equals(ZERO) ? this : ZERO;\n}\nint gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\nif (gcd == 1) {\nreturn this;\n}\nreturn Fraction.getFraction(numerator / gcd, denominator / gcd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.Fraction:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object obj) {\nif (obj == this) {\nreturn true;\n}\nif (obj instanceof Fraction == false) {\nreturn false;\n}\nFraction other = (Fraction) obj;\nreturn (getNumerator() == other.getNumerator() &&\ngetDenominator() == other.getDenominator());\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.math.FractionTest.testReducedFactory_int_int",
                            "test_body": "250: public void testReducedFactory_int_int() {\n251: Fraction f = null;\n252: 253: // zero\n254: f = Fraction.getReducedFraction(0, 1);\n255: assertEquals(0, f.getNumerator());\n256: assertEquals(1, f.getDenominator());\n257: 258: // normal\n259: f = Fraction.getReducedFraction(1, 1);\n260: assertEquals(1, f.getNumerator());\n261: assertEquals(1, f.getDenominator());\n262: 263: f = Fraction.getReducedFraction(2, 1);\n264: assertEquals(2, f.getNumerator());\n265: assertEquals(1, f.getDenominator());\n266: 267: // improper\n268: f = Fraction.getReducedFraction(22, 7);\n269: assertEquals(22, f.getNumerator());\n270: assertEquals(7, f.getDenominator());\n271: 272: // negatives\n273: f = Fraction.getReducedFraction(-6, 10);\n274: assertEquals(-3, f.getNumerator());\n275: assertEquals(5, f.getDenominator());\n276: 277: f = Fraction.getReducedFraction(6, -10);\n278: assertEquals(-3, f.getNumerator());\n279: assertEquals(5, f.getDenominator());\n280: 281: f = Fraction.getReducedFraction(-6, -10);\n282: assertEquals(3, f.getNumerator());\n283: assertEquals(5, f.getDenominator());\n284: 285: // zero denominator\n286: try {\n287: f = Fraction.getReducedFraction(1, 0);\n288: fail(\"expecting ArithmeticException\");\n289: } catch (ArithmeticException ex) {}\n290: 291: try {\n292: f = Fraction.getReducedFraction(2, 0);\n293: fail(\"expecting ArithmeticException\");\n294: } catch (ArithmeticException ex) {}\n295: 296: try {\n297: f = Fraction.getReducedFraction(-3, 0);\n298: fail(\"expecting ArithmeticException\");\n299: } catch (ArithmeticException ex) {}\n300: 301: // reduced        \n302: f = Fraction.getReducedFraction(0, 2);\n303: assertEquals(0, f.getNumerator());\n304: assertEquals(1, f.getDenominator());\n305: 306: f = Fraction.getReducedFraction(2, 2);\n307: assertEquals(1, f.getNumerator());\n308: assertEquals(1, f.getDenominator());\n309: 310: f = Fraction.getReducedFraction(2, 4);\n311: assertEquals(1, f.getNumerator());\n312: assertEquals(2, f.getDenominator());\n313: 314: f = Fraction.getReducedFraction(15, 10);\n315: assertEquals(3, f.getNumerator());\n316: assertEquals(2, f.getDenominator());\n317: 318: f = Fraction.getReducedFraction(121, 22);\n319: assertEquals(11, f.getNumerator());\n320: assertEquals(2, f.getDenominator());\n321: 322: // Extreme values \n323: // OK, can reduce before negating\n324: f = Fraction.getReducedFraction(-2, Integer.MIN_VALUE);\n325: assertEquals(1, f.getNumerator());\n326: assertEquals(-(Integer.MIN_VALUE / 2), f.getDenominator());\n327: 328: // Can't reduce, negation will throw\n329: try { \n330: f = Fraction.getReducedFraction(-7, Integer.MIN_VALUE);  \n331: fail(\"Expecting ArithmeticException\");\n332: } catch (ArithmeticException ex) {}      \n333: 334: // LANG-662\n335: f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2);\n336: assertEquals(Integer.MIN_VALUE / 2, f.getNumerator());\n337: assertEquals(1, f.getDenominator());\n338: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.math.Fraction:<init>(II)V",
                                    "method_body": "private Fraction(int numerator, int denominator) {\nsuper();\nthis.numerator = numerator;\nthis.denominator = denominator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.Fraction:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 65382027393090L;\n\n/**\n* <code>Fraction</code> representation of 0.\n*/\npublic static final Fraction ZERO = new Fraction(0, 1);\n/**\n* <code>Fraction</code> representation of 1.\n*/\npublic static final Fraction ONE = new Fraction(1, 1);\n/**\n* <code>Fraction</code> representation of 1/2.\n*/\npublic static final Fraction ONE_HALF = new Fraction(1, 2);\n/**\n* <code>Fraction</code> representation of 1/3.\n*/\npublic static final Fraction ONE_THIRD = new Fraction(1, 3);\n/**\n* <code>Fraction</code> representation of 2/3.\n*/\npublic static final Fraction TWO_THIRDS = new Fraction(2, 3);\n/**\n* <code>Fraction</code> representation of 1/4.\n*/\npublic static final Fraction ONE_QUARTER = new Fraction(1, 4);\n/**\n* <code>Fraction</code> representation of 2/4.\n*/\npublic static final Fraction TWO_QUARTERS = new Fraction(2, 4);\n/**\n* <code>Fraction</code> representation of 3/4.\n*/\npublic static final Fraction THREE_QUARTERS = new Fraction(3, 4);\n/**\n* <code>Fraction</code> representation of 1/5.\n*/\npublic static final Fraction ONE_FIFTH = new Fraction(1, 5);\n/**\n* <code>Fraction</code> representation of 2/5.\n*/\npublic static final Fraction TWO_FIFTHS = new Fraction(2, 5);\n/**\n* <code>Fraction</code> representation of 3/5.\n*/\npublic static final Fraction THREE_FIFTHS = new Fraction(3, 5);\n/**\n* <code>Fraction</code> representation of 4/5.\n*/\npublic static final Fraction FOUR_FIFTHS = new Fraction(4, 5);\n\n\n/**\n* The numerator number part of the fraction (the three in three sevenths).\n*/\nprivate final int numerator;\n/**\n* The denominator number part of the fraction (the seven in three sevenths).\n*/\nprivate final int denominator;\n\n/**\n* Cached output hashCode (class is immutable).\n*/\nprivate transient int hashCode = 0;\n/**\n* Cached output toString (class is immutable).\n*/\nprivate transient String toString = null;\n/**\n* Cached output toProperString (class is immutable).\n*/\nprivate transient String toProperString = null;\n\n/**\n* <p>Constructs a <code>Fraction</code> instance with the 2 parts\n* of a fraction Y/Z.</p>\n*\n* @param numerator  the numerator, for example the three in 'three sevenths'\n* @param denominator  the denominator, for example the seven in 'three sevenths'\n*/\nprivate Fraction(int numerator, int denominator) {\nsuper();\nthis.numerator = numerator;\nthis.denominator = denominator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.Fraction:getReducedFraction(II)Lorg/apache/commons/lang3/math/Fraction;",
                                    "method_body": "public static Fraction getReducedFraction(int numerator, int denominator) {\nif (denominator == 0) {\nthrow new ArithmeticException(\"The denominator must not be zero\");\n}\nif (numerator==0) {\nreturn ZERO; // normalize zero.\n}\n// allow 2^k/-2^31 as a valid fraction (where k>0)\nif (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\nnumerator/=2; denominator/=2;\n}\nif (denominator < 0) {\nif (numerator==Integer.MIN_VALUE ||\ndenominator==Integer.MIN_VALUE) {\nthrow new ArithmeticException(\"overflow: can't negate\");\n}\nnumerator = -numerator;\ndenominator = -denominator;\n}\n// simplify fraction.\nint gcd = greatestCommonDivisor(numerator, denominator);\nnumerator /= gcd;\ndenominator /= gcd;\nreturn new Fraction(numerator, denominator);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.Fraction:getNumerator()I",
                                    "method_body": "public int getNumerator() {\nreturn numerator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.Fraction:getDenominator()I",
                                    "method_body": "public int getDenominator() {\nreturn denominator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.Fraction:greatestCommonDivisor(II)I",
                                    "method_body": "private static int greatestCommonDivisor(int u, int v) {\n// From Commons Math:\n//if either operand is abs 1, return 1:\nif (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\nreturn 1;\n}\n// keep u and v negative, as negative integers range down to\n// -2^31, while positive numbers can only be as large as 2^31-1\n// (i.e. we can't necessarily negate a negative number without\n// overflow)\nif (u>0) { u=-u; } // make u negative\nif (v>0) { v=-v; } // make v negative\n// B1. [Find power of 2]\nint k=0;\nwhile ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\nu/=2; v/=2; k++; // cast out twos.\n}\nif (k==31) {\nthrow new ArithmeticException(\"overflow: gcd is 2^31\");\n}\n// B2. Initialize: u and v have been divided by 2^k and at least\n//     one is odd.\nint t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n// t negative: u was odd, v may be even (t replaces v)\n// t positive: u was even, v is odd (t replaces u)\ndo {\n/* assert u<0 && v<0; */\n// B4/B3: cast out twos from t.\nwhile ((t&1)==0) { // while t is even..\nt/=2; // cast out twos\n}\n// B5 [reset max(u,v)]\nif (t>0) {\nu = -t;\n} else {\nv = t;\n}\n// B6/B3. at this point both u and v should be odd.\nt = (v - u)/2;\n// |u| larger: t positive (replace u)\n// |v| larger: t negative (replace v)\n} while (t!=0);\nreturn -u*(1<<k); // gcd is u*2^k\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 24,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.math.NumberUtilsTest.testIsNumber",
                            "test_body": "1005: public void testIsNumber() {\n1006: String val = \"12345\";\n1007: assertTrue(\"isNumber(String) 1 failed\", NumberUtils.isNumber(val));\n1008: assertTrue(\"isNumber(String)/createNumber(String) 1 failed\", checkCreateNumber(val));\n1009: val = \"1234.5\";\n1010: assertTrue(\"isNumber(String) 2 failed\", NumberUtils.isNumber(val));\n1011: assertTrue(\"isNumber(String)/createNumber(String) 2 failed\", checkCreateNumber(val));\n1012: val = \".12345\";\n1013: assertTrue(\"isNumber(String) 3 failed\", NumberUtils.isNumber(val));\n1014: assertTrue(\"isNumber(String)/createNumber(String) 3 failed\", checkCreateNumber(val));\n1015: val = \"1234E5\";\n1016: assertTrue(\"isNumber(String) 4 failed\", NumberUtils.isNumber(val));\n1017: assertTrue(\"isNumber(String)/createNumber(String) 4 failed\", checkCreateNumber(val));\n1018: val = \"1234E+5\";\n1019: assertTrue(\"isNumber(String) 5 failed\", NumberUtils.isNumber(val));\n1020: assertTrue(\"isNumber(String)/createNumber(String) 5 failed\", checkCreateNumber(val));\n1021: val = \"1234E-5\";\n1022: assertTrue(\"isNumber(String) 6 failed\", NumberUtils.isNumber(val));\n1023: assertTrue(\"isNumber(String)/createNumber(String) 6 failed\", checkCreateNumber(val));\n1024: val = \"123.4E5\";\n1025: assertTrue(\"isNumber(String) 7 failed\", NumberUtils.isNumber(val));\n1026: assertTrue(\"isNumber(String)/createNumber(String) 7 failed\", checkCreateNumber(val));\n1027: val = \"-1234\";\n1028: assertTrue(\"isNumber(String) 8 failed\", NumberUtils.isNumber(val));\n1029: assertTrue(\"isNumber(String)/createNumber(String) 8 failed\", checkCreateNumber(val));\n1030: val = \"-1234.5\";\n1031: assertTrue(\"isNumber(String) 9 failed\", NumberUtils.isNumber(val));\n1032: assertTrue(\"isNumber(String)/createNumber(String) 9 failed\", checkCreateNumber(val));\n1033: val = \"-.12345\";\n1034: assertTrue(\"isNumber(String) 10 failed\", NumberUtils.isNumber(val));\n1035: assertTrue(\"isNumber(String)/createNumber(String) 10 failed\", checkCreateNumber(val));\n1036: val = \"-1234E5\";\n1037: assertTrue(\"isNumber(String) 11 failed\", NumberUtils.isNumber(val));\n1038: assertTrue(\"isNumber(String)/createNumber(String) 11 failed\", checkCreateNumber(val));\n1039: val = \"0\";\n1040: assertTrue(\"isNumber(String) 12 failed\", NumberUtils.isNumber(val));\n1041: assertTrue(\"isNumber(String)/createNumber(String) 12 failed\", checkCreateNumber(val));\n1042: val = \"-0\";\n1043: assertTrue(\"isNumber(String) 13 failed\", NumberUtils.isNumber(val));\n1044: assertTrue(\"isNumber(String)/createNumber(String) 13 failed\", checkCreateNumber(val));\n1045: val = \"01234\";\n1046: assertTrue(\"isNumber(String) 14 failed\", NumberUtils.isNumber(val));\n1047: assertTrue(\"isNumber(String)/createNumber(String) 14 failed\", checkCreateNumber(val));\n1048: val = \"-01234\";\n1049: assertTrue(\"isNumber(String) 15 failed\", NumberUtils.isNumber(val));\n1050: assertTrue(\"isNumber(String)/createNumber(String) 15 failed\", checkCreateNumber(val));\n1051: val = \"0xABC123\";\n1052: assertTrue(\"isNumber(String) 16 failed\", NumberUtils.isNumber(val));\n1053: assertTrue(\"isNumber(String)/createNumber(String) 16 failed\", checkCreateNumber(val));\n1054: val = \"0x0\";\n1055: assertTrue(\"isNumber(String) 17 failed\", NumberUtils.isNumber(val));\n1056: assertTrue(\"isNumber(String)/createNumber(String) 17 failed\", checkCreateNumber(val));\n1057: val = \"123.4E21D\";\n1058: assertTrue(\"isNumber(String) 19 failed\", NumberUtils.isNumber(val));\n1059: assertTrue(\"isNumber(String)/createNumber(String) 19 failed\", checkCreateNumber(val));\n1060: val = \"-221.23F\";\n1061: assertTrue(\"isNumber(String) 20 failed\", NumberUtils.isNumber(val));\n1062: assertTrue(\"isNumber(String)/createNumber(String) 20 failed\", checkCreateNumber(val));\n1063: val = \"22338L\";\n1064: assertTrue(\"isNumber(String) 21 failed\", NumberUtils.isNumber(val));\n1065: assertTrue(\"isNumber(String)/createNumber(String) 21 failed\", checkCreateNumber(val));\n1066: val = null;\n1067: assertTrue(\"isNumber(String) 1 Neg failed\", !NumberUtils.isNumber(val));\n1068: assertTrue(\"isNumber(String)/createNumber(String) 1 Neg failed\", !checkCreateNumber(val));\n1069: val = \"\";\n1070: assertTrue(\"isNumber(String) 2 Neg failed\", !NumberUtils.isNumber(val));\n1071: assertTrue(\"isNumber(String)/createNumber(String) 2 Neg failed\", !checkCreateNumber(val));\n1072: val = \"--2.3\";\n1073: assertTrue(\"isNumber(String) 3 Neg failed\", !NumberUtils.isNumber(val));\n1074: assertTrue(\"isNumber(String)/createNumber(String) 3 Neg failed\", !checkCreateNumber(val));\n1075: val = \".12.3\";\n1076: assertTrue(\"isNumber(String) 4 Neg failed\", !NumberUtils.isNumber(val));\n1077: assertTrue(\"isNumber(String)/createNumber(String) 4 Neg failed\", !checkCreateNumber(val));\n1078: val = \"-123E\";\n1079: assertTrue(\"isNumber(String) 5 Neg failed\", !NumberUtils.isNumber(val));\n1080: assertTrue(\"isNumber(String)/createNumber(String) 5 Neg failed\", !checkCreateNumber(val));\n1081: val = \"-123E+-212\";\n1082: assertTrue(\"isNumber(String) 6 Neg failed\", !NumberUtils.isNumber(val));\n1083: assertTrue(\"isNumber(String)/createNumber(String) 6 Neg failed\", !checkCreateNumber(val));\n1084: val = \"-123E2.12\";\n1085: assertTrue(\"isNumber(String) 7 Neg failed\", !NumberUtils.isNumber(val));\n1086: assertTrue(\"isNumber(String)/createNumber(String) 7 Neg failed\", !checkCreateNumber(val));\n1087: val = \"0xGF\";\n1088: assertTrue(\"isNumber(String) 8 Neg failed\", !NumberUtils.isNumber(val));\n1089: assertTrue(\"isNumber(String)/createNumber(String) 8 Neg failed\", !checkCreateNumber(val));\n1090: val = \"0xFAE-1\";\n1091: assertTrue(\"isNumber(String) 9 Neg failed\", !NumberUtils.isNumber(val));\n1092: assertTrue(\"isNumber(String)/createNumber(String) 9 Neg failed\", !checkCreateNumber(val));\n1093: val = \".\";\n1094: assertTrue(\"isNumber(String) 10 Neg failed\", !NumberUtils.isNumber(val));\n1095: assertTrue(\"isNumber(String)/createNumber(String) 10 Neg failed\", !checkCreateNumber(val));\n1096: val = \"-0ABC123\";\n1097: assertTrue(\"isNumber(String) 11 Neg failed\", !NumberUtils.isNumber(val));\n1098: assertTrue(\"isNumber(String)/createNumber(String) 11 Neg failed\", !checkCreateNumber(val));\n1099: val = \"123.4E-D\";\n1100: assertTrue(\"isNumber(String) 12 Neg failed\", !NumberUtils.isNumber(val));\n1101: assertTrue(\"isNumber(String)/createNumber(String) 12 Neg failed\", !checkCreateNumber(val));\n1102: val = \"123.4ED\";\n1103: assertTrue(\"isNumber(String) 13 Neg failed\", !NumberUtils.isNumber(val));\n1104: assertTrue(\"isNumber(String)/createNumber(String) 13 Neg failed\", !checkCreateNumber(val));\n1105: val = \"1234E5l\";\n1106: assertTrue(\"isNumber(String) 14 Neg failed\", !NumberUtils.isNumber(val));\n1107: assertTrue(\"isNumber(String)/createNumber(String) 14 Neg failed\", !checkCreateNumber(val));\n1108: val = \"11a\";\n1109: assertTrue(\"isNumber(String) 15 Neg failed\", !NumberUtils.isNumber(val));\n1110: assertTrue(\"isNumber(String)/createNumber(String) 15 Neg failed\", !checkCreateNumber(val)); \n1111: val = \"1a\";\n1112: assertTrue(\"isNumber(String) 16 Neg failed\", !NumberUtils.isNumber(val));\n1113: assertTrue(\"isNumber(String)/createNumber(String) 16 Neg failed\", !checkCreateNumber(val)); \n1114: val = \"a\";\n1115: assertTrue(\"isNumber(String) 17 Neg failed\", !NumberUtils.isNumber(val));\n1116: assertTrue(\"isNumber(String)/createNumber(String) 17 Neg failed\", !checkCreateNumber(val)); \n1117: val = \"11g\";\n1118: assertTrue(\"isNumber(String) 18 Neg failed\", !NumberUtils.isNumber(val));\n1119: assertTrue(\"isNumber(String)/createNumber(String) 18 Neg failed\", !checkCreateNumber(val)); \n1120: val = \"11z\";\n1121: assertTrue(\"isNumber(String) 19 Neg failed\", !NumberUtils.isNumber(val));\n1122: assertTrue(\"isNumber(String)/createNumber(String) 19 Neg failed\", !checkCreateNumber(val)); \n1123: val = \"11def\";\n1124: assertTrue(\"isNumber(String) 20 Neg failed\", !NumberUtils.isNumber(val));\n1125: assertTrue(\"isNumber(String)/createNumber(String) 20 Neg failed\", !checkCreateNumber(val)); \n1126: val = \"11d11\";\n1127: assertTrue(\"isNumber(String) 21 Neg failed\", !NumberUtils.isNumber(val));\n1128: assertTrue(\"isNumber(String)/createNumber(String) 21 Neg failed\", !checkCreateNumber(val)); \n1129: val = \"11 11\";\n1130: assertTrue(\"isNumber(String) 22 Neg failed\", !NumberUtils.isNumber(val));\n1131: assertTrue(\"isNumber(String)/createNumber(String) 22 Neg failed\", !checkCreateNumber(val));\n1132: val = \" 1111\";\n1133: assertTrue(\"isNumber(String) 23 Neg failed\", !NumberUtils.isNumber(val));\n1134: assertTrue(\"isNumber(String)/createNumber(String) 23 Neg failed\", !checkCreateNumber(val));\n1135: val = \"1111 \";\n1136: assertTrue(\"isNumber(String) 24 Neg failed\", !NumberUtils.isNumber(val));\n1137: assertTrue(\"isNumber(String)/createNumber(String) 24 Neg failed\", !checkCreateNumber(val));\n1138: 1139: // LANG-521\n1140: val = \"2.\";\n1141: assertTrue(\"isNumber(String) LANG-521 failed\", NumberUtils.isNumber(val));\n1142: 1143: // LANG-664\n1144: val = \"1.1L\";\n1145: assertFalse(\"isNumber(String) LANG-664 failed\", NumberUtils.isNumber(val));\n1146: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:<clinit>()V",
                                    "method_body": "public static final String EMPTY = \"\";\n\n/**\n* Represents a failed index search.\n* @since 2.1\n*/\npublic static final int INDEX_NOT_FOUND = -1;\n\n/**\n* <p>The maximum size to which the padding constant(s) can expand.</p>\n*/\nprivate static final int PAD_LIMIT = 8192;\n\n/**\n* A regex pattern for recognizing blocks of whitespace characters.\n*/\nprivate static final Pattern WHITESPACE_BLOCK = Pattern.compile(\"\\\\s+\");\n\n/**\n* <p><code>StringUtils</code> instances should NOT be constructed in\n* standard programming. Instead, the class should be used as\n* <code>StringUtils.trim(\" foo \");</code>.</p>\n*\n* <p>This constructor is public to permit tools that require a JavaBean\n* instance to operate.</p>\n*/\npublic StringUtils() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:isEmpty(Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean isEmpty(CharSequence cs) {\nreturn cs == null || cs.length() == 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:isBlank(Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean isBlank(CharSequence cs) {\nint strLen;\nif (cs == null || (strLen = cs.length()) == 0) {\nreturn true;\n}\nfor (int i = 0; i < strLen; i++) {\nif ((Character.isWhitespace(cs.charAt(i)) == false)) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:<clinit>()V",
                                    "method_body": "public static final Long LONG_ZERO = new Long(0L);\n/** Reusable Long constant for one. */\npublic static final Long LONG_ONE = new Long(1L);\n/** Reusable Long constant for minus one. */\npublic static final Long LONG_MINUS_ONE = new Long(-1L);\n/** Reusable Integer constant for zero. */\npublic static final Integer INTEGER_ZERO = new Integer(0);\n/** Reusable Integer constant for one. */\npublic static final Integer INTEGER_ONE = new Integer(1);\n/** Reusable Integer constant for minus one. */\npublic static final Integer INTEGER_MINUS_ONE = new Integer(-1);\n/** Reusable Short constant for zero. */\npublic static final Short SHORT_ZERO = new Short((short) 0);\n/** Reusable Short constant for one. */\npublic static final Short SHORT_ONE = new Short((short) 1);\n/** Reusable Short constant for minus one. */\npublic static final Short SHORT_MINUS_ONE = new Short((short) -1);\n/** Reusable Byte constant for zero. */\npublic static final Byte BYTE_ZERO = Byte.valueOf((byte) 0);\n/** Reusable Byte constant for one. */\npublic static final Byte BYTE_ONE = Byte.valueOf((byte) 1);\n/** Reusable Byte constant for minus one. */\npublic static final Byte BYTE_MINUS_ONE = Byte.valueOf((byte) -1);\n/** Reusable Double constant for zero. */\npublic static final Double DOUBLE_ZERO = new Double(0.0d);\n/** Reusable Double constant for one. */\npublic static final Double DOUBLE_ONE = new Double(1.0d);\n/** Reusable Double constant for minus one. */\npublic static final Double DOUBLE_MINUS_ONE = new Double(-1.0d);\n/** Reusable Float constant for zero. */\npublic static final Float FLOAT_ZERO = new Float(0.0f);\n/** Reusable Float constant for one. */\npublic static final Float FLOAT_ONE = new Float(1.0f);\n/** Reusable Float constant for minus one. */\npublic static final Float FLOAT_MINUS_ONE = new Float(-1.0f);\n\n/**\n* <p><code>NumberUtils</code> instances should NOT be constructed in standard programming.\n* Instead, the class should be used as <code>NumberUtils.toInt(\"6\");</code>.</p>\n*\n* <p>This constructor is public to permit tools that require a JavaBean instance\n* to operate.</p>\n*/\npublic NumberUtils() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createNumber(Ljava/lang/String;)Ljava/lang/Number;",
                                    "method_body": "public static Number createNumber(String str) throws NumberFormatException {\nif (str == null) {\nreturn null;\n}\nif (StringUtils.isBlank(str)) {\nthrow new NumberFormatException(\"A blank string is not a valid number\");\n}\nif (str.startsWith(\"--\")) {\n// this is protection for poorness in java.lang.BigDecimal.\n// it accepts this as a legal value, but it does not appear\n// to be in specification of class. OS X Java parses it to\n// a wrong value.\nreturn null;\n}\nif (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\nreturn createInteger(str);\n}\nchar lastChar = str.charAt(str.length() - 1);\nString mant;\nString dec;\nString exp;\nint decPos = str.indexOf('.');\nint expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\nif (decPos > -1) {\n\nif (expPos > -1) {\nif (expPos < decPos || expPos > str.length()) {\nthrow new NumberFormatException(str + \" is not a valid number.\");\n}\ndec = str.substring(decPos + 1, expPos);\n} else {\ndec = str.substring(decPos + 1);\n}\nmant = str.substring(0, decPos);\n} else {\nif (expPos > -1) {\nif (expPos > str.length()) {\nthrow new NumberFormatException(str + \" is not a valid number.\");\n}\nmant = str.substring(0, expPos);\n} else {\nmant = str;\n}\ndec = null;\n}\nif (!Character.isDigit(lastChar) && lastChar != '.') {\nif (expPos > -1 && expPos < str.length() - 1) {\nexp = str.substring(expPos + 1, str.length() - 1);\n} else {\nexp = null;\n}\n//Requesting a specific type..\nString numeric = str.substring(0, str.length() - 1);\nboolean allZeros = isAllZeros(mant) && isAllZeros(exp);\nswitch (lastChar) {\ncase 'l' :\ncase 'L' :\nif (dec == null\n&& exp == null\n&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\ntry {\nreturn createLong(numeric);\n} catch (NumberFormatException nfe) {\n//Too big for a long\n}\nreturn createBigInteger(numeric);\n\n}\nthrow new NumberFormatException(str + \" is not a valid number.\");\ncase 'f' :\ncase 'F' :\ntry {\nFloat f = NumberUtils.createFloat(numeric);\nif (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n//If it's too big for a float or the float value = 0 and the string\n//has non-zeros in it, then float does not have the precision we want\nreturn f;\n}\n\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\n//$FALL-THROUGH$\ncase 'd' :\ncase 'D' :\ntry {\nDouble d = NumberUtils.createDouble(numeric);\nif (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\nreturn d;\n}\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\ntry {\nreturn createBigDecimal(numeric);\n} catch (NumberFormatException e) {\n// ignore the bad number\n}\n//$FALL-THROUGH$\ndefault :\nthrow new NumberFormatException(str + \" is not a valid number.\");\n\n}\n} else {\n//User doesn't have a preference on the return type, so let's start\n//small and go from there...\nif (expPos > -1 && expPos < str.length() - 1) {\nexp = str.substring(expPos + 1, str.length());\n} else {\nexp = null;\n}\nif (dec == null && exp == null) {\n//Must be an int,long,bigint\ntry {\nreturn createInteger(str);\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\ntry {\nreturn createLong(str);\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\nreturn createBigInteger(str);\n\n} else {\n//Must be a float,double,BigDec\nboolean allZeros = isAllZeros(mant) && isAllZeros(exp);\ntry {\nFloat f = createFloat(str);\nif (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\nreturn f;\n}\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\ntry {\nDouble d = createDouble(str);\nif (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\nreturn d;\n}\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\n\nreturn createBigDecimal(str);\n\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:isAllZeros(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean isAllZeros(String str) {\nif (str == null) {\nreturn true;\n}\nfor (int i = str.length() - 1; i >= 0; i--) {\nif (str.charAt(i) != '0') {\nreturn false;\n}\n}\nreturn str.length() > 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createFloat(Ljava/lang/String;)Ljava/lang/Float;",
                                    "method_body": "public static Float createFloat(String str) {\nif (str == null) {\nreturn null;\n}\nreturn Float.valueOf(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createDouble(Ljava/lang/String;)Ljava/lang/Double;",
                                    "method_body": "public static Double createDouble(String str) {\nif (str == null) {\nreturn null;\n}\nreturn Double.valueOf(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createInteger(Ljava/lang/String;)Ljava/lang/Integer;",
                                    "method_body": "public static Integer createInteger(String str) {\nif (str == null) {\nreturn null;\n}\n// decode() handles 0xAABD and 0777 (hex and octal) as well.\nreturn Integer.decode(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createLong(Ljava/lang/String;)Ljava/lang/Long;",
                                    "method_body": "public static Long createLong(String str) {\nif (str == null) {\nreturn null;\n}\nreturn Long.valueOf(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createBigInteger(Ljava/lang/String;)Ljava/math/BigInteger;",
                                    "method_body": "public static BigInteger createBigInteger(String str) {\nif (str == null) {\nreturn null;\n}\nreturn new BigInteger(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createBigDecimal(Ljava/lang/String;)Ljava/math/BigDecimal;",
                                    "method_body": "public static BigDecimal createBigDecimal(String str) {\nif (str == null) {\nreturn null;\n}\n// handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\nif (StringUtils.isBlank(str)) {\nthrow new NumberFormatException(\"A blank string is not a valid number\");\n}\nreturn new BigDecimal(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:isDigits(Ljava/lang/String;)Z",
                                    "method_body": "public static boolean isDigits(String str) {\nif (StringUtils.isEmpty(str)) {\nreturn false;\n}\nfor (int i = 0; i < str.length(); i++) {\nif (!Character.isDigit(str.charAt(i))) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:isNumber(Ljava/lang/String;)Z",
                                    "method_body": "public static boolean isNumber(String str) {\nif (StringUtils.isEmpty(str)) {\nreturn false;\n}\nchar[] chars = str.toCharArray();\nint sz = chars.length;\nboolean hasExp = false;\nboolean hasDecPoint = false;\nboolean allowSigns = false;\nboolean foundDigit = false;\n// deal with any possible sign up front\nint start = (chars[0] == '-') ? 1 : 0;\nif (sz > start + 1) {\nif (chars[start] == '0' && chars[start + 1] == 'x') {\nint i = start + 2;\nif (i == sz) {\nreturn false; // str == \"0x\"\n}\n// checking hex (it can't be anything else)\nfor (; i < chars.length; i++) {\nif ((chars[i] < '0' || chars[i] > '9')\n&& (chars[i] < 'a' || chars[i] > 'f')\n&& (chars[i] < 'A' || chars[i] > 'F')) {\nreturn false;\n}\n}\nreturn true;\n}\n}\nsz--; // don't want to loop to the last char, check it afterwords\n// for type qualifiers\nint i = start;\n// loop to the next to last char or to the last char if we need another digit to\n// make a valid number (e.g. chars[0..5] = \"1234E\")\nwhile (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\nif (chars[i] >= '0' && chars[i] <= '9') {\nfoundDigit = true;\nallowSigns = false;\n\n} else if (chars[i] == '.') {\nif (hasDecPoint || hasExp) {\n// two decimal points or dec in exponent\nreturn false;\n}\nhasDecPoint = true;\n} else if (chars[i] == 'e' || chars[i] == 'E') {\n// we've already taken care of hex.\nif (hasExp) {\n// two E's\nreturn false;\n}\nif (!foundDigit) {\nreturn false;\n}\nhasExp = true;\nallowSigns = true;\n} else if (chars[i] == '+' || chars[i] == '-') {\nif (!allowSigns) {\nreturn false;\n}\nallowSigns = false;\nfoundDigit = false; // we need a digit after the E\n} else {\nreturn false;\n}\ni++;\n}\nif (i < chars.length) {\nif (chars[i] >= '0' && chars[i] <= '9') {\n// no type qualifier, OK\nreturn true;\n}\nif (chars[i] == 'e' || chars[i] == 'E') {\n// can't have an E at the last byte\nreturn false;\n}\nif (chars[i] == '.') {\nif (hasDecPoint || hasExp) {\n// two decimal points or dec in exponent\nreturn false;\n}\n// single trailing decimal point after non-exponent is ok\nreturn foundDigit;\n}\nif (!allowSigns\n&& (chars[i] == 'd'\n|| chars[i] == 'D'\n|| chars[i] == 'f'\n|| chars[i] == 'F')) {\nreturn foundDigit;\n}\nif (chars[i] == 'l'\n|| chars[i] == 'L') {\n// not allowing L with an exponent or decimal point\nreturn foundDigit && !hasExp;\n}\n// last character is illegal\nreturn false;\n}\n// allowSigns is true iff the val ends in 'E'\n// found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\nreturn !allowSigns && foundDigit;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 26,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.time.FastDateFormatTest.testLang645",
                            "test_body": "328: public void testLang645() {\n329: Locale locale = new Locale(\"sv\", \"SE\");\n330: 331: Calendar cal = Calendar.getInstance();\n332: cal.set(2010, 0, 1, 12, 0, 0);\n333: Date d = cal.getTime();\n334: 335: FastDateFormat fdf = FastDateFormat.getInstance(\"EEEE', week 'ww\", locale);\n336: 337: assertEquals(\"fredag, week 53\", fdf.format(d));\n338: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:<init>(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)V",
                                    "method_body": "protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {\nsuper();\nif (pattern == null) {\nthrow new IllegalArgumentException(\"The pattern must not be null\");\n}\nmPattern = pattern;\n\nmTimeZoneForced = (timeZone != null);\nif (timeZone == null) {\ntimeZone = TimeZone.getDefault();\n}\nmTimeZone = timeZone;\n\nmLocaleForced = (locale != null);\nif (locale == null) {\nlocale = Locale.getDefault();\n}\nmLocale = locale;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\n/**\n* FULL locale dependent date or time style.\n*/\npublic static final int FULL = DateFormat.FULL;\n/**\n* LONG locale dependent date or time style.\n*/\npublic static final int LONG = DateFormat.LONG;\n/**\n* MEDIUM locale dependent date or time style.\n*/\npublic static final int MEDIUM = DateFormat.MEDIUM;\n/**\n* SHORT locale dependent date or time style.\n*/\npublic static final int SHORT = DateFormat.SHORT;\n\n//@GuardedBy(\"this\")\nprivate static String cDefaultPattern; // lazily initialised by getInstance()\n\nprivate static final Map<FastDateFormat, FastDateFormat> cInstanceCache = new HashMap<FastDateFormat, FastDateFormat>(7);\nprivate static final Map<Object, FastDateFormat> cDateInstanceCache = new HashMap<Object, FastDateFormat>(7);\nprivate static final Map<Object, FastDateFormat> cTimeInstanceCache = new HashMap<Object, FastDateFormat>(7);\nprivate static final Map<Object, FastDateFormat> cDateTimeInstanceCache = new HashMap<Object, FastDateFormat>(7);\nprivate static final Map<Object, String> cTimeZoneDisplayCache = new HashMap<Object, String>(7);\n\n/**\n* The pattern.\n*/\nprivate final String mPattern;\n/**\n* The time zone.\n*/\nprivate final TimeZone mTimeZone;\n/**\n* Whether the time zone overrides any on Calendars.\n*/\nprivate final boolean mTimeZoneForced;\n/**\n* The locale.\n*/\nprivate final Locale mLocale;\n/**\n* Whether the locale overrides the default.\n*/\nprivate final boolean mLocaleForced;\n/**\n* The parsed rules.\n*/\nprivate transient Rule[] mRules;\n/**\n* The estimated maximum length.\n*/\nprivate transient int mMaxLengthEstimate;\n\n//-----------------------------------------------------------------------\n/**\n* <p>Gets a formatter instance using the default pattern in the\n* default locale.</p>\n*\n* @return a date/time formatter\n*/\npublic static FastDateFormat getInstance() {\nreturn getInstance(getDefaultPattern(), null, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:getInstance(Ljava/lang/String;Ljava/util/Locale;)Lorg/apache/commons/lang3/time/FastDateFormat;",
                                    "method_body": "public static FastDateFormat getInstance(String pattern, Locale locale) {\nreturn getInstance(pattern, null, locale);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:getInstance(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)Lorg/apache/commons/lang3/time/FastDateFormat;",
                                    "method_body": "public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {\nFastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);\nFastDateFormat format = cInstanceCache.get(emptyFormat);\nif (format == null) {\nformat = emptyFormat;\nformat.init();  // convert shell format into usable one\ncInstanceCache.put(format, format);  // this is OK!\n}\nreturn format;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:init()V",
                                    "method_body": "protected void init() {\nList<Rule> rulesList = parsePattern();\nmRules = rulesList.toArray(new Rule[rulesList.size()]);\n\nint len = 0;\nfor (int i=mRules.length; --i >= 0; ) {\nlen += mRules[i].estimateLength();\n}\n\nmMaxLengthEstimate = len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:parsePattern()Ljava/util/List;",
                                    "method_body": "protected List<Rule> parsePattern() {\nDateFormatSymbols symbols = new DateFormatSymbols(mLocale);\nList<Rule> rules = new ArrayList<Rule>();\n\nString[] ERAs = symbols.getEras();\nString[] months = symbols.getMonths();\nString[] shortMonths = symbols.getShortMonths();\nString[] weekdays = symbols.getWeekdays();\nString[] shortWeekdays = symbols.getShortWeekdays();\nString[] AmPmStrings = symbols.getAmPmStrings();\n\nint length = mPattern.length();\nint[] indexRef = new int[1];\n\nfor (int i = 0; i < length; i++) {\nindexRef[0] = i;\nString token = parseToken(mPattern, indexRef);\ni = indexRef[0];\n\nint tokenLen = token.length();\nif (tokenLen == 0) {\nbreak;\n}\n\nRule rule;\nchar c = token.charAt(0);\n\nswitch (c) {\ncase 'G': // era designator (text)\nrule = new TextField(Calendar.ERA, ERAs);\nbreak;\ncase 'y': // year (number)\nif (tokenLen >= 4) {\nrule = selectNumberRule(Calendar.YEAR, tokenLen);\n} else {\nrule = TwoDigitYearField.INSTANCE;\n}\nbreak;\ncase 'M': // month in year (text and number)\nif (tokenLen >= 4) {\nrule = new TextField(Calendar.MONTH, months);\n} else if (tokenLen == 3) {\nrule = new TextField(Calendar.MONTH, shortMonths);\n} else if (tokenLen == 2) {\nrule = TwoDigitMonthField.INSTANCE;\n} else {\nrule = UnpaddedMonthField.INSTANCE;\n}\nbreak;\ncase 'd': // day in month (number)\nrule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\nbreak;\ncase 'h': // hour in am/pm (number, 1..12)\nrule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\nbreak;\ncase 'H': // hour in day (number, 0..23)\nrule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\nbreak;\ncase 'm': // minute in hour (number)\nrule = selectNumberRule(Calendar.MINUTE, tokenLen);\nbreak;\ncase 's': // second in minute (number)\nrule = selectNumberRule(Calendar.SECOND, tokenLen);\nbreak;\ncase 'S': // millisecond (number)\nrule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\nbreak;\ncase 'E': // day in week (text)\nrule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\nbreak;\ncase 'D': // day in year (number)\nrule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\nbreak;\ncase 'F': // day of week in month (number)\nrule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\nbreak;\ncase 'w': // week in year (number)\nrule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\nbreak;\ncase 'W': // week in month (number)\nrule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\nbreak;\ncase 'a': // am/pm marker (text)\nrule = new TextField(Calendar.AM_PM, AmPmStrings);\nbreak;\ncase 'k': // hour in day (1..24)\nrule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\nbreak;\ncase 'K': // hour in am/pm (0..11)\nrule = selectNumberRule(Calendar.HOUR, tokenLen);\nbreak;\ncase 'z': // time zone (text)\nif (tokenLen >= 4) {\nrule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.LONG);\n} else {\nrule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.SHORT);\n}\nbreak;\ncase 'Z': // time zone (value)\nif (tokenLen == 1) {\nrule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n} else {\nrule = TimeZoneNumberRule.INSTANCE_COLON;\n}\nbreak;\ncase '\\'': // literal text\nString sub = token.substring(1);\nif (sub.length() == 1) {\nrule = new CharacterLiteral(sub.charAt(0));\n} else {\nrule = new StringLiteral(sub);\n}\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"Illegal pattern component: \" + token);\n}\n\nrules.add(rule);\n}\n\nreturn rules;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
                                    "method_body": "protected String parseToken(String pattern, int[] indexRef) {\nStringBuilder buf = new StringBuilder();\n\nint i = indexRef[0];\nint length = pattern.length();\n\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n// Scan a run of the same character, which indicates a time\n// pattern.\nbuf.append(c);\n\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append(c);\ni++;\n} else {\nbreak;\n}\n}\n} else {\n// This will identify token as text.\nbuf.append('\\'');\n\nboolean inLiteral = false;\n\nfor (; i < length; i++) {\nc = pattern.charAt(i);\n\nif (c == '\\'') {\nif (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n// '' is treated as escaped '\ni++;\nbuf.append(c);\n} else {\ninLiteral = !inLiteral;\n}\n} else if (!inLiteral &&\n(c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\ni--;\nbreak;\n} else {\nbuf.append(c);\n}\n}\n}\n\nindexRef[0] = i;\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:selectNumberRule(II)Lorg/apache/commons/lang3/time/FastDateFormat$NumberRule;",
                                    "method_body": "protected NumberRule selectNumberRule(int field, int padding) {\nswitch (padding) {\ncase 1:\nreturn new UnpaddedNumberField(field);\ncase 2:\nreturn new TwoDigitNumberField(field);\ndefault:\nreturn new PaddedNumberField(field, padding);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:format(Ljava/util/Date;)Ljava/lang/String;",
                                    "method_body": "public String format(Date date) {\nCalendar c = new GregorianCalendar(mTimeZone);\nc.setTime(date);\nreturn applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:applyRules(Ljava/util/Calendar;Ljava/lang/StringBuffer;)Ljava/lang/StringBuffer;",
                                    "method_body": "protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\nRule[] rules = mRules;\nint len = mRules.length;\nfor (int i = 0; i < len; i++) {\nrules[i].appendTo(buf, calendar);\n}\nreturn buf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:hashCode()I",
                                    "method_body": "public int hashCode() {\nint total = 0;\ntotal += mPattern.hashCode();\ntotal += mTimeZone.hashCode();\ntotal += (mTimeZoneForced ? 1 : 0);\ntotal += mLocale.hashCode();\ntotal += (mLocaleForced ? 1 : 0);\nreturn total;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$TwoDigitNumberField:<init>(I)V",
                                    "method_body": "TwoDigitNumberField(int field) {\nmField = field;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$TwoDigitNumberField:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nreturn 2;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$TwoDigitNumberField:appendTo(Ljava/lang/StringBuffer;Ljava/util/Calendar;)V",
                                    "method_body": "public void appendTo(StringBuffer buffer, Calendar calendar) {\nappendTo(buffer, calendar.get(mField));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$TwoDigitNumberField:appendTo(Ljava/lang/StringBuffer;I)V",
                                    "method_body": "public final void appendTo(StringBuffer buffer, int value) {\nif (value < 100) {\nbuffer.append((char)(value / 10 + '0'));\nbuffer.append((char)(value % 10 + '0'));\n} else {\nbuffer.append(Integer.toString(value));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$TextField:<init>(I[Ljava/lang/String;)V",
                                    "method_body": "TextField(int field, String[] values) {\nmField = field;\nmValues = values;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$TextField:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nint max = 0;\nfor (int i=mValues.length; --i >= 0; ) {\nint len = mValues[i].length();\nif (len > max) {\nmax = len;\n}\n}\nreturn max;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$TextField:appendTo(Ljava/lang/StringBuffer;Ljava/util/Calendar;)V",
                                    "method_body": "public void appendTo(StringBuffer buffer, Calendar calendar) {\nbuffer.append(mValues[calendar.get(mField)]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$StringLiteral:<init>(Ljava/lang/String;)V",
                                    "method_body": "StringLiteral(String value) {\nmValue = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$StringLiteral:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nreturn mValue.length();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$StringLiteral:appendTo(Ljava/lang/StringBuffer;Ljava/util/Calendar;)V",
                                    "method_body": "public void appendTo(StringBuffer buffer, Calendar calendar) {\nbuffer.append(mValue);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 27,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.math.NumberUtilsTest.testCreateNumber",
                            "test_body": "176: public void testCreateNumber() {\n177: // a lot of things can go wrong\n178: assertEquals(\"createNumber(String) 1 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5\"));\n179: assertEquals(\"createNumber(String) 2 failed\", new Integer(\"12345\"), NumberUtils.createNumber(\"12345\"));\n180: assertEquals(\"createNumber(String) 3 failed\", new Double(\"1234.5\"), NumberUtils.createNumber(\"1234.5D\"));\n181: assertEquals(\"createNumber(String) 3 failed\", new Double(\"1234.5\"), NumberUtils.createNumber(\"1234.5d\"));\n182: assertEquals(\"createNumber(String) 4 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5F\"));\n183: assertEquals(\"createNumber(String) 4 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5f\"));\n184: assertEquals(\"createNumber(String) 5 failed\", new Long(Integer.MAX_VALUE + 1L), NumberUtils.createNumber(\"\"\n185: + (Integer.MAX_VALUE + 1L)));\n186: assertEquals(\"createNumber(String) 6 failed\", new Long(12345), NumberUtils.createNumber(\"12345L\"));\n187: assertEquals(\"createNumber(String) 6 failed\", new Long(12345), NumberUtils.createNumber(\"12345l\"));\n188: assertEquals(\"createNumber(String) 7 failed\", new Float(\"-1234.5\"), NumberUtils.createNumber(\"-1234.5\"));\n189: assertEquals(\"createNumber(String) 8 failed\", new Integer(\"-12345\"), NumberUtils.createNumber(\"-12345\"));\n190: assertTrue(\"createNumber(String) 9 failed\", 0xFADE == NumberUtils.createNumber(\"0xFADE\").intValue());\n191: assertTrue(\"createNumber(String) 10 failed\", -0xFADE == NumberUtils.createNumber(\"-0xFADE\").intValue());\n192: assertEquals(\"createNumber(String) 11 failed\", new Double(\"1.1E200\"), NumberUtils.createNumber(\"1.1E200\"));\n193: assertEquals(\"createNumber(String) 12 failed\", new Float(\"1.1E20\"), NumberUtils.createNumber(\"1.1E20\"));\n194: assertEquals(\"createNumber(String) 13 failed\", new Double(\"-1.1E200\"), NumberUtils.createNumber(\"-1.1E200\"));\n195: assertEquals(\"createNumber(String) 14 failed\", new Double(\"1.1E-200\"), NumberUtils.createNumber(\"1.1E-200\"));\n196: assertEquals(\"createNumber(null) failed\", null, NumberUtils.createNumber(null));\n197: assertEquals(\"createNumber(String) failed\", new BigInteger(\"12345678901234567890\"), NumberUtils\n198: .createNumber(\"12345678901234567890L\"));\n199: 200: // jdk 1.2 doesn't support this. unsure about jdk 1.2.2\n201: if (SystemUtils.isJavaVersionAtLeast(1.3f)) {\n202: assertEquals(\"createNumber(String) 15 failed\", new BigDecimal(\"1.1E-700\"), NumberUtils\n203: .createNumber(\"1.1E-700F\"));\n204: }\n205: assertEquals(\"createNumber(String) 16 failed\", new Long(\"10\" + Integer.MAX_VALUE), NumberUtils\n206: .createNumber(\"10\" + Integer.MAX_VALUE + \"L\"));\n207: assertEquals(\"createNumber(String) 17 failed\", new Long(\"10\" + Integer.MAX_VALUE), NumberUtils\n208: .createNumber(\"10\" + Integer.MAX_VALUE));\n209: assertEquals(\"createNumber(String) 18 failed\", new BigInteger(\"10\" + Long.MAX_VALUE), NumberUtils\n210: .createNumber(\"10\" + Long.MAX_VALUE));\n211: 212: // LANG-521\n213: assertEquals(\"createNumber(String) LANG-521 failed\", new Float(\"2.\"), NumberUtils.createNumber(\"2.\"));\n214: 215: // LANG-638\n216: assertFalse(\"createNumber(String) succeeded\", checkCreateNumber(\"1eE\"));\n217: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:isEmpty(Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean isEmpty(CharSequence cs) {\nreturn cs == null || cs.length() == 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:isBlank(Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean isBlank(CharSequence cs) {\nint strLen;\nif (cs == null || (strLen = cs.length()) == 0) {\nreturn true;\n}\nfor (int i = 0; i < strLen; i++) {\nif ((Character.isWhitespace(cs.charAt(i)) == false)) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>\n* The <code>file.encoding</code> System Property.\n* </p>\n* <p>\n* File encoding, such as <code>Cp1252</code>.\n* </p>\n*\n* <p>\n* Defaults to <code>null</code> if the runtime does not have security access to read this property or the property does not exist.\n* </p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nreturn toVersionFloat(toJavaVersionIntArray(SystemUtils.JAVA_VERSION, JAVA_VERSION_TRIM_SIZE));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nreturn toVersionInt(toJavaVersionIntArray(SystemUtils.JAVA_VERSION, JAVA_VERSION_TRIM_SIZE));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nreturn isJavaVersionMatch(JAVA_VERSION_TRIMMED, versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nreturn isOSMatch(OS_NAME, OS_VERSION, osNamePrefix, osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatchesName(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatchesName(String osNamePrefix) {\nreturn isOSNameMatch(OS_NAME, osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\");\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:isJavaVersionAtLeast(F)Z",
                                    "method_body": "public static boolean isJavaVersionAtLeast(float requiredVersion) {\nreturn JAVA_VERSION_FLOAT >= requiredVersion;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:isJavaVersionMatch(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "static boolean isJavaVersionMatch(String version, String versionPrefix) {\nif (version == null) {\nreturn false;\n}\nreturn version.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:isOSMatch(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "static boolean isOSMatch(String osName, String osVersion, String osNamePrefix, String osVersionPrefix) {\nif (osName == null || osVersion == null) {\nreturn false;\n}\nreturn osName.startsWith(osNamePrefix) && osVersion.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:isOSNameMatch(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "static boolean isOSNameMatch(String osName, String osNamePrefix) {\nif (osName == null) {\nreturn false;\n}\nreturn osName.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:toJavaVersionIntArray(Ljava/lang/String;I)[I",
                                    "method_body": "private static int[] toJavaVersionIntArray(String version, int limit) {\nif (version == null) {\nreturn ArrayUtils.EMPTY_INT_ARRAY;\n}\nString[] strings = Pattern.compile(\"[^\\\\d]\").split(version);\nint[] ints = new int[Math.min(limit, strings.length)];\nint j = 0;\nfor (int i = 0; i < strings.length && j < limit; i++) {\nString s = strings[i];\nif (s.length() > 0) {\nints[j++] = Integer.parseInt(s);\n}\n}\nreturn ints;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:toVersionFloat([I)F",
                                    "method_body": "private static float toVersionFloat(int[] javaVersions) {\nif (javaVersions == null || javaVersions.length == 0) {\nreturn 0f;\n}\nif (javaVersions.length == 1) {\nreturn javaVersions[0];\n}\nStringBuilder builder = new StringBuilder();\nbuilder.append(javaVersions[0]);\nbuilder.append('.');\nfor (int i = 1; i < javaVersions.length; i++) {\nbuilder.append(javaVersions[i]);\n}\ntry {\nreturn Float.parseFloat(builder.toString());\n} catch (Exception ex) {\nreturn 0f;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:toVersionInt([I)I",
                                    "method_body": "private static int toVersionInt(int[] javaVersions) {\nif (javaVersions == null) {\nreturn 0;\n}\nint intVersion = 0;\nint len = javaVersions.length;\nif (len >= 1) {\nintVersion = javaVersions[0] * 100;\n}\nif (len >= 2) {\nintVersion += javaVersions[1] * 10;\n}\nif (len >= 3) {\nintVersion += javaVersions[2];\n}\nreturn intVersion;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:<clinit>()V",
                                    "method_body": "public static final Long LONG_ZERO = new Long(0L);\n/** Reusable Long constant for one. */\npublic static final Long LONG_ONE = new Long(1L);\n/** Reusable Long constant for minus one. */\npublic static final Long LONG_MINUS_ONE = new Long(-1L);\n/** Reusable Integer constant for zero. */\npublic static final Integer INTEGER_ZERO = new Integer(0);\n/** Reusable Integer constant for one. */\npublic static final Integer INTEGER_ONE = new Integer(1);\n/** Reusable Integer constant for minus one. */\npublic static final Integer INTEGER_MINUS_ONE = new Integer(-1);\n/** Reusable Short constant for zero. */\npublic static final Short SHORT_ZERO = new Short((short) 0);\n/** Reusable Short constant for one. */\npublic static final Short SHORT_ONE = new Short((short) 1);\n/** Reusable Short constant for minus one. */\npublic static final Short SHORT_MINUS_ONE = new Short((short) -1);\n/** Reusable Byte constant for zero. */\npublic static final Byte BYTE_ZERO = Byte.valueOf((byte) 0);\n/** Reusable Byte constant for one. */\npublic static final Byte BYTE_ONE = Byte.valueOf((byte) 1);\n/** Reusable Byte constant for minus one. */\npublic static final Byte BYTE_MINUS_ONE = Byte.valueOf((byte) -1);\n/** Reusable Double constant for zero. */\npublic static final Double DOUBLE_ZERO = new Double(0.0d);\n/** Reusable Double constant for one. */\npublic static final Double DOUBLE_ONE = new Double(1.0d);\n/** Reusable Double constant for minus one. */\npublic static final Double DOUBLE_MINUS_ONE = new Double(-1.0d);\n/** Reusable Float constant for zero. */\npublic static final Float FLOAT_ZERO = new Float(0.0f);\n/** Reusable Float constant for one. */\npublic static final Float FLOAT_ONE = new Float(1.0f);\n/** Reusable Float constant for minus one. */\npublic static final Float FLOAT_MINUS_ONE = new Float(-1.0f);\n\n/**\n* <p><code>NumberUtils</code> instances should NOT be constructed in standard programming.\n* Instead, the class should be used as <code>NumberUtils.toInt(\"6\");</code>.</p>\n*\n* <p>This constructor is public to permit tools that require a JavaBean instance\n* to operate.</p>\n*/\npublic NumberUtils() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createNumber(Ljava/lang/String;)Ljava/lang/Number;",
                                    "method_body": "public static Number createNumber(String str) throws NumberFormatException {\nif (str == null) {\nreturn null;\n}\nif (StringUtils.isBlank(str)) {\nthrow new NumberFormatException(\"A blank string is not a valid number\");\n}\nif (str.startsWith(\"--\")) {\n// this is protection for poorness in java.lang.BigDecimal.\n// it accepts this as a legal value, but it does not appear\n// to be in specification of class. OS X Java parses it to\n// a wrong value.\nreturn null;\n}\nif (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\nreturn createInteger(str);\n}\nchar lastChar = str.charAt(str.length() - 1);\nString mant;\nString dec;\nString exp;\nint decPos = str.indexOf('.');\nint expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\nif (decPos > -1) {\n\nif (expPos > -1) {\nif (expPos < decPos) {\nthrow new NumberFormatException(str + \" is not a valid number.\");\n}\ndec = str.substring(decPos + 1, expPos);\n} else {\ndec = str.substring(decPos + 1);\n}\nmant = str.substring(0, decPos);\n} else {\nif (expPos > -1) {\nmant = str.substring(0, expPos);\n} else {\nmant = str;\n}\ndec = null;\n}\nif (!Character.isDigit(lastChar) && lastChar != '.') {\nif (expPos > -1 && expPos < str.length() - 1) {\nexp = str.substring(expPos + 1, str.length() - 1);\n} else {\nexp = null;\n}\n//Requesting a specific type..\nString numeric = str.substring(0, str.length() - 1);\nboolean allZeros = isAllZeros(mant) && isAllZeros(exp);\nswitch (lastChar) {\ncase 'l' :\ncase 'L' :\nif (dec == null\n&& exp == null\n&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\ntry {\nreturn createLong(numeric);\n} catch (NumberFormatException nfe) {\n//Too big for a long\n}\nreturn createBigInteger(numeric);\n\n}\nthrow new NumberFormatException(str + \" is not a valid number.\");\ncase 'f' :\ncase 'F' :\ntry {\nFloat f = NumberUtils.createFloat(numeric);\nif (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n//If it's too big for a float or the float value = 0 and the string\n//has non-zeros in it, then float does not have the precision we want\nreturn f;\n}\n\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\n//$FALL-THROUGH$\ncase 'd' :\ncase 'D' :\ntry {\nDouble d = NumberUtils.createDouble(numeric);\nif (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\nreturn d;\n}\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\ntry {\nreturn createBigDecimal(numeric);\n} catch (NumberFormatException e) {\n// ignore the bad number\n}\n//$FALL-THROUGH$\ndefault :\nthrow new NumberFormatException(str + \" is not a valid number.\");\n\n}\n} else {\n//User doesn't have a preference on the return type, so let's start\n//small and go from there...\nif (expPos > -1 && expPos < str.length() - 1) {\nexp = str.substring(expPos + 1, str.length());\n} else {\nexp = null;\n}\nif (dec == null && exp == null) {\n//Must be an int,long,bigint\ntry {\nreturn createInteger(str);\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\ntry {\nreturn createLong(str);\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\nreturn createBigInteger(str);\n\n} else {\n//Must be a float,double,BigDec\nboolean allZeros = isAllZeros(mant) && isAllZeros(exp);\ntry {\nFloat f = createFloat(str);\nif (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\nreturn f;\n}\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\ntry {\nDouble d = createDouble(str);\nif (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\nreturn d;\n}\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\n\nreturn createBigDecimal(str);\n\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:isAllZeros(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean isAllZeros(String str) {\nif (str == null) {\nreturn true;\n}\nfor (int i = str.length() - 1; i >= 0; i--) {\nif (str.charAt(i) != '0') {\nreturn false;\n}\n}\nreturn str.length() > 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createFloat(Ljava/lang/String;)Ljava/lang/Float;",
                                    "method_body": "public static Float createFloat(String str) {\nif (str == null) {\nreturn null;\n}\nreturn Float.valueOf(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createDouble(Ljava/lang/String;)Ljava/lang/Double;",
                                    "method_body": "public static Double createDouble(String str) {\nif (str == null) {\nreturn null;\n}\nreturn Double.valueOf(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createInteger(Ljava/lang/String;)Ljava/lang/Integer;",
                                    "method_body": "public static Integer createInteger(String str) {\nif (str == null) {\nreturn null;\n}\n// decode() handles 0xAABD and 0777 (hex and octal) as well.\nreturn Integer.decode(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createLong(Ljava/lang/String;)Ljava/lang/Long;",
                                    "method_body": "public static Long createLong(String str) {\nif (str == null) {\nreturn null;\n}\nreturn Long.valueOf(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createBigInteger(Ljava/lang/String;)Ljava/math/BigInteger;",
                                    "method_body": "public static BigInteger createBigInteger(String str) {\nif (str == null) {\nreturn null;\n}\nreturn new BigInteger(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createBigDecimal(Ljava/lang/String;)Ljava/math/BigDecimal;",
                                    "method_body": "public static BigDecimal createBigDecimal(String str) {\nif (str == null) {\nreturn null;\n}\n// handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\nif (StringUtils.isBlank(str)) {\nthrow new NumberFormatException(\"A blank string is not a valid number\");\n}\nreturn new BigDecimal(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:isDigits(Ljava/lang/String;)Z",
                                    "method_body": "public static boolean isDigits(String str) {\nif (StringUtils.isEmpty(str)) {\nreturn false;\n}\nfor (int i = 0; i < str.length(); i++) {\nif (!Character.isDigit(str.charAt(i))) {\nreturn false;\n}\n}\nreturn true;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 28,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.text.translate.NumericEntityUnescaperTest.testSupplementaryUnescaping",
                            "test_body": "27: public void testSupplementaryUnescaping() {\n28: NumericEntityUnescaper neu = new NumericEntityUnescaper();\n29: String input = \"&#68642;\";\n30: String expected = \"\\uD803\\uDC22\";\n31: 32: String result = neu.translate(input);\n33: assertEquals(\"Failed to unescape numeric entities supplementary characters\", expected, result);\n34: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.CharSequenceTranslator:translate(Ljava/lang/CharSequence;)Ljava/lang/String;",
                                    "method_body": "public abstract int translate(CharSequence input, int index, Writer out) throws IOException;\n\n/**\n* Helper for non-Writer usage.\n* @param input CharSequence to be translated\n* @return String output of translation\n*/\npublic final String translate(CharSequence input) {\nif (input == null) {\nreturn null;\n}\ntry {\nStringWriter writer = new StringWriter(input.length() * 2);  // TODO: Make the 2 part of the API???\ntranslate(input, writer);\nreturn writer.toString();\n} catch (IOException ioe) {\n// this should never ever happen while writing to a StringWriter\nthrow new RuntimeException(ioe);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.CharSequenceTranslator:translate(Ljava/lang/CharSequence;Ljava/io/Writer;)V",
                                    "method_body": "public final void translate(CharSequence input, Writer out) throws IOException {\nif (out == null) {\nthrow new IllegalArgumentException(\"The Writer must not be null\");\n}\nif (input == null) {\nreturn;\n}\nint sz = Character.codePointCount(input, 0, input.length());\nfor (int i = 0; i < sz; i++) {\n\n// consumed is the number of codepoints consumed\nint consumed = translate(input, i, out);\n\nif(consumed == 0) {\nout.write( Character.toChars( Character.codePointAt(input, i) ) );\n} else {\n// contract with translators is that they have to understand codepoints and they just took care of a surrogate pair\nfor(int j=0; j<consumed; j++) {\nif(i < sz - 2) {\ni += Character.charCount( Character.codePointAt(input, i) );\n} else {\n// If the String ends with a high surrogate, just add the 1 and don't worry about such things\ni++;\n}\n}\n// for loop will increment 1 anyway, so remove 1 to account for that\ni--;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.text.translate.NumericEntityUnescaper:translate(Ljava/lang/CharSequence;ILjava/io/Writer;)I",
                                    "method_body": "public int translate(CharSequence input, int index, Writer out) throws IOException {\n// TODO: Protect from ArrayIndexOutOfBounds\nif(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {\nint start = index + 2;\nboolean isHex = false;\n\nchar firstChar = input.charAt(start);\nif(firstChar == 'x' || firstChar == 'X') {\nstart++;\nisHex = true;\n}\n\nint end = start;\nwhile(input.charAt(end) != ';') {\nend++;\n}\n\nint entityValue;\ntry {\nif(isHex) {\nentityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n} else {\nentityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n}\n} catch(NumberFormatException nfe) {\nreturn 0;\n}\n\nout.write(entityValue);\nreturn 2 + (end - start) + (isHex ? 1 : 0) + 1;\n}\nreturn 0;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 29,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.SystemUtilsTest.testJavaVersionAsInt",
                            "test_body": "209: public void testJavaVersionAsInt() {\n210: assertEquals(0, SystemUtils.toJavaVersionInt(null));\n211: assertEquals(0, SystemUtils.toJavaVersionInt(\"\"));\n212: assertEquals(0, SystemUtils.toJavaVersionInt(\"0\"));\n213: assertEquals(110, SystemUtils.toJavaVersionInt(\"1.1\"));\n214: assertEquals(120, SystemUtils.toJavaVersionInt(\"1.2\"));\n215: assertEquals(130, SystemUtils.toJavaVersionInt(\"1.3.0\"));\n216: assertEquals(131, SystemUtils.toJavaVersionInt(\"1.3.1\"));\n217: assertEquals(140, SystemUtils.toJavaVersionInt(\"1.4.0\"));\n218: assertEquals(141, SystemUtils.toJavaVersionInt(\"1.4.1\"));\n219: assertEquals(142, SystemUtils.toJavaVersionInt(\"1.4.2\"));\n220: assertEquals(150, SystemUtils.toJavaVersionInt(\"1.5.0\"));\n221: assertEquals(160, SystemUtils.toJavaVersionInt(\"1.6.0\"));\n222: assertEquals(131, SystemUtils.toJavaVersionInt(\"JavaVM-1.3.1\"));\n223: assertEquals(131, SystemUtils.toJavaVersionInt(\"1.3.1 subset\"));\n224: // This used to return 0f in [lang] version 2.5:\n225: assertEquals(130, SystemUtils.toJavaVersionInt(\"XXX-1.3.x\"));\n226: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>\n* The <code>file.encoding</code> System Property.\n* </p>\n* <p>\n* File encoding, such as <code>Cp1252</code>.\n* </p>\n*\n* <p>\n* Defaults to <code>null</code> if the runtime does not have security access to read this property or the property does not exist.\n* </p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)} or"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nreturn toVersionFloat(toJavaVersionIntArray(SystemUtils.JAVA_VERSION, JAVA_VERSION_TRIM_SIZE));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nreturn toVersionInt(toJavaVersionIntArray(SystemUtils.JAVA_VERSION, JAVA_VERSION_TRIM_SIZE));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nreturn isJavaVersionMatch(JAVA_VERSION_TRIMMED, versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nreturn isOSMatch(OS_NAME, OS_VERSION, osNamePrefix, osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatchesName(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatchesName(String osNamePrefix) {\nreturn isOSNameMatch(OS_NAME, osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\");\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:isJavaVersionMatch(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "static boolean isJavaVersionMatch(String version, String versionPrefix) {\nif (version == null) {\nreturn false;\n}\nreturn version.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:isOSMatch(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "static boolean isOSMatch(String osName, String osVersion, String osNamePrefix, String osVersionPrefix) {\nif (osName == null || osVersion == null) {\nreturn false;\n}\nreturn osName.startsWith(osNamePrefix) && osVersion.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:isOSNameMatch(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "static boolean isOSNameMatch(String osName, String osNamePrefix) {\nif (osName == null) {\nreturn false;\n}\nreturn osName.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:toJavaVersionInt(Ljava/lang/String;)F",
                                    "method_body": "static float toJavaVersionInt(String version) {\nreturn toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:toJavaVersionIntArray(Ljava/lang/String;I)[I",
                                    "method_body": "private static int[] toJavaVersionIntArray(String version, int limit) {\nif (version == null) {\nreturn ArrayUtils.EMPTY_INT_ARRAY;\n}\nString[] strings = Pattern.compile(\"[^\\\\d]\").split(version);\nint[] ints = new int[Math.min(limit, strings.length)];\nint j = 0;\nfor (int i = 0; i < strings.length && j < limit; i++) {\nString s = strings[i];\nif (s.length() > 0) {\nints[j++] = Integer.parseInt(s);\n}\n}\nreturn ints;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:toVersionFloat([I)F",
                                    "method_body": "private static float toVersionFloat(int[] javaVersions) {\nif (javaVersions == null || javaVersions.length == 0) {\nreturn 0f;\n}\nif (javaVersions.length == 1) {\nreturn javaVersions[0];\n}\nStringBuilder builder = new StringBuilder();\nbuilder.append(javaVersions[0]);\nbuilder.append('.');\nfor (int i = 1; i < javaVersions.length; i++) {\nbuilder.append(javaVersions[i]);\n}\ntry {\nreturn Float.parseFloat(builder.toString());\n} catch (Exception ex) {\nreturn 0f;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:toVersionInt([I)I",
                                    "method_body": "private static int toVersionInt(int[] javaVersions) {\nif (javaVersions == null) {\nreturn 0;\n}\nint intVersion = 0;\nint len = javaVersions.length;\nif (len >= 1) {\nintVersion = javaVersions[0] * 100;\n}\nif (len >= 2) {\nintVersion += javaVersions[1] * 10;\n}\nif (len >= 3) {\nintVersion += javaVersions[2];\n}\nreturn intVersion;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:<clinit>()V",
                                    "method_body": "public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n/**\n* An empty immutable <code>Class</code> array.\n*/\npublic static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n/**\n* An empty immutable <code>String</code> array.\n*/\npublic static final String[] EMPTY_STRING_ARRAY = new String[0];\n/**\n* An empty immutable <code>long</code> array.\n*/\npublic static final long[] EMPTY_LONG_ARRAY = new long[0];\n/**\n* An empty immutable <code>Long</code> array.\n*/\npublic static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];\n/**\n* An empty immutable <code>int</code> array.\n*/\npublic static final int[] EMPTY_INT_ARRAY = new int[0];\n/**\n* An empty immutable <code>Integer</code> array.\n*/\npublic static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n/**\n* An empty immutable <code>short</code> array.\n*/\npublic static final short[] EMPTY_SHORT_ARRAY = new short[0];\n/**\n* An empty immutable <code>Short</code> array.\n*/\npublic static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0];\n/**\n* An empty immutable <code>byte</code> array.\n*/\npublic static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n/**\n* An empty immutable <code>Byte</code> array.\n*/\npublic static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];\n/**\n* An empty immutable <code>double</code> array.\n*/\npublic static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n/**\n* An empty immutable <code>Double</code> array.\n*/\npublic static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0];\n/**\n* An empty immutable <code>float</code> array.\n*/\npublic static final float[] EMPTY_FLOAT_ARRAY = new float[0];\n/**\n* An empty immutable <code>Float</code> array.\n*/\npublic static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0];\n/**\n* An empty immutable <code>boolean</code> array.\n*/\npublic static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];\n/**\n* An empty immutable <code>Boolean</code> array.\n*/\npublic static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];\n/**\n* An empty immutable <code>char</code> array.\n*/\npublic static final char[] EMPTY_CHAR_ARRAY = new char[0];\n/**\n* An empty immutable <code>Character</code> array.\n*/\npublic static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n\n/**\n* The index value when an element is not found in a list or array: <code>-1</code>.\n* This value is returned by methods in this class and can also be used in comparisons with values returned by\n* various method from {@link java.util.List}."
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 30,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest.testContainsAny_StringCharArrayWithBadSupplementaryChars",
                            "test_body": "133: public void testContainsAny_StringCharArrayWithBadSupplementaryChars() {\n134: // Test edge case: 1/2 of a (broken) supplementary char\n135: assertEquals(false, StringUtils.containsAny(CharUSuppCharHigh, CharU20001.toCharArray()));\n136: assertEquals(false, StringUtils.containsAny(\"abc\" + CharUSuppCharHigh + \"xyz\", CharU20001.toCharArray()));\n137: assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001));\n138: assertEquals(false, StringUtils.containsAny(CharUSuppCharLow, CharU20001.toCharArray()));\n139: assertEquals(false, StringUtils.containsAny(CharU20001, CharUSuppCharHigh.toCharArray()));\n140: assertEquals(0, CharU20001.indexOf(CharUSuppCharLow));\n141: assertEquals(true, StringUtils.containsAny(CharU20001, CharUSuppCharLow.toCharArray()));\n142: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:isEmpty(Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean isEmpty(CharSequence cs) {\nreturn cs == null || cs.length() == 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:containsAny(Ljava/lang/CharSequence;[C)Z",
                                    "method_body": "public static boolean containsAny(CharSequence cs, char[] searchChars) {\nif (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\nreturn false;\n}\nint csLength = cs.length();\nint searchLength = searchChars.length;\nint csLast = csLength - 1;\nint searchLast = searchLength - 1;\nfor (int i = 0; i < csLength; i++) {\nchar ch = cs.charAt(i);\nfor (int j = 0; j < searchLength; j++) {\nif (searchChars[j] == ch) {\nif (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n// missing low surrogate, fine, like String.indexOf(String)\nif (searchChars[j + 1] == cs.charAt(i + 1)) {\nreturn true;\n}\n} else {\n// ch is in the Basic Multilingual Plane\nreturn true;\n}\n}\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:<clinit>()V",
                                    "method_body": "public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n/**\n* An empty immutable <code>Class</code> array.\n*/\npublic static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n/**\n* An empty immutable <code>String</code> array.\n*/\npublic static final String[] EMPTY_STRING_ARRAY = new String[0];\n/**\n* An empty immutable <code>long</code> array.\n*/\npublic static final long[] EMPTY_LONG_ARRAY = new long[0];\n/**\n* An empty immutable <code>Long</code> array.\n*/\npublic static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];\n/**\n* An empty immutable <code>int</code> array.\n*/\npublic static final int[] EMPTY_INT_ARRAY = new int[0];\n/**\n* An empty immutable <code>Integer</code> array.\n*/\npublic static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n/**\n* An empty immutable <code>short</code> array.\n*/\npublic static final short[] EMPTY_SHORT_ARRAY = new short[0];\n/**\n* An empty immutable <code>Short</code> array.\n*/\npublic static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0];\n/**\n* An empty immutable <code>byte</code> array.\n*/\npublic static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n/**\n* An empty immutable <code>Byte</code> array.\n*/\npublic static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];\n/**\n* An empty immutable <code>double</code> array.\n*/\npublic static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n/**\n* An empty immutable <code>Double</code> array.\n*/\npublic static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0];\n/**\n* An empty immutable <code>float</code> array.\n*/\npublic static final float[] EMPTY_FLOAT_ARRAY = new float[0];\n/**\n* An empty immutable <code>Float</code> array.\n*/\npublic static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0];\n/**\n* An empty immutable <code>boolean</code> array.\n*/\npublic static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];\n/**\n* An empty immutable <code>Boolean</code> array.\n*/\npublic static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];\n/**\n* An empty immutable <code>char</code> array.\n*/\npublic static final char[] EMPTY_CHAR_ARRAY = new char[0];\n/**\n* An empty immutable <code>Character</code> array.\n*/\npublic static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n\n/**\n* The index value when an element is not found in a list or array: <code>-1</code>.\n* This value is returned by methods in this class and can also be used in comparisons with values returned by\n* various method from {@link java.util.List}."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:isEmpty([C)Z",
                                    "method_body": "public static boolean isEmpty(char[] array) {\nif (array == null || array.length == 0) {\nreturn true;\n}\nreturn false;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest.testIndexOfAny_StringCharArrayWithSupplementaryChars",
                            "test_body": "526: public void testIndexOfAny_StringCharArrayWithSupplementaryChars() {\n527: assertEquals(0, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20000.toCharArray()));\n528: assertEquals(2, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20001.toCharArray()));\n529: assertEquals(0, StringUtils.indexOfAny(CharU20000, CharU20000.toCharArray()));\n530: assertEquals(-1, StringUtils.indexOfAny(CharU20000, CharU20001.toCharArray()));    \n531: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:isEmpty(Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean isEmpty(CharSequence cs) {\nreturn cs == null || cs.length() == 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:<clinit>()V",
                                    "method_body": "public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n/**\n* An empty immutable <code>Class</code> array.\n*/\npublic static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n/**\n* An empty immutable <code>String</code> array.\n*/\npublic static final String[] EMPTY_STRING_ARRAY = new String[0];\n/**\n* An empty immutable <code>long</code> array.\n*/\npublic static final long[] EMPTY_LONG_ARRAY = new long[0];\n/**\n* An empty immutable <code>Long</code> array.\n*/\npublic static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];\n/**\n* An empty immutable <code>int</code> array.\n*/\npublic static final int[] EMPTY_INT_ARRAY = new int[0];\n/**\n* An empty immutable <code>Integer</code> array.\n*/\npublic static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n/**\n* An empty immutable <code>short</code> array.\n*/\npublic static final short[] EMPTY_SHORT_ARRAY = new short[0];\n/**\n* An empty immutable <code>Short</code> array.\n*/\npublic static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0];\n/**\n* An empty immutable <code>byte</code> array.\n*/\npublic static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n/**\n* An empty immutable <code>Byte</code> array.\n*/\npublic static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];\n/**\n* An empty immutable <code>double</code> array.\n*/\npublic static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n/**\n* An empty immutable <code>Double</code> array.\n*/\npublic static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0];\n/**\n* An empty immutable <code>float</code> array.\n*/\npublic static final float[] EMPTY_FLOAT_ARRAY = new float[0];\n/**\n* An empty immutable <code>Float</code> array.\n*/\npublic static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0];\n/**\n* An empty immutable <code>boolean</code> array.\n*/\npublic static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];\n/**\n* An empty immutable <code>Boolean</code> array.\n*/\npublic static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];\n/**\n* An empty immutable <code>char</code> array.\n*/\npublic static final char[] EMPTY_CHAR_ARRAY = new char[0];\n/**\n* An empty immutable <code>Character</code> array.\n*/\npublic static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n\n/**\n* The index value when an element is not found in a list or array: <code>-1</code>.\n* This value is returned by methods in this class and can also be used in comparisons with values returned by\n* various method from {@link java.util.List}."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:isEmpty([C)Z",
                                    "method_body": "public static boolean isEmpty(char[] array) {\nif (array == null || array.length == 0) {\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:indexOfAny(Ljava/lang/CharSequence;[C)I",
                                    "method_body": "public static int indexOfAny(CharSequence cs, char[] searchChars) {\nif (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\nreturn INDEX_NOT_FOUND;\n}\nint csLen = cs.length();\nint searchLen = searchChars.length;\nfor (int i = 0; i < csLen; i++) {\nchar ch = cs.charAt(i);\nfor (int j = 0; j < searchLen; j++) {\nif (searchChars[j] == ch) {\n// ch is a supplementary character\nreturn i;\n}\n}\n}\nreturn INDEX_NOT_FOUND;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest.testIndexOfAny_StringStringWithSupplementaryChars",
                            "test_body": "569: public void testIndexOfAny_StringStringWithSupplementaryChars() {\n570: assertEquals(0, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20000));\n571: assertEquals(2, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20001));\n572: assertEquals(0, StringUtils.indexOfAny(CharU20000, CharU20000));\n573: assertEquals(-1, StringUtils.indexOfAny(CharU20000, CharU20001));    \n574: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:isEmpty(Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean isEmpty(CharSequence cs) {\nreturn cs == null || cs.length() == 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:<clinit>()V",
                                    "method_body": "public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n/**\n* An empty immutable <code>Class</code> array.\n*/\npublic static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n/**\n* An empty immutable <code>String</code> array.\n*/\npublic static final String[] EMPTY_STRING_ARRAY = new String[0];\n/**\n* An empty immutable <code>long</code> array.\n*/\npublic static final long[] EMPTY_LONG_ARRAY = new long[0];\n/**\n* An empty immutable <code>Long</code> array.\n*/\npublic static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];\n/**\n* An empty immutable <code>int</code> array.\n*/\npublic static final int[] EMPTY_INT_ARRAY = new int[0];\n/**\n* An empty immutable <code>Integer</code> array.\n*/\npublic static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n/**\n* An empty immutable <code>short</code> array.\n*/\npublic static final short[] EMPTY_SHORT_ARRAY = new short[0];\n/**\n* An empty immutable <code>Short</code> array.\n*/\npublic static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0];\n/**\n* An empty immutable <code>byte</code> array.\n*/\npublic static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n/**\n* An empty immutable <code>Byte</code> array.\n*/\npublic static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];\n/**\n* An empty immutable <code>double</code> array.\n*/\npublic static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n/**\n* An empty immutable <code>Double</code> array.\n*/\npublic static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0];\n/**\n* An empty immutable <code>float</code> array.\n*/\npublic static final float[] EMPTY_FLOAT_ARRAY = new float[0];\n/**\n* An empty immutable <code>Float</code> array.\n*/\npublic static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0];\n/**\n* An empty immutable <code>boolean</code> array.\n*/\npublic static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];\n/**\n* An empty immutable <code>Boolean</code> array.\n*/\npublic static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];\n/**\n* An empty immutable <code>char</code> array.\n*/\npublic static final char[] EMPTY_CHAR_ARRAY = new char[0];\n/**\n* An empty immutable <code>Character</code> array.\n*/\npublic static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n\n/**\n* The index value when an element is not found in a list or array: <code>-1</code>.\n* This value is returned by methods in this class and can also be used in comparisons with values returned by\n* various method from {@link java.util.List}."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:isEmpty([C)Z",
                                    "method_body": "public static boolean isEmpty(char[] array) {\nif (array == null || array.length == 0) {\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:indexOfAny(Ljava/lang/CharSequence;[C)I",
                                    "method_body": "public static int indexOfAny(CharSequence cs, char[] searchChars) {\nif (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\nreturn INDEX_NOT_FOUND;\n}\nint csLen = cs.length();\nint searchLen = searchChars.length;\nfor (int i = 0; i < csLen; i++) {\nchar ch = cs.charAt(i);\nfor (int j = 0; j < searchLen; j++) {\nif (searchChars[j] == ch) {\n// ch is a supplementary character\nreturn i;\n}\n}\n}\nreturn INDEX_NOT_FOUND;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:indexOfAny(Ljava/lang/CharSequence;Ljava/lang/String;)I",
                                    "method_body": "public static int indexOfAny(CharSequence cs, String searchChars) {\nif (isEmpty(cs) || isEmpty(searchChars)) {\nreturn INDEX_NOT_FOUND;\n}\nreturn indexOfAny(cs, searchChars.toCharArray());\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest.testContainsAny_StringWithBadSupplementaryChars",
                            "test_body": "182: public void testContainsAny_StringWithBadSupplementaryChars() {\n183: // Test edge case: 1/2 of a (broken) supplementary char\n184: assertEquals(false, StringUtils.containsAny(CharUSuppCharHigh, CharU20001));\n185: assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001));\n186: assertEquals(false, StringUtils.containsAny(CharUSuppCharLow, CharU20001));\n187: assertEquals(false, StringUtils.containsAny(CharU20001, CharUSuppCharHigh));\n188: assertEquals(0, CharU20001.indexOf(CharUSuppCharLow));\n189: assertEquals(true, StringUtils.containsAny(CharU20001, CharUSuppCharLow));\n190: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:isEmpty(Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean isEmpty(CharSequence cs) {\nreturn cs == null || cs.length() == 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:containsAny(Ljava/lang/CharSequence;[C)Z",
                                    "method_body": "public static boolean containsAny(CharSequence cs, char[] searchChars) {\nif (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\nreturn false;\n}\nint csLength = cs.length();\nint searchLength = searchChars.length;\nint csLast = csLength - 1;\nint searchLast = searchLength - 1;\nfor (int i = 0; i < csLength; i++) {\nchar ch = cs.charAt(i);\nfor (int j = 0; j < searchLength; j++) {\nif (searchChars[j] == ch) {\nif (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n// missing low surrogate, fine, like String.indexOf(String)\nif (searchChars[j + 1] == cs.charAt(i + 1)) {\nreturn true;\n}\n} else {\n// ch is in the Basic Multilingual Plane\nreturn true;\n}\n}\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:<clinit>()V",
                                    "method_body": "public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n/**\n* An empty immutable <code>Class</code> array.\n*/\npublic static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n/**\n* An empty immutable <code>String</code> array.\n*/\npublic static final String[] EMPTY_STRING_ARRAY = new String[0];\n/**\n* An empty immutable <code>long</code> array.\n*/\npublic static final long[] EMPTY_LONG_ARRAY = new long[0];\n/**\n* An empty immutable <code>Long</code> array.\n*/\npublic static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];\n/**\n* An empty immutable <code>int</code> array.\n*/\npublic static final int[] EMPTY_INT_ARRAY = new int[0];\n/**\n* An empty immutable <code>Integer</code> array.\n*/\npublic static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n/**\n* An empty immutable <code>short</code> array.\n*/\npublic static final short[] EMPTY_SHORT_ARRAY = new short[0];\n/**\n* An empty immutable <code>Short</code> array.\n*/\npublic static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0];\n/**\n* An empty immutable <code>byte</code> array.\n*/\npublic static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n/**\n* An empty immutable <code>Byte</code> array.\n*/\npublic static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];\n/**\n* An empty immutable <code>double</code> array.\n*/\npublic static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n/**\n* An empty immutable <code>Double</code> array.\n*/\npublic static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0];\n/**\n* An empty immutable <code>float</code> array.\n*/\npublic static final float[] EMPTY_FLOAT_ARRAY = new float[0];\n/**\n* An empty immutable <code>Float</code> array.\n*/\npublic static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0];\n/**\n* An empty immutable <code>boolean</code> array.\n*/\npublic static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];\n/**\n* An empty immutable <code>Boolean</code> array.\n*/\npublic static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];\n/**\n* An empty immutable <code>char</code> array.\n*/\npublic static final char[] EMPTY_CHAR_ARRAY = new char[0];\n/**\n* An empty immutable <code>Character</code> array.\n*/\npublic static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n\n/**\n* The index value when an element is not found in a list or array: <code>-1</code>.\n* This value is returned by methods in this class and can also be used in comparisons with values returned by\n* various method from {@link java.util.List}."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:isEmpty([C)Z",
                                    "method_body": "public static boolean isEmpty(char[] array) {\nif (array == null || array.length == 0) {\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:containsAny(Ljava/lang/CharSequence;Ljava/lang/String;)Z",
                                    "method_body": "public static boolean containsAny(CharSequence cs, String searchChars) {\nif (searchChars == null) {\nreturn false;\n}\nreturn containsAny(cs, searchChars.toCharArray());\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest.testIndexOfAnyBut_StringStringWithSupplementaryChars",
                            "test_body": "615: public void testIndexOfAnyBut_StringStringWithSupplementaryChars() {\n616: assertEquals(2, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20000));\n617: assertEquals(0, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20001));\n618: assertEquals(-1, StringUtils.indexOfAnyBut(CharU20000, CharU20000));\n619: assertEquals(0, StringUtils.indexOfAnyBut(CharU20000, CharU20001));        \n620: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:isEmpty(Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean isEmpty(CharSequence cs) {\nreturn cs == null || cs.length() == 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:indexOfAnyBut(Ljava/lang/String;Ljava/lang/String;)I",
                                    "method_body": "public static int indexOfAnyBut(String str, String searchChars) {\nif (isEmpty(str) || isEmpty(searchChars)) {\nreturn INDEX_NOT_FOUND;\n}\nint strLen = str.length();\nfor (int i = 0; i < strLen; i++) {\nchar ch = str.charAt(i);\nif (searchChars.indexOf(ch) < 0) {\nreturn i;\n}\n}\nreturn INDEX_NOT_FOUND;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest.testIndexOfAnyBut_StringCharArrayWithSupplementaryChars",
                            "test_body": "592: public void testIndexOfAnyBut_StringCharArrayWithSupplementaryChars() {\n593: assertEquals(2, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20000.toCharArray()));\n594: assertEquals(0, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20001.toCharArray()));\n595: assertEquals(-1, StringUtils.indexOfAnyBut(CharU20000, CharU20000.toCharArray()));\n596: assertEquals(0, StringUtils.indexOfAnyBut(CharU20000, CharU20001.toCharArray()));        \n597: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:isEmpty(Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean isEmpty(CharSequence cs) {\nreturn cs == null || cs.length() == 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:<clinit>()V",
                                    "method_body": "public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n/**\n* An empty immutable <code>Class</code> array.\n*/\npublic static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n/**\n* An empty immutable <code>String</code> array.\n*/\npublic static final String[] EMPTY_STRING_ARRAY = new String[0];\n/**\n* An empty immutable <code>long</code> array.\n*/\npublic static final long[] EMPTY_LONG_ARRAY = new long[0];\n/**\n* An empty immutable <code>Long</code> array.\n*/\npublic static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];\n/**\n* An empty immutable <code>int</code> array.\n*/\npublic static final int[] EMPTY_INT_ARRAY = new int[0];\n/**\n* An empty immutable <code>Integer</code> array.\n*/\npublic static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n/**\n* An empty immutable <code>short</code> array.\n*/\npublic static final short[] EMPTY_SHORT_ARRAY = new short[0];\n/**\n* An empty immutable <code>Short</code> array.\n*/\npublic static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0];\n/**\n* An empty immutable <code>byte</code> array.\n*/\npublic static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n/**\n* An empty immutable <code>Byte</code> array.\n*/\npublic static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];\n/**\n* An empty immutable <code>double</code> array.\n*/\npublic static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n/**\n* An empty immutable <code>Double</code> array.\n*/\npublic static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0];\n/**\n* An empty immutable <code>float</code> array.\n*/\npublic static final float[] EMPTY_FLOAT_ARRAY = new float[0];\n/**\n* An empty immutable <code>Float</code> array.\n*/\npublic static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0];\n/**\n* An empty immutable <code>boolean</code> array.\n*/\npublic static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];\n/**\n* An empty immutable <code>Boolean</code> array.\n*/\npublic static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];\n/**\n* An empty immutable <code>char</code> array.\n*/\npublic static final char[] EMPTY_CHAR_ARRAY = new char[0];\n/**\n* An empty immutable <code>Character</code> array.\n*/\npublic static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n\n/**\n* The index value when an element is not found in a list or array: <code>-1</code>.\n* This value is returned by methods in this class and can also be used in comparisons with values returned by\n* various method from {@link java.util.List}."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:isEmpty([C)Z",
                                    "method_body": "public static boolean isEmpty(char[] array) {\nif (array == null || array.length == 0) {\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:indexOfAnyBut(Ljava/lang/CharSequence;[C)I",
                                    "method_body": "public static int indexOfAnyBut(CharSequence cs, char[] searchChars) {\nif (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\nreturn INDEX_NOT_FOUND;\n}\nint csLen = cs.length();\nint searchLen = searchChars.length;\nouter:\nfor (int i = 0; i < csLen; i++) {\nchar ch = cs.charAt(i);\nfor (int j = 0; j < searchLen; j++) {\nif (searchChars[j] == ch) {\ncontinue outer;\n}\n}\nreturn i;\n}\nreturn INDEX_NOT_FOUND;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest.testContainsNone_StringWithSupplementaryChars",
                            "test_body": "372: public void testContainsNone_StringWithSupplementaryChars() {\n373: assertEquals(false, StringUtils.containsNone(CharU20000 + CharU20001, CharU20000));\n374: assertEquals(false, StringUtils.containsNone(CharU20000 + CharU20001, CharU20001));\n375: assertEquals(false, StringUtils.containsNone(CharU20000, CharU20000));\n376: // Sanity check:\n377: assertEquals(-1, CharU20000.indexOf(CharU20001));\n378: assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0)));\n379: assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1)));\n380: // Test:\n381: assertEquals(true, StringUtils.containsNone(CharU20000, CharU20001));\n382: assertEquals(true, StringUtils.containsNone(CharU20001, CharU20000));\n383: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:containsNone(Ljava/lang/CharSequence;[C)Z",
                                    "method_body": "public static boolean containsNone(CharSequence cs, char[] searchChars) {\nif (cs == null || searchChars == null) {\nreturn true;\n}\nint csLen = cs.length();\nint searchLen = searchChars.length;\nfor (int i = 0; i < csLen; i++) {\nchar ch = cs.charAt(i);\nfor (int j = 0; j < searchLen; j++) {\nif (searchChars[j] == ch) {\n// missing low surrogate, fine, like String.indexOf(String)\n// ch is in the Basic Multilingual Plane\nreturn false;\n}\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:containsNone(Ljava/lang/CharSequence;Ljava/lang/String;)Z",
                                    "method_body": "public static boolean containsNone(CharSequence cs, String invalidChars) {\nif (cs == null || invalidChars == null) {\nreturn true;\n}\nreturn containsNone(cs, invalidChars.toCharArray());\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest.testContainsNone_StringWithBadSupplementaryChars",
                            "test_body": "358: public void testContainsNone_StringWithBadSupplementaryChars() {\n359: // Test edge case: 1/2 of a (broken) supplementary char\n360: assertEquals(true, StringUtils.containsNone(CharUSuppCharHigh, CharU20001));\n361: assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001));\n362: assertEquals(true, StringUtils.containsNone(CharUSuppCharLow, CharU20001));\n363: assertEquals(-1, CharU20001.indexOf(CharUSuppCharHigh));\n364: assertEquals(true, StringUtils.containsNone(CharU20001, CharUSuppCharHigh));\n365: assertEquals(0, CharU20001.indexOf(CharUSuppCharLow));\n366: assertEquals(false, StringUtils.containsNone(CharU20001, CharUSuppCharLow));        \n367: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:containsNone(Ljava/lang/CharSequence;[C)Z",
                                    "method_body": "public static boolean containsNone(CharSequence cs, char[] searchChars) {\nif (cs == null || searchChars == null) {\nreturn true;\n}\nint csLen = cs.length();\nint searchLen = searchChars.length;\nfor (int i = 0; i < csLen; i++) {\nchar ch = cs.charAt(i);\nfor (int j = 0; j < searchLen; j++) {\nif (searchChars[j] == ch) {\n// missing low surrogate, fine, like String.indexOf(String)\n// ch is in the Basic Multilingual Plane\nreturn false;\n}\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:containsNone(Ljava/lang/CharSequence;Ljava/lang/String;)Z",
                                    "method_body": "public static boolean containsNone(CharSequence cs, String invalidChars) {\nif (cs == null || invalidChars == null) {\nreturn true;\n}\nreturn containsNone(cs, invalidChars.toCharArray());\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest.testContainsNone_CharArrayWithSupplementaryChars",
                            "test_body": "318: public void testContainsNone_CharArrayWithSupplementaryChars() {\n319: assertEquals(false, StringUtils.containsNone(CharU20000 + CharU20001, CharU20000.toCharArray()));\n320: assertEquals(false, StringUtils.containsNone(CharU20000 + CharU20001, CharU20001.toCharArray()));\n321: assertEquals(false, StringUtils.containsNone(CharU20000, CharU20000.toCharArray()));\n322: // Sanity check:\n323: assertEquals(-1, CharU20000.indexOf(CharU20001));\n324: assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0)));\n325: assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1)));\n326: // Test:\n327: assertEquals(true, StringUtils.containsNone(CharU20000, CharU20001.toCharArray()));\n328: assertEquals(true, StringUtils.containsNone(CharU20001, CharU20000.toCharArray()));\n329: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:containsNone(Ljava/lang/CharSequence;[C)Z",
                                    "method_body": "public static boolean containsNone(CharSequence cs, char[] searchChars) {\nif (cs == null || searchChars == null) {\nreturn true;\n}\nint csLen = cs.length();\nint searchLen = searchChars.length;\nfor (int i = 0; i < csLen; i++) {\nchar ch = cs.charAt(i);\nfor (int j = 0; j < searchLen; j++) {\nif (searchChars[j] == ch) {\n// missing low surrogate, fine, like String.indexOf(String)\n// ch is in the Basic Multilingual Plane\nreturn false;\n}\n}\n}\nreturn true;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest.testContainsNone_CharArrayWithBadSupplementaryChars",
                            "test_body": "304: public void testContainsNone_CharArrayWithBadSupplementaryChars() {\n305: // Test edge case: 1/2 of a (broken) supplementary char\n306: assertEquals(true, StringUtils.containsNone(CharUSuppCharHigh, CharU20001.toCharArray()));\n307: assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001));\n308: assertEquals(true, StringUtils.containsNone(CharUSuppCharLow, CharU20001.toCharArray()));\n309: assertEquals(-1, CharU20001.indexOf(CharUSuppCharHigh));\n310: assertEquals(true, StringUtils.containsNone(CharU20001, CharUSuppCharHigh.toCharArray()));\n311: assertEquals(0, CharU20001.indexOf(CharUSuppCharLow));\n312: assertEquals(false, StringUtils.containsNone(CharU20001, CharUSuppCharLow.toCharArray()));\n313: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:containsNone(Ljava/lang/CharSequence;[C)Z",
                                    "method_body": "public static boolean containsNone(CharSequence cs, char[] searchChars) {\nif (cs == null || searchChars == null) {\nreturn true;\n}\nint csLen = cs.length();\nint searchLen = searchChars.length;\nfor (int i = 0; i < csLen; i++) {\nchar ch = cs.charAt(i);\nfor (int j = 0; j < searchLen; j++) {\nif (searchChars[j] == ch) {\n// missing low surrogate, fine, like String.indexOf(String)\n// ch is in the Basic Multilingual Plane\nreturn false;\n}\n}\n}\nreturn true;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 31,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest.testContainsAnyStringWithSupplementaryChars",
                            "test_body": "671: public void testContainsAnyStringWithSupplementaryChars() {\n672: assertEquals(true, StringUtils.containsAny(CharU20000 + CharU20001, CharU20000));\n673: assertEquals(true, StringUtils.containsAny(CharU20000 + CharU20001, CharU20001));\n674: assertEquals(true, StringUtils.containsAny(CharU20000, CharU20000));\n675: // Sanity check:\n676: assertEquals(-1, CharU20000.indexOf(CharU20001));\n677: assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0)));\n678: assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1)));\n679: // Test:\n680: assertEquals(false, StringUtils.containsAny(CharU20000, CharU20001));\n681: assertEquals(false, StringUtils.containsAny(CharU20001, CharU20000));\n682: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:isEmpty(Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean isEmpty(CharSequence cs) {\nreturn cs == null || cs.length() == 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:containsAny(Ljava/lang/CharSequence;[C)Z",
                                    "method_body": "public static boolean containsAny(CharSequence cs, char[] searchChars) {\nif (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\nreturn false;\n}\nint csLength = cs.length();\nint searchLength = searchChars.length;\nfor (int i = 0; i < csLength; i++) {\nchar ch = cs.charAt(i);\nfor (int j = 0; j < searchLength; j++) {\nif (searchChars[j] == ch) {\n// ch is a supplementary character\n// ch is in the Basic Multilingual Plane\nreturn true;\n}\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:containsAny(Ljava/lang/CharSequence;Ljava/lang/String;)Z",
                                    "method_body": "public static boolean containsAny(CharSequence cs, String searchChars) {\nif (searchChars == null) {\nreturn false;\n}\nreturn containsAny(cs, searchChars.toCharArray());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:<clinit>()V",
                                    "method_body": "public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n/**\n* An empty immutable <code>Class</code> array.\n*/\npublic static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n/**\n* An empty immutable <code>String</code> array.\n*/\npublic static final String[] EMPTY_STRING_ARRAY = new String[0];\n/**\n* An empty immutable <code>long</code> array.\n*/\npublic static final long[] EMPTY_LONG_ARRAY = new long[0];\n/**\n* An empty immutable <code>Long</code> array.\n*/\npublic static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];\n/**\n* An empty immutable <code>int</code> array.\n*/\npublic static final int[] EMPTY_INT_ARRAY = new int[0];\n/**\n* An empty immutable <code>Integer</code> array.\n*/\npublic static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n/**\n* An empty immutable <code>short</code> array.\n*/\npublic static final short[] EMPTY_SHORT_ARRAY = new short[0];\n/**\n* An empty immutable <code>Short</code> array.\n*/\npublic static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0];\n/**\n* An empty immutable <code>byte</code> array.\n*/\npublic static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n/**\n* An empty immutable <code>Byte</code> array.\n*/\npublic static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];\n/**\n* An empty immutable <code>double</code> array.\n*/\npublic static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n/**\n* An empty immutable <code>Double</code> array.\n*/\npublic static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0];\n/**\n* An empty immutable <code>float</code> array.\n*/\npublic static final float[] EMPTY_FLOAT_ARRAY = new float[0];\n/**\n* An empty immutable <code>Float</code> array.\n*/\npublic static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0];\n/**\n* An empty immutable <code>boolean</code> array.\n*/\npublic static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];\n/**\n* An empty immutable <code>Boolean</code> array.\n*/\npublic static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];\n/**\n* An empty immutable <code>char</code> array.\n*/\npublic static final char[] EMPTY_CHAR_ARRAY = new char[0];\n/**\n* An empty immutable <code>Character</code> array.\n*/\npublic static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n\n/**\n* The index value when an element is not found in a list or array: <code>-1</code>.\n* This value is returned by methods in this class and can also be used in comparisons with values returned by\n* various method from {@link java.util.List}."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:isEmpty([C)Z",
                                    "method_body": "public static boolean isEmpty(char[] array) {\nif (array == null || array.length == 0) {\nreturn true;\n}\nreturn false;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest.testContainsAnyCharArrayWithSupplementaryChars",
                            "test_body": "687: public void testContainsAnyCharArrayWithSupplementaryChars() {\n688: assertEquals(true, StringUtils.containsAny(CharU20000 + CharU20001, CharU20000.toCharArray()));\n689: assertEquals(true, StringUtils.containsAny(CharU20000 + CharU20001, CharU20001.toCharArray()));\n690: assertEquals(true, StringUtils.containsAny(CharU20000, CharU20000.toCharArray()));\n691: // Sanity check:\n692: assertEquals(-1, CharU20000.indexOf(CharU20001));\n693: assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0)));\n694: assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1)));\n695: // Test:\n696: assertEquals(false, StringUtils.containsAny(CharU20000, CharU20001.toCharArray()));\n697: assertEquals(false, StringUtils.containsAny(CharU20001, CharU20000.toCharArray()));\n698: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:isEmpty(Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean isEmpty(CharSequence cs) {\nreturn cs == null || cs.length() == 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:containsAny(Ljava/lang/CharSequence;[C)Z",
                                    "method_body": "public static boolean containsAny(CharSequence cs, char[] searchChars) {\nif (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\nreturn false;\n}\nint csLength = cs.length();\nint searchLength = searchChars.length;\nfor (int i = 0; i < csLength; i++) {\nchar ch = cs.charAt(i);\nfor (int j = 0; j < searchLength; j++) {\nif (searchChars[j] == ch) {\n// ch is a supplementary character\n// ch is in the Basic Multilingual Plane\nreturn true;\n}\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:<clinit>()V",
                                    "method_body": "public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n/**\n* An empty immutable <code>Class</code> array.\n*/\npublic static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n/**\n* An empty immutable <code>String</code> array.\n*/\npublic static final String[] EMPTY_STRING_ARRAY = new String[0];\n/**\n* An empty immutable <code>long</code> array.\n*/\npublic static final long[] EMPTY_LONG_ARRAY = new long[0];\n/**\n* An empty immutable <code>Long</code> array.\n*/\npublic static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];\n/**\n* An empty immutable <code>int</code> array.\n*/\npublic static final int[] EMPTY_INT_ARRAY = new int[0];\n/**\n* An empty immutable <code>Integer</code> array.\n*/\npublic static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n/**\n* An empty immutable <code>short</code> array.\n*/\npublic static final short[] EMPTY_SHORT_ARRAY = new short[0];\n/**\n* An empty immutable <code>Short</code> array.\n*/\npublic static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0];\n/**\n* An empty immutable <code>byte</code> array.\n*/\npublic static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n/**\n* An empty immutable <code>Byte</code> array.\n*/\npublic static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];\n/**\n* An empty immutable <code>double</code> array.\n*/\npublic static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n/**\n* An empty immutable <code>Double</code> array.\n*/\npublic static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0];\n/**\n* An empty immutable <code>float</code> array.\n*/\npublic static final float[] EMPTY_FLOAT_ARRAY = new float[0];\n/**\n* An empty immutable <code>Float</code> array.\n*/\npublic static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0];\n/**\n* An empty immutable <code>boolean</code> array.\n*/\npublic static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];\n/**\n* An empty immutable <code>Boolean</code> array.\n*/\npublic static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];\n/**\n* An empty immutable <code>char</code> array.\n*/\npublic static final char[] EMPTY_CHAR_ARRAY = new char[0];\n/**\n* An empty immutable <code>Character</code> array.\n*/\npublic static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n\n/**\n* The index value when an element is not found in a list or array: <code>-1</code>.\n* This value is returned by methods in this class and can also be used in comparisons with values returned by\n* various method from {@link java.util.List}."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:isEmpty([C)Z",
                                    "method_body": "public static boolean isEmpty(char[] array) {\nif (array == null || array.length == 0) {\nreturn true;\n}\nreturn false;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 32,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.builder.HashCodeBuilderTest.testReflectionObjectCycle",
                            "test_body": "500: public void testReflectionObjectCycle() {\n501: ReflectionTestCycleA a = new ReflectionTestCycleA();\n502: ReflectionTestCycleB b = new ReflectionTestCycleB();\n503: a.b = b;\n504: b.a = a;\n505: 506: // Used to caused:\n507: // java.lang.StackOverflowError\n508: // at java.lang.ClassLoader.getCallerClassLoader(Native Method)\n509: // at java.lang.Class.getDeclaredFields(Class.java:992)\n510: // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionAppend(HashCodeBuilder.java:373)\n511: // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:349)\n512: // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:155)\n513: // at\n514: // org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleB.hashCode(HashCodeBuilderTest.java:53)\n515: // at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422)\n516: // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionAppend(HashCodeBuilder.java:383)\n517: // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:349)\n518: // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:155)\n519: // at\n520: // org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleA.hashCode(HashCodeBuilderTest.java:42)\n521: // at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422)\n522: 523: a.hashCode();\n524: assertNull(HashCodeBuilder.getRegistry());\n525: b.hashCode();\n526: assertNull(HashCodeBuilder.getRegistry());\n527: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:<clinit>()V",
                                    "method_body": "public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n/**\n* An empty immutable <code>Class</code> array.\n*/\npublic static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n/**\n* An empty immutable <code>String</code> array.\n*/\npublic static final String[] EMPTY_STRING_ARRAY = new String[0];\n/**\n* An empty immutable <code>long</code> array.\n*/\npublic static final long[] EMPTY_LONG_ARRAY = new long[0];\n/**\n* An empty immutable <code>Long</code> array.\n*/\npublic static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];\n/**\n* An empty immutable <code>int</code> array.\n*/\npublic static final int[] EMPTY_INT_ARRAY = new int[0];\n/**\n* An empty immutable <code>Integer</code> array.\n*/\npublic static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n/**\n* An empty immutable <code>short</code> array.\n*/\npublic static final short[] EMPTY_SHORT_ARRAY = new short[0];\n/**\n* An empty immutable <code>Short</code> array.\n*/\npublic static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0];\n/**\n* An empty immutable <code>byte</code> array.\n*/\npublic static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n/**\n* An empty immutable <code>Byte</code> array.\n*/\npublic static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];\n/**\n* An empty immutable <code>double</code> array.\n*/\npublic static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n/**\n* An empty immutable <code>Double</code> array.\n*/\npublic static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0];\n/**\n* An empty immutable <code>float</code> array.\n*/\npublic static final float[] EMPTY_FLOAT_ARRAY = new float[0];\n/**\n* An empty immutable <code>Float</code> array.\n*/\npublic static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0];\n/**\n* An empty immutable <code>boolean</code> array.\n*/\npublic static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];\n/**\n* An empty immutable <code>Boolean</code> array.\n*/\npublic static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];\n/**\n* An empty immutable <code>char</code> array.\n*/\npublic static final char[] EMPTY_CHAR_ARRAY = new char[0];\n/**\n* An empty immutable <code>Character</code> array.\n*/\npublic static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n\n/**\n* The index value when an element is not found in a list or array: <code>-1</code>.\n* This value is returned by methods in this class and can also be used in comparisons with values returned by\n* various method from {@link java.util.List}."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:indexOf([Ljava/lang/Object;Ljava/lang/Object;)I",
                                    "method_body": "public static int indexOf(Object[] array, Object objectToFind) {\nreturn indexOf(array, objectToFind, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:indexOf([Ljava/lang/Object;Ljava/lang/Object;I)I",
                                    "method_body": "public static int indexOf(Object[] array, Object objectToFind, int startIndex) {\nif (array == null) {\nreturn INDEX_NOT_FOUND;\n}\nif (startIndex < 0) {\nstartIndex = 0;\n}\nif (objectToFind == null) {\nfor (int i = startIndex; i < array.length; i++) {\nif (array[i] == null) {\nreturn i;\n}\n}\n} else if (array.getClass().getComponentType().isInstance(objectToFind)) {\nfor (int i = startIndex; i < array.length; i++) {\nif (objectToFind.equals(array[i])) {\nreturn i;\n}\n}\n}\nreturn INDEX_NOT_FOUND;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:contains([Ljava/lang/Object;Ljava/lang/Object;)Z",
                                    "method_body": "public static boolean contains(Object[] array, Object objectToFind) {\nreturn indexOf(array, objectToFind) != INDEX_NOT_FOUND;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.HashCodeBuilder:<init>(II)V",
                                    "method_body": "public HashCodeBuilder(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber) {\nif (initialNonZeroOddNumber == 0) {\nthrow new IllegalArgumentException(\"HashCodeBuilder requires a non zero initial value\");\n}\nif (initialNonZeroOddNumber % 2 == 0) {\nthrow new IllegalArgumentException(\"HashCodeBuilder requires an odd initial value\");\n}\nif (multiplierNonZeroOddNumber == 0) {\nthrow new IllegalArgumentException(\"HashCodeBuilder requires a non zero multiplier\");\n}\nif (multiplierNonZeroOddNumber % 2 == 0) {\nthrow new IllegalArgumentException(\"HashCodeBuilder requires an odd multiplier\");\n}\niConstant = multiplierNonZeroOddNumber;\niTotal = initialNonZeroOddNumber;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.HashCodeBuilder:<clinit>()V",
                                    "method_body": "private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {\n@Override\nprotected Set<IDKey> initialValue() {\nreturn new HashSet<IDKey>();\n}\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.HashCodeBuilder:getRegistry()Ljava/util/Set;",
                                    "method_body": "static Set<IDKey> getRegistry() {\nreturn REGISTRY.get();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.HashCodeBuilder:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nreturn getRegistry().contains(new IDKey(value));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.HashCodeBuilder:reflectionAppend(Ljava/lang/Object;Ljava/lang/Class;Lorg/apache/commons/lang3/builder/HashCodeBuilder;Z[Ljava/lang/String;)V",
                                    "method_body": "private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients,\nString[] excludeFields) {\nif (isRegistered(object)) {\nreturn;\n}\ntry {\nregister(object);\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nif (!ArrayUtils.contains(excludeFields, field.getName())\n&& (field.getName().indexOf('$') == -1)\n&& (useTransients || !Modifier.isTransient(field.getModifiers()))\n&& (!Modifier.isStatic(field.getModifiers()))) {\ntry {\nObject fieldValue = field.get(object);\nbuilder.append(fieldValue);\n} catch (IllegalAccessException e) {\n// this can't happen. Would get a Security exception instead\n// throw a runtime exception in case the impossible happens.\nthrow new InternalError(\"Unexpected IllegalAccessException\");\n}\n}\n}\n} finally {\nunregister(object);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.HashCodeBuilder:reflectionHashCode(IILjava/lang/Object;ZLjava/lang/Class;[Ljava/lang/String;)I",
                                    "method_body": "public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\nboolean testTransients, Class<? super T> reflectUpToClass, String[] excludeFields) {\n\nif (object == null) {\nthrow new IllegalArgumentException(\"The object to build a hash code for must not be null\");\n}\nHashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\nClass<?> clazz = object.getClass();\nreflectionAppend(object, clazz, builder, testTransients, excludeFields);\nwhile (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\nclazz = clazz.getSuperclass();\nreflectionAppend(object, clazz, builder, testTransients, excludeFields);\n}\nreturn builder.toHashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.HashCodeBuilder:reflectionHashCode(Ljava/lang/Object;)I",
                                    "method_body": "public static int reflectionHashCode(Object object) {\nreturn reflectionHashCode(17, 37, object, false, null, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.HashCodeBuilder:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\ngetRegistry().add(new IDKey(value));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.HashCodeBuilder:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\ngetRegistry().remove(new IDKey(value));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.HashCodeBuilder:append(Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/HashCodeBuilder;",
                                    "method_body": "public HashCodeBuilder append(Object object) {\nif (object == null) {\niTotal = iTotal * iConstant;\n\n} else {\nif(object.getClass().isArray()) {\n// 'Switch' on type of array, to dispatch to the correct handler\n// This handles multi dimensional arrays\nif (object instanceof long[]) {\nappend((long[]) object);\n} else if (object instanceof int[]) {\nappend((int[]) object);\n} else if (object instanceof short[]) {\nappend((short[]) object);\n} else if (object instanceof char[]) {\nappend((char[]) object);\n} else if (object instanceof byte[]) {\nappend((byte[]) object);\n} else if (object instanceof double[]) {\nappend((double[]) object);\n} else if (object instanceof float[]) {\nappend((float[]) object);\n} else if (object instanceof boolean[]) {\nappend((boolean[]) object);\n} else {\n// Not an array of primitives\nappend((Object[]) object);\n}\n} else {\niTotal = iTotal * iConstant + object.hashCode();\n}\n}\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.HashCodeBuilder:toHashCode()I",
                                    "method_body": "public int toHashCode() {\nreturn iTotal;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.HashCodeBuilder$1:initialValue()Ljava/util/Set;",
                                    "method_body": "protected Set<IDKey> initialValue() {\nreturn new HashSet<IDKey>();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.IDKey:<init>(Ljava/lang/Object;)V",
                                    "method_body": "public IDKey(Object _value) {\n// This is the Object hashcode\nid = System.identityHashCode(_value);\n// There have been some cases (LANG-459) that return the\n// same identity hash code for different objects.  So\n// the value is also added to disambiguate these cases.\nvalue = _value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.IDKey:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.IDKey:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object other) {\nif (!(other instanceof IDKey)) {\nreturn false;\n}\nIDKey idKey = (IDKey) other;\nif (id != idKey.id) {\nreturn false;\n}\n// Note that identity equals is used.\nreturn value == idKey.value;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 33,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.ClassUtilsTest.testToClass_object",
                            "test_body": "902: public void testToClass_object() {\n903: assertNull(ClassUtils.toClass(null));\n904: 905: assertSame(ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.toClass(ArrayUtils.EMPTY_OBJECT_ARRAY));\n906: 907: assertTrue(Arrays.equals(new Class[] { String.class, Integer.class, Double.class },\n908: ClassUtils.toClass(new Object[] { \"Test\", 1, 99d })));\n909: 910: assertTrue(Arrays.equals(new Class[] { String.class, null, Double.class },\n911: ClassUtils.toClass(new Object[] { \"Test\", null, 99d })));\n912: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.ClassUtils:<clinit>()V",
                                    "method_body": "public static final char PACKAGE_SEPARATOR_CHAR = '.';\n\n/**\n* <p>The package separator String: <code>\"&#x2e;\"</code>.</p>\n*/\npublic static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR);\n\n/**\n* <p>The inner class separator character: <code>'$' == {@value}</code>.</p>"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ClassUtils:addAbbreviation(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "private static void addAbbreviation(String primitive, String abbreviation) {\nabbreviationMap.put(primitive, abbreviation);\nreverseAbbreviationMap.put(abbreviation, primitive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ClassUtils:toClass([Ljava/lang/Object;)[Ljava/lang/Class;",
                                    "method_body": "public static Class<?>[] toClass(Object[] array) {\nif (array == null) {\nreturn null;\n} else if (array.length == 0) {\nreturn ArrayUtils.EMPTY_CLASS_ARRAY;\n}\nClass<?>[] classes = new Class[array.length];\nfor (int i = 0; i < array.length; i++) {\nclasses[i] = array[i].getClass();\n}\nreturn classes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:<clinit>()V",
                                    "method_body": "public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n/**\n* An empty immutable <code>Class</code> array.\n*/\npublic static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n/**\n* An empty immutable <code>String</code> array.\n*/\npublic static final String[] EMPTY_STRING_ARRAY = new String[0];\n/**\n* An empty immutable <code>long</code> array.\n*/\npublic static final long[] EMPTY_LONG_ARRAY = new long[0];\n/**\n* An empty immutable <code>Long</code> array.\n*/\npublic static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];\n/**\n* An empty immutable <code>int</code> array.\n*/\npublic static final int[] EMPTY_INT_ARRAY = new int[0];\n/**\n* An empty immutable <code>Integer</code> array.\n*/\npublic static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n/**\n* An empty immutable <code>short</code> array.\n*/\npublic static final short[] EMPTY_SHORT_ARRAY = new short[0];\n/**\n* An empty immutable <code>Short</code> array.\n*/\npublic static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0];\n/**\n* An empty immutable <code>byte</code> array.\n*/\npublic static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n/**\n* An empty immutable <code>Byte</code> array.\n*/\npublic static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];\n/**\n* An empty immutable <code>double</code> array.\n*/\npublic static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n/**\n* An empty immutable <code>Double</code> array.\n*/\npublic static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0];\n/**\n* An empty immutable <code>float</code> array.\n*/\npublic static final float[] EMPTY_FLOAT_ARRAY = new float[0];\n/**\n* An empty immutable <code>Float</code> array.\n*/\npublic static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0];\n/**\n* An empty immutable <code>boolean</code> array.\n*/\npublic static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];\n/**\n* An empty immutable <code>Boolean</code> array.\n*/\npublic static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];\n/**\n* An empty immutable <code>char</code> array.\n*/\npublic static final char[] EMPTY_CHAR_ARRAY = new char[0];\n/**\n* An empty immutable <code>Character</code> array.\n*/\npublic static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n\n/**\n* The index value when an element is not found in a list or array: <code>-1</code>.\n* This value is returned by methods in this class and can also be used in comparisons with values returned by\n* various method from {@link java.util.List}."
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 34,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testReflectionArrayArrayCycle",
                            "test_body": "402: public void testReflectionArrayArrayCycle() throws Exception {\n403: Object[][] objects = new Object[2][2];\n404: objects[0][0] = objects;\n405: objects[0][1] = objects;\n406: objects[1][0] = objects;\n407: objects[1][1] = objects;\n408: String basicToString = this.toBaseString(objects);\n409: assertEquals(\n410: basicToString\n411: + \"[{{\"\n412: + basicToString\n413: + \",\"\n414: + basicToString\n415: + \"},{\"\n416: + basicToString\n417: + \",\"\n418: + basicToString\n419: + \"}}]\",\n420: ToStringBuilder.reflectionToString(objects));\n421: this.validateNullToStringStyleRegistry();\n422: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils:<clinit>()V",
                                    "method_body": "public static final Null NULL = new Null();\n\n/**\n* <p><code>ObjectUtils</code> instances should NOT be constructed in\n* standard programming. Instead, the class should be used as\n* <code>ObjectUtils.defaultIfNull(\"a\",\"b\");</code>.</p>\n*\n* <p>This constructor is public to permit tools that require a JavaBean instance\n* to operate.</p>\n*/\npublic ObjectUtils() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils:identityToString(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public static void identityToString(StringBuffer buffer, Object object) {\nif (object == null) {\nthrow new NullPointerException(\"Cannot get the toString of a null identity\");\n}\nbuffer.append(object.getClass().getName())\n.append('@')\n.append(Integer.toHexString(System.identityHashCode(object)));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils$Null:<init>()V",
                                    "method_body": "Null() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object) {\nreturn ReflectionToStringBuilder.toString(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendCyclicObject(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendCyclicObject(StringBuffer buffer, String fieldName, Object value) {\nObjectUtils.identityToString(buffer, value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;Ljava/lang/Class;ZZ)V",
                                    "method_body": "public <T> ReflectionToStringBuilder(\nT object, ToStringStyle style, StringBuffer buffer,\nClass<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\nsuper(object, style, buffer);\nthis.setUpToClass(reflectUpToClass);\nthis.setAppendTransients(outputTransients);\nthis.setAppendStatics(outputStatics);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object) {\nreturn toString(object, null, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String toString(\nT object, ToStringStyle style, boolean outputTransients,\nboolean outputStatics, Class<? super T> reflectUpToClass) {\nreturn new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:appendFieldsIn(Ljava/lang/Class;)V",
                                    "method_body": "protected void appendFieldsIn(Class<?> clazz) {\nif (clazz.isArray()) {\nthis.reflectionAppendArray(this.getObject());\nreturn;\n}\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nString fieldName = field.getName();\nif (this.accept(field)) {\ntry {\n// Warning: Field.get(Object) creates wrappers objects\n// for primitive types.\nObject fieldValue = this.getValue(field);\nthis.append(fieldName, fieldValue);\n} catch (IllegalAccessException ex) {\n//this can't happen. Would get a Security exception\n// instead\n//throw a runtime exception in case the impossible\n// happens.\nthrow new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getUpToClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getUpToClass() {\nreturn this.upToClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendStatics(Z)V",
                                    "method_body": "public void setAppendStatics(boolean appendStatics) {\nthis.appendStatics = appendStatics;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendTransients(Z)V",
                                    "method_body": "public void setAppendTransients(boolean appendTransients) {\nthis.appendTransients = appendTransients;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setUpToClass(Ljava/lang/Class;)V",
                                    "method_body": "public void setUpToClass(Class<?> clazz) {\nif (clazz != null) {\nObject object = getObject();\nif (object != null && clazz.isInstance(object) == false) {\nthrow new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n}\n}\nthis.upToClass = clazz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nreturn this.getStyle().getNullText();\n}\nClass<?> clazz = this.getObject().getClass();\nthis.appendFieldsIn(clazz);\nwhile (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\nclazz = clazz.getSuperclass();\nthis.appendFieldsIn(clazz);\n}\nreturn super.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public ToStringStyle getStyle() {\nreturn style;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:reflectionAppendArrayDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\nbuffer.append(arrayStart);\nint length = Array.getLength(array);\nfor (int i = 0; i < length; i++) {\nObject item = Array.get(array, i);\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nif (item == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, item, arrayContentDetail);\n}\n}\nbuffer.append(arrayEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:reflectionAppendArray(Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ReflectionToStringBuilder;",
                                    "method_body": "public ReflectionToStringBuilder reflectionAppendArray(Object array) {\nthis.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;[Ljava/lang/Object;)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, Object[] array) {\nbuffer.append(arrayStart);\nfor (int i = 0; i < array.length; i++) {\nObject item = array[i];\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nif (item == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, item, arrayContentDetail);\n}\n}\nbuffer.append(arrayEnd);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testReflectionLongArrayArray",
                            "test_body": "237: public void testReflectionLongArrayArray() {\n238: long[][] array = new long[][] { { 1, 2 }, null, { 5 } };\n239: String baseStr = this.toBaseString(array);\n240: assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n241: array = null;\n242: assertReflectionArray(\"<null>\", array);\n243: this.validateNullToStringStyleRegistry();\n244: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object) {\nreturn ReflectionToStringBuilder.toString(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;Ljava/lang/Class;ZZ)V",
                                    "method_body": "public <T> ReflectionToStringBuilder(\nT object, ToStringStyle style, StringBuffer buffer,\nClass<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\nsuper(object, style, buffer);\nthis.setUpToClass(reflectUpToClass);\nthis.setAppendTransients(outputTransients);\nthis.setAppendStatics(outputStatics);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object) {\nreturn toString(object, null, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String toString(\nT object, ToStringStyle style, boolean outputTransients,\nboolean outputStatics, Class<? super T> reflectUpToClass) {\nreturn new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:appendFieldsIn(Ljava/lang/Class;)V",
                                    "method_body": "protected void appendFieldsIn(Class<?> clazz) {\nif (clazz.isArray()) {\nthis.reflectionAppendArray(this.getObject());\nreturn;\n}\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nString fieldName = field.getName();\nif (this.accept(field)) {\ntry {\n// Warning: Field.get(Object) creates wrappers objects\n// for primitive types.\nObject fieldValue = this.getValue(field);\nthis.append(fieldName, fieldValue);\n} catch (IllegalAccessException ex) {\n//this can't happen. Would get a Security exception\n// instead\n//throw a runtime exception in case the impossible\n// happens.\nthrow new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getUpToClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getUpToClass() {\nreturn this.upToClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendStatics(Z)V",
                                    "method_body": "public void setAppendStatics(boolean appendStatics) {\nthis.appendStatics = appendStatics;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendTransients(Z)V",
                                    "method_body": "public void setAppendTransients(boolean appendTransients) {\nthis.appendTransients = appendTransients;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setUpToClass(Ljava/lang/Class;)V",
                                    "method_body": "public void setUpToClass(Class<?> clazz) {\nif (clazz != null) {\nObject object = getObject();\nif (object != null && clazz.isInstance(object) == false) {\nthrow new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n}\n}\nthis.upToClass = clazz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nreturn this.getStyle().getNullText();\n}\nClass<?> clazz = this.getObject().getClass();\nthis.appendFieldsIn(clazz);\nwhile (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\nclazz = clazz.getSuperclass();\nthis.appendFieldsIn(clazz);\n}\nreturn super.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public ToStringStyle getStyle() {\nreturn style;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:reflectionAppendArrayDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\nbuffer.append(arrayStart);\nint length = Array.getLength(array);\nfor (int i = 0; i < length; i++) {\nObject item = Array.get(array, i);\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nif (item == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, item, arrayContentDetail);\n}\n}\nbuffer.append(arrayEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendNullText(Ljava/lang/StringBuffer;Ljava/lang/String;)V",
                                    "method_body": "protected void appendNullText(StringBuffer buffer, String fieldName) {\nbuffer.append(nullText);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:reflectionAppendArray(Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ReflectionToStringBuilder;",
                                    "method_body": "public ReflectionToStringBuilder reflectionAppendArray(Object array) {\nthis.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;J)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, long value) {\nbuffer.append(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;[J)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, long[] array) {\nbuffer.append(arrayStart);\nfor (int i = 0; i < array.length; i++) {\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nappendDetail(buffer, fieldName, array[i]);\n}\nbuffer.append(arrayEnd);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testSimpleReflectionObjectCycle",
                            "test_body": "506: public void testSimpleReflectionObjectCycle() throws Exception {\n507: SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture();\n508: simple.o = simple;\n509: assertEquals(this.toBaseString(simple) + \"[o=\" + this.toBaseString(simple) + \"]\", simple.toString());\n510: this.validateNullToStringStyleRegistry();\n511: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils:<clinit>()V",
                                    "method_body": "public static final Null NULL = new Null();\n\n/**\n* <p><code>ObjectUtils</code> instances should NOT be constructed in\n* standard programming. Instead, the class should be used as\n* <code>ObjectUtils.defaultIfNull(\"a\",\"b\");</code>.</p>\n*\n* <p>This constructor is public to permit tools that require a JavaBean instance\n* to operate.</p>\n*/\npublic ObjectUtils() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils:identityToString(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public static void identityToString(StringBuffer buffer, Object object) {\nif (object == null) {\nthrow new NullPointerException(\"Cannot get the toString of a null identity\");\n}\nbuffer.append(object.getClass().getName())\n.append('@')\n.append(Integer.toHexString(System.identityHashCode(object)));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils$Null:<init>()V",
                                    "method_body": "Null() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object) {\nreturn ReflectionToStringBuilder.toString(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:append(Ljava/lang/String;Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ToStringBuilder;",
                                    "method_body": "public ToStringBuilder append(String fieldName, Object obj) {\nstyle.append(buffer, fieldName, obj, null);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:append(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Boolean;)V",
                                    "method_body": "public void append(StringBuffer buffer, String fieldName, Object value, Boolean fullDetail) {\nappendFieldStart(buffer, fieldName);\n\nif (value == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, value, isFullDetail(fullDetail));\n}\n\nappendFieldEnd(buffer, fieldName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendCyclicObject(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendCyclicObject(StringBuffer buffer, String fieldName, Object value) {\nObjectUtils.identityToString(buffer, value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendFieldSeparator(StringBuffer buffer) {\nbuffer.append(fieldSeparator);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendFieldStart(Ljava/lang/StringBuffer;Ljava/lang/String;)V",
                                    "method_body": "protected void appendFieldStart(StringBuffer buffer, String fieldName) {\nif (useFieldNames && fieldName != null) {\nbuffer.append(fieldName);\nbuffer.append(fieldNameValueSeparator);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendFieldEnd(Ljava/lang/StringBuffer;Ljava/lang/String;)V",
                                    "method_body": "protected void appendFieldEnd(StringBuffer buffer, String fieldName) {\nappendFieldSeparator(buffer);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isFullDetail(Ljava/lang/Boolean;)Z",
                                    "method_body": "protected boolean isFullDetail(Boolean fullDetailRequest) {\nif (fullDetailRequest == null) {\nreturn defaultFullDetail;\n}\nreturn fullDetailRequest.booleanValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;Ljava/lang/Class;ZZ)V",
                                    "method_body": "public <T> ReflectionToStringBuilder(\nT object, ToStringStyle style, StringBuffer buffer,\nClass<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\nsuper(object, style, buffer);\nthis.setUpToClass(reflectUpToClass);\nthis.setAppendTransients(outputTransients);\nthis.setAppendStatics(outputStatics);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object) {\nreturn toString(object, null, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String toString(\nT object, ToStringStyle style, boolean outputTransients,\nboolean outputStatics, Class<? super T> reflectUpToClass) {\nreturn new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:accept(Ljava/lang/reflect/Field;)Z",
                                    "method_body": "protected boolean accept(Field field) {\nif (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\n// Reject field from inner class.\nreturn false;\n}\nif (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {\n// Reject transient fields.\nreturn false;\n}\nif (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {\n// Reject static fields.\nreturn false;\n}\nif (this.excludeFieldNames != null\n&& Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\n// Reject fields from the getExcludeFieldNames list.\nreturn false;\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:appendFieldsIn(Ljava/lang/Class;)V",
                                    "method_body": "protected void appendFieldsIn(Class<?> clazz) {\nif (clazz.isArray()) {\nthis.reflectionAppendArray(this.getObject());\nreturn;\n}\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nString fieldName = field.getName();\nif (this.accept(field)) {\ntry {\n// Warning: Field.get(Object) creates wrappers objects\n// for primitive types.\nObject fieldValue = this.getValue(field);\nthis.append(fieldName, fieldValue);\n} catch (IllegalAccessException ex) {\n//this can't happen. Would get a Security exception\n// instead\n//throw a runtime exception in case the impossible\n// happens.\nthrow new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getUpToClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getUpToClass() {\nreturn this.upToClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getValue(Ljava/lang/reflect/Field;)Ljava/lang/Object;",
                                    "method_body": "protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\nreturn field.get(this.getObject());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendStatics(Z)V",
                                    "method_body": "public void setAppendStatics(boolean appendStatics) {\nthis.appendStatics = appendStatics;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendTransients(Z)V",
                                    "method_body": "public void setAppendTransients(boolean appendTransients) {\nthis.appendTransients = appendTransients;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setUpToClass(Ljava/lang/Class;)V",
                                    "method_body": "public void setUpToClass(Class<?> clazz) {\nif (clazz != null) {\nObject object = getObject();\nif (object != null && clazz.isInstance(object) == false) {\nthrow new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n}\n}\nthis.upToClass = clazz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nreturn this.getStyle().getNullText();\n}\nClass<?> clazz = this.getObject().getClass();\nthis.appendFieldsIn(clazz);\nwhile (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\nclazz = clazz.getSuperclass();\nthis.appendFieldsIn(clazz);\n}\nreturn super.toString();\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testReflectionDoubleArrayArray",
                            "test_body": "282: public void testReflectionDoubleArrayArray() {\n283: double[][] array = new double[][] { { 1.0, 2.29686 }, null, { Double.NaN } };\n284: String baseStr = this.toBaseString(array);\n285: assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", ToStringBuilder.reflectionToString(array));\n286: array = null;\n287: assertReflectionArray(\"<null>\", array);\n288: this.validateNullToStringStyleRegistry();\n289: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object) {\nreturn ReflectionToStringBuilder.toString(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;Ljava/lang/Class;ZZ)V",
                                    "method_body": "public <T> ReflectionToStringBuilder(\nT object, ToStringStyle style, StringBuffer buffer,\nClass<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\nsuper(object, style, buffer);\nthis.setUpToClass(reflectUpToClass);\nthis.setAppendTransients(outputTransients);\nthis.setAppendStatics(outputStatics);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object) {\nreturn toString(object, null, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String toString(\nT object, ToStringStyle style, boolean outputTransients,\nboolean outputStatics, Class<? super T> reflectUpToClass) {\nreturn new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:appendFieldsIn(Ljava/lang/Class;)V",
                                    "method_body": "protected void appendFieldsIn(Class<?> clazz) {\nif (clazz.isArray()) {\nthis.reflectionAppendArray(this.getObject());\nreturn;\n}\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nString fieldName = field.getName();\nif (this.accept(field)) {\ntry {\n// Warning: Field.get(Object) creates wrappers objects\n// for primitive types.\nObject fieldValue = this.getValue(field);\nthis.append(fieldName, fieldValue);\n} catch (IllegalAccessException ex) {\n//this can't happen. Would get a Security exception\n// instead\n//throw a runtime exception in case the impossible\n// happens.\nthrow new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getUpToClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getUpToClass() {\nreturn this.upToClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendStatics(Z)V",
                                    "method_body": "public void setAppendStatics(boolean appendStatics) {\nthis.appendStatics = appendStatics;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendTransients(Z)V",
                                    "method_body": "public void setAppendTransients(boolean appendTransients) {\nthis.appendTransients = appendTransients;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setUpToClass(Ljava/lang/Class;)V",
                                    "method_body": "public void setUpToClass(Class<?> clazz) {\nif (clazz != null) {\nObject object = getObject();\nif (object != null && clazz.isInstance(object) == false) {\nthrow new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n}\n}\nthis.upToClass = clazz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nreturn this.getStyle().getNullText();\n}\nClass<?> clazz = this.getObject().getClass();\nthis.appendFieldsIn(clazz);\nwhile (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\nclazz = clazz.getSuperclass();\nthis.appendFieldsIn(clazz);\n}\nreturn super.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public ToStringStyle getStyle() {\nreturn style;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:reflectionAppendArrayDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\nbuffer.append(arrayStart);\nint length = Array.getLength(array);\nfor (int i = 0; i < length; i++) {\nObject item = Array.get(array, i);\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nif (item == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, item, arrayContentDetail);\n}\n}\nbuffer.append(arrayEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendNullText(Ljava/lang/StringBuffer;Ljava/lang/String;)V",
                                    "method_body": "protected void appendNullText(StringBuffer buffer, String fieldName) {\nbuffer.append(nullText);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:reflectionAppendArray(Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ReflectionToStringBuilder;",
                                    "method_body": "public ReflectionToStringBuilder reflectionAppendArray(Object array) {\nthis.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;D)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, double value) {\nbuffer.append(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;[D)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, double[] array) {\nbuffer.append(arrayStart);\nfor (int i = 0; i < array.length; i++) {\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nappendDetail(buffer, fieldName, array[i]);\n}\nbuffer.append(arrayEnd);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testReflectionFloatArray",
                            "test_body": "207: public void testReflectionFloatArray() {\n208: float[] array = new float[] { 1.0f, 2.9876f, -3.00001f, 4.3f };\n209: String baseStr = this.toBaseString(array);\n210: assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", ToStringBuilder.reflectionToString(array));\n211: array = null;\n212: assertReflectionArray(\"<null>\", array);\n213: this.validateNullToStringStyleRegistry();\n214: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object) {\nreturn ReflectionToStringBuilder.toString(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {\nbuffer.append(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;Ljava/lang/Class;ZZ)V",
                                    "method_body": "public <T> ReflectionToStringBuilder(\nT object, ToStringStyle style, StringBuffer buffer,\nClass<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\nsuper(object, style, buffer);\nthis.setUpToClass(reflectUpToClass);\nthis.setAppendTransients(outputTransients);\nthis.setAppendStatics(outputStatics);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object) {\nreturn toString(object, null, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String toString(\nT object, ToStringStyle style, boolean outputTransients,\nboolean outputStatics, Class<? super T> reflectUpToClass) {\nreturn new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:appendFieldsIn(Ljava/lang/Class;)V",
                                    "method_body": "protected void appendFieldsIn(Class<?> clazz) {\nif (clazz.isArray()) {\nthis.reflectionAppendArray(this.getObject());\nreturn;\n}\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nString fieldName = field.getName();\nif (this.accept(field)) {\ntry {\n// Warning: Field.get(Object) creates wrappers objects\n// for primitive types.\nObject fieldValue = this.getValue(field);\nthis.append(fieldName, fieldValue);\n} catch (IllegalAccessException ex) {\n//this can't happen. Would get a Security exception\n// instead\n//throw a runtime exception in case the impossible\n// happens.\nthrow new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getUpToClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getUpToClass() {\nreturn this.upToClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendStatics(Z)V",
                                    "method_body": "public void setAppendStatics(boolean appendStatics) {\nthis.appendStatics = appendStatics;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendTransients(Z)V",
                                    "method_body": "public void setAppendTransients(boolean appendTransients) {\nthis.appendTransients = appendTransients;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setUpToClass(Ljava/lang/Class;)V",
                                    "method_body": "public void setUpToClass(Class<?> clazz) {\nif (clazz != null) {\nObject object = getObject();\nif (object != null && clazz.isInstance(object) == false) {\nthrow new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n}\n}\nthis.upToClass = clazz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nreturn this.getStyle().getNullText();\n}\nClass<?> clazz = this.getObject().getClass();\nthis.appendFieldsIn(clazz);\nwhile (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\nclazz = clazz.getSuperclass();\nthis.appendFieldsIn(clazz);\n}\nreturn super.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public ToStringStyle getStyle() {\nreturn style;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:reflectionAppendArrayDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\nbuffer.append(arrayStart);\nint length = Array.getLength(array);\nfor (int i = 0; i < length; i++) {\nObject item = Array.get(array, i);\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nif (item == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, item, arrayContentDetail);\n}\n}\nbuffer.append(arrayEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:reflectionAppendArray(Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ReflectionToStringBuilder;",
                                    "method_body": "public ReflectionToStringBuilder reflectionAppendArray(Object array) {\nthis.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\nreturn this;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testReflectionArrayCycleLevel2",
                            "test_body": "388: public void testReflectionArrayCycleLevel2() throws Exception {\n389: Object[] objects = new Object[1];\n390: Object[] objectsLevel2 = new Object[1];\n391: objects[0] = objectsLevel2;\n392: objectsLevel2[0] = objects;\n393: assertEquals(\n394: this.toBaseString(objects) + \"[{{\" + this.toBaseString(objects) + \"}}]\",\n395: ToStringBuilder.reflectionToString(objects));\n396: assertEquals(\n397: this.toBaseString(objectsLevel2) + \"[{{\" + this.toBaseString(objectsLevel2) + \"}}]\",\n398: ToStringBuilder.reflectionToString(objectsLevel2));\n399: this.validateNullToStringStyleRegistry();\n400: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils:<clinit>()V",
                                    "method_body": "public static final Null NULL = new Null();\n\n/**\n* <p><code>ObjectUtils</code> instances should NOT be constructed in\n* standard programming. Instead, the class should be used as\n* <code>ObjectUtils.defaultIfNull(\"a\",\"b\");</code>.</p>\n*\n* <p>This constructor is public to permit tools that require a JavaBean instance\n* to operate.</p>\n*/\npublic ObjectUtils() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils:identityToString(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public static void identityToString(StringBuffer buffer, Object object) {\nif (object == null) {\nthrow new NullPointerException(\"Cannot get the toString of a null identity\");\n}\nbuffer.append(object.getClass().getName())\n.append('@')\n.append(Integer.toHexString(System.identityHashCode(object)));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils$Null:<init>()V",
                                    "method_body": "Null() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object) {\nreturn ReflectionToStringBuilder.toString(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendCyclicObject(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendCyclicObject(StringBuffer buffer, String fieldName, Object value) {\nObjectUtils.identityToString(buffer, value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;Ljava/lang/Class;ZZ)V",
                                    "method_body": "public <T> ReflectionToStringBuilder(\nT object, ToStringStyle style, StringBuffer buffer,\nClass<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\nsuper(object, style, buffer);\nthis.setUpToClass(reflectUpToClass);\nthis.setAppendTransients(outputTransients);\nthis.setAppendStatics(outputStatics);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object) {\nreturn toString(object, null, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String toString(\nT object, ToStringStyle style, boolean outputTransients,\nboolean outputStatics, Class<? super T> reflectUpToClass) {\nreturn new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:appendFieldsIn(Ljava/lang/Class;)V",
                                    "method_body": "protected void appendFieldsIn(Class<?> clazz) {\nif (clazz.isArray()) {\nthis.reflectionAppendArray(this.getObject());\nreturn;\n}\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nString fieldName = field.getName();\nif (this.accept(field)) {\ntry {\n// Warning: Field.get(Object) creates wrappers objects\n// for primitive types.\nObject fieldValue = this.getValue(field);\nthis.append(fieldName, fieldValue);\n} catch (IllegalAccessException ex) {\n//this can't happen. Would get a Security exception\n// instead\n//throw a runtime exception in case the impossible\n// happens.\nthrow new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getUpToClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getUpToClass() {\nreturn this.upToClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendStatics(Z)V",
                                    "method_body": "public void setAppendStatics(boolean appendStatics) {\nthis.appendStatics = appendStatics;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendTransients(Z)V",
                                    "method_body": "public void setAppendTransients(boolean appendTransients) {\nthis.appendTransients = appendTransients;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setUpToClass(Ljava/lang/Class;)V",
                                    "method_body": "public void setUpToClass(Class<?> clazz) {\nif (clazz != null) {\nObject object = getObject();\nif (object != null && clazz.isInstance(object) == false) {\nthrow new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n}\n}\nthis.upToClass = clazz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nreturn this.getStyle().getNullText();\n}\nClass<?> clazz = this.getObject().getClass();\nthis.appendFieldsIn(clazz);\nwhile (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\nclazz = clazz.getSuperclass();\nthis.appendFieldsIn(clazz);\n}\nreturn super.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public ToStringStyle getStyle() {\nreturn style;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:reflectionAppendArrayDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\nbuffer.append(arrayStart);\nint length = Array.getLength(array);\nfor (int i = 0; i < length; i++) {\nObject item = Array.get(array, i);\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nif (item == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, item, arrayContentDetail);\n}\n}\nbuffer.append(arrayEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:reflectionAppendArray(Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ReflectionToStringBuilder;",
                                    "method_body": "public ReflectionToStringBuilder reflectionAppendArray(Object array) {\nthis.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;[Ljava/lang/Object;)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, Object[] array) {\nbuffer.append(arrayStart);\nfor (int i = 0; i < array.length; i++) {\nObject item = array[i];\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nif (item == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, item, arrayContentDetail);\n}\n}\nbuffer.append(arrayEnd);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testReflectionyteArray",
                            "test_body": "180: public void testReflectionyteArray() {\n181: byte[] array = new byte[] { 1, 2, -3, 4 };\n182: String baseStr = this.toBaseString(array);\n183: assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n184: array = null;\n185: assertReflectionArray(\"<null>\", array);\n186: this.validateNullToStringStyleRegistry();\n187: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object) {\nreturn ReflectionToStringBuilder.toString(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {\nbuffer.append(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;Ljava/lang/Class;ZZ)V",
                                    "method_body": "public <T> ReflectionToStringBuilder(\nT object, ToStringStyle style, StringBuffer buffer,\nClass<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\nsuper(object, style, buffer);\nthis.setUpToClass(reflectUpToClass);\nthis.setAppendTransients(outputTransients);\nthis.setAppendStatics(outputStatics);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object) {\nreturn toString(object, null, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String toString(\nT object, ToStringStyle style, boolean outputTransients,\nboolean outputStatics, Class<? super T> reflectUpToClass) {\nreturn new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:appendFieldsIn(Ljava/lang/Class;)V",
                                    "method_body": "protected void appendFieldsIn(Class<?> clazz) {\nif (clazz.isArray()) {\nthis.reflectionAppendArray(this.getObject());\nreturn;\n}\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nString fieldName = field.getName();\nif (this.accept(field)) {\ntry {\n// Warning: Field.get(Object) creates wrappers objects\n// for primitive types.\nObject fieldValue = this.getValue(field);\nthis.append(fieldName, fieldValue);\n} catch (IllegalAccessException ex) {\n//this can't happen. Would get a Security exception\n// instead\n//throw a runtime exception in case the impossible\n// happens.\nthrow new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getUpToClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getUpToClass() {\nreturn this.upToClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendStatics(Z)V",
                                    "method_body": "public void setAppendStatics(boolean appendStatics) {\nthis.appendStatics = appendStatics;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendTransients(Z)V",
                                    "method_body": "public void setAppendTransients(boolean appendTransients) {\nthis.appendTransients = appendTransients;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setUpToClass(Ljava/lang/Class;)V",
                                    "method_body": "public void setUpToClass(Class<?> clazz) {\nif (clazz != null) {\nObject object = getObject();\nif (object != null && clazz.isInstance(object) == false) {\nthrow new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n}\n}\nthis.upToClass = clazz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nreturn this.getStyle().getNullText();\n}\nClass<?> clazz = this.getObject().getClass();\nthis.appendFieldsIn(clazz);\nwhile (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\nclazz = clazz.getSuperclass();\nthis.appendFieldsIn(clazz);\n}\nreturn super.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public ToStringStyle getStyle() {\nreturn style;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:reflectionAppendArrayDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\nbuffer.append(arrayStart);\nint length = Array.getLength(array);\nfor (int i = 0; i < length; i++) {\nObject item = Array.get(array, i);\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nif (item == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, item, arrayContentDetail);\n}\n}\nbuffer.append(arrayEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:reflectionAppendArray(Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ReflectionToStringBuilder;",
                                    "method_body": "public ReflectionToStringBuilder reflectionAppendArray(Object array) {\nthis.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\nreturn this;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testReflectionByteArrayArray",
                            "test_body": "264: public void testReflectionByteArrayArray() {\n265: byte[][] array = new byte[][] { { 1, 2 }, null, { 5 } };\n266: String baseStr = this.toBaseString(array);\n267: assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n268: array = null;\n269: assertReflectionArray(\"<null>\", array);\n270: this.validateNullToStringStyleRegistry();\n271: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object) {\nreturn ReflectionToStringBuilder.toString(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;Ljava/lang/Class;ZZ)V",
                                    "method_body": "public <T> ReflectionToStringBuilder(\nT object, ToStringStyle style, StringBuffer buffer,\nClass<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\nsuper(object, style, buffer);\nthis.setUpToClass(reflectUpToClass);\nthis.setAppendTransients(outputTransients);\nthis.setAppendStatics(outputStatics);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object) {\nreturn toString(object, null, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String toString(\nT object, ToStringStyle style, boolean outputTransients,\nboolean outputStatics, Class<? super T> reflectUpToClass) {\nreturn new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:appendFieldsIn(Ljava/lang/Class;)V",
                                    "method_body": "protected void appendFieldsIn(Class<?> clazz) {\nif (clazz.isArray()) {\nthis.reflectionAppendArray(this.getObject());\nreturn;\n}\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nString fieldName = field.getName();\nif (this.accept(field)) {\ntry {\n// Warning: Field.get(Object) creates wrappers objects\n// for primitive types.\nObject fieldValue = this.getValue(field);\nthis.append(fieldName, fieldValue);\n} catch (IllegalAccessException ex) {\n//this can't happen. Would get a Security exception\n// instead\n//throw a runtime exception in case the impossible\n// happens.\nthrow new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getUpToClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getUpToClass() {\nreturn this.upToClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendStatics(Z)V",
                                    "method_body": "public void setAppendStatics(boolean appendStatics) {\nthis.appendStatics = appendStatics;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendTransients(Z)V",
                                    "method_body": "public void setAppendTransients(boolean appendTransients) {\nthis.appendTransients = appendTransients;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setUpToClass(Ljava/lang/Class;)V",
                                    "method_body": "public void setUpToClass(Class<?> clazz) {\nif (clazz != null) {\nObject object = getObject();\nif (object != null && clazz.isInstance(object) == false) {\nthrow new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n}\n}\nthis.upToClass = clazz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nreturn this.getStyle().getNullText();\n}\nClass<?> clazz = this.getObject().getClass();\nthis.appendFieldsIn(clazz);\nwhile (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\nclazz = clazz.getSuperclass();\nthis.appendFieldsIn(clazz);\n}\nreturn super.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public ToStringStyle getStyle() {\nreturn style;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:reflectionAppendArrayDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\nbuffer.append(arrayStart);\nint length = Array.getLength(array);\nfor (int i = 0; i < length; i++) {\nObject item = Array.get(array, i);\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nif (item == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, item, arrayContentDetail);\n}\n}\nbuffer.append(arrayEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendNullText(Ljava/lang/StringBuffer;Ljava/lang/String;)V",
                                    "method_body": "protected void appendNullText(StringBuffer buffer, String fieldName) {\nbuffer.append(nullText);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:reflectionAppendArray(Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ReflectionToStringBuilder;",
                                    "method_body": "public ReflectionToStringBuilder reflectionAppendArray(Object array) {\nthis.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;B)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, byte value) {\nbuffer.append(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;[B)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\nbuffer.append(arrayStart);\nfor (int i = 0; i < array.length; i++) {\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nappendDetail(buffer, fieldName, array[i]);\n}\nbuffer.append(arrayEnd);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testReflectionBooleanArray",
                            "test_body": "216: public void testReflectionBooleanArray() {\n217: boolean[] array = new boolean[] { true, false, false };\n218: String baseStr = this.toBaseString(array);\n219: assertEquals(baseStr + \"[{true,false,false}]\", ToStringBuilder.reflectionToString(array));\n220: array = null;\n221: assertReflectionArray(\"<null>\", array);\n222: this.validateNullToStringStyleRegistry();\n223: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object) {\nreturn ReflectionToStringBuilder.toString(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {\nbuffer.append(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;Ljava/lang/Class;ZZ)V",
                                    "method_body": "public <T> ReflectionToStringBuilder(\nT object, ToStringStyle style, StringBuffer buffer,\nClass<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\nsuper(object, style, buffer);\nthis.setUpToClass(reflectUpToClass);\nthis.setAppendTransients(outputTransients);\nthis.setAppendStatics(outputStatics);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object) {\nreturn toString(object, null, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String toString(\nT object, ToStringStyle style, boolean outputTransients,\nboolean outputStatics, Class<? super T> reflectUpToClass) {\nreturn new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:appendFieldsIn(Ljava/lang/Class;)V",
                                    "method_body": "protected void appendFieldsIn(Class<?> clazz) {\nif (clazz.isArray()) {\nthis.reflectionAppendArray(this.getObject());\nreturn;\n}\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nString fieldName = field.getName();\nif (this.accept(field)) {\ntry {\n// Warning: Field.get(Object) creates wrappers objects\n// for primitive types.\nObject fieldValue = this.getValue(field);\nthis.append(fieldName, fieldValue);\n} catch (IllegalAccessException ex) {\n//this can't happen. Would get a Security exception\n// instead\n//throw a runtime exception in case the impossible\n// happens.\nthrow new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getUpToClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getUpToClass() {\nreturn this.upToClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendStatics(Z)V",
                                    "method_body": "public void setAppendStatics(boolean appendStatics) {\nthis.appendStatics = appendStatics;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendTransients(Z)V",
                                    "method_body": "public void setAppendTransients(boolean appendTransients) {\nthis.appendTransients = appendTransients;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setUpToClass(Ljava/lang/Class;)V",
                                    "method_body": "public void setUpToClass(Class<?> clazz) {\nif (clazz != null) {\nObject object = getObject();\nif (object != null && clazz.isInstance(object) == false) {\nthrow new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n}\n}\nthis.upToClass = clazz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nreturn this.getStyle().getNullText();\n}\nClass<?> clazz = this.getObject().getClass();\nthis.appendFieldsIn(clazz);\nwhile (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\nclazz = clazz.getSuperclass();\nthis.appendFieldsIn(clazz);\n}\nreturn super.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public ToStringStyle getStyle() {\nreturn style;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:reflectionAppendArrayDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\nbuffer.append(arrayStart);\nint length = Array.getLength(array);\nfor (int i = 0; i < length; i++) {\nObject item = Array.get(array, i);\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nif (item == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, item, arrayContentDetail);\n}\n}\nbuffer.append(arrayEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:reflectionAppendArray(Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ReflectionToStringBuilder;",
                                    "method_body": "public ReflectionToStringBuilder reflectionAppendArray(Object array) {\nthis.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\nreturn this;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testReflectionCharArrayArray",
                            "test_body": "273: public void testReflectionCharArrayArray() {\n274: char[][] array = new char[][] { { 'A', 'B' }, null, { 'p' } };\n275: String baseStr = this.toBaseString(array);\n276: assertEquals(baseStr + \"[{{A,B},<null>,{p}}]\", ToStringBuilder.reflectionToString(array));\n277: array = null;\n278: assertReflectionArray(\"<null>\", array);\n279: this.validateNullToStringStyleRegistry();\n280: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object) {\nreturn ReflectionToStringBuilder.toString(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;Ljava/lang/Class;ZZ)V",
                                    "method_body": "public <T> ReflectionToStringBuilder(\nT object, ToStringStyle style, StringBuffer buffer,\nClass<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\nsuper(object, style, buffer);\nthis.setUpToClass(reflectUpToClass);\nthis.setAppendTransients(outputTransients);\nthis.setAppendStatics(outputStatics);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object) {\nreturn toString(object, null, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String toString(\nT object, ToStringStyle style, boolean outputTransients,\nboolean outputStatics, Class<? super T> reflectUpToClass) {\nreturn new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:appendFieldsIn(Ljava/lang/Class;)V",
                                    "method_body": "protected void appendFieldsIn(Class<?> clazz) {\nif (clazz.isArray()) {\nthis.reflectionAppendArray(this.getObject());\nreturn;\n}\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nString fieldName = field.getName();\nif (this.accept(field)) {\ntry {\n// Warning: Field.get(Object) creates wrappers objects\n// for primitive types.\nObject fieldValue = this.getValue(field);\nthis.append(fieldName, fieldValue);\n} catch (IllegalAccessException ex) {\n//this can't happen. Would get a Security exception\n// instead\n//throw a runtime exception in case the impossible\n// happens.\nthrow new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getUpToClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getUpToClass() {\nreturn this.upToClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendStatics(Z)V",
                                    "method_body": "public void setAppendStatics(boolean appendStatics) {\nthis.appendStatics = appendStatics;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendTransients(Z)V",
                                    "method_body": "public void setAppendTransients(boolean appendTransients) {\nthis.appendTransients = appendTransients;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setUpToClass(Ljava/lang/Class;)V",
                                    "method_body": "public void setUpToClass(Class<?> clazz) {\nif (clazz != null) {\nObject object = getObject();\nif (object != null && clazz.isInstance(object) == false) {\nthrow new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n}\n}\nthis.upToClass = clazz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nreturn this.getStyle().getNullText();\n}\nClass<?> clazz = this.getObject().getClass();\nthis.appendFieldsIn(clazz);\nwhile (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\nclazz = clazz.getSuperclass();\nthis.appendFieldsIn(clazz);\n}\nreturn super.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public ToStringStyle getStyle() {\nreturn style;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:reflectionAppendArrayDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\nbuffer.append(arrayStart);\nint length = Array.getLength(array);\nfor (int i = 0; i < length; i++) {\nObject item = Array.get(array, i);\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nif (item == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, item, arrayContentDetail);\n}\n}\nbuffer.append(arrayEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendNullText(Ljava/lang/StringBuffer;Ljava/lang/String;)V",
                                    "method_body": "protected void appendNullText(StringBuffer buffer, String fieldName) {\nbuffer.append(nullText);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:reflectionAppendArray(Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ReflectionToStringBuilder;",
                                    "method_body": "public ReflectionToStringBuilder reflectionAppendArray(Object array) {\nthis.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;C)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, char value) {\nbuffer.append(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;[C)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, char[] array) {\nbuffer.append(arrayStart);\nfor (int i = 0; i < array.length; i++) {\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nappendDetail(buffer, fieldName, array[i]);\n}\nbuffer.append(arrayEnd);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testReflectionArrayAndObjectCycle",
                            "test_body": "559: public void testReflectionArrayAndObjectCycle() throws Exception {\n560: Object[] objects = new Object[1];\n561: SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture(objects);\n562: objects[0] = simple;\n563: assertEquals(\n564: this.toBaseString(objects)\n565: + \"[{\"\n566: + this.toBaseString(simple)\n567: + \"[o=\"\n568: + this.toBaseString(objects)\n569: + \"]\"\n570: + \"}]\",\n571: ToStringBuilder.reflectionToString(objects));\n572: assertEquals(\n573: this.toBaseString(simple)\n574: + \"[o={\"\n575: + this.toBaseString(simple)\n576: + \"}]\",\n577: ToStringBuilder.reflectionToString(simple));\n578: this.validateNullToStringStyleRegistry();\n579: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils:<clinit>()V",
                                    "method_body": "public static final Null NULL = new Null();\n\n/**\n* <p><code>ObjectUtils</code> instances should NOT be constructed in\n* standard programming. Instead, the class should be used as\n* <code>ObjectUtils.defaultIfNull(\"a\",\"b\");</code>.</p>\n*\n* <p>This constructor is public to permit tools that require a JavaBean instance\n* to operate.</p>\n*/\npublic ObjectUtils() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils:identityToString(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public static void identityToString(StringBuffer buffer, Object object) {\nif (object == null) {\nthrow new NullPointerException(\"Cannot get the toString of a null identity\");\n}\nbuffer.append(object.getClass().getName())\n.append('@')\n.append(Integer.toHexString(System.identityHashCode(object)));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils$Null:<init>()V",
                                    "method_body": "Null() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object) {\nreturn ReflectionToStringBuilder.toString(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:append(Ljava/lang/String;Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ToStringBuilder;",
                                    "method_body": "public ToStringBuilder append(String fieldName, Object obj) {\nstyle.append(buffer, fieldName, obj, null);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:append(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Boolean;)V",
                                    "method_body": "public void append(StringBuffer buffer, String fieldName, Object value, Boolean fullDetail) {\nappendFieldStart(buffer, fieldName);\n\nif (value == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, value, isFullDetail(fullDetail));\n}\n\nappendFieldEnd(buffer, fieldName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendCyclicObject(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendCyclicObject(StringBuffer buffer, String fieldName, Object value) {\nObjectUtils.identityToString(buffer, value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {\nbuffer.append(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendFieldSeparator(StringBuffer buffer) {\nbuffer.append(fieldSeparator);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendFieldStart(Ljava/lang/StringBuffer;Ljava/lang/String;)V",
                                    "method_body": "protected void appendFieldStart(StringBuffer buffer, String fieldName) {\nif (useFieldNames && fieldName != null) {\nbuffer.append(fieldName);\nbuffer.append(fieldNameValueSeparator);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendFieldEnd(Ljava/lang/StringBuffer;Ljava/lang/String;)V",
                                    "method_body": "protected void appendFieldEnd(StringBuffer buffer, String fieldName) {\nappendFieldSeparator(buffer);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isFullDetail(Ljava/lang/Boolean;)Z",
                                    "method_body": "protected boolean isFullDetail(Boolean fullDetailRequest) {\nif (fullDetailRequest == null) {\nreturn defaultFullDetail;\n}\nreturn fullDetailRequest.booleanValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;Ljava/lang/Class;ZZ)V",
                                    "method_body": "public <T> ReflectionToStringBuilder(\nT object, ToStringStyle style, StringBuffer buffer,\nClass<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\nsuper(object, style, buffer);\nthis.setUpToClass(reflectUpToClass);\nthis.setAppendTransients(outputTransients);\nthis.setAppendStatics(outputStatics);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object) {\nreturn toString(object, null, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String toString(\nT object, ToStringStyle style, boolean outputTransients,\nboolean outputStatics, Class<? super T> reflectUpToClass) {\nreturn new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:accept(Ljava/lang/reflect/Field;)Z",
                                    "method_body": "protected boolean accept(Field field) {\nif (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\n// Reject field from inner class.\nreturn false;\n}\nif (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {\n// Reject transient fields.\nreturn false;\n}\nif (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {\n// Reject static fields.\nreturn false;\n}\nif (this.excludeFieldNames != null\n&& Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\n// Reject fields from the getExcludeFieldNames list.\nreturn false;\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:appendFieldsIn(Ljava/lang/Class;)V",
                                    "method_body": "protected void appendFieldsIn(Class<?> clazz) {\nif (clazz.isArray()) {\nthis.reflectionAppendArray(this.getObject());\nreturn;\n}\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nString fieldName = field.getName();\nif (this.accept(field)) {\ntry {\n// Warning: Field.get(Object) creates wrappers objects\n// for primitive types.\nObject fieldValue = this.getValue(field);\nthis.append(fieldName, fieldValue);\n} catch (IllegalAccessException ex) {\n//this can't happen. Would get a Security exception\n// instead\n//throw a runtime exception in case the impossible\n// happens.\nthrow new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getUpToClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getUpToClass() {\nreturn this.upToClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getValue(Ljava/lang/reflect/Field;)Ljava/lang/Object;",
                                    "method_body": "protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\nreturn field.get(this.getObject());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendStatics(Z)V",
                                    "method_body": "public void setAppendStatics(boolean appendStatics) {\nthis.appendStatics = appendStatics;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendTransients(Z)V",
                                    "method_body": "public void setAppendTransients(boolean appendTransients) {\nthis.appendTransients = appendTransients;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setUpToClass(Ljava/lang/Class;)V",
                                    "method_body": "public void setUpToClass(Class<?> clazz) {\nif (clazz != null) {\nObject object = getObject();\nif (object != null && clazz.isInstance(object) == false) {\nthrow new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n}\n}\nthis.upToClass = clazz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nreturn this.getStyle().getNullText();\n}\nClass<?> clazz = this.getObject().getClass();\nthis.appendFieldsIn(clazz);\nwhile (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\nclazz = clazz.getSuperclass();\nthis.appendFieldsIn(clazz);\n}\nreturn super.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public ToStringStyle getStyle() {\nreturn style;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:reflectionAppendArrayDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\nbuffer.append(arrayStart);\nint length = Array.getLength(array);\nfor (int i = 0; i < length; i++) {\nObject item = Array.get(array, i);\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nif (item == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, item, arrayContentDetail);\n}\n}\nbuffer.append(arrayEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:reflectionAppendArray(Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ReflectionToStringBuilder;",
                                    "method_body": "public ReflectionToStringBuilder reflectionAppendArray(Object array) {\nthis.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;[Ljava/lang/Object;)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, Object[] array) {\nbuffer.append(arrayStart);\nfor (int i = 0; i < array.length; i++) {\nObject item = array[i];\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nif (item == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, item, arrayContentDetail);\n}\n}\nbuffer.append(arrayEnd);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testReflectionDoubleArray",
                            "test_body": "198: public void testReflectionDoubleArray() {\n199: double[] array = new double[] { 1.0, 2.9876, -3.00001, 4.3 };\n200: String baseStr = this.toBaseString(array);\n201: assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", ToStringBuilder.reflectionToString(array));\n202: array = null;\n203: assertReflectionArray(\"<null>\", array);\n204: this.validateNullToStringStyleRegistry();\n205: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object) {\nreturn ReflectionToStringBuilder.toString(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {\nbuffer.append(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;Ljava/lang/Class;ZZ)V",
                                    "method_body": "public <T> ReflectionToStringBuilder(\nT object, ToStringStyle style, StringBuffer buffer,\nClass<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\nsuper(object, style, buffer);\nthis.setUpToClass(reflectUpToClass);\nthis.setAppendTransients(outputTransients);\nthis.setAppendStatics(outputStatics);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object) {\nreturn toString(object, null, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String toString(\nT object, ToStringStyle style, boolean outputTransients,\nboolean outputStatics, Class<? super T> reflectUpToClass) {\nreturn new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:appendFieldsIn(Ljava/lang/Class;)V",
                                    "method_body": "protected void appendFieldsIn(Class<?> clazz) {\nif (clazz.isArray()) {\nthis.reflectionAppendArray(this.getObject());\nreturn;\n}\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nString fieldName = field.getName();\nif (this.accept(field)) {\ntry {\n// Warning: Field.get(Object) creates wrappers objects\n// for primitive types.\nObject fieldValue = this.getValue(field);\nthis.append(fieldName, fieldValue);\n} catch (IllegalAccessException ex) {\n//this can't happen. Would get a Security exception\n// instead\n//throw a runtime exception in case the impossible\n// happens.\nthrow new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getUpToClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getUpToClass() {\nreturn this.upToClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendStatics(Z)V",
                                    "method_body": "public void setAppendStatics(boolean appendStatics) {\nthis.appendStatics = appendStatics;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendTransients(Z)V",
                                    "method_body": "public void setAppendTransients(boolean appendTransients) {\nthis.appendTransients = appendTransients;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setUpToClass(Ljava/lang/Class;)V",
                                    "method_body": "public void setUpToClass(Class<?> clazz) {\nif (clazz != null) {\nObject object = getObject();\nif (object != null && clazz.isInstance(object) == false) {\nthrow new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n}\n}\nthis.upToClass = clazz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nreturn this.getStyle().getNullText();\n}\nClass<?> clazz = this.getObject().getClass();\nthis.appendFieldsIn(clazz);\nwhile (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\nclazz = clazz.getSuperclass();\nthis.appendFieldsIn(clazz);\n}\nreturn super.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public ToStringStyle getStyle() {\nreturn style;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:reflectionAppendArrayDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\nbuffer.append(arrayStart);\nint length = Array.getLength(array);\nfor (int i = 0; i < length; i++) {\nObject item = Array.get(array, i);\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nif (item == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, item, arrayContentDetail);\n}\n}\nbuffer.append(arrayEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:reflectionAppendArray(Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ReflectionToStringBuilder;",
                                    "method_body": "public ReflectionToStringBuilder reflectionAppendArray(Object array) {\nthis.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\nreturn this;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testSelfInstanceVarReflectionObjectCycle",
                            "test_body": "518: public void testSelfInstanceVarReflectionObjectCycle() throws Exception {\n519: SelfInstanceVarReflectionTestFixture test = new SelfInstanceVarReflectionTestFixture();\n520: assertEquals(this.toBaseString(test) + \"[typeIsSelf=\" + this.toBaseString(test) + \"]\", test.toString());\n521: this.validateNullToStringStyleRegistry();\n522: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils:<clinit>()V",
                                    "method_body": "public static final Null NULL = new Null();\n\n/**\n* <p><code>ObjectUtils</code> instances should NOT be constructed in\n* standard programming. Instead, the class should be used as\n* <code>ObjectUtils.defaultIfNull(\"a\",\"b\");</code>.</p>\n*\n* <p>This constructor is public to permit tools that require a JavaBean instance\n* to operate.</p>\n*/\npublic ObjectUtils() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils:identityToString(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public static void identityToString(StringBuffer buffer, Object object) {\nif (object == null) {\nthrow new NullPointerException(\"Cannot get the toString of a null identity\");\n}\nbuffer.append(object.getClass().getName())\n.append('@')\n.append(Integer.toHexString(System.identityHashCode(object)));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils$Null:<init>()V",
                                    "method_body": "Null() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object) {\nreturn ReflectionToStringBuilder.toString(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:append(Ljava/lang/String;Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ToStringBuilder;",
                                    "method_body": "public ToStringBuilder append(String fieldName, Object obj) {\nstyle.append(buffer, fieldName, obj, null);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:append(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Boolean;)V",
                                    "method_body": "public void append(StringBuffer buffer, String fieldName, Object value, Boolean fullDetail) {\nappendFieldStart(buffer, fieldName);\n\nif (value == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, value, isFullDetail(fullDetail));\n}\n\nappendFieldEnd(buffer, fieldName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendCyclicObject(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendCyclicObject(StringBuffer buffer, String fieldName, Object value) {\nObjectUtils.identityToString(buffer, value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendFieldSeparator(StringBuffer buffer) {\nbuffer.append(fieldSeparator);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendFieldStart(Ljava/lang/StringBuffer;Ljava/lang/String;)V",
                                    "method_body": "protected void appendFieldStart(StringBuffer buffer, String fieldName) {\nif (useFieldNames && fieldName != null) {\nbuffer.append(fieldName);\nbuffer.append(fieldNameValueSeparator);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendFieldEnd(Ljava/lang/StringBuffer;Ljava/lang/String;)V",
                                    "method_body": "protected void appendFieldEnd(StringBuffer buffer, String fieldName) {\nappendFieldSeparator(buffer);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isFullDetail(Ljava/lang/Boolean;)Z",
                                    "method_body": "protected boolean isFullDetail(Boolean fullDetailRequest) {\nif (fullDetailRequest == null) {\nreturn defaultFullDetail;\n}\nreturn fullDetailRequest.booleanValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;Ljava/lang/Class;ZZ)V",
                                    "method_body": "public <T> ReflectionToStringBuilder(\nT object, ToStringStyle style, StringBuffer buffer,\nClass<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\nsuper(object, style, buffer);\nthis.setUpToClass(reflectUpToClass);\nthis.setAppendTransients(outputTransients);\nthis.setAppendStatics(outputStatics);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object) {\nreturn toString(object, null, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String toString(\nT object, ToStringStyle style, boolean outputTransients,\nboolean outputStatics, Class<? super T> reflectUpToClass) {\nreturn new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:accept(Ljava/lang/reflect/Field;)Z",
                                    "method_body": "protected boolean accept(Field field) {\nif (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\n// Reject field from inner class.\nreturn false;\n}\nif (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {\n// Reject transient fields.\nreturn false;\n}\nif (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {\n// Reject static fields.\nreturn false;\n}\nif (this.excludeFieldNames != null\n&& Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\n// Reject fields from the getExcludeFieldNames list.\nreturn false;\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:appendFieldsIn(Ljava/lang/Class;)V",
                                    "method_body": "protected void appendFieldsIn(Class<?> clazz) {\nif (clazz.isArray()) {\nthis.reflectionAppendArray(this.getObject());\nreturn;\n}\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nString fieldName = field.getName();\nif (this.accept(field)) {\ntry {\n// Warning: Field.get(Object) creates wrappers objects\n// for primitive types.\nObject fieldValue = this.getValue(field);\nthis.append(fieldName, fieldValue);\n} catch (IllegalAccessException ex) {\n//this can't happen. Would get a Security exception\n// instead\n//throw a runtime exception in case the impossible\n// happens.\nthrow new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getUpToClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getUpToClass() {\nreturn this.upToClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getValue(Ljava/lang/reflect/Field;)Ljava/lang/Object;",
                                    "method_body": "protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\nreturn field.get(this.getObject());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendStatics(Z)V",
                                    "method_body": "public void setAppendStatics(boolean appendStatics) {\nthis.appendStatics = appendStatics;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendTransients(Z)V",
                                    "method_body": "public void setAppendTransients(boolean appendTransients) {\nthis.appendTransients = appendTransients;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setUpToClass(Ljava/lang/Class;)V",
                                    "method_body": "public void setUpToClass(Class<?> clazz) {\nif (clazz != null) {\nObject object = getObject();\nif (object != null && clazz.isInstance(object) == false) {\nthrow new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n}\n}\nthis.upToClass = clazz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nreturn this.getStyle().getNullText();\n}\nClass<?> clazz = this.getObject().getClass();\nthis.appendFieldsIn(clazz);\nwhile (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\nclazz = clazz.getSuperclass();\nthis.appendFieldsIn(clazz);\n}\nreturn super.toString();\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testObjectCycle",
                            "test_body": "829: public void testObjectCycle() {\n830: ObjectCycle a = new ObjectCycle();\n831: ObjectCycle b = new ObjectCycle();\n832: a.obj = b;\n833: b.obj = a;\n834: 835: String expected = toBaseString(a) + \"[\" + toBaseString(b) + \"[\" + toBaseString(a) + \"]]\";\n836: assertEquals(expected, a.toString());\n837: validateNullToStringStyleRegistry();\n838: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils:<clinit>()V",
                                    "method_body": "public static final Null NULL = new Null();\n\n/**\n* <p><code>ObjectUtils</code> instances should NOT be constructed in\n* standard programming. Instead, the class should be used as\n* <code>ObjectUtils.defaultIfNull(\"a\",\"b\");</code>.</p>\n*\n* <p>This constructor is public to permit tools that require a JavaBean instance\n* to operate.</p>\n*/\npublic ObjectUtils() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils:identityToString(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public static void identityToString(StringBuffer buffer, Object object) {\nif (object == null) {\nthrow new NullPointerException(\"Cannot get the toString of a null identity\");\n}\nbuffer.append(object.getClass().getName())\n.append('@')\n.append(Integer.toHexString(System.identityHashCode(object)));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils$Null:<init>()V",
                                    "method_body": "Null() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:append(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Boolean;)V",
                                    "method_body": "public void append(StringBuffer buffer, String fieldName, Object value, Boolean fullDetail) {\nappendFieldStart(buffer, fieldName);\n\nif (value == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, value, isFullDetail(fullDetail));\n}\n\nappendFieldEnd(buffer, fieldName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendCyclicObject(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendCyclicObject(StringBuffer buffer, String fieldName, Object value) {\nObjectUtils.identityToString(buffer, value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {\nbuffer.append(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendFieldSeparator(StringBuffer buffer) {\nbuffer.append(fieldSeparator);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendFieldStart(Ljava/lang/StringBuffer;Ljava/lang/String;)V",
                                    "method_body": "protected void appendFieldStart(StringBuffer buffer, String fieldName) {\nif (useFieldNames && fieldName != null) {\nbuffer.append(fieldName);\nbuffer.append(fieldNameValueSeparator);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendFieldEnd(Ljava/lang/StringBuffer;Ljava/lang/String;)V",
                                    "method_body": "protected void appendFieldEnd(StringBuffer buffer, String fieldName) {\nappendFieldSeparator(buffer);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isFullDetail(Ljava/lang/Boolean;)Z",
                                    "method_body": "protected boolean isFullDetail(Boolean fullDetailRequest) {\nif (fullDetailRequest == null) {\nreturn defaultFullDetail;\n}\nreturn fullDetailRequest.booleanValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;)V",
                                    "method_body": "public ToStringBuilder(Object object) {\nthis(object, null, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:append(Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ToStringBuilder;",
                                    "method_body": "public ToStringBuilder append(Object obj) {\nstyle.append(buffer, null, obj, null);\nreturn this;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testReflectionShortArray",
                            "test_body": "171: public void testReflectionShortArray() {\n172: short[] array = new short[] { 1, 2, -3, 4 };\n173: String baseStr = this.toBaseString(array);\n174: assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n175: array = null;\n176: assertReflectionArray(\"<null>\", array);\n177: this.validateNullToStringStyleRegistry();\n178: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object) {\nreturn ReflectionToStringBuilder.toString(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {\nbuffer.append(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;Ljava/lang/Class;ZZ)V",
                                    "method_body": "public <T> ReflectionToStringBuilder(\nT object, ToStringStyle style, StringBuffer buffer,\nClass<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\nsuper(object, style, buffer);\nthis.setUpToClass(reflectUpToClass);\nthis.setAppendTransients(outputTransients);\nthis.setAppendStatics(outputStatics);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object) {\nreturn toString(object, null, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String toString(\nT object, ToStringStyle style, boolean outputTransients,\nboolean outputStatics, Class<? super T> reflectUpToClass) {\nreturn new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:appendFieldsIn(Ljava/lang/Class;)V",
                                    "method_body": "protected void appendFieldsIn(Class<?> clazz) {\nif (clazz.isArray()) {\nthis.reflectionAppendArray(this.getObject());\nreturn;\n}\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nString fieldName = field.getName();\nif (this.accept(field)) {\ntry {\n// Warning: Field.get(Object) creates wrappers objects\n// for primitive types.\nObject fieldValue = this.getValue(field);\nthis.append(fieldName, fieldValue);\n} catch (IllegalAccessException ex) {\n//this can't happen. Would get a Security exception\n// instead\n//throw a runtime exception in case the impossible\n// happens.\nthrow new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getUpToClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getUpToClass() {\nreturn this.upToClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendStatics(Z)V",
                                    "method_body": "public void setAppendStatics(boolean appendStatics) {\nthis.appendStatics = appendStatics;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendTransients(Z)V",
                                    "method_body": "public void setAppendTransients(boolean appendTransients) {\nthis.appendTransients = appendTransients;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setUpToClass(Ljava/lang/Class;)V",
                                    "method_body": "public void setUpToClass(Class<?> clazz) {\nif (clazz != null) {\nObject object = getObject();\nif (object != null && clazz.isInstance(object) == false) {\nthrow new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n}\n}\nthis.upToClass = clazz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nreturn this.getStyle().getNullText();\n}\nClass<?> clazz = this.getObject().getClass();\nthis.appendFieldsIn(clazz);\nwhile (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\nclazz = clazz.getSuperclass();\nthis.appendFieldsIn(clazz);\n}\nreturn super.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public ToStringStyle getStyle() {\nreturn style;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:reflectionAppendArrayDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\nbuffer.append(arrayStart);\nint length = Array.getLength(array);\nfor (int i = 0; i < length; i++) {\nObject item = Array.get(array, i);\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nif (item == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, item, arrayContentDetail);\n}\n}\nbuffer.append(arrayEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:reflectionAppendArray(Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ReflectionToStringBuilder;",
                                    "method_body": "public ReflectionToStringBuilder reflectionAppendArray(Object array) {\nthis.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\nreturn this;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testReflectionLongArray",
                            "test_body": "153: public void testReflectionLongArray() {\n154: long[] array = new long[] { 1, 2, -3, 4 };\n155: String baseStr = this.toBaseString(array);\n156: assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n157: array = null;\n158: assertReflectionArray(\"<null>\", array);\n159: this.validateNullToStringStyleRegistry();\n160: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object) {\nreturn ReflectionToStringBuilder.toString(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {\nbuffer.append(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;Ljava/lang/Class;ZZ)V",
                                    "method_body": "public <T> ReflectionToStringBuilder(\nT object, ToStringStyle style, StringBuffer buffer,\nClass<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\nsuper(object, style, buffer);\nthis.setUpToClass(reflectUpToClass);\nthis.setAppendTransients(outputTransients);\nthis.setAppendStatics(outputStatics);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object) {\nreturn toString(object, null, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String toString(\nT object, ToStringStyle style, boolean outputTransients,\nboolean outputStatics, Class<? super T> reflectUpToClass) {\nreturn new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:appendFieldsIn(Ljava/lang/Class;)V",
                                    "method_body": "protected void appendFieldsIn(Class<?> clazz) {\nif (clazz.isArray()) {\nthis.reflectionAppendArray(this.getObject());\nreturn;\n}\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nString fieldName = field.getName();\nif (this.accept(field)) {\ntry {\n// Warning: Field.get(Object) creates wrappers objects\n// for primitive types.\nObject fieldValue = this.getValue(field);\nthis.append(fieldName, fieldValue);\n} catch (IllegalAccessException ex) {\n//this can't happen. Would get a Security exception\n// instead\n//throw a runtime exception in case the impossible\n// happens.\nthrow new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getUpToClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getUpToClass() {\nreturn this.upToClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendStatics(Z)V",
                                    "method_body": "public void setAppendStatics(boolean appendStatics) {\nthis.appendStatics = appendStatics;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendTransients(Z)V",
                                    "method_body": "public void setAppendTransients(boolean appendTransients) {\nthis.appendTransients = appendTransients;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setUpToClass(Ljava/lang/Class;)V",
                                    "method_body": "public void setUpToClass(Class<?> clazz) {\nif (clazz != null) {\nObject object = getObject();\nif (object != null && clazz.isInstance(object) == false) {\nthrow new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n}\n}\nthis.upToClass = clazz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nreturn this.getStyle().getNullText();\n}\nClass<?> clazz = this.getObject().getClass();\nthis.appendFieldsIn(clazz);\nwhile (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\nclazz = clazz.getSuperclass();\nthis.appendFieldsIn(clazz);\n}\nreturn super.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public ToStringStyle getStyle() {\nreturn style;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:reflectionAppendArrayDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\nbuffer.append(arrayStart);\nint length = Array.getLength(array);\nfor (int i = 0; i < length; i++) {\nObject item = Array.get(array, i);\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nif (item == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, item, arrayContentDetail);\n}\n}\nbuffer.append(arrayEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:reflectionAppendArray(Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ReflectionToStringBuilder;",
                                    "method_body": "public ReflectionToStringBuilder reflectionAppendArray(Object array) {\nthis.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\nreturn this;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testSelfInstanceTwoVarsReflectionObjectCycle",
                            "test_body": "530: public void testSelfInstanceTwoVarsReflectionObjectCycle() throws Exception {\n531: SelfInstanceTwoVarsReflectionTestFixture test = new SelfInstanceTwoVarsReflectionTestFixture();\n532: assertEquals(this.toBaseString(test) + \"[typeIsSelf=\" + this.toBaseString(test) + \",otherType=\" + test.getOtherType().toString() + \"]\", test.toString());\n533: this.validateNullToStringStyleRegistry();\n534: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils:<clinit>()V",
                                    "method_body": "public static final Null NULL = new Null();\n\n/**\n* <p><code>ObjectUtils</code> instances should NOT be constructed in\n* standard programming. Instead, the class should be used as\n* <code>ObjectUtils.defaultIfNull(\"a\",\"b\");</code>.</p>\n*\n* <p>This constructor is public to permit tools that require a JavaBean instance\n* to operate.</p>\n*/\npublic ObjectUtils() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils:identityToString(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public static void identityToString(StringBuffer buffer, Object object) {\nif (object == null) {\nthrow new NullPointerException(\"Cannot get the toString of a null identity\");\n}\nbuffer.append(object.getClass().getName())\n.append('@')\n.append(Integer.toHexString(System.identityHashCode(object)));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils$Null:<init>()V",
                                    "method_body": "Null() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object) {\nreturn ReflectionToStringBuilder.toString(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:append(Ljava/lang/String;Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ToStringBuilder;",
                                    "method_body": "public ToStringBuilder append(String fieldName, Object obj) {\nstyle.append(buffer, fieldName, obj, null);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:append(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Boolean;)V",
                                    "method_body": "public void append(StringBuffer buffer, String fieldName, Object value, Boolean fullDetail) {\nappendFieldStart(buffer, fieldName);\n\nif (value == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, value, isFullDetail(fullDetail));\n}\n\nappendFieldEnd(buffer, fieldName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendCyclicObject(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendCyclicObject(StringBuffer buffer, String fieldName, Object value) {\nObjectUtils.identityToString(buffer, value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {\nbuffer.append(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendFieldSeparator(StringBuffer buffer) {\nbuffer.append(fieldSeparator);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendFieldStart(Ljava/lang/StringBuffer;Ljava/lang/String;)V",
                                    "method_body": "protected void appendFieldStart(StringBuffer buffer, String fieldName) {\nif (useFieldNames && fieldName != null) {\nbuffer.append(fieldName);\nbuffer.append(fieldNameValueSeparator);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendFieldEnd(Ljava/lang/StringBuffer;Ljava/lang/String;)V",
                                    "method_body": "protected void appendFieldEnd(StringBuffer buffer, String fieldName) {\nappendFieldSeparator(buffer);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isFullDetail(Ljava/lang/Boolean;)Z",
                                    "method_body": "protected boolean isFullDetail(Boolean fullDetailRequest) {\nif (fullDetailRequest == null) {\nreturn defaultFullDetail;\n}\nreturn fullDetailRequest.booleanValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;Ljava/lang/Class;ZZ)V",
                                    "method_body": "public <T> ReflectionToStringBuilder(\nT object, ToStringStyle style, StringBuffer buffer,\nClass<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\nsuper(object, style, buffer);\nthis.setUpToClass(reflectUpToClass);\nthis.setAppendTransients(outputTransients);\nthis.setAppendStatics(outputStatics);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object) {\nreturn toString(object, null, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String toString(\nT object, ToStringStyle style, boolean outputTransients,\nboolean outputStatics, Class<? super T> reflectUpToClass) {\nreturn new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:accept(Ljava/lang/reflect/Field;)Z",
                                    "method_body": "protected boolean accept(Field field) {\nif (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\n// Reject field from inner class.\nreturn false;\n}\nif (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {\n// Reject transient fields.\nreturn false;\n}\nif (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {\n// Reject static fields.\nreturn false;\n}\nif (this.excludeFieldNames != null\n&& Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\n// Reject fields from the getExcludeFieldNames list.\nreturn false;\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:appendFieldsIn(Ljava/lang/Class;)V",
                                    "method_body": "protected void appendFieldsIn(Class<?> clazz) {\nif (clazz.isArray()) {\nthis.reflectionAppendArray(this.getObject());\nreturn;\n}\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nString fieldName = field.getName();\nif (this.accept(field)) {\ntry {\n// Warning: Field.get(Object) creates wrappers objects\n// for primitive types.\nObject fieldValue = this.getValue(field);\nthis.append(fieldName, fieldValue);\n} catch (IllegalAccessException ex) {\n//this can't happen. Would get a Security exception\n// instead\n//throw a runtime exception in case the impossible\n// happens.\nthrow new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getUpToClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getUpToClass() {\nreturn this.upToClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getValue(Ljava/lang/reflect/Field;)Ljava/lang/Object;",
                                    "method_body": "protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\nreturn field.get(this.getObject());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendStatics(Z)V",
                                    "method_body": "public void setAppendStatics(boolean appendStatics) {\nthis.appendStatics = appendStatics;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendTransients(Z)V",
                                    "method_body": "public void setAppendTransients(boolean appendTransients) {\nthis.appendTransients = appendTransients;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setUpToClass(Ljava/lang/Class;)V",
                                    "method_body": "public void setUpToClass(Class<?> clazz) {\nif (clazz != null) {\nObject object = getObject();\nif (object != null && clazz.isInstance(object) == false) {\nthrow new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n}\n}\nthis.upToClass = clazz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nreturn this.getStyle().getNullText();\n}\nClass<?> clazz = this.getObject().getClass();\nthis.appendFieldsIn(clazz);\nwhile (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\nclazz = clazz.getSuperclass();\nthis.appendFieldsIn(clazz);\n}\nreturn super.toString();\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testReflectionIntArrayArray",
                            "test_body": "246: public void testReflectionIntArrayArray() {\n247: int[][] array = new int[][] { { 1, 2 }, null, { 5 } };\n248: String baseStr = this.toBaseString(array);\n249: assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n250: array = null;\n251: assertReflectionArray(\"<null>\", array);\n252: this.validateNullToStringStyleRegistry();\n253: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object) {\nreturn ReflectionToStringBuilder.toString(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;Ljava/lang/Class;ZZ)V",
                                    "method_body": "public <T> ReflectionToStringBuilder(\nT object, ToStringStyle style, StringBuffer buffer,\nClass<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\nsuper(object, style, buffer);\nthis.setUpToClass(reflectUpToClass);\nthis.setAppendTransients(outputTransients);\nthis.setAppendStatics(outputStatics);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object) {\nreturn toString(object, null, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String toString(\nT object, ToStringStyle style, boolean outputTransients,\nboolean outputStatics, Class<? super T> reflectUpToClass) {\nreturn new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:appendFieldsIn(Ljava/lang/Class;)V",
                                    "method_body": "protected void appendFieldsIn(Class<?> clazz) {\nif (clazz.isArray()) {\nthis.reflectionAppendArray(this.getObject());\nreturn;\n}\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nString fieldName = field.getName();\nif (this.accept(field)) {\ntry {\n// Warning: Field.get(Object) creates wrappers objects\n// for primitive types.\nObject fieldValue = this.getValue(field);\nthis.append(fieldName, fieldValue);\n} catch (IllegalAccessException ex) {\n//this can't happen. Would get a Security exception\n// instead\n//throw a runtime exception in case the impossible\n// happens.\nthrow new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getUpToClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getUpToClass() {\nreturn this.upToClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendStatics(Z)V",
                                    "method_body": "public void setAppendStatics(boolean appendStatics) {\nthis.appendStatics = appendStatics;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendTransients(Z)V",
                                    "method_body": "public void setAppendTransients(boolean appendTransients) {\nthis.appendTransients = appendTransients;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setUpToClass(Ljava/lang/Class;)V",
                                    "method_body": "public void setUpToClass(Class<?> clazz) {\nif (clazz != null) {\nObject object = getObject();\nif (object != null && clazz.isInstance(object) == false) {\nthrow new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n}\n}\nthis.upToClass = clazz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nreturn this.getStyle().getNullText();\n}\nClass<?> clazz = this.getObject().getClass();\nthis.appendFieldsIn(clazz);\nwhile (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\nclazz = clazz.getSuperclass();\nthis.appendFieldsIn(clazz);\n}\nreturn super.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public ToStringStyle getStyle() {\nreturn style;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;I)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, int value) {\nbuffer.append(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:reflectionAppendArrayDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\nbuffer.append(arrayStart);\nint length = Array.getLength(array);\nfor (int i = 0; i < length; i++) {\nObject item = Array.get(array, i);\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nif (item == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, item, arrayContentDetail);\n}\n}\nbuffer.append(arrayEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;[I)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\nbuffer.append(arrayStart);\nfor (int i = 0; i < array.length; i++) {\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nappendDetail(buffer, fieldName, array[i]);\n}\nbuffer.append(arrayEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendNullText(Ljava/lang/StringBuffer;Ljava/lang/String;)V",
                                    "method_body": "protected void appendNullText(StringBuffer buffer, String fieldName) {\nbuffer.append(nullText);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:reflectionAppendArray(Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ReflectionToStringBuilder;",
                                    "method_body": "public ReflectionToStringBuilder reflectionAppendArray(Object array) {\nthis.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\nreturn this;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testReflectionIntArray",
                            "test_body": "162: public void testReflectionIntArray() {\n163: int[] array = new int[] { 1, 2, -3, 4 };\n164: String baseStr = this.toBaseString(array);\n165: assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n166: array = null;\n167: assertReflectionArray(\"<null>\", array);\n168: this.validateNullToStringStyleRegistry();\n169: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object) {\nreturn ReflectionToStringBuilder.toString(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {\nbuffer.append(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;Ljava/lang/Class;ZZ)V",
                                    "method_body": "public <T> ReflectionToStringBuilder(\nT object, ToStringStyle style, StringBuffer buffer,\nClass<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\nsuper(object, style, buffer);\nthis.setUpToClass(reflectUpToClass);\nthis.setAppendTransients(outputTransients);\nthis.setAppendStatics(outputStatics);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object) {\nreturn toString(object, null, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String toString(\nT object, ToStringStyle style, boolean outputTransients,\nboolean outputStatics, Class<? super T> reflectUpToClass) {\nreturn new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:appendFieldsIn(Ljava/lang/Class;)V",
                                    "method_body": "protected void appendFieldsIn(Class<?> clazz) {\nif (clazz.isArray()) {\nthis.reflectionAppendArray(this.getObject());\nreturn;\n}\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nString fieldName = field.getName();\nif (this.accept(field)) {\ntry {\n// Warning: Field.get(Object) creates wrappers objects\n// for primitive types.\nObject fieldValue = this.getValue(field);\nthis.append(fieldName, fieldValue);\n} catch (IllegalAccessException ex) {\n//this can't happen. Would get a Security exception\n// instead\n//throw a runtime exception in case the impossible\n// happens.\nthrow new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getUpToClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getUpToClass() {\nreturn this.upToClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendStatics(Z)V",
                                    "method_body": "public void setAppendStatics(boolean appendStatics) {\nthis.appendStatics = appendStatics;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendTransients(Z)V",
                                    "method_body": "public void setAppendTransients(boolean appendTransients) {\nthis.appendTransients = appendTransients;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setUpToClass(Ljava/lang/Class;)V",
                                    "method_body": "public void setUpToClass(Class<?> clazz) {\nif (clazz != null) {\nObject object = getObject();\nif (object != null && clazz.isInstance(object) == false) {\nthrow new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n}\n}\nthis.upToClass = clazz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nreturn this.getStyle().getNullText();\n}\nClass<?> clazz = this.getObject().getClass();\nthis.appendFieldsIn(clazz);\nwhile (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\nclazz = clazz.getSuperclass();\nthis.appendFieldsIn(clazz);\n}\nreturn super.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public ToStringStyle getStyle() {\nreturn style;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:reflectionAppendArrayDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\nbuffer.append(arrayStart);\nint length = Array.getLength(array);\nfor (int i = 0; i < length; i++) {\nObject item = Array.get(array, i);\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nif (item == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, item, arrayContentDetail);\n}\n}\nbuffer.append(arrayEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:reflectionAppendArray(Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ReflectionToStringBuilder;",
                                    "method_body": "public ReflectionToStringBuilder reflectionAppendArray(Object array) {\nthis.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\nreturn this;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testReflectionHierarchy",
                            "test_body": "313: public void testReflectionHierarchy() {\n314: ReflectionTestFixtureA baseA = new ReflectionTestFixtureA();\n315: String baseStr = this.toBaseString(baseA);\n316: assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA));\n317: assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null));\n318: assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false));\n319: assertEquals(baseStr + \"[a=a,transientA=t]\", ToStringBuilder.reflectionToString(baseA, null, true));\n320: assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, null));\n321: assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, Object.class));\n322: assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, ReflectionTestFixtureA.class));\n323: 324: ReflectionTestFixtureB baseB = new ReflectionTestFixtureB();\n325: baseStr = this.toBaseString(baseB);\n326: assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB));\n327: assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB));\n328: assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null));\n329: assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false));\n330: assertEquals(baseStr + \"[b=b,transientB=t,a=a,transientA=t]\", ToStringBuilder.reflectionToString(baseB, null, true));\n331: assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, null));\n332: assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, Object.class));\n333: assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureA.class));\n334: assertEquals(baseStr + \"[b=b]\", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureB.class));\n335: this.validateNullToStringStyleRegistry();\n336: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object) {\nreturn ReflectionToStringBuilder.toString(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:append(Ljava/lang/String;Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ToStringBuilder;",
                                    "method_body": "public ToStringBuilder append(String fieldName, Object obj) {\nstyle.append(buffer, fieldName, obj, null);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:append(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Boolean;)V",
                                    "method_body": "public void append(StringBuffer buffer, String fieldName, Object value, Boolean fullDetail) {\nappendFieldStart(buffer, fieldName);\n\nif (value == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, value, isFullDetail(fullDetail));\n}\n\nappendFieldEnd(buffer, fieldName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {\nbuffer.append(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendFieldSeparator(StringBuffer buffer) {\nbuffer.append(fieldSeparator);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendFieldStart(Ljava/lang/StringBuffer;Ljava/lang/String;)V",
                                    "method_body": "protected void appendFieldStart(StringBuffer buffer, String fieldName) {\nif (useFieldNames && fieldName != null) {\nbuffer.append(fieldName);\nbuffer.append(fieldNameValueSeparator);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendFieldEnd(Ljava/lang/StringBuffer;Ljava/lang/String;)V",
                                    "method_body": "protected void appendFieldEnd(StringBuffer buffer, String fieldName) {\nappendFieldSeparator(buffer);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isFullDetail(Ljava/lang/Boolean;)Z",
                                    "method_body": "protected boolean isFullDetail(Boolean fullDetailRequest) {\nif (fullDetailRequest == null) {\nreturn defaultFullDetail;\n}\nreturn fullDetailRequest.booleanValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;Ljava/lang/Class;ZZ)V",
                                    "method_body": "public <T> ReflectionToStringBuilder(\nT object, ToStringStyle style, StringBuffer buffer,\nClass<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\nsuper(object, style, buffer);\nthis.setUpToClass(reflectUpToClass);\nthis.setAppendTransients(outputTransients);\nthis.setAppendStatics(outputStatics);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object) {\nreturn toString(object, null, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String toString(\nT object, ToStringStyle style, boolean outputTransients,\nboolean outputStatics, Class<? super T> reflectUpToClass) {\nreturn new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:accept(Ljava/lang/reflect/Field;)Z",
                                    "method_body": "protected boolean accept(Field field) {\nif (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\n// Reject field from inner class.\nreturn false;\n}\nif (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {\n// Reject transient fields.\nreturn false;\n}\nif (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {\n// Reject static fields.\nreturn false;\n}\nif (this.excludeFieldNames != null\n&& Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\n// Reject fields from the getExcludeFieldNames list.\nreturn false;\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:appendFieldsIn(Ljava/lang/Class;)V",
                                    "method_body": "protected void appendFieldsIn(Class<?> clazz) {\nif (clazz.isArray()) {\nthis.reflectionAppendArray(this.getObject());\nreturn;\n}\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nString fieldName = field.getName();\nif (this.accept(field)) {\ntry {\n// Warning: Field.get(Object) creates wrappers objects\n// for primitive types.\nObject fieldValue = this.getValue(field);\nthis.append(fieldName, fieldValue);\n} catch (IllegalAccessException ex) {\n//this can't happen. Would get a Security exception\n// instead\n//throw a runtime exception in case the impossible\n// happens.\nthrow new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getUpToClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getUpToClass() {\nreturn this.upToClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getValue(Ljava/lang/reflect/Field;)Ljava/lang/Object;",
                                    "method_body": "protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\nreturn field.get(this.getObject());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendStatics(Z)V",
                                    "method_body": "public void setAppendStatics(boolean appendStatics) {\nthis.appendStatics = appendStatics;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendTransients(Z)V",
                                    "method_body": "public void setAppendTransients(boolean appendTransients) {\nthis.appendTransients = appendTransients;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setUpToClass(Ljava/lang/Class;)V",
                                    "method_body": "public void setUpToClass(Class<?> clazz) {\nif (clazz != null) {\nObject object = getObject();\nif (object != null && clazz.isInstance(object) == false) {\nthrow new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n}\n}\nthis.upToClass = clazz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nreturn this.getStyle().getNullText();\n}\nClass<?> clazz = this.getObject().getClass();\nthis.appendFieldsIn(clazz);\nwhile (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\nclazz = clazz.getSuperclass();\nthis.appendFieldsIn(clazz);\n}\nreturn super.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object, ToStringStyle style) {\nreturn ReflectionToStringBuilder.toString(object, style);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Z)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object, ToStringStyle style, boolean outputTransients) {\nreturn ReflectionToStringBuilder.toString(object, style, outputTransients, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String reflectionToString(\nT object,\nToStringStyle style,\nboolean outputTransients,\nClass<? super T> reflectUpToClass) {\nreturn ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object, ToStringStyle style) {\nreturn toString(object, style, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:isAppendTransients()Z",
                                    "method_body": "public boolean isAppendTransients() {\nreturn this.appendTransients;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testReflectionObjectArray",
                            "test_body": "144: public void testReflectionObjectArray() {\n145: Object[] array = new Object[] { null, base, new int[] { 3, 6 } };\n146: String baseStr = this.toBaseString(array);\n147: assertEquals(baseStr + \"[{<null>,5,{3,6}}]\", ToStringBuilder.reflectionToString(array));\n148: array = null;\n149: assertReflectionArray(\"<null>\", array);\n150: this.validateNullToStringStyleRegistry();\n151: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object) {\nreturn ReflectionToStringBuilder.toString(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {\nbuffer.append(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;Ljava/lang/Class;ZZ)V",
                                    "method_body": "public <T> ReflectionToStringBuilder(\nT object, ToStringStyle style, StringBuffer buffer,\nClass<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\nsuper(object, style, buffer);\nthis.setUpToClass(reflectUpToClass);\nthis.setAppendTransients(outputTransients);\nthis.setAppendStatics(outputStatics);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object) {\nreturn toString(object, null, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String toString(\nT object, ToStringStyle style, boolean outputTransients,\nboolean outputStatics, Class<? super T> reflectUpToClass) {\nreturn new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:appendFieldsIn(Ljava/lang/Class;)V",
                                    "method_body": "protected void appendFieldsIn(Class<?> clazz) {\nif (clazz.isArray()) {\nthis.reflectionAppendArray(this.getObject());\nreturn;\n}\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nString fieldName = field.getName();\nif (this.accept(field)) {\ntry {\n// Warning: Field.get(Object) creates wrappers objects\n// for primitive types.\nObject fieldValue = this.getValue(field);\nthis.append(fieldName, fieldValue);\n} catch (IllegalAccessException ex) {\n//this can't happen. Would get a Security exception\n// instead\n//throw a runtime exception in case the impossible\n// happens.\nthrow new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getUpToClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getUpToClass() {\nreturn this.upToClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendStatics(Z)V",
                                    "method_body": "public void setAppendStatics(boolean appendStatics) {\nthis.appendStatics = appendStatics;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendTransients(Z)V",
                                    "method_body": "public void setAppendTransients(boolean appendTransients) {\nthis.appendTransients = appendTransients;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setUpToClass(Ljava/lang/Class;)V",
                                    "method_body": "public void setUpToClass(Class<?> clazz) {\nif (clazz != null) {\nObject object = getObject();\nif (object != null && clazz.isInstance(object) == false) {\nthrow new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n}\n}\nthis.upToClass = clazz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nreturn this.getStyle().getNullText();\n}\nClass<?> clazz = this.getObject().getClass();\nthis.appendFieldsIn(clazz);\nwhile (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\nclazz = clazz.getSuperclass();\nthis.appendFieldsIn(clazz);\n}\nreturn super.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public ToStringStyle getStyle() {\nreturn style;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;I)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, int value) {\nbuffer.append(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:reflectionAppendArrayDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\nbuffer.append(arrayStart);\nint length = Array.getLength(array);\nfor (int i = 0; i < length; i++) {\nObject item = Array.get(array, i);\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nif (item == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, item, arrayContentDetail);\n}\n}\nbuffer.append(arrayEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;[I)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\nbuffer.append(arrayStart);\nfor (int i = 0; i < array.length; i++) {\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nappendDetail(buffer, fieldName, array[i]);\n}\nbuffer.append(arrayEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendNullText(Ljava/lang/StringBuffer;Ljava/lang/String;)V",
                                    "method_body": "protected void appendNullText(StringBuffer buffer, String fieldName) {\nbuffer.append(nullText);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:reflectionAppendArray(Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ReflectionToStringBuilder;",
                                    "method_body": "public ReflectionToStringBuilder reflectionAppendArray(Object array) {\nthis.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\nreturn this;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testReflectionhortArrayArray",
                            "test_body": "255: public void testReflectionhortArrayArray() {\n256: short[][] array = new short[][] { { 1, 2 }, null, { 5 } };\n257: String baseStr = this.toBaseString(array);\n258: assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n259: array = null;\n260: assertReflectionArray(\"<null>\", array);\n261: this.validateNullToStringStyleRegistry();\n262: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object) {\nreturn ReflectionToStringBuilder.toString(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;Ljava/lang/Class;ZZ)V",
                                    "method_body": "public <T> ReflectionToStringBuilder(\nT object, ToStringStyle style, StringBuffer buffer,\nClass<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\nsuper(object, style, buffer);\nthis.setUpToClass(reflectUpToClass);\nthis.setAppendTransients(outputTransients);\nthis.setAppendStatics(outputStatics);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object) {\nreturn toString(object, null, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String toString(\nT object, ToStringStyle style, boolean outputTransients,\nboolean outputStatics, Class<? super T> reflectUpToClass) {\nreturn new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:appendFieldsIn(Ljava/lang/Class;)V",
                                    "method_body": "protected void appendFieldsIn(Class<?> clazz) {\nif (clazz.isArray()) {\nthis.reflectionAppendArray(this.getObject());\nreturn;\n}\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nString fieldName = field.getName();\nif (this.accept(field)) {\ntry {\n// Warning: Field.get(Object) creates wrappers objects\n// for primitive types.\nObject fieldValue = this.getValue(field);\nthis.append(fieldName, fieldValue);\n} catch (IllegalAccessException ex) {\n//this can't happen. Would get a Security exception\n// instead\n//throw a runtime exception in case the impossible\n// happens.\nthrow new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getUpToClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getUpToClass() {\nreturn this.upToClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendStatics(Z)V",
                                    "method_body": "public void setAppendStatics(boolean appendStatics) {\nthis.appendStatics = appendStatics;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendTransients(Z)V",
                                    "method_body": "public void setAppendTransients(boolean appendTransients) {\nthis.appendTransients = appendTransients;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setUpToClass(Ljava/lang/Class;)V",
                                    "method_body": "public void setUpToClass(Class<?> clazz) {\nif (clazz != null) {\nObject object = getObject();\nif (object != null && clazz.isInstance(object) == false) {\nthrow new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n}\n}\nthis.upToClass = clazz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nreturn this.getStyle().getNullText();\n}\nClass<?> clazz = this.getObject().getClass();\nthis.appendFieldsIn(clazz);\nwhile (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\nclazz = clazz.getSuperclass();\nthis.appendFieldsIn(clazz);\n}\nreturn super.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public ToStringStyle getStyle() {\nreturn style;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:reflectionAppendArrayDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\nbuffer.append(arrayStart);\nint length = Array.getLength(array);\nfor (int i = 0; i < length; i++) {\nObject item = Array.get(array, i);\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nif (item == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, item, arrayContentDetail);\n}\n}\nbuffer.append(arrayEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendNullText(Ljava/lang/StringBuffer;Ljava/lang/String;)V",
                                    "method_body": "protected void appendNullText(StringBuffer buffer, String fieldName) {\nbuffer.append(nullText);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:reflectionAppendArray(Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ReflectionToStringBuilder;",
                                    "method_body": "public ReflectionToStringBuilder reflectionAppendArray(Object array) {\nthis.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;S)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, short value) {\nbuffer.append(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;[S)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, short[] array) {\nbuffer.append(arrayStart);\nfor (int i = 0; i < array.length; i++) {\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nappendDetail(buffer, fieldName, array[i]);\n}\nbuffer.append(arrayEnd);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testReflectionFloatArrayArray",
                            "test_body": "227: public void testReflectionFloatArrayArray() {\n228: float[][] array = new float[][] { { 1.0f, 2.29686f }, null, { Float.NaN } };\n229: String baseStr = this.toBaseString(array);\n230: assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", ToStringBuilder.reflectionToString(array));\n231: array = null;\n232: assertReflectionArray(\"<null>\", array);\n233: this.validateNullToStringStyleRegistry();\n234: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object) {\nreturn ReflectionToStringBuilder.toString(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;Ljava/lang/Class;ZZ)V",
                                    "method_body": "public <T> ReflectionToStringBuilder(\nT object, ToStringStyle style, StringBuffer buffer,\nClass<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\nsuper(object, style, buffer);\nthis.setUpToClass(reflectUpToClass);\nthis.setAppendTransients(outputTransients);\nthis.setAppendStatics(outputStatics);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object) {\nreturn toString(object, null, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String toString(\nT object, ToStringStyle style, boolean outputTransients,\nboolean outputStatics, Class<? super T> reflectUpToClass) {\nreturn new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:appendFieldsIn(Ljava/lang/Class;)V",
                                    "method_body": "protected void appendFieldsIn(Class<?> clazz) {\nif (clazz.isArray()) {\nthis.reflectionAppendArray(this.getObject());\nreturn;\n}\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nString fieldName = field.getName();\nif (this.accept(field)) {\ntry {\n// Warning: Field.get(Object) creates wrappers objects\n// for primitive types.\nObject fieldValue = this.getValue(field);\nthis.append(fieldName, fieldValue);\n} catch (IllegalAccessException ex) {\n//this can't happen. Would get a Security exception\n// instead\n//throw a runtime exception in case the impossible\n// happens.\nthrow new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getUpToClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getUpToClass() {\nreturn this.upToClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendStatics(Z)V",
                                    "method_body": "public void setAppendStatics(boolean appendStatics) {\nthis.appendStatics = appendStatics;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendTransients(Z)V",
                                    "method_body": "public void setAppendTransients(boolean appendTransients) {\nthis.appendTransients = appendTransients;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setUpToClass(Ljava/lang/Class;)V",
                                    "method_body": "public void setUpToClass(Class<?> clazz) {\nif (clazz != null) {\nObject object = getObject();\nif (object != null && clazz.isInstance(object) == false) {\nthrow new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n}\n}\nthis.upToClass = clazz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nreturn this.getStyle().getNullText();\n}\nClass<?> clazz = this.getObject().getClass();\nthis.appendFieldsIn(clazz);\nwhile (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\nclazz = clazz.getSuperclass();\nthis.appendFieldsIn(clazz);\n}\nreturn super.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public ToStringStyle getStyle() {\nreturn style;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:reflectionAppendArrayDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\nbuffer.append(arrayStart);\nint length = Array.getLength(array);\nfor (int i = 0; i < length; i++) {\nObject item = Array.get(array, i);\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nif (item == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, item, arrayContentDetail);\n}\n}\nbuffer.append(arrayEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendNullText(Ljava/lang/StringBuffer;Ljava/lang/String;)V",
                                    "method_body": "protected void appendNullText(StringBuffer buffer, String fieldName) {\nbuffer.append(nullText);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:reflectionAppendArray(Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ReflectionToStringBuilder;",
                                    "method_body": "public ReflectionToStringBuilder reflectionAppendArray(Object array) {\nthis.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;F)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, float value) {\nbuffer.append(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;[F)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, float[] array) {\nbuffer.append(arrayStart);\nfor (int i = 0; i < array.length; i++) {\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nappendDetail(buffer, fieldName, array[i]);\n}\nbuffer.append(arrayEnd);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testReflectionArrayCycle",
                            "test_body": "376: public void testReflectionArrayCycle() throws Exception {\n377: Object[] objects = new Object[1];\n378: objects[0] = objects;\n379: assertEquals(\n380: this.toBaseString(objects) + \"[{\" + this.toBaseString(objects) + \"}]\",\n381: ToStringBuilder.reflectionToString(objects));\n382: this.validateNullToStringStyleRegistry();\n383: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils:<clinit>()V",
                                    "method_body": "public static final Null NULL = new Null();\n\n/**\n* <p><code>ObjectUtils</code> instances should NOT be constructed in\n* standard programming. Instead, the class should be used as\n* <code>ObjectUtils.defaultIfNull(\"a\",\"b\");</code>.</p>\n*\n* <p>This constructor is public to permit tools that require a JavaBean instance\n* to operate.</p>\n*/\npublic ObjectUtils() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils:identityToString(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public static void identityToString(StringBuffer buffer, Object object) {\nif (object == null) {\nthrow new NullPointerException(\"Cannot get the toString of a null identity\");\n}\nbuffer.append(object.getClass().getName())\n.append('@')\n.append(Integer.toHexString(System.identityHashCode(object)));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils$Null:<init>()V",
                                    "method_body": "Null() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object) {\nreturn ReflectionToStringBuilder.toString(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendCyclicObject(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendCyclicObject(StringBuffer buffer, String fieldName, Object value) {\nObjectUtils.identityToString(buffer, value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;Ljava/lang/Class;ZZ)V",
                                    "method_body": "public <T> ReflectionToStringBuilder(\nT object, ToStringStyle style, StringBuffer buffer,\nClass<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\nsuper(object, style, buffer);\nthis.setUpToClass(reflectUpToClass);\nthis.setAppendTransients(outputTransients);\nthis.setAppendStatics(outputStatics);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object) {\nreturn toString(object, null, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String toString(\nT object, ToStringStyle style, boolean outputTransients,\nboolean outputStatics, Class<? super T> reflectUpToClass) {\nreturn new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:appendFieldsIn(Ljava/lang/Class;)V",
                                    "method_body": "protected void appendFieldsIn(Class<?> clazz) {\nif (clazz.isArray()) {\nthis.reflectionAppendArray(this.getObject());\nreturn;\n}\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nString fieldName = field.getName();\nif (this.accept(field)) {\ntry {\n// Warning: Field.get(Object) creates wrappers objects\n// for primitive types.\nObject fieldValue = this.getValue(field);\nthis.append(fieldName, fieldValue);\n} catch (IllegalAccessException ex) {\n//this can't happen. Would get a Security exception\n// instead\n//throw a runtime exception in case the impossible\n// happens.\nthrow new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getUpToClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getUpToClass() {\nreturn this.upToClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendStatics(Z)V",
                                    "method_body": "public void setAppendStatics(boolean appendStatics) {\nthis.appendStatics = appendStatics;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendTransients(Z)V",
                                    "method_body": "public void setAppendTransients(boolean appendTransients) {\nthis.appendTransients = appendTransients;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setUpToClass(Ljava/lang/Class;)V",
                                    "method_body": "public void setUpToClass(Class<?> clazz) {\nif (clazz != null) {\nObject object = getObject();\nif (object != null && clazz.isInstance(object) == false) {\nthrow new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n}\n}\nthis.upToClass = clazz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nreturn this.getStyle().getNullText();\n}\nClass<?> clazz = this.getObject().getClass();\nthis.appendFieldsIn(clazz);\nwhile (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\nclazz = clazz.getSuperclass();\nthis.appendFieldsIn(clazz);\n}\nreturn super.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public ToStringStyle getStyle() {\nreturn style;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:reflectionAppendArrayDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\nbuffer.append(arrayStart);\nint length = Array.getLength(array);\nfor (int i = 0; i < length; i++) {\nObject item = Array.get(array, i);\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nif (item == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, item, arrayContentDetail);\n}\n}\nbuffer.append(arrayEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:reflectionAppendArray(Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ReflectionToStringBuilder;",
                                    "method_body": "public ReflectionToStringBuilder reflectionAppendArray(Object array) {\nthis.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\nreturn this;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testReflectionBooleanArrayArray",
                            "test_body": "291: public void testReflectionBooleanArrayArray() {\n292: boolean[][] array = new boolean[][] { { true, false }, null, { false } };\n293: String baseStr = this.toBaseString(array);\n294: assertEquals(baseStr + \"[{{true,false},<null>,{false}}]\", ToStringBuilder.reflectionToString(array));\n295: assertEquals(baseStr + \"[{{true,false},<null>,{false}}]\", ToStringBuilder.reflectionToString(array));\n296: array = null;\n297: assertReflectionArray(\"<null>\", array);\n298: this.validateNullToStringStyleRegistry();\n299: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object) {\nreturn ReflectionToStringBuilder.toString(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;Ljava/lang/Class;ZZ)V",
                                    "method_body": "public <T> ReflectionToStringBuilder(\nT object, ToStringStyle style, StringBuffer buffer,\nClass<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\nsuper(object, style, buffer);\nthis.setUpToClass(reflectUpToClass);\nthis.setAppendTransients(outputTransients);\nthis.setAppendStatics(outputStatics);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object) {\nreturn toString(object, null, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String toString(\nT object, ToStringStyle style, boolean outputTransients,\nboolean outputStatics, Class<? super T> reflectUpToClass) {\nreturn new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:appendFieldsIn(Ljava/lang/Class;)V",
                                    "method_body": "protected void appendFieldsIn(Class<?> clazz) {\nif (clazz.isArray()) {\nthis.reflectionAppendArray(this.getObject());\nreturn;\n}\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nString fieldName = field.getName();\nif (this.accept(field)) {\ntry {\n// Warning: Field.get(Object) creates wrappers objects\n// for primitive types.\nObject fieldValue = this.getValue(field);\nthis.append(fieldName, fieldValue);\n} catch (IllegalAccessException ex) {\n//this can't happen. Would get a Security exception\n// instead\n//throw a runtime exception in case the impossible\n// happens.\nthrow new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getUpToClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getUpToClass() {\nreturn this.upToClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendStatics(Z)V",
                                    "method_body": "public void setAppendStatics(boolean appendStatics) {\nthis.appendStatics = appendStatics;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendTransients(Z)V",
                                    "method_body": "public void setAppendTransients(boolean appendTransients) {\nthis.appendTransients = appendTransients;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setUpToClass(Ljava/lang/Class;)V",
                                    "method_body": "public void setUpToClass(Class<?> clazz) {\nif (clazz != null) {\nObject object = getObject();\nif (object != null && clazz.isInstance(object) == false) {\nthrow new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n}\n}\nthis.upToClass = clazz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nreturn this.getStyle().getNullText();\n}\nClass<?> clazz = this.getObject().getClass();\nthis.appendFieldsIn(clazz);\nwhile (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\nclazz = clazz.getSuperclass();\nthis.appendFieldsIn(clazz);\n}\nreturn super.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public ToStringStyle getStyle() {\nreturn style;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:reflectionAppendArrayDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\nbuffer.append(arrayStart);\nint length = Array.getLength(array);\nfor (int i = 0; i < length; i++) {\nObject item = Array.get(array, i);\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nif (item == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, item, arrayContentDetail);\n}\n}\nbuffer.append(arrayEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendNullText(Ljava/lang/StringBuffer;Ljava/lang/String;)V",
                                    "method_body": "protected void appendNullText(StringBuffer buffer, String fieldName) {\nbuffer.append(nullText);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:reflectionAppendArray(Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ReflectionToStringBuilder;",
                                    "method_body": "public ReflectionToStringBuilder reflectionAppendArray(Object array) {\nthis.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Z)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, boolean value) {\nbuffer.append(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;[Z)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, boolean[] array) {\nbuffer.append(arrayStart);\nfor (int i = 0; i < array.length; i++) {\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nappendDetail(buffer, fieldName, array[i]);\n}\nbuffer.append(arrayEnd);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testReflectionCharArray",
                            "test_body": "189: public void testReflectionCharArray() {\n190: char[] array = new char[] { 'A', '2', '_', 'D' };\n191: String baseStr = this.toBaseString(array);\n192: assertEquals(baseStr + \"[{A,2,_,D}]\", ToStringBuilder.reflectionToString(array));\n193: array = null;\n194: assertReflectionArray(\"<null>\", array);\n195: this.validateNullToStringStyleRegistry();\n196: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object) {\nreturn ReflectionToStringBuilder.toString(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {\nbuffer.append(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;Ljava/lang/Class;ZZ)V",
                                    "method_body": "public <T> ReflectionToStringBuilder(\nT object, ToStringStyle style, StringBuffer buffer,\nClass<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\nsuper(object, style, buffer);\nthis.setUpToClass(reflectUpToClass);\nthis.setAppendTransients(outputTransients);\nthis.setAppendStatics(outputStatics);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object) {\nreturn toString(object, null, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String toString(\nT object, ToStringStyle style, boolean outputTransients,\nboolean outputStatics, Class<? super T> reflectUpToClass) {\nreturn new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:appendFieldsIn(Ljava/lang/Class;)V",
                                    "method_body": "protected void appendFieldsIn(Class<?> clazz) {\nif (clazz.isArray()) {\nthis.reflectionAppendArray(this.getObject());\nreturn;\n}\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nString fieldName = field.getName();\nif (this.accept(field)) {\ntry {\n// Warning: Field.get(Object) creates wrappers objects\n// for primitive types.\nObject fieldValue = this.getValue(field);\nthis.append(fieldName, fieldValue);\n} catch (IllegalAccessException ex) {\n//this can't happen. Would get a Security exception\n// instead\n//throw a runtime exception in case the impossible\n// happens.\nthrow new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getUpToClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getUpToClass() {\nreturn this.upToClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendStatics(Z)V",
                                    "method_body": "public void setAppendStatics(boolean appendStatics) {\nthis.appendStatics = appendStatics;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendTransients(Z)V",
                                    "method_body": "public void setAppendTransients(boolean appendTransients) {\nthis.appendTransients = appendTransients;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setUpToClass(Ljava/lang/Class;)V",
                                    "method_body": "public void setUpToClass(Class<?> clazz) {\nif (clazz != null) {\nObject object = getObject();\nif (object != null && clazz.isInstance(object) == false) {\nthrow new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n}\n}\nthis.upToClass = clazz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nreturn this.getStyle().getNullText();\n}\nClass<?> clazz = this.getObject().getClass();\nthis.appendFieldsIn(clazz);\nwhile (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\nclazz = clazz.getSuperclass();\nthis.appendFieldsIn(clazz);\n}\nreturn super.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public ToStringStyle getStyle() {\nreturn style;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:reflectionAppendArrayDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\nbuffer.append(arrayStart);\nint length = Array.getLength(array);\nfor (int i = 0; i < length; i++) {\nObject item = Array.get(array, i);\nif (i > 0) {\nbuffer.append(arraySeparator);\n}\nif (item == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, item, arrayContentDetail);\n}\n}\nbuffer.append(arrayEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:reflectionAppendArray(Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ReflectionToStringBuilder;",
                                    "method_body": "public ReflectionToStringBuilder reflectionAppendArray(Object array) {\nthis.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\nreturn this;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest.testReflectionObjectCycle",
                            "test_body": "542: public void testReflectionObjectCycle() throws Exception {\n543: ReflectionTestCycleA a = new ReflectionTestCycleA();\n544: ReflectionTestCycleB b = new ReflectionTestCycleB();\n545: a.b = b;\n546: b.a = a;\n547: assertEquals(\n548: this.toBaseString(a) + \"[b=\" + this.toBaseString(b) + \"[a=\" + this.toBaseString(a) + \"]]\",\n549: a.toString());\n550: this.validateNullToStringStyleRegistry();\n551: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils:<clinit>()V",
                                    "method_body": "public static final Null NULL = new Null();\n\n/**\n* <p><code>ObjectUtils</code> instances should NOT be constructed in\n* standard programming. Instead, the class should be used as\n* <code>ObjectUtils.defaultIfNull(\"a\",\"b\");</code>.</p>\n*\n* <p>This constructor is public to permit tools that require a JavaBean instance\n* to operate.</p>\n*/\npublic ObjectUtils() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils:identityToString(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public static void identityToString(StringBuffer buffer, Object object) {\nif (object == null) {\nthrow new NullPointerException(\"Cannot get the toString of a null identity\");\n}\nbuffer.append(object.getClass().getName())\n.append('@')\n.append(Integer.toHexString(System.identityHashCode(object)));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ObjectUtils$Null:<init>()V",
                                    "method_body": "Null() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;)V",
                                    "method_body": "public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\nif (style == null) {\nstyle = getDefaultStyle();\n}\nif (buffer == null) {\nbuffer = new StringBuffer(512);\n}\nthis.buffer = buffer;\nthis.style = style;\nthis.object = object;\n\nstyle.appendStart(buffer, object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:<clinit>()V",
                                    "method_body": "private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n\n//----------------------------------------------------------------------------\n\n/**\n* <p>Gets the default <code>ToStringStyle</code> to use.</p>\n*\n* <p>This method gets a singleton default value, typically for the whole JVM.\n* Changing this default should generally only be done during application startup.\n* It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n* of using this global default.</p>\n*\n* <p>This method can be used from multiple threads.\n* Internally, a <code>volatile</code> variable is used to provide the guarantee\n* that the latest value set using {@link #setDefaultStyle} is the value returned."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getDefaultStyle()Lorg/apache/commons/lang3/builder/ToStringStyle;",
                                    "method_body": "public static ToStringStyle getDefaultStyle() {\nreturn defaultStyle;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:reflectionToString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String reflectionToString(Object object) {\nreturn ReflectionToStringBuilder.toString(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:append(Ljava/lang/String;Ljava/lang/Object;)Lorg/apache/commons/lang3/builder/ToStringBuilder;",
                                    "method_body": "public ToStringBuilder append(String fieldName, Object obj) {\nstyle.append(buffer, fieldName, obj, null);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getObject()Ljava/lang/Object;",
                                    "method_body": "public Object getObject() {\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:getStringBuffer()Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer getStringBuffer() {\nreturn buffer;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nthis.getStringBuffer().append(this.getStyle().getNullText());\n} else {\nstyle.appendEnd(this.getStringBuffer(), this.getObject());\n}\nreturn this.getStringBuffer().toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<init>()V",
                                    "method_body": "protected ToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:<clinit>()V",
                                    "method_body": "public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n\n/**\n* The multi line toString style. Using the Using the <code>Person</code>\n* example from {@link ToStringBuilder}, the output would look like this:"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:getRegistry()Ljava/util/Map;",
                                    "method_body": "static Map<Object, Object> getRegistry() {\nreturn REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isRegistered(Ljava/lang/Object;)Z",
                                    "method_body": "static boolean isRegistered(Object value) {\nMap<Object, Object> m = getRegistry();\nreturn m.containsKey(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:register(Ljava/lang/Object;)V",
                                    "method_body": "static void register(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m == null) {\nm = new WeakHashMap<Object, Object>();\nREGISTRY.set(m);\n}\n}\nm.put(value, null);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:unregister(Ljava/lang/Object;)V",
                                    "method_body": "static void unregister(Object value) {\nif (value != null) {\nWeakHashMap<Object, Object> m;\nsynchronized (ToStringStyle.class) {\nm = REGISTRY.get();\nif (m != null) {\nm.remove(value);\nif (m.isEmpty()) {\nREGISTRY.remove();\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendStart(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendStart(StringBuffer buffer, Object object) {\nif (object != null) {\nappendClassName(buffer, object);\nappendIdentityHashCode(buffer, object);\nappendContentStart(buffer);\nif (fieldSeparatorAtStart) {\nappendFieldSeparator(buffer);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendEnd(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "public void appendEnd(StringBuffer buffer, Object object) {\nif (this.fieldSeparatorAtEnd == false) {\nremoveLastFieldSeparator(buffer);\n}\nappendContentEnd(buffer);\nunregister(object);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:removeLastFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void removeLastFieldSeparator(StringBuffer buffer) {\nint len = buffer.length();\nint sepLen = fieldSeparator.length();\nif (len > 0 && sepLen > 0 && len >= sepLen) {\nboolean match = true;\nfor (int i = 0; i < sepLen; i++) {\nif (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\nmatch = false;\nbreak;\n}\n}\nif (match) {\nbuffer.setLength(len - sepLen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:append(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Boolean;)V",
                                    "method_body": "public void append(StringBuffer buffer, String fieldName, Object value, Boolean fullDetail) {\nappendFieldStart(buffer, fieldName);\n\nif (value == null) {\nappendNullText(buffer, fieldName);\n\n} else {\nappendInternal(buffer, fieldName, value, isFullDetail(fullDetail));\n}\n\nappendFieldEnd(buffer, fieldName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendInternal(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;Z)V",
                                    "method_body": "protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\nif (isRegistered(value)\n&& !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\nappendCyclicObject(buffer, fieldName, value);\nreturn;\n}\n\nregister(value);\n\ntry {\nif (value instanceof Collection<?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Collection<?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n}\n\n} else if (value instanceof Map<?, ?>) {\nif (detail) {\nappendDetail(buffer, fieldName, (Map<?, ?>) value);\n} else {\nappendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n}\n\n} else if (value instanceof long[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (long[]) value);\n} else {\nappendSummary(buffer, fieldName, (long[]) value);\n}\n\n} else if (value instanceof int[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (int[]) value);\n} else {\nappendSummary(buffer, fieldName, (int[]) value);\n}\n\n} else if (value instanceof short[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (short[]) value);\n} else {\nappendSummary(buffer, fieldName, (short[]) value);\n}\n\n} else if (value instanceof byte[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (byte[]) value);\n} else {\nappendSummary(buffer, fieldName, (byte[]) value);\n}\n\n} else if (value instanceof char[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (char[]) value);\n} else {\nappendSummary(buffer, fieldName, (char[]) value);\n}\n\n} else if (value instanceof double[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (double[]) value);\n} else {\nappendSummary(buffer, fieldName, (double[]) value);\n}\n\n} else if (value instanceof float[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (float[]) value);\n} else {\nappendSummary(buffer, fieldName, (float[]) value);\n}\n\n} else if (value instanceof boolean[]) {\nif (detail) {\nappendDetail(buffer, fieldName, (boolean[]) value);\n} else {\nappendSummary(buffer, fieldName, (boolean[]) value);\n}\n\n} else if (value.getClass().isArray()) {\nif (detail) {\nappendDetail(buffer, fieldName, (Object[]) value);\n} else {\nappendSummary(buffer, fieldName, (Object[]) value);\n}\n\n} else {\nif (detail) {\nappendDetail(buffer, fieldName, value);\n} else {\nappendSummary(buffer, fieldName, value);\n}\n}\n} finally {\nunregister(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendCyclicObject(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendCyclicObject(StringBuffer buffer, String fieldName, Object value) {\nObjectUtils.identityToString(buffer, value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendDetail(Ljava/lang/StringBuffer;Ljava/lang/String;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {\nbuffer.append(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendClassName(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendClassName(StringBuffer buffer, Object object) {\nif (useClassName && object != null) {\nregister(object);\nif (useShortClassName) {\nbuffer.append(getShortClassName(object.getClass()));\n} else {\nbuffer.append(object.getClass().getName());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendIdentityHashCode(Ljava/lang/StringBuffer;Ljava/lang/Object;)V",
                                    "method_body": "protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\nif (this.isUseIdentityHashCode() && object!=null) {\nregister(object);\nbuffer.append('@');\nbuffer.append(Integer.toHexString(System.identityHashCode(object)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentStart(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentStart(StringBuffer buffer) {\nbuffer.append(contentStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendContentEnd(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendContentEnd(StringBuffer buffer) {\nbuffer.append(contentEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendFieldSeparator(Ljava/lang/StringBuffer;)V",
                                    "method_body": "protected void appendFieldSeparator(StringBuffer buffer) {\nbuffer.append(fieldSeparator);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendFieldStart(Ljava/lang/StringBuffer;Ljava/lang/String;)V",
                                    "method_body": "protected void appendFieldStart(StringBuffer buffer, String fieldName) {\nif (useFieldNames && fieldName != null) {\nbuffer.append(fieldName);\nbuffer.append(fieldNameValueSeparator);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:appendFieldEnd(Ljava/lang/StringBuffer;Ljava/lang/String;)V",
                                    "method_body": "protected void appendFieldEnd(StringBuffer buffer, String fieldName) {\nappendFieldSeparator(buffer);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isFullDetail(Ljava/lang/Boolean;)Z",
                                    "method_body": "protected boolean isFullDetail(Boolean fullDetailRequest) {\nif (fullDetailRequest == null) {\nreturn defaultFullDetail;\n}\nreturn fullDetailRequest.booleanValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseClassName(Z)V",
                                    "method_body": "protected void setUseClassName(boolean useClassName) {\nthis.useClassName = useClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseShortClassName(Z)V",
                                    "method_body": "protected void setUseShortClassName(boolean useShortClassName) {\nthis.useShortClassName = useShortClassName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:isUseIdentityHashCode()Z",
                                    "method_body": "protected boolean isUseIdentityHashCode() {\nreturn useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseIdentityHashCode(Z)V",
                                    "method_body": "protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\nthis.useIdentityHashCode = useIdentityHashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setUseFieldNames(Z)V",
                                    "method_body": "protected void setUseFieldNames(boolean useFieldNames) {\nthis.useFieldNames = useFieldNames;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentStart(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentStart(String contentStart) {\nif (contentStart == null) {\ncontentStart = \"\";\n}\nthis.contentStart = contentStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setContentEnd(Ljava/lang/String;)V",
                                    "method_body": "protected void setContentEnd(String contentEnd) {\nif (contentEnd == null) {\ncontentEnd = \"\";\n}\nthis.contentEnd = contentEnd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparator(Ljava/lang/String;)V",
                                    "method_body": "protected void setFieldSeparator(String fieldSeparator) {\nif (fieldSeparator == null) {\nfieldSeparator = \"\";\n}\nthis.fieldSeparator = fieldSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle:setFieldSeparatorAtStart(Z)V",
                                    "method_body": "protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\nthis.fieldSeparatorAtStart = fieldSeparatorAtStart;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$DefaultToStringStyle:<init>()V",
                                    "method_body": "DefaultToStringStyle() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$MultiLineToStringStyle:<init>()V",
                                    "method_body": "MultiLineToStringStyle() {\nsuper();\nthis.setContentStart(\"[\");\nthis.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\nthis.setFieldSeparatorAtStart(true);\nthis.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$NoFieldNameToStringStyle:<init>()V",
                                    "method_body": "NoFieldNameToStringStyle() {\nsuper();\nthis.setUseFieldNames(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle:<init>()V",
                                    "method_body": "ShortPrefixToStringStyle() {\nsuper();\nthis.setUseShortClassName(true);\nthis.setUseIdentityHashCode(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ToStringStyle$SimpleToStringStyle:<init>()V",
                                    "method_body": "SimpleToStringStyle() {\nsuper();\nthis.setUseClassName(false);\nthis.setUseIdentityHashCode(false);\nthis.setUseFieldNames(false);\nthis.setContentStart(\"\");\nthis.setContentEnd(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:<init>(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;Ljava/lang/StringBuffer;Ljava/lang/Class;ZZ)V",
                                    "method_body": "public <T> ReflectionToStringBuilder(\nT object, ToStringStyle style, StringBuffer buffer,\nClass<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\nsuper(object, style, buffer);\nthis.setUpToClass(reflectUpToClass);\nthis.setAppendTransients(outputTransients);\nthis.setAppendStatics(outputStatics);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public static String toString(Object object) {\nreturn toString(object, null, false, false, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString(Ljava/lang/Object;Lorg/apache/commons/lang3/builder/ToStringStyle;ZZLjava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static <T> String toString(\nT object, ToStringStyle style, boolean outputTransients,\nboolean outputStatics, Class<? super T> reflectUpToClass) {\nreturn new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:accept(Ljava/lang/reflect/Field;)Z",
                                    "method_body": "protected boolean accept(Field field) {\nif (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\n// Reject field from inner class.\nreturn false;\n}\nif (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {\n// Reject transient fields.\nreturn false;\n}\nif (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {\n// Reject static fields.\nreturn false;\n}\nif (this.excludeFieldNames != null\n&& Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\n// Reject fields from the getExcludeFieldNames list.\nreturn false;\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:appendFieldsIn(Ljava/lang/Class;)V",
                                    "method_body": "protected void appendFieldsIn(Class<?> clazz) {\nif (clazz.isArray()) {\nthis.reflectionAppendArray(this.getObject());\nreturn;\n}\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field field : fields) {\nString fieldName = field.getName();\nif (this.accept(field)) {\ntry {\n// Warning: Field.get(Object) creates wrappers objects\n// for primitive types.\nObject fieldValue = this.getValue(field);\nthis.append(fieldName, fieldValue);\n} catch (IllegalAccessException ex) {\n//this can't happen. Would get a Security exception\n// instead\n//throw a runtime exception in case the impossible\n// happens.\nthrow new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getUpToClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getUpToClass() {\nreturn this.upToClass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:getValue(Ljava/lang/reflect/Field;)Ljava/lang/Object;",
                                    "method_body": "protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\nreturn field.get(this.getObject());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendStatics(Z)V",
                                    "method_body": "public void setAppendStatics(boolean appendStatics) {\nthis.appendStatics = appendStatics;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setAppendTransients(Z)V",
                                    "method_body": "public void setAppendTransients(boolean appendTransients) {\nthis.appendTransients = appendTransients;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:setUpToClass(Ljava/lang/Class;)V",
                                    "method_body": "public void setUpToClass(Class<?> clazz) {\nif (clazz != null) {\nObject object = getObject();\nif (object != null && clazz.isInstance(object) == false) {\nthrow new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n}\n}\nthis.upToClass = clazz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.builder.ReflectionToStringBuilder:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nif (this.getObject() == null) {\nreturn this.getStyle().getNullText();\n}\nClass<?> clazz = this.getObject().getClass();\nthis.appendFieldsIn(clazz);\nwhile (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\nclazz = clazz.getSuperclass();\nthis.appendFieldsIn(clazz);\n}\nreturn super.toString();\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 35,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.ArrayUtilsAddTest.testLANG571",
                            "test_body": "227: public void testLANG571(){\n228: String[] stringArray=null;\n229: String aString=null;\n230: try {\n231: @SuppressWarnings(\"unused\")\n232: String[] sa = ArrayUtils.add(stringArray, aString);\n233: fail(\"Should have caused IllegalArgumentException\");\n234: } catch (IllegalArgumentException iae){\n235: //expected\n236: }\n237: try {\n238: @SuppressWarnings(\"unused\")\n239: String[] sa = ArrayUtils.add(stringArray, 0, aString);\n240: fail(\"Should have caused IllegalArgumentException\");\n241: } catch (IllegalArgumentException iae){\n242: //expected\n243: }\n244: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:<clinit>()V",
                                    "method_body": "public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n/**\n* An empty immutable <code>Class</code> array.\n*/\npublic static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n/**\n* An empty immutable <code>String</code> array.\n*/\npublic static final String[] EMPTY_STRING_ARRAY = new String[0];\n/**\n* An empty immutable <code>long</code> array.\n*/\npublic static final long[] EMPTY_LONG_ARRAY = new long[0];\n/**\n* An empty immutable <code>Long</code> array.\n*/\npublic static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];\n/**\n* An empty immutable <code>int</code> array.\n*/\npublic static final int[] EMPTY_INT_ARRAY = new int[0];\n/**\n* An empty immutable <code>Integer</code> array.\n*/\npublic static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n/**\n* An empty immutable <code>short</code> array.\n*/\npublic static final short[] EMPTY_SHORT_ARRAY = new short[0];\n/**\n* An empty immutable <code>Short</code> array.\n*/\npublic static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0];\n/**\n* An empty immutable <code>byte</code> array.\n*/\npublic static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n/**\n* An empty immutable <code>Byte</code> array.\n*/\npublic static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];\n/**\n* An empty immutable <code>double</code> array.\n*/\npublic static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n/**\n* An empty immutable <code>Double</code> array.\n*/\npublic static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0];\n/**\n* An empty immutable <code>float</code> array.\n*/\npublic static final float[] EMPTY_FLOAT_ARRAY = new float[0];\n/**\n* An empty immutable <code>Float</code> array.\n*/\npublic static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0];\n/**\n* An empty immutable <code>boolean</code> array.\n*/\npublic static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];\n/**\n* An empty immutable <code>Boolean</code> array.\n*/\npublic static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];\n/**\n* An empty immutable <code>char</code> array.\n*/\npublic static final char[] EMPTY_CHAR_ARRAY = new char[0];\n/**\n* An empty immutable <code>Character</code> array.\n*/\npublic static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n\n/**\n* The index value when an element is not found in a list or array: <code>-1</code>.\n* This value is returned by methods in this class and can also be used in comparisons with values returned by\n* various method from {@link java.util.List}."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:add([Ljava/lang/Object;Ljava/lang/Object;)[Ljava/lang/Object;",
                                    "method_body": "public static <T> T[] add(T[] array, T element) {\nClass<?> type;\nif (array != null){\ntype = array.getClass();\n} else if (element != null) {\ntype = element.getClass();\n} else {\ntype = Object.class;\n}\n@SuppressWarnings(\"unchecked\") // type must be T\nT[] newArray = (T[]) copyArrayGrow1(array, type);\nnewArray[newArray.length - 1] = element;\nreturn newArray;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:copyArrayGrow1(Ljava/lang/Object;Ljava/lang/Class;)Ljava/lang/Object;",
                                    "method_body": "private static Object copyArrayGrow1(Object array, Class<?> newArrayComponentType) {\nif (array != null) {\nint arrayLength = Array.getLength(array);\nObject newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1);\nSystem.arraycopy(array, 0, newArray, 0, arrayLength);\nreturn newArray;\n}\nreturn Array.newInstance(newArrayComponentType, 1);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 36,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.math.NumberUtilsTest.testIsNumber",
                            "test_body": "1002: public void testIsNumber() {\n1003: String val = \"12345\";\n1004: assertTrue(\"isNumber(String) 1 failed\", NumberUtils.isNumber(val));\n1005: assertTrue(\"isNumber(String)/createNumber(String) 1 failed\", checkCreateNumber(val));\n1006: val = \"1234.5\";\n1007: assertTrue(\"isNumber(String) 2 failed\", NumberUtils.isNumber(val));\n1008: assertTrue(\"isNumber(String)/createNumber(String) 2 failed\", checkCreateNumber(val));\n1009: val = \".12345\";\n1010: assertTrue(\"isNumber(String) 3 failed\", NumberUtils.isNumber(val));\n1011: assertTrue(\"isNumber(String)/createNumber(String) 3 failed\", checkCreateNumber(val));\n1012: val = \"1234E5\";\n1013: assertTrue(\"isNumber(String) 4 failed\", NumberUtils.isNumber(val));\n1014: assertTrue(\"isNumber(String)/createNumber(String) 4 failed\", checkCreateNumber(val));\n1015: val = \"1234E+5\";\n1016: assertTrue(\"isNumber(String) 5 failed\", NumberUtils.isNumber(val));\n1017: assertTrue(\"isNumber(String)/createNumber(String) 5 failed\", checkCreateNumber(val));\n1018: val = \"1234E-5\";\n1019: assertTrue(\"isNumber(String) 6 failed\", NumberUtils.isNumber(val));\n1020: assertTrue(\"isNumber(String)/createNumber(String) 6 failed\", checkCreateNumber(val));\n1021: val = \"123.4E5\";\n1022: assertTrue(\"isNumber(String) 7 failed\", NumberUtils.isNumber(val));\n1023: assertTrue(\"isNumber(String)/createNumber(String) 7 failed\", checkCreateNumber(val));\n1024: val = \"-1234\";\n1025: assertTrue(\"isNumber(String) 8 failed\", NumberUtils.isNumber(val));\n1026: assertTrue(\"isNumber(String)/createNumber(String) 8 failed\", checkCreateNumber(val));\n1027: val = \"-1234.5\";\n1028: assertTrue(\"isNumber(String) 9 failed\", NumberUtils.isNumber(val));\n1029: assertTrue(\"isNumber(String)/createNumber(String) 9 failed\", checkCreateNumber(val));\n1030: val = \"-.12345\";\n1031: assertTrue(\"isNumber(String) 10 failed\", NumberUtils.isNumber(val));\n1032: assertTrue(\"isNumber(String)/createNumber(String) 10 failed\", checkCreateNumber(val));\n1033: val = \"-1234E5\";\n1034: assertTrue(\"isNumber(String) 11 failed\", NumberUtils.isNumber(val));\n1035: assertTrue(\"isNumber(String)/createNumber(String) 11 failed\", checkCreateNumber(val));\n1036: val = \"0\";\n1037: assertTrue(\"isNumber(String) 12 failed\", NumberUtils.isNumber(val));\n1038: assertTrue(\"isNumber(String)/createNumber(String) 12 failed\", checkCreateNumber(val));\n1039: val = \"-0\";\n1040: assertTrue(\"isNumber(String) 13 failed\", NumberUtils.isNumber(val));\n1041: assertTrue(\"isNumber(String)/createNumber(String) 13 failed\", checkCreateNumber(val));\n1042: val = \"01234\";\n1043: assertTrue(\"isNumber(String) 14 failed\", NumberUtils.isNumber(val));\n1044: assertTrue(\"isNumber(String)/createNumber(String) 14 failed\", checkCreateNumber(val));\n1045: val = \"-01234\";\n1046: assertTrue(\"isNumber(String) 15 failed\", NumberUtils.isNumber(val));\n1047: assertTrue(\"isNumber(String)/createNumber(String) 15 failed\", checkCreateNumber(val));\n1048: val = \"0xABC123\";\n1049: assertTrue(\"isNumber(String) 16 failed\", NumberUtils.isNumber(val));\n1050: assertTrue(\"isNumber(String)/createNumber(String) 16 failed\", checkCreateNumber(val));\n1051: val = \"0x0\";\n1052: assertTrue(\"isNumber(String) 17 failed\", NumberUtils.isNumber(val));\n1053: assertTrue(\"isNumber(String)/createNumber(String) 17 failed\", checkCreateNumber(val));\n1054: val = \"123.4E21D\";\n1055: assertTrue(\"isNumber(String) 19 failed\", NumberUtils.isNumber(val));\n1056: assertTrue(\"isNumber(String)/createNumber(String) 19 failed\", checkCreateNumber(val));\n1057: val = \"-221.23F\";\n1058: assertTrue(\"isNumber(String) 20 failed\", NumberUtils.isNumber(val));\n1059: assertTrue(\"isNumber(String)/createNumber(String) 20 failed\", checkCreateNumber(val));\n1060: val = \"22338L\";\n1061: assertTrue(\"isNumber(String) 21 failed\", NumberUtils.isNumber(val));\n1062: assertTrue(\"isNumber(String)/createNumber(String) 21 failed\", checkCreateNumber(val));\n1063: val = null;\n1064: assertTrue(\"isNumber(String) 1 Neg failed\", !NumberUtils.isNumber(val));\n1065: assertTrue(\"isNumber(String)/createNumber(String) 1 Neg failed\", !checkCreateNumber(val));\n1066: val = \"\";\n1067: assertTrue(\"isNumber(String) 2 Neg failed\", !NumberUtils.isNumber(val));\n1068: assertTrue(\"isNumber(String)/createNumber(String) 2 Neg failed\", !checkCreateNumber(val));\n1069: val = \"--2.3\";\n1070: assertTrue(\"isNumber(String) 3 Neg failed\", !NumberUtils.isNumber(val));\n1071: assertTrue(\"isNumber(String)/createNumber(String) 3 Neg failed\", !checkCreateNumber(val));\n1072: val = \".12.3\";\n1073: assertTrue(\"isNumber(String) 4 Neg failed\", !NumberUtils.isNumber(val));\n1074: assertTrue(\"isNumber(String)/createNumber(String) 4 Neg failed\", !checkCreateNumber(val));\n1075: val = \"-123E\";\n1076: assertTrue(\"isNumber(String) 5 Neg failed\", !NumberUtils.isNumber(val));\n1077: assertTrue(\"isNumber(String)/createNumber(String) 5 Neg failed\", !checkCreateNumber(val));\n1078: val = \"-123E+-212\";\n1079: assertTrue(\"isNumber(String) 6 Neg failed\", !NumberUtils.isNumber(val));\n1080: assertTrue(\"isNumber(String)/createNumber(String) 6 Neg failed\", !checkCreateNumber(val));\n1081: val = \"-123E2.12\";\n1082: assertTrue(\"isNumber(String) 7 Neg failed\", !NumberUtils.isNumber(val));\n1083: assertTrue(\"isNumber(String)/createNumber(String) 7 Neg failed\", !checkCreateNumber(val));\n1084: val = \"0xGF\";\n1085: assertTrue(\"isNumber(String) 8 Neg failed\", !NumberUtils.isNumber(val));\n1086: assertTrue(\"isNumber(String)/createNumber(String) 8 Neg failed\", !checkCreateNumber(val));\n1087: val = \"0xFAE-1\";\n1088: assertTrue(\"isNumber(String) 9 Neg failed\", !NumberUtils.isNumber(val));\n1089: assertTrue(\"isNumber(String)/createNumber(String) 9 Neg failed\", !checkCreateNumber(val));\n1090: val = \".\";\n1091: assertTrue(\"isNumber(String) 10 Neg failed\", !NumberUtils.isNumber(val));\n1092: assertTrue(\"isNumber(String)/createNumber(String) 10 Neg failed\", !checkCreateNumber(val));\n1093: val = \"-0ABC123\";\n1094: assertTrue(\"isNumber(String) 11 Neg failed\", !NumberUtils.isNumber(val));\n1095: assertTrue(\"isNumber(String)/createNumber(String) 11 Neg failed\", !checkCreateNumber(val));\n1096: val = \"123.4E-D\";\n1097: assertTrue(\"isNumber(String) 12 Neg failed\", !NumberUtils.isNumber(val));\n1098: assertTrue(\"isNumber(String)/createNumber(String) 12 Neg failed\", !checkCreateNumber(val));\n1099: val = \"123.4ED\";\n1100: assertTrue(\"isNumber(String) 13 Neg failed\", !NumberUtils.isNumber(val));\n1101: assertTrue(\"isNumber(String)/createNumber(String) 13 Neg failed\", !checkCreateNumber(val));\n1102: val = \"1234E5l\";\n1103: assertTrue(\"isNumber(String) 14 Neg failed\", !NumberUtils.isNumber(val));\n1104: assertTrue(\"isNumber(String)/createNumber(String) 14 Neg failed\", !checkCreateNumber(val));\n1105: val = \"11a\";\n1106: assertTrue(\"isNumber(String) 15 Neg failed\", !NumberUtils.isNumber(val));\n1107: assertTrue(\"isNumber(String)/createNumber(String) 15 Neg failed\", !checkCreateNumber(val)); \n1108: val = \"1a\";\n1109: assertTrue(\"isNumber(String) 16 Neg failed\", !NumberUtils.isNumber(val));\n1110: assertTrue(\"isNumber(String)/createNumber(String) 16 Neg failed\", !checkCreateNumber(val)); \n1111: val = \"a\";\n1112: assertTrue(\"isNumber(String) 17 Neg failed\", !NumberUtils.isNumber(val));\n1113: assertTrue(\"isNumber(String)/createNumber(String) 17 Neg failed\", !checkCreateNumber(val)); \n1114: val = \"11g\";\n1115: assertTrue(\"isNumber(String) 18 Neg failed\", !NumberUtils.isNumber(val));\n1116: assertTrue(\"isNumber(String)/createNumber(String) 18 Neg failed\", !checkCreateNumber(val)); \n1117: val = \"11z\";\n1118: assertTrue(\"isNumber(String) 19 Neg failed\", !NumberUtils.isNumber(val));\n1119: assertTrue(\"isNumber(String)/createNumber(String) 19 Neg failed\", !checkCreateNumber(val)); \n1120: val = \"11def\";\n1121: assertTrue(\"isNumber(String) 20 Neg failed\", !NumberUtils.isNumber(val));\n1122: assertTrue(\"isNumber(String)/createNumber(String) 20 Neg failed\", !checkCreateNumber(val)); \n1123: val = \"11d11\";\n1124: assertTrue(\"isNumber(String) 21 Neg failed\", !NumberUtils.isNumber(val));\n1125: assertTrue(\"isNumber(String)/createNumber(String) 21 Neg failed\", !checkCreateNumber(val)); \n1126: val = \"11 11\";\n1127: assertTrue(\"isNumber(String) 22 Neg failed\", !NumberUtils.isNumber(val));\n1128: assertTrue(\"isNumber(String)/createNumber(String) 22 Neg failed\", !checkCreateNumber(val));\n1129: val = \" 1111\";\n1130: assertTrue(\"isNumber(String) 23 Neg failed\", !NumberUtils.isNumber(val));\n1131: assertTrue(\"isNumber(String)/createNumber(String) 23 Neg failed\", !checkCreateNumber(val));\n1132: val = \"1111 \";\n1133: assertTrue(\"isNumber(String) 24 Neg failed\", !NumberUtils.isNumber(val));\n1134: assertTrue(\"isNumber(String)/createNumber(String) 24 Neg failed\", !checkCreateNumber(val));\n1135: 1136: // LANG-521\n1137: val = \"2.\";\n1138: assertTrue(\"isNumber(String) LANG-521 failed\", NumberUtils.isNumber(val));\n1139: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:isEmpty(Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean isEmpty(CharSequence str) {\nreturn str == null || str.length() == 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:isBlank(Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean isBlank(CharSequence str) {\nint strLen;\nif (str == null || (strLen = str.length()) == 0) {\nreturn true;\n}\nfor (int i = 0; i < strLen; i++) {\nif ((Character.isWhitespace(str.charAt(i)) == false)) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:<clinit>()V",
                                    "method_body": "public static final Long LONG_ZERO = new Long(0L);\n/** Reusable Long constant for one. */\npublic static final Long LONG_ONE = new Long(1L);\n/** Reusable Long constant for minus one. */\npublic static final Long LONG_MINUS_ONE = new Long(-1L);\n/** Reusable Integer constant for zero. */\npublic static final Integer INTEGER_ZERO = new Integer(0);\n/** Reusable Integer constant for one. */\npublic static final Integer INTEGER_ONE = new Integer(1);\n/** Reusable Integer constant for minus one. */\npublic static final Integer INTEGER_MINUS_ONE = new Integer(-1);\n/** Reusable Short constant for zero. */\npublic static final Short SHORT_ZERO = new Short((short) 0);\n/** Reusable Short constant for one. */\npublic static final Short SHORT_ONE = new Short((short) 1);\n/** Reusable Short constant for minus one. */\npublic static final Short SHORT_MINUS_ONE = new Short((short) -1);\n/** Reusable Byte constant for zero. */\npublic static final Byte BYTE_ZERO = Byte.valueOf((byte) 0);\n/** Reusable Byte constant for one. */\npublic static final Byte BYTE_ONE = Byte.valueOf((byte) 1);\n/** Reusable Byte constant for minus one. */\npublic static final Byte BYTE_MINUS_ONE = Byte.valueOf((byte) -1);\n/** Reusable Double constant for zero. */\npublic static final Double DOUBLE_ZERO = new Double(0.0d);\n/** Reusable Double constant for one. */\npublic static final Double DOUBLE_ONE = new Double(1.0d);\n/** Reusable Double constant for minus one. */\npublic static final Double DOUBLE_MINUS_ONE = new Double(-1.0d);\n/** Reusable Float constant for zero. */\npublic static final Float FLOAT_ZERO = new Float(0.0f);\n/** Reusable Float constant for one. */\npublic static final Float FLOAT_ONE = new Float(1.0f);\n/** Reusable Float constant for minus one. */\npublic static final Float FLOAT_MINUS_ONE = new Float(-1.0f);\n\n/**\n* <p><code>NumberUtils</code> instances should NOT be constructed in standard programming.\n* Instead, the class should be used as <code>NumberUtils.toInt(\"6\");</code>.</p>\n*\n* <p>This constructor is public to permit tools that require a JavaBean instance\n* to operate.</p>\n*/\npublic NumberUtils() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createNumber(Ljava/lang/String;)Ljava/lang/Number;",
                                    "method_body": "public static Number createNumber(String str) throws NumberFormatException {\nif (str == null) {\nreturn null;\n}\nif (StringUtils.isBlank(str)) {\nthrow new NumberFormatException(\"A blank string is not a valid number\");\n}\nif (str.startsWith(\"--\")) {\n// this is protection for poorness in java.lang.BigDecimal.\n// it accepts this as a legal value, but it does not appear\n// to be in specification of class. OS X Java parses it to\n// a wrong value.\nreturn null;\n}\nif (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\nreturn createInteger(str);\n}\nchar lastChar = str.charAt(str.length() - 1);\nString mant;\nString dec;\nString exp;\nint decPos = str.indexOf('.');\nint expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\nif (decPos > -1) {\n\nif (expPos > -1) {\nif (expPos < decPos) {\nthrow new NumberFormatException(str + \" is not a valid number.\");\n}\ndec = str.substring(decPos + 1, expPos);\n} else {\ndec = str.substring(decPos + 1);\n}\nmant = str.substring(0, decPos);\n} else {\nif (expPos > -1) {\nmant = str.substring(0, expPos);\n} else {\nmant = str;\n}\ndec = null;\n}\nif (!Character.isDigit(lastChar)) {\nif (expPos > -1 && expPos < str.length() - 1) {\nexp = str.substring(expPos + 1, str.length() - 1);\n} else {\nexp = null;\n}\n//Requesting a specific type..\nString numeric = str.substring(0, str.length() - 1);\nboolean allZeros = isAllZeros(mant) && isAllZeros(exp);\nswitch (lastChar) {\ncase 'l' :\ncase 'L' :\nif (dec == null\n&& exp == null\n&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\ntry {\nreturn createLong(numeric);\n} catch (NumberFormatException nfe) {\n//Too big for a long\n}\nreturn createBigInteger(numeric);\n\n}\nthrow new NumberFormatException(str + \" is not a valid number.\");\ncase 'f' :\ncase 'F' :\ntry {\nFloat f = NumberUtils.createFloat(numeric);\nif (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n//If it's too big for a float or the float value = 0 and the string\n//has non-zeros in it, then float does not have the precision we want\nreturn f;\n}\n\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\n//$FALL-THROUGH$\ncase 'd' :\ncase 'D' :\ntry {\nDouble d = NumberUtils.createDouble(numeric);\nif (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\nreturn d;\n}\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\ntry {\nreturn createBigDecimal(numeric);\n} catch (NumberFormatException e) {\n// ignore the bad number\n}\n//$FALL-THROUGH$\ndefault :\nthrow new NumberFormatException(str + \" is not a valid number.\");\n\n}\n} else {\n//User doesn't have a preference on the return type, so let's start\n//small and go from there...\nif (expPos > -1 && expPos < str.length() - 1) {\nexp = str.substring(expPos + 1, str.length());\n} else {\nexp = null;\n}\nif (dec == null && exp == null) {\n//Must be an int,long,bigint\ntry {\nreturn createInteger(str);\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\ntry {\nreturn createLong(str);\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\nreturn createBigInteger(str);\n\n} else {\n//Must be a float,double,BigDec\nboolean allZeros = isAllZeros(mant) && isAllZeros(exp);\ntry {\nFloat f = createFloat(str);\nif (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\nreturn f;\n}\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\ntry {\nDouble d = createDouble(str);\nif (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\nreturn d;\n}\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\n\nreturn createBigDecimal(str);\n\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:isAllZeros(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean isAllZeros(String str) {\nif (str == null) {\nreturn true;\n}\nfor (int i = str.length() - 1; i >= 0; i--) {\nif (str.charAt(i) != '0') {\nreturn false;\n}\n}\nreturn str.length() > 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createFloat(Ljava/lang/String;)Ljava/lang/Float;",
                                    "method_body": "public static Float createFloat(String str) {\nif (str == null) {\nreturn null;\n}\nreturn Float.valueOf(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createDouble(Ljava/lang/String;)Ljava/lang/Double;",
                                    "method_body": "public static Double createDouble(String str) {\nif (str == null) {\nreturn null;\n}\nreturn Double.valueOf(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createInteger(Ljava/lang/String;)Ljava/lang/Integer;",
                                    "method_body": "public static Integer createInteger(String str) {\nif (str == null) {\nreturn null;\n}\n// decode() handles 0xAABD and 0777 (hex and octal) as well.\nreturn Integer.decode(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createLong(Ljava/lang/String;)Ljava/lang/Long;",
                                    "method_body": "public static Long createLong(String str) {\nif (str == null) {\nreturn null;\n}\nreturn Long.valueOf(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createBigInteger(Ljava/lang/String;)Ljava/math/BigInteger;",
                                    "method_body": "public static BigInteger createBigInteger(String str) {\nif (str == null) {\nreturn null;\n}\nreturn new BigInteger(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createBigDecimal(Ljava/lang/String;)Ljava/math/BigDecimal;",
                                    "method_body": "public static BigDecimal createBigDecimal(String str) {\nif (str == null) {\nreturn null;\n}\n// handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\nif (StringUtils.isBlank(str)) {\nthrow new NumberFormatException(\"A blank string is not a valid number\");\n}\nreturn new BigDecimal(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:isDigits(Ljava/lang/String;)Z",
                                    "method_body": "public static boolean isDigits(String str) {\nif (StringUtils.isEmpty(str)) {\nreturn false;\n}\nfor (int i = 0; i < str.length(); i++) {\nif (!Character.isDigit(str.charAt(i))) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:isNumber(Ljava/lang/String;)Z",
                                    "method_body": "public static boolean isNumber(String str) {\nif (StringUtils.isEmpty(str)) {\nreturn false;\n}\nchar[] chars = str.toCharArray();\nint sz = chars.length;\nboolean hasExp = false;\nboolean hasDecPoint = false;\nboolean allowSigns = false;\nboolean foundDigit = false;\n// deal with any possible sign up front\nint start = (chars[0] == '-') ? 1 : 0;\nif (sz > start + 1) {\nif (chars[start] == '0' && chars[start + 1] == 'x') {\nint i = start + 2;\nif (i == sz) {\nreturn false; // str == \"0x\"\n}\n// checking hex (it can't be anything else)\nfor (; i < chars.length; i++) {\nif ((chars[i] < '0' || chars[i] > '9')\n&& (chars[i] < 'a' || chars[i] > 'f')\n&& (chars[i] < 'A' || chars[i] > 'F')) {\nreturn false;\n}\n}\nreturn true;\n}\n}\nsz--; // don't want to loop to the last char, check it afterwords\n// for type qualifiers\nint i = start;\n// loop to the next to last char or to the last char if we need another digit to\n// make a valid number (e.g. chars[0..5] = \"1234E\")\nwhile (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\nif (chars[i] >= '0' && chars[i] <= '9') {\nfoundDigit = true;\nallowSigns = false;\n\n} else if (chars[i] == '.') {\nif (hasDecPoint || hasExp) {\n// two decimal points or dec in exponent\nreturn false;\n}\nhasDecPoint = true;\n} else if (chars[i] == 'e' || chars[i] == 'E') {\n// we've already taken care of hex.\nif (hasExp) {\n// two E's\nreturn false;\n}\nif (!foundDigit) {\nreturn false;\n}\nhasExp = true;\nallowSigns = true;\n} else if (chars[i] == '+' || chars[i] == '-') {\nif (!allowSigns) {\nreturn false;\n}\nallowSigns = false;\nfoundDigit = false; // we need a digit after the E\n} else {\nreturn false;\n}\ni++;\n}\nif (i < chars.length) {\nif (chars[i] >= '0' && chars[i] <= '9') {\n// no type qualifier, OK\nreturn true;\n}\nif (chars[i] == 'e' || chars[i] == 'E') {\n// can't have an E at the last byte\nreturn false;\n}\nif (!allowSigns\n&& (chars[i] == 'd'\n|| chars[i] == 'D'\n|| chars[i] == 'f'\n|| chars[i] == 'F')) {\nreturn foundDigit;\n}\nif (chars[i] == 'l'\n|| chars[i] == 'L') {\n// not allowing L with an exponent\nreturn foundDigit && !hasExp;\n}\n// last character is illegal\nreturn false;\n}\n// allowSigns is true iff the val ends in 'E'\n// found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\nreturn !allowSigns && foundDigit;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang3.math.NumberUtilsTest.testCreateNumber",
                            "test_body": "176: public void testCreateNumber() {\n177: // a lot of things can go wrong\n178: assertEquals(\"createNumber(String) 1 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5\"));\n179: assertEquals(\"createNumber(String) 2 failed\", new Integer(\"12345\"), NumberUtils.createNumber(\"12345\"));\n180: assertEquals(\"createNumber(String) 3 failed\", new Double(\"1234.5\"), NumberUtils.createNumber(\"1234.5D\"));\n181: assertEquals(\"createNumber(String) 3 failed\", new Double(\"1234.5\"), NumberUtils.createNumber(\"1234.5d\"));\n182: assertEquals(\"createNumber(String) 4 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5F\"));\n183: assertEquals(\"createNumber(String) 4 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5f\"));\n184: assertEquals(\"createNumber(String) 5 failed\", new Long(Integer.MAX_VALUE + 1L), NumberUtils.createNumber(\"\"\n185: + (Integer.MAX_VALUE + 1L)));\n186: assertEquals(\"createNumber(String) 6 failed\", new Long(12345), NumberUtils.createNumber(\"12345L\"));\n187: assertEquals(\"createNumber(String) 6 failed\", new Long(12345), NumberUtils.createNumber(\"12345l\"));\n188: assertEquals(\"createNumber(String) 7 failed\", new Float(\"-1234.5\"), NumberUtils.createNumber(\"-1234.5\"));\n189: assertEquals(\"createNumber(String) 8 failed\", new Integer(\"-12345\"), NumberUtils.createNumber(\"-12345\"));\n190: assertTrue(\"createNumber(String) 9 failed\", 0xFADE == NumberUtils.createNumber(\"0xFADE\").intValue());\n191: assertTrue(\"createNumber(String) 10 failed\", -0xFADE == NumberUtils.createNumber(\"-0xFADE\").intValue());\n192: assertEquals(\"createNumber(String) 11 failed\", new Double(\"1.1E200\"), NumberUtils.createNumber(\"1.1E200\"));\n193: assertEquals(\"createNumber(String) 12 failed\", new Float(\"1.1E20\"), NumberUtils.createNumber(\"1.1E20\"));\n194: assertEquals(\"createNumber(String) 13 failed\", new Double(\"-1.1E200\"), NumberUtils.createNumber(\"-1.1E200\"));\n195: assertEquals(\"createNumber(String) 14 failed\", new Double(\"1.1E-200\"), NumberUtils.createNumber(\"1.1E-200\"));\n196: assertEquals(\"createNumber(null) failed\", null, NumberUtils.createNumber(null));\n197: assertEquals(\"createNumber(String) failed\", new BigInteger(\"12345678901234567890\"), NumberUtils\n198: .createNumber(\"12345678901234567890L\"));\n199: 200: // jdk 1.2 doesn't support this. unsure about jdk 1.2.2\n201: if (SystemUtils.isJavaVersionAtLeast(1.3f)) {\n202: assertEquals(\"createNumber(String) 15 failed\", new BigDecimal(\"1.1E-700\"), NumberUtils\n203: .createNumber(\"1.1E-700F\"));\n204: }\n205: assertEquals(\"createNumber(String) 16 failed\", new Long(\"10\" + Integer.MAX_VALUE), NumberUtils\n206: .createNumber(\"10\" + Integer.MAX_VALUE + \"L\"));\n207: assertEquals(\"createNumber(String) 17 failed\", new Long(\"10\" + Integer.MAX_VALUE), NumberUtils\n208: .createNumber(\"10\" + Integer.MAX_VALUE));\n209: assertEquals(\"createNumber(String) 18 failed\", new BigInteger(\"10\" + Long.MAX_VALUE), NumberUtils\n210: .createNumber(\"10\" + Long.MAX_VALUE));\n211: 212: // LANG-521\n213: assertEquals(\"createNumber(String) LANG-521 failed\", new Float(\"2.\"), NumberUtils.createNumber(\"2.\"));\n214: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:isEmpty(Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean isEmpty(CharSequence str) {\nreturn str == null || str.length() == 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:isBlank(Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean isBlank(CharSequence str) {\nint strLen;\nif (str == null || (strLen = str.length()) == 0) {\nreturn true;\n}\nfor (int i = 0; i < strLen; i++) {\nif ((Character.isWhitespace(str.charAt(i)) == false)) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:<clinit>()V",
                                    "method_body": "public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n\n/**\n* <p>The <code>file.encoding</code> System Property.</p>\n* <p>File encoding, such as <code>Cp1252</code>.</p>\n*\n* <p>Defaults to <code>null</code> if the runtime does not have\n* security access to read this property or the property does not exist.</p>\n*\n* <p>\n* This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsFloat()F",
                                    "method_body": "private static float getJavaVersionAsFloat() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0f;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n}\ntry {\nreturn Float.parseFloat(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionAsInt()I",
                                    "method_body": "private static int getJavaVersionAsInt() {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn 0;\n}\nString str = JAVA_VERSION_TRIMMED.substring(0, 1);\nstr = str + JAVA_VERSION_TRIMMED.substring(2, 3);\nif (JAVA_VERSION_TRIMMED.length() >= 5) {\nstr = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n} else {\nstr = str + \"0\";\n}\ntry {\nreturn Integer.parseInt(str);\n} catch (Exception ex) {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionTrimmed()Ljava/lang/String;",
                                    "method_body": "private static String getJavaVersionTrimmed() {\nif (JAVA_VERSION != null) {\nfor (int i = 0; i < JAVA_VERSION.length(); i++) {\nchar ch = JAVA_VERSION.charAt(i);\nif (ch >= '0' && ch <= '9') {\nreturn JAVA_VERSION.substring(i);\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getJavaVersionMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getJavaVersionMatches(String versionPrefix) {\nif (JAVA_VERSION_TRIMMED == null) {\nreturn false;\n}\nreturn JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix) {\nif (OS_NAME == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getOSMatches(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\nif (OS_NAME == null || OS_VERSION == null) {\nreturn false;\n}\nreturn OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:getSystemProperty(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String getSystemProperty(String property) {\ntry {\nreturn System.getProperty(property);\n} catch (SecurityException ex) {\n// we are not allowed to look at this property\nSystem.err.println(\n\"Caught a SecurityException reading the system property '\" + property\n+ \"'; the SystemUtils property value will default to null.\"\n);\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.SystemUtils:isJavaVersionAtLeast(F)Z",
                                    "method_body": "public static boolean isJavaVersionAtLeast(float requiredVersion) {\nreturn JAVA_VERSION_FLOAT >= requiredVersion;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:<clinit>()V",
                                    "method_body": "public static final Long LONG_ZERO = new Long(0L);\n/** Reusable Long constant for one. */\npublic static final Long LONG_ONE = new Long(1L);\n/** Reusable Long constant for minus one. */\npublic static final Long LONG_MINUS_ONE = new Long(-1L);\n/** Reusable Integer constant for zero. */\npublic static final Integer INTEGER_ZERO = new Integer(0);\n/** Reusable Integer constant for one. */\npublic static final Integer INTEGER_ONE = new Integer(1);\n/** Reusable Integer constant for minus one. */\npublic static final Integer INTEGER_MINUS_ONE = new Integer(-1);\n/** Reusable Short constant for zero. */\npublic static final Short SHORT_ZERO = new Short((short) 0);\n/** Reusable Short constant for one. */\npublic static final Short SHORT_ONE = new Short((short) 1);\n/** Reusable Short constant for minus one. */\npublic static final Short SHORT_MINUS_ONE = new Short((short) -1);\n/** Reusable Byte constant for zero. */\npublic static final Byte BYTE_ZERO = Byte.valueOf((byte) 0);\n/** Reusable Byte constant for one. */\npublic static final Byte BYTE_ONE = Byte.valueOf((byte) 1);\n/** Reusable Byte constant for minus one. */\npublic static final Byte BYTE_MINUS_ONE = Byte.valueOf((byte) -1);\n/** Reusable Double constant for zero. */\npublic static final Double DOUBLE_ZERO = new Double(0.0d);\n/** Reusable Double constant for one. */\npublic static final Double DOUBLE_ONE = new Double(1.0d);\n/** Reusable Double constant for minus one. */\npublic static final Double DOUBLE_MINUS_ONE = new Double(-1.0d);\n/** Reusable Float constant for zero. */\npublic static final Float FLOAT_ZERO = new Float(0.0f);\n/** Reusable Float constant for one. */\npublic static final Float FLOAT_ONE = new Float(1.0f);\n/** Reusable Float constant for minus one. */\npublic static final Float FLOAT_MINUS_ONE = new Float(-1.0f);\n\n/**\n* <p><code>NumberUtils</code> instances should NOT be constructed in standard programming.\n* Instead, the class should be used as <code>NumberUtils.toInt(\"6\");</code>.</p>\n*\n* <p>This constructor is public to permit tools that require a JavaBean instance\n* to operate.</p>\n*/\npublic NumberUtils() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createNumber(Ljava/lang/String;)Ljava/lang/Number;",
                                    "method_body": "public static Number createNumber(String str) throws NumberFormatException {\nif (str == null) {\nreturn null;\n}\nif (StringUtils.isBlank(str)) {\nthrow new NumberFormatException(\"A blank string is not a valid number\");\n}\nif (str.startsWith(\"--\")) {\n// this is protection for poorness in java.lang.BigDecimal.\n// it accepts this as a legal value, but it does not appear\n// to be in specification of class. OS X Java parses it to\n// a wrong value.\nreturn null;\n}\nif (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\nreturn createInteger(str);\n}\nchar lastChar = str.charAt(str.length() - 1);\nString mant;\nString dec;\nString exp;\nint decPos = str.indexOf('.');\nint expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\nif (decPos > -1) {\n\nif (expPos > -1) {\nif (expPos < decPos) {\nthrow new NumberFormatException(str + \" is not a valid number.\");\n}\ndec = str.substring(decPos + 1, expPos);\n} else {\ndec = str.substring(decPos + 1);\n}\nmant = str.substring(0, decPos);\n} else {\nif (expPos > -1) {\nmant = str.substring(0, expPos);\n} else {\nmant = str;\n}\ndec = null;\n}\nif (!Character.isDigit(lastChar)) {\nif (expPos > -1 && expPos < str.length() - 1) {\nexp = str.substring(expPos + 1, str.length() - 1);\n} else {\nexp = null;\n}\n//Requesting a specific type..\nString numeric = str.substring(0, str.length() - 1);\nboolean allZeros = isAllZeros(mant) && isAllZeros(exp);\nswitch (lastChar) {\ncase 'l' :\ncase 'L' :\nif (dec == null\n&& exp == null\n&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\ntry {\nreturn createLong(numeric);\n} catch (NumberFormatException nfe) {\n//Too big for a long\n}\nreturn createBigInteger(numeric);\n\n}\nthrow new NumberFormatException(str + \" is not a valid number.\");\ncase 'f' :\ncase 'F' :\ntry {\nFloat f = NumberUtils.createFloat(numeric);\nif (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n//If it's too big for a float or the float value = 0 and the string\n//has non-zeros in it, then float does not have the precision we want\nreturn f;\n}\n\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\n//$FALL-THROUGH$\ncase 'd' :\ncase 'D' :\ntry {\nDouble d = NumberUtils.createDouble(numeric);\nif (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\nreturn d;\n}\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\ntry {\nreturn createBigDecimal(numeric);\n} catch (NumberFormatException e) {\n// ignore the bad number\n}\n//$FALL-THROUGH$\ndefault :\nthrow new NumberFormatException(str + \" is not a valid number.\");\n\n}\n} else {\n//User doesn't have a preference on the return type, so let's start\n//small and go from there...\nif (expPos > -1 && expPos < str.length() - 1) {\nexp = str.substring(expPos + 1, str.length());\n} else {\nexp = null;\n}\nif (dec == null && exp == null) {\n//Must be an int,long,bigint\ntry {\nreturn createInteger(str);\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\ntry {\nreturn createLong(str);\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\nreturn createBigInteger(str);\n\n} else {\n//Must be a float,double,BigDec\nboolean allZeros = isAllZeros(mant) && isAllZeros(exp);\ntry {\nFloat f = createFloat(str);\nif (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\nreturn f;\n}\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\ntry {\nDouble d = createDouble(str);\nif (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\nreturn d;\n}\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\n\nreturn createBigDecimal(str);\n\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:isAllZeros(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean isAllZeros(String str) {\nif (str == null) {\nreturn true;\n}\nfor (int i = str.length() - 1; i >= 0; i--) {\nif (str.charAt(i) != '0') {\nreturn false;\n}\n}\nreturn str.length() > 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createFloat(Ljava/lang/String;)Ljava/lang/Float;",
                                    "method_body": "public static Float createFloat(String str) {\nif (str == null) {\nreturn null;\n}\nreturn Float.valueOf(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createDouble(Ljava/lang/String;)Ljava/lang/Double;",
                                    "method_body": "public static Double createDouble(String str) {\nif (str == null) {\nreturn null;\n}\nreturn Double.valueOf(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createInteger(Ljava/lang/String;)Ljava/lang/Integer;",
                                    "method_body": "public static Integer createInteger(String str) {\nif (str == null) {\nreturn null;\n}\n// decode() handles 0xAABD and 0777 (hex and octal) as well.\nreturn Integer.decode(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createLong(Ljava/lang/String;)Ljava/lang/Long;",
                                    "method_body": "public static Long createLong(String str) {\nif (str == null) {\nreturn null;\n}\nreturn Long.valueOf(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createBigInteger(Ljava/lang/String;)Ljava/math/BigInteger;",
                                    "method_body": "public static BigInteger createBigInteger(String str) {\nif (str == null) {\nreturn null;\n}\nreturn new BigInteger(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:createBigDecimal(Ljava/lang/String;)Ljava/math/BigDecimal;",
                                    "method_body": "public static BigDecimal createBigDecimal(String str) {\nif (str == null) {\nreturn null;\n}\n// handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\nif (StringUtils.isBlank(str)) {\nthrow new NumberFormatException(\"A blank string is not a valid number\");\n}\nreturn new BigDecimal(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.math.NumberUtils:isDigits(Ljava/lang/String;)Z",
                                    "method_body": "public static boolean isDigits(String str) {\nif (StringUtils.isEmpty(str)) {\nreturn false;\n}\nfor (int i = 0; i < str.length(); i++) {\nif (!Character.isDigit(str.charAt(i))) {\nreturn false;\n}\n}\nreturn true;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 37,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.ArrayUtilsAddTest.testJira567",
                            "test_body": "32: public void testJira567(){\n33: Number[] n;\n34: // Valid array construction\n35: n = ArrayUtils.addAll(new Number[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)});\n36: assertEquals(2,n.length);\n37: assertEquals(Number.class,n.getClass().getComponentType());\n38: try {\n39: // Invalid - can't store Long in Integer array\n40: n = ArrayUtils.addAll(new Integer[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)});\n41: fail(\"Should have generated IllegalArgumentException\");\n42: } catch (IllegalArgumentException expected) {\n43: }\n44: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:<clinit>()V",
                                    "method_body": "public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n/**\n* An empty immutable <code>Class</code> array.\n*/\npublic static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n/**\n* An empty immutable <code>String</code> array.\n*/\npublic static final String[] EMPTY_STRING_ARRAY = new String[0];\n/**\n* An empty immutable <code>long</code> array.\n*/\npublic static final long[] EMPTY_LONG_ARRAY = new long[0];\n/**\n* An empty immutable <code>Long</code> array.\n*/\npublic static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];\n/**\n* An empty immutable <code>int</code> array.\n*/\npublic static final int[] EMPTY_INT_ARRAY = new int[0];\n/**\n* An empty immutable <code>Integer</code> array.\n*/\npublic static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n/**\n* An empty immutable <code>short</code> array.\n*/\npublic static final short[] EMPTY_SHORT_ARRAY = new short[0];\n/**\n* An empty immutable <code>Short</code> array.\n*/\npublic static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0];\n/**\n* An empty immutable <code>byte</code> array.\n*/\npublic static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n/**\n* An empty immutable <code>Byte</code> array.\n*/\npublic static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];\n/**\n* An empty immutable <code>double</code> array.\n*/\npublic static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n/**\n* An empty immutable <code>Double</code> array.\n*/\npublic static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0];\n/**\n* An empty immutable <code>float</code> array.\n*/\npublic static final float[] EMPTY_FLOAT_ARRAY = new float[0];\n/**\n* An empty immutable <code>Float</code> array.\n*/\npublic static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0];\n/**\n* An empty immutable <code>boolean</code> array.\n*/\npublic static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];\n/**\n* An empty immutable <code>Boolean</code> array.\n*/\npublic static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];\n/**\n* An empty immutable <code>char</code> array.\n*/\npublic static final char[] EMPTY_CHAR_ARRAY = new char[0];\n/**\n* An empty immutable <code>Character</code> array.\n*/\npublic static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n\n/**\n* The index value when an element is not found in a list or array: <code>-1</code>.\n* This value is returned by methods in this class and can also be used in comparisons with values returned by\n* various method from {@link java.util.List}."
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.ArrayUtils:addAll([Ljava/lang/Object;[Ljava/lang/Object;)[Ljava/lang/Object;",
                                    "method_body": "public static <T> T[] addAll(T[] array1, T... array2) {\nif (array1 == null) {\nreturn clone(array2);\n} else if (array2 == null) {\nreturn clone(array1);\n}\nfinal Class<?> type1 = array1.getClass().getComponentType();\nT[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\nSystem.arraycopy(array1, 0, joinedArray, 0, array1.length);\nSystem.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n// Check if problem is incompatible types\nreturn joinedArray;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 38,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.time.FastDateFormatTest.testLang538",
                            "test_body": "339: public void testLang538() {\n340: final String dateTime = \"2009-10-16T16:42:16.000Z\";\n341: 342: // more commonly constructed with: cal = new GregorianCalendar(2009, 9, 16, 8, 42, 16)\n343: // for the unit test to work in any time zone, constructing with GMT-8 rather than default locale time zone\n344: GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-8\"));\n345: cal.clear();\n346: cal.set(2009, 9, 16, 8, 42, 16);\n347: 348: FastDateFormat format = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\", TimeZone.getTimeZone(\"GMT\"));\n349: assertEquals(\"dateTime\", dateTime, format.format(cal));\n350: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.Validate:isTrue(ZLjava/lang/String;J)V",
                                    "method_body": "public static void isTrue(boolean expression, String message, long value) {\nif (expression == false) {\nthrow new IllegalArgumentException(String.format(message, Long.valueOf(value)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:<init>(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)V",
                                    "method_body": "protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {\nsuper();\nif (pattern == null) {\nthrow new IllegalArgumentException(\"The pattern must not be null\");\n}\nmPattern = pattern;\n\nmTimeZoneForced = (timeZone != null);\nif (timeZone == null) {\ntimeZone = TimeZone.getDefault();\n}\nmTimeZone = timeZone;\n\nmLocaleForced = (locale != null);\nif (locale == null) {\nlocale = Locale.getDefault();\n}\nmLocale = locale;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\n/**\n* FULL locale dependent date or time style.\n*/\npublic static final int FULL = DateFormat.FULL;\n/**\n* LONG locale dependent date or time style.\n*/\npublic static final int LONG = DateFormat.LONG;\n/**\n* MEDIUM locale dependent date or time style.\n*/\npublic static final int MEDIUM = DateFormat.MEDIUM;\n/**\n* SHORT locale dependent date or time style.\n*/\npublic static final int SHORT = DateFormat.SHORT;\n\n//@GuardedBy(\"this\")\nprivate static String cDefaultPattern; // lazily initialised by getInstance()\n\nprivate static final Map<FastDateFormat, FastDateFormat> cInstanceCache = new HashMap<FastDateFormat, FastDateFormat>(7);\nprivate static final Map<Object, FastDateFormat> cDateInstanceCache = new HashMap<Object, FastDateFormat>(7);\nprivate static final Map<Object, FastDateFormat> cTimeInstanceCache = new HashMap<Object, FastDateFormat>(7);\nprivate static final Map<Object, FastDateFormat> cDateTimeInstanceCache = new HashMap<Object, FastDateFormat>(7);\nprivate static final Map<Object, String> cTimeZoneDisplayCache = new HashMap<Object, String>(7);\n\n/**\n* The pattern.\n*/\nprivate final String mPattern;\n/**\n* The time zone.\n*/\nprivate final TimeZone mTimeZone;\n/**\n* Whether the time zone overrides any on Calendars.\n*/\nprivate final boolean mTimeZoneForced;\n/**\n* The locale.\n*/\nprivate final Locale mLocale;\n/**\n* Whether the locale overrides the default.\n*/\nprivate final boolean mLocaleForced;\n/**\n* The parsed rules.\n*/\nprivate transient Rule[] mRules;\n/**\n* The estimated maximum length.\n*/\nprivate transient int mMaxLengthEstimate;\n\n//-----------------------------------------------------------------------\n/**\n* <p>Gets a formatter instance using the default pattern in the\n* default locale.</p>\n*\n* @return a date/time formatter\n*/\npublic static FastDateFormat getInstance() {\nreturn getInstance(getDefaultPattern(), null, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:getInstance(Ljava/lang/String;Ljava/util/TimeZone;)Lorg/apache/commons/lang3/time/FastDateFormat;",
                                    "method_body": "public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {\nreturn getInstance(pattern, timeZone, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:getInstance(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)Lorg/apache/commons/lang3/time/FastDateFormat;",
                                    "method_body": "public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {\nFastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);\nFastDateFormat format = cInstanceCache.get(emptyFormat);\nif (format == null) {\nformat = emptyFormat;\nformat.init();  // convert shell format into usable one\ncInstanceCache.put(format, format);  // this is OK!\n}\nreturn format;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:init()V",
                                    "method_body": "protected void init() {\nList<Rule> rulesList = parsePattern();\nmRules = rulesList.toArray(new Rule[rulesList.size()]);\n\nint len = 0;\nfor (int i=mRules.length; --i >= 0; ) {\nlen += mRules[i].estimateLength();\n}\n\nmMaxLengthEstimate = len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:parsePattern()Ljava/util/List;",
                                    "method_body": "protected List<Rule> parsePattern() {\nDateFormatSymbols symbols = new DateFormatSymbols(mLocale);\nList<Rule> rules = new ArrayList<Rule>();\n\nString[] ERAs = symbols.getEras();\nString[] months = symbols.getMonths();\nString[] shortMonths = symbols.getShortMonths();\nString[] weekdays = symbols.getWeekdays();\nString[] shortWeekdays = symbols.getShortWeekdays();\nString[] AmPmStrings = symbols.getAmPmStrings();\n\nint length = mPattern.length();\nint[] indexRef = new int[1];\n\nfor (int i = 0; i < length; i++) {\nindexRef[0] = i;\nString token = parseToken(mPattern, indexRef);\ni = indexRef[0];\n\nint tokenLen = token.length();\nif (tokenLen == 0) {\nbreak;\n}\n\nRule rule;\nchar c = token.charAt(0);\n\nswitch (c) {\ncase 'G': // era designator (text)\nrule = new TextField(Calendar.ERA, ERAs);\nbreak;\ncase 'y': // year (number)\nif (tokenLen >= 4) {\nrule = selectNumberRule(Calendar.YEAR, tokenLen);\n} else {\nrule = TwoDigitYearField.INSTANCE;\n}\nbreak;\ncase 'M': // month in year (text and number)\nif (tokenLen >= 4) {\nrule = new TextField(Calendar.MONTH, months);\n} else if (tokenLen == 3) {\nrule = new TextField(Calendar.MONTH, shortMonths);\n} else if (tokenLen == 2) {\nrule = TwoDigitMonthField.INSTANCE;\n} else {\nrule = UnpaddedMonthField.INSTANCE;\n}\nbreak;\ncase 'd': // day in month (number)\nrule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\nbreak;\ncase 'h': // hour in am/pm (number, 1..12)\nrule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\nbreak;\ncase 'H': // hour in day (number, 0..23)\nrule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\nbreak;\ncase 'm': // minute in hour (number)\nrule = selectNumberRule(Calendar.MINUTE, tokenLen);\nbreak;\ncase 's': // second in minute (number)\nrule = selectNumberRule(Calendar.SECOND, tokenLen);\nbreak;\ncase 'S': // millisecond (number)\nrule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\nbreak;\ncase 'E': // day in week (text)\nrule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\nbreak;\ncase 'D': // day in year (number)\nrule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\nbreak;\ncase 'F': // day of week in month (number)\nrule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\nbreak;\ncase 'w': // week in year (number)\nrule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\nbreak;\ncase 'W': // week in month (number)\nrule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\nbreak;\ncase 'a': // am/pm marker (text)\nrule = new TextField(Calendar.AM_PM, AmPmStrings);\nbreak;\ncase 'k': // hour in day (1..24)\nrule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\nbreak;\ncase 'K': // hour in am/pm (0..11)\nrule = selectNumberRule(Calendar.HOUR, tokenLen);\nbreak;\ncase 'z': // time zone (text)\nif (tokenLen >= 4) {\nrule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.LONG);\n} else {\nrule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.SHORT);\n}\nbreak;\ncase 'Z': // time zone (value)\nif (tokenLen == 1) {\nrule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n} else {\nrule = TimeZoneNumberRule.INSTANCE_COLON;\n}\nbreak;\ncase '\\'': // literal text\nString sub = token.substring(1);\nif (sub.length() == 1) {\nrule = new CharacterLiteral(sub.charAt(0));\n} else {\nrule = new StringLiteral(sub);\n}\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"Illegal pattern component: \" + token);\n}\n\nrules.add(rule);\n}\n\nreturn rules;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
                                    "method_body": "protected String parseToken(String pattern, int[] indexRef) {\nStringBuilder buf = new StringBuilder();\n\nint i = indexRef[0];\nint length = pattern.length();\n\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n// Scan a run of the same character, which indicates a time\n// pattern.\nbuf.append(c);\n\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append(c);\ni++;\n} else {\nbreak;\n}\n}\n} else {\n// This will identify token as text.\nbuf.append('\\'');\n\nboolean inLiteral = false;\n\nfor (; i < length; i++) {\nc = pattern.charAt(i);\n\nif (c == '\\'') {\nif (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n// '' is treated as escaped '\ni++;\nbuf.append(c);\n} else {\ninLiteral = !inLiteral;\n}\n} else if (!inLiteral &&\n(c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\ni--;\nbreak;\n} else {\nbuf.append(c);\n}\n}\n}\n\nindexRef[0] = i;\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:selectNumberRule(II)Lorg/apache/commons/lang3/time/FastDateFormat$NumberRule;",
                                    "method_body": "protected NumberRule selectNumberRule(int field, int padding) {\nswitch (padding) {\ncase 1:\nreturn new UnpaddedNumberField(field);\ncase 2:\nreturn new TwoDigitNumberField(field);\ndefault:\nreturn new PaddedNumberField(field, padding);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:format(Ljava/util/Calendar;)Ljava/lang/String;",
                                    "method_body": "public String format(Calendar calendar) {\nreturn format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:format(Ljava/util/Calendar;Ljava/lang/StringBuffer;)Ljava/lang/StringBuffer;",
                                    "method_body": "public StringBuffer format(Calendar calendar, StringBuffer buf) {\nif (mTimeZoneForced) {\ncalendar = (Calendar) calendar.clone();\ncalendar.setTimeZone(mTimeZone);\n}\nreturn applyRules(calendar, buf);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:applyRules(Ljava/util/Calendar;Ljava/lang/StringBuffer;)Ljava/lang/StringBuffer;",
                                    "method_body": "protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\nRule[] rules = mRules;\nint len = mRules.length;\nfor (int i = 0; i < len; i++) {\nrules[i].appendTo(buf, calendar);\n}\nreturn buf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat:hashCode()I",
                                    "method_body": "public int hashCode() {\nint total = 0;\ntotal += mPattern.hashCode();\ntotal += mTimeZone.hashCode();\ntotal += (mTimeZoneForced ? 1 : 0);\ntotal += mLocale.hashCode();\ntotal += (mLocaleForced ? 1 : 0);\nreturn total;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$PaddedNumberField:<init>(II)V",
                                    "method_body": "PaddedNumberField(int field, int size) {\nif (size < 3) {\n// Should use UnpaddedNumberField or TwoDigitNumberField.\nthrow new IllegalArgumentException();\n}\nmField = field;\nmSize = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$PaddedNumberField:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nreturn 4;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$PaddedNumberField:appendTo(Ljava/lang/StringBuffer;Ljava/util/Calendar;)V",
                                    "method_body": "public void appendTo(StringBuffer buffer, Calendar calendar) {\nappendTo(buffer, calendar.get(mField));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$PaddedNumberField:appendTo(Ljava/lang/StringBuffer;I)V",
                                    "method_body": "public final void appendTo(StringBuffer buffer, int value) {\nif (value < 100) {\nfor (int i = mSize; --i >= 2; ) {\nbuffer.append('0');\n}\nbuffer.append((char)(value / 10 + '0'));\nbuffer.append((char)(value % 10 + '0'));\n} else {\nint digits;\nif (value < 1000) {\ndigits = 3;\n} else {\nValidate.isTrue(value > -1, \"Negative values should not be possible\", value);\ndigits = Integer.toString(value).length();\n}\nfor (int i = mSize; --i >= digits; ) {\nbuffer.append('0');\n}\nbuffer.append(Integer.toString(value));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$CharacterLiteral:<init>(C)V",
                                    "method_body": "void appendTo(StringBuffer buffer, int value);\n}\n\n/**\n* <p>Inner class to output a constant single character.</p>\n*/\nprivate static class CharacterLiteral implements Rule {\nprivate final char mValue;\n\n/**\n* Constructs a new instance of <code>CharacterLiteral</code>\n* to hold the specified value.\n*\n* @param value the character literal\n*/\nCharacterLiteral(char value) {\nmValue = value;\n}\n\n/**\n* {@inheritDoc}\n*/\npublic int estimateLength() {\nreturn 1;\n}\n\n/**\n* {@inheritDoc}\n*/\npublic void appendTo(StringBuffer buffer, Calendar calendar) {\nbuffer.append(mValue);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$CharacterLiteral:estimateLength()I",
                                    "method_body": "void appendTo(StringBuffer buffer, int value);\n}\n\n/**\n* <p>Inner class to output a constant single character.</p>\n*/\nprivate static class CharacterLiteral implements Rule {\nprivate final char mValue;\n\n/**\n* Constructs a new instance of <code>CharacterLiteral</code>\n* to hold the specified value.\n*\n* @param value the character literal\n*/\nCharacterLiteral(char value) {\nmValue = value;\n}\n\n/**\n* {@inheritDoc}\n*/\npublic int estimateLength() {\nreturn 1;\n}\n\n/**\n* {@inheritDoc}\n*/\npublic void appendTo(StringBuffer buffer, Calendar calendar) {\nbuffer.append(mValue);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$CharacterLiteral:appendTo(Ljava/lang/StringBuffer;Ljava/util/Calendar;)V",
                                    "method_body": "void appendTo(StringBuffer buffer, int value);\n}\n\n/**\n* <p>Inner class to output a constant single character.</p>\n*/\nprivate static class CharacterLiteral implements Rule {\nprivate final char mValue;\n\n/**\n* Constructs a new instance of <code>CharacterLiteral</code>\n* to hold the specified value.\n*\n* @param value the character literal\n*/\nCharacterLiteral(char value) {\nmValue = value;\n}\n\n/**\n* {@inheritDoc}\n*/\npublic int estimateLength() {\nreturn 1;\n}\n\n/**\n* {@inheritDoc}\n*/\npublic void appendTo(StringBuffer buffer, Calendar calendar) {\nbuffer.append(mValue);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$TwoDigitMonthField:<init>()V",
                                    "method_body": "TwoDigitMonthField() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$TwoDigitMonthField:<clinit>()V",
                                    "method_body": "static final TwoDigitMonthField INSTANCE = new TwoDigitMonthField();\n\n/**\n* Constructs an instance of <code>TwoDigitMonthField</code>.\n*/\nTwoDigitMonthField() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$TwoDigitMonthField:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nreturn 2;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$TwoDigitMonthField:appendTo(Ljava/lang/StringBuffer;Ljava/util/Calendar;)V",
                                    "method_body": "public void appendTo(StringBuffer buffer, Calendar calendar) {\nappendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$TwoDigitMonthField:appendTo(Ljava/lang/StringBuffer;I)V",
                                    "method_body": "public final void appendTo(StringBuffer buffer, int value) {\nbuffer.append((char)(value / 10 + '0'));\nbuffer.append((char)(value % 10 + '0'));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$TwoDigitNumberField:<init>(I)V",
                                    "method_body": "TwoDigitNumberField(int field) {\nmField = field;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$TwoDigitNumberField:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nreturn 2;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$TwoDigitNumberField:appendTo(Ljava/lang/StringBuffer;Ljava/util/Calendar;)V",
                                    "method_body": "public void appendTo(StringBuffer buffer, Calendar calendar) {\nappendTo(buffer, calendar.get(mField));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.time.FastDateFormat$TwoDigitNumberField:appendTo(Ljava/lang/StringBuffer;I)V",
                                    "method_body": "public final void appendTo(StringBuffer buffer, int value) {\nif (value < 100) {\nbuffer.append((char)(value / 10 + '0'));\nbuffer.append((char)(value % 10 + '0'));\n} else {\nbuffer.append(Integer.toString(value));\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 39,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang3.StringUtilsTest.testReplace_StringStringArrayStringArray",
                            "test_body": "1009: public void testReplace_StringStringArrayStringArray() {\n1010: 1011: 1012: //JAVADOC TESTS START\n1013: assertNull(StringUtils.replaceEach(null, new String[]{\"a\"}, new String[]{\"b\"}));\n1014: assertEquals(StringUtils.replaceEach(\"\", new String[]{\"a\"}, new String[]{\"b\"}),\"\");\n1015: assertEquals(StringUtils.replaceEach(\"aba\", null, null),\"aba\");\n1016: assertEquals(StringUtils.replaceEach(\"aba\", new String[0], null),\"aba\");\n1017: assertEquals(StringUtils.replaceEach(\"aba\", null, new String[0]),\"aba\");\n1018: assertEquals(StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null),\"aba\");\n1019: 1020: assertEquals(StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}),\"b\");\n1021: assertEquals(StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}),\"aba\");\n1022: assertEquals(StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}),\"wcte\");\n1023: assertEquals(StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}),\"dcte\");\n1024: //JAVADOC TESTS END\n1025: 1026: assertEquals(\"bcc\", StringUtils.replaceEach(\"abc\", new String[]{\"a\", \"b\"}, new String[]{\"b\", \"c\"}));\n1027: assertEquals(\"q651.506bera\", StringUtils.replaceEach(\"d216.102oren\",\n1028: new String[]{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \n1029: \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"A\", \"B\", \"C\", \"D\", \n1030: \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \n1031: \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"},\n1032: new String[]{\"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"a\", \n1033: \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"N\", \"O\", \"P\", \"Q\", \n1034: \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \n1035: \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"5\", \"6\", \"7\", \"8\", \"9\", \"1\", \"2\", \"3\", \"4\"}));\n1036: 1037: // Test null safety inside arrays - LANG-552\n1038: assertEquals(StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{null}),\"aba\");\n1039: assertEquals(StringUtils.replaceEach(\"aba\", new String[]{\"a\", \"b\"}, new String[]{\"c\", null}),\"cbc\");\n1040: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:replaceEach(Ljava/lang/String;[Ljava/lang/String;[Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public static String replaceEach(String text, String[] searchList, String[] replacementList) {\nreturn replaceEach(text, searchList, replacementList, false, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang3.StringUtils:replaceEach(Ljava/lang/String;[Ljava/lang/String;[Ljava/lang/String;ZI)Ljava/lang/String;",
                                    "method_body": "private static String replaceEach(String text, String[] searchList, String[] replacementList,\nboolean repeat, int timeToLive)\n{\n\n// mchyzer Performance note: This creates very few new objects (one major goal)\n// let me know if there are performance requests, we can create a harness to measure\n\nif (text == null || text.length() == 0 || searchList == null ||\nsearchList.length == 0 || replacementList == null || replacementList.length == 0)\n{\nreturn text;\n}\n\n// if recursing, this shouldnt be less than 0\nif (timeToLive < 0) {\nthrow new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n}\n\nint searchLength = searchList.length;\nint replacementLength = replacementList.length;\n\n// make sure lengths are ok, these need to be equal\nif (searchLength != replacementLength) {\nthrow new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n+ searchLength\n+ \" vs \"\n+ replacementLength);\n}\n\n// keep track of which still have matches\nboolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n// index on index that the match was found\nint textIndex = -1;\nint replaceIndex = -1;\nint tempIndex = -1;\n\n// index of replace array that will replace the search string found\n// NOTE: logic duplicated below START\nfor (int i = 0; i < searchLength; i++) {\nif (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\nsearchList[i].length() == 0 || replacementList[i] == null)\n{\ncontinue;\n}\ntempIndex = text.indexOf(searchList[i]);\n\n// see if we need to keep searching for this\nif (tempIndex == -1) {\nnoMoreMatchesForReplIndex[i] = true;\n} else {\nif (textIndex == -1 || tempIndex < textIndex) {\ntextIndex = tempIndex;\nreplaceIndex = i;\n}\n}\n}\n// NOTE: logic mostly below END\n\n// no search strings found, we are done\nif (textIndex == -1) {\nreturn text;\n}\n\nint start = 0;\n\n// get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\nint increase = 0;\n\n// count the replacement text elements that are larger than their corresponding text being replaced\nfor (int i = 0; i < searchList.length; i++) {\nint greater = replacementList[i].length() - searchList[i].length();\nif (greater > 0) {\nincrease += 3 * greater; // assume 3 matches\n}\n}\n// have upper-bound at 20% increase, then let Java take over\nincrease = Math.min(increase, text.length() / 5);\n\nStringBuilder buf = new StringBuilder(text.length() + increase);\n\nwhile (textIndex != -1) {\n\nfor (int i = start; i < textIndex; i++) {\nbuf.append(text.charAt(i));\n}\nbuf.append(replacementList[replaceIndex]);\n\nstart = textIndex + searchList[replaceIndex].length();\n\ntextIndex = -1;\nreplaceIndex = -1;\ntempIndex = -1;\n// find the next earliest match\n// NOTE: logic mostly duplicated above START\nfor (int i = 0; i < searchLength; i++) {\nif (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\nsearchList[i].length() == 0 || replacementList[i] == null)\n{\ncontinue;\n}\ntempIndex = text.indexOf(searchList[i], start);\n\n// see if we need to keep searching for this\nif (tempIndex == -1) {\nnoMoreMatchesForReplIndex[i] = true;\n} else {\nif (textIndex == -1 || tempIndex < textIndex) {\ntextIndex = tempIndex;\nreplaceIndex = i;\n}\n}\n}\n// NOTE: logic duplicated above END\n\n}\nint textLength = text.length();\nfor (int i = start; i < textLength; i++) {\nbuf.append(text.charAt(i));\n}\nString result = buf.toString();\nif (!repeat) {\nreturn result;\n}\n\nreturn replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 40,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang.StringUtilsEqualsIndexOfTest.testContainsIgnoreCase_LocaleIndependence",
                            "test_body": "316: public void testContainsIgnoreCase_LocaleIndependence() {\n317: Locale orig = Locale.getDefault();\n318: 319: Locale[] locales = { Locale.ENGLISH, new Locale(\"tr\"), Locale.getDefault() };\n320: 321: String[][] tdata = { \n322: { \"i\", \"I\" },\n323: { \"I\", \"i\" },\n324: { \"\\u03C2\", \"\\u03C3\" },\n325: { \"\\u03A3\", \"\\u03C2\" },\n326: { \"\\u03A3\", \"\\u03C3\" },\n327: };\n328: 329: String[][] fdata = { \n330: { \"\\u00DF\", \"SS\" },\n331: };\n332: 333: try {\n334: for (int i = 0; i < locales.length; i++) {\n335: Locale.setDefault(locales[i]);\n336: for (int j = 0; j < tdata.length; j++) {\n337: assertTrue(Locale.getDefault() + \": \" + j + \" \" + tdata[j][0] + \" \" + tdata[j][1], StringUtils\n338: .containsIgnoreCase(tdata[j][0], tdata[j][1]));\n339: }\n340: for (int j = 0; j < fdata.length; j++) {\n341: assertFalse(Locale.getDefault() + \": \" + j + \" \" + fdata[j][0] + \" \" + fdata[j][1], StringUtils\n342: .containsIgnoreCase(fdata[j][0], fdata[j][1]));\n343: }\n344: }\n345: } finally {\n346: Locale.setDefault(orig);\n347: }\n348: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.StringUtils:contains(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "public static boolean contains(String str, String searchStr) {\nif (str == null || searchStr == null) {\nreturn false;\n}\nreturn str.indexOf(searchStr) >= 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.StringUtils:containsIgnoreCase(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "public static boolean containsIgnoreCase(String str, String searchStr) {\nif (str == null || searchStr == null) {\nreturn false;\n}\nreturn contains(str.toUpperCase(), searchStr.toUpperCase());\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 41,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang.ClassUtilsTest.test_getPackageName_Class",
                            "test_body": "140: public void test_getPackageName_Class() {\n141: assertEquals(\"java.lang\", ClassUtils.getPackageName(String.class));\n142: assertEquals(\"java.util\", ClassUtils.getPackageName(Map.Entry.class));\n143: assertEquals(\"\", ClassUtils.getPackageName((Class)null));\n144: 145: // LANG-535\n146: assertEquals(\"java.lang\", ClassUtils.getPackageName(String[].class));\n147: 148: // Primitive Arrays\n149: assertEquals(\"\", ClassUtils.getPackageName(boolean[].class));\n150: assertEquals(\"\", ClassUtils.getPackageName(byte[].class));\n151: assertEquals(\"\", ClassUtils.getPackageName(char[].class));\n152: assertEquals(\"\", ClassUtils.getPackageName(short[].class));\n153: assertEquals(\"\", ClassUtils.getPackageName(int[].class));\n154: assertEquals(\"\", ClassUtils.getPackageName(long[].class));\n155: assertEquals(\"\", ClassUtils.getPackageName(float[].class));\n156: assertEquals(\"\", ClassUtils.getPackageName(double[].class));\n157: 158: // Arrays of arrays of ...\n159: assertEquals(\"java.lang\", ClassUtils.getPackageName(String[][].class));\n160: assertEquals(\"java.lang\", ClassUtils.getPackageName(String[][][].class));\n161: assertEquals(\"java.lang\", ClassUtils.getPackageName(String[][][][].class));\n162: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.ClassUtils:<clinit>()V",
                                    "method_body": "public static final char PACKAGE_SEPARATOR_CHAR = '.';\n\n/**\n* <p>The package separator String: <code>\"&#x2e;\"</code>.</p>\n*/\npublic static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR);\n\n/**\n* <p>The inner class separator character: <code>'$' == {@value}</code>.</p>"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.ClassUtils:addAbbreviation(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "private static void addAbbreviation(String primitive, String abbreviation) {\nabbreviationMap.put(primitive, abbreviation);\nreverseAbbreviationMap.put(abbreviation, primitive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.ClassUtils:getPackageName(Ljava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static String getPackageName(Class<?> cls) {\nif (cls == null) {\nreturn StringUtils.EMPTY;\n}\nreturn getPackageName(cls.getName());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.ClassUtils:getPackageName(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public static String getPackageName(String className) {\nif (className == null) {\nreturn StringUtils.EMPTY;\n}\n\n// Strip array encoding\n// Strip Object type encoding\n\nint i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\nif (i == -1) {\nreturn StringUtils.EMPTY;\n}\nreturn className.substring(0, i);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang.ClassUtilsTest.test_getShortClassName_Class",
                            "test_body": "91: public void test_getShortClassName_Class() {\n92: assertEquals(\"ClassUtils\", ClassUtils.getShortClassName(ClassUtils.class));\n93: assertEquals(\"Map.Entry\", ClassUtils.getShortClassName(Map.Entry.class));\n94: assertEquals(\"\", ClassUtils.getShortClassName((Class) null));\n95: 96: // LANG-535\n97: assertEquals(\"String[]\", ClassUtils.getShortClassName(String[].class));\n98: assertEquals(\"Map.Entry[]\", ClassUtils.getShortClassName(Map.Entry[].class));\n99: 100: // Primitives\n101: assertEquals(\"boolean\", ClassUtils.getShortClassName(boolean.class));\n102: assertEquals(\"byte\", ClassUtils.getShortClassName(byte.class));\n103: assertEquals(\"char\", ClassUtils.getShortClassName(char.class));\n104: assertEquals(\"short\", ClassUtils.getShortClassName(short.class));\n105: assertEquals(\"int\", ClassUtils.getShortClassName(int.class));\n106: assertEquals(\"long\", ClassUtils.getShortClassName(long.class));\n107: assertEquals(\"float\", ClassUtils.getShortClassName(float.class));\n108: assertEquals(\"double\", ClassUtils.getShortClassName(double.class));\n109: 110: // Primitive Arrays\n111: assertEquals(\"boolean[]\", ClassUtils.getShortClassName(boolean[].class));\n112: assertEquals(\"byte[]\", ClassUtils.getShortClassName(byte[].class));\n113: assertEquals(\"char[]\", ClassUtils.getShortClassName(char[].class));\n114: assertEquals(\"short[]\", ClassUtils.getShortClassName(short[].class));\n115: assertEquals(\"int[]\", ClassUtils.getShortClassName(int[].class));\n116: assertEquals(\"long[]\", ClassUtils.getShortClassName(long[].class));\n117: assertEquals(\"float[]\", ClassUtils.getShortClassName(float[].class));\n118: assertEquals(\"double[]\", ClassUtils.getShortClassName(double[].class));\n119: 120: // Arrays of arrays of ...\n121: assertEquals(\"String[][]\", ClassUtils.getShortClassName(String[][].class));\n122: assertEquals(\"String[][][]\", ClassUtils.getShortClassName(String[][][].class));\n123: assertEquals(\"String[][][][]\", ClassUtils.getShortClassName(String[][][][].class));\n124: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.ClassUtils:<clinit>()V",
                                    "method_body": "public static final char PACKAGE_SEPARATOR_CHAR = '.';\n\n/**\n* <p>The package separator String: <code>\"&#x2e;\"</code>.</p>\n*/\npublic static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR);\n\n/**\n* <p>The inner class separator character: <code>'$' == {@value}</code>.</p>"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.ClassUtils:addAbbreviation(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "private static void addAbbreviation(String primitive, String abbreviation) {\nabbreviationMap.put(primitive, abbreviation);\nreverseAbbreviationMap.put(abbreviation, primitive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.ClassUtils:getShortClassName(Ljava/lang/Class;)Ljava/lang/String;",
                                    "method_body": "public static String getShortClassName(Class<?> cls) {\nif (cls == null) {\nreturn StringUtils.EMPTY;\n}\nreturn getShortClassName(cls.getName());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.ClassUtils:getShortClassName(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public static String getShortClassName(String className) {\nif (className == null) {\nreturn StringUtils.EMPTY;\n}\nif (className.length() == 0) {\nreturn StringUtils.EMPTY;\n}\n\n\n// Handle array encoding\n// Strip Object type encoding\n\n\nint lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\nint innerIdx = className.indexOf(\nINNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);\nString out = className.substring(lastDotIdx + 1);\nif (innerIdx != -1) {\nout = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n}\nreturn out;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 42,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang.StringEscapeUtilsTest.testEscapeHtmlHighUnicode",
                            "test_body": "420: public void testEscapeHtmlHighUnicode() throws java.io.UnsupportedEncodingException {\n421: // this is the utf8 representation of the character:\n422: // COUNTING ROD UNIT DIGIT THREE\n423: // in unicode\n424: // codepoint: U+1D362\n425: byte[] data = new byte[] { (byte)0xF0, (byte)0x9D, (byte)0x8D, (byte)0xA2 };\n426: 427: String escaped = StringEscapeUtils.escapeHtml( new String(data, \"UTF8\") );\n428: String unescaped = StringEscapeUtils.unescapeHtml( escaped );\n429: 430: assertEquals( \"High unicode was not escaped correctly\", \"&#119650;\", escaped);\n431: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.StringEscapeUtils:<clinit>()V",
                                    "method_body": "private static final char CSV_DELIMITER = ',';\nprivate static final char CSV_QUOTE = '\"';\nprivate static final String CSV_QUOTE_STR = String.valueOf(CSV_QUOTE);\nprivate static final char[] CSV_SEARCH_CHARS = new char[] {CSV_DELIMITER, CSV_QUOTE, CharUtils.CR, CharUtils.LF};"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.StringEscapeUtils:escapeHtml(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public static String escapeHtml(String str) {\nif (str == null) {\nreturn null;\n}\ntry {\nStringWriter writer = new StringWriter ((int)(str.length() * 1.5));\nescapeHtml(writer, str);\nreturn writer.toString();\n} catch (IOException ioe) {\n//should be impossible\nthrow new UnhandledException(ioe);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.StringEscapeUtils:escapeHtml(Ljava/io/Writer;Ljava/lang/String;)V",
                                    "method_body": "public static void escapeHtml(Writer writer, String string) throws IOException {\nif (writer == null ) {\nthrow new IllegalArgumentException (\"The Writer must not be null.\");\n}\nif (string == null) {\nreturn;\n}\nEntities.HTML40.escape(writer, string);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.StringEscapeUtils:unescapeHtml(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public static String unescapeHtml(String str) {\nif (str == null) {\nreturn null;\n}\ntry {\nStringWriter writer = new StringWriter ((int)(str.length() * 1.5));\nunescapeHtml(writer, str);\nreturn writer.toString();\n} catch (IOException ioe) {\n//should be impossible\nthrow new UnhandledException(ioe);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.StringEscapeUtils:unescapeHtml(Ljava/io/Writer;Ljava/lang/String;)V",
                                    "method_body": "public static void unescapeHtml(Writer writer, String string) throws IOException {\nif (writer == null ) {\nthrow new IllegalArgumentException (\"The Writer must not be null.\");\n}\nif (string == null) {\nreturn;\n}\nEntities.HTML40.unescape(writer, string);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.Entities:<clinit>()V",
                                    "method_body": "private static final String[][] BASIC_ARRAY = {{\"quot\", \"34\"}, // \" - double-quote\n{\"amp\", \"38\"}, // & - ampersand\n{\"lt\", \"60\"}, // < - less-than\n{\"gt\", \"62\"}, // > - greater-than\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.Entities:fillWithHtml40Entities(Lorg/apache/commons/lang/Entities;)V",
                                    "method_body": "static void fillWithHtml40Entities(Entities entities) {\nentities.addEntities(BASIC_ARRAY);\nentities.addEntities(ISO8859_1_ARRAY);\nentities.addEntities(HTML40_ARRAY);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.Entities:addEntities([[Ljava/lang/String;)V",
                                    "method_body": "public void addEntities(String[][] entityArray) {\nfor (int i = 0; i < entityArray.length; ++i) {\naddEntity(entityArray[i][0], Integer.parseInt(entityArray[i][1]));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.Entities:addEntity(Ljava/lang/String;I)V",
                                    "method_body": "public void addEntity(String name, int value) {\nmap.add(name, value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.Entities:entityName(I)Ljava/lang/String;",
                                    "method_body": "public String entityName(int value) {\nreturn map.name(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.Entities:escape(Ljava/io/Writer;Ljava/lang/String;)V",
                                    "method_body": "public void escape(Writer writer, String str) throws IOException {\nint len = str.length();\nfor (int i = 0; i < len; i++) {\nchar c = str.charAt(i);\nString entityName = this.entityName(c);\nif (entityName == null) {\nif (c > 0x7F) {\nwriter.write(\"&#\");\nwriter.write(Integer.toString(c, 10));\nwriter.write(';');\n} else {\nwriter.write(c);\n}\n} else {\nwriter.write('&');\nwriter.write(entityName);\nwriter.write(';');\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.Entities:unescape(Ljava/io/Writer;Ljava/lang/String;)V",
                                    "method_body": "public void unescape(Writer writer, String str) throws IOException {\nint firstAmp = str.indexOf('&');\nif (firstAmp < 0) {\nwriter.write(str);\nreturn;\n} else {\ndoUnescape(writer, str, firstAmp);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.Entities:doUnescape(Ljava/io/Writer;Ljava/lang/String;I)V",
                                    "method_body": "private void doUnescape(Writer writer, String str, int firstAmp) throws IOException {\nwriter.write(str, 0, firstAmp);\nint len = str.length();\nfor (int i = firstAmp; i < len; i++) {\nchar c = str.charAt(i);\nif (c == '&') {\nint nextIdx = i + 1;\nint semiColonIdx = str.indexOf(';', nextIdx);\nif (semiColonIdx == -1) {\nwriter.write(c);\ncontinue;\n}\nint amphersandIdx = str.indexOf('&', i + 1);\nif (amphersandIdx != -1 && amphersandIdx < semiColonIdx) {\n// Then the text looks like &...&...;\nwriter.write(c);\ncontinue;\n}\nString entityContent = str.substring(nextIdx, semiColonIdx);\nint entityValue = -1;\nint entityContentLen = entityContent.length();\nif (entityContentLen > 0) {\nif (entityContent.charAt(0) == '#') { // escaped value content is an integer (decimal or\n// hexidecimal)\nif (entityContentLen > 1) {\nchar isHexChar = entityContent.charAt(1);\ntry {\nswitch (isHexChar) {\ncase 'X' :\ncase 'x' : {\nentityValue = Integer.parseInt(entityContent.substring(2), 16);\nbreak;\n}\ndefault : {\nentityValue = Integer.parseInt(entityContent.substring(1), 10);\n}\n}\nif (entityValue > 0xFFFF) {\nentityValue = -1;\n}\n} catch (NumberFormatException e) {\nentityValue = -1;\n}\n}\n} else { // escaped value content is an entity name\nentityValue = this.entityValue(entityContent);\n}\n}\n\nif (entityValue == -1) {\nwriter.write('&');\nwriter.write(entityContent);\nwriter.write(';');\n} else {\nwriter.write(entityValue);\n}\ni = semiColonIdx; // move index up to the semi-colon\n} else {\nwriter.write(c);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.Entities$PrimitiveEntityMap:<init>()V",
                                    "method_body": "void add(String name, int value);\n\n/**\n* <p>\n* Returns the name of the entity identified by the specified value.\n* </p>\n*\n* @param value\n*            the value to locate\n* @return entity name associated with the specified value\n*/\nString name(int value);\n\n/**\n* <p>\n* Returns the value of the entity identified by the specified name.\n* </p>\n*\n* @param name\n*            the name to locate\n* @return entity value associated with the specified name\n*/\nint value(String name);\n}\n\nstatic class PrimitiveEntityMap implements EntityMap {\nprivate Map mapNameToValue = new HashMap();\n\nprivate IntHashMap mapValueToName = new IntHashMap();\n\n/**\n* {@inheritDoc}\n*/\npublic void add(String name, int value) {\nmapNameToValue.put(name, new Integer(value));\nmapValueToName.put(value, name);\n}\n\n/**\n* {@inheritDoc}\n*/\npublic String name(int value) {\nreturn (String) mapValueToName.get(value);\n}\n\n/**\n* {@inheritDoc}\n*/\npublic int value(String name) {\nObject value = mapNameToValue.get(name);\nif (value == null) {\nreturn -1;\n}\nreturn ((Integer) value).intValue();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.Entities$PrimitiveEntityMap:add(Ljava/lang/String;I)V",
                                    "method_body": "void add(String name, int value);\n\n/**\n* <p>\n* Returns the name of the entity identified by the specified value.\n* </p>\n*\n* @param value\n*            the value to locate\n* @return entity name associated with the specified value\n*/\nString name(int value);\n\n/**\n* <p>\n* Returns the value of the entity identified by the specified name.\n* </p>\n*\n* @param name\n*            the name to locate\n* @return entity value associated with the specified name\n*/\nint value(String name);\n}\n\nstatic class PrimitiveEntityMap implements EntityMap {\nprivate Map mapNameToValue = new HashMap();\n\nprivate IntHashMap mapValueToName = new IntHashMap();\n\n/**\n* {@inheritDoc}\n*/\npublic void add(String name, int value) {\nmapNameToValue.put(name, new Integer(value));\nmapValueToName.put(value, name);\n}\n\n/**\n* {@inheritDoc}\n*/\npublic String name(int value) {\nreturn (String) mapValueToName.get(value);\n}\n\n/**\n* {@inheritDoc}\n*/\npublic int value(String name) {\nObject value = mapNameToValue.get(name);\nif (value == null) {\nreturn -1;\n}\nreturn ((Integer) value).intValue();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.Entities$PrimitiveEntityMap:name(I)Ljava/lang/String;",
                                    "method_body": "void add(String name, int value);\n\n/**\n* <p>\n* Returns the name of the entity identified by the specified value.\n* </p>\n*\n* @param value\n*            the value to locate\n* @return entity name associated with the specified value\n*/\nString name(int value);\n\n/**\n* <p>\n* Returns the value of the entity identified by the specified name.\n* </p>\n*\n* @param name\n*            the name to locate\n* @return entity value associated with the specified name\n*/\nint value(String name);\n}\n\nstatic class PrimitiveEntityMap implements EntityMap {\nprivate Map mapNameToValue = new HashMap();\n\nprivate IntHashMap mapValueToName = new IntHashMap();\n\n/**\n* {@inheritDoc}\n*/\npublic void add(String name, int value) {\nmapNameToValue.put(name, new Integer(value));\nmapValueToName.put(value, name);\n}\n\n/**\n* {@inheritDoc}\n*/\npublic String name(int value) {\nreturn (String) mapValueToName.get(value);\n}\n\n/**\n* {@inheritDoc}\n*/\npublic int value(String name) {\nObject value = mapNameToValue.get(name);\nif (value == null) {\nreturn -1;\n}\nreturn ((Integer) value).intValue();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.Entities$LookupEntityMap:name(I)Ljava/lang/String;",
                                    "method_body": "public String name(int value) {\nif (value < LOOKUP_TABLE_SIZE) {\nreturn lookupTable()[value];\n}\nreturn super.name(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.IntHashMap:<init>()V",
                                    "method_body": "public IntHashMap() {\nthis(20, 0.75f);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.IntHashMap:<init>(IF)V",
                                    "method_body": "public IntHashMap(int initialCapacity, float loadFactor) {\nsuper();\nif (initialCapacity < 0) {\nthrow new IllegalArgumentException(\"Illegal Capacity: \" + initialCapacity);\n}\nif (loadFactor <= 0) {\nthrow new IllegalArgumentException(\"Illegal Load: \" + loadFactor);\n}\nif (initialCapacity == 0) {\ninitialCapacity = 1;\n}\n\nthis.loadFactor = loadFactor;\ntable = new Entry[initialCapacity];\nthreshold = (int) (initialCapacity * loadFactor);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.IntHashMap:get(I)Ljava/lang/Object;",
                                    "method_body": "public Object get(int key) {\nEntry tab[] = table;\nint hash = key;\nint index = (hash & 0x7FFFFFFF) % tab.length;\nfor (Entry e = tab[index]; e != null; e = e.next) {\nif (e.hash == hash) {\nreturn e.value;\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.IntHashMap:rehash()V",
                                    "method_body": "protected void rehash() {\nint oldCapacity = table.length;\nEntry oldMap[] = table;\n\nint newCapacity = oldCapacity * 2 + 1;\nEntry newMap[] = new Entry[newCapacity];\n\nthreshold = (int) (newCapacity * loadFactor);\ntable = newMap;\n\nfor (int i = oldCapacity; i-- > 0;) {\nfor (Entry old = oldMap[i]; old != null;) {\nEntry e = old;\nold = old.next;\n\nint index = (e.hash & 0x7FFFFFFF) % newCapacity;\ne.next = newMap[index];\nnewMap[index] = e;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.IntHashMap:put(ILjava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public Object put(int key, Object value) {\n// Makes sure the key is not already in the hashtable.\nEntry tab[] = table;\nint hash = key;\nint index = (hash & 0x7FFFFFFF) % tab.length;\nfor (Entry e = tab[index]; e != null; e = e.next) {\nif (e.hash == hash) {\nObject old = e.value;\ne.value = value;\nreturn old;\n}\n}\n\nif (count >= threshold) {\n// Rehash the table if the threshold is exceeded\nrehash();\n\ntab = table;\nindex = (hash & 0x7FFFFFFF) % tab.length;\n}\n\n// Creates the new entry.\nEntry e = new Entry(hash, key, value, tab[index]);\ntab[index] = e;\ncount++;\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.IntHashMap$Entry:<init>(IILjava/lang/Object;Lorg/apache/commons/lang/IntHashMap$Entry;)V",
                                    "method_body": "protected Entry(int hash, int key, Object value, Entry next) {\nthis.hash = hash;\nthis.key = key;\nthis.value = value;\nthis.next = next;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 43,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang.text.ExtendedMessageFormatTest.testEscapedQuote_LANG_477",
                            "test_body": "98: public void testEscapedQuote_LANG_477() {\n99: String pattern = \"it''s a {0,lower} 'test'!\";\n100: ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry);\n101: assertEquals(\"it's a dummy test!\", emf.format(new Object[] {\"DUMMY\"}));\n102: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.text.ExtendedMessageFormat:<init>(Ljava/lang/String;Ljava/util/Map;)V",
                                    "method_body": "public ExtendedMessageFormat(String pattern, Map registry) {\nthis(pattern, Locale.getDefault(), registry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.ExtendedMessageFormat:<init>(Ljava/lang/String;Ljava/util/Locale;Ljava/util/Map;)V",
                                    "method_body": "public ExtendedMessageFormat(String pattern, Locale locale, Map registry) {\nsuper(DUMMY_PATTERN);\nsetLocale(locale);\nthis.registry = registry;\napplyPattern(pattern);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.ExtendedMessageFormat:applyPattern(Ljava/lang/String;)V",
                                    "method_body": "public final void applyPattern(String pattern) {\nif (registry == null) {\nsuper.applyPattern(pattern);\ntoPattern = super.toPattern();\nreturn;\n}\nArrayList foundFormats = new ArrayList();\nArrayList foundDescriptions = new ArrayList();\nStringBuffer stripCustom = new StringBuffer(pattern.length());\n\nParsePosition pos = new ParsePosition(0);\nchar[] c = pattern.toCharArray();\nint fmtCount = 0;\nwhile (pos.getIndex() < pattern.length()) {\nswitch (c[pos.getIndex()]) {\ncase QUOTE:\nappendQuotedString(pattern, pos, stripCustom, true);\nbreak;\ncase START_FE:\nfmtCount++;\nseekNonWs(pattern, pos);\nint start = pos.getIndex();\nint index = readArgumentIndex(pattern, next(pos));\nstripCustom.append(START_FE).append(index);\nseekNonWs(pattern, pos);\nFormat format = null;\nString formatDescription = null;\nif (c[pos.getIndex()] == START_FMT) {\nformatDescription = parseFormatDescription(pattern,\nnext(pos));\nformat = getFormat(formatDescription);\nif (format == null) {\nstripCustom.append(START_FMT).append(formatDescription);\n}\n}\nfoundFormats.add(format);\nfoundDescriptions.add(format == null ? null : formatDescription);\nValidate.isTrue(foundFormats.size() == fmtCount);\nValidate.isTrue(foundDescriptions.size() == fmtCount);\nif (c[pos.getIndex()] != END_FE) {\nthrow new IllegalArgumentException(\n\"Unreadable format element at position \" + start);\n}\n// fall through\ndefault:\nstripCustom.append(c[pos.getIndex()]);\nnext(pos);\n}\n}\nsuper.applyPattern(stripCustom.toString());\ntoPattern = insertFormats(super.toPattern(), foundDescriptions);\nif (containsElements(foundFormats)) {\nFormat[] origFormats = getFormats();\n// only loop over what we know we have, as MessageFormat on Java 1.3\n// seems to provide an extra format element:\nint i = 0;\nfor (Iterator it = foundFormats.iterator(); it.hasNext(); i++) {\nFormat f = (Format) it.next();\nif (f != null) {\norigFormats[i] = f;\n}\n}\nsuper.setFormats(origFormats);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.ExtendedMessageFormat:next(Ljava/text/ParsePosition;)Ljava/text/ParsePosition;",
                                    "method_body": "private ParsePosition next(ParsePosition pos) {\npos.setIndex(pos.getIndex() + 1);\nreturn pos;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.ExtendedMessageFormat:appendQuotedString(Ljava/lang/String;Ljava/text/ParsePosition;Ljava/lang/StringBuffer;Z)Ljava/lang/StringBuffer;",
                                    "method_body": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\nStringBuffer appendTo, boolean escapingOn) {\nint start = pos.getIndex();\nchar[] c = pattern.toCharArray();\nif (escapingOn && c[start] == QUOTE) {\nreturn appendTo == null ? null : appendTo.append(QUOTE);\n}\nint lastHold = start;\nfor (int i = pos.getIndex(); i < pattern.length(); i++) {\nif (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\nappendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\nQUOTE);\npos.setIndex(i + ESCAPED_QUOTE.length());\nlastHold = pos.getIndex();\ncontinue;\n}\nswitch (c[pos.getIndex()]) {\ncase QUOTE:\nnext(pos);\nreturn appendTo == null ? null : appendTo.append(c, lastHold,\npos.getIndex() - lastHold);\ndefault:\nnext(pos);\n}\n}\nthrow new IllegalArgumentException(\n\"Unterminated quoted string at position \" + start);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 44,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang.NumberUtilsTest.testLang457",
                            "test_body": "524: public void testLang457() {\n525: String[] badInputs = new String[] { \"l\", \"L\", \"f\", \"F\", \"junk\", \"bobL\"};\n526: for(int i=0; i<badInputs.length; i++) {\n527: try {\n528: NumberUtils.createNumber(badInputs[i]);\n529: fail(\"NumberFormatException was expected for \" + badInputs[i]);\n530: } catch (NumberFormatException e) {\n531: return; // expected\n532: }\n533: }\n534: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.NumberUtils:createNumber(Ljava/lang/String;)Ljava/lang/Number;",
                                    "method_body": "public static Number createNumber(String val) throws NumberFormatException {\nif (val == null) {\nreturn null;\n}\nif (val.length() == 0) {\nthrow new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n}\nif (val.startsWith(\"--\")) {\n// this is protection for poorness in java.lang.BigDecimal.\n// it accepts this as a legal value, but it does not appear\n// to be in specification of class. OS X Java parses it to\n// a wrong value.\nreturn null;\n}\nif (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\nreturn createInteger(val);\n}\nchar lastChar = val.charAt(val.length() - 1);\nString mant;\nString dec;\nString exp;\nint decPos = val.indexOf('.');\nint expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\nif (decPos > -1) {\n\nif (expPos > -1) {\nif (expPos < decPos) {\nthrow new NumberFormatException(val + \" is not a valid number.\");\n}\ndec = val.substring(decPos + 1, expPos);\n} else {\ndec = val.substring(decPos + 1);\n}\nmant = val.substring(0, decPos);\n} else {\nif (expPos > -1) {\nmant = val.substring(0, expPos);\n} else {\nmant = val;\n}\ndec = null;\n}\nif (!Character.isDigit(lastChar)) {\nif (expPos > -1 && expPos < val.length() - 1) {\nexp = val.substring(expPos + 1, val.length() - 1);\n} else {\nexp = null;\n}\n//Requesting a specific type..\nString numeric = val.substring(0, val.length() - 1);\nboolean allZeros = isAllZeros(mant) && isAllZeros(exp);\nswitch (lastChar) {\ncase 'l' :\ncase 'L' :\nif (dec == null\n&& exp == null\n&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\ntry {\nreturn createLong(numeric);\n} catch (NumberFormatException nfe) {\n//Too big for a long\n}\nreturn createBigInteger(numeric);\n\n}\nthrow new NumberFormatException(val + \" is not a valid number.\");\ncase 'f' :\ncase 'F' :\ntry {\nFloat f = NumberUtils.createFloat(numeric);\nif (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n//If it's too big for a float or the float value = 0 and the string\n//has non-zeros in it, then float does not have the precision we want\nreturn f;\n}\n\n} catch (NumberFormatException e) {\n// ignore the bad number\n}\n//Fall through\ncase 'd' :\ncase 'D' :\ntry {\nDouble d = NumberUtils.createDouble(numeric);\nif (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\nreturn d;\n}\n} catch (NumberFormatException nfe) {\n// empty catch\n}\ntry {\nreturn createBigDecimal(numeric);\n} catch (NumberFormatException e) {\n// empty catch\n}\n//Fall through\ndefault :\nthrow new NumberFormatException(val + \" is not a valid number.\");\n\n}\n} else {\n//User doesn't have a preference on the return type, so let's start\n//small and go from there...\nif (expPos > -1 && expPos < val.length() - 1) {\nexp = val.substring(expPos + 1, val.length());\n} else {\nexp = null;\n}\nif (dec == null && exp == null) {\n//Must be an int,long,bigint\ntry {\nreturn createInteger(val);\n} catch (NumberFormatException nfe) {\n// empty catch\n}\ntry {\nreturn createLong(val);\n} catch (NumberFormatException nfe) {\n// empty catch\n}\nreturn createBigInteger(val);\n\n} else {\n//Must be a float,double,BigDec\nboolean allZeros = isAllZeros(mant) && isAllZeros(exp);\ntry {\nFloat f = createFloat(val);\nif (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\nreturn f;\n}\n} catch (NumberFormatException nfe) {\n// empty catch\n}\ntry {\nDouble d = createDouble(val);\nif (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\nreturn d;\n}\n} catch (NumberFormatException nfe) {\n// empty catch\n}\n\nreturn createBigDecimal(val);\n\n}\n\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.NumberUtils:isAllZeros(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean isAllZeros(String s) {\nif (s == null) {\nreturn true;\n}\nfor (int i = s.length() - 1; i >= 0; i--) {\nif (s.charAt(i) != '0') {\nreturn false;\n}\n}\nreturn s.length() > 0;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 45,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang.WordUtilsTest.testAbbreviate",
                            "test_body": "366: public void testAbbreviate() {\n367: // check null and empty are returned respectively\n368: assertNull(WordUtils.abbreviate(null, 1,-1,\"\"));\n369: assertEquals(StringUtils.EMPTY, WordUtils.abbreviate(\"\", 1,-1,\"\"));\n370: 371: // test upper limit\n372: assertEquals(\"01234\", WordUtils.abbreviate(\"0123456789\", 0,5,\"\"));\n373: assertEquals(\"01234\", WordUtils.abbreviate(\"0123456789\", 5, 2,\"\"));\n374: assertEquals(\"012\", WordUtils.abbreviate(\"012 3456789\", 2, 5,\"\"));\n375: assertEquals(\"012 3\", WordUtils.abbreviate(\"012 3456789\", 5, 2,\"\"));\n376: assertEquals(\"0123456789\", WordUtils.abbreviate(\"0123456789\", 0,-1,\"\"));\n377: 378: // test upper limit + append string\n379: assertEquals(\"01234-\", WordUtils.abbreviate(\"0123456789\", 0,5,\"-\"));\n380: assertEquals(\"01234-\", WordUtils.abbreviate(\"0123456789\", 5, 2,\"-\"));\n381: assertEquals(\"012\", WordUtils.abbreviate(\"012 3456789\", 2, 5, null));\n382: assertEquals(\"012 3\", WordUtils.abbreviate(\"012 3456789\", 5, 2,\"\"));\n383: assertEquals(\"0123456789\", WordUtils.abbreviate(\"0123456789\", 0,-1,\"\"));\n384: 385: // test lower value\n386: assertEquals(\"012\", WordUtils.abbreviate(\"012 3456789\", 0,5, null));\n387: assertEquals(\"01234\", WordUtils.abbreviate(\"01234 56789\", 5, 10, null));\n388: assertEquals(\"01 23 45 67\", WordUtils.abbreviate(\"01 23 45 67 89\", 9, -1, null));\n389: assertEquals(\"01 23 45 6\", WordUtils.abbreviate(\"01 23 45 67 89\", 9, 10, null));\n390: assertEquals(\"0123456789\", WordUtils.abbreviate(\"0123456789\", 15, 20, null));\n391: 392: // test lower value + append\n393: assertEquals(\"012\", WordUtils.abbreviate(\"012 3456789\", 0,5, null));\n394: assertEquals(\"01234-\", WordUtils.abbreviate(\"01234 56789\", 5, 10, \"-\"));\n395: assertEquals(\"01 23 45 67abc\", WordUtils.abbreviate(\"01 23 45 67 89\", 9, -1, \"abc\"));\n396: assertEquals(\"01 23 45 6\", WordUtils.abbreviate(\"01 23 45 67 89\", 9, 10, \"\"));\n397: 398: // others\n399: assertEquals(\"\", WordUtils.abbreviate(\"0123456790\", 0,0,\"\"));\n400: assertEquals(\"\", WordUtils.abbreviate(\" 0123456790\", 0,-1,\"\"));\n401: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.StringUtils:indexOf(Ljava/lang/String;Ljava/lang/String;I)I",
                                    "method_body": "public static int indexOf(String str, String searchStr, int startPos) {\nif (str == null || searchStr == null) {\nreturn -1;\n}\n// JDK1.2/JDK1.3 have a bug, when startPos > str.length for \"\", hence\nif (searchStr.length() == 0 && startPos >= str.length()) {\nreturn str.length();\n}\nreturn str.indexOf(searchStr, startPos);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.StringUtils:defaultString(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public static String defaultString(String str) {\nreturn str == null ? EMPTY : str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.WordUtils:abbreviate(Ljava/lang/String;IILjava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n// initial parameter checks\nif (str == null) {\nreturn null;\n}\nif (str.length() == 0) {\nreturn StringUtils.EMPTY;\n}\n\n// if the lower value is greater than the length of the string,\n// set to the length of the string\n// if the upper value is -1 (i.e. no limit) or is greater\n// than the length of the string, set to the length of the string\nif (upper == -1 || upper > str.length()) {\nupper = str.length();\n}\n// if upper is less than lower, raise it to lower\nif (upper < lower) {\nupper = lower;\n}\n\nStringBuffer result = new StringBuffer();\nint index = StringUtils.indexOf(str, \" \", lower);\nif (index == -1) {\nresult.append(str.substring(0, upper));\n// only if abbreviation has occured do we append the appendToEnd value\nif (upper != str.length()) {\nresult.append(StringUtils.defaultString(appendToEnd));\n}\n} else if (index > upper) {\nresult.append(str.substring(0, upper));\nresult.append(StringUtils.defaultString(appendToEnd));\n} else {\nresult.append(str.substring(0, index));\nresult.append(StringUtils.defaultString(appendToEnd));\n}\nreturn result.toString();\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 46,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang.StringEscapeUtilsTest.testEscapeJavaWithSlash",
                            "test_body": "103: public void testEscapeJavaWithSlash() {\n104: final String input = \"String with a slash (/) in it\";\n105: 106: final String expected = input;\n107: final String actual = StringEscapeUtils.escapeJava(input);\n108: 109: /**\n110: * In 2.4 StringEscapeUtils.escapeJava(String) escapes '/' characters, which are not a valid character to escape\n111: * in a Java string.\n112: */\n113: assertEquals(expected, actual);\n114: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.StringEscapeUtils:<clinit>()V",
                                    "method_body": "private static final char CSV_DELIMITER = ',';\nprivate static final char CSV_QUOTE = '\"';\nprivate static final String CSV_QUOTE_STR = String.valueOf(CSV_QUOTE);\nprivate static final char[] CSV_SEARCH_CHARS = new char[] {CSV_DELIMITER, CSV_QUOTE, CharUtils.CR, CharUtils.LF};"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.StringEscapeUtils:escapeJava(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public static String escapeJava(String str) {\nreturn escapeJavaStyleString(str, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.StringEscapeUtils:escapeJavaStyleString(Ljava/lang/String;Z)Ljava/lang/String;",
                                    "method_body": "private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\nif (str == null) {\nreturn null;\n}\ntry {\nStringWriter writer = new StringWriter(str.length() * 2);\nescapeJavaStyleString(writer, str, escapeSingleQuotes);\nreturn writer.toString();\n} catch (IOException ioe) {\n// this should never ever happen while writing to a StringWriter\nioe.printStackTrace();\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.StringEscapeUtils:escapeJavaStyleString(Ljava/io/Writer;Ljava/lang/String;Z)V",
                                    "method_body": "private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\nif (out == null) {\nthrow new IllegalArgumentException(\"The Writer must not be null\");\n}\nif (str == null) {\nreturn;\n}\nint sz;\nsz = str.length();\nfor (int i = 0; i < sz; i++) {\nchar ch = str.charAt(i);\n\n// handle unicode\nif (ch > 0xfff) {\nout.write(\"\\\\u\" + hex(ch));\n} else if (ch > 0xff) {\nout.write(\"\\\\u0\" + hex(ch));\n} else if (ch > 0x7f) {\nout.write(\"\\\\u00\" + hex(ch));\n} else if (ch < 32) {\nswitch (ch) {\ncase '\\b' :\nout.write('\\\\');\nout.write('b');\nbreak;\ncase '\\n' :\nout.write('\\\\');\nout.write('n');\nbreak;\ncase '\\t' :\nout.write('\\\\');\nout.write('t');\nbreak;\ncase '\\f' :\nout.write('\\\\');\nout.write('f');\nbreak;\ncase '\\r' :\nout.write('\\\\');\nout.write('r');\nbreak;\ndefault :\nif (ch > 0xf) {\nout.write(\"\\\\u00\" + hex(ch));\n} else {\nout.write(\"\\\\u000\" + hex(ch));\n}\nbreak;\n}\n} else {\nswitch (ch) {\ncase '\\'' :\nif (escapeSingleQuote) {\nout.write('\\\\');\n}\nout.write('\\'');\nbreak;\ncase '\"' :\nout.write('\\\\');\nout.write('\"');\nbreak;\ncase '\\\\' :\nout.write('\\\\');\nout.write('\\\\');\nbreak;\ncase '/' :\nout.write('\\\\');\nout.write('/');\nbreak;\ndefault :\nout.write(ch);\nbreak;\n}\n}\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 47,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang.text.StrBuilderTest.testLang412Right",
                            "test_body": "1753: public void testLang412Right() {\n1754: StrBuilder sb = new StrBuilder();\n1755: sb.appendFixedWidthPadRight(null, 10, '*');\n1756: assertEquals( \"Failed to invoke appendFixedWidthPadRight correctly\", \"**********\", sb.toString());\n1757: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher:<init>()V",
                                    "method_body": "protected StrMatcher() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher:<clinit>()V",
                                    "method_body": "private static final StrMatcher COMMA_MATCHER = new CharMatcher(',');\n/**\n* Matches the tab character.\n*/\nprivate static final StrMatcher TAB_MATCHER = new CharMatcher('\\t');\n/**\n* Matches the space character.\n*/\nprivate static final StrMatcher SPACE_MATCHER = new CharMatcher(' ');\n/**\n* Matches the same characters as StringTokenizer,\n* namely space, tab, newline, formfeed.\n*/\nprivate static final StrMatcher SPLIT_MATCHER = new CharSetMatcher(\" \\t\\n\\r\\f\".toCharArray());\n/**\n* Matches the String trim() whitespace characters.\n*/\nprivate static final StrMatcher TRIM_MATCHER = new TrimMatcher();\n/**\n* Matches the double quote character.\n*/\nprivate static final StrMatcher SINGLE_QUOTE_MATCHER = new CharMatcher('\\'');\n/**\n* Matches the double quote character.\n*/\nprivate static final StrMatcher DOUBLE_QUOTE_MATCHER = new CharMatcher('\"');\n/**\n* Matches the single or double quote character.\n*/\nprivate static final StrMatcher QUOTE_MATCHER = new CharSetMatcher(\"'\\\"\".toCharArray());\n/**\n* Matches no characters.\n*/\nprivate static final StrMatcher NONE_MATCHER = new NoMatcher();\n\n// -----------------------------------------------------------------------\n\n/**\n* Returns a matcher which matches the comma character.\n*\n* @return a matcher for a comma\n*/\npublic static StrMatcher commaMatcher() {\nreturn COMMA_MATCHER;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher$CharMatcher:<init>(C)V",
                                    "method_body": "CharMatcher(char ch) {\nsuper();\nthis.ch = ch;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher$CharSetMatcher:<init>([C)V",
                                    "method_body": "CharSetMatcher(char chars[]) {\nsuper();\nthis.chars = (char[]) chars.clone();\nArrays.sort(this.chars);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher$TrimMatcher:<init>()V",
                                    "method_body": "TrimMatcher() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher$NoMatcher:<init>()V",
                                    "method_body": "NoMatcher() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:<init>()V",
                                    "method_body": "public StrBuilder() {\nthis(CAPACITY);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:<init>(I)V",
                                    "method_body": "public StrBuilder(int initialCapacity) {\nsuper();\nif (initialCapacity <= 0) {\ninitialCapacity = CAPACITY;\n}\nbuffer = new char[initialCapacity];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:getNullText()Ljava/lang/String;",
                                    "method_body": "public String getNullText() {\nreturn nullText;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:ensureCapacity(I)Lorg/apache/commons/lang/text/StrBuilder;",
                                    "method_body": "public StrBuilder ensureCapacity(int capacity) {\nif (capacity > buffer.length) {\nchar[] old = buffer;\nbuffer = new char[capacity];\nSystem.arraycopy(old, 0, buffer, 0, size);\n}\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:appendFixedWidthPadRight(Ljava/lang/Object;IC)Lorg/apache/commons/lang/text/StrBuilder;",
                                    "method_body": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\nif (width > 0) {\nensureCapacity(size + width);\nString str = (obj == null ? getNullText() : obj.toString());\nint strLen = str.length();\nif (strLen >= width) {\nstr.getChars(0, width, buffer, size);\n} else {\nint padLen = width - strLen;\nstr.getChars(0, strLen, buffer, size);\nfor (int i = 0; i < padLen; i++) {\nbuffer[size + strLen + i] = padChar;\n}\n}\nsize += width;\n}\nreturn this;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang.text.StrBuilderTest.testLang412Left",
                            "test_body": "1759: public void testLang412Left() {\n1760: StrBuilder sb = new StrBuilder();\n1761: sb.appendFixedWidthPadLeft(null, 10, '*');\n1762: assertEquals( \"Failed to invoke appendFixedWidthPadLeft correctly\", \"**********\", sb.toString());\n1763: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher:<init>()V",
                                    "method_body": "protected StrMatcher() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher:<clinit>()V",
                                    "method_body": "private static final StrMatcher COMMA_MATCHER = new CharMatcher(',');\n/**\n* Matches the tab character.\n*/\nprivate static final StrMatcher TAB_MATCHER = new CharMatcher('\\t');\n/**\n* Matches the space character.\n*/\nprivate static final StrMatcher SPACE_MATCHER = new CharMatcher(' ');\n/**\n* Matches the same characters as StringTokenizer,\n* namely space, tab, newline, formfeed.\n*/\nprivate static final StrMatcher SPLIT_MATCHER = new CharSetMatcher(\" \\t\\n\\r\\f\".toCharArray());\n/**\n* Matches the String trim() whitespace characters.\n*/\nprivate static final StrMatcher TRIM_MATCHER = new TrimMatcher();\n/**\n* Matches the double quote character.\n*/\nprivate static final StrMatcher SINGLE_QUOTE_MATCHER = new CharMatcher('\\'');\n/**\n* Matches the double quote character.\n*/\nprivate static final StrMatcher DOUBLE_QUOTE_MATCHER = new CharMatcher('\"');\n/**\n* Matches the single or double quote character.\n*/\nprivate static final StrMatcher QUOTE_MATCHER = new CharSetMatcher(\"'\\\"\".toCharArray());\n/**\n* Matches no characters.\n*/\nprivate static final StrMatcher NONE_MATCHER = new NoMatcher();\n\n// -----------------------------------------------------------------------\n\n/**\n* Returns a matcher which matches the comma character.\n*\n* @return a matcher for a comma\n*/\npublic static StrMatcher commaMatcher() {\nreturn COMMA_MATCHER;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher$CharMatcher:<init>(C)V",
                                    "method_body": "CharMatcher(char ch) {\nsuper();\nthis.ch = ch;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher$CharSetMatcher:<init>([C)V",
                                    "method_body": "CharSetMatcher(char chars[]) {\nsuper();\nthis.chars = (char[]) chars.clone();\nArrays.sort(this.chars);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher$TrimMatcher:<init>()V",
                                    "method_body": "TrimMatcher() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher$NoMatcher:<init>()V",
                                    "method_body": "NoMatcher() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:<init>()V",
                                    "method_body": "public StrBuilder() {\nthis(CAPACITY);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:<init>(I)V",
                                    "method_body": "public StrBuilder(int initialCapacity) {\nsuper();\nif (initialCapacity <= 0) {\ninitialCapacity = CAPACITY;\n}\nbuffer = new char[initialCapacity];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:getNullText()Ljava/lang/String;",
                                    "method_body": "public String getNullText() {\nreturn nullText;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:ensureCapacity(I)Lorg/apache/commons/lang/text/StrBuilder;",
                                    "method_body": "public StrBuilder ensureCapacity(int capacity) {\nif (capacity > buffer.length) {\nchar[] old = buffer;\nbuffer = new char[capacity];\nSystem.arraycopy(old, 0, buffer, 0, size);\n}\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:appendFixedWidthPadLeft(Ljava/lang/Object;IC)Lorg/apache/commons/lang/text/StrBuilder;",
                                    "method_body": "public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\nif (width > 0) {\nensureCapacity(size + width);\nString str = (obj == null ? getNullText() : obj.toString());\nint strLen = str.length();\nif (strLen >= width) {\nstr.getChars(strLen - width, strLen, buffer, size);\n} else {\nint padLen = width - strLen;\nfor (int i = 0; i < padLen; i++) {\nbuffer[size + i] = padChar;\n}\nstr.getChars(0, strLen, buffer, size + padLen);\n}\nsize += width;\n}\nreturn this;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 49,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang.math.FractionTest.testReduce",
                            "test_body": "616: public void testReduce() {\n617: Fraction f = null;\n618: 619: f = Fraction.getFraction(50, 75);\n620: Fraction result = f.reduce();\n621: assertEquals(2, result.getNumerator());\n622: assertEquals(3, result.getDenominator());\n623: 624: f = Fraction.getFraction(-2, -3);\n625: result = f.reduce();\n626: assertEquals(2, result.getNumerator());\n627: assertEquals(3, result.getDenominator());\n628: 629: f = Fraction.getFraction(2, -3);\n630: result = f.reduce();\n631: assertEquals(-2, result.getNumerator());\n632: assertEquals(3, result.getDenominator());\n633: 634: f = Fraction.getFraction(-2, 3);\n635: result = f.reduce();\n636: assertEquals(-2, result.getNumerator());\n637: assertEquals(3, result.getDenominator());\n638: assertSame(f, result);\n639: 640: f = Fraction.getFraction(2, 3);\n641: result = f.reduce();\n642: assertEquals(2, result.getNumerator());\n643: assertEquals(3, result.getDenominator());\n644: assertSame(f, result);\n645: 646: f = Fraction.getFraction(0, 1);\n647: result = f.reduce();\n648: assertEquals(0, result.getNumerator());\n649: assertEquals(1, result.getDenominator());\n650: assertSame(f, result);\n651: 652: f = Fraction.getFraction(0, 100);\n653: result = f.reduce();\n654: assertEquals(0, result.getNumerator());\n655: assertEquals(1, result.getDenominator());\n656: assertSame(result, Fraction.ZERO);\n657: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.math.Fraction:<init>(II)V",
                                    "method_body": "private Fraction(int numerator, int denominator) {\nsuper();\nthis.numerator = numerator;\nthis.denominator = denominator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.math.Fraction:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 65382027393090L;\n\n/**\n* <code>Fraction</code> representation of 0.\n*/\npublic static final Fraction ZERO = new Fraction(0, 1);\n/**\n* <code>Fraction</code> representation of 1.\n*/\npublic static final Fraction ONE = new Fraction(1, 1);\n/**\n* <code>Fraction</code> representation of 1/2.\n*/\npublic static final Fraction ONE_HALF = new Fraction(1, 2);\n/**\n* <code>Fraction</code> representation of 1/3.\n*/\npublic static final Fraction ONE_THIRD = new Fraction(1, 3);\n/**\n* <code>Fraction</code> representation of 2/3.\n*/\npublic static final Fraction TWO_THIRDS = new Fraction(2, 3);\n/**\n* <code>Fraction</code> representation of 1/4.\n*/\npublic static final Fraction ONE_QUARTER = new Fraction(1, 4);\n/**\n* <code>Fraction</code> representation of 2/4.\n*/\npublic static final Fraction TWO_QUARTERS = new Fraction(2, 4);\n/**\n* <code>Fraction</code> representation of 3/4.\n*/\npublic static final Fraction THREE_QUARTERS = new Fraction(3, 4);\n/**\n* <code>Fraction</code> representation of 1/5.\n*/\npublic static final Fraction ONE_FIFTH = new Fraction(1, 5);\n/**\n* <code>Fraction</code> representation of 2/5.\n*/\npublic static final Fraction TWO_FIFTHS = new Fraction(2, 5);\n/**\n* <code>Fraction</code> representation of 3/5.\n*/\npublic static final Fraction THREE_FIFTHS = new Fraction(3, 5);\n/**\n* <code>Fraction</code> representation of 4/5.\n*/\npublic static final Fraction FOUR_FIFTHS = new Fraction(4, 5);\n\n\n/**\n* The numerator number part of the fraction (the three in three sevenths).\n*/\nprivate final int numerator;\n/**\n* The denominator number part of the fraction (the seven in three sevenths).\n*/\nprivate final int denominator;\n\n/**\n* Cached output hashCode (class is immutable).\n*/\nprivate transient int hashCode = 0;\n/**\n* Cached output toString (class is immutable).\n*/\nprivate transient String toString = null;\n/**\n* Cached output toProperString (class is immutable).\n*/\nprivate transient String toProperString = null;\n\n/**\n* <p>Constructs a <code>Fraction</code> instance with the 2 parts\n* of a fraction Y/Z.</p>\n*\n* @param numerator  the numerator, for example the three in 'three sevenths'\n* @param denominator  the denominator, for example the seven in 'three sevenths'\n*/\nprivate Fraction(int numerator, int denominator) {\nsuper();\nthis.numerator = numerator;\nthis.denominator = denominator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.math.Fraction:getFraction(II)Lorg/apache/commons/lang/math/Fraction;",
                                    "method_body": "public static Fraction getFraction(int numerator, int denominator) {\nif (denominator == 0) {\nthrow new ArithmeticException(\"The denominator must not be zero\");\n}\nif (denominator < 0) {\nif (numerator==Integer.MIN_VALUE ||\ndenominator==Integer.MIN_VALUE) {\nthrow new ArithmeticException(\"overflow: can't negate\");\n}\nnumerator = -numerator;\ndenominator = -denominator;\n}\nreturn new Fraction(numerator, denominator);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.math.Fraction:getNumerator()I",
                                    "method_body": "public int getNumerator() {\nreturn numerator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.math.Fraction:getDenominator()I",
                                    "method_body": "public int getDenominator() {\nreturn denominator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.math.Fraction:reduce()Lorg/apache/commons/lang/math/Fraction;",
                                    "method_body": "public Fraction reduce() {\nint gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\nif (gcd == 1) {\nreturn this;\n}\nreturn Fraction.getFraction(numerator / gcd, denominator / gcd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.math.Fraction:greatestCommonDivisor(II)I",
                                    "method_body": "private static int greatestCommonDivisor(int u, int v) {\n//if either op. is abs 0 or 1, return 1:\nif (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\nreturn 1;\n}\n// keep u and v negative, as negative integers range down to\n// -2^31, while positive numbers can only be as large as 2^31-1\n// (i.e. we can't necessarily negate a negative number without\n// overflow)\nif (u>0) { u=-u; } // make u negative\nif (v>0) { v=-v; } // make v negative\n// B1. [Find power of 2]\nint k=0;\nwhile ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\nu/=2; v/=2; k++; // cast out twos.\n}\nif (k==31) {\nthrow new ArithmeticException(\"overflow: gcd is 2^31\");\n}\n// B2. Initialize: u and v have been divided by 2^k and at least\n//     one is odd.\nint t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n// t negative: u was odd, v may be even (t replaces v)\n// t positive: u was even, v is odd (t replaces u)\ndo {\n/* assert u<0 && v<0; */\n// B4/B3: cast out twos from t.\nwhile ((t&1)==0) { // while t is even..\nt/=2; // cast out twos\n}\n// B5 [reset max(u,v)]\nif (t>0) {\nu = -t;\n} else {\nv = t;\n}\n// B6/B3. at this point both u and v should be odd.\nt = (v - u)/2;\n// |u| larger: t positive (replace u)\n// |v| larger: t negative (replace v)\n} while (t!=0);\nreturn -u*(1<<k); // gcd is u*2^k\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 50,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang.time.FastDateFormatTest.test_changeDefault_Locale_DateTimeInstance",
                            "test_body": "155: public void test_changeDefault_Locale_DateTimeInstance() {\n156: Locale realDefaultLocale = Locale.getDefault();\n157: try {\n158: Locale.setDefault(Locale.US);\n159: FastDateFormat format1 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL, Locale.GERMANY);\n160: FastDateFormat format2 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL);\n161: Locale.setDefault(Locale.GERMANY);\n162: FastDateFormat format3 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL);\n163: 164: assertSame(Locale.GERMANY, format1.getLocale());\n165: assertSame(Locale.US, format2.getLocale());\n166: assertSame(Locale.GERMANY, format3.getLocale());\n167: assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);\n168: assertTrue(format2 != format3);\n169: 170: } finally {\n171: Locale.setDefault(realDefaultLocale);\n172: }\n173: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat:<init>(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)V",
                                    "method_body": "protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {\nsuper();\nif (pattern == null) {\nthrow new IllegalArgumentException(\"The pattern must not be null\");\n}\nmPattern = pattern;\n\nmTimeZoneForced = (timeZone != null);\nif (timeZone == null) {\ntimeZone = TimeZone.getDefault();\n}\nmTimeZone = timeZone;\n\nmLocaleForced = (locale != null);\nif (locale == null) {\nlocale = Locale.getDefault();\n}\nmLocale = locale;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\n/**\n* FULL locale dependent date or time style.\n*/\npublic static final int FULL = DateFormat.FULL;\n/**\n* LONG locale dependent date or time style.\n*/\npublic static final int LONG = DateFormat.LONG;\n/**\n* MEDIUM locale dependent date or time style.\n*/\npublic static final int MEDIUM = DateFormat.MEDIUM;\n/**\n* SHORT locale dependent date or time style.\n*/\npublic static final int SHORT = DateFormat.SHORT;\n\nprivate static String cDefaultPattern;\n\nprivate static Map cInstanceCache = new HashMap(7);\nprivate static Map cDateInstanceCache = new HashMap(7);\nprivate static Map cTimeInstanceCache = new HashMap(7);\nprivate static Map cDateTimeInstanceCache = new HashMap(7);\nprivate static Map cTimeZoneDisplayCache = new HashMap(7);\n\n/**\n* The pattern.\n*/\nprivate final String mPattern;\n/**\n* The time zone.\n*/\nprivate final TimeZone mTimeZone;\n/**\n* Whether the time zone overrides any on Calendars.\n*/\nprivate final boolean mTimeZoneForced;\n/**\n* The locale.\n*/\nprivate final Locale mLocale;\n/**\n* Whether the locale overrides the default.\n*/\nprivate final boolean mLocaleForced;\n/**\n* The parsed rules.\n*/\nprivate transient Rule[] mRules;\n/**\n* The estimated maximum length.\n*/\nprivate transient int mMaxLengthEstimate;\n\n//-----------------------------------------------------------------------\n/**\n* <p>Gets a formatter instance using the default pattern in the\n* default locale.</p>\n*\n* @return a date/time formatter\n*/\npublic static FastDateFormat getInstance() {\nreturn getInstance(getDefaultPattern(), null, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat:getInstance(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)Lorg/apache/commons/lang/time/FastDateFormat;",
                                    "method_body": "public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {\nFastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);\nFastDateFormat format = (FastDateFormat) cInstanceCache.get(emptyFormat);\nif (format == null) {\nformat = emptyFormat;\nformat.init();  // convert shell format into usable one\ncInstanceCache.put(format, format);  // this is OK!\n}\nreturn format;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat:init()V",
                                    "method_body": "protected void init() {\nList rulesList = parsePattern();\nmRules = (Rule[]) rulesList.toArray(new Rule[rulesList.size()]);\n\nint len = 0;\nfor (int i=mRules.length; --i >= 0; ) {\nlen += mRules[i].estimateLength();\n}\n\nmMaxLengthEstimate = len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat:parsePattern()Ljava/util/List;",
                                    "method_body": "protected List parsePattern() {\nDateFormatSymbols symbols = new DateFormatSymbols(mLocale);\nList rules = new ArrayList();\n\nString[] ERAs = symbols.getEras();\nString[] months = symbols.getMonths();\nString[] shortMonths = symbols.getShortMonths();\nString[] weekdays = symbols.getWeekdays();\nString[] shortWeekdays = symbols.getShortWeekdays();\nString[] AmPmStrings = symbols.getAmPmStrings();\n\nint length = mPattern.length();\nint[] indexRef = new int[1];\n\nfor (int i = 0; i < length; i++) {\nindexRef[0] = i;\nString token = parseToken(mPattern, indexRef);\ni = indexRef[0];\n\nint tokenLen = token.length();\nif (tokenLen == 0) {\nbreak;\n}\n\nRule rule;\nchar c = token.charAt(0);\n\nswitch (c) {\ncase 'G': // era designator (text)\nrule = new TextField(Calendar.ERA, ERAs);\nbreak;\ncase 'y': // year (number)\nif (tokenLen >= 4) {\nrule = selectNumberRule(Calendar.YEAR, tokenLen);\n} else {\nrule = TwoDigitYearField.INSTANCE;\n}\nbreak;\ncase 'M': // month in year (text and number)\nif (tokenLen >= 4) {\nrule = new TextField(Calendar.MONTH, months);\n} else if (tokenLen == 3) {\nrule = new TextField(Calendar.MONTH, shortMonths);\n} else if (tokenLen == 2) {\nrule = TwoDigitMonthField.INSTANCE;\n} else {\nrule = UnpaddedMonthField.INSTANCE;\n}\nbreak;\ncase 'd': // day in month (number)\nrule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\nbreak;\ncase 'h': // hour in am/pm (number, 1..12)\nrule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\nbreak;\ncase 'H': // hour in day (number, 0..23)\nrule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\nbreak;\ncase 'm': // minute in hour (number)\nrule = selectNumberRule(Calendar.MINUTE, tokenLen);\nbreak;\ncase 's': // second in minute (number)\nrule = selectNumberRule(Calendar.SECOND, tokenLen);\nbreak;\ncase 'S': // millisecond (number)\nrule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\nbreak;\ncase 'E': // day in week (text)\nrule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\nbreak;\ncase 'D': // day in year (number)\nrule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\nbreak;\ncase 'F': // day of week in month (number)\nrule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\nbreak;\ncase 'w': // week in year (number)\nrule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\nbreak;\ncase 'W': // week in month (number)\nrule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\nbreak;\ncase 'a': // am/pm marker (text)\nrule = new TextField(Calendar.AM_PM, AmPmStrings);\nbreak;\ncase 'k': // hour in day (1..24)\nrule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\nbreak;\ncase 'K': // hour in am/pm (0..11)\nrule = selectNumberRule(Calendar.HOUR, tokenLen);\nbreak;\ncase 'z': // time zone (text)\nif (tokenLen >= 4) {\nrule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.LONG);\n} else {\nrule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.SHORT);\n}\nbreak;\ncase 'Z': // time zone (value)\nif (tokenLen == 1) {\nrule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n} else {\nrule = TimeZoneNumberRule.INSTANCE_COLON;\n}\nbreak;\ncase '\\'': // literal text\nString sub = token.substring(1);\nif (sub.length() == 1) {\nrule = new CharacterLiteral(sub.charAt(0));\n} else {\nrule = new StringLiteral(sub);\n}\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"Illegal pattern component: \" + token);\n}\n\nrules.add(rule);\n}\n\nreturn rules;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
                                    "method_body": "protected String parseToken(String pattern, int[] indexRef) {\nStringBuffer buf = new StringBuffer();\n\nint i = indexRef[0];\nint length = pattern.length();\n\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n// Scan a run of the same character, which indicates a time\n// pattern.\nbuf.append(c);\n\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append(c);\ni++;\n} else {\nbreak;\n}\n}\n} else {\n// This will identify token as text.\nbuf.append('\\'');\n\nboolean inLiteral = false;\n\nfor (; i < length; i++) {\nc = pattern.charAt(i);\n\nif (c == '\\'') {\nif (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n// '' is treated as escaped '\ni++;\nbuf.append(c);\n} else {\ninLiteral = !inLiteral;\n}\n} else if (!inLiteral &&\n(c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\ni--;\nbreak;\n} else {\nbuf.append(c);\n}\n}\n}\n\nindexRef[0] = i;\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat:selectNumberRule(II)Lorg/apache/commons/lang/time/FastDateFormat$NumberRule;",
                                    "method_body": "protected NumberRule selectNumberRule(int field, int padding) {\nswitch (padding) {\ncase 1:\nreturn new UnpaddedNumberField(field);\ncase 2:\nreturn new TwoDigitNumberField(field);\ndefault:\nreturn new PaddedNumberField(field, padding);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat:getLocale()Ljava/util/Locale;",
                                    "method_body": "public Locale getLocale() {\nreturn mLocale;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat:hashCode()I",
                                    "method_body": "public int hashCode() {\nint total = 0;\ntotal += mPattern.hashCode();\ntotal += mTimeZone.hashCode();\ntotal += (mTimeZoneForced ? 1 : 0);\ntotal += mLocale.hashCode();\ntotal += (mLocaleForced ? 1 : 0);\nreturn total;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$PaddedNumberField:<init>(II)V",
                                    "method_body": "PaddedNumberField(int field, int size) {\nif (size < 3) {\n// Should use UnpaddedNumberField or TwoDigitNumberField.\nthrow new IllegalArgumentException();\n}\nmField = field;\nmSize = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$PaddedNumberField:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nreturn 4;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$CharacterLiteral:<init>(C)V",
                                    "method_body": "void appendTo(StringBuffer buffer, int value);\n}\n\n/**\n* <p>Inner class to output a constant single character.</p>\n*/\nprivate static class CharacterLiteral implements Rule {\nprivate final char mValue;\n\n/**\n* Constructs a new instance of <code>CharacterLiteral</code>\n* to hold the specified value.\n*\n* @param value the character literal\n*/\nCharacterLiteral(char value) {\nmValue = value;\n}\n\n/**\n* {@inheritDoc}\n*/\npublic int estimateLength() {\nreturn 1;\n}\n\n/**\n* {@inheritDoc}\n*/\npublic void appendTo(StringBuffer buffer, Calendar calendar) {\nbuffer.append(mValue);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$CharacterLiteral:estimateLength()I",
                                    "method_body": "void appendTo(StringBuffer buffer, int value);\n}\n\n/**\n* <p>Inner class to output a constant single character.</p>\n*/\nprivate static class CharacterLiteral implements Rule {\nprivate final char mValue;\n\n/**\n* Constructs a new instance of <code>CharacterLiteral</code>\n* to hold the specified value.\n*\n* @param value the character literal\n*/\nCharacterLiteral(char value) {\nmValue = value;\n}\n\n/**\n* {@inheritDoc}\n*/\npublic int estimateLength() {\nreturn 1;\n}\n\n/**\n* {@inheritDoc}\n*/\npublic void appendTo(StringBuffer buffer, Calendar calendar) {\nbuffer.append(mValue);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$TextField:<init>(I[Ljava/lang/String;)V",
                                    "method_body": "TextField(int field, String[] values) {\nmField = field;\nmValues = values;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$TextField:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nint max = 0;\nfor (int i=mValues.length; --i >= 0; ) {\nint len = mValues[i].length();\nif (len > max) {\nmax = len;\n}\n}\nreturn max;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$StringLiteral:<init>(Ljava/lang/String;)V",
                                    "method_body": "StringLiteral(String value) {\nmValue = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$StringLiteral:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nreturn mValue.length();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$UnpaddedNumberField:<init>(I)V",
                                    "method_body": "UnpaddedNumberField(int field) {\nmField = field;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$UnpaddedNumberField:<clinit>()V",
                                    "method_body": "static final UnpaddedNumberField INSTANCE_YEAR = new UnpaddedNumberField(Calendar.YEAR);\n\nprivate final int mField;\n\n/**\n* Constructs an instance of <code>UnpadedNumberField</code> with the specified field.\n*\n* @param field the field\n*/\nUnpaddedNumberField(int field) {\nmField = field;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$UnpaddedNumberField:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nreturn 4;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$Pair:<init>(Ljava/lang/Object;Ljava/lang/Object;)V",
                                    "method_body": "public Pair(Object obj1, Object obj2) {\nmObj1 = obj1;\nmObj2 = obj2;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$Pair:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn\n(mObj1 == null ? 0 : mObj1.hashCode()) +\n(mObj2 == null ? 0 : mObj2.hashCode());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat:getDateTimeInstance(II)Lorg/apache/commons/lang/time/FastDateFormat;",
                                    "method_body": "public static FastDateFormat getDateTimeInstance(\nint dateStyle, int timeStyle) {\nreturn getDateTimeInstance(dateStyle, timeStyle, null, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat:getDateTimeInstance(IILjava/util/Locale;)Lorg/apache/commons/lang/time/FastDateFormat;",
                                    "method_body": "public static FastDateFormat getDateTimeInstance(\nint dateStyle, int timeStyle, Locale locale) {\nreturn getDateTimeInstance(dateStyle, timeStyle, null, locale);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat:getDateTimeInstance(IILjava/util/TimeZone;Ljava/util/Locale;)Lorg/apache/commons/lang/time/FastDateFormat;",
                                    "method_body": "public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone,\nLocale locale) {\n\nObject key = new Pair(new Integer(dateStyle), new Integer(timeStyle));\nif (timeZone != null) {\nkey = new Pair(key, timeZone);\n}\nif (locale != null) {\nkey = new Pair(key, locale);\n}\n\nFastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);\nif (format == null) {\nif (locale == null) {\nlocale = Locale.getDefault();\n}\ntry {\nSimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,\nlocale);\nString pattern = formatter.toPattern();\nformat = getInstance(pattern, timeZone, locale);\ncDateTimeInstanceCache.put(key, format);\n\n} catch (ClassCastException ex) {\nthrow new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n}\n}\nreturn format;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$TwoDigitNumberField:<init>(I)V",
                                    "method_body": "TwoDigitNumberField(int field) {\nmField = field;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$TwoDigitNumberField:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nreturn 2;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$Pair:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object obj) {\nif (this == obj) {\nreturn true;\n}\n\nif (!(obj instanceof Pair)) {\nreturn false;\n}\n\nPair key = (Pair)obj;\n\nreturn\n(mObj1 == null ?\nkey.mObj1 == null : mObj1.equals(key.mObj1)) &&\n(mObj2 == null ?\nkey.mObj2 == null : mObj2.equals(key.mObj2));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$TwelveHourField:<init>(Lorg/apache/commons/lang/time/FastDateFormat$NumberRule;)V",
                                    "method_body": "TwelveHourField(NumberRule rule) {\nmRule = rule;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$TwelveHourField:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nreturn mRule.estimateLength();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$TimeZoneNameRule:<init>(Ljava/util/TimeZone;ZLjava/util/Locale;I)V",
                                    "method_body": "TimeZoneNameRule(TimeZone timeZone, boolean timeZoneForced, Locale locale, int style) {\nmTimeZone = timeZone;\nmTimeZoneForced = timeZoneForced;\nmLocale = locale;\nmStyle = style;\n\nif (timeZoneForced) {\nmStandard = getTimeZoneDisplay(timeZone, false, style, locale);\nmDaylight = getTimeZoneDisplay(timeZone, true, style, locale);\n} else {\nmStandard = null;\nmDaylight = null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$TimeZoneNameRule:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nif (mTimeZoneForced) {\nreturn Math.max(mStandard.length(), mDaylight.length());\n} else if (mStyle == TimeZone.SHORT) {\nreturn 4;\n} else {\nreturn 40;\n}\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang.time.FastDateFormatTest.test_changeDefault_Locale_DateInstance",
                            "test_body": "135: public void test_changeDefault_Locale_DateInstance() {\n136: Locale realDefaultLocale = Locale.getDefault();\n137: try {\n138: Locale.setDefault(Locale.US);\n139: FastDateFormat format1 = FastDateFormat.getDateInstance(FastDateFormat.FULL, Locale.GERMANY);\n140: FastDateFormat format2 = FastDateFormat.getDateInstance(FastDateFormat.FULL);\n141: Locale.setDefault(Locale.GERMANY);\n142: FastDateFormat format3 = FastDateFormat.getDateInstance(FastDateFormat.FULL);\n143: 144: assertSame(Locale.GERMANY, format1.getLocale());\n145: assertSame(Locale.US, format2.getLocale());\n146: assertSame(Locale.GERMANY, format3.getLocale());\n147: assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);\n148: assertTrue(format2 != format3);\n149: 150: } finally {\n151: Locale.setDefault(realDefaultLocale);\n152: }\n153: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat:<init>(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)V",
                                    "method_body": "protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {\nsuper();\nif (pattern == null) {\nthrow new IllegalArgumentException(\"The pattern must not be null\");\n}\nmPattern = pattern;\n\nmTimeZoneForced = (timeZone != null);\nif (timeZone == null) {\ntimeZone = TimeZone.getDefault();\n}\nmTimeZone = timeZone;\n\nmLocaleForced = (locale != null);\nif (locale == null) {\nlocale = Locale.getDefault();\n}\nmLocale = locale;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\n/**\n* FULL locale dependent date or time style.\n*/\npublic static final int FULL = DateFormat.FULL;\n/**\n* LONG locale dependent date or time style.\n*/\npublic static final int LONG = DateFormat.LONG;\n/**\n* MEDIUM locale dependent date or time style.\n*/\npublic static final int MEDIUM = DateFormat.MEDIUM;\n/**\n* SHORT locale dependent date or time style.\n*/\npublic static final int SHORT = DateFormat.SHORT;\n\nprivate static String cDefaultPattern;\n\nprivate static Map cInstanceCache = new HashMap(7);\nprivate static Map cDateInstanceCache = new HashMap(7);\nprivate static Map cTimeInstanceCache = new HashMap(7);\nprivate static Map cDateTimeInstanceCache = new HashMap(7);\nprivate static Map cTimeZoneDisplayCache = new HashMap(7);\n\n/**\n* The pattern.\n*/\nprivate final String mPattern;\n/**\n* The time zone.\n*/\nprivate final TimeZone mTimeZone;\n/**\n* Whether the time zone overrides any on Calendars.\n*/\nprivate final boolean mTimeZoneForced;\n/**\n* The locale.\n*/\nprivate final Locale mLocale;\n/**\n* Whether the locale overrides the default.\n*/\nprivate final boolean mLocaleForced;\n/**\n* The parsed rules.\n*/\nprivate transient Rule[] mRules;\n/**\n* The estimated maximum length.\n*/\nprivate transient int mMaxLengthEstimate;\n\n//-----------------------------------------------------------------------\n/**\n* <p>Gets a formatter instance using the default pattern in the\n* default locale.</p>\n*\n* @return a date/time formatter\n*/\npublic static FastDateFormat getInstance() {\nreturn getInstance(getDefaultPattern(), null, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat:getInstance(Ljava/lang/String;Ljava/util/TimeZone;Ljava/util/Locale;)Lorg/apache/commons/lang/time/FastDateFormat;",
                                    "method_body": "public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {\nFastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);\nFastDateFormat format = (FastDateFormat) cInstanceCache.get(emptyFormat);\nif (format == null) {\nformat = emptyFormat;\nformat.init();  // convert shell format into usable one\ncInstanceCache.put(format, format);  // this is OK!\n}\nreturn format;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat:getDateInstance(I)Lorg/apache/commons/lang/time/FastDateFormat;",
                                    "method_body": "public static FastDateFormat getDateInstance(int style) {\nreturn getDateInstance(style, null, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat:getDateInstance(ILjava/util/Locale;)Lorg/apache/commons/lang/time/FastDateFormat;",
                                    "method_body": "public static FastDateFormat getDateInstance(int style, Locale locale) {\nreturn getDateInstance(style, null, locale);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat:getDateInstance(ILjava/util/TimeZone;Ljava/util/Locale;)Lorg/apache/commons/lang/time/FastDateFormat;",
                                    "method_body": "public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {\nObject key = new Integer(style);\nif (timeZone != null) {\nkey = new Pair(key, timeZone);\n}\n\nif (locale != null) {\nkey = new Pair(key, locale);\n}\n\n\nFastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);\nif (format == null) {\nif (locale == null) {\nlocale = Locale.getDefault();\n}\ntry {\nSimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);\nString pattern = formatter.toPattern();\nformat = getInstance(pattern, timeZone, locale);\ncDateInstanceCache.put(key, format);\n\n} catch (ClassCastException ex) {\nthrow new IllegalArgumentException(\"No date pattern for locale: \" + locale);\n}\n}\nreturn format;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat:init()V",
                                    "method_body": "protected void init() {\nList rulesList = parsePattern();\nmRules = (Rule[]) rulesList.toArray(new Rule[rulesList.size()]);\n\nint len = 0;\nfor (int i=mRules.length; --i >= 0; ) {\nlen += mRules[i].estimateLength();\n}\n\nmMaxLengthEstimate = len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat:parsePattern()Ljava/util/List;",
                                    "method_body": "protected List parsePattern() {\nDateFormatSymbols symbols = new DateFormatSymbols(mLocale);\nList rules = new ArrayList();\n\nString[] ERAs = symbols.getEras();\nString[] months = symbols.getMonths();\nString[] shortMonths = symbols.getShortMonths();\nString[] weekdays = symbols.getWeekdays();\nString[] shortWeekdays = symbols.getShortWeekdays();\nString[] AmPmStrings = symbols.getAmPmStrings();\n\nint length = mPattern.length();\nint[] indexRef = new int[1];\n\nfor (int i = 0; i < length; i++) {\nindexRef[0] = i;\nString token = parseToken(mPattern, indexRef);\ni = indexRef[0];\n\nint tokenLen = token.length();\nif (tokenLen == 0) {\nbreak;\n}\n\nRule rule;\nchar c = token.charAt(0);\n\nswitch (c) {\ncase 'G': // era designator (text)\nrule = new TextField(Calendar.ERA, ERAs);\nbreak;\ncase 'y': // year (number)\nif (tokenLen >= 4) {\nrule = selectNumberRule(Calendar.YEAR, tokenLen);\n} else {\nrule = TwoDigitYearField.INSTANCE;\n}\nbreak;\ncase 'M': // month in year (text and number)\nif (tokenLen >= 4) {\nrule = new TextField(Calendar.MONTH, months);\n} else if (tokenLen == 3) {\nrule = new TextField(Calendar.MONTH, shortMonths);\n} else if (tokenLen == 2) {\nrule = TwoDigitMonthField.INSTANCE;\n} else {\nrule = UnpaddedMonthField.INSTANCE;\n}\nbreak;\ncase 'd': // day in month (number)\nrule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\nbreak;\ncase 'h': // hour in am/pm (number, 1..12)\nrule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\nbreak;\ncase 'H': // hour in day (number, 0..23)\nrule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\nbreak;\ncase 'm': // minute in hour (number)\nrule = selectNumberRule(Calendar.MINUTE, tokenLen);\nbreak;\ncase 's': // second in minute (number)\nrule = selectNumberRule(Calendar.SECOND, tokenLen);\nbreak;\ncase 'S': // millisecond (number)\nrule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\nbreak;\ncase 'E': // day in week (text)\nrule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\nbreak;\ncase 'D': // day in year (number)\nrule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\nbreak;\ncase 'F': // day of week in month (number)\nrule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\nbreak;\ncase 'w': // week in year (number)\nrule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\nbreak;\ncase 'W': // week in month (number)\nrule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\nbreak;\ncase 'a': // am/pm marker (text)\nrule = new TextField(Calendar.AM_PM, AmPmStrings);\nbreak;\ncase 'k': // hour in day (1..24)\nrule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\nbreak;\ncase 'K': // hour in am/pm (0..11)\nrule = selectNumberRule(Calendar.HOUR, tokenLen);\nbreak;\ncase 'z': // time zone (text)\nif (tokenLen >= 4) {\nrule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.LONG);\n} else {\nrule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.SHORT);\n}\nbreak;\ncase 'Z': // time zone (value)\nif (tokenLen == 1) {\nrule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n} else {\nrule = TimeZoneNumberRule.INSTANCE_COLON;\n}\nbreak;\ncase '\\'': // literal text\nString sub = token.substring(1);\nif (sub.length() == 1) {\nrule = new CharacterLiteral(sub.charAt(0));\n} else {\nrule = new StringLiteral(sub);\n}\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"Illegal pattern component: \" + token);\n}\n\nrules.add(rule);\n}\n\nreturn rules;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
                                    "method_body": "protected String parseToken(String pattern, int[] indexRef) {\nStringBuffer buf = new StringBuffer();\n\nint i = indexRef[0];\nint length = pattern.length();\n\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n// Scan a run of the same character, which indicates a time\n// pattern.\nbuf.append(c);\n\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append(c);\ni++;\n} else {\nbreak;\n}\n}\n} else {\n// This will identify token as text.\nbuf.append('\\'');\n\nboolean inLiteral = false;\n\nfor (; i < length; i++) {\nc = pattern.charAt(i);\n\nif (c == '\\'') {\nif (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n// '' is treated as escaped '\ni++;\nbuf.append(c);\n} else {\ninLiteral = !inLiteral;\n}\n} else if (!inLiteral &&\n(c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\ni--;\nbreak;\n} else {\nbuf.append(c);\n}\n}\n}\n\nindexRef[0] = i;\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat:selectNumberRule(II)Lorg/apache/commons/lang/time/FastDateFormat$NumberRule;",
                                    "method_body": "protected NumberRule selectNumberRule(int field, int padding) {\nswitch (padding) {\ncase 1:\nreturn new UnpaddedNumberField(field);\ncase 2:\nreturn new TwoDigitNumberField(field);\ndefault:\nreturn new PaddedNumberField(field, padding);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat:getLocale()Ljava/util/Locale;",
                                    "method_body": "public Locale getLocale() {\nreturn mLocale;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat:hashCode()I",
                                    "method_body": "public int hashCode() {\nint total = 0;\ntotal += mPattern.hashCode();\ntotal += mTimeZone.hashCode();\ntotal += (mTimeZoneForced ? 1 : 0);\ntotal += mLocale.hashCode();\ntotal += (mLocaleForced ? 1 : 0);\nreturn total;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$PaddedNumberField:<init>(II)V",
                                    "method_body": "PaddedNumberField(int field, int size) {\nif (size < 3) {\n// Should use UnpaddedNumberField or TwoDigitNumberField.\nthrow new IllegalArgumentException();\n}\nmField = field;\nmSize = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$PaddedNumberField:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nreturn 4;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$CharacterLiteral:<init>(C)V",
                                    "method_body": "void appendTo(StringBuffer buffer, int value);\n}\n\n/**\n* <p>Inner class to output a constant single character.</p>\n*/\nprivate static class CharacterLiteral implements Rule {\nprivate final char mValue;\n\n/**\n* Constructs a new instance of <code>CharacterLiteral</code>\n* to hold the specified value.\n*\n* @param value the character literal\n*/\nCharacterLiteral(char value) {\nmValue = value;\n}\n\n/**\n* {@inheritDoc}\n*/\npublic int estimateLength() {\nreturn 1;\n}\n\n/**\n* {@inheritDoc}\n*/\npublic void appendTo(StringBuffer buffer, Calendar calendar) {\nbuffer.append(mValue);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$CharacterLiteral:estimateLength()I",
                                    "method_body": "void appendTo(StringBuffer buffer, int value);\n}\n\n/**\n* <p>Inner class to output a constant single character.</p>\n*/\nprivate static class CharacterLiteral implements Rule {\nprivate final char mValue;\n\n/**\n* Constructs a new instance of <code>CharacterLiteral</code>\n* to hold the specified value.\n*\n* @param value the character literal\n*/\nCharacterLiteral(char value) {\nmValue = value;\n}\n\n/**\n* {@inheritDoc}\n*/\npublic int estimateLength() {\nreturn 1;\n}\n\n/**\n* {@inheritDoc}\n*/\npublic void appendTo(StringBuffer buffer, Calendar calendar) {\nbuffer.append(mValue);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$TextField:<init>(I[Ljava/lang/String;)V",
                                    "method_body": "TextField(int field, String[] values) {\nmField = field;\nmValues = values;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$TextField:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nint max = 0;\nfor (int i=mValues.length; --i >= 0; ) {\nint len = mValues[i].length();\nif (len > max) {\nmax = len;\n}\n}\nreturn max;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$StringLiteral:<init>(Ljava/lang/String;)V",
                                    "method_body": "StringLiteral(String value) {\nmValue = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$StringLiteral:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nreturn mValue.length();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$UnpaddedNumberField:<init>(I)V",
                                    "method_body": "UnpaddedNumberField(int field) {\nmField = field;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$UnpaddedNumberField:<clinit>()V",
                                    "method_body": "static final UnpaddedNumberField INSTANCE_YEAR = new UnpaddedNumberField(Calendar.YEAR);\n\nprivate final int mField;\n\n/**\n* Constructs an instance of <code>UnpadedNumberField</code> with the specified field.\n*\n* @param field the field\n*/\nUnpaddedNumberField(int field) {\nmField = field;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$UnpaddedNumberField:estimateLength()I",
                                    "method_body": "public int estimateLength() {\nreturn 4;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$Pair:<init>(Ljava/lang/Object;Ljava/lang/Object;)V",
                                    "method_body": "public Pair(Object obj1, Object obj2) {\nmObj1 = obj1;\nmObj2 = obj2;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.FastDateFormat$Pair:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn\n(mObj1 == null ? 0 : mObj1.hashCode()) +\n(mObj2 == null ? 0 : mObj2.hashCode());\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 51,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang.BooleanUtilsTest.test_toBoolean_String",
                            "test_body": "295: public void test_toBoolean_String() {\n296: assertEquals(false, BooleanUtils.toBoolean((String) null));\n297: assertEquals(false, BooleanUtils.toBoolean(\"\"));\n298: assertEquals(false, BooleanUtils.toBoolean(\"off\"));\n299: assertEquals(false, BooleanUtils.toBoolean(\"oof\"));\n300: assertEquals(false, BooleanUtils.toBoolean(\"yep\"));\n301: assertEquals(false, BooleanUtils.toBoolean(\"trux\"));\n302: assertEquals(false, BooleanUtils.toBoolean(\"false\"));\n303: assertEquals(false, BooleanUtils.toBoolean(\"a\"));\n304: assertEquals(true, BooleanUtils.toBoolean(\"true\")); // interned handled differently\n305: assertEquals(true, BooleanUtils.toBoolean(new StringBuffer(\"tr\").append(\"ue\").toString()));\n306: assertEquals(true, BooleanUtils.toBoolean(\"truE\"));\n307: assertEquals(true, BooleanUtils.toBoolean(\"trUe\"));\n308: assertEquals(true, BooleanUtils.toBoolean(\"trUE\"));\n309: assertEquals(true, BooleanUtils.toBoolean(\"tRue\"));\n310: assertEquals(true, BooleanUtils.toBoolean(\"tRuE\"));\n311: assertEquals(true, BooleanUtils.toBoolean(\"tRUe\"));\n312: assertEquals(true, BooleanUtils.toBoolean(\"tRUE\"));\n313: assertEquals(true, BooleanUtils.toBoolean(\"TRUE\"));\n314: assertEquals(true, BooleanUtils.toBoolean(\"TRUe\"));\n315: assertEquals(true, BooleanUtils.toBoolean(\"TRuE\"));\n316: assertEquals(true, BooleanUtils.toBoolean(\"TRue\"));\n317: assertEquals(true, BooleanUtils.toBoolean(\"TrUE\"));\n318: assertEquals(true, BooleanUtils.toBoolean(\"TrUe\"));\n319: assertEquals(true, BooleanUtils.toBoolean(\"TruE\"));\n320: assertEquals(true, BooleanUtils.toBoolean(\"True\"));\n321: assertEquals(true, BooleanUtils.toBoolean(\"on\"));\n322: assertEquals(true, BooleanUtils.toBoolean(\"oN\"));\n323: assertEquals(true, BooleanUtils.toBoolean(\"On\"));\n324: assertEquals(true, BooleanUtils.toBoolean(\"ON\"));\n325: assertEquals(true, BooleanUtils.toBoolean(\"yes\"));\n326: assertEquals(true, BooleanUtils.toBoolean(\"yeS\"));\n327: assertEquals(true, BooleanUtils.toBoolean(\"yEs\"));\n328: assertEquals(true, BooleanUtils.toBoolean(\"yES\"));\n329: assertEquals(true, BooleanUtils.toBoolean(\"Yes\"));\n330: assertEquals(true, BooleanUtils.toBoolean(\"YeS\"));\n331: assertEquals(true, BooleanUtils.toBoolean(\"YEs\"));\n332: assertEquals(true, BooleanUtils.toBoolean(\"YES\"));\n333: assertEquals(false, BooleanUtils.toBoolean(\"yes?\"));\n334: assertEquals(false, BooleanUtils.toBoolean(\"tru\"));\n335: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.BooleanUtils:toBoolean(Ljava/lang/String;)Z",
                                    "method_body": "public static boolean toBoolean(String str) {\n// Previously used equalsIgnoreCase, which was fast for interned 'true'.\n// Non interned 'true' matched 15 times slower.\n//\n// Optimisation provides same performance as before for interned 'true'.\n// Similar performance for null, 'false', and other strings not length 2/3/4.\n// 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\nif (str == \"true\") {\nreturn true;\n}\nif (str == null) {\nreturn false;\n}\nswitch (str.length()) {\ncase 2: {\nchar ch0 = str.charAt(0);\nchar ch1 = str.charAt(1);\nreturn\n(ch0 == 'o' || ch0 == 'O') &&\n(ch1 == 'n' || ch1 == 'N');\n}\ncase 3: {\nchar ch = str.charAt(0);\nif (ch == 'y') {\nreturn\n(str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n(str.charAt(2) == 's' || str.charAt(2) == 'S');\n}\nif (ch == 'Y') {\nreturn\n(str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n(str.charAt(2) == 'S' || str.charAt(2) == 's');\n}\n}\ncase 4: {\nchar ch = str.charAt(0);\nif (ch == 't') {\nreturn\n(str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n(str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n(str.charAt(3) == 'e' || str.charAt(3) == 'E');\n}\nif (ch == 'T') {\nreturn\n(str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n(str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n(str.charAt(3) == 'E' || str.charAt(3) == 'e');\n}\n}\n}\nreturn false;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 52,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang.StringEscapeUtilsTest.testEscapeJavaScript",
                            "test_body": "169: public void testEscapeJavaScript() {\n170: assertEquals(null, StringEscapeUtils.escapeJavaScript(null));\n171: try {\n172: StringEscapeUtils.escapeJavaScript(null, null);\n173: fail();\n174: } catch (IOException ex) {\n175: fail();\n176: } catch (IllegalArgumentException ex) {\n177: }\n178: try {\n179: StringEscapeUtils.escapeJavaScript(null, \"\");\n180: fail();\n181: } catch (IOException ex) {\n182: fail();\n183: } catch (IllegalArgumentException ex) {\n184: }\n185: 186: assertEquals(\"He didn\\\\'t say, \\\\\\\"stop!\\\\\\\"\", StringEscapeUtils.escapeJavaScript(\"He didn't say, \\\"stop!\\\"\"));\n187: assertEquals(\"document.getElementById(\\\\\\\"test\\\\\\\").value = \\\\'<script>alert(\\\\'aaa\\\\');<\\\\/script>\\\\';\", \n188: StringEscapeUtils.escapeJavaScript(\"document.getElementById(\\\"test\\\").value = '<script>alert('aaa');</script>';\"));\n189: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.StringEscapeUtils:escapeJavaScript(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public static String escapeJavaScript(String str) {\nreturn escapeJavaStyleString(str, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.StringEscapeUtils:escapeJavaScript(Ljava/io/Writer;Ljava/lang/String;)V",
                                    "method_body": "public static void escapeJavaScript(Writer out, String str) throws IOException {\nescapeJavaStyleString(out, str, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.StringEscapeUtils:escapeJavaStyleString(Ljava/lang/String;Z)Ljava/lang/String;",
                                    "method_body": "private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\nif (str == null) {\nreturn null;\n}\ntry {\nStringWriter writer = new StringWriter(str.length() * 2);\nescapeJavaStyleString(writer, str, escapeSingleQuotes);\nreturn writer.toString();\n} catch (IOException ioe) {\n// this should never ever happen while writing to a StringWriter\nioe.printStackTrace();\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.StringEscapeUtils:escapeJavaStyleString(Ljava/io/Writer;Ljava/lang/String;Z)V",
                                    "method_body": "private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\nif (out == null) {\nthrow new IllegalArgumentException(\"The Writer must not be null\");\n}\nif (str == null) {\nreturn;\n}\nint sz;\nsz = str.length();\nfor (int i = 0; i < sz; i++) {\nchar ch = str.charAt(i);\n\n// handle unicode\nif (ch > 0xfff) {\nout.write(\"\\\\u\" + hex(ch));\n} else if (ch > 0xff) {\nout.write(\"\\\\u0\" + hex(ch));\n} else if (ch > 0x7f) {\nout.write(\"\\\\u00\" + hex(ch));\n} else if (ch < 32) {\nswitch (ch) {\ncase '\\b':\nout.write('\\\\');\nout.write('b');\nbreak;\ncase '\\n':\nout.write('\\\\');\nout.write('n');\nbreak;\ncase '\\t':\nout.write('\\\\');\nout.write('t');\nbreak;\ncase '\\f':\nout.write('\\\\');\nout.write('f');\nbreak;\ncase '\\r':\nout.write('\\\\');\nout.write('r');\nbreak;\ndefault :\nif (ch > 0xf) {\nout.write(\"\\\\u00\" + hex(ch));\n} else {\nout.write(\"\\\\u000\" + hex(ch));\n}\nbreak;\n}\n} else {\nswitch (ch) {\ncase '\\'':\nif (escapeSingleQuote) {\nout.write('\\\\');\n}\nout.write('\\'');\nbreak;\ncase '\"':\nout.write('\\\\');\nout.write('\"');\nbreak;\ncase '\\\\':\nout.write('\\\\');\nout.write('\\\\');\nbreak;\ndefault :\nout.write(ch);\nbreak;\n}\n}\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 53,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang.time.DateUtilsTest.testRoundLang346",
                            "test_body": "705: public void testRoundLang346() throws Exception\n706: {\n707: TimeZone.setDefault(defaultZone);\n708: dateTimeParser.setTimeZone(defaultZone);\n709: Calendar testCalendar = Calendar.getInstance();\n710: testCalendar.set(2007, 6, 2, 8, 8, 50);\n711: Date date = testCalendar.getTime();\n712: assertEquals(\"Minute Round Up Failed\",\n713: dateTimeParser.parse(\"July 2, 2007 08:09:00.000\"),\n714: DateUtils.round(date, Calendar.MINUTE));\n715: 716: testCalendar.set(2007, 6, 2, 8, 8, 20);\n717: date = testCalendar.getTime();\n718: assertEquals(\"Minute No Round Failed\",\n719: dateTimeParser.parse(\"July 2, 2007 08:08:00.000\"),\n720: DateUtils.round(date, Calendar.MINUTE));\n721: 722: testCalendar.set(2007, 6, 2, 8, 8, 50);\n723: testCalendar.set(Calendar.MILLISECOND, 600);\n724: date = testCalendar.getTime();\n725: 726: assertEquals(\"Second Round Up with 600 Milli Seconds Failed\",\n727: dateTimeParser.parse(\"July 2, 2007 08:08:51.000\"),\n728: DateUtils.round(date, Calendar.SECOND));\n729: 730: testCalendar.set(2007, 6, 2, 8, 8, 50);\n731: testCalendar.set(Calendar.MILLISECOND, 200);\n732: date = testCalendar.getTime();\n733: assertEquals(\"Second Round Down with 200 Milli Seconds Failed\",\n734: dateTimeParser.parse(\"July 2, 2007 08:08:50.000\"),\n735: DateUtils.round(date, Calendar.SECOND));\n736: 737: testCalendar.set(2007, 6, 2, 8, 8, 20);\n738: testCalendar.set(Calendar.MILLISECOND, 600);\n739: date = testCalendar.getTime();\n740: assertEquals(\"Second Round Up with 200 Milli Seconds Failed\",\n741: dateTimeParser.parse(\"July 2, 2007 08:08:21.000\"),\n742: DateUtils.round(date, Calendar.SECOND));\n743: 744: testCalendar.set(2007, 6, 2, 8, 8, 20);\n745: testCalendar.set(Calendar.MILLISECOND, 200);\n746: date = testCalendar.getTime();\n747: assertEquals(\"Second Round Down with 200 Milli Seconds Failed\",\n748: dateTimeParser.parse(\"July 2, 2007 08:08:20.000\"),\n749: DateUtils.round(date, Calendar.SECOND));\n750: 751: testCalendar.set(2007, 6, 2, 8, 8, 50);\n752: date = testCalendar.getTime();\n753: assertEquals(\"Hour Round Down Failed\",\n754: dateTimeParser.parse(\"July 2, 2007 08:00:00.000\"),\n755: DateUtils.round(date, Calendar.HOUR));\n756: 757: testCalendar.set(2007, 6, 2, 8, 31, 50);\n758: date = testCalendar.getTime();\n759: assertEquals(\"Hour Round Up Failed\",\n760: dateTimeParser.parse(\"July 2, 2007 09:00:00.000\"),\n761: DateUtils.round(date, Calendar.HOUR));\n762: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.time.DateUtils:<clinit>()V",
                                    "method_body": "public static final TimeZone UTC_TIME_ZONE = TimeZone.getTimeZone(\"GMT\");\n/**\n* Number of milliseconds in a standard second.\n* @since 2.1\n*/\npublic static final long MILLIS_PER_SECOND = 1000;\n/**\n* Number of milliseconds in a standard minute.\n* @since 2.1\n*/\npublic static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n/**\n* Number of milliseconds in a standard hour.\n* @since 2.1\n*/\npublic static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n/**\n* Number of milliseconds in a standard day.\n* @since 2.1\n*/\npublic static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR;\n\n/**\n* This is half a month, so this represents whether a date is in the top\n* or bottom half of the month.\n*/\npublic final static int SEMI_MONTH = 1001;\n\nprivate static final int[][] fields = {\n{Calendar.MILLISECOND},\n{Calendar.SECOND},\n{Calendar.MINUTE},\n{Calendar.HOUR_OF_DAY, Calendar.HOUR},\n{Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM\n/* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */\n},\n{Calendar.MONTH, DateUtils.SEMI_MONTH},\n{Calendar.YEAR},\n{Calendar.ERA}};"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.DateUtils:round(Ljava/util/Date;I)Ljava/util/Date;",
                                    "method_body": "public static Date round(Date date, int field) {\nif (date == null) {\nthrow new IllegalArgumentException(\"The date must not be null\");\n}\nCalendar gval = Calendar.getInstance();\ngval.setTime(date);\nmodify(gval, field, true);\nreturn gval.getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.DateUtils:modify(Ljava/util/Calendar;IZ)V",
                                    "method_body": "private static void modify(Calendar val, int field, boolean round) {\nif (val.get(Calendar.YEAR) > 280000000) {\nthrow new ArithmeticException(\"Calendar value too large for accurate calculations\");\n}\n\nif (field == Calendar.MILLISECOND) {\nreturn;\n}\n\n// ----------------- Fix for LANG-59 ---------------------- START ---------------\n// see http://issues.apache.org/jira/browse/LANG-59\n//\n// Manually truncate milliseconds, seconds and minutes, rather than using\n// Calendar methods.\n\nDate date = val.getTime();\nlong time = date.getTime();\nboolean done = false;\n\n// truncate milliseconds\nint millisecs = val.get(Calendar.MILLISECOND);\nif (!round || millisecs < 500) {\ntime = time - millisecs;\nif (field == Calendar.SECOND) {\ndone = true;\n}\n}\n\n// truncate seconds\nint seconds = val.get(Calendar.SECOND);\nif (!done && (!round || seconds < 30)) {\ntime = time - (seconds * 1000L);\nif (field == Calendar.MINUTE) {\ndone = true;\n}\n}\n\n// truncate minutes\nint minutes = val.get(Calendar.MINUTE);\nif (!done && (!round || minutes < 30)) {\ntime = time - (minutes * 60000L);\n}\n\n// reset time\nif (date.getTime() != time) {\ndate.setTime(time);\nval.setTime(date);\n}\n// ----------------- Fix for LANG-59 ----------------------- END ----------------\n\nboolean roundUp = false;\nfor (int i = 0; i < fields.length; i++) {\nfor (int j = 0; j < fields[i].length; j++) {\nif (fields[i][j] == field) {\n//This is our field... we stop looping\nif (round && roundUp) {\nif (field == DateUtils.SEMI_MONTH) {\n//This is a special case that's hard to generalize\n//If the date is 1, we round up to 16, otherwise\n//  we subtract 15 days and add 1 month\nif (val.get(Calendar.DATE) == 1) {\nval.add(Calendar.DATE, 15);\n} else {\nval.add(Calendar.DATE, -15);\nval.add(Calendar.MONTH, 1);\n}\n} else {\n//We need at add one to this field since the\n//  last number causes us to round up\nval.add(fields[i][0], 1);\n}\n}\nreturn;\n}\n}\n//We have various fields that are not easy roundings\nint offset = 0;\nboolean offsetSet = false;\n//These are special types of fields that require different rounding rules\nswitch (field) {\ncase DateUtils.SEMI_MONTH:\nif (fields[i][0] == Calendar.DATE) {\n//If we're going to drop the DATE field's value,\n//  we want to do this our own way.\n//We need to subtrace 1 since the date has a minimum of 1\noffset = val.get(Calendar.DATE) - 1;\n//If we're above 15 days adjustment, that means we're in the\n//  bottom half of the month and should stay accordingly.\nif (offset >= 15) {\noffset -= 15;\n}\n//Record whether we're in the top or bottom half of that range\nroundUp = offset > 7;\noffsetSet = true;\n}\nbreak;\ncase Calendar.AM_PM:\nif (fields[i][0] == Calendar.HOUR_OF_DAY) {\n//If we're going to drop the HOUR field's value,\n//  we want to do this our own way.\noffset = val.get(Calendar.HOUR_OF_DAY);\nif (offset >= 12) {\noffset -= 12;\n}\nroundUp = offset > 6;\noffsetSet = true;\n}\nbreak;\n}\nif (!offsetSet) {\nint min = val.getActualMinimum(fields[i][0]);\nint max = val.getActualMaximum(fields[i][0]);\n//Calculate the offset from the minimum allowed value\noffset = val.get(fields[i][0]) - min;\n//Set roundUp if this is more than half way between the minimum and maximum\nroundUp = offset > ((max - min) / 2);\n}\n//We need to remove this field\nif (offset != 0) {\nval.set(fields[i][0], val.get(fields[i][0]) - offset);\n}\n}\nthrow new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 54,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang.LocaleUtilsTest.testLang328",
                            "test_body": "504: public void testLang328() {\n505: assertValidToLocale(\"fr__POSIX\", \"fr\", \"\", \"POSIX\");\n506: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.LocaleUtils:<clinit>()V",
                                    "method_body": "private static final List cAvailableLocaleList;\n/** Unmodifiable set of available locales. */\nprivate static Set cAvailableLocaleSet;\n/** Unmodifiable map of language locales by country. */\nprivate static final Map cLanguagesByCountry = Collections.synchronizedMap(new HashMap());\n/** Unmodifiable map of country locales by language. */\nprivate static final Map cCountriesByLanguage = Collections.synchronizedMap(new HashMap());\nstatic {\nList list = Arrays.asList(Locale.getAvailableLocales());\ncAvailableLocaleList = Collections.unmodifiableList(list);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.LocaleUtils:toLocale(Ljava/lang/String;)Ljava/util/Locale;",
                                    "method_body": "public static Locale toLocale(String str) {\nif (str == null) {\nreturn null;\n}\nint len = str.length();\nif (len != 2 && len != 5 && len < 7) {\nthrow new IllegalArgumentException(\"Invalid locale format: \" + str);\n}\nchar ch0 = str.charAt(0);\nchar ch1 = str.charAt(1);\nif (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {\nthrow new IllegalArgumentException(\"Invalid locale format: \" + str);\n}\nif (len == 2) {\nreturn new Locale(str, \"\");\n} else {\nif (str.charAt(2) != '_') {\nthrow new IllegalArgumentException(\"Invalid locale format: \" + str);\n}\nchar ch3 = str.charAt(3);\nchar ch4 = str.charAt(4);\nif (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {\nthrow new IllegalArgumentException(\"Invalid locale format: \" + str);\n}\nif (len == 5) {\nreturn new Locale(str.substring(0, 2), str.substring(3, 5));\n} else {\nif (str.charAt(5) != '_') {\nthrow new IllegalArgumentException(\"Invalid locale format: \" + str);\n}\nreturn new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.LocaleUtils:availableLocaleList()Ljava/util/List;",
                                    "method_body": "public static List availableLocaleList() {\nreturn cAvailableLocaleList;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.LocaleUtils:isAvailableLocale(Ljava/util/Locale;)Z",
                                    "method_body": "public static boolean isAvailableLocale(Locale locale) {\nreturn availableLocaleList().contains(locale);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 55,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang.time.StopWatchTest.testLang315",
                            "test_body": "111: public void testLang315() {\n112: StopWatch watch = new StopWatch();\n113: watch.start();\n114: try {Thread.sleep(200);} catch (InterruptedException ex) {}\n115: watch.suspend();\n116: long suspendTime = watch.getTime();\n117: try {Thread.sleep(200);} catch (InterruptedException ex) {}\n118: watch.stop();\n119: long totalTime = watch.getTime();\n120: assertTrue( suspendTime == totalTime );\n121: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.time.StopWatch:<init>()V",
                                    "method_body": "public StopWatch() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.StopWatch:start()V",
                                    "method_body": "public void start() {\nif(this.runningState == STATE_STOPPED) {\nthrow new IllegalStateException(\"Stopwatch must be reset before being restarted. \");\n}\nif(this.runningState != STATE_UNSTARTED) {\nthrow new IllegalStateException(\"Stopwatch already started. \");\n}\nstopTime = -1;\nstartTime = System.currentTimeMillis();\nthis.runningState = STATE_RUNNING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.StopWatch:stop()V",
                                    "method_body": "public void stop() {\nif(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\nthrow new IllegalStateException(\"Stopwatch is not running. \");\n}\nstopTime = System.currentTimeMillis();\nthis.runningState = STATE_STOPPED;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.StopWatch:suspend()V",
                                    "method_body": "public void suspend() {\nif(this.runningState != STATE_RUNNING) {\nthrow new IllegalStateException(\"Stopwatch must be running to suspend. \");\n}\nstopTime = System.currentTimeMillis();\nthis.runningState = STATE_SUSPENDED;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.StopWatch:getTime()J",
                                    "method_body": "public long getTime() {\nif(this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) {\nreturn this.stopTime - this.startTime;\n} else\nif(this.runningState == STATE_UNSTARTED) {\nreturn 0;\n} else\nif(this.runningState == STATE_RUNNING) {\nreturn System.currentTimeMillis() - this.startTime;\n}\nthrow new RuntimeException(\"Illegal running state has occured. \");\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 57,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang.LocaleUtilsTest.testAvailableLocaleList",
                            "test_body": "348: public void testAvailableLocaleList() {\n349: List list = LocaleUtils.availableLocaleList();\n350: List list2 = LocaleUtils.availableLocaleList();\n351: assertNotNull(list);\n352: assertSame(list, list2);\n353: assertUnmodifiableCollection(list);\n354: 355: Locale[] jdkLocaleArray = Locale.getAvailableLocales();\n356: List jdkLocaleList = Arrays.asList(jdkLocaleArray);\n357: assertEquals(jdkLocaleList, list);\n358: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.LocaleUtils:<clinit>()V",
                                    "method_body": "private static final List cAvailableLocaleList;\n/** Unmodifiable set of available locales. */\nprivate static Set cAvailableLocaleSet;\n/** Unmodifiable map of language locales by country. */\nprivate static final Map cLanguagesByCountry = Collections.synchronizedMap(new HashMap());\n/** Unmodifiable map of country locales by language. */\nprivate static final Map cCountriesByLanguage = Collections.synchronizedMap(new HashMap());\nstatic {\nList list = Arrays.asList(Locale.getAvailableLocales());\ncAvailableLocaleList = Collections.unmodifiableList(list);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.LocaleUtils:isAvailableLocale(Ljava/util/Locale;)Z",
                                    "method_body": "public static boolean isAvailableLocale(Locale locale) {\nreturn cAvailableLocaleSet.contains(locale);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang.LocaleUtilsTest.testLanguagesByCountry",
                            "test_body": "432: public void testLanguagesByCountry() {\n433: assertLanguageByCountry(null, new String[0]);\n434: assertLanguageByCountry(\"GB\", new String[]{\"en\"});\n435: assertLanguageByCountry(\"ZZ\", new String[0]);\n436: assertLanguageByCountry(\"CH\", new String[]{\"fr\", \"de\", \"it\"});\n437: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.LocaleUtils:<clinit>()V",
                                    "method_body": "private static final List cAvailableLocaleList;\n/** Unmodifiable set of available locales. */\nprivate static Set cAvailableLocaleSet;\n/** Unmodifiable map of language locales by country. */\nprivate static final Map cLanguagesByCountry = Collections.synchronizedMap(new HashMap());\n/** Unmodifiable map of country locales by language. */\nprivate static final Map cCountriesByLanguage = Collections.synchronizedMap(new HashMap());\nstatic {\nList list = Arrays.asList(Locale.getAvailableLocales());\ncAvailableLocaleList = Collections.unmodifiableList(list);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.LocaleUtils:isAvailableLocale(Ljava/util/Locale;)Z",
                                    "method_body": "public static boolean isAvailableLocale(Locale locale) {\nreturn cAvailableLocaleSet.contains(locale);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang.LocaleUtilsTest.testToLocale_3Part",
                            "test_body": "231: public void testToLocale_3Part() {\n232: assertValidToLocale(\"us_EN_A\", \"us\", \"EN\", \"A\");\n233: // this isn't pretty, but was caused by a jdk bug it seems\n234: // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4210525\n235: if (SystemUtils.isJavaVersionAtLeast(1.4f)) {\n236: assertValidToLocale(\"us_EN_a\", \"us\", \"EN\", \"a\");\n237: assertValidToLocale(\"us_EN_SFsafdFDsdfF\", \"us\", \"EN\", \"SFsafdFDsdfF\");\n238: } else {\n239: assertValidToLocale(\"us_EN_a\", \"us\", \"EN\", \"A\");\n240: assertValidToLocale(\"us_EN_SFsafdFDsdfF\", \"us\", \"EN\", \"SFSAFDFDSDFF\");\n241: }\n242: 243: try {\n244: LocaleUtils.toLocale(\"us_EN-a\");\n245: fail(\"Should fail as not underscore\");\n246: } catch (IllegalArgumentException iae) {}\n247: try {\n248: LocaleUtils.toLocale(\"uu_UU_\");\n249: fail(\"Must be 3, 5 or 7+ in length\");\n250: } catch (IllegalArgumentException iae) {}\n251: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.LocaleUtils:<clinit>()V",
                                    "method_body": "private static final List cAvailableLocaleList;\n/** Unmodifiable set of available locales. */\nprivate static Set cAvailableLocaleSet;\n/** Unmodifiable map of language locales by country. */\nprivate static final Map cLanguagesByCountry = Collections.synchronizedMap(new HashMap());\n/** Unmodifiable map of country locales by language. */\nprivate static final Map cCountriesByLanguage = Collections.synchronizedMap(new HashMap());\nstatic {\nList list = Arrays.asList(Locale.getAvailableLocales());\ncAvailableLocaleList = Collections.unmodifiableList(list);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.LocaleUtils:isAvailableLocale(Ljava/util/Locale;)Z",
                                    "method_body": "public static boolean isAvailableLocale(Locale locale) {\nreturn cAvailableLocaleSet.contains(locale);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang.LocaleUtilsTest.testIsAvailableLocale",
                            "test_body": "381: public void testIsAvailableLocale() {\n382: Set set = LocaleUtils.availableLocaleSet();\n383: assertEquals(set.contains(LOCALE_EN), LocaleUtils.isAvailableLocale(LOCALE_EN));\n384: assertEquals(set.contains(LOCALE_EN_US), LocaleUtils.isAvailableLocale(LOCALE_EN_US));\n385: assertEquals(set.contains(LOCALE_EN_US_ZZZZ), LocaleUtils.isAvailableLocale(LOCALE_EN_US_ZZZZ));\n386: assertEquals(set.contains(LOCALE_FR), LocaleUtils.isAvailableLocale(LOCALE_FR));\n387: assertEquals(set.contains(LOCALE_FR_CA), LocaleUtils.isAvailableLocale(LOCALE_FR_CA));\n388: assertEquals(set.contains(LOCALE_QQ), LocaleUtils.isAvailableLocale(LOCALE_QQ));\n389: assertEquals(set.contains(LOCALE_QQ_ZZ), LocaleUtils.isAvailableLocale(LOCALE_QQ_ZZ));\n390: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.LocaleUtils:<clinit>()V",
                                    "method_body": "private static final List cAvailableLocaleList;\n/** Unmodifiable set of available locales. */\nprivate static Set cAvailableLocaleSet;\n/** Unmodifiable map of language locales by country. */\nprivate static final Map cLanguagesByCountry = Collections.synchronizedMap(new HashMap());\n/** Unmodifiable map of country locales by language. */\nprivate static final Map cCountriesByLanguage = Collections.synchronizedMap(new HashMap());\nstatic {\nList list = Arrays.asList(Locale.getAvailableLocales());\ncAvailableLocaleList = Collections.unmodifiableList(list);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.LocaleUtils:isAvailableLocale(Ljava/util/Locale;)Z",
                                    "method_body": "public static boolean isAvailableLocale(Locale locale) {\nreturn cAvailableLocaleSet.contains(locale);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang.LocaleUtilsTest.testToLocale_2Part",
                            "test_body": "197: public void testToLocale_2Part() {\n198: assertValidToLocale(\"us_EN\", \"us\", \"EN\");\n199: //valid though doesnt exist\n200: assertValidToLocale(\"us_ZH\", \"us\", \"ZH\");\n201: 202: try {\n203: LocaleUtils.toLocale(\"us-EN\");\n204: fail(\"Should fail as not underscore\");\n205: } catch (IllegalArgumentException iae) {}\n206: try {\n207: LocaleUtils.toLocale(\"us_En\");\n208: fail(\"Should fail second part not uppercase\");\n209: } catch (IllegalArgumentException iae) {}\n210: try {\n211: LocaleUtils.toLocale(\"us_en\");\n212: fail(\"Should fail second part not uppercase\");\n213: } catch (IllegalArgumentException iae) {}\n214: try {\n215: LocaleUtils.toLocale(\"us_eN\");\n216: fail(\"Should fail second part not uppercase\");\n217: } catch (IllegalArgumentException iae) {}\n218: try {\n219: LocaleUtils.toLocale(\"uS_EN\");\n220: fail(\"Should fail first part not lowercase\");\n221: } catch (IllegalArgumentException iae) {}\n222: try {\n223: LocaleUtils.toLocale(\"us_E3\");\n224: fail(\"Should fail second part not uppercase\");\n225: } catch (IllegalArgumentException iae) {}\n226: }        \n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.LocaleUtils:<clinit>()V",
                                    "method_body": "private static final List cAvailableLocaleList;\n/** Unmodifiable set of available locales. */\nprivate static Set cAvailableLocaleSet;\n/** Unmodifiable map of language locales by country. */\nprivate static final Map cLanguagesByCountry = Collections.synchronizedMap(new HashMap());\n/** Unmodifiable map of country locales by language. */\nprivate static final Map cCountriesByLanguage = Collections.synchronizedMap(new HashMap());\nstatic {\nList list = Arrays.asList(Locale.getAvailableLocales());\ncAvailableLocaleList = Collections.unmodifiableList(list);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.LocaleUtils:isAvailableLocale(Ljava/util/Locale;)Z",
                                    "method_body": "public static boolean isAvailableLocale(Locale locale) {\nreturn cAvailableLocaleSet.contains(locale);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang.LocaleUtilsTest.testLocaleLookupList_LocaleLocale",
                            "test_body": "294: public void testLocaleLookupList_LocaleLocale() {\n295: assertLocaleLookupList(LOCALE_QQ, LOCALE_QQ, \n296: new Locale[]{LOCALE_QQ});\n297: assertLocaleLookupList(LOCALE_EN, LOCALE_EN, \n298: new Locale[]{LOCALE_EN});\n299: 300: assertLocaleLookupList(LOCALE_EN_US, LOCALE_EN_US, \n301: new Locale[]{\n302: LOCALE_EN_US,\n303: LOCALE_EN});\n304: assertLocaleLookupList(LOCALE_EN_US, LOCALE_QQ,\n305: new Locale[] {\n306: LOCALE_EN_US,\n307: LOCALE_EN,\n308: LOCALE_QQ});\n309: assertLocaleLookupList(LOCALE_EN_US, LOCALE_QQ_ZZ,\n310: new Locale[] {\n311: LOCALE_EN_US,\n312: LOCALE_EN,\n313: LOCALE_QQ_ZZ});\n314: 315: assertLocaleLookupList(LOCALE_EN_US_ZZZZ, null,\n316: new Locale[] {\n317: LOCALE_EN_US_ZZZZ,\n318: LOCALE_EN_US,\n319: LOCALE_EN});\n320: assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_EN_US_ZZZZ,\n321: new Locale[] {\n322: LOCALE_EN_US_ZZZZ,\n323: LOCALE_EN_US,\n324: LOCALE_EN});\n325: assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_QQ,\n326: new Locale[] {\n327: LOCALE_EN_US_ZZZZ,\n328: LOCALE_EN_US,\n329: LOCALE_EN,\n330: LOCALE_QQ});\n331: assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_QQ_ZZ,\n332: new Locale[] {\n333: LOCALE_EN_US_ZZZZ,\n334: LOCALE_EN_US,\n335: LOCALE_EN,\n336: LOCALE_QQ_ZZ});\n337: assertLocaleLookupList(LOCALE_FR_CA, LOCALE_EN,\n338: new Locale[] {\n339: LOCALE_FR_CA,\n340: LOCALE_FR,\n341: LOCALE_EN});\n342: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.LocaleUtils:<clinit>()V",
                                    "method_body": "private static final List cAvailableLocaleList;\n/** Unmodifiable set of available locales. */\nprivate static Set cAvailableLocaleSet;\n/** Unmodifiable map of language locales by country. */\nprivate static final Map cLanguagesByCountry = Collections.synchronizedMap(new HashMap());\n/** Unmodifiable map of country locales by language. */\nprivate static final Map cCountriesByLanguage = Collections.synchronizedMap(new HashMap());\nstatic {\nList list = Arrays.asList(Locale.getAvailableLocales());\ncAvailableLocaleList = Collections.unmodifiableList(list);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.LocaleUtils:isAvailableLocale(Ljava/util/Locale;)Z",
                                    "method_body": "public static boolean isAvailableLocale(Locale locale) {\nreturn cAvailableLocaleSet.contains(locale);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang.LocaleUtilsTest.testConstructor",
                            "test_body": "89: public void testConstructor() {\n90: assertNotNull(new LocaleUtils());\n91: Constructor[] cons = LocaleUtils.class.getDeclaredConstructors();\n92: assertEquals(1, cons.length);\n93: assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n94: assertEquals(true, Modifier.isPublic(LocaleUtils.class.getModifiers()));\n95: assertEquals(false, Modifier.isFinal(LocaleUtils.class.getModifiers()));\n96: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.LocaleUtils:<clinit>()V",
                                    "method_body": "private static final List cAvailableLocaleList;\n/** Unmodifiable set of available locales. */\nprivate static Set cAvailableLocaleSet;\n/** Unmodifiable map of language locales by country. */\nprivate static final Map cLanguagesByCountry = Collections.synchronizedMap(new HashMap());\n/** Unmodifiable map of country locales by language. */\nprivate static final Map cCountriesByLanguage = Collections.synchronizedMap(new HashMap());\nstatic {\nList list = Arrays.asList(Locale.getAvailableLocales());\ncAvailableLocaleList = Collections.unmodifiableList(list);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.LocaleUtils:isAvailableLocale(Ljava/util/Locale;)Z",
                                    "method_body": "public static boolean isAvailableLocale(Locale locale) {\nreturn cAvailableLocaleSet.contains(locale);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang.LocaleUtilsTest.testAvailableLocaleSet",
                            "test_body": "364: public void testAvailableLocaleSet() {\n365: Set set = LocaleUtils.availableLocaleSet();\n366: Set set2 = LocaleUtils.availableLocaleSet();\n367: assertNotNull(set);\n368: assertSame(set, set2);\n369: assertUnmodifiableCollection(set);\n370: 371: Locale[] jdkLocaleArray = Locale.getAvailableLocales();\n372: List jdkLocaleList = Arrays.asList(jdkLocaleArray);\n373: Set jdkLocaleSet = new HashSet(jdkLocaleList);\n374: assertEquals(jdkLocaleSet, set);\n375: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.LocaleUtils:<clinit>()V",
                                    "method_body": "private static final List cAvailableLocaleList;\n/** Unmodifiable set of available locales. */\nprivate static Set cAvailableLocaleSet;\n/** Unmodifiable map of language locales by country. */\nprivate static final Map cLanguagesByCountry = Collections.synchronizedMap(new HashMap());\n/** Unmodifiable map of country locales by language. */\nprivate static final Map cCountriesByLanguage = Collections.synchronizedMap(new HashMap());\nstatic {\nList list = Arrays.asList(Locale.getAvailableLocales());\ncAvailableLocaleList = Collections.unmodifiableList(list);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.LocaleUtils:isAvailableLocale(Ljava/util/Locale;)Z",
                                    "method_body": "public static boolean isAvailableLocale(Locale locale) {\nreturn cAvailableLocaleSet.contains(locale);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang.LocaleUtilsTest.testCountriesByLanguage",
                            "test_body": "479: public void testCountriesByLanguage() {}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.LocaleUtils:<clinit>()V",
                                    "method_body": "private static final List cAvailableLocaleList;\n/** Unmodifiable set of available locales. */\nprivate static Set cAvailableLocaleSet;\n/** Unmodifiable map of language locales by country. */\nprivate static final Map cLanguagesByCountry = Collections.synchronizedMap(new HashMap());\n/** Unmodifiable map of country locales by language. */\nprivate static final Map cCountriesByLanguage = Collections.synchronizedMap(new HashMap());\nstatic {\nList list = Arrays.asList(Locale.getAvailableLocales());\ncAvailableLocaleList = Collections.unmodifiableList(list);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.LocaleUtils:isAvailableLocale(Ljava/util/Locale;)Z",
                                    "method_body": "public static boolean isAvailableLocale(Locale locale) {\nreturn cAvailableLocaleSet.contains(locale);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang.LocaleUtilsTest.testLocaleLookupList_Locale",
                            "test_body": "275: public void testLocaleLookupList_Locale() {\n276: assertLocaleLookupList(null, null, new Locale[0]);\n277: assertLocaleLookupList(LOCALE_QQ, null, new Locale[]{LOCALE_QQ});\n278: assertLocaleLookupList(LOCALE_EN, null, new Locale[]{LOCALE_EN});\n279: assertLocaleLookupList(LOCALE_EN, null, new Locale[]{LOCALE_EN});\n280: assertLocaleLookupList(LOCALE_EN_US, null,\n281: new Locale[] {\n282: LOCALE_EN_US,\n283: LOCALE_EN});\n284: assertLocaleLookupList(LOCALE_EN_US_ZZZZ, null,\n285: new Locale[] {\n286: LOCALE_EN_US_ZZZZ,\n287: LOCALE_EN_US,\n288: LOCALE_EN});\n289: }        \n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.LocaleUtils:<clinit>()V",
                                    "method_body": "private static final List cAvailableLocaleList;\n/** Unmodifiable set of available locales. */\nprivate static Set cAvailableLocaleSet;\n/** Unmodifiable map of language locales by country. */\nprivate static final Map cLanguagesByCountry = Collections.synchronizedMap(new HashMap());\n/** Unmodifiable map of country locales by language. */\nprivate static final Map cCountriesByLanguage = Collections.synchronizedMap(new HashMap());\nstatic {\nList list = Arrays.asList(Locale.getAvailableLocales());\ncAvailableLocaleList = Collections.unmodifiableList(list);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.LocaleUtils:isAvailableLocale(Ljava/util/Locale;)Z",
                                    "method_body": "public static boolean isAvailableLocale(Locale locale) {\nreturn cAvailableLocaleSet.contains(locale);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang.LocaleUtilsTest.testToLocale_1Part",
                            "test_body": "151: public void testToLocale_1Part() {\n152: assertEquals(null, LocaleUtils.toLocale((String) null));\n153: 154: assertValidToLocale(\"us\");\n155: assertValidToLocale(\"fr\");\n156: assertValidToLocale(\"de\");\n157: assertValidToLocale(\"zh\");\n158: // Valid format but lang doesnt exist, should make instance anyway\n159: assertValidToLocale(\"qq\");\n160: 161: try {\n162: LocaleUtils.toLocale(\"Us\");\n163: fail(\"Should fail if not lowercase\");\n164: } catch (IllegalArgumentException iae) {}\n165: try {\n166: LocaleUtils.toLocale(\"US\");\n167: fail(\"Should fail if not lowercase\");\n168: } catch (IllegalArgumentException iae) {}\n169: try {\n170: LocaleUtils.toLocale(\"uS\");\n171: fail(\"Should fail if not lowercase\");\n172: } catch (IllegalArgumentException iae) {}\n173: try {\n174: LocaleUtils.toLocale(\"u#\");\n175: fail(\"Should fail if not lowercase\");\n176: } catch (IllegalArgumentException iae) {}\n177: 178: try {\n179: LocaleUtils.toLocale(\"u\");\n180: fail(\"Must be 2 chars if less than 5\");\n181: } catch (IllegalArgumentException iae) {}\n182: 183: try {\n184: LocaleUtils.toLocale(\"uuu\");\n185: fail(\"Must be 2 chars if less than 5\");\n186: } catch (IllegalArgumentException iae) {}\n187: 188: try {\n189: LocaleUtils.toLocale(\"uu_U\");\n190: fail(\"Must be 2 chars if less than 5\");\n191: } catch (IllegalArgumentException iae) {}\n192: }        \n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.LocaleUtils:<clinit>()V",
                                    "method_body": "private static final List cAvailableLocaleList;\n/** Unmodifiable set of available locales. */\nprivate static Set cAvailableLocaleSet;\n/** Unmodifiable map of language locales by country. */\nprivate static final Map cLanguagesByCountry = Collections.synchronizedMap(new HashMap());\n/** Unmodifiable map of country locales by language. */\nprivate static final Map cCountriesByLanguage = Collections.synchronizedMap(new HashMap());\nstatic {\nList list = Arrays.asList(Locale.getAvailableLocales());\ncAvailableLocaleList = Collections.unmodifiableList(list);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.LocaleUtils:isAvailableLocale(Ljava/util/Locale;)Z",
                                    "method_body": "public static boolean isAvailableLocale(Locale locale) {\nreturn cAvailableLocaleSet.contains(locale);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 58,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang.math.NumberUtilsTest.testLang300",
                            "test_body": "1368: public void testLang300() {\n1369: NumberUtils.createNumber(\"-1l\");\n1370: NumberUtils.createNumber(\"01l\");\n1371: NumberUtils.createNumber(\"1l\");\n1372: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.StringUtils:isEmpty(Ljava/lang/String;)Z",
                                    "method_body": "public static boolean isEmpty(String str) {\nreturn str == null || str.length() == 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.StringUtils:isBlank(Ljava/lang/String;)Z",
                                    "method_body": "public static boolean isBlank(String str) {\nint strLen;\nif (str == null || (strLen = str.length()) == 0) {\nreturn true;\n}\nfor (int i = 0; i < strLen; i++) {\nif ((Character.isWhitespace(str.charAt(i)) == false)) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.math.NumberUtils:<clinit>()V",
                                    "method_body": "public static final Long LONG_ZERO = new Long(0L);\n/** Reusable Long constant for one. */\npublic static final Long LONG_ONE = new Long(1L);\n/** Reusable Long constant for minus one. */\npublic static final Long LONG_MINUS_ONE = new Long(-1L);\n/** Reusable Integer constant for zero. */\npublic static final Integer INTEGER_ZERO = new Integer(0);\n/** Reusable Integer constant for one. */\npublic static final Integer INTEGER_ONE = new Integer(1);\n/** Reusable Integer constant for minus one. */\npublic static final Integer INTEGER_MINUS_ONE = new Integer(-1);\n/** Reusable Short constant for zero. */\npublic static final Short SHORT_ZERO = new Short((short) 0);\n/** Reusable Short constant for one. */\npublic static final Short SHORT_ONE = new Short((short) 1);\n/** Reusable Short constant for minus one. */\npublic static final Short SHORT_MINUS_ONE = new Short((short) -1);\n/** Reusable Byte constant for zero. */\npublic static final Byte BYTE_ZERO = new Byte((byte) 0);\n/** Reusable Byte constant for one. */\npublic static final Byte BYTE_ONE = new Byte((byte) 1);\n/** Reusable Byte constant for minus one. */\npublic static final Byte BYTE_MINUS_ONE = new Byte((byte) -1);\n/** Reusable Double constant for zero. */\npublic static final Double DOUBLE_ZERO = new Double(0.0d);\n/** Reusable Double constant for one. */\npublic static final Double DOUBLE_ONE = new Double(1.0d);\n/** Reusable Double constant for minus one. */\npublic static final Double DOUBLE_MINUS_ONE = new Double(-1.0d);\n/** Reusable Float constant for zero. */\npublic static final Float FLOAT_ZERO = new Float(0.0f);\n/** Reusable Float constant for one. */\npublic static final Float FLOAT_ONE = new Float(1.0f);\n/** Reusable Float constant for minus one. */\npublic static final Float FLOAT_MINUS_ONE = new Float(-1.0f);\n\n/**\n* <p><code>NumberUtils</code> instances should NOT be constructed in standard programming.\n* Instead, the class should be used as <code>NumberUtils.stringToInt(\"6\");</code>.</p>\n*\n* <p>This constructor is public to permit tools that require a JavaBean instance\n* to operate.</p>\n*/\npublic NumberUtils() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.math.NumberUtils:createNumber(Ljava/lang/String;)Ljava/lang/Number;",
                                    "method_body": "public static Number createNumber(String str) throws NumberFormatException {\nif (str == null) {\nreturn null;\n}\nif (StringUtils.isBlank(str)) {\nthrow new NumberFormatException(\"A blank string is not a valid number\");\n}\nif (str.startsWith(\"--\")) {\n// this is protection for poorness in java.lang.BigDecimal.\n// it accepts this as a legal value, but it does not appear\n// to be in specification of class. OS X Java parses it to\n// a wrong value.\nreturn null;\n}\nif (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\nreturn createInteger(str);\n}\nchar lastChar = str.charAt(str.length() - 1);\nString mant;\nString dec;\nString exp;\nint decPos = str.indexOf('.');\nint expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\nif (decPos > -1) {\n\nif (expPos > -1) {\nif (expPos < decPos) {\nthrow new NumberFormatException(str + \" is not a valid number.\");\n}\ndec = str.substring(decPos + 1, expPos);\n} else {\ndec = str.substring(decPos + 1);\n}\nmant = str.substring(0, decPos);\n} else {\nif (expPos > -1) {\nmant = str.substring(0, expPos);\n} else {\nmant = str;\n}\ndec = null;\n}\nif (!Character.isDigit(lastChar)) {\nif (expPos > -1 && expPos < str.length() - 1) {\nexp = str.substring(expPos + 1, str.length() - 1);\n} else {\nexp = null;\n}\n//Requesting a specific type..\nString numeric = str.substring(0, str.length() - 1);\nboolean allZeros = isAllZeros(mant) && isAllZeros(exp);\nswitch (lastChar) {\ncase 'l' :\ncase 'L' :\nif (dec == null\n&& exp == null\n&& isDigits(numeric.substring(1))\n&& (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\ntry {\nreturn createLong(numeric);\n} catch (NumberFormatException nfe) {\n//Too big for a long\n}\nreturn createBigInteger(numeric);\n\n}\nthrow new NumberFormatException(str + \" is not a valid number.\");\ncase 'f' :\ncase 'F' :\ntry {\nFloat f = NumberUtils.createFloat(numeric);\nif (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n//If it's too big for a float or the float value = 0 and the string\n//has non-zeros in it, then float does not have the precision we want\nreturn f;\n}\n\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\n//Fall through\ncase 'd' :\ncase 'D' :\ntry {\nDouble d = NumberUtils.createDouble(numeric);\nif (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\nreturn d;\n}\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\ntry {\nreturn createBigDecimal(numeric);\n} catch (NumberFormatException e) {\n// ignore the bad number\n}\n//Fall through\ndefault :\nthrow new NumberFormatException(str + \" is not a valid number.\");\n\n}\n} else {\n//User doesn't have a preference on the return type, so let's start\n//small and go from there...\nif (expPos > -1 && expPos < str.length() - 1) {\nexp = str.substring(expPos + 1, str.length());\n} else {\nexp = null;\n}\nif (dec == null && exp == null) {\n//Must be an int,long,bigint\ntry {\nreturn createInteger(str);\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\ntry {\nreturn createLong(str);\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\nreturn createBigInteger(str);\n\n} else {\n//Must be a float,double,BigDec\nboolean allZeros = isAllZeros(mant) && isAllZeros(exp);\ntry {\nFloat f = createFloat(str);\nif (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\nreturn f;\n}\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\ntry {\nDouble d = createDouble(str);\nif (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\nreturn d;\n}\n} catch (NumberFormatException nfe) {\n// ignore the bad number\n}\n\nreturn createBigDecimal(str);\n\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.math.NumberUtils:isAllZeros(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean isAllZeros(String str) {\nif (str == null) {\nreturn true;\n}\nfor (int i = str.length() - 1; i >= 0; i--) {\nif (str.charAt(i) != '0') {\nreturn false;\n}\n}\nreturn str.length() > 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.math.NumberUtils:createLong(Ljava/lang/String;)Ljava/lang/Long;",
                                    "method_body": "public static Long createLong(String str) {\nif (str == null) {\nreturn null;\n}\nreturn Long.valueOf(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.math.NumberUtils:isDigits(Ljava/lang/String;)Z",
                                    "method_body": "public static boolean isDigits(String str) {\nif (StringUtils.isEmpty(str)) {\nreturn false;\n}\nfor (int i = 0; i < str.length(); i++) {\nif (!Character.isDigit(str.charAt(i))) {\nreturn false;\n}\n}\nreturn true;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 59,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang.text.StrBuilderAppendInsertTest.testLang299",
                            "test_body": "600: public void testLang299() {\n601: StrBuilder sb = new StrBuilder(1);\n602: sb.appendFixedWidthPadRight(\"foo\", 1, '-');\n603: assertEquals(\"f\", sb.toString());\n604: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:<init>(I)V",
                                    "method_body": "public StrBuilder(int initialCapacity) {\nsuper();\nif (initialCapacity <= 0) {\ninitialCapacity = CAPACITY;\n}\nbuffer = new char[initialCapacity];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:ensureCapacity(I)Lorg/apache/commons/lang/text/StrBuilder;",
                                    "method_body": "public StrBuilder ensureCapacity(int capacity) {\nif (capacity > buffer.length) {\nchar[] old = buffer;\nbuffer = new char[capacity];\nSystem.arraycopy(old, 0, buffer, 0, size);\n}\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:appendFixedWidthPadRight(Ljava/lang/Object;IC)Lorg/apache/commons/lang/text/StrBuilder;",
                                    "method_body": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\nif (width > 0) {\nensureCapacity(size + width);\nString str = (obj == null ? getNullText() : obj.toString());\nint strLen = str.length();\nif (strLen >= width) {\nstr.getChars(0, strLen, buffer, size);\n} else {\nint padLen = width - strLen;\nstr.getChars(0, strLen, buffer, size);\nfor (int i = 0; i < padLen; i++) {\nbuffer[size + strLen + i] = padChar;\n}\n}\nsize += width;\n}\nreturn this;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 60,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang.text.StrBuilderTest.testLang295",
                            "test_body": "1745: public void testLang295() {\n1746: StrBuilder sb = new StrBuilder(\"onetwothree\");\n1747: sb.deleteFirst(\"three\");\n1748: assertFalse( \"The contains(char) method is looking beyond the end of the string\", sb.contains('h'));\n1749: assertEquals( \"The indexOf(char) method is looking beyond the end of the string\", -1, sb.indexOf('h'));\n1750: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher:<init>()V",
                                    "method_body": "protected StrMatcher() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher:<clinit>()V",
                                    "method_body": "private static final StrMatcher COMMA_MATCHER = new CharMatcher(',');\n/**\n* Matches the tab character.\n*/\nprivate static final StrMatcher TAB_MATCHER = new CharMatcher('\\t');\n/**\n* Matches the space character.\n*/\nprivate static final StrMatcher SPACE_MATCHER = new CharMatcher(' ');\n/**\n* Matches the same characters as StringTokenizer,\n* namely space, tab, newline, formfeed.\n*/\nprivate static final StrMatcher SPLIT_MATCHER = new CharSetMatcher(\" \\t\\n\\r\\f\".toCharArray());\n/**\n* Matches the String trim() whitespace characters.\n*/\nprivate static final StrMatcher TRIM_MATCHER = new TrimMatcher();\n/**\n* Matches the double quote character.\n*/\nprivate static final StrMatcher SINGLE_QUOTE_MATCHER = new CharMatcher('\\'');\n/**\n* Matches the double quote character.\n*/\nprivate static final StrMatcher DOUBLE_QUOTE_MATCHER = new CharMatcher('\"');\n/**\n* Matches the single or double quote character.\n*/\nprivate static final StrMatcher QUOTE_MATCHER = new CharSetMatcher(\"'\\\"\".toCharArray());\n/**\n* Matches no characters.\n*/\nprivate static final StrMatcher NONE_MATCHER = new NoMatcher();\n\n// -----------------------------------------------------------------------\n\n/**\n* Returns a matcher which matches the comma character.\n*\n* @return a matcher for a comma\n*/\npublic static StrMatcher commaMatcher() {\nreturn COMMA_MATCHER;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher$CharMatcher:<init>(C)V",
                                    "method_body": "CharMatcher(char ch) {\nsuper();\nthis.ch = ch;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher$CharSetMatcher:<init>([C)V",
                                    "method_body": "public abstract int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd);\n\n//-----------------------------------------------------------------------\n/**\n* Class used to define a set of characters for matching purposes.\n*/\nstatic final class CharSetMatcher extends StrMatcher {\n/** The set of characters to match. */\nprivate char[] chars;\n\n/**\n* Constructor that creates a matcher from a character array.\n*\n* @param chars  the characters to match, must not be null\n*/\nCharSetMatcher(char chars[]) {\nsuper();\nthis.chars = (char[]) chars.clone();\nArrays.sort(this.chars);\n}\n\n/**\n* Returns whether or not the given charatcer matches.\n*\n* @param buffer  the text content to match against, do not change\n* @param pos  the starting position for the match, valid for buffer\n* @param bufferStart  the first active index in the buffer, valid for buffer\n* @param bufferEnd  the end index of the active buffer, valid for buffer\n* @return the number of matching characters, zero for no match\n*/\npublic int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) {\nreturn Arrays.binarySearch(chars, buffer[pos]) >= 0 ? 1 : 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher$TrimMatcher:<init>()V",
                                    "method_body": "TrimMatcher() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher$NoMatcher:<init>()V",
                                    "method_body": "NoMatcher() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:<init>(Ljava/lang/String;)V",
                                    "method_body": "public StrBuilder(String str) {\nsuper();\nif (str == null) {\nbuffer = new char[CAPACITY];\n} else {\nbuffer = new char[str.length() + CAPACITY];\nappend(str);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:length()I",
                                    "method_body": "public int length() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:ensureCapacity(I)Lorg/apache/commons/lang/text/StrBuilder;",
                                    "method_body": "public StrBuilder ensureCapacity(int capacity) {\nif (capacity > buffer.length) {\nchar[] old = buffer;\nbuffer = new char[capacity];\nSystem.arraycopy(old, 0, buffer, 0, size);\n}\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:append(Ljava/lang/String;)Lorg/apache/commons/lang/text/StrBuilder;",
                                    "method_body": "public StrBuilder append(String str) {\nif (str == null) {\nreturn appendNull();\n}\nint strLen = str.length();\nif (strLen > 0) {\nint len = length();\nensureCapacity(len + strLen);\nstr.getChars(0, strLen, buffer, len);\nsize += strLen;\n}\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:deleteImpl(III)V",
                                    "method_body": "private void deleteImpl(int startIndex, int endIndex, int len) {\nSystem.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);\nsize -= len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:deleteFirst(Ljava/lang/String;)Lorg/apache/commons/lang/text/StrBuilder;",
                                    "method_body": "public StrBuilder deleteFirst(String str) {\nint len = (str == null ? 0 : str.length());\nif (len > 0) {\nint index = indexOf(str, 0);\nif (index >= 0) {\ndeleteImpl(index, index + len, len);\n}\n}\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:contains(C)Z",
                                    "method_body": "public boolean contains(char ch) {\nchar[] thisBuf = buffer;\nfor (int i = 0; i < thisBuf.length; i++) {\nif (thisBuf[i] == ch) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:indexOf(Ljava/lang/String;I)I",
                                    "method_body": "public int indexOf(String str, int startIndex) {\nstartIndex = (startIndex < 0 ? 0 : startIndex);\nif (str == null || startIndex >= size) {\nreturn -1;\n}\nint strLen = str.length();\nif (strLen == 1) {\nreturn indexOf(str.charAt(0), startIndex);\n}\nif (strLen == 0) {\nreturn startIndex;\n}\nif (strLen > size) {\nreturn -1;\n}\nchar[] thisBuf = buffer;\nint len = size - strLen + 1;\nouter:\nfor (int i = startIndex; i < len; i++) {\nfor (int j = 0; j < strLen; j++) {\nif (str.charAt(j) != thisBuf[i + j]) {\ncontinue outer;\n}\n}\nreturn i;\n}\nreturn -1;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 61,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang.text.StrBuilderTest.testLang294",
                            "test_body": "1732: public void testLang294() {\n1733: StrBuilder sb = new StrBuilder(\"\\n%BLAH%\\nDo more stuff\\neven more stuff\\n%BLAH%\\n\");\n1734: sb.deleteAll(\"\\n%BLAH%\");\n1735: assertEquals(\"\\nDo more stuff\\neven more stuff\\n\", sb.toString()); \n1736: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher:<init>()V",
                                    "method_body": "protected StrMatcher() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher:<clinit>()V",
                                    "method_body": "private static final StrMatcher COMMA_MATCHER = new CharMatcher(',');\n/**\n* Matches the tab character.\n*/\nprivate static final StrMatcher TAB_MATCHER = new CharMatcher('\\t');\n/**\n* Matches the space character.\n*/\nprivate static final StrMatcher SPACE_MATCHER = new CharMatcher(' ');\n/**\n* Matches the same characters as StringTokenizer,\n* namely space, tab, newline, formfeed.\n*/\nprivate static final StrMatcher SPLIT_MATCHER = new CharSetMatcher(\" \\t\\n\\r\\f\".toCharArray());\n/**\n* Matches the String trim() whitespace characters.\n*/\nprivate static final StrMatcher TRIM_MATCHER = new TrimMatcher();\n/**\n* Matches the double quote character.\n*/\nprivate static final StrMatcher SINGLE_QUOTE_MATCHER = new CharMatcher('\\'');\n/**\n* Matches the double quote character.\n*/\nprivate static final StrMatcher DOUBLE_QUOTE_MATCHER = new CharMatcher('\"');\n/**\n* Matches the single or double quote character.\n*/\nprivate static final StrMatcher QUOTE_MATCHER = new CharSetMatcher(\"'\\\"\".toCharArray());\n/**\n* Matches no characters.\n*/\nprivate static final StrMatcher NONE_MATCHER = new NoMatcher();\n\n// -----------------------------------------------------------------------\n\n/**\n* Returns a matcher which matches the comma character.\n*\n* @return a matcher for a comma\n*/\npublic static StrMatcher commaMatcher() {\nreturn COMMA_MATCHER;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher$CharMatcher:<init>(C)V",
                                    "method_body": "CharMatcher(char ch) {\nsuper();\nthis.ch = ch;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher$CharSetMatcher:<init>([C)V",
                                    "method_body": "public abstract int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd);\n\n//-----------------------------------------------------------------------\n/**\n* Class used to define a set of characters for matching purposes.\n*/\nstatic final class CharSetMatcher extends StrMatcher {\n/** The set of characters to match. */\nprivate char[] chars;\n\n/**\n* Constructor that creates a matcher from a character array.\n*\n* @param chars  the characters to match, must not be null\n*/\nCharSetMatcher(char chars[]) {\nsuper();\nthis.chars = (char[]) chars.clone();\nArrays.sort(this.chars);\n}\n\n/**\n* Returns whether or not the given charatcer matches.\n*\n* @param buffer  the text content to match against, do not change\n* @param pos  the starting position for the match, valid for buffer\n* @param bufferStart  the first active index in the buffer, valid for buffer\n* @param bufferEnd  the end index of the active buffer, valid for buffer\n* @return the number of matching characters, zero for no match\n*/\npublic int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) {\nreturn Arrays.binarySearch(chars, buffer[pos]) >= 0 ? 1 : 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher$TrimMatcher:<init>()V",
                                    "method_body": "TrimMatcher() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher$NoMatcher:<init>()V",
                                    "method_body": "NoMatcher() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:<init>(Ljava/lang/String;)V",
                                    "method_body": "public StrBuilder(String str) {\nsuper();\nif (str == null) {\nbuffer = new char[CAPACITY];\n} else {\nbuffer = new char[str.length() + CAPACITY];\nappend(str);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:length()I",
                                    "method_body": "public int length() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:ensureCapacity(I)Lorg/apache/commons/lang/text/StrBuilder;",
                                    "method_body": "public StrBuilder ensureCapacity(int capacity) {\nif (capacity > buffer.length) {\nchar[] old = buffer;\nbuffer = new char[capacity];\nSystem.arraycopy(old, 0, buffer, 0, size);\n}\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:append(Ljava/lang/String;)Lorg/apache/commons/lang/text/StrBuilder;",
                                    "method_body": "public StrBuilder append(String str) {\nif (str == null) {\nreturn appendNull();\n}\nint strLen = str.length();\nif (strLen > 0) {\nint len = length();\nensureCapacity(len + strLen);\nstr.getChars(0, strLen, buffer, len);\nsize += strLen;\n}\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:deleteImpl(III)V",
                                    "method_body": "private void deleteImpl(int startIndex, int endIndex, int len) {\nSystem.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);\nsize -= len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:indexOf(Ljava/lang/String;I)I",
                                    "method_body": "public int indexOf(String str, int startIndex) {\nstartIndex = (startIndex < 0 ? 0 : startIndex);\nif (str == null || startIndex >= size) {\nreturn -1;\n}\nint strLen = str.length();\nif (strLen == 1) {\nreturn indexOf(str.charAt(0), startIndex);\n}\nif (strLen == 0) {\nreturn startIndex;\n}\nif (strLen > size) {\nreturn -1;\n}\nchar[] thisBuf = buffer;\nint len = thisBuf.length - strLen;\nouter:\nfor (int i = startIndex; i < len; i++) {\nfor (int j = 0; j < strLen; j++) {\nif (str.charAt(j) != thisBuf[i + j]) {\ncontinue outer;\n}\n}\nreturn i;\n}\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:deleteAll(Ljava/lang/String;)Lorg/apache/commons/lang/text/StrBuilder;",
                                    "method_body": "public StrBuilder deleteAll(String str) {\nint len = (str == null ? 0 : str.length());\nif (len > 0) {\nint index = indexOf(str, 0);\nwhile (index >= 0) {\ndeleteImpl(index, index + len, len);\nindex = indexOf(str, index);\n}\n}\nreturn this;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.lang.text.StrBuilderTest.testIndexOfLang294",
                            "test_body": "1738: public void testIndexOfLang294() {\n1739: StrBuilder sb = new StrBuilder(\"onetwothree\");\n1740: sb.deleteFirst(\"three\");\n1741: assertEquals(-1, sb.indexOf(\"three\"));\n1742: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher:<init>()V",
                                    "method_body": "protected StrMatcher() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher:<clinit>()V",
                                    "method_body": "private static final StrMatcher COMMA_MATCHER = new CharMatcher(',');\n/**\n* Matches the tab character.\n*/\nprivate static final StrMatcher TAB_MATCHER = new CharMatcher('\\t');\n/**\n* Matches the space character.\n*/\nprivate static final StrMatcher SPACE_MATCHER = new CharMatcher(' ');\n/**\n* Matches the same characters as StringTokenizer,\n* namely space, tab, newline, formfeed.\n*/\nprivate static final StrMatcher SPLIT_MATCHER = new CharSetMatcher(\" \\t\\n\\r\\f\".toCharArray());\n/**\n* Matches the String trim() whitespace characters.\n*/\nprivate static final StrMatcher TRIM_MATCHER = new TrimMatcher();\n/**\n* Matches the double quote character.\n*/\nprivate static final StrMatcher SINGLE_QUOTE_MATCHER = new CharMatcher('\\'');\n/**\n* Matches the double quote character.\n*/\nprivate static final StrMatcher DOUBLE_QUOTE_MATCHER = new CharMatcher('\"');\n/**\n* Matches the single or double quote character.\n*/\nprivate static final StrMatcher QUOTE_MATCHER = new CharSetMatcher(\"'\\\"\".toCharArray());\n/**\n* Matches no characters.\n*/\nprivate static final StrMatcher NONE_MATCHER = new NoMatcher();\n\n// -----------------------------------------------------------------------\n\n/**\n* Returns a matcher which matches the comma character.\n*\n* @return a matcher for a comma\n*/\npublic static StrMatcher commaMatcher() {\nreturn COMMA_MATCHER;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher$CharMatcher:<init>(C)V",
                                    "method_body": "CharMatcher(char ch) {\nsuper();\nthis.ch = ch;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher$CharSetMatcher:<init>([C)V",
                                    "method_body": "public abstract int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd);\n\n//-----------------------------------------------------------------------\n/**\n* Class used to define a set of characters for matching purposes.\n*/\nstatic final class CharSetMatcher extends StrMatcher {\n/** The set of characters to match. */\nprivate char[] chars;\n\n/**\n* Constructor that creates a matcher from a character array.\n*\n* @param chars  the characters to match, must not be null\n*/\nCharSetMatcher(char chars[]) {\nsuper();\nthis.chars = (char[]) chars.clone();\nArrays.sort(this.chars);\n}\n\n/**\n* Returns whether or not the given charatcer matches.\n*\n* @param buffer  the text content to match against, do not change\n* @param pos  the starting position for the match, valid for buffer\n* @param bufferStart  the first active index in the buffer, valid for buffer\n* @param bufferEnd  the end index of the active buffer, valid for buffer\n* @return the number of matching characters, zero for no match\n*/\npublic int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) {\nreturn Arrays.binarySearch(chars, buffer[pos]) >= 0 ? 1 : 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher$TrimMatcher:<init>()V",
                                    "method_body": "TrimMatcher() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrMatcher$NoMatcher:<init>()V",
                                    "method_body": "NoMatcher() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:<init>(Ljava/lang/String;)V",
                                    "method_body": "public StrBuilder(String str) {\nsuper();\nif (str == null) {\nbuffer = new char[CAPACITY];\n} else {\nbuffer = new char[str.length() + CAPACITY];\nappend(str);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:length()I",
                                    "method_body": "public int length() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:ensureCapacity(I)Lorg/apache/commons/lang/text/StrBuilder;",
                                    "method_body": "public StrBuilder ensureCapacity(int capacity) {\nif (capacity > buffer.length) {\nchar[] old = buffer;\nbuffer = new char[capacity];\nSystem.arraycopy(old, 0, buffer, 0, size);\n}\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:append(Ljava/lang/String;)Lorg/apache/commons/lang/text/StrBuilder;",
                                    "method_body": "public StrBuilder append(String str) {\nif (str == null) {\nreturn appendNull();\n}\nint strLen = str.length();\nif (strLen > 0) {\nint len = length();\nensureCapacity(len + strLen);\nstr.getChars(0, strLen, buffer, len);\nsize += strLen;\n}\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:deleteImpl(III)V",
                                    "method_body": "private void deleteImpl(int startIndex, int endIndex, int len) {\nSystem.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);\nsize -= len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:deleteFirst(Ljava/lang/String;)Lorg/apache/commons/lang/text/StrBuilder;",
                                    "method_body": "public StrBuilder deleteFirst(String str) {\nint len = (str == null ? 0 : str.length());\nif (len > 0) {\nint index = indexOf(str, 0);\nif (index >= 0) {\ndeleteImpl(index, index + len, len);\n}\n}\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:indexOf(Ljava/lang/String;)I",
                                    "method_body": "public int indexOf(String str) {\nreturn indexOf(str, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.text.StrBuilder:indexOf(Ljava/lang/String;I)I",
                                    "method_body": "public int indexOf(String str, int startIndex) {\nstartIndex = (startIndex < 0 ? 0 : startIndex);\nif (str == null || startIndex >= size) {\nreturn -1;\n}\nint strLen = str.length();\nif (strLen == 1) {\nreturn indexOf(str.charAt(0), startIndex);\n}\nif (strLen == 0) {\nreturn startIndex;\n}\nif (strLen > size) {\nreturn -1;\n}\nchar[] thisBuf = buffer;\nint len = thisBuf.length - strLen;\nouter:\nfor (int i = startIndex; i < len; i++) {\nfor (int j = 0; j < strLen; j++) {\nif (str.charAt(j) != thisBuf[i + j]) {\ncontinue outer;\n}\n}\nreturn i;\n}\nreturn -1;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 62,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang.EntitiesTest.testNumberOverflow",
                            "test_body": "200: public void testNumberOverflow() throws Exception {\n201: doTestUnescapeEntity(\"&#12345678;\", \"&#12345678;\");\n202: doTestUnescapeEntity(\"x&#12345678;y\", \"x&#12345678;y\");\n203: doTestUnescapeEntity(\"&#x12345678;\", \"&#x12345678;\");\n204: doTestUnescapeEntity(\"x&#x12345678;y\", \"x&#x12345678;y\");\n205: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.Entities:<clinit>()V",
                                    "method_body": "private static final String[][] BASIC_ARRAY = {\n{\"quot\", \"34\"}, // \" - double-quote\n{\"amp\", \"38\"}, // & - ampersand\n{\"lt\", \"60\"}, // < - less-than\n{\"gt\", \"62\"}, // > - greater-than\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.Entities:fillWithHtml40Entities(Lorg/apache/commons/lang/Entities;)V",
                                    "method_body": "static void fillWithHtml40Entities(Entities entities) {\nentities.addEntities(BASIC_ARRAY);\nentities.addEntities(ISO8859_1_ARRAY);\nentities.addEntities(HTML40_ARRAY);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.Entities:addEntities([[Ljava/lang/String;)V",
                                    "method_body": "public void addEntities(String[][] entityArray) {\nfor (int i = 0; i < entityArray.length; ++i) {\naddEntity(entityArray[i][0], Integer.parseInt(entityArray[i][1]));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.Entities:addEntity(Ljava/lang/String;I)V",
                                    "method_body": "public void addEntity(String name, int value) {\nmap.add(name, value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.Entities:unescape(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String unescape(String str) {\nint firstAmp = str.indexOf('&');\nif (firstAmp < 0) {\nreturn str;\n}\n\nStringBuffer buf = new StringBuffer(str.length());\nbuf.append(str.substring(0, firstAmp));\nfor (int i = firstAmp; i < str.length(); ++i) {\nchar ch = str.charAt(i);\nif (ch == '&') {\nint semi = str.indexOf(';', i + 1);\nif (semi == -1) {\nbuf.append(ch);\ncontinue;\n}\nint amph = str.indexOf('&', i + 1);\nif( amph != -1 && amph < semi ) {\n// Then the text looks like &...&...;\nbuf.append(ch);\ncontinue;\n}\nString entityName = str.substring(i + 1, semi);\nint entityValue;\nif (entityName.length() == 0) {\nentityValue = -1;\n} else if (entityName.charAt(0) == '#') {\nif (entityName.length() == 1) {\nentityValue = -1;\n} else {\nchar charAt1 = entityName.charAt(1);\ntry {\nif (charAt1 == 'x' || charAt1=='X') {\nentityValue = Integer.valueOf(entityName.substring(2), 16).intValue();\n} else {\nentityValue = Integer.parseInt(entityName.substring(1));\n}\n} catch (NumberFormatException ex) {\nentityValue = -1;\n}\n}\n} else {\nentityValue = this.entityValue(entityName);\n}\nif (entityValue == -1) {\nbuf.append('&');\nbuf.append(entityName);\nbuf.append(';');\n} else {\nbuf.append((char) (entityValue));\n}\ni = semi;\n} else {\nbuf.append(ch);\n}\n}\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.Entities$PrimitiveEntityMap:<init>()V",
                                    "method_body": "void add(String name, int value);\n\n/**\n* <p>Returns the name of the entity identified by the specified value.</p>\n*\n* @param value the value to locate\n* @return entity name associated with the specified value\n*/\nString name(int value);\n\n/**\n* <p>Returns the value of the entity identified by the specified name.</p>\n*\n* @param name the name to locate\n* @return entity value associated with the specified name\n*/\nint value(String name);\n}\n\nstatic class PrimitiveEntityMap implements EntityMap {\nprivate Map mapNameToValue = new HashMap();\nprivate IntHashMap mapValueToName = new IntHashMap();\n\n/**\n* {@inheritDoc}\n*/\npublic void add(String name, int value) {\nmapNameToValue.put(name, new Integer(value));\nmapValueToName.put(value, name);\n}\n\n/**\n* {@inheritDoc}\n*/\npublic String name(int value) {\nreturn (String) mapValueToName.get(value);\n}\n\n/**\n* {@inheritDoc}\n*/\npublic int value(String name) {\nObject value = mapNameToValue.get(name);\nif (value == null) {\nreturn -1;\n}\nreturn ((Integer) value).intValue();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.Entities$PrimitiveEntityMap:add(Ljava/lang/String;I)V",
                                    "method_body": "void add(String name, int value);\n\n/**\n* <p>Returns the name of the entity identified by the specified value.</p>\n*\n* @param value the value to locate\n* @return entity name associated with the specified value\n*/\nString name(int value);\n\n/**\n* <p>Returns the value of the entity identified by the specified name.</p>\n*\n* @param name the name to locate\n* @return entity value associated with the specified name\n*/\nint value(String name);\n}\n\nstatic class PrimitiveEntityMap implements EntityMap {\nprivate Map mapNameToValue = new HashMap();\nprivate IntHashMap mapValueToName = new IntHashMap();\n\n/**\n* {@inheritDoc}\n*/\npublic void add(String name, int value) {\nmapNameToValue.put(name, new Integer(value));\nmapValueToName.put(value, name);\n}\n\n/**\n* {@inheritDoc}\n*/\npublic String name(int value) {\nreturn (String) mapValueToName.get(value);\n}\n\n/**\n* {@inheritDoc}\n*/\npublic int value(String name) {\nObject value = mapNameToValue.get(name);\nif (value == null) {\nreturn -1;\n}\nreturn ((Integer) value).intValue();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.IntHashMap:<init>()V",
                                    "method_body": "public IntHashMap() {\nthis(20, 0.75f);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.IntHashMap:<init>(IF)V",
                                    "method_body": "public IntHashMap(int initialCapacity, float loadFactor) {\nsuper();\nif (initialCapacity < 0) {\nthrow new IllegalArgumentException(\"Illegal Capacity: \" + initialCapacity);\n}\nif (loadFactor <= 0) {\nthrow new IllegalArgumentException(\"Illegal Load: \" + loadFactor);\n}\nif (initialCapacity == 0) {\ninitialCapacity = 1;\n}\n\nthis.loadFactor = loadFactor;\ntable = new Entry[initialCapacity];\nthreshold = (int) (initialCapacity * loadFactor);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.IntHashMap:rehash()V",
                                    "method_body": "protected void rehash() {\nint oldCapacity = table.length;\nEntry oldMap[] = table;\n\nint newCapacity = oldCapacity * 2 + 1;\nEntry newMap[] = new Entry[newCapacity];\n\nthreshold = (int) (newCapacity * loadFactor);\ntable = newMap;\n\nfor (int i = oldCapacity; i-- > 0;) {\nfor (Entry old = oldMap[i]; old != null;) {\nEntry e = old;\nold = old.next;\n\nint index = (e.hash & 0x7FFFFFFF) % newCapacity;\ne.next = newMap[index];\nnewMap[index] = e;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.IntHashMap:put(ILjava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public Object put(int key, Object value) {\n// Makes sure the key is not already in the hashtable.\nEntry tab[] = table;\nint hash = key;\nint index = (hash & 0x7FFFFFFF) % tab.length;\nfor (Entry e = tab[index]; e != null; e = e.next) {\nif (e.hash == hash) {\nObject old = e.value;\ne.value = value;\nreturn old;\n}\n}\n\nif (count >= threshold) {\n// Rehash the table if the threshold is exceeded\nrehash();\n\ntab = table;\nindex = (hash & 0x7FFFFFFF) % tab.length;\n}\n\n// Creates the new entry.\nEntry e = new Entry(hash, key, value, tab[index]);\ntab[index] = e;\ncount++;\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.IntHashMap$Entry:<init>(IILjava/lang/Object;Lorg/apache/commons/lang/IntHashMap$Entry;)V",
                                    "method_body": "protected Entry(int hash, int key, Object value, Entry next) {\nthis.hash = hash;\nthis.key = key;\nthis.value = value;\nthis.next = next;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 63,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang.time.DurationFormatUtilsTest.testJiraLang281",
                            "test_body": "417: public void testJiraLang281() {\n418: Calendar cal = Calendar.getInstance();\n419: cal.set(Calendar.MONTH, Calendar.DECEMBER);\n420: cal.set(Calendar.DAY_OF_MONTH, 31);\n421: cal.set(Calendar.YEAR, 2005);\n422: cal.set(Calendar.HOUR_OF_DAY, 0);\n423: cal.set(Calendar.MINUTE, 0);\n424: cal.set(Calendar.SECOND, 0);\n425: cal.set(Calendar.MILLISECOND, 0);\n426: 427: Calendar cal2 = Calendar.getInstance();\n428: cal2.set(Calendar.MONTH, Calendar.OCTOBER);\n429: cal2.set(Calendar.DAY_OF_MONTH, 6);\n430: cal2.set(Calendar.YEAR, 2006);\n431: cal2.set(Calendar.HOUR_OF_DAY, 0);\n432: cal2.set(Calendar.MINUTE, 0);\n433: cal2.set(Calendar.SECOND, 0);\n434: cal2.set(Calendar.MILLISECOND, 0);\n435: String result = DurationFormatUtils.formatPeriod(cal.getTime().getTime(), cal2.getTime().getTime(), \"MM\");\n436: assertEquals(\"09\", result);\n437: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.StringUtils:leftPad(Ljava/lang/String;IC)Ljava/lang/String;",
                                    "method_body": "public static String leftPad(String str, int size, char padChar) {\nif (str == null) {\nreturn null;\n}\nint pads = size - str.length();\nif (pads <= 0) {\nreturn str; // returns original String when possible\n}\nif (pads > PAD_LIMIT) {\nreturn leftPad(str, size, String.valueOf(padChar));\n}\nreturn padding(pads, padChar).concat(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.DurationFormatUtils:<clinit>()V",
                                    "method_body": "static final Object y = \"y\";\nstatic final Object M = \"M\";\nstatic final Object d = \"d\";\nstatic final Object H = \"H\";\nstatic final Object m = \"m\";\nstatic final Object s = \"s\";\nstatic final Object S = \"S\";\n\n/**\n* Parses a classic date format string into Tokens\n*\n* @param format to parse\n* @return Token[] of tokens\n*/\nstatic Token[] lexx(String format) {\nchar[] array = format.toCharArray();\njava.util.ArrayList list = new java.util.ArrayList(array.length);\n\nboolean inLiteral = false;\nStringBuffer buffer = null;\nToken previous = null;\nint sz = array.length;\nfor(int i=0; i<sz; i++) {\nchar ch = array[i];\nif(inLiteral && ch != '\\'') {\nbuffer.append(ch);\ncontinue;\n}\nObject value = null;\nswitch(ch) {\n// TODO: Need to handle escaping of '\ncase '\\'' :\nif(inLiteral) {\nbuffer = null;\ninLiteral = false;\n} else {\nbuffer = new StringBuffer();\nlist.add(new Token(buffer));\ninLiteral = true;\n}\nbreak;\ncase 'y'  : value = y; break;\ncase 'M'  : value = M; break;\ncase 'd'  : value = d; break;\ncase 'H'  : value = H; break;\ncase 'm'  : value = m; break;\ncase 's'  : value = s; break;\ncase 'S'  : value = S; break;\ndefault   :\nif(buffer == null) {\nbuffer = new StringBuffer();\nlist.add(new Token(buffer));\n}\nbuffer.append(ch);\n}\n\nif(value != null) {\nif(previous != null && previous.getValue() == value) {\nprevious.increment();\n} else {\nToken token = new Token(value);\nlist.add(token);\nprevious = token;\n}\nbuffer = null;\n}\n}\nreturn (Token[]) list.toArray( new Token[0] );\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.DurationFormatUtils:formatPeriod(JJLjava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public static String formatPeriod(long startMillis, long endMillis, String format) {\nreturn formatPeriod(startMillis, endMillis, format, true, TimeZone.getDefault());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.DurationFormatUtils:formatPeriod(JJLjava/lang/String;ZLjava/util/TimeZone;)Ljava/lang/String;",
                                    "method_body": "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros,\nTimeZone timezone) {\n\nlong millis = endMillis - startMillis;\nif (millis < 28 * DateUtils.MILLIS_PER_DAY) {\nreturn formatDuration(millis, format, padWithZeros);\n}\n\nToken[] tokens = lexx(format);\n\n// timezones get funky around 0, so normalizing everything to GMT\n// stops the hours being off\nCalendar start = Calendar.getInstance(timezone);\nstart.setTime(new Date(startMillis));\nCalendar end = Calendar.getInstance(timezone);\nend.setTime(new Date(endMillis));\n\n// initial estimates\nint milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\nint seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\nint minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\nint hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\nint days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\nint years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n// each initial estimate is adjusted in case it is under 0\nwhile (milliseconds < 0) {\nmilliseconds += 1000;\nseconds -= 1;\n}\nwhile (seconds < 0) {\nseconds += 60;\nminutes -= 1;\n}\nwhile (minutes < 0) {\nminutes += 60;\nhours -= 1;\n}\nwhile (hours < 0) {\nhours += 24;\ndays -= 1;\n}\nwhile (days < 0) {\ndays += 31;\n//days += 31; // TODO: Need tests to show this is bad and the new code is good.\n// HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n// 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n// Also it's contextual - if asked for no M in the format then I should probably\n// be doing no calculating here.\nmonths -= 1;\n}\nwhile (months < 0) {\nmonths += 12;\nyears -= 1;\n}\nmilliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\nseconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\nminutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\nhours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\ndays -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\nmonths -= reduceAndCorrect(start, end, Calendar.MONTH, months);\nyears -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n\n// This next block of code adds in values that\n// aren't requested. This allows the user to ask for the\n// number of months and get the real count and not just 0->11.\nif (!Token.containsTokenWithValue(tokens, y)) {\nif (Token.containsTokenWithValue(tokens, M)) {\nmonths += 12 * years;\nyears = 0;\n} else {\n// TODO: this is a bit weak, needs work to know about leap years\ndays += 365 * years;\nyears = 0;\n}\n}\nif (!Token.containsTokenWithValue(tokens, M)) {\ndays += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\nmonths = 0;\n}\nif (!Token.containsTokenWithValue(tokens, d)) {\nhours += 24 * days;\ndays = 0;\n}\nif (!Token.containsTokenWithValue(tokens, H)) {\nminutes += 60 * hours;\nhours = 0;\n}\nif (!Token.containsTokenWithValue(tokens, m)) {\nseconds += 60 * minutes;\nminutes = 0;\n}\nif (!Token.containsTokenWithValue(tokens, s)) {\nmilliseconds += 1000 * seconds;\nseconds = 0;\n}\n\nreturn format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.DurationFormatUtils:format([Lorg/apache/commons/lang/time/DurationFormatUtils$Token;IIIIIIIZ)Ljava/lang/String;",
                                    "method_body": "static String format(Token[] tokens, int years, int months, int days, int hours, int minutes, int seconds,\nint milliseconds, boolean padWithZeros) {\nStringBuffer buffer = new StringBuffer();\nboolean lastOutputSeconds = false;\nint sz = tokens.length;\nfor (int i = 0; i < sz; i++) {\nToken token = tokens[i];\nObject value = token.getValue();\nint count = token.getCount();\nif (value instanceof StringBuffer) {\nbuffer.append(value.toString());\n} else {\nif (value == y) {\nbuffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer\n.toString(years));\nlastOutputSeconds = false;\n} else if (value == M) {\nbuffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer\n.toString(months));\nlastOutputSeconds = false;\n} else if (value == d) {\nbuffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer\n.toString(days));\nlastOutputSeconds = false;\n} else if (value == H) {\nbuffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer\n.toString(hours));\nlastOutputSeconds = false;\n} else if (value == m) {\nbuffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer\n.toString(minutes));\nlastOutputSeconds = false;\n} else if (value == s) {\nbuffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer\n.toString(seconds));\nlastOutputSeconds = true;\n} else if (value == S) {\nif (lastOutputSeconds) {\nmilliseconds += 1000;\nString str = padWithZeros\n? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n: Integer.toString(milliseconds);\nbuffer.append(str.substring(1));\n} else {\nbuffer.append(padWithZeros\n? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n: Integer.toString(milliseconds));\n}\nlastOutputSeconds = false;\n}\n}\n}\nreturn buffer.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.DurationFormatUtils:reduceAndCorrect(Ljava/util/Calendar;Ljava/util/Calendar;II)I",
                                    "method_body": "static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\nend.add( field, -1 * difference );\nint endValue = end.get(field);\nint startValue = start.get(field);\nif (endValue < startValue) {\nint newdiff = startValue - endValue;\nend.add( field, newdiff );\nreturn newdiff;\n} else {\nreturn 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.DurationFormatUtils:lexx(Ljava/lang/String;)[Lorg/apache/commons/lang/time/DurationFormatUtils$Token;",
                                    "method_body": "static Token[] lexx(String format) {\nchar[] array = format.toCharArray();\njava.util.ArrayList list = new java.util.ArrayList(array.length);\n\nboolean inLiteral = false;\nStringBuffer buffer = null;\nToken previous = null;\nint sz = array.length;\nfor(int i=0; i<sz; i++) {\nchar ch = array[i];\nif(inLiteral && ch != '\\'') {\nbuffer.append(ch);\ncontinue;\n}\nObject value = null;\nswitch(ch) {\n// TODO: Need to handle escaping of '\ncase '\\'' :\nif(inLiteral) {\nbuffer = null;\ninLiteral = false;\n} else {\nbuffer = new StringBuffer();\nlist.add(new Token(buffer));\ninLiteral = true;\n}\nbreak;\ncase 'y'  : value = y; break;\ncase 'M'  : value = M; break;\ncase 'd'  : value = d; break;\ncase 'H'  : value = H; break;\ncase 'm'  : value = m; break;\ncase 's'  : value = s; break;\ncase 'S'  : value = S; break;\ndefault   :\nif(buffer == null) {\nbuffer = new StringBuffer();\nlist.add(new Token(buffer));\n}\nbuffer.append(ch);\n}\n\nif(value != null) {\nif(previous != null && previous.getValue() == value) {\nprevious.increment();\n} else {\nToken token = new Token(value);\nlist.add(token);\nprevious = token;\n}\nbuffer = null;\n}\n}\nreturn (Token[]) list.toArray( new Token[0] );\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.DurationFormatUtils$Token:<init>(Ljava/lang/Object;)V",
                                    "method_body": "Token(Object value) {\nthis.value = value;\nthis.count = 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.DurationFormatUtils$Token:containsTokenWithValue([Lorg/apache/commons/lang/time/DurationFormatUtils$Token;Ljava/lang/Object;)Z",
                                    "method_body": "static boolean containsTokenWithValue(Token[] tokens, Object value) {\nint sz = tokens.length;\nfor (int i = 0; i < sz; i++) {\nif (tokens[i].getValue() == value) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.DurationFormatUtils$Token:increment()V",
                                    "method_body": "void increment() {\ncount++;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.DurationFormatUtils$Token:getCount()I",
                                    "method_body": "int getCount() {\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.DurationFormatUtils$Token:getValue()Ljava/lang/Object;",
                                    "method_body": "Object getValue() {\nreturn value;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 64,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang.enums.ValuedEnumTest.testCompareTo_otherEnumType",
                            "test_body": "105: public void testCompareTo_otherEnumType() {\n106: try {\n107: ValuedColorEnum.BLUE.compareTo(ValuedLanguageEnum.ENGLISH);\n108: fail();\n109: } catch (ClassCastException ex) {\n110: // expected\n111: }\n112: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.StringUtils:isEmpty(Ljava/lang/String;)Z",
                                    "method_body": "public static boolean isEmpty(String str) {\nreturn str == null || str.length() == 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.enums.Enum:<init>(Ljava/lang/String;)V",
                                    "method_body": "protected Enum(String name) {\nsuper();\ninit(name);\niName = name;\niHashCode = 7 + getEnumClass().hashCode() + 3 * name.hashCode();\n// cannot create toString here as subclasses may want to include other data\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.enums.Enum:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = -487045951170455942L;\n\n// After discussion, the default size for HashMaps is used, as the\n// sizing algorithm changes across the JDK versions\n/**\n* An empty <code>Map</code>, as JDK1.2 didn't have an empty map.\n*/\nprivate static final Map EMPTY_MAP = Collections.unmodifiableMap(new HashMap(0));\n\n/**\n* <code>Map</code>, key of class name, value of <code>Entry</code>.\n*/\nprivate static final Map cEnumClasses = new HashMap();\n\n/**\n* The string representation of the Enum.\n*/\nprivate final String iName;\n\n/**\n* The hashcode representation of the Enum.\n*/\nprivate transient final int iHashCode;\n\n/**\n* The toString representation of the Enum.\n* @since 2.0\n*/\nprotected transient String iToString = null;\n\n/**\n* <p>Enable the iterator to retain the source code order.</p>\n*/\nprivate static class Entry {\n/**\n* Map of Enum name to Enum.\n*/\nfinal Map map = new HashMap();\n/**\n* Map of Enum name to Enum.\n*/\nfinal Map unmodifiableMap = Collections.unmodifiableMap(map);\n/**\n* List of Enums in source code order.\n*/\nfinal List list = new ArrayList(25);\n/**\n* Map of Enum name to Enum.\n*/\nfinal List unmodifiableList = Collections.unmodifiableList(list);\n\n/**\n* <p>Restrictive constructor.</p>\n*/\nprotected Entry() {\nsuper();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.enums.Enum:init(Ljava/lang/String;)V",
                                    "method_body": "private void init(String name) {\nif (StringUtils.isEmpty(name)) {\nthrow new IllegalArgumentException(\"The Enum name must not be empty or null\");\n}\n\nClass enumClass = getEnumClass();\nif (enumClass == null) {\nthrow new IllegalArgumentException(\"getEnumClass() must not be null\");\n}\nClass cls = getClass();\nboolean ok = false;\nwhile (cls != null && cls != Enum.class && cls != ValuedEnum.class) {\nif (cls == enumClass) {\nok = true;\nbreak;\n}\ncls = cls.getSuperclass();\n}\nif (ok == false) {\nthrow new IllegalArgumentException(\"getEnumClass() must return a superclass of this class\");\n}\n\n// create entry\nEntry entry = (Entry) cEnumClasses.get(enumClass);\nif (entry == null) {\nentry = createEntry(enumClass);\ncEnumClasses.put(enumClass, entry);\n}\nif (entry.map.containsKey(name)) {\nthrow new IllegalArgumentException(\"The Enum name must be unique, '\" + name + \"' has already been added\");\n}\nentry.map.put(name, this);\nentry.list.add(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.enums.Enum:createEntry(Ljava/lang/Class;)Lorg/apache/commons/lang/enums/Enum$Entry;",
                                    "method_body": "private static Entry createEntry(Class enumClass) {\nEntry entry = new Entry();\nClass cls = enumClass.getSuperclass();\nwhile (cls != null && cls != Enum.class && cls != ValuedEnum.class) {\nEntry loopEntry = (Entry) cEnumClasses.get(cls);\nif (loopEntry != null) {\nentry.list.addAll(loopEntry.list);\nentry.map.putAll(loopEntry.map);\nbreak;  // stop here, as this will already have had superclasses added\n}\ncls = cls.getSuperclass();\n}\nreturn entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.enums.Enum:getEnumClass()Ljava/lang/Class;",
                                    "method_body": "public Class getEnumClass() {\nreturn getClass();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.enums.ValuedEnum:<init>(Ljava/lang/String;I)V",
                                    "method_body": "protected ValuedEnum(String name, int value) {\nsuper(name);\niValue = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.enums.ValuedEnum:compareTo(Ljava/lang/Object;)I",
                                    "method_body": "public int compareTo(Object other) {\nreturn iValue - ((ValuedEnum) other).iValue;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.enums.Enum$Entry:<init>()V",
                                    "method_body": "protected Entry() {\nsuper();\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 65,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.lang.time.DateUtilsTest.testTruncateLang59",
                            "test_body": "896: public void testTruncateLang59() throws Exception {\n897: 898: // Set TimeZone to Mountain Time\n899: TimeZone MST_MDT = TimeZone.getTimeZone(\"MST7MDT\");\n900: TimeZone.setDefault(MST_MDT);\n901: DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS z\");\n902: format.setTimeZone(MST_MDT);\n903: 904: Date oct31_01MDT = new Date(1099206000000L); \n905: 906: Date oct31MDT             = new Date(oct31_01MDT.getTime()       - 3600000L); // - 1 hour\n907: Date oct31_01_02MDT       = new Date(oct31_01MDT.getTime()       + 120000L);  // + 2 minutes\n908: Date oct31_01_02_03MDT    = new Date(oct31_01_02MDT.getTime()    + 3000L);    // + 3 seconds\n909: Date oct31_01_02_03_04MDT = new Date(oct31_01_02_03MDT.getTime() + 4L);       // + 4 milliseconds\n910: 911: assertEquals(\"Check 00:00:00.000\", \"2004-10-31 00:00:00.000 MDT\", format.format(oct31MDT));\n912: assertEquals(\"Check 01:00:00.000\", \"2004-10-31 01:00:00.000 MDT\", format.format(oct31_01MDT));\n913: assertEquals(\"Check 01:02:00.000\", \"2004-10-31 01:02:00.000 MDT\", format.format(oct31_01_02MDT));\n914: assertEquals(\"Check 01:02:03.000\", \"2004-10-31 01:02:03.000 MDT\", format.format(oct31_01_02_03MDT));\n915: assertEquals(\"Check 01:02:03.004\", \"2004-10-31 01:02:03.004 MDT\", format.format(oct31_01_02_03_04MDT));\n916: 917: // ------- Demonstrate Problem -------\n918: Calendar gval = Calendar.getInstance();\n919: gval.setTime(new Date(oct31_01MDT.getTime()));\n920: gval.set(Calendar.MINUTE, gval.get(Calendar.MINUTE)); // set minutes to the same value\n921: assertEquals(\"Demonstrate Problem\", gval.getTime().getTime(), oct31_01MDT.getTime() + 3600000L);\n922: 923: // ---------- Test Truncate ----------\n924: assertEquals(\"Truncate Calendar.MILLISECOND\",\n925: oct31_01_02_03_04MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.MILLISECOND));\n926: 927: assertEquals(\"Truncate Calendar.SECOND\",\n928: oct31_01_02_03MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.SECOND));\n929: 930: assertEquals(\"Truncate Calendar.MINUTE\",\n931: oct31_01_02MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.MINUTE));\n932: 933: assertEquals(\"Truncate Calendar.HOUR_OF_DAY\",\n934: oct31_01MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.HOUR_OF_DAY));\n935: 936: assertEquals(\"Truncate Calendar.HOUR\",\n937: oct31_01MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.HOUR));\n938: 939: assertEquals(\"Truncate Calendar.DATE\",\n940: oct31MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.DATE));\n941: 942: 943: // ---------- Test Round (down) ----------\n944: assertEquals(\"Round Calendar.MILLISECOND\",\n945: oct31_01_02_03_04MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.MILLISECOND));\n946: 947: assertEquals(\"Round Calendar.SECOND\",\n948: oct31_01_02_03MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.SECOND));\n949: 950: assertEquals(\"Round Calendar.MINUTE\",\n951: oct31_01_02MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.MINUTE));\n952: 953: assertEquals(\"Round Calendar.HOUR_OF_DAY\",\n954: oct31_01MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.HOUR_OF_DAY));\n955: 956: assertEquals(\"Round Calendar.HOUR\",\n957: oct31_01MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.HOUR));\n958: 959: assertEquals(\"Round Calendar.DATE\",\n960: oct31MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.DATE));\n961: 962: // restore default time zone\n963: TimeZone.setDefault(defaultZone);\n964: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.lang.time.DateUtils:<clinit>()V",
                                    "method_body": "public static final TimeZone UTC_TIME_ZONE = TimeZone.getTimeZone(\"GMT\");\n/**\n* Number of milliseconds in a standard second.\n* @since 2.1\n*/\npublic static final long MILLIS_PER_SECOND = 1000;\n/**\n* Number of milliseconds in a standard minute.\n* @since 2.1\n*/\npublic static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n/**\n* Number of milliseconds in a standard hour.\n* @since 2.1\n*/\npublic static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n/**\n* Number of milliseconds in a standard day.\n* @since 2.1\n*/\npublic static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR;\n\n/**\n* This is half a month, so this represents whether a date is in the top\n* or bottom half of the month.\n*/\npublic final static int SEMI_MONTH = 1001;\n\nprivate static final int[][] fields = {\n{Calendar.MILLISECOND},\n{Calendar.SECOND},\n{Calendar.MINUTE},\n{Calendar.HOUR_OF_DAY, Calendar.HOUR},\n{Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM\n/* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */\n},\n{Calendar.MONTH, DateUtils.SEMI_MONTH},\n{Calendar.YEAR},\n{Calendar.ERA}};"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.DateUtils:truncate(Ljava/util/Date;I)Ljava/util/Date;",
                                    "method_body": "public static Date truncate(Date date, int field) {\nif (date == null) {\nthrow new IllegalArgumentException(\"The date must not be null\");\n}\nCalendar gval = Calendar.getInstance();\ngval.setTime(date);\nmodify(gval, field, false);\nreturn gval.getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.lang.time.DateUtils:modify(Ljava/util/Calendar;IZ)V",
                                    "method_body": "private static void modify(Calendar val, int field, boolean round) {\nif (val.get(Calendar.YEAR) > 280000000) {\nthrow new ArithmeticException(\"Calendar value too large for accurate calculations\");\n}\n\n\n// ----------------- Fix for LANG-59 ---------------------- START ---------------\n// see http://issues.apache.org/jira/browse/LANG-59\n//\n// Manually truncate milliseconds, seconds and minutes, rather than using\n// Calendar methods.\n\n\n// truncate milliseconds\n\n// truncate seconds\n\n// truncate minutes\n\n// reset time\n// ----------------- Fix for LANG-59 ----------------------- END ----------------\n\nboolean roundUp = false;\nfor (int i = 0; i < fields.length; i++) {\nfor (int j = 0; j < fields[i].length; j++) {\nif (fields[i][j] == field) {\n//This is our field... we stop looping\nif (round && roundUp) {\nif (field == DateUtils.SEMI_MONTH) {\n//This is a special case that's hard to generalize\n//If the date is 1, we round up to 16, otherwise\n//  we subtract 15 days and add 1 month\nif (val.get(Calendar.DATE) == 1) {\nval.add(Calendar.DATE, 15);\n} else {\nval.add(Calendar.DATE, -15);\nval.add(Calendar.MONTH, 1);\n}\n} else {\n//We need at add one to this field since the\n//  last number causes us to round up\nval.add(fields[i][0], 1);\n}\n}\nreturn;\n}\n}\n//We have various fields that are not easy roundings\nint offset = 0;\nboolean offsetSet = false;\n//These are special types of fields that require different rounding rules\nswitch (field) {\ncase DateUtils.SEMI_MONTH:\nif (fields[i][0] == Calendar.DATE) {\n//If we're going to drop the DATE field's value,\n//  we want to do this our own way.\n//We need to subtrace 1 since the date has a minimum of 1\noffset = val.get(Calendar.DATE) - 1;\n//If we're above 15 days adjustment, that means we're in the\n//  bottom half of the month and should stay accordingly.\nif (offset >= 15) {\noffset -= 15;\n}\n//Record whether we're in the top or bottom half of that range\nroundUp = offset > 7;\noffsetSet = true;\n}\nbreak;\ncase Calendar.AM_PM:\nif (fields[i][0] == Calendar.HOUR_OF_DAY) {\n//If we're going to drop the HOUR field's value,\n//  we want to do this our own way.\noffset = val.get(Calendar.HOUR_OF_DAY);\nif (offset >= 12) {\noffset -= 12;\n}\nroundUp = offset > 6;\noffsetSet = true;\n}\nbreak;\n}\nif (!offsetSet) {\nint min = val.getActualMinimum(fields[i][0]);\nint max = val.getActualMaximum(fields[i][0]);\n//Calculate the offset from the minimum allowed value\noffset = val.get(fields[i][0]) - min;\n//Set roundUp if this is more than half way between the minimum and maximum\nroundUp = offset > ((max - min) / 2);\n}\n//We need to remove this field\nval.set(fields[i][0], val.get(fields[i][0]) - offset);\n}\nthrow new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n}"
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}