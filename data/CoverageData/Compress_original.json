{
    "projects": [
        {
            "name": "Compress",
            "bugs": [
                {
                    "bug_id": 1,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.CpioTestCase.testCpioUnarchive",
                            "test_body": "54: public void testCpioUnarchive() throws Exception {\n55: final File output = new File(dir, \"bla.cpio\");\n56: {\n57: final File file1 = getFile(\"test1.xml\");\n58: final File file2 = getFile(\"test2.xml\");\n59: 60: final OutputStream out = new FileOutputStream(output);\n61: final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\"cpio\", out);\n62: os.putArchiveEntry(new CpioArchiveEntry(\"test1.xml\", file1.length()));\n63: IOUtils.copy(new FileInputStream(file1), os);\n64: os.closeArchiveEntry();\n65: 66: os.putArchiveEntry(new CpioArchiveEntry(\"test2.xml\", file2.length()));\n67: IOUtils.copy(new FileInputStream(file2), os);\n68: os.closeArchiveEntry();\n69: 70: os.close();\n71: out.close();\n72: }\n73: 74: // Unarchive Operation\n75: final File input = output;\n76: final InputStream is = new FileInputStream(input);\n77: final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"cpio\", is);\n78: 79: 80: Map result = new HashMap();\n81: ArchiveEntry entry = null;\n82: while ((entry = in.getNextEntry()) != null) {\n83: File target = new File(dir, entry.getName());\n84: final OutputStream out = new FileOutputStream(target);\n85: IOUtils.copy(in, out);\n86: out.close();\n87: result.put(entry.getName(), target);\n88: }\n89: in.close();\n90: 91: int lineSepLength = System.getProperty(\"line.separator\").length();\n92: 93: File t = (File)result.get(\"test1.xml\");\n94: assertTrue(\"Expected \" + t.getAbsolutePath() + \" to exist\", t.exists());\n95: assertEquals(\"length of \" + t.getAbsolutePath(),\n96: 72 + 4 * lineSepLength, t.length());\n97: 98: t = (File)result.get(\"test2.xml\");\n99: assertTrue(\"Expected \" + t.getAbsolutePath() + \" to exist\", t.exists());\n100: assertEquals(\"length of \" + t.getAbsolutePath(),\n101: 73 + 5 * lineSepLength, t.length());\n102: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveInputStream(Ljava/lang/String;Ljava/io/InputStream;)Lorg/apache/commons/compress/archivers/ArchiveInputStream;",
                                    "method_body": "public ArchiveInputStream createArchiveInputStream(\nif (archiverName == null || in == null) {\nif (\"ar\".equalsIgnoreCase(archiverName)) {\n} else if (\"zip\".equalsIgnoreCase(archiverName)) {\n} else if (\"tar\".equalsIgnoreCase(archiverName)) {\n} else if (\"jar\".equalsIgnoreCase(archiverName)) {\n} else if (\"cpio\".equalsIgnoreCase(archiverName)) {\nreturn new CpioArchiveInputStream(in);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveOutputStream(Ljava/lang/String;Ljava/io/OutputStream;)Lorg/apache/commons/compress/archivers/ArchiveOutputStream;",
                                    "method_body": "public ArchiveOutputStream createArchiveOutputStream(\nif (archiverName == null || out == null) {\nif (\"ar\".equalsIgnoreCase(archiverName)) {\n} else if (\"zip\".equalsIgnoreCase(archiverName)) {\n} else if (\"tar\".equalsIgnoreCase(archiverName)) {\n} else if (\"jar\".equalsIgnoreCase(archiverName)) {\n} else if (\"cpio\".equalsIgnoreCase(archiverName)) {\nreturn new CpioArchiveOutputStream(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:<init>(Ljava/io/OutputStream;S)V",
                                    "method_body": "private CpioArchiveEntry cpioEntry;\nprivate boolean closed = false;\nprivate short entryFormat = FORMAT_NEW;\nprivate final HashMap names = new HashMap();\nprivate long crc = 0;\npublic CpioArchiveOutputStream(final OutputStream out, final short format) {\nthis.out = new FilterOutputStream(out);\nsetFormat(format);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public CpioArchiveOutputStream(final OutputStream out) {\nthis(out, FORMAT_NEW);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:ensureOpen()V",
                                    "method_body": "private void ensureOpen() throws IOException {\nif (this.closed) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:setFormat(S)V",
                                    "method_body": "private void setFormat(final short format) {\nswitch (format) {\nbreak;\nsynchronized (this) {\nthis.entryFormat = format;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:putNextEntry(Lorg/apache/commons/compress/archivers/cpio/CpioArchiveEntry;)V",
                                    "method_body": "public void putNextEntry(final CpioArchiveEntry e) throws IOException {\nensureOpen();\nif (this.cpioEntry != null) {\nif (e.getTime() == -1) {\ne.setTime(System.currentTimeMillis());\nif (e.getFormat() == -1) {\nif (this.names.put(e.getName(), e) != null) {\nwriteHeader(e);\nthis.cpioEntry = e;\nthis.written = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:writeHeader(Lorg/apache/commons/compress/archivers/cpio/CpioArchiveEntry;)V",
                                    "method_body": "private void writeHeader(final CpioArchiveEntry e) throws IOException {\nswitch (e.getFormat()) {\nout.write(MAGIC_NEW.getBytes());\nwriteNewEntry(e);\nbreak;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:writeNewEntry(Lorg/apache/commons/compress/archivers/cpio/CpioArchiveEntry;)V",
                                    "method_body": "private void writeNewEntry(final CpioArchiveEntry entry) throws IOException {\nwriteAsciiLong(entry.getInode(), 8, 16);\nwriteAsciiLong(entry.getMode(), 8, 16);\nwriteAsciiLong(entry.getUID(), 8, 16);\nwriteAsciiLong(entry.getGID(), 8, 16);\nwriteAsciiLong(entry.getNumberOfLinks(), 8, 16);\nwriteAsciiLong(entry.getTime(), 8, 16);\nwriteAsciiLong(entry.getSize(), 8, 16);\nwriteAsciiLong(entry.getDeviceMaj(), 8, 16);\nwriteAsciiLong(entry.getDeviceMin(), 8, 16);\nwriteAsciiLong(entry.getRemoteDeviceMaj(), 8, 16);\nwriteAsciiLong(entry.getRemoteDeviceMin(), 8, 16);\nwriteAsciiLong(entry.getName().length() + 1, 8, 16);\nwriteAsciiLong(entry.getChksum(), 8, 16);\nwriteCString(entry.getName());\npad(entry.getHeaderSize() + entry.getName().length() + 1, 4);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nensureOpen();\nif (this.cpioEntry.getSize() != this.written) {\nif ((this.cpioEntry.getFormat() | FORMAT_NEW_MASK) == FORMAT_NEW_MASK) {\npad(this.cpioEntry.getSize(), 4);\nif ((this.cpioEntry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) {\nthis.cpioEntry = null;\nthis.crc = 0;\nthis.written = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int off, final int len)\nensureOpen();\nif (off < 0 || len < 0 || off > b.length - len) {\n} else if (len == 0) {\nif (this.cpioEntry == null) {\nif (this.written + len > this.cpioEntry.getSize()) {\nout.write(b, off, len);\nthis.written += len;\nif ((this.cpioEntry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!this.closed) {\nsuper.close();\nthis.closed = true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:pad(JI)V",
                                    "method_body": "private void pad(final long count, final int border) throws IOException {\nlong skip = count % border;\nif (skip > 0) {\nbyte tmp[] = new byte[(int) (border - skip)];\nout.write(tmp);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:writeAsciiLong(JII)V",
                                    "method_body": "private void writeAsciiLong(final long number, final int length,\nStringBuffer tmp = new StringBuffer();\nif (radix == 16) {\ntmp.append(Long.toHexString(number));\nif (tmp.length() <= length) {\nlong insertLength = length - tmp.length();\nfor (int pos = 0; pos < insertLength; pos++) {\ntmp.insert(0, \"0\");\ntmpStr = tmp.toString();\n} else {\ntmpStr = tmp.substring(tmp.length() - length);\nout.write(tmpStr.getBytes());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:writeCString(Ljava/lang/String;)V",
                                    "method_body": "private void writeCString(final String str) throws IOException {\nout.write(str.getBytes());\nout.write('\\0');\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry entry) throws IOException {\nthis.putNextEntry((CpioArchiveEntry) entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:<init>(S)V",
                                    "method_body": "public CpioArchiveEntry(final short format) {\nsetFormat(format);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:<init>(Ljava/lang/String;J)V",
                                    "method_body": "public CpioArchiveEntry(final String name, final long size) {\nthis(FORMAT_NEW);\nthis.name = name;\nthis.setSize(size);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:checkNewFormat()V",
                                    "method_body": "private void checkNewFormat() {\nif ((this.fileFormat & FORMAT_NEW_MASK) == 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getChksum()J",
                                    "method_body": "public long getChksum() {\ncheckNewFormat();\nreturn this.chksum;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getDeviceMaj()J",
                                    "method_body": "public long getDeviceMaj() {\ncheckNewFormat();\nreturn this.maj;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getDeviceMin()J",
                                    "method_body": "public long getDeviceMin() {\ncheckNewFormat();\nreturn this.min;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn this.filesize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getFormat()S",
                                    "method_body": "public short getFormat() {\nreturn this.fileFormat;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getGID()J",
                                    "method_body": "public long getGID() {\nreturn this.gid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getHeaderSize()J",
                                    "method_body": "public long getHeaderSize() {\nreturn this.headerSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getInode()J",
                                    "method_body": "public long getInode() {\nreturn this.inode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getMode()J",
                                    "method_body": "public long getMode() {\nreturn this.mode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn this.name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getNumberOfLinks()J",
                                    "method_body": "public long getNumberOfLinks() {\nreturn this.nlink;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getRemoteDeviceMaj()J",
                                    "method_body": "public long getRemoteDeviceMaj() {\ncheckNewFormat();\nreturn this.rmaj;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getRemoteDeviceMin()J",
                                    "method_body": "public long getRemoteDeviceMin() {\ncheckNewFormat();\nreturn this.rmin;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getTime()J",
                                    "method_body": "public long getTime() {\nreturn this.mtime;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getUID()J",
                                    "method_body": "public long getUID() {\nreturn this.uid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setChksum(J)V",
                                    "method_body": "public void setChksum(final long chksum) {\ncheckNewFormat();\nthis.chksum = chksum;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setDeviceMaj(J)V",
                                    "method_body": "public void setDeviceMaj(final long maj) {\ncheckNewFormat();\nthis.maj = maj;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setDeviceMin(J)V",
                                    "method_body": "public void setDeviceMin(final long min) {\ncheckNewFormat();\nthis.min = min;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(final long size) {\nif (size < 0 || size > 0xFFFFFFFFL) {\nthis.filesize = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setFormat(S)V",
                                    "method_body": "final void setFormat(final short format) {\nswitch (format) {\nthis.fileFormat = FORMAT_NEW;\nthis.headerSize = 110;\nbreak;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setGID(J)V",
                                    "method_body": "public void setGID(final long gid) {\nthis.gid = gid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setInode(J)V",
                                    "method_body": "public void setInode(final long inode) {\nthis.inode = inode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setMode(J)V",
                                    "method_body": "public void setMode(final long mode) {\nswitch ((int) (mode & S_IFMT)) {\nnew IllegalArgumentException(\"Unknown mode (full mode: \" + mode\nthis.mode = mode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "public void setName(final String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setNumberOfLinks(J)V",
                                    "method_body": "public void setNumberOfLinks(final long nlink) {\nthis.nlink = nlink;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setRemoteDeviceMaj(J)V",
                                    "method_body": "public void setRemoteDeviceMaj(final long rmaj) {\ncheckNewFormat();\nthis.rmaj = rmaj;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setRemoteDeviceMin(J)V",
                                    "method_body": "public void setRemoteDeviceMin(final long rmin) {\ncheckNewFormat();\nthis.rmin = rmin;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setTime(J)V",
                                    "method_body": "public void setTime(final long time) {\nthis.mtime = time;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setUID(J)V",
                                    "method_body": "public void setUID(final long uid) {\nthis.uid = uid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:copy(Ljava/io/InputStream;Ljava/io/OutputStream;)V",
                                    "method_body": "public static void copy(final InputStream input, final OutputStream output) throws IOException {\ncopy(input, output, 8024);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:copy(Ljava/io/InputStream;Ljava/io/OutputStream;I)V",
                                    "method_body": "public static void copy(final InputStream input, final OutputStream output, int buffersize) throws IOException {\nfinal byte[] buffer = new byte[buffersize];\nint n = 0;\nwhile (-1 != (n = input.read(buffer))) {\noutput.write(buffer, 0, n);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public CpioArchiveInputStream(final InputStream in) {\nthis.in = in;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:closeEntry()V",
                                    "method_body": "public void closeEntry() throws IOException {\nensureOpen();\nwhile (read(this.tmpbuf, 0, this.tmpbuf.length) != -1) {\nthis.entryEOF = true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:ensureOpen()V",
                                    "method_body": "private void ensureOpen() throws IOException {\nif (this.closed) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:getNextCPIOEntry()Lorg/apache/commons/compress/archivers/cpio/CpioArchiveEntry;",
                                    "method_body": "public CpioArchiveEntry getNextCPIOEntry() throws IOException {\nensureOpen();\nif (this.entry != null) {\ncloseEntry();\nbyte magic[] = new byte[2];\nreadFully(magic, 0, magic.length);\nif (CpioUtil.byteArray2long(magic, false) == MAGIC_OLD_BINARY) {\n} else if (CpioUtil.byteArray2long(magic, true) == MAGIC_OLD_BINARY) {\nbyte more_magic[] = new byte[4];\nreadFully(more_magic, 0, more_magic.length);\nbyte tmp[] = new byte[6];\nSystem.arraycopy(magic, 0, tmp, 0, magic.length);\nSystem.arraycopy(more_magic, 0, tmp, magic.length,\nString magicString = new String(tmp);\nif (magicString.equals(MAGIC_NEW)) {\nthis.entry = readNewEntry(false);\nthis.entryBytesRead = 0;\nthis.entryEOF = false;\nthis.crc = 0;\nif (this.entry.getName().equals(\"TRAILER!!!\")) {\nreturn this.entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:pad(JI)J",
                                    "method_body": "private long pad(final long count, final int border) throws IOException {\nlong skip = count % border;\nif (skip > 0) {\nskip = this.in.skip(border - skip);\nreturn skip;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:read([BII)I",
                                    "method_body": "public int read(final byte[] b, final int off, final int len)\nensureOpen();\nif (off < 0 || len < 0 || off > b.length - len) {\n} else if (len == 0) {\nif (this.entry == null || this.entryEOF) {\nreturn -1;\nif (this.entryBytesRead == this.entry.getSize()) {\nif ((this.entry.getFormat() | FORMAT_NEW_MASK) == FORMAT_NEW_MASK) {\npad(this.entry.getSize(), 4);\nthis.entryEOF = true;\nif ((this.entry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) {\nreturn -1;\nint tmplength = (int) Math.min(len, this.entry.getSize()\nif (tmplength < 0) {\nint tmpread = this.in.read(b, off, tmplength);\nif ((this.entry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) {\nthis.entryBytesRead += tmpread;\nreturn tmpread;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:readFully([BII)I",
                                    "method_body": "private final int readFully(final byte[] b, final int off, final int len)\nif (len < 0) {\nint n = 0;\nwhile (n < len) {\nint count = this.in.read(b, off + n, len - n);\nif (count < 0) {\nthrow new EOFException();\nn += count;\n}\nreturn n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:readAsciiLong(II)J",
                                    "method_body": "private long readAsciiLong(final int length, final int radix)\nbyte tmpBuffer[] = new byte[length];\nreadFully(tmpBuffer, 0, tmpBuffer.length);\nreturn Long.parseLong(new String(tmpBuffer), radix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:readNewEntry(Z)Lorg/apache/commons/compress/archivers/cpio/CpioArchiveEntry;",
                                    "method_body": "private CpioArchiveEntry readNewEntry(final boolean hasCrc)\nif (hasCrc) {\nret = new CpioArchiveEntry(FORMAT_NEW);\nret.setInode(readAsciiLong(8, 16));\nret.setMode(readAsciiLong(8, 16));\nret.setUID(readAsciiLong(8, 16));\nret.setGID(readAsciiLong(8, 16));\nret.setNumberOfLinks(readAsciiLong(8, 16));\nret.setTime(readAsciiLong(8, 16));\nret.setSize(readAsciiLong(8, 16));\nret.setDeviceMaj(readAsciiLong(8, 16));\nret.setDeviceMin(readAsciiLong(8, 16));\nret.setRemoteDeviceMaj(readAsciiLong(8, 16));\nret.setRemoteDeviceMin(readAsciiLong(8, 16));\nlong namesize = readAsciiLong(8, 16);\nret.setChksum(readAsciiLong(8, 16));\nret.setName(readCString((int) namesize));\npad(ret.getHeaderSize() + namesize, 4);\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:readCString(I)Ljava/lang/String;",
                                    "method_body": "private String readCString(final int length) throws IOException {\nbyte tmpBuffer[] = new byte[length];\nreadFully(tmpBuffer, 0, tmpBuffer.length);\nreturn new String(tmpBuffer, 0, tmpBuffer.length - 1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:getNextEntry()Lorg/apache/commons/compress/archivers/ArchiveEntry;",
                                    "method_body": "public ArchiveEntry getNextEntry() throws IOException {\nreturn getNextCPIOEntry();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioUtil:byteArray2long([BZ)J",
                                    "method_body": "static long byteArray2long(final byte[] number, final boolean swapHalfWord) {\nlong ret = 0;\nint pos = 0;\nbyte tmp_number[] = new byte[number.length];\nSystem.arraycopy(number, 0, tmp_number, 0, number.length);\nif (tmp_number.length % 2 != 0) {\nif (!swapHalfWord) {\nbyte tmp = 0;\nfor (pos = 0; pos < tmp_number.length; pos++) {\ntmp = tmp_number[pos];\ntmp_number[pos++] = tmp_number[pos];\ntmp_number[pos] = tmp;\nret = tmp_number[0] & 0xFF;\nfor (pos = 1; pos < tmp_number.length; pos++) {\nret <<= 8;\nret |= tmp_number[pos] & 0xFF;\nreturn ret;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 2,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.ArTestCase.testArDelete",
                            "test_body": "89: public void testArDelete() throws Exception {\n90: final File output = new File(dir, \"bla.ar\");\n91: 92: final File file1 = getFile(\"test1.xml\");\n93: final File file2 = getFile(\"test2.xml\");\n94: {\n95: // create\n96: 97: final OutputStream out = new FileOutputStream(output);\n98: final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\"ar\", out);\n99: os.putArchiveEntry(new ArArchiveEntry(\"test1.xml\", file1.length()));\n100: IOUtils.copy(new FileInputStream(file1), os);\n101: os.closeArchiveEntry();\n102: 103: os.putArchiveEntry(new ArArchiveEntry(\"test2.xml\", file2.length()));\n104: IOUtils.copy(new FileInputStream(file2), os);\n105: os.closeArchiveEntry();\n106: os.close();\n107: out.close();\n108: }\n109: 110: assertEquals(8\n111: + 60 + file1.length() + (file1.length() % 2)\n112: + 60 + file2.length() + (file2.length() % 2),\n113: output.length());\n114: 115: final File output2 = new File(dir, \"bla2.ar\");\n116: 117: int copied = 0;\n118: int deleted = 0;\n119: 120: {\n121: // remove all but one file\n122: 123: final InputStream is = new FileInputStream(output);\n124: final OutputStream os = new FileOutputStream(output2);\n125: final ArchiveOutputStream aos = new ArchiveStreamFactory().createArchiveOutputStream(\"ar\", os);\n126: final ArchiveInputStream ais = new ArchiveStreamFactory().createArchiveInputStream(new BufferedInputStream(is));\n127: while(true) {\n128: final ArArchiveEntry entry = (ArArchiveEntry)ais.getNextEntry();\n129: if (entry == null) {\n130: break;\n131: }\n132: 133: if (\"test1.xml\".equals(entry.getName())) {\n134: aos.putArchiveEntry(entry);\n135: IOUtils.copy(ais, aos);\n136: aos.closeArchiveEntry();\n137: copied++;\n138: } else {\n139: IOUtils.copy(ais, new ByteArrayOutputStream());\n140: deleted++;\n141: }\n142: 143: }\n144: ais.close();\n145: aos.close();\n146: is.close();\n147: os.close();\n148: }\n149: 150: assertEquals(1, copied);\n151: assertEquals(1, deleted);\n152: assertEquals(144, output2.length());\n153: 154: long files = 0;\n155: long sum = 0;\n156: 157: {\n158: final InputStream is = new FileInputStream(output2);\n159: final ArchiveInputStream ais = new ArchiveStreamFactory().createArchiveInputStream(new BufferedInputStream(is));\n160: while(true) {\n161: final ArArchiveEntry entry = (ArArchiveEntry)ais.getNextEntry();\n162: if (entry == null) {\n163: break;\n164: }\n165: 166: IOUtils.copy(ais, new ByteArrayOutputStream());\n167: 168: sum +=  entry.getLength();\n169: files++;\n170: }\n171: ais.close();\n172: is.close();\n173: }\n174: 175: assertEquals(1, files);\n176: assertEquals(76, sum);\n177: 178: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveOutputStream(Ljava/lang/String;Ljava/io/OutputStream;)Lorg/apache/commons/compress/archivers/ArchiveOutputStream;",
                                    "method_body": "public ArchiveOutputStream createArchiveOutputStream(\nif (archiverName == null || out == null) {\nif (\"ar\".equalsIgnoreCase(archiverName)) {\nreturn new ArArchiveOutputStream(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveInputStream(Ljava/io/InputStream;)Lorg/apache/commons/compress/archivers/ArchiveInputStream;",
                                    "method_body": "public ArchiveInputStream createArchiveInputStream(final InputStream in)\nif (in == null) {\nif (!in.markSupported()) {\nfinal byte[] signature = new byte[12];\nin.mark(signature.length);\nint signatureLength = in.read(signature);\nin.reset();\nif (ZipArchiveInputStream.matches(signature, signatureLength)) {\n} else if (JarArchiveInputStream\n} else if (TarArchiveInputStream\n} else if (ArArchiveInputStream.matches(signature, signatureLength)) {\nreturn new ArArchiveInputStream(in);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:copy(Ljava/io/InputStream;Ljava/io/OutputStream;)J",
                                    "method_body": "public static long copy(final InputStream input, final OutputStream output) throws IOException {\nreturn copy(input, output, 8024);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:copy(Ljava/io/InputStream;Ljava/io/OutputStream;I)J",
                                    "method_body": "public static long copy(final InputStream input, final OutputStream output, int buffersize) throws IOException {\nfinal byte[] buffer = new byte[buffersize];\nint n = 0;\nlong count=0;\nwhile (-1 != (n = input.read(buffer))) {\noutput.write(buffer, 0, n);\ncount += n;\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "private final OutputStream out;\nprivate long archiveOffset = 0;\nprivate long entryOffset = 0;\nprivate boolean haveUnclosedEntry = true;\npublic ArArchiveOutputStream( final OutputStream pOut ) {\nthis.out = pOut;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:writeArchiveHeader()J",
                                    "method_body": "private long writeArchiveHeader() throws IOException {\nbyte [] header = ArArchiveEntry.HEADER.getBytes();\nout.write(header);\nreturn header.length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (prevEntry != null && haveUnclosedEntry && (entryOffset % 2) != 0) {\nhaveUnclosedEntry = false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry( final ArchiveEntry pEntry ) throws IOException {\nArArchiveEntry pArEntry = (ArArchiveEntry)pEntry;\nif (prevEntry == null) {\narchiveOffset += writeArchiveHeader();\nif (prevEntry.getLength() != entryOffset) {\ncloseArchiveEntry();\nprevEntry = pArEntry;\narchiveOffset += writeEntryHeader(pArEntry);\nentryOffset = 0;\nhaveUnclosedEntry = true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:fill(JJC)J",
                                    "method_body": "private long fill( final long pOffset, final long pNewOffset, final char pFill ) throws IOException {\nfinal long diff = pNewOffset - pOffset;\nif (diff > 0) {\nfor (int i = 0; i < diff; i++) {\nwrite(pFill);\nreturn pNewOffset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:write(Ljava/lang/String;)J",
                                    "method_body": "private long write( final String data ) throws IOException {\nfinal byte[] bytes = data.getBytes(\"ascii\");\nwrite(bytes);\nreturn bytes.length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:writeEntryHeader(Lorg/apache/commons/compress/archivers/ar/ArArchiveEntry;)J",
                                    "method_body": "private long writeEntryHeader( final ArArchiveEntry pEntry ) throws IOException {\nlong offset = 0;\nfinal String n = pEntry.getName();\nif (n.length() > 16) {\noffset += write(n);\noffset = fill(offset, 16, ' ');\nfinal String m = \"\" + (pEntry.getLastModified() / 1000);\nif (m.length() > 12) {\noffset += write(m);\noffset = fill(offset, 28, ' ');\nfinal String u = \"\" + pEntry.getUserId();\nif (u.length() > 6) {\noffset += write(u);\noffset = fill(offset, 34, ' ');\nfinal String g = \"\" + pEntry.getGroupId();\nif (g.length() > 6) {\noffset += write(g);\noffset = fill(offset, 40, ' ');\nfinal String fm = \"\" + Integer.toString(pEntry.getMode(), 8);\nif (fm.length() > 8) {\noffset += write(fm);\noffset = fill(offset, 48, ' ');\nfinal String s = \"\" + pEntry.getLength();\nif (s.length() > 10) {\noffset += write(s);\noffset = fill(offset, 58, ' ');\noffset += write(ArArchiveEntry.TRAILER);\nreturn offset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:write(I)V",
                                    "method_body": "public void write(int b) throws IOException {\nout.write(b);\nentryOffset++;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int off, int len) throws IOException {\nout.write(b, off, len);\nentryOffset += len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:write([B)V",
                                    "method_body": "public void write(byte[] b) throws IOException {\nout.write(b);\nentryOffset += b.length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\ncloseArchiveEntry();\nout.close();\nprevEntry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:<init>(Ljava/lang/String;J)V",
                                    "method_body": "public ArArchiveEntry(String name, long length) {\nthis(name, length, 0, 0, DEFAULT_MODE, System.currentTimeMillis());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:<init>(Ljava/lang/String;JIIIJ)V",
                                    "method_body": "public ArArchiveEntry(String name, long length, int userId, int groupId, int mode, long lastModified) {\nthis.name = name;\nthis.length = length;\nthis.userId = userId;\nthis.groupId = groupId;\nthis.mode = mode;\nthis.lastModified = lastModified;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getUserId()I",
                                    "method_body": "public int getUserId() {\nreturn userId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getGroupId()I",
                                    "method_body": "public int getGroupId() {\nreturn groupId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getMode()I",
                                    "method_body": "public int getMode() {\nreturn mode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getLastModified()J",
                                    "method_body": "public long getLastModified() {\nreturn lastModified;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getLength()J",
                                    "method_body": "public long getLength() {\nreturn length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < ZipArchiveOutputStream.LFH_SIG.length) {\nreturn checksig(signature, ZipArchiveOutputStream.LFH_SIG) // normal file\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:checksig([B[B)Z",
                                    "method_body": "private static boolean checksig(byte[] signature, byte[] expected){\nfor (int i = 0; i < expected.length; i++) {\nif (signature[i] != expected[i]) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "private static final byte[] LZERO = {0, 0, 0, 0};\nprivate static final byte[] LZERO = {0, 0, 0, 0};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length ) {\nreturn ZipArchiveInputStream.matches(signature, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < 8) {\nif (signature[0] != 0x74) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public ArArchiveInputStream( final InputStream pInput ) {\ninput = pInput;\nclosed = false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:getNextArEntry()Lorg/apache/commons/compress/archivers/ar/ArArchiveEntry;",
                                    "method_body": "public ArArchiveEntry getNextArEntry() throws IOException {\nif (offset == 0) {\nfinal byte[] expected = ArArchiveEntry.HEADER.getBytes();\nfinal byte[] realized = new byte[expected.length];\nfinal int read = read(realized);\nif (read != expected.length) {\nfor (int i = 0; i < expected.length; i++) {\nif (expected[i] != realized[i]) {\nif (input.available() == 0) {\nreturn null;\nif (offset % 2 != 0) {\nfinal byte[] name = new byte[16];\nfinal byte[] lastmodified = new byte[12];\nfinal byte[] userid = new byte[6];\nfinal byte[] groupid = new byte[6];\nfinal byte[] filemode = new byte[8];\nfinal byte[] length = new byte[10];\nread(name);\nread(lastmodified);\nread(userid);\nread(groupid);\nread(filemode);\nread(length);\nfinal byte[] expected = ArArchiveEntry.TRAILER.getBytes();\nfinal byte[] realized = new byte[expected.length];\nfinal int read = read(realized);\nif (read != expected.length) {\nfor (int i = 0; i < expected.length; i++) {\nif (expected[i] != realized[i]) {\nreturn new ArArchiveEntry(new String(name).trim(),\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:getNextEntry()Lorg/apache/commons/compress/archivers/ArchiveEntry;",
                                    "method_body": "public ArchiveEntry getNextEntry() throws IOException {\nreturn getNextArEntry();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!closed) {\nclosed = true;\ninput.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:read([B)I",
                                    "method_body": "public int read(byte[] b) throws IOException {\nreturn read(b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, final int off, final int len) throws IOException {\nint toRead = len;\nfinal int ret = this.input.read(b, off, toRead);\noffset += (ret > 0 ? ret : 0);\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < 8) {\nif (signature[0] != 0x21) {\nif (signature[1] != 0x3c) {\nif (signature[2] != 0x61) {\nif (signature[3] != 0x72) {\nif (signature[4] != 0x63) {\nif (signature[5] != 0x68) {\nif (signature[6] != 0x3e) {\nif (signature[7] != 0x0a) {\nreturn true;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 3,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.ArchiveOutputStreamTest.testFinish",
                            "test_body": "24: public void testFinish() throws Exception {\n25: OutputStream out1 = new ByteArrayOutputStream();\n26: 27: ArchiveOutputStream aos1 = factory.createArchiveOutputStream(\"zip\", out1);\n28: aos1.putArchiveEntry(new ZipArchiveEntry(\"dummy\"));\n29: try {\n30: aos1.finish();\n31: fail(\"After putArchive should follow closeArchive\");\n32: } catch (IOException io) {\n33: // Exception expected\n34: }\n35: 36: aos1 = factory.createArchiveOutputStream(\"jar\", out1);\n37: aos1.putArchiveEntry(new JarArchiveEntry(\"dummy\"));\n38: try {\n39: aos1.finish();\n40: fail(\"After putArchive should follow closeArchive\");\n41: } catch (IOException io) {\n42: // Exception expected\n43: }\n44: 45: aos1 = factory.createArchiveOutputStream(\"ar\", out1);\n46: aos1.putArchiveEntry(new ArArchiveEntry(\"dummy\", 100));\n47: try {\n48: aos1.finish();\n49: fail(\"After putArchive should follow closeArchive\");\n50: } catch (IOException io) {\n51: // Exception expected\n52: }\n53: 54: aos1 = factory.createArchiveOutputStream(\"cpio\", out1);\n55: aos1.putArchiveEntry(new CpioArchiveEntry(\"dummy\"));\n56: try {\n57: aos1.finish();\n58: fail(\"After putArchive should follow closeArchive\");\n59: } catch (IOException io) {\n60: // Exception expected\n61: }\n62: 63: aos1 = factory.createArchiveOutputStream(\"tar\", out1);\n64: aos1.putArchiveEntry(new TarArchiveEntry(\"dummy\"));\n65: try {\n66: aos1.finish();\n67: fail(\"After putArchive should follow closeArchive\");\n68: } catch (IOException io) {\n69: // Exception expected\n70: }\n71: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveOutputStream(Ljava/lang/String;Ljava/io/OutputStream;)Lorg/apache/commons/compress/archivers/ArchiveOutputStream;",
                                    "method_body": "public ArchiveOutputStream createArchiveOutputStream(\nif (archiverName == null || out == null) {\nif (\"ar\".equalsIgnoreCase(archiverName)) {\nreturn new ArArchiveOutputStream(out);\n} else if (\"zip\".equalsIgnoreCase(archiverName)) {\nreturn new ZipArchiveOutputStream(out);\n} else if (\"tar\".equalsIgnoreCase(archiverName)) {\nreturn new TarArchiveOutputStream(out);\n} else if (\"jar\".equalsIgnoreCase(archiverName)) {\nreturn new JarArchiveOutputStream(out);\n} else if (\"cpio\".equalsIgnoreCase(archiverName)) {\nreturn new CpioArchiveOutputStream(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveOutputStream:<init>()V",
                                    "method_body": "private final byte[] oneByte = new byte[1];\n* {@link #closeArchiveEntry()} to complete the process."
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveOutputStream:write(I)V",
                                    "method_body": "public void write(int b) throws IOException {\noneByte[0] = (byte) (b & BYTE_MASK);\nwrite(oneByte, 0, 1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:<init>(Ljava/io/OutputStream;S)V",
                                    "method_body": "public CpioArchiveOutputStream(final OutputStream out, final short format) {\nthis.out = new FilterOutputStream(out);\nswitch (format) {\nbreak;\nthis.entryFormat = format;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public CpioArchiveOutputStream(final OutputStream out) {\nthis(out, FORMAT_NEW);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:ensureOpen()V",
                                    "method_body": "private void ensureOpen() throws IOException {\nif (this.closed) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry entry) throws IOException {\nCpioArchiveEntry e = (CpioArchiveEntry) entry;\nensureOpen();\nif (this.entry != null) {\nif (e.getTime() == -1) {\nfinal short format = e.getFormat();\nif (format != this.entryFormat){\nif (this.names.put(e.getName(), e) != null) {\nwriteHeader(e);\nthis.entry = e;\nthis.written = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:writeHeader(Lorg/apache/commons/compress/archivers/cpio/CpioArchiveEntry;)V",
                                    "method_body": "private void writeHeader(final CpioArchiveEntry e) throws IOException {\nswitch (e.getFormat()) {\nout.write(ArchiveUtils.toAsciiBytes(MAGIC_NEW));\nwriteNewEntry(e);\nbreak;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:writeNewEntry(Lorg/apache/commons/compress/archivers/cpio/CpioArchiveEntry;)V",
                                    "method_body": "private void writeNewEntry(final CpioArchiveEntry entry) throws IOException {\nwriteAsciiLong(entry.getInode(), 8, 16);\nwriteAsciiLong(entry.getMode(), 8, 16);\nwriteAsciiLong(entry.getUID(), 8, 16);\nwriteAsciiLong(entry.getGID(), 8, 16);\nwriteAsciiLong(entry.getNumberOfLinks(), 8, 16);\nwriteAsciiLong(entry.getTime(), 8, 16);\nwriteAsciiLong(entry.getSize(), 8, 16);\nwriteAsciiLong(entry.getDeviceMaj(), 8, 16);\nwriteAsciiLong(entry.getDeviceMin(), 8, 16);\nwriteAsciiLong(entry.getRemoteDeviceMaj(), 8, 16);\nwriteAsciiLong(entry.getRemoteDeviceMin(), 8, 16);\nwriteAsciiLong(entry.getName().length() + 1, 8, 16);\nwriteAsciiLong(entry.getChksum(), 8, 16);\nwriteCString(entry.getName());\npad(entry.getHeaderPadCount());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nensureOpen();\nif (this.finished) {\nif (this.entry != null) {\nthrow new IOException(\"This archives contains unclosed entries.\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:pad(I)V",
                                    "method_body": "private void pad(int count) throws IOException{\nif (count > 0){\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:writeAsciiLong(JII)V",
                                    "method_body": "private void writeAsciiLong(final long number, final int length,\nStringBuffer tmp = new StringBuffer();\nif (radix == 16) {\ntmp.append(Long.toHexString(number));\nif (tmp.length() <= length) {\nlong insertLength = length - tmp.length();\nfor (int pos = 0; pos < insertLength; pos++) {\ntmp.insert(0, \"0\");\ntmpStr = tmp.toString();\n} else {\nout.write(tmpStr.getBytes()); // TODO is it correct to use the default charset here?\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:writeCString(Ljava/lang/String;)V",
                                    "method_body": "private void writeCString(final String str) throws IOException {\nout.write(str.getBytes()); // TODO is it correct to use the default charset here?\nout.write('\\0');\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:<init>(S)V",
                                    "method_body": "public CpioArchiveEntry(final short format) {\nswitch (format) {\nthis.headerSize = 110;\nthis.alignmentBoundary = 4;\nbreak;\nthis.fileFormat = format;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public CpioArchiveEntry(final String name) {\nthis(FORMAT_NEW);\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:checkNewFormat()V",
                                    "method_body": "private void checkNewFormat() {\nif ((this.fileFormat & FORMAT_NEW_MASK) == 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getChksum()J",
                                    "method_body": "public long getChksum() {\ncheckNewFormat();\nreturn this.chksum;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getDeviceMaj()J",
                                    "method_body": "public long getDeviceMaj() {\ncheckNewFormat();\nreturn this.maj;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getDeviceMin()J",
                                    "method_body": "public long getDeviceMin() {\ncheckNewFormat();\nreturn this.min;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn this.filesize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getFormat()S",
                                    "method_body": "public short getFormat() {\nreturn this.fileFormat;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getGID()J",
                                    "method_body": "public long getGID() {\nreturn this.gid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getHeaderPadCount()I",
                                    "method_body": "public int getHeaderPadCount(){\nif (this.alignmentBoundary == 0) return 0;\nint size = this.headerSize+this.name.length()+1; // Name has terminating null\nint remain = size % this.alignmentBoundary;\nif (remain > 0){\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getInode()J",
                                    "method_body": "public long getInode() {\nreturn this.inode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getMode()J",
                                    "method_body": "public long getMode() {\nreturn this.mode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn this.name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getNumberOfLinks()J",
                                    "method_body": "public long getNumberOfLinks() {\nreturn this.nlink;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getRemoteDeviceMaj()J",
                                    "method_body": "public long getRemoteDeviceMaj() {\ncheckNewFormat();\nreturn this.rmaj;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getRemoteDeviceMin()J",
                                    "method_body": "public long getRemoteDeviceMin() {\ncheckNewFormat();\nreturn this.rmin;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getTime()J",
                                    "method_body": "public long getTime() {\nreturn this.mtime;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getUID()J",
                                    "method_body": "public long getUID() {\nreturn this.uid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:toAsciiBytes(Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] toAsciiBytes(String inputString){\nreturn inputString.getBytes(\"ASCII\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public ArArchiveOutputStream( final OutputStream pOut ) {\nthis.out = pOut;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:writeArchiveHeader()J",
                                    "method_body": "private long writeArchiveHeader() throws IOException {\nbyte [] header = ArchiveUtils.toAsciiBytes(ArArchiveEntry.HEADER);\nout.write(header);\nreturn header.length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry( final ArchiveEntry pEntry ) throws IOException {\nArArchiveEntry pArEntry = (ArArchiveEntry)pEntry;\nif (prevEntry == null) {\narchiveOffset += writeArchiveHeader();\nprevEntry = pArEntry;\narchiveOffset += writeEntryHeader(pArEntry);\nentryOffset = 0;\nhaveUnclosedEntry = true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:fill(JJC)J",
                                    "method_body": "private long fill( final long pOffset, final long pNewOffset, final char pFill ) throws IOException {\nfinal long diff = pNewOffset - pOffset;\nif (diff > 0) {\nfor (int i = 0; i < diff; i++) {\nwrite(pFill);\nreturn pNewOffset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:write(Ljava/lang/String;)J",
                                    "method_body": "private long write( final String data ) throws IOException {\nfinal byte[] bytes = data.getBytes(\"ascii\");\nwrite(bytes);\nreturn bytes.length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:writeEntryHeader(Lorg/apache/commons/compress/archivers/ar/ArArchiveEntry;)J",
                                    "method_body": "private long writeEntryHeader( final ArArchiveEntry pEntry ) throws IOException {\nlong offset = 0;\nfinal String n = pEntry.getName();\nif (n.length() > 16) {\noffset += write(n);\noffset = fill(offset, 16, ' ');\nfinal String m = \"\" + (pEntry.getLastModified() / 1000);\nif (m.length() > 12) {\noffset += write(m);\noffset = fill(offset, 28, ' ');\nfinal String u = \"\" + pEntry.getUserId();\nif (u.length() > 6) {\noffset += write(u);\noffset = fill(offset, 34, ' ');\nfinal String g = \"\" + pEntry.getGroupId();\nif (g.length() > 6) {\noffset += write(g);\noffset = fill(offset, 40, ' ');\nfinal String fm = \"\" + Integer.toString(pEntry.getMode(), 8);\nif (fm.length() > 8) {\noffset += write(fm);\noffset = fill(offset, 48, ' ');\nfinal String s = \"\" + pEntry.getLength();\nif (s.length() > 10) {\noffset += write(s);\noffset = fill(offset, 58, ' ');\noffset += write(ArArchiveEntry.TRAILER);\nreturn offset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int off, int len) throws IOException {\nout.write(b, off, len);\nentryOffset += len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif(haveUnclosedEntry) {\nthrow new IOException(\"This archives contains unclosed entries.\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:<init>(Ljava/lang/String;J)V",
                                    "method_body": "public ArArchiveEntry(String name, long length) {\nthis(name, length, 0, 0, DEFAULT_MODE, System.currentTimeMillis());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:<init>(Ljava/lang/String;JIIIJ)V",
                                    "method_body": "public ArArchiveEntry(String name, long length, int userId, int groupId, int mode, long lastModified) {\nthis.name = name;\nthis.length = length;\nthis.userId = userId;\nthis.groupId = groupId;\nthis.mode = mode;\nthis.lastModified = lastModified;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getUserId()I",
                                    "method_body": "public int getUserId() {\nreturn userId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getGroupId()I",
                                    "method_body": "public int getGroupId() {\nreturn groupId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getMode()I",
                                    "method_body": "public int getMode() {\nreturn mode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getLastModified()J",
                                    "method_body": "public long getLastModified() {\nreturn lastModified;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getLength()J",
                                    "method_body": "public long getLength() {\nreturn length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public ZipArchiveOutputStream(OutputStream out) {\nthis.out = out;\nthis.raf = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/File;)V",
                                    "method_body": "private ZipEncoding zipEncoding =\nprotected final Deflater def = new Deflater(level, true);\nprivate final byte[] buf = new byte[BUFFER_SIZE];\nprivate boolean useEFS = true;\nprivate boolean fallbackToUTF8 = false;\nprivate UnicodeExtraFieldPolicy createUnicodeExtraFields =\npublic ZipArchiveOutputStream(OutputStream out) {\nthis.out = out;\nthis.raf = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes();\nstatic final byte[] DD_SIG = ZipLong.getBytes(0X08074B50L);\nstatic final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes();\nstatic final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif(entry != null) {\nthrow new IOException(\"This archives contains unclosed entries.\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (entry == null) {\nreturn;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\ncloseArchiveEntry();\nentry = ((ZipArchiveEntry) archiveEntry);\nentries.add(entry);\nif (entry.getMethod() == -1) { // not specified\nentry.setMethod(method);\nif (entry.getTime() == -1) { // not specified\nentry.setTime(System.currentTimeMillis());\nif (entry.getMethod() == STORED && raf == null) {\nif (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\nwriteLocalFileHeader(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\nboolean encodable = zipEncoding.canEncode(ze.getName());\nif (!encodable && fallbackToUTF8) {\nentryEncoding = zipEncoding;\nByteBuffer name = entryEncoding.encode(ze.getName());\nif (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\noffsets.put(ze, ZipLong.getBytes(written));\nwriteOut(LFH_SIG);\nwritten += WORD;\nfinal int zipMethod = ze.getMethod();\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\nwritten += WORD;\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\nlocalDataStart = written;\nif (zipMethod == DEFLATED || raf != null) {\nwriteOut(LZERO);\nwriteOut(LZERO);\nwriteOut(LZERO);\nwritten += 12;\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\nbyte[] extra = ze.getLocalFileDataExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\nwriteOut(extra);\nwritten += extra.length;\ndataStart = written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([B)V",
                                    "method_body": "protected final void writeOut(byte[] data) throws IOException {\nwriteOut(data, 0, data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([BII)V",
                                    "method_body": "protected final void writeOut(byte[] data, int offset, int length)\nif (raf != null) {\nout.write(data, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeVersionNeededToExtractAndGeneralPurposeBits(IZ)V",
                                    "method_body": "private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\nint versionNeededToExtract = 10;\nint generalPurposeFlag = (useEFS || utfFallback) ? EFS_FLAG : 0;\nif (zipMethod == DEFLATED && raf == null) {\nversionNeededToExtract =  20;\ngeneralPurposeFlag |= 8;\nwriteOut(ZipShort.getBytes(versionNeededToExtract));\nwriteOut(ZipShort.getBytes(generalPurposeFlag));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map simpleEncodings;\nsimpleEncodings = new HashMap();\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\nreturn UTF8.equalsIgnoreCase(encoding)\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:canEncode(Ljava/lang/String;)Z",
                                    "method_body": "public boolean canEncode(String name) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(String name) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn ByteBuffer.wrap(name.getBytes(this.charset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "public static final int PLATFORM_UNIX = 3;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate LinkedHashMap/*<ZipShort, ZipExtraField>*/ extraFields = null;\nprivate String name = null;\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields() {\nif (extraFields == null) {\nZipExtraField[] result = new ZipExtraField[extraFields.size()];\nreturn (ZipExtraField[]) extraFields.values().toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:addAsFirstExtraField(Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void addAsFirstExtraField(ZipExtraField ze) {\nLinkedHashMap copy = extraFields;\nextraFields = new LinkedHashMap();\nextraFields.put(ze.getHeaderId(), ze);\nif (copy != null) {\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
                                    "method_body": "public byte[] getLocalFileDataExtra() {\nbyte[] extra = getExtra();\nreturn extra != null ? extra : new byte[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes(I)[B",
                                    "method_body": "public static byte[] getBytes(int value) {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(J)[B",
                                    "method_body": "public static byte[] toDosTime(long t) {\nCalendar c = Calendar.getInstance();\nc.setTimeInMillis(t);\nint year = c.get(Calendar.YEAR);\nif (year < 1980) {\nint month = c.get(Calendar.MONTH) + 1;\nlong value =  ((year - 1980) << 25)\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\nimplementations = new HashMap();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class c) {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\npublic JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getInstance()Lorg/apache/commons/compress/archivers/zip/JarMarker;",
                                    "method_body": "public static JarMarker getInstance() {\nreturn DEFAULT;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn NULL;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn NO_BYTES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public JarArchiveEntry(String name) {\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveEntry:<init>(Ljava/util/jar/JarEntry;)V",
                                    "method_body": "private Attributes manifestAttributes = null;\nprivate Certificate[] certificates = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn super.hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public JarArchiveOutputStream(final OutputStream out) {\nsuper(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry ze) throws IOException {\nif (!jarMarkerAdded) {\n((ZipArchiveEntry)ze).addAsFirstExtraField(JarMarker.getInstance());\njarMarkerAdded = true;\nsuper.putArchiveEntry(ze);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<init>(Ljava/lang/String;)V",
                                    "method_body": "private UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
                                    "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS =\npublic static final UnicodeExtraFieldPolicy NEVER =\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nprivate UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public TarArchiveOutputStream(OutputStream os) {\nthis(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;II)V",
                                    "method_body": "public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) {\nout = os;\nthis.buffer = new TarBuffer(os, blockSize, recordSize);\nthis.assemLen = 0;\nthis.assemBuf = new byte[recordSize];\nthis.recordBuf = new byte[recordSize];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nwriteEOFRecord();\nwriteEOFRecord();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\nTarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\nif (entry.getName().length() >= TarConstants.NAMELEN) {\nentry.writeEntryHeader(recordBuf);\nbuffer.writeRecord(recordBuf);\ncurrBytes = 0;\nif (entry.isDirectory()) {\ncurrSize = entry.getSize();\ncurrName = entry.getName();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:writeEOFRecord()V",
                                    "method_body": "private void writeEOFRecord() throws IOException {\nfor (int i = 0; i < recordBuf.length; ++i) {\nrecordBuf[i] = 0;\nbuffer.writeRecord(recordBuf);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/OutputStream;II)V",
                                    "method_body": "public TarBuffer(OutputStream outStream, int blockSize, int recordSize) {\nthis.inStream = null;\nthis.outStream = outStream;\nthis.initialize(blockSize, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:initialize(II)V",
                                    "method_body": "private void initialize(int blockSize, int recordSize) {\nthis.blockSize = blockSize;\nthis.recordSize = recordSize;\nthis.recsPerBlock = (this.blockSize / this.recordSize);\nthis.blockBuffer = new byte[this.blockSize];\nif (this.inStream != null) {\nthis.currBlkIdx = 0;\nthis.currRecIdx = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:writeRecord([B)V",
                                    "method_body": "public void writeRecord(byte[] record) throws IOException {\nif (outStream == null) {\nif (record.length != recordSize) {\nif (currRecIdx >= recsPerBlock) {\nSystem.arraycopy(record, 0, blockBuffer,\ncurrRecIdx++;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry () {\nthis.magic = MAGIC_POSIX;\nthis.version = VERSION_POSIX;\nthis.name = \"\";\nthis.linkName = \"\";\nString user = System.getProperty(\"user.name\", \"\");\nif (user.length() > MAX_NAMELEN) {\nthis.userId = 0;\nthis.groupId = 0;\nthis.userName = user;\nthis.groupName = \"\";\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public TarArchiveEntry(String name) {\nthis();\nname = normalizeFileName(name);\nboolean isDir = name.endsWith(\"/\");\nthis.devMajor = 0;\nthis.devMinor = 0;\nthis.name = name;\nthis.mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE;\nthis.linkFlag = isDir ? LF_DIR : LF_NORMAL;\nthis.userId = 0;\nthis.groupId = 0;\nthis.size = 0;\nthis.modTime = (new Date()).getTime() / MILLIS_PER_SECOND;\nthis.linkName = \"\";\nthis.userName = \"\";\nthis.groupName = \"\";\nthis.devMajor = 0;\nthis.devMinor = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nif (file != null) {\nif (linkFlag == LF_DIR) {\nif (getName().endsWith(\"/\")) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:writeEntryHeader([B)V",
                                    "method_body": "public void writeEntryHeader(byte[] outbuf) {\nint offset = 0;\noffset = TarUtils.formatNameBytes(name, outbuf, offset, NAMELEN);\noffset = TarUtils.formatOctalBytes(mode, outbuf, offset, MODELEN);\noffset = TarUtils.formatOctalBytes(userId, outbuf, offset, UIDLEN);\noffset = TarUtils.formatOctalBytes(groupId, outbuf, offset, GIDLEN);\noffset = TarUtils.formatLongOctalBytes(size, outbuf, offset, SIZELEN);\noffset = TarUtils.formatLongOctalBytes(modTime, outbuf, offset, MODTIMELEN);\nint csOffset = offset;\nfor (int c = 0; c < CHKSUMLEN; ++c) {\noutbuf[offset++] = (byte) ' ';\noutbuf[offset++] = linkFlag;\noffset = TarUtils.formatNameBytes(linkName, outbuf, offset, NAMELEN);\noffset = TarUtils.formatNameBytes(magic, outbuf, offset, MAGICLEN);\noffset = TarUtils.formatNameBytes(version, outbuf, offset, VERSIONLEN);\noffset = TarUtils.formatNameBytes(userName, outbuf, offset, UNAMELEN);\noffset = TarUtils.formatNameBytes(groupName, outbuf, offset, GNAMELEN);\noffset = TarUtils.formatOctalBytes(devMajor, outbuf, offset, DEVLEN);\noffset = TarUtils.formatOctalBytes(devMinor, outbuf, offset, DEVLEN);\nwhile (offset < outbuf.length) {\noutbuf[offset++] = 0;\nlong chk = TarUtils.computeCheckSum(outbuf);\nTarUtils.formatCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:normalizeFileName(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String normalizeFileName(String fileName) {\nString osname = System.getProperty(\"os.name\").toLowerCase(Locale.US);\nif (osname != null) {\nif (osname.startsWith(\"windows\")) {\n} else if (osname.indexOf(\"netware\") > -1) {\nfileName = fileName.replace(File.separatorChar, '/');\nwhile (fileName.startsWith(\"/\")) {\nreturn fileName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatNameBytes(Ljava/lang/String;[BII)I",
                                    "method_body": "public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {\nfor (i = 0; i < length && i < name.length(); ++i) {\nbuf[offset + i] = (byte) name.charAt(i);\nfor (; i < length; ++i) {\nbuf[offset + i] = 0;\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatUnsignedOctalString(J[BII)V",
                                    "method_body": "public static void formatUnsignedOctalString(final long value, byte[] buffer,\nint remaining = length;\nremaining--;\nif (value == 0) {\nbuffer[offset + remaining--] = (byte) '0';\nlong val = value;\nfor (; remaining >= 0 && val != 0; --remaining) {\nbuffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));\nval = val >>> 3;\nif (val != 0){\nfor (; remaining >= 0; --remaining) { // leading zeros\nbuffer[offset + remaining] = (byte) '0';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatOctalBytes(J[BII)I",
                                    "method_body": "public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {\nint idx=length-2; // For space and trailing null\nformatUnsignedOctalString(value, buf, offset, idx);\nbuf[offset + idx++] = (byte) ' '; // Trailing space\nbuf[offset + idx]   = 0; // Trailing null\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatLongOctalBytes(J[BII)I",
                                    "method_body": "public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {\nint idx=length-1; // For space\nformatUnsignedOctalString(value, buf, offset, idx);\nbuf[offset + idx] = (byte) ' '; // Trailing space\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatCheckSumOctalBytes(J[BII)I",
                                    "method_body": "public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {\nint idx=length-2; // for NUL and space\nformatUnsignedOctalString(value, buf, offset, idx);\nbuf[offset + idx++]   = 0; // Trailing null\nbuf[offset + idx]     = (byte) ' '; // Trailing space\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:computeCheckSum([B)J",
                                    "method_body": "public static long computeCheckSum(final byte[] buf) {\nlong sum = 0;\nfor (int i = 0; i < buf.length; ++i) {\nsum += BYTE_MASK & buf[i];\nreturn sum;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 4,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.jar.JarArchiveOutputStreamTest.testJarMarker",
                            "test_body": "33: public void testJarMarker() throws IOException {\n34: File testArchive = File.createTempFile(\"jar-aostest\", \".jar\");\n35: JarArchiveOutputStream out = null;\n36: ZipFile zf = null;\n37: try {\n38: 39: out = new JarArchiveOutputStream(new FileOutputStream(testArchive));\n40: out.putArchiveEntry(new ZipArchiveEntry(\"foo/\"));\n41: out.closeArchiveEntry();\n42: out.putArchiveEntry(new ZipArchiveEntry(\"bar/\"));\n43: out.closeArchiveEntry();\n44: out.finish();\n45: out.close();\n46: out = null;\n47: 48: zf = new ZipFile(testArchive);\n49: ZipArchiveEntry ze = zf.getEntry(\"foo/\");\n50: assertNotNull(ze);\n51: ZipExtraField[] fes = ze.getExtraFields();\n52: assertEquals(1, fes.length);\n53: assertTrue(fes[0] instanceof JarMarker);\n54: 55: ze = zf.getEntry(\"bar/\");\n56: assertNotNull(ze);\n57: fes = ze.getExtraFields();\n58: assertEquals(0, fes.length);\n59: } finally {\n60: if (out != null) {\n61: try {\n62: out.close();\n63: } catch (IOException e) { /* swallow */ }\n64: }\n65: ZipFile.closeQuietly(zf);\n66: if (testArchive.exists()) {\n67: testArchive.delete();\n68: }\n69: }\n70: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public ZipArchiveOutputStream(OutputStream out) {\nthis.out = out;\nthis.raf = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes();\nstatic final byte[] DD_SIG = ZipLong.getBytes(0X08074B50L);\nstatic final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes();\nstatic final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif(entry != null) {\ncdOffset = written;\nfor (Iterator i = entries.iterator(); i.hasNext(); ) {\nwriteCentralFileHeader((ZipArchiveEntry) i.next());\ncdLength = written - cdOffset;\nwriteCentralDirectoryEnd();\noffsets.clear();\nentries.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (entry == null) {\nreturn;\nlong realCrc = crc.getValue();\ncrc.reset();\nif (entry.getMethod() == DEFLATED) {\ndef.finish();\nwhile (!def.finished()) {\ndeflate();\nentry.setSize(ZipUtil.adjustToLong(def.getTotalIn()));\nentry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut()));\nentry.setCrc(realCrc);\ndef.reset();\nwritten += entry.getCompressedSize();\nif (raf != null) {\nlong save = raf.getFilePointer();\nraf.seek(localDataStart);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\nraf.seek(save);\nwriteDataDescriptor(entry);\nentry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\ncloseArchiveEntry();\nentry = ((ZipArchiveEntry) archiveEntry);\nentries.add(entry);\nif (entry.getMethod() == -1) { // not specified\nentry.setMethod(method);\nif (entry.getTime() == -1) { // not specified\nentry.setTime(System.currentTimeMillis());\nif (entry.getMethod() == STORED && raf == null) {\nif (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\nwriteLocalFileHeader(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nfinish();\nif (raf != null) {\nraf.close();\nif (out != null) {\nout.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflate()V",
                                    "method_body": "protected final void deflate() throws IOException {\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\nboolean encodable = zipEncoding.canEncode(ze.getName());\nif (!encodable && fallbackToUTF8) {\nentryEncoding = zipEncoding;\nByteBuffer name = entryEncoding.encode(ze.getName());\nif (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\nze.addExtraField(new UnicodePathExtraField(ze.getName(),\nString comm = ze.getComment();\nif (comm != null && !\"\".equals(comm)) {\noffsets.put(ze, ZipLong.getBytes(written));\nwriteOut(LFH_SIG);\nwritten += WORD;\nfinal int zipMethod = ze.getMethod();\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\nwritten += WORD;\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\nlocalDataStart = written;\nif (zipMethod == DEFLATED || raf != null) {\nwriteOut(LZERO);\nwriteOut(LZERO);\nwriteOut(LZERO);\nwritten += 12;\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\nbyte[] extra = ze.getLocalFileDataExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\nwriteOut(extra);\nwritten += extra.length;\ndataStart = written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeDataDescriptor(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeDataDescriptor(ZipArchiveEntry ze) throws IOException {\nif (ze.getMethod() != DEFLATED || raf != null) {\nreturn;\nwriteOut(DD_SIG);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\nwritten += 16;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\nwriteOut(CFH_SIG);\nwritten += WORD;\nwriteOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\nwritten += SHORT;\nfinal int zipMethod = ze.getMethod();\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\nwritten += WORD;\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getCompressedSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\nwritten += 12;\nif (!encodable && fallbackToUTF8) {\nentryEncoding = zipEncoding;\nByteBuffer name = entryEncoding.encode(ze.getName());\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\nbyte[] extra = ze.getCentralDirectoryExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\nString comm = ze.getComment();\nif (comm == null) {\ncomm = \"\";\nByteBuffer commentB = entryEncoding.encode(comm);\nwriteOut(ZipShort.getBytes(commentB.limit()));\nwritten += SHORT;\nwriteOut(ZERO);\nwritten += SHORT;\nwriteOut(ZipShort.getBytes(ze.getInternalAttributes()));\nwritten += SHORT;\nwriteOut(ZipLong.getBytes(ze.getExternalAttributes()));\nwritten += WORD;\nwriteOut((byte[]) offsets.get(ze));\nwritten += WORD;\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\nwriteOut(extra);\nwritten += extra.length;\nwriteOut(commentB.array(), commentB.arrayOffset(), commentB.limit());\nwritten += commentB.limit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryEnd()V",
                                    "method_body": "protected void writeCentralDirectoryEnd() throws IOException {\nwriteOut(EOCD_SIG);\nwriteOut(ZERO);\nwriteOut(ZERO);\nbyte[] num = ZipShort.getBytes(entries.size());\nwriteOut(num);\nwriteOut(num);\nwriteOut(ZipLong.getBytes(cdLength));\nwriteOut(ZipLong.getBytes(cdOffset));\nByteBuffer data = this.zipEncoding.encode(comment);\nwriteOut(ZipShort.getBytes(data.limit()));\nwriteOut(data.array(), data.arrayOffset(), data.limit());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([B)V",
                                    "method_body": "protected final void writeOut(byte[] data) throws IOException {\nwriteOut(data, 0, data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([BII)V",
                                    "method_body": "protected final void writeOut(byte[] data, int offset, int length)\nif (raf != null) {\nraf.write(data, offset, length);\nout.write(data, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeVersionNeededToExtractAndGeneralPurposeBits(IZ)V",
                                    "method_body": "private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\nint versionNeededToExtract = 10;\nint generalPurposeFlag = (useEFS || utfFallback) ? EFS_FLAG : 0;\nif (zipMethod == DEFLATED && raf == null) {\nversionNeededToExtract =  20;\ngeneralPurposeFlag |= 8;\nwriteOut(ZipShort.getBytes(versionNeededToExtract));\nwriteOut(ZipShort.getBytes(generalPurposeFlag));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map simpleEncodings;\nsimpleEncodings = new HashMap();\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\nif (name == null) {\nSimpleEncodingHolder h =\nif (h!=null) {\nreturn h.getEncoding();\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\nreturn UTF8.equalsIgnoreCase(encoding)\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:canEncode(Ljava/lang/String;)Z",
                                    "method_body": "public boolean canEncode(String name) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(String name) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn ByteBuffer.wrap(name.getBytes(this.charset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "public static final int PLATFORM_UNIX = 3;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate LinkedHashMap/*<ZipShort, ZipExtraField>*/ extraFields = null;\nprivate String name = null;\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getInternalAttributes()I",
                                    "method_body": "public int getInternalAttributes() {\nreturn internalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExternalAttributes()J",
                                    "method_body": "public long getExternalAttributes() {\nreturn externalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields() {\nif (extraFields == null) {\nreturn new ZipExtraField[0];\nZipExtraField[] result = new ZipExtraField[extraFields.size()];\nreturn (ZipExtraField[]) extraFields.values().toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:addAsFirstExtraField(Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void addAsFirstExtraField(ZipExtraField ze) {\nLinkedHashMap copy = extraFields;\nextraFields = new LinkedHashMap();\nextraFields.put(ze.getHeaderId(), ze);\nif (copy != null) {\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
                                    "method_body": "public byte[] getLocalFileDataExtra() {\nbyte[] extra = getExtra();\nreturn extra != null ? extra : new byte[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getCentralDirectoryExtra()[B",
                                    "method_body": "public byte[] getCentralDirectoryExtra() {\nreturn ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes(I)[B",
                                    "method_body": "public static byte[] getBytes(int value) {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(J)[B",
                                    "method_body": "public static byte[] toDosTime(long t) {\nCalendar c = Calendar.getInstance();\nc.setTimeInMillis(t);\nint year = c.get(Calendar.YEAR);\nif (year < 1980) {\nint month = c.get(Calendar.MONTH) + 1;\nlong value =  ((year - 1980) << 25)\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:adjustToLong(I)J",
                                    "method_body": "public static long adjustToLong(int i) {\nif (i < 0) {\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\nimplementations = new HashMap();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class c) {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeCentralDirectoryData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getCentralDirectoryLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\nbyte[] local = data[i].getCentralDirectoryData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\npublic JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getInstance()Lorg/apache/commons/compress/archivers/zip/JarMarker;",
                                    "method_body": "public static JarMarker getInstance() {\nreturn DEFAULT;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn NULL;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getCentralDirectoryLength() {\nreturn NULL;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn NO_BYTES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getCentralDirectoryData()[B",
                                    "method_body": "public byte[] getCentralDirectoryData() {\nreturn NO_BYTES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public JarArchiveOutputStream(final OutputStream out) {\nsuper(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry ze) throws IOException {\nif (!jarMarkerAdded) {\n((ZipArchiveEntry)ze).addAsFirstExtraField(JarMarker.getInstance());\njarMarkerAdded = true;\nsuper.putArchiveEntry(ze);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<init>(Ljava/lang/String;)V",
                                    "method_body": "private UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
                                    "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS =\npublic static final UnicodeExtraFieldPolicy NEVER =\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nprivate UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipFile(File f) throws IOException {\nthis(f, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;)V",
                                    "method_body": "public ZipFile(File f, String encoding) throws IOException {\nthis(f, encoding, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\nthrows IOException {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = new RandomAccessFile(f, \"r\");\nboolean success = false;\nMap entriesWithoutEFS = populateFromCentralDirectory();\nif (!success) {\narchive.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
                                    "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map populateFromCentralDirectory()\nHashMap noEFS = new HashMap();\npositionAtCentralDirectory();\nbyte[] cfh = new byte[CFH_LEN];\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nfinal long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\nif (sig != cfhSig && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nboolean found = false;\nlong off = archive.length() - MIN_EOCD_SIZE;\nlong stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE);\nif (off >= 0) {\narchive.seek(off);\nbyte[] sig = ZipArchiveOutputStream.EOCD_SIG;\nint curr = archive.read();\nwhile (off >= stopSearching && curr != -1) {\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\nif (!found) {\narchive.seek(off + CFD_LOCATOR_OFFSET);\nbyte[] cfdOffset = new byte[WORD];\narchive.readFully(cfdOffset);\narchive.seek(ZipLong.getValue(cfdOffset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:startsWithLocalFileHeader()Z",
                                    "method_body": "private boolean startsWithLocalFileHeader() throws IOException {\narchive.seek(0);\nfinal byte[] start = new byte[WORD];\narchive.readFully(start);\nfor (int i = 0; i < start.length; i++) {\nif (start[i] != ZipArchiveOutputStream.LFH_SIG[i]) {\nreturn true;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testCP437FileRoundtripExplicitUnicodeExtra",
                            "test_body": "53: public void testCP437FileRoundtripExplicitUnicodeExtra()\n54: throws IOException {\n55: testFileRoundtrip(CP437, false, true);\n56: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipArchiveOutputStream(File file) throws IOException {\nOutputStream o = null;\nRandomAccessFile _raf = null;\n_raf = new RandomAccessFile(file, \"rw\");\n_raf.setLength(0);\n}\nout = o;\nraf = _raf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes();\nstatic final byte[] DD_SIG = ZipLong.getBytes(0X08074B50L);\nstatic final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes();\nstatic final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif(entry != null) {\ncdOffset = written;\nfor (Iterator i = entries.iterator(); i.hasNext(); ) {\nwriteCentralFileHeader((ZipArchiveEntry) i.next());\ncdLength = written - cdOffset;\nwriteCentralDirectoryEnd();\noffsets.clear();\nentries.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (entry == null) {\nreturn;\nlong realCrc = crc.getValue();\ncrc.reset();\nif (entry.getMethod() == DEFLATED) {\ndef.finish();\nwhile (!def.finished()) {\ndeflate();\nentry.setSize(ZipUtil.adjustToLong(def.getTotalIn()));\nentry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut()));\nentry.setCrc(realCrc);\ndef.reset();\nwritten += entry.getCompressedSize();\nif (raf != null) {\nlong save = raf.getFilePointer();\nraf.seek(localDataStart);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\nraf.seek(save);\nwriteDataDescriptor(entry);\nentry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\ncloseArchiveEntry();\nentry = ((ZipArchiveEntry) archiveEntry);\nentries.add(entry);\nif (entry.getMethod() == -1) { // not specified\nentry.setMethod(method);\nif (entry.getTime() == -1) { // not specified\nentry.setTime(System.currentTimeMillis());\nif (entry.getMethod() == STORED && raf == null) {\nif (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\nwriteLocalFileHeader(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nfinish();\nif (raf != null) {\nraf.close();\nif (out != null) {\nout.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflate()V",
                                    "method_body": "protected final void deflate() throws IOException {\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\nboolean encodable = zipEncoding.canEncode(ze.getName());\nif (!encodable && fallbackToUTF8) {\nentryEncoding = zipEncoding;\nByteBuffer name = entryEncoding.encode(ze.getName());\nif (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\nze.addExtraField(new UnicodePathExtraField(ze.getName(),\nString comm = ze.getComment();\nif (comm != null && !\"\".equals(comm)) {\noffsets.put(ze, ZipLong.getBytes(written));\nwriteOut(LFH_SIG);\nwritten += WORD;\nfinal int zipMethod = ze.getMethod();\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\nwritten += WORD;\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\nlocalDataStart = written;\nif (zipMethod == DEFLATED || raf != null) {\nwriteOut(LZERO);\nwriteOut(LZERO);\nwriteOut(LZERO);\nwritten += 12;\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\nbyte[] extra = ze.getLocalFileDataExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\nwriteOut(extra);\nwritten += extra.length;\ndataStart = written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\nwriteOut(CFH_SIG);\nwritten += WORD;\nwriteOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\nwritten += SHORT;\nfinal int zipMethod = ze.getMethod();\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\nwritten += WORD;\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getCompressedSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\nwritten += 12;\nif (!encodable && fallbackToUTF8) {\nentryEncoding = zipEncoding;\nByteBuffer name = entryEncoding.encode(ze.getName());\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\nbyte[] extra = ze.getCentralDirectoryExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\nString comm = ze.getComment();\nif (comm == null) {\ncomm = \"\";\nByteBuffer commentB = entryEncoding.encode(comm);\nwriteOut(ZipShort.getBytes(commentB.limit()));\nwritten += SHORT;\nwriteOut(ZERO);\nwritten += SHORT;\nwriteOut(ZipShort.getBytes(ze.getInternalAttributes()));\nwritten += SHORT;\nwriteOut(ZipLong.getBytes(ze.getExternalAttributes()));\nwritten += WORD;\nwriteOut((byte[]) offsets.get(ze));\nwritten += WORD;\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\nwriteOut(extra);\nwritten += extra.length;\nwriteOut(commentB.array(), commentB.arrayOffset(), commentB.limit());\nwritten += commentB.limit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryEnd()V",
                                    "method_body": "protected void writeCentralDirectoryEnd() throws IOException {\nwriteOut(EOCD_SIG);\nwriteOut(ZERO);\nwriteOut(ZERO);\nbyte[] num = ZipShort.getBytes(entries.size());\nwriteOut(num);\nwriteOut(num);\nwriteOut(ZipLong.getBytes(cdLength));\nwriteOut(ZipLong.getBytes(cdOffset));\nByteBuffer data = this.zipEncoding.encode(comment);\nwriteOut(ZipShort.getBytes(data.limit()));\nwriteOut(data.array(), data.arrayOffset(), data.limit());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([B)V",
                                    "method_body": "protected final void writeOut(byte[] data) throws IOException {\nwriteOut(data, 0, data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([BII)V",
                                    "method_body": "protected final void writeOut(byte[] data, int offset, int length)\nif (raf != null) {\nraf.write(data, offset, length);\nout.write(data, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeVersionNeededToExtractAndGeneralPurposeBits(IZ)V",
                                    "method_body": "private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\nint versionNeededToExtract = 10;\nint generalPurposeFlag = (useEFS || utfFallback) ? EFS_FLAG : 0;\nif (zipMethod == DEFLATED && raf == null) {\nversionNeededToExtract =  20;\ngeneralPurposeFlag |= 8;\nwriteOut(ZipShort.getBytes(versionNeededToExtract));\nwriteOut(ZipShort.getBytes(generalPurposeFlag));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map simpleEncodings;\nsimpleEncodings = new HashMap();\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\nif (name == null) {\nSimpleEncodingHolder h =\nif (h!=null) {\nreturn h.getEncoding();\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\nreturn UTF8.equalsIgnoreCase(encoding)\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "public static final int PLATFORM_UNIX = 3;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate LinkedHashMap/*<ZipShort, ZipExtraField>*/ extraFields = null;\nprivate String name = null;\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getInternalAttributes()I",
                                    "method_body": "public int getInternalAttributes() {\nreturn internalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExternalAttributes()J",
                                    "method_body": "public long getExternalAttributes() {\nreturn externalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields() {\nif (extraFields == null) {\nreturn new ZipExtraField[0];\nZipExtraField[] result = new ZipExtraField[extraFields.size()];\nreturn (ZipExtraField[]) extraFields.values().toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
                                    "method_body": "public byte[] getLocalFileDataExtra() {\nbyte[] extra = getExtra();\nreturn extra != null ? extra : new byte[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getCentralDirectoryExtra()[B",
                                    "method_body": "public byte[] getCentralDirectoryExtra() {\nreturn ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes(I)[B",
                                    "method_body": "public static byte[] getBytes(int value) {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(J)[B",
                                    "method_body": "public static byte[] toDosTime(long t) {\nCalendar c = Calendar.getInstance();\nc.setTimeInMillis(t);\nint year = c.get(Calendar.YEAR);\nif (year < 1980) {\nint month = c.get(Calendar.MONTH) + 1;\nlong value =  ((year - 1980) << 25)\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:adjustToLong(I)J",
                                    "method_body": "public static long adjustToLong(int i) {\nif (i < 0) {\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\nimplementations = new HashMap();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class c) {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeCentralDirectoryData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getCentralDirectoryLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\nbyte[] local = data[i].getCentralDirectoryData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\npublic JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<init>(Ljava/lang/String;)V",
                                    "method_body": "private UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
                                    "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS =\npublic static final UnicodeExtraFieldPolicy NEVER =\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nprivate UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\nthrows IOException {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = new RandomAccessFile(f, \"r\");\nboolean success = false;\nMap entriesWithoutEFS = populateFromCentralDirectory();\nif (!success) {\narchive.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
                                    "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map populateFromCentralDirectory()\nHashMap noEFS = new HashMap();\npositionAtCentralDirectory();\nbyte[] cfh = new byte[CFH_LEN];\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nfinal long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\nif (sig != cfhSig && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nboolean found = false;\nlong off = archive.length() - MIN_EOCD_SIZE;\nlong stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE);\nif (off >= 0) {\narchive.seek(off);\nbyte[] sig = ZipArchiveOutputStream.EOCD_SIG;\nint curr = archive.read();\nwhile (off >= stopSearching && curr != -1) {\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\nif (!found) {\narchive.seek(off + CFD_LOCATOR_OFFSET);\nbyte[] cfdOffset = new byte[WORD];\narchive.readFully(cfdOffset);\narchive.seek(ZipLong.getValue(cfdOffset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:startsWithLocalFileHeader()Z",
                                    "method_body": "private boolean startsWithLocalFileHeader() throws IOException {\narchive.seek(0);\nfinal byte[] start = new byte[WORD];\narchive.readFully(start);\nfor (int i = 0; i < start.length; i++) {\nif (start[i] != ZipArchiveOutputStream.LFH_SIG[i]) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setEncoding(Ljava/lang/String;)V",
                                    "method_body": "public void setEncoding(final String encoding) {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nuseEFS &= ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setUseLanguageEncodingFlag(Z)V",
                                    "method_body": "public void setUseLanguageEncodingFlag(boolean b) {\nuseEFS = b && ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setCreateUnicodeExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveOutputStream$UnicodeExtraFieldPolicy;)V",
                                    "method_body": "public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b) {\ncreateUnicodeExtraFields = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int offset, int length) throws IOException {\nif (entry.getMethod() == DEFLATED) {\nif (length > 0) {\nif (!def.finished()) {\nif (length <= DEFLATER_BLOCK_SIZE) {\ndef.setInput(b, offset, length);\ndeflateUntilInputIsNeeded();\ncrc.update(b, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflateUntilInputIsNeeded()V",
                                    "method_body": "private void deflateUntilInputIsNeeded() throws IOException {\nwhile (!def.needsInput()) {\ndeflate();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:addExtraField(Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void addExtraField(ZipExtraField ze) {\nif (extraFields == null) {\nextraFields = new LinkedHashMap();\nextraFields.put(ze.getHeaderId(), ze);\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "protected AbstractUnicodeExtraField(String text, byte[] bytes, int off,\nint len) {\nCRC32 crc32 = new CRC32();\ncrc32.update(bytes, off, len);\nnameCRC32 = crc32.getValue();\nunicodeName = text.getBytes(\"UTF-8\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:assembleData()V",
                                    "method_body": "private void assembleData() {\nif (unicodeName == null) {\ndata = new byte[5 + unicodeName.length];\ndata[0] = 0x01;\nSystem.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4);\nSystem.arraycopy(unicodeName, 0, data, 5, unicodeName.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryData()[B",
                                    "method_body": "public byte[] getCentralDirectoryData() {\nif (data == null) {\nreturn data;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getCentralDirectoryLength() {\nif (data == null) {\nassembleData();\nreturn new ZipShort(data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn getCentralDirectoryData();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn getCentralDirectoryLength();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "public UnicodePathExtraField(String text, byte[] bytes, int off, int len) {\nsuper(text, bytes, off, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:appendSurrogate(Ljava/nio/ByteBuffer;C)V",
                                    "method_body": "static void appendSurrogate(ByteBuffer bb, char c) {\nbb.put((byte) '%');\nbb.put((byte) 'U');\nbb.put(HEX_DIGITS[(c >> 12)&0x0f]);\nbb.put(HEX_DIGITS[(c >> 8)&0x0f]);\nbb.put(HEX_DIGITS[(c >> 4)&0x0f]);\nbb.put(HEX_DIGITS[c & 0x0f]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:getEncoding()Lorg/apache/commons/compress/archivers/zip/Simple8BitZipEncoding;",
                                    "method_body": "public synchronized Simple8BitZipEncoding getEncoding() {\nif (this.encoding == null) {\nthis.encoding = new Simple8BitZipEncoding(this.highChars);\nreturn this.encoding;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding:<init>([C)V",
                                    "method_body": "public Simple8BitZipEncoding(char[] highChars) {\nthis.highChars = (char[]) highChars.clone();\nList temp = new ArrayList(this.highChars.length);\nbyte code = 127;\nfor (int i = 0; i < this.highChars.length; ++i) {\ntemp.add(new Simple8BitChar(++code, this.highChars[i]));\nCollections.sort(temp);\nthis.reverseMapping = Collections.unmodifiableList(temp);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding:canEncodeChar(C)Z",
                                    "method_body": "public boolean canEncodeChar(char c) {\nif (c >= 0 && c < 128) {\nreturn true;\nSimple8BitChar r = this.encodeHighChar(c);\nreturn r != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding:pushEncodedChar(Ljava/nio/ByteBuffer;C)Z",
                                    "method_body": "public boolean pushEncodedChar(ByteBuffer bb, char c) {\nif (c >= 0 && c < 128) {\nbb.put((byte) c);\nreturn true;\nSimple8BitChar r = this.encodeHighChar(c);\nif (r == null) {\nreturn false;\nbb.put(r.code);\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding:encodeHighChar(C)Lorg/apache/commons/compress/archivers/zip/Simple8BitZipEncoding$Simple8BitChar;",
                                    "method_body": "private Simple8BitChar encodeHighChar(char c) {\nint i0 = 0;\nint i1 = this.reverseMapping.size();\nwhile (i1 > i0) {\nint i = i0 + (i1 - i0) / 2;\nSimple8BitChar m = (Simple8BitChar) this.reverseMapping.get(i);\nif (m.unicode == c) {\nreturn m;\nif (m.unicode < c) {\ni0 = i + 1;\ni1 = i;\n}\nif (i0 >= this.reverseMapping.size()) {\nSimple8BitChar r = (Simple8BitChar) this.reverseMapping.get(i0);\nif (r.unicode != c) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding:canEncode(Ljava/lang/String;)Z",
                                    "method_body": "public boolean canEncode(String name) {\nfor (int i=0;i<name.length();++i) {\nchar c = name.charAt(i);\nif (!this.canEncodeChar(c)) {\nreturn false;\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(String name) {\nByteBuffer out = ByteBuffer.allocate(name.length()\nfor (int i=0;i<name.length();++i) {\nchar c = name.charAt(i);\nif (out.remaining() < 6) {\nif (!this.pushEncodedChar(out,c)) {\nZipEncodingHelper.appendSurrogate(out,c);\nout.limit(out.position());\nout.rewind();\nreturn out;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding$Simple8BitChar:<init>(BC)V",
                                    "method_body": "Simple8BitChar(byte code, char unicode) {\nthis.code = code;\nthis.unicode = unicode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding$Simple8BitChar:compareTo(Ljava/lang/Object;)I",
                                    "method_body": "public int compareTo(Object o) {\nSimple8BitChar a = (Simple8BitChar) o;\nreturn this.unicode - a.unicode;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testUtf8FileRoundtripImplicitUnicodeExtra",
                            "test_body": "63: public void testUtf8FileRoundtripImplicitUnicodeExtra()\n64: throws IOException {\n65: testFileRoundtrip(UTF_8, true, false);\n66: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipArchiveOutputStream(File file) throws IOException {\nOutputStream o = null;\nRandomAccessFile _raf = null;\n_raf = new RandomAccessFile(file, \"rw\");\n_raf.setLength(0);\n}\nout = o;\nraf = _raf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes();\nstatic final byte[] DD_SIG = ZipLong.getBytes(0X08074B50L);\nstatic final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes();\nstatic final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif(entry != null) {\ncdOffset = written;\nfor (Iterator i = entries.iterator(); i.hasNext(); ) {\nwriteCentralFileHeader((ZipArchiveEntry) i.next());\ncdLength = written - cdOffset;\nwriteCentralDirectoryEnd();\noffsets.clear();\nentries.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (entry == null) {\nreturn;\nlong realCrc = crc.getValue();\ncrc.reset();\nif (entry.getMethod() == DEFLATED) {\ndef.finish();\nwhile (!def.finished()) {\ndeflate();\nentry.setSize(ZipUtil.adjustToLong(def.getTotalIn()));\nentry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut()));\nentry.setCrc(realCrc);\ndef.reset();\nwritten += entry.getCompressedSize();\nif (raf != null) {\nlong save = raf.getFilePointer();\nraf.seek(localDataStart);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\nraf.seek(save);\nwriteDataDescriptor(entry);\nentry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\ncloseArchiveEntry();\nentry = ((ZipArchiveEntry) archiveEntry);\nentries.add(entry);\nif (entry.getMethod() == -1) { // not specified\nentry.setMethod(method);\nif (entry.getTime() == -1) { // not specified\nentry.setTime(System.currentTimeMillis());\nif (entry.getMethod() == STORED && raf == null) {\nif (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\nwriteLocalFileHeader(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nfinish();\nif (raf != null) {\nraf.close();\nif (out != null) {\nout.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflate()V",
                                    "method_body": "protected final void deflate() throws IOException {\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\nboolean encodable = zipEncoding.canEncode(ze.getName());\nif (!encodable && fallbackToUTF8) {\nentryEncoding = zipEncoding;\nByteBuffer name = entryEncoding.encode(ze.getName());\nif (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\nze.addExtraField(new UnicodePathExtraField(ze.getName(),\nString comm = ze.getComment();\nif (comm != null && !\"\".equals(comm)) {\noffsets.put(ze, ZipLong.getBytes(written));\nwriteOut(LFH_SIG);\nwritten += WORD;\nfinal int zipMethod = ze.getMethod();\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\nwritten += WORD;\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\nlocalDataStart = written;\nif (zipMethod == DEFLATED || raf != null) {\nwriteOut(LZERO);\nwriteOut(LZERO);\nwriteOut(LZERO);\nwritten += 12;\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\nbyte[] extra = ze.getLocalFileDataExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\nwriteOut(extra);\nwritten += extra.length;\ndataStart = written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\nwriteOut(CFH_SIG);\nwritten += WORD;\nwriteOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\nwritten += SHORT;\nfinal int zipMethod = ze.getMethod();\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\nwritten += WORD;\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getCompressedSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\nwritten += 12;\nif (!encodable && fallbackToUTF8) {\nentryEncoding = zipEncoding;\nByteBuffer name = entryEncoding.encode(ze.getName());\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\nbyte[] extra = ze.getCentralDirectoryExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\nString comm = ze.getComment();\nif (comm == null) {\ncomm = \"\";\nByteBuffer commentB = entryEncoding.encode(comm);\nwriteOut(ZipShort.getBytes(commentB.limit()));\nwritten += SHORT;\nwriteOut(ZERO);\nwritten += SHORT;\nwriteOut(ZipShort.getBytes(ze.getInternalAttributes()));\nwritten += SHORT;\nwriteOut(ZipLong.getBytes(ze.getExternalAttributes()));\nwritten += WORD;\nwriteOut((byte[]) offsets.get(ze));\nwritten += WORD;\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\nwriteOut(extra);\nwritten += extra.length;\nwriteOut(commentB.array(), commentB.arrayOffset(), commentB.limit());\nwritten += commentB.limit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryEnd()V",
                                    "method_body": "protected void writeCentralDirectoryEnd() throws IOException {\nwriteOut(EOCD_SIG);\nwriteOut(ZERO);\nwriteOut(ZERO);\nbyte[] num = ZipShort.getBytes(entries.size());\nwriteOut(num);\nwriteOut(num);\nwriteOut(ZipLong.getBytes(cdLength));\nwriteOut(ZipLong.getBytes(cdOffset));\nByteBuffer data = this.zipEncoding.encode(comment);\nwriteOut(ZipShort.getBytes(data.limit()));\nwriteOut(data.array(), data.arrayOffset(), data.limit());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([B)V",
                                    "method_body": "protected final void writeOut(byte[] data) throws IOException {\nwriteOut(data, 0, data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([BII)V",
                                    "method_body": "protected final void writeOut(byte[] data, int offset, int length)\nif (raf != null) {\nraf.write(data, offset, length);\nout.write(data, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeVersionNeededToExtractAndGeneralPurposeBits(IZ)V",
                                    "method_body": "private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\nint versionNeededToExtract = 10;\nint generalPurposeFlag = (useEFS || utfFallback) ? EFS_FLAG : 0;\nif (zipMethod == DEFLATED && raf == null) {\nversionNeededToExtract =  20;\ngeneralPurposeFlag |= 8;\nwriteOut(ZipShort.getBytes(versionNeededToExtract));\nwriteOut(ZipShort.getBytes(generalPurposeFlag));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map simpleEncodings;\nsimpleEncodings = new HashMap();\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\nif (name == null) {\nSimpleEncodingHolder h =\nif (h!=null) {\nreturn h.getEncoding();\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\nreturn UTF8.equalsIgnoreCase(encoding)\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:canEncode(Ljava/lang/String;)Z",
                                    "method_body": "public boolean canEncode(String name) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(String name) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn ByteBuffer.wrap(name.getBytes(this.charset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "public static final int PLATFORM_UNIX = 3;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate LinkedHashMap/*<ZipShort, ZipExtraField>*/ extraFields = null;\nprivate String name = null;\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getInternalAttributes()I",
                                    "method_body": "public int getInternalAttributes() {\nreturn internalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExternalAttributes()J",
                                    "method_body": "public long getExternalAttributes() {\nreturn externalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
                                    "method_body": "public byte[] getLocalFileDataExtra() {\nbyte[] extra = getExtra();\nreturn extra != null ? extra : new byte[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getCentralDirectoryExtra()[B",
                                    "method_body": "public byte[] getCentralDirectoryExtra() {\nreturn ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes(I)[B",
                                    "method_body": "public static byte[] getBytes(int value) {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(J)[B",
                                    "method_body": "public static byte[] toDosTime(long t) {\nCalendar c = Calendar.getInstance();\nc.setTimeInMillis(t);\nint year = c.get(Calendar.YEAR);\nif (year < 1980) {\nint month = c.get(Calendar.MONTH) + 1;\nlong value =  ((year - 1980) << 25)\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:adjustToLong(I)J",
                                    "method_body": "public static long adjustToLong(int i) {\nif (i < 0) {\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\nimplementations = new HashMap();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class c) {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeCentralDirectoryData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getCentralDirectoryLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\nbyte[] local = data[i].getCentralDirectoryData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\npublic JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<init>(Ljava/lang/String;)V",
                                    "method_body": "private UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
                                    "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS =\npublic static final UnicodeExtraFieldPolicy NEVER =\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nprivate UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\nthrows IOException {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = new RandomAccessFile(f, \"r\");\nboolean success = false;\nMap entriesWithoutEFS = populateFromCentralDirectory();\nif (!success) {\narchive.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
                                    "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map populateFromCentralDirectory()\nHashMap noEFS = new HashMap();\npositionAtCentralDirectory();\nbyte[] cfh = new byte[CFH_LEN];\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nfinal long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\nif (sig != cfhSig && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nboolean found = false;\nlong off = archive.length() - MIN_EOCD_SIZE;\nlong stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE);\nif (off >= 0) {\narchive.seek(off);\nbyte[] sig = ZipArchiveOutputStream.EOCD_SIG;\nint curr = archive.read();\nwhile (off >= stopSearching && curr != -1) {\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\nif (!found) {\narchive.seek(off + CFD_LOCATOR_OFFSET);\nbyte[] cfdOffset = new byte[WORD];\narchive.readFully(cfdOffset);\narchive.seek(ZipLong.getValue(cfdOffset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:startsWithLocalFileHeader()Z",
                                    "method_body": "private boolean startsWithLocalFileHeader() throws IOException {\narchive.seek(0);\nfinal byte[] start = new byte[WORD];\narchive.readFully(start);\nfor (int i = 0; i < start.length; i++) {\nif (start[i] != ZipArchiveOutputStream.LFH_SIG[i]) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setEncoding(Ljava/lang/String;)V",
                                    "method_body": "public void setEncoding(final String encoding) {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nuseEFS &= ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setUseLanguageEncodingFlag(Z)V",
                                    "method_body": "public void setUseLanguageEncodingFlag(boolean b) {\nuseEFS = b && ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setCreateUnicodeExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveOutputStream$UnicodeExtraFieldPolicy;)V",
                                    "method_body": "public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b) {\ncreateUnicodeExtraFields = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int offset, int length) throws IOException {\nif (entry.getMethod() == DEFLATED) {\nif (length > 0) {\nif (!def.finished()) {\nif (length <= DEFLATER_BLOCK_SIZE) {\ndef.setInput(b, offset, length);\ndeflateUntilInputIsNeeded();\ncrc.update(b, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflateUntilInputIsNeeded()V",
                                    "method_body": "private void deflateUntilInputIsNeeded() throws IOException {\nwhile (!def.needsInput()) {\ndeflate();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:addExtraField(Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void addExtraField(ZipExtraField ze) {\nif (extraFields == null) {\nextraFields = new LinkedHashMap();\nextraFields.put(ze.getHeaderId(), ze);\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "protected AbstractUnicodeExtraField(String text, byte[] bytes, int off,\nint len) {\nCRC32 crc32 = new CRC32();\ncrc32.update(bytes, off, len);\nnameCRC32 = crc32.getValue();\nunicodeName = text.getBytes(\"UTF-8\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:assembleData()V",
                                    "method_body": "private void assembleData() {\nif (unicodeName == null) {\ndata = new byte[5 + unicodeName.length];\ndata[0] = 0x01;\nSystem.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4);\nSystem.arraycopy(unicodeName, 0, data, 5, unicodeName.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryData()[B",
                                    "method_body": "public byte[] getCentralDirectoryData() {\nif (data == null) {\nreturn data;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getCentralDirectoryLength() {\nif (data == null) {\nassembleData();\nreturn new ZipShort(data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn getCentralDirectoryData();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn getCentralDirectoryLength();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "public UnicodePathExtraField(String text, byte[] bytes, int off, int len) {\nsuper(text, bytes, off, len);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testUtf8FileRoundtripExplicitUnicodeExtra",
                            "test_body": "43: public void testUtf8FileRoundtripExplicitUnicodeExtra()\n44: throws IOException {\n45: testFileRoundtrip(UTF_8, true, true);\n46: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipArchiveOutputStream(File file) throws IOException {\nOutputStream o = null;\nRandomAccessFile _raf = null;\n_raf = new RandomAccessFile(file, \"rw\");\n_raf.setLength(0);\n}\nout = o;\nraf = _raf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes();\nstatic final byte[] DD_SIG = ZipLong.getBytes(0X08074B50L);\nstatic final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes();\nstatic final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif(entry != null) {\ncdOffset = written;\nfor (Iterator i = entries.iterator(); i.hasNext(); ) {\nwriteCentralFileHeader((ZipArchiveEntry) i.next());\ncdLength = written - cdOffset;\nwriteCentralDirectoryEnd();\noffsets.clear();\nentries.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (entry == null) {\nreturn;\nlong realCrc = crc.getValue();\ncrc.reset();\nif (entry.getMethod() == DEFLATED) {\ndef.finish();\nwhile (!def.finished()) {\ndeflate();\nentry.setSize(ZipUtil.adjustToLong(def.getTotalIn()));\nentry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut()));\nentry.setCrc(realCrc);\ndef.reset();\nwritten += entry.getCompressedSize();\nif (raf != null) {\nlong save = raf.getFilePointer();\nraf.seek(localDataStart);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\nraf.seek(save);\nwriteDataDescriptor(entry);\nentry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\ncloseArchiveEntry();\nentry = ((ZipArchiveEntry) archiveEntry);\nentries.add(entry);\nif (entry.getMethod() == -1) { // not specified\nentry.setMethod(method);\nif (entry.getTime() == -1) { // not specified\nentry.setTime(System.currentTimeMillis());\nif (entry.getMethod() == STORED && raf == null) {\nif (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\nwriteLocalFileHeader(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nfinish();\nif (raf != null) {\nraf.close();\nif (out != null) {\nout.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflate()V",
                                    "method_body": "protected final void deflate() throws IOException {\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\nboolean encodable = zipEncoding.canEncode(ze.getName());\nif (!encodable && fallbackToUTF8) {\nentryEncoding = zipEncoding;\nByteBuffer name = entryEncoding.encode(ze.getName());\nif (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\nze.addExtraField(new UnicodePathExtraField(ze.getName(),\nString comm = ze.getComment();\nif (comm != null && !\"\".equals(comm)) {\noffsets.put(ze, ZipLong.getBytes(written));\nwriteOut(LFH_SIG);\nwritten += WORD;\nfinal int zipMethod = ze.getMethod();\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\nwritten += WORD;\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\nlocalDataStart = written;\nif (zipMethod == DEFLATED || raf != null) {\nwriteOut(LZERO);\nwriteOut(LZERO);\nwriteOut(LZERO);\nwritten += 12;\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\nbyte[] extra = ze.getLocalFileDataExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\nwriteOut(extra);\nwritten += extra.length;\ndataStart = written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\nwriteOut(CFH_SIG);\nwritten += WORD;\nwriteOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\nwritten += SHORT;\nfinal int zipMethod = ze.getMethod();\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\nwritten += WORD;\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getCompressedSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\nwritten += 12;\nif (!encodable && fallbackToUTF8) {\nentryEncoding = zipEncoding;\nByteBuffer name = entryEncoding.encode(ze.getName());\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\nbyte[] extra = ze.getCentralDirectoryExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\nString comm = ze.getComment();\nif (comm == null) {\ncomm = \"\";\nByteBuffer commentB = entryEncoding.encode(comm);\nwriteOut(ZipShort.getBytes(commentB.limit()));\nwritten += SHORT;\nwriteOut(ZERO);\nwritten += SHORT;\nwriteOut(ZipShort.getBytes(ze.getInternalAttributes()));\nwritten += SHORT;\nwriteOut(ZipLong.getBytes(ze.getExternalAttributes()));\nwritten += WORD;\nwriteOut((byte[]) offsets.get(ze));\nwritten += WORD;\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\nwriteOut(extra);\nwritten += extra.length;\nwriteOut(commentB.array(), commentB.arrayOffset(), commentB.limit());\nwritten += commentB.limit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryEnd()V",
                                    "method_body": "protected void writeCentralDirectoryEnd() throws IOException {\nwriteOut(EOCD_SIG);\nwriteOut(ZERO);\nwriteOut(ZERO);\nbyte[] num = ZipShort.getBytes(entries.size());\nwriteOut(num);\nwriteOut(num);\nwriteOut(ZipLong.getBytes(cdLength));\nwriteOut(ZipLong.getBytes(cdOffset));\nByteBuffer data = this.zipEncoding.encode(comment);\nwriteOut(ZipShort.getBytes(data.limit()));\nwriteOut(data.array(), data.arrayOffset(), data.limit());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([B)V",
                                    "method_body": "protected final void writeOut(byte[] data) throws IOException {\nwriteOut(data, 0, data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([BII)V",
                                    "method_body": "protected final void writeOut(byte[] data, int offset, int length)\nif (raf != null) {\nraf.write(data, offset, length);\nout.write(data, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeVersionNeededToExtractAndGeneralPurposeBits(IZ)V",
                                    "method_body": "private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\nint versionNeededToExtract = 10;\nint generalPurposeFlag = (useEFS || utfFallback) ? EFS_FLAG : 0;\nif (zipMethod == DEFLATED && raf == null) {\nversionNeededToExtract =  20;\ngeneralPurposeFlag |= 8;\nwriteOut(ZipShort.getBytes(versionNeededToExtract));\nwriteOut(ZipShort.getBytes(generalPurposeFlag));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map simpleEncodings;\nsimpleEncodings = new HashMap();\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\nif (name == null) {\nSimpleEncodingHolder h =\nif (h!=null) {\nreturn h.getEncoding();\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\nreturn UTF8.equalsIgnoreCase(encoding)\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:canEncode(Ljava/lang/String;)Z",
                                    "method_body": "public boolean canEncode(String name) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(String name) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn ByteBuffer.wrap(name.getBytes(this.charset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "public static final int PLATFORM_UNIX = 3;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate LinkedHashMap/*<ZipShort, ZipExtraField>*/ extraFields = null;\nprivate String name = null;\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getInternalAttributes()I",
                                    "method_body": "public int getInternalAttributes() {\nreturn internalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExternalAttributes()J",
                                    "method_body": "public long getExternalAttributes() {\nreturn externalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields() {\nif (extraFields == null) {\nreturn new ZipExtraField[0];\nZipExtraField[] result = new ZipExtraField[extraFields.size()];\nreturn (ZipExtraField[]) extraFields.values().toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
                                    "method_body": "public byte[] getLocalFileDataExtra() {\nbyte[] extra = getExtra();\nreturn extra != null ? extra : new byte[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getCentralDirectoryExtra()[B",
                                    "method_body": "public byte[] getCentralDirectoryExtra() {\nreturn ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes(I)[B",
                                    "method_body": "public static byte[] getBytes(int value) {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(J)[B",
                                    "method_body": "public static byte[] toDosTime(long t) {\nCalendar c = Calendar.getInstance();\nc.setTimeInMillis(t);\nint year = c.get(Calendar.YEAR);\nif (year < 1980) {\nint month = c.get(Calendar.MONTH) + 1;\nlong value =  ((year - 1980) << 25)\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:adjustToLong(I)J",
                                    "method_body": "public static long adjustToLong(int i) {\nif (i < 0) {\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\nimplementations = new HashMap();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class c) {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeCentralDirectoryData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getCentralDirectoryLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\nbyte[] local = data[i].getCentralDirectoryData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\npublic JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<init>(Ljava/lang/String;)V",
                                    "method_body": "private UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
                                    "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS =\npublic static final UnicodeExtraFieldPolicy NEVER =\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nprivate UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\nthrows IOException {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = new RandomAccessFile(f, \"r\");\nboolean success = false;\nMap entriesWithoutEFS = populateFromCentralDirectory();\nif (!success) {\narchive.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
                                    "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map populateFromCentralDirectory()\nHashMap noEFS = new HashMap();\npositionAtCentralDirectory();\nbyte[] cfh = new byte[CFH_LEN];\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nfinal long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\nif (sig != cfhSig && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nboolean found = false;\nlong off = archive.length() - MIN_EOCD_SIZE;\nlong stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE);\nif (off >= 0) {\narchive.seek(off);\nbyte[] sig = ZipArchiveOutputStream.EOCD_SIG;\nint curr = archive.read();\nwhile (off >= stopSearching && curr != -1) {\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\nif (!found) {\narchive.seek(off + CFD_LOCATOR_OFFSET);\nbyte[] cfdOffset = new byte[WORD];\narchive.readFully(cfdOffset);\narchive.seek(ZipLong.getValue(cfdOffset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:startsWithLocalFileHeader()Z",
                                    "method_body": "private boolean startsWithLocalFileHeader() throws IOException {\narchive.seek(0);\nfinal byte[] start = new byte[WORD];\narchive.readFully(start);\nfor (int i = 0; i < start.length; i++) {\nif (start[i] != ZipArchiveOutputStream.LFH_SIG[i]) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setEncoding(Ljava/lang/String;)V",
                                    "method_body": "public void setEncoding(final String encoding) {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nuseEFS &= ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setUseLanguageEncodingFlag(Z)V",
                                    "method_body": "public void setUseLanguageEncodingFlag(boolean b) {\nuseEFS = b && ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setCreateUnicodeExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveOutputStream$UnicodeExtraFieldPolicy;)V",
                                    "method_body": "public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b) {\ncreateUnicodeExtraFields = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int offset, int length) throws IOException {\nif (entry.getMethod() == DEFLATED) {\nif (length > 0) {\nif (!def.finished()) {\nif (length <= DEFLATER_BLOCK_SIZE) {\ndef.setInput(b, offset, length);\ndeflateUntilInputIsNeeded();\ncrc.update(b, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflateUntilInputIsNeeded()V",
                                    "method_body": "private void deflateUntilInputIsNeeded() throws IOException {\nwhile (!def.needsInput()) {\ndeflate();\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testUtf8FileRoundtripNoEFSImplicitUnicodeExtra",
                            "test_body": "68: public void testUtf8FileRoundtripNoEFSImplicitUnicodeExtra()\n69: throws IOException {\n70: testFileRoundtrip(UTF_8, false, false);\n71: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipArchiveOutputStream(File file) throws IOException {\nOutputStream o = null;\nRandomAccessFile _raf = null;\n_raf = new RandomAccessFile(file, \"rw\");\n_raf.setLength(0);\n}\nout = o;\nraf = _raf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes();\nstatic final byte[] DD_SIG = ZipLong.getBytes(0X08074B50L);\nstatic final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes();\nstatic final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif(entry != null) {\ncdOffset = written;\nfor (Iterator i = entries.iterator(); i.hasNext(); ) {\nwriteCentralFileHeader((ZipArchiveEntry) i.next());\ncdLength = written - cdOffset;\nwriteCentralDirectoryEnd();\noffsets.clear();\nentries.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (entry == null) {\nreturn;\nlong realCrc = crc.getValue();\ncrc.reset();\nif (entry.getMethod() == DEFLATED) {\ndef.finish();\nwhile (!def.finished()) {\ndeflate();\nentry.setSize(ZipUtil.adjustToLong(def.getTotalIn()));\nentry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut()));\nentry.setCrc(realCrc);\ndef.reset();\nwritten += entry.getCompressedSize();\nif (raf != null) {\nlong save = raf.getFilePointer();\nraf.seek(localDataStart);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\nraf.seek(save);\nwriteDataDescriptor(entry);\nentry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\ncloseArchiveEntry();\nentry = ((ZipArchiveEntry) archiveEntry);\nentries.add(entry);\nif (entry.getMethod() == -1) { // not specified\nentry.setMethod(method);\nif (entry.getTime() == -1) { // not specified\nentry.setTime(System.currentTimeMillis());\nif (entry.getMethod() == STORED && raf == null) {\nif (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\nwriteLocalFileHeader(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nfinish();\nif (raf != null) {\nraf.close();\nif (out != null) {\nout.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflate()V",
                                    "method_body": "protected final void deflate() throws IOException {\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\nboolean encodable = zipEncoding.canEncode(ze.getName());\nif (!encodable && fallbackToUTF8) {\nentryEncoding = zipEncoding;\nByteBuffer name = entryEncoding.encode(ze.getName());\nif (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\nze.addExtraField(new UnicodePathExtraField(ze.getName(),\nString comm = ze.getComment();\nif (comm != null && !\"\".equals(comm)) {\noffsets.put(ze, ZipLong.getBytes(written));\nwriteOut(LFH_SIG);\nwritten += WORD;\nfinal int zipMethod = ze.getMethod();\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\nwritten += WORD;\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\nlocalDataStart = written;\nif (zipMethod == DEFLATED || raf != null) {\nwriteOut(LZERO);\nwriteOut(LZERO);\nwriteOut(LZERO);\nwritten += 12;\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\nbyte[] extra = ze.getLocalFileDataExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\nwriteOut(extra);\nwritten += extra.length;\ndataStart = written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\nwriteOut(CFH_SIG);\nwritten += WORD;\nwriteOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\nwritten += SHORT;\nfinal int zipMethod = ze.getMethod();\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\nwritten += WORD;\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getCompressedSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\nwritten += 12;\nif (!encodable && fallbackToUTF8) {\nentryEncoding = zipEncoding;\nByteBuffer name = entryEncoding.encode(ze.getName());\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\nbyte[] extra = ze.getCentralDirectoryExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\nString comm = ze.getComment();\nif (comm == null) {\ncomm = \"\";\nByteBuffer commentB = entryEncoding.encode(comm);\nwriteOut(ZipShort.getBytes(commentB.limit()));\nwritten += SHORT;\nwriteOut(ZERO);\nwritten += SHORT;\nwriteOut(ZipShort.getBytes(ze.getInternalAttributes()));\nwritten += SHORT;\nwriteOut(ZipLong.getBytes(ze.getExternalAttributes()));\nwritten += WORD;\nwriteOut((byte[]) offsets.get(ze));\nwritten += WORD;\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\nwriteOut(extra);\nwritten += extra.length;\nwriteOut(commentB.array(), commentB.arrayOffset(), commentB.limit());\nwritten += commentB.limit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryEnd()V",
                                    "method_body": "protected void writeCentralDirectoryEnd() throws IOException {\nwriteOut(EOCD_SIG);\nwriteOut(ZERO);\nwriteOut(ZERO);\nbyte[] num = ZipShort.getBytes(entries.size());\nwriteOut(num);\nwriteOut(num);\nwriteOut(ZipLong.getBytes(cdLength));\nwriteOut(ZipLong.getBytes(cdOffset));\nByteBuffer data = this.zipEncoding.encode(comment);\nwriteOut(ZipShort.getBytes(data.limit()));\nwriteOut(data.array(), data.arrayOffset(), data.limit());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([B)V",
                                    "method_body": "protected final void writeOut(byte[] data) throws IOException {\nwriteOut(data, 0, data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([BII)V",
                                    "method_body": "protected final void writeOut(byte[] data, int offset, int length)\nif (raf != null) {\nraf.write(data, offset, length);\nout.write(data, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeVersionNeededToExtractAndGeneralPurposeBits(IZ)V",
                                    "method_body": "private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\nint versionNeededToExtract = 10;\nint generalPurposeFlag = (useEFS || utfFallback) ? EFS_FLAG : 0;\nif (zipMethod == DEFLATED && raf == null) {\nversionNeededToExtract =  20;\ngeneralPurposeFlag |= 8;\nwriteOut(ZipShort.getBytes(versionNeededToExtract));\nwriteOut(ZipShort.getBytes(generalPurposeFlag));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map simpleEncodings;\nsimpleEncodings = new HashMap();\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\nif (name == null) {\nSimpleEncodingHolder h =\nif (h!=null) {\nreturn h.getEncoding();\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\nreturn UTF8.equalsIgnoreCase(encoding)\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:canEncode(Ljava/lang/String;)Z",
                                    "method_body": "public boolean canEncode(String name) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(String name) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn ByteBuffer.wrap(name.getBytes(this.charset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "public static final int PLATFORM_UNIX = 3;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate LinkedHashMap/*<ZipShort, ZipExtraField>*/ extraFields = null;\nprivate String name = null;\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getInternalAttributes()I",
                                    "method_body": "public int getInternalAttributes() {\nreturn internalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExternalAttributes()J",
                                    "method_body": "public long getExternalAttributes() {\nreturn externalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
                                    "method_body": "public byte[] getLocalFileDataExtra() {\nbyte[] extra = getExtra();\nreturn extra != null ? extra : new byte[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getCentralDirectoryExtra()[B",
                                    "method_body": "public byte[] getCentralDirectoryExtra() {\nreturn ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes(I)[B",
                                    "method_body": "public static byte[] getBytes(int value) {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(J)[B",
                                    "method_body": "public static byte[] toDosTime(long t) {\nCalendar c = Calendar.getInstance();\nc.setTimeInMillis(t);\nint year = c.get(Calendar.YEAR);\nif (year < 1980) {\nint month = c.get(Calendar.MONTH) + 1;\nlong value =  ((year - 1980) << 25)\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:adjustToLong(I)J",
                                    "method_body": "public static long adjustToLong(int i) {\nif (i < 0) {\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\nimplementations = new HashMap();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class c) {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeCentralDirectoryData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getCentralDirectoryLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\nbyte[] local = data[i].getCentralDirectoryData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\npublic JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<init>(Ljava/lang/String;)V",
                                    "method_body": "private UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
                                    "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS =\npublic static final UnicodeExtraFieldPolicy NEVER =\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nprivate UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\nthrows IOException {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = new RandomAccessFile(f, \"r\");\nboolean success = false;\nMap entriesWithoutEFS = populateFromCentralDirectory();\nif (!success) {\narchive.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
                                    "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map populateFromCentralDirectory()\nHashMap noEFS = new HashMap();\npositionAtCentralDirectory();\nbyte[] cfh = new byte[CFH_LEN];\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nfinal long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\nif (sig != cfhSig && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nboolean found = false;\nlong off = archive.length() - MIN_EOCD_SIZE;\nlong stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE);\nif (off >= 0) {\narchive.seek(off);\nbyte[] sig = ZipArchiveOutputStream.EOCD_SIG;\nint curr = archive.read();\nwhile (off >= stopSearching && curr != -1) {\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\nif (!found) {\narchive.seek(off + CFD_LOCATOR_OFFSET);\nbyte[] cfdOffset = new byte[WORD];\narchive.readFully(cfdOffset);\narchive.seek(ZipLong.getValue(cfdOffset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:startsWithLocalFileHeader()Z",
                                    "method_body": "private boolean startsWithLocalFileHeader() throws IOException {\narchive.seek(0);\nfinal byte[] start = new byte[WORD];\narchive.readFully(start);\nfor (int i = 0; i < start.length; i++) {\nif (start[i] != ZipArchiveOutputStream.LFH_SIG[i]) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setEncoding(Ljava/lang/String;)V",
                                    "method_body": "public void setEncoding(final String encoding) {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nuseEFS &= ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setUseLanguageEncodingFlag(Z)V",
                                    "method_body": "public void setUseLanguageEncodingFlag(boolean b) {\nuseEFS = b && ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setCreateUnicodeExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveOutputStream$UnicodeExtraFieldPolicy;)V",
                                    "method_body": "public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b) {\ncreateUnicodeExtraFields = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int offset, int length) throws IOException {\nif (entry.getMethod() == DEFLATED) {\nif (length > 0) {\nif (!def.finished()) {\nif (length <= DEFLATER_BLOCK_SIZE) {\ndef.setInput(b, offset, length);\ndeflateUntilInputIsNeeded();\ncrc.update(b, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflateUntilInputIsNeeded()V",
                                    "method_body": "private void deflateUntilInputIsNeeded() throws IOException {\nwhile (!def.needsInput()) {\ndeflate();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:addExtraField(Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void addExtraField(ZipExtraField ze) {\nif (extraFields == null) {\nextraFields = new LinkedHashMap();\nextraFields.put(ze.getHeaderId(), ze);\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "protected AbstractUnicodeExtraField(String text, byte[] bytes, int off,\nint len) {\nCRC32 crc32 = new CRC32();\ncrc32.update(bytes, off, len);\nnameCRC32 = crc32.getValue();\nunicodeName = text.getBytes(\"UTF-8\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:assembleData()V",
                                    "method_body": "private void assembleData() {\nif (unicodeName == null) {\ndata = new byte[5 + unicodeName.length];\ndata[0] = 0x01;\nSystem.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4);\nSystem.arraycopy(unicodeName, 0, data, 5, unicodeName.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryData()[B",
                                    "method_body": "public byte[] getCentralDirectoryData() {\nif (data == null) {\nreturn data;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getCentralDirectoryLength() {\nif (data == null) {\nassembleData();\nreturn new ZipShort(data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn getCentralDirectoryData();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn getCentralDirectoryLength();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "public UnicodePathExtraField(String text, byte[] bytes, int off, int len) {\nsuper(text, bytes, off, len);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testASCIIFileRoundtripImplicitUnicodeExtra",
                            "test_body": "78: public void testASCIIFileRoundtripImplicitUnicodeExtra()\n79: throws IOException {\n80: testFileRoundtrip(US_ASCII, false, false);\n81: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipArchiveOutputStream(File file) throws IOException {\nOutputStream o = null;\nRandomAccessFile _raf = null;\n_raf = new RandomAccessFile(file, \"rw\");\n_raf.setLength(0);\n}\nout = o;\nraf = _raf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes();\nstatic final byte[] DD_SIG = ZipLong.getBytes(0X08074B50L);\nstatic final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes();\nstatic final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif(entry != null) {\ncdOffset = written;\nfor (Iterator i = entries.iterator(); i.hasNext(); ) {\nwriteCentralFileHeader((ZipArchiveEntry) i.next());\ncdLength = written - cdOffset;\nwriteCentralDirectoryEnd();\noffsets.clear();\nentries.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (entry == null) {\nreturn;\nlong realCrc = crc.getValue();\ncrc.reset();\nif (entry.getMethod() == DEFLATED) {\ndef.finish();\nwhile (!def.finished()) {\ndeflate();\nentry.setSize(ZipUtil.adjustToLong(def.getTotalIn()));\nentry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut()));\nentry.setCrc(realCrc);\ndef.reset();\nwritten += entry.getCompressedSize();\nif (raf != null) {\nlong save = raf.getFilePointer();\nraf.seek(localDataStart);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\nraf.seek(save);\nwriteDataDescriptor(entry);\nentry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\ncloseArchiveEntry();\nentry = ((ZipArchiveEntry) archiveEntry);\nentries.add(entry);\nif (entry.getMethod() == -1) { // not specified\nentry.setMethod(method);\nif (entry.getTime() == -1) { // not specified\nentry.setTime(System.currentTimeMillis());\nif (entry.getMethod() == STORED && raf == null) {\nif (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\nwriteLocalFileHeader(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nfinish();\nif (raf != null) {\nraf.close();\nif (out != null) {\nout.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflate()V",
                                    "method_body": "protected final void deflate() throws IOException {\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\nboolean encodable = zipEncoding.canEncode(ze.getName());\nif (!encodable && fallbackToUTF8) {\nentryEncoding = zipEncoding;\nByteBuffer name = entryEncoding.encode(ze.getName());\nif (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\nze.addExtraField(new UnicodePathExtraField(ze.getName(),\nString comm = ze.getComment();\nif (comm != null && !\"\".equals(comm)) {\noffsets.put(ze, ZipLong.getBytes(written));\nwriteOut(LFH_SIG);\nwritten += WORD;\nfinal int zipMethod = ze.getMethod();\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\nwritten += WORD;\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\nlocalDataStart = written;\nif (zipMethod == DEFLATED || raf != null) {\nwriteOut(LZERO);\nwriteOut(LZERO);\nwriteOut(LZERO);\nwritten += 12;\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\nbyte[] extra = ze.getLocalFileDataExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\nwriteOut(extra);\nwritten += extra.length;\ndataStart = written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\nwriteOut(CFH_SIG);\nwritten += WORD;\nwriteOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\nwritten += SHORT;\nfinal int zipMethod = ze.getMethod();\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\nwritten += WORD;\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getCompressedSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\nwritten += 12;\nif (!encodable && fallbackToUTF8) {\nentryEncoding = zipEncoding;\nByteBuffer name = entryEncoding.encode(ze.getName());\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\nbyte[] extra = ze.getCentralDirectoryExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\nString comm = ze.getComment();\nif (comm == null) {\ncomm = \"\";\nByteBuffer commentB = entryEncoding.encode(comm);\nwriteOut(ZipShort.getBytes(commentB.limit()));\nwritten += SHORT;\nwriteOut(ZERO);\nwritten += SHORT;\nwriteOut(ZipShort.getBytes(ze.getInternalAttributes()));\nwritten += SHORT;\nwriteOut(ZipLong.getBytes(ze.getExternalAttributes()));\nwritten += WORD;\nwriteOut((byte[]) offsets.get(ze));\nwritten += WORD;\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\nwriteOut(extra);\nwritten += extra.length;\nwriteOut(commentB.array(), commentB.arrayOffset(), commentB.limit());\nwritten += commentB.limit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryEnd()V",
                                    "method_body": "protected void writeCentralDirectoryEnd() throws IOException {\nwriteOut(EOCD_SIG);\nwriteOut(ZERO);\nwriteOut(ZERO);\nbyte[] num = ZipShort.getBytes(entries.size());\nwriteOut(num);\nwriteOut(num);\nwriteOut(ZipLong.getBytes(cdLength));\nwriteOut(ZipLong.getBytes(cdOffset));\nByteBuffer data = this.zipEncoding.encode(comment);\nwriteOut(ZipShort.getBytes(data.limit()));\nwriteOut(data.array(), data.arrayOffset(), data.limit());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([B)V",
                                    "method_body": "protected final void writeOut(byte[] data) throws IOException {\nwriteOut(data, 0, data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([BII)V",
                                    "method_body": "protected final void writeOut(byte[] data, int offset, int length)\nif (raf != null) {\nraf.write(data, offset, length);\nout.write(data, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeVersionNeededToExtractAndGeneralPurposeBits(IZ)V",
                                    "method_body": "private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\nint versionNeededToExtract = 10;\nint generalPurposeFlag = (useEFS || utfFallback) ? EFS_FLAG : 0;\nif (zipMethod == DEFLATED && raf == null) {\nversionNeededToExtract =  20;\ngeneralPurposeFlag |= 8;\nwriteOut(ZipShort.getBytes(versionNeededToExtract));\nwriteOut(ZipShort.getBytes(generalPurposeFlag));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map simpleEncodings;\nsimpleEncodings = new HashMap();\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\nif (name == null) {\nSimpleEncodingHolder h =\nif (h!=null) {\nreturn h.getEncoding();\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\nreturn UTF8.equalsIgnoreCase(encoding)\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "public static final int PLATFORM_UNIX = 3;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate LinkedHashMap/*<ZipShort, ZipExtraField>*/ extraFields = null;\nprivate String name = null;\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getInternalAttributes()I",
                                    "method_body": "public int getInternalAttributes() {\nreturn internalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExternalAttributes()J",
                                    "method_body": "public long getExternalAttributes() {\nreturn externalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
                                    "method_body": "public byte[] getLocalFileDataExtra() {\nbyte[] extra = getExtra();\nreturn extra != null ? extra : new byte[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getCentralDirectoryExtra()[B",
                                    "method_body": "public byte[] getCentralDirectoryExtra() {\nreturn ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes(I)[B",
                                    "method_body": "public static byte[] getBytes(int value) {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(J)[B",
                                    "method_body": "public static byte[] toDosTime(long t) {\nCalendar c = Calendar.getInstance();\nc.setTimeInMillis(t);\nint year = c.get(Calendar.YEAR);\nif (year < 1980) {\nint month = c.get(Calendar.MONTH) + 1;\nlong value =  ((year - 1980) << 25)\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:adjustToLong(I)J",
                                    "method_body": "public static long adjustToLong(int i) {\nif (i < 0) {\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\nimplementations = new HashMap();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class c) {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeCentralDirectoryData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getCentralDirectoryLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\nbyte[] local = data[i].getCentralDirectoryData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\npublic JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<init>(Ljava/lang/String;)V",
                                    "method_body": "private UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
                                    "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS =\npublic static final UnicodeExtraFieldPolicy NEVER =\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nprivate UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\nthrows IOException {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = new RandomAccessFile(f, \"r\");\nboolean success = false;\nMap entriesWithoutEFS = populateFromCentralDirectory();\nif (!success) {\narchive.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
                                    "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map populateFromCentralDirectory()\nHashMap noEFS = new HashMap();\npositionAtCentralDirectory();\nbyte[] cfh = new byte[CFH_LEN];\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nfinal long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\nif (sig != cfhSig && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nboolean found = false;\nlong off = archive.length() - MIN_EOCD_SIZE;\nlong stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE);\nif (off >= 0) {\narchive.seek(off);\nbyte[] sig = ZipArchiveOutputStream.EOCD_SIG;\nint curr = archive.read();\nwhile (off >= stopSearching && curr != -1) {\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\nif (!found) {\narchive.seek(off + CFD_LOCATOR_OFFSET);\nbyte[] cfdOffset = new byte[WORD];\narchive.readFully(cfdOffset);\narchive.seek(ZipLong.getValue(cfdOffset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:startsWithLocalFileHeader()Z",
                                    "method_body": "private boolean startsWithLocalFileHeader() throws IOException {\narchive.seek(0);\nfinal byte[] start = new byte[WORD];\narchive.readFully(start);\nfor (int i = 0; i < start.length; i++) {\nif (start[i] != ZipArchiveOutputStream.LFH_SIG[i]) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setEncoding(Ljava/lang/String;)V",
                                    "method_body": "public void setEncoding(final String encoding) {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nuseEFS &= ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setUseLanguageEncodingFlag(Z)V",
                                    "method_body": "public void setUseLanguageEncodingFlag(boolean b) {\nuseEFS = b && ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setCreateUnicodeExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveOutputStream$UnicodeExtraFieldPolicy;)V",
                                    "method_body": "public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b) {\ncreateUnicodeExtraFields = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int offset, int length) throws IOException {\nif (entry.getMethod() == DEFLATED) {\nif (length > 0) {\nif (!def.finished()) {\nif (length <= DEFLATER_BLOCK_SIZE) {\ndef.setInput(b, offset, length);\ndeflateUntilInputIsNeeded();\ncrc.update(b, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflateUntilInputIsNeeded()V",
                                    "method_body": "private void deflateUntilInputIsNeeded() throws IOException {\nwhile (!def.needsInput()) {\ndeflate();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:addExtraField(Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void addExtraField(ZipExtraField ze) {\nif (extraFields == null) {\nextraFields = new LinkedHashMap();\nextraFields.put(ze.getHeaderId(), ze);\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "protected AbstractUnicodeExtraField(String text, byte[] bytes, int off,\nint len) {\nCRC32 crc32 = new CRC32();\ncrc32.update(bytes, off, len);\nnameCRC32 = crc32.getValue();\nunicodeName = text.getBytes(\"UTF-8\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:assembleData()V",
                                    "method_body": "private void assembleData() {\nif (unicodeName == null) {\ndata = new byte[5 + unicodeName.length];\ndata[0] = 0x01;\nSystem.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4);\nSystem.arraycopy(unicodeName, 0, data, 5, unicodeName.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryData()[B",
                                    "method_body": "public byte[] getCentralDirectoryData() {\nif (data == null) {\nreturn data;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getCentralDirectoryLength() {\nif (data == null) {\nassembleData();\nreturn new ZipShort(data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn getCentralDirectoryData();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn getCentralDirectoryLength();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "public UnicodePathExtraField(String text, byte[] bytes, int off, int len) {\nsuper(text, bytes, off, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:appendSurrogate(Ljava/nio/ByteBuffer;C)V",
                                    "method_body": "static void appendSurrogate(ByteBuffer bb, char c) {\nbb.put((byte) '%');\nbb.put((byte) 'U');\nbb.put(HEX_DIGITS[(c >> 12)&0x0f]);\nbb.put(HEX_DIGITS[(c >> 8)&0x0f]);\nbb.put(HEX_DIGITS[(c >> 4)&0x0f]);\nbb.put(HEX_DIGITS[c & 0x0f]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:growBuffer(Ljava/nio/ByteBuffer;I)Ljava/nio/ByteBuffer;",
                                    "method_body": "static ByteBuffer growBuffer(ByteBuffer b, int newCapacity) {\nb.limit(b.position());\nb.rewind();\nint c2 = b.capacity() * 2;\nByteBuffer on = ByteBuffer.allocate(c2 < newCapacity ? newCapacity : c2);\non.put(b);\nreturn on;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:<init>(Ljava/nio/charset/Charset;)V",
                                    "method_body": "public NioZipEncoding(Charset charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:canEncode(Ljava/lang/String;)Z",
                                    "method_body": "public boolean canEncode(String name) {\nCharsetEncoder enc = this.charset.newEncoder();\nenc.onMalformedInput(CodingErrorAction.REPORT);\nenc.onUnmappableCharacter(CodingErrorAction.REPORT);\nreturn enc.canEncode(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(String name) {\nCharsetEncoder enc = this.charset.newEncoder();\nenc.onMalformedInput(CodingErrorAction.REPORT);\nenc.onUnmappableCharacter(CodingErrorAction.REPORT);\nCharBuffer cb = CharBuffer.wrap(name);\nByteBuffer out = ByteBuffer.allocate(name.length()\nwhile (cb.remaining() > 0) {\nCoderResult res = enc.encode(cb, out,true);\nif (res.isUnmappable() || res.isMalformed()) {\nif (res.length() * 6 > out.remaining()) {\nfor (int i=0; i<res.length(); ++i) {\nZipEncodingHelper.appendSurrogate(out,cb.get());\n} else if (res.isOverflow()) {\nout = ZipEncodingHelper.growBuffer(out, 0);\n} else if (res.isUnderflow()) {\nenc.flush(out);\nbreak;\n}\nout.limit(out.position());\nout.rewind();\nreturn out;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testASCIIFileRoundtripExplicitUnicodeExtra",
                            "test_body": "58: public void testASCIIFileRoundtripExplicitUnicodeExtra()\n59: throws IOException {\n60: testFileRoundtrip(US_ASCII, false, true);\n61: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipArchiveOutputStream(File file) throws IOException {\nOutputStream o = null;\nRandomAccessFile _raf = null;\n_raf = new RandomAccessFile(file, \"rw\");\n_raf.setLength(0);\n}\nout = o;\nraf = _raf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes();\nstatic final byte[] DD_SIG = ZipLong.getBytes(0X08074B50L);\nstatic final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes();\nstatic final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif(entry != null) {\ncdOffset = written;\nfor (Iterator i = entries.iterator(); i.hasNext(); ) {\nwriteCentralFileHeader((ZipArchiveEntry) i.next());\ncdLength = written - cdOffset;\nwriteCentralDirectoryEnd();\noffsets.clear();\nentries.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (entry == null) {\nreturn;\nlong realCrc = crc.getValue();\ncrc.reset();\nif (entry.getMethod() == DEFLATED) {\ndef.finish();\nwhile (!def.finished()) {\ndeflate();\nentry.setSize(ZipUtil.adjustToLong(def.getTotalIn()));\nentry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut()));\nentry.setCrc(realCrc);\ndef.reset();\nwritten += entry.getCompressedSize();\nif (raf != null) {\nlong save = raf.getFilePointer();\nraf.seek(localDataStart);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\nraf.seek(save);\nwriteDataDescriptor(entry);\nentry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\ncloseArchiveEntry();\nentry = ((ZipArchiveEntry) archiveEntry);\nentries.add(entry);\nif (entry.getMethod() == -1) { // not specified\nentry.setMethod(method);\nif (entry.getTime() == -1) { // not specified\nentry.setTime(System.currentTimeMillis());\nif (entry.getMethod() == STORED && raf == null) {\nif (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\nwriteLocalFileHeader(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nfinish();\nif (raf != null) {\nraf.close();\nif (out != null) {\nout.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflate()V",
                                    "method_body": "protected final void deflate() throws IOException {\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\nboolean encodable = zipEncoding.canEncode(ze.getName());\nif (!encodable && fallbackToUTF8) {\nentryEncoding = zipEncoding;\nByteBuffer name = entryEncoding.encode(ze.getName());\nif (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\nze.addExtraField(new UnicodePathExtraField(ze.getName(),\nString comm = ze.getComment();\nif (comm != null && !\"\".equals(comm)) {\noffsets.put(ze, ZipLong.getBytes(written));\nwriteOut(LFH_SIG);\nwritten += WORD;\nfinal int zipMethod = ze.getMethod();\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\nwritten += WORD;\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\nlocalDataStart = written;\nif (zipMethod == DEFLATED || raf != null) {\nwriteOut(LZERO);\nwriteOut(LZERO);\nwriteOut(LZERO);\nwritten += 12;\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\nbyte[] extra = ze.getLocalFileDataExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\nwriteOut(extra);\nwritten += extra.length;\ndataStart = written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\nwriteOut(CFH_SIG);\nwritten += WORD;\nwriteOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\nwritten += SHORT;\nfinal int zipMethod = ze.getMethod();\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\nwritten += WORD;\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getCompressedSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\nwritten += 12;\nif (!encodable && fallbackToUTF8) {\nentryEncoding = zipEncoding;\nByteBuffer name = entryEncoding.encode(ze.getName());\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\nbyte[] extra = ze.getCentralDirectoryExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\nString comm = ze.getComment();\nif (comm == null) {\ncomm = \"\";\nByteBuffer commentB = entryEncoding.encode(comm);\nwriteOut(ZipShort.getBytes(commentB.limit()));\nwritten += SHORT;\nwriteOut(ZERO);\nwritten += SHORT;\nwriteOut(ZipShort.getBytes(ze.getInternalAttributes()));\nwritten += SHORT;\nwriteOut(ZipLong.getBytes(ze.getExternalAttributes()));\nwritten += WORD;\nwriteOut((byte[]) offsets.get(ze));\nwritten += WORD;\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\nwriteOut(extra);\nwritten += extra.length;\nwriteOut(commentB.array(), commentB.arrayOffset(), commentB.limit());\nwritten += commentB.limit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryEnd()V",
                                    "method_body": "protected void writeCentralDirectoryEnd() throws IOException {\nwriteOut(EOCD_SIG);\nwriteOut(ZERO);\nwriteOut(ZERO);\nbyte[] num = ZipShort.getBytes(entries.size());\nwriteOut(num);\nwriteOut(num);\nwriteOut(ZipLong.getBytes(cdLength));\nwriteOut(ZipLong.getBytes(cdOffset));\nByteBuffer data = this.zipEncoding.encode(comment);\nwriteOut(ZipShort.getBytes(data.limit()));\nwriteOut(data.array(), data.arrayOffset(), data.limit());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([B)V",
                                    "method_body": "protected final void writeOut(byte[] data) throws IOException {\nwriteOut(data, 0, data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([BII)V",
                                    "method_body": "protected final void writeOut(byte[] data, int offset, int length)\nif (raf != null) {\nraf.write(data, offset, length);\nout.write(data, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeVersionNeededToExtractAndGeneralPurposeBits(IZ)V",
                                    "method_body": "private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\nint versionNeededToExtract = 10;\nint generalPurposeFlag = (useEFS || utfFallback) ? EFS_FLAG : 0;\nif (zipMethod == DEFLATED && raf == null) {\nversionNeededToExtract =  20;\ngeneralPurposeFlag |= 8;\nwriteOut(ZipShort.getBytes(versionNeededToExtract));\nwriteOut(ZipShort.getBytes(generalPurposeFlag));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map simpleEncodings;\nsimpleEncodings = new HashMap();\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\nif (name == null) {\nSimpleEncodingHolder h =\nif (h!=null) {\nreturn h.getEncoding();\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\nreturn UTF8.equalsIgnoreCase(encoding)\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "public static final int PLATFORM_UNIX = 3;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate LinkedHashMap/*<ZipShort, ZipExtraField>*/ extraFields = null;\nprivate String name = null;\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getInternalAttributes()I",
                                    "method_body": "public int getInternalAttributes() {\nreturn internalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExternalAttributes()J",
                                    "method_body": "public long getExternalAttributes() {\nreturn externalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields() {\nif (extraFields == null) {\nreturn new ZipExtraField[0];\nZipExtraField[] result = new ZipExtraField[extraFields.size()];\nreturn (ZipExtraField[]) extraFields.values().toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
                                    "method_body": "public byte[] getLocalFileDataExtra() {\nbyte[] extra = getExtra();\nreturn extra != null ? extra : new byte[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getCentralDirectoryExtra()[B",
                                    "method_body": "public byte[] getCentralDirectoryExtra() {\nreturn ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes(I)[B",
                                    "method_body": "public static byte[] getBytes(int value) {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(J)[B",
                                    "method_body": "public static byte[] toDosTime(long t) {\nCalendar c = Calendar.getInstance();\nc.setTimeInMillis(t);\nint year = c.get(Calendar.YEAR);\nif (year < 1980) {\nint month = c.get(Calendar.MONTH) + 1;\nlong value =  ((year - 1980) << 25)\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:adjustToLong(I)J",
                                    "method_body": "public static long adjustToLong(int i) {\nif (i < 0) {\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\nimplementations = new HashMap();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class c) {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeCentralDirectoryData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getCentralDirectoryLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\nbyte[] local = data[i].getCentralDirectoryData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\npublic JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<init>(Ljava/lang/String;)V",
                                    "method_body": "private UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
                                    "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS =\npublic static final UnicodeExtraFieldPolicy NEVER =\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nprivate UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\nthrows IOException {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = new RandomAccessFile(f, \"r\");\nboolean success = false;\nMap entriesWithoutEFS = populateFromCentralDirectory();\nif (!success) {\narchive.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
                                    "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map populateFromCentralDirectory()\nHashMap noEFS = new HashMap();\npositionAtCentralDirectory();\nbyte[] cfh = new byte[CFH_LEN];\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nfinal long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\nif (sig != cfhSig && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nboolean found = false;\nlong off = archive.length() - MIN_EOCD_SIZE;\nlong stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE);\nif (off >= 0) {\narchive.seek(off);\nbyte[] sig = ZipArchiveOutputStream.EOCD_SIG;\nint curr = archive.read();\nwhile (off >= stopSearching && curr != -1) {\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\nif (!found) {\narchive.seek(off + CFD_LOCATOR_OFFSET);\nbyte[] cfdOffset = new byte[WORD];\narchive.readFully(cfdOffset);\narchive.seek(ZipLong.getValue(cfdOffset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:startsWithLocalFileHeader()Z",
                                    "method_body": "private boolean startsWithLocalFileHeader() throws IOException {\narchive.seek(0);\nfinal byte[] start = new byte[WORD];\narchive.readFully(start);\nfor (int i = 0; i < start.length; i++) {\nif (start[i] != ZipArchiveOutputStream.LFH_SIG[i]) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setEncoding(Ljava/lang/String;)V",
                                    "method_body": "public void setEncoding(final String encoding) {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nuseEFS &= ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setUseLanguageEncodingFlag(Z)V",
                                    "method_body": "public void setUseLanguageEncodingFlag(boolean b) {\nuseEFS = b && ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setCreateUnicodeExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveOutputStream$UnicodeExtraFieldPolicy;)V",
                                    "method_body": "public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b) {\ncreateUnicodeExtraFields = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int offset, int length) throws IOException {\nif (entry.getMethod() == DEFLATED) {\nif (length > 0) {\nif (!def.finished()) {\nif (length <= DEFLATER_BLOCK_SIZE) {\ndef.setInput(b, offset, length);\ndeflateUntilInputIsNeeded();\ncrc.update(b, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflateUntilInputIsNeeded()V",
                                    "method_body": "private void deflateUntilInputIsNeeded() throws IOException {\nwhile (!def.needsInput()) {\ndeflate();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:addExtraField(Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void addExtraField(ZipExtraField ze) {\nif (extraFields == null) {\nextraFields = new LinkedHashMap();\nextraFields.put(ze.getHeaderId(), ze);\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "protected AbstractUnicodeExtraField(String text, byte[] bytes, int off,\nint len) {\nCRC32 crc32 = new CRC32();\ncrc32.update(bytes, off, len);\nnameCRC32 = crc32.getValue();\nunicodeName = text.getBytes(\"UTF-8\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:assembleData()V",
                                    "method_body": "private void assembleData() {\nif (unicodeName == null) {\ndata = new byte[5 + unicodeName.length];\ndata[0] = 0x01;\nSystem.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4);\nSystem.arraycopy(unicodeName, 0, data, 5, unicodeName.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryData()[B",
                                    "method_body": "public byte[] getCentralDirectoryData() {\nif (data == null) {\nreturn data;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getCentralDirectoryLength() {\nif (data == null) {\nassembleData();\nreturn new ZipShort(data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn getCentralDirectoryData();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn getCentralDirectoryLength();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "public UnicodePathExtraField(String text, byte[] bytes, int off, int len) {\nsuper(text, bytes, off, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:appendSurrogate(Ljava/nio/ByteBuffer;C)V",
                                    "method_body": "static void appendSurrogate(ByteBuffer bb, char c) {\nbb.put((byte) '%');\nbb.put((byte) 'U');\nbb.put(HEX_DIGITS[(c >> 12)&0x0f]);\nbb.put(HEX_DIGITS[(c >> 8)&0x0f]);\nbb.put(HEX_DIGITS[(c >> 4)&0x0f]);\nbb.put(HEX_DIGITS[c & 0x0f]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:growBuffer(Ljava/nio/ByteBuffer;I)Ljava/nio/ByteBuffer;",
                                    "method_body": "static ByteBuffer growBuffer(ByteBuffer b, int newCapacity) {\nb.limit(b.position());\nb.rewind();\nint c2 = b.capacity() * 2;\nByteBuffer on = ByteBuffer.allocate(c2 < newCapacity ? newCapacity : c2);\non.put(b);\nreturn on;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:<init>(Ljava/nio/charset/Charset;)V",
                                    "method_body": "public NioZipEncoding(Charset charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:canEncode(Ljava/lang/String;)Z",
                                    "method_body": "public boolean canEncode(String name) {\nCharsetEncoder enc = this.charset.newEncoder();\nenc.onMalformedInput(CodingErrorAction.REPORT);\nenc.onUnmappableCharacter(CodingErrorAction.REPORT);\nreturn enc.canEncode(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(String name) {\nCharsetEncoder enc = this.charset.newEncoder();\nenc.onMalformedInput(CodingErrorAction.REPORT);\nenc.onUnmappableCharacter(CodingErrorAction.REPORT);\nCharBuffer cb = CharBuffer.wrap(name);\nByteBuffer out = ByteBuffer.allocate(name.length()\nwhile (cb.remaining() > 0) {\nCoderResult res = enc.encode(cb, out,true);\nif (res.isUnmappable() || res.isMalformed()) {\nif (res.length() * 6 > out.remaining()) {\nfor (int i=0; i<res.length(); ++i) {\nZipEncodingHelper.appendSurrogate(out,cb.get());\n} else if (res.isOverflow()) {\nout = ZipEncodingHelper.growBuffer(out, 0);\n} else if (res.isUnderflow()) {\nenc.flush(out);\nbreak;\n}\nout.limit(out.position());\nout.rewind();\nreturn out;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testZipArchiveInputStreamReadsUnicodeFields",
                            "test_body": "177: public void testZipArchiveInputStreamReadsUnicodeFields()\n178: throws IOException {\n179: File file = File.createTempFile(\"unicode-test\", \".zip\");\n180: ZipFile zf = null;\n181: try {\n182: createTestFile(file, US_ASCII, false, true);\n183: zf = new ZipFile(file, US_ASCII, true);\n184: assertNotNull(zf.getEntry(ASCII_TXT));\n185: assertNotNull(zf.getEntry(EURO_FOR_DOLLAR_TXT));\n186: assertNotNull(zf.getEntry(OIL_BARREL_TXT));\n187: } finally {\n188: ZipFile.closeQuietly(zf);\n189: if (file.exists()) {\n190: file.delete();\n191: }\n192: }\n193: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipArchiveOutputStream(File file) throws IOException {\nOutputStream o = null;\nRandomAccessFile _raf = null;\n_raf = new RandomAccessFile(file, \"rw\");\n_raf.setLength(0);\n}\nout = o;\nraf = _raf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes();\nstatic final byte[] DD_SIG = ZipLong.getBytes(0X08074B50L);\nstatic final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes();\nstatic final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif(entry != null) {\ncdOffset = written;\nfor (Iterator i = entries.iterator(); i.hasNext(); ) {\nwriteCentralFileHeader((ZipArchiveEntry) i.next());\ncdLength = written - cdOffset;\nwriteCentralDirectoryEnd();\noffsets.clear();\nentries.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (entry == null) {\nreturn;\nlong realCrc = crc.getValue();\ncrc.reset();\nif (entry.getMethod() == DEFLATED) {\ndef.finish();\nwhile (!def.finished()) {\ndeflate();\nentry.setSize(ZipUtil.adjustToLong(def.getTotalIn()));\nentry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut()));\nentry.setCrc(realCrc);\ndef.reset();\nwritten += entry.getCompressedSize();\nif (raf != null) {\nlong save = raf.getFilePointer();\nraf.seek(localDataStart);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\nraf.seek(save);\nwriteDataDescriptor(entry);\nentry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\ncloseArchiveEntry();\nentry = ((ZipArchiveEntry) archiveEntry);\nentries.add(entry);\nif (entry.getMethod() == -1) { // not specified\nentry.setMethod(method);\nif (entry.getTime() == -1) { // not specified\nentry.setTime(System.currentTimeMillis());\nif (entry.getMethod() == STORED && raf == null) {\nif (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\nwriteLocalFileHeader(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nfinish();\nif (raf != null) {\nraf.close();\nif (out != null) {\nout.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflate()V",
                                    "method_body": "protected final void deflate() throws IOException {\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\nboolean encodable = zipEncoding.canEncode(ze.getName());\nif (!encodable && fallbackToUTF8) {\nentryEncoding = zipEncoding;\nByteBuffer name = entryEncoding.encode(ze.getName());\nif (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\nze.addExtraField(new UnicodePathExtraField(ze.getName(),\nString comm = ze.getComment();\nif (comm != null && !\"\".equals(comm)) {\noffsets.put(ze, ZipLong.getBytes(written));\nwriteOut(LFH_SIG);\nwritten += WORD;\nfinal int zipMethod = ze.getMethod();\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\nwritten += WORD;\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\nlocalDataStart = written;\nif (zipMethod == DEFLATED || raf != null) {\nwriteOut(LZERO);\nwriteOut(LZERO);\nwriteOut(LZERO);\nwritten += 12;\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\nbyte[] extra = ze.getLocalFileDataExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\nwriteOut(extra);\nwritten += extra.length;\ndataStart = written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\nwriteOut(CFH_SIG);\nwritten += WORD;\nwriteOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\nwritten += SHORT;\nfinal int zipMethod = ze.getMethod();\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\nwritten += WORD;\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getCompressedSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\nwritten += 12;\nif (!encodable && fallbackToUTF8) {\nentryEncoding = zipEncoding;\nByteBuffer name = entryEncoding.encode(ze.getName());\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\nbyte[] extra = ze.getCentralDirectoryExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\nString comm = ze.getComment();\nif (comm == null) {\ncomm = \"\";\nByteBuffer commentB = entryEncoding.encode(comm);\nwriteOut(ZipShort.getBytes(commentB.limit()));\nwritten += SHORT;\nwriteOut(ZERO);\nwritten += SHORT;\nwriteOut(ZipShort.getBytes(ze.getInternalAttributes()));\nwritten += SHORT;\nwriteOut(ZipLong.getBytes(ze.getExternalAttributes()));\nwritten += WORD;\nwriteOut((byte[]) offsets.get(ze));\nwritten += WORD;\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\nwriteOut(extra);\nwritten += extra.length;\nwriteOut(commentB.array(), commentB.arrayOffset(), commentB.limit());\nwritten += commentB.limit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryEnd()V",
                                    "method_body": "protected void writeCentralDirectoryEnd() throws IOException {\nwriteOut(EOCD_SIG);\nwriteOut(ZERO);\nwriteOut(ZERO);\nbyte[] num = ZipShort.getBytes(entries.size());\nwriteOut(num);\nwriteOut(num);\nwriteOut(ZipLong.getBytes(cdLength));\nwriteOut(ZipLong.getBytes(cdOffset));\nByteBuffer data = this.zipEncoding.encode(comment);\nwriteOut(ZipShort.getBytes(data.limit()));\nwriteOut(data.array(), data.arrayOffset(), data.limit());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([B)V",
                                    "method_body": "protected final void writeOut(byte[] data) throws IOException {\nwriteOut(data, 0, data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([BII)V",
                                    "method_body": "protected final void writeOut(byte[] data, int offset, int length)\nif (raf != null) {\nraf.write(data, offset, length);\nout.write(data, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeVersionNeededToExtractAndGeneralPurposeBits(IZ)V",
                                    "method_body": "private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\nint versionNeededToExtract = 10;\nint generalPurposeFlag = (useEFS || utfFallback) ? EFS_FLAG : 0;\nif (zipMethod == DEFLATED && raf == null) {\nversionNeededToExtract =  20;\ngeneralPurposeFlag |= 8;\nwriteOut(ZipShort.getBytes(versionNeededToExtract));\nwriteOut(ZipShort.getBytes(generalPurposeFlag));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map simpleEncodings;\nsimpleEncodings = new HashMap();\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\nif (name == null) {\nSimpleEncodingHolder h =\nif (h!=null) {\nreturn h.getEncoding();\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\nreturn UTF8.equalsIgnoreCase(encoding)\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "public static final int PLATFORM_UNIX = 3;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate LinkedHashMap/*<ZipShort, ZipExtraField>*/ extraFields = null;\nprivate String name = null;\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getInternalAttributes()I",
                                    "method_body": "public int getInternalAttributes() {\nreturn internalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExternalAttributes()J",
                                    "method_body": "public long getExternalAttributes() {\nreturn externalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields() {\nif (extraFields == null) {\nreturn new ZipExtraField[0];\nZipExtraField[] result = new ZipExtraField[extraFields.size()];\nreturn (ZipExtraField[]) extraFields.values().toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
                                    "method_body": "public byte[] getLocalFileDataExtra() {\nbyte[] extra = getExtra();\nreturn extra != null ? extra : new byte[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getCentralDirectoryExtra()[B",
                                    "method_body": "public byte[] getCentralDirectoryExtra() {\nreturn ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes(I)[B",
                                    "method_body": "public static byte[] getBytes(int value) {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(J)[B",
                                    "method_body": "public static byte[] toDosTime(long t) {\nCalendar c = Calendar.getInstance();\nc.setTimeInMillis(t);\nint year = c.get(Calendar.YEAR);\nif (year < 1980) {\nint month = c.get(Calendar.MONTH) + 1;\nlong value =  ((year - 1980) << 25)\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:adjustToLong(I)J",
                                    "method_body": "public static long adjustToLong(int i) {\nif (i < 0) {\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\nimplementations = new HashMap();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class c) {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeCentralDirectoryData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getCentralDirectoryLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\nbyte[] local = data[i].getCentralDirectoryData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\npublic JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<init>(Ljava/lang/String;)V",
                                    "method_body": "private UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
                                    "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS =\npublic static final UnicodeExtraFieldPolicy NEVER =\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nprivate UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\nthrows IOException {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = new RandomAccessFile(f, \"r\");\nboolean success = false;\nMap entriesWithoutEFS = populateFromCentralDirectory();\nif (!success) {\narchive.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
                                    "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map populateFromCentralDirectory()\nHashMap noEFS = new HashMap();\npositionAtCentralDirectory();\nbyte[] cfh = new byte[CFH_LEN];\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nfinal long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\nif (sig != cfhSig && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nboolean found = false;\nlong off = archive.length() - MIN_EOCD_SIZE;\nlong stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE);\nif (off >= 0) {\narchive.seek(off);\nbyte[] sig = ZipArchiveOutputStream.EOCD_SIG;\nint curr = archive.read();\nwhile (off >= stopSearching && curr != -1) {\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\nif (!found) {\narchive.seek(off + CFD_LOCATOR_OFFSET);\nbyte[] cfdOffset = new byte[WORD];\narchive.readFully(cfdOffset);\narchive.seek(ZipLong.getValue(cfdOffset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:startsWithLocalFileHeader()Z",
                                    "method_body": "private boolean startsWithLocalFileHeader() throws IOException {\narchive.seek(0);\nfinal byte[] start = new byte[WORD];\narchive.readFully(start);\nfor (int i = 0; i < start.length; i++) {\nif (start[i] != ZipArchiveOutputStream.LFH_SIG[i]) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setEncoding(Ljava/lang/String;)V",
                                    "method_body": "public void setEncoding(final String encoding) {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nuseEFS &= ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setUseLanguageEncodingFlag(Z)V",
                                    "method_body": "public void setUseLanguageEncodingFlag(boolean b) {\nuseEFS = b && ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setCreateUnicodeExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveOutputStream$UnicodeExtraFieldPolicy;)V",
                                    "method_body": "public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b) {\ncreateUnicodeExtraFields = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int offset, int length) throws IOException {\nif (entry.getMethod() == DEFLATED) {\nif (length > 0) {\nif (!def.finished()) {\nif (length <= DEFLATER_BLOCK_SIZE) {\ndef.setInput(b, offset, length);\ndeflateUntilInputIsNeeded();\ncrc.update(b, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflateUntilInputIsNeeded()V",
                                    "method_body": "private void deflateUntilInputIsNeeded() throws IOException {\nwhile (!def.needsInput()) {\ndeflate();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:addExtraField(Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void addExtraField(ZipExtraField ze) {\nif (extraFields == null) {\nextraFields = new LinkedHashMap();\nextraFields.put(ze.getHeaderId(), ze);\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "protected AbstractUnicodeExtraField(String text, byte[] bytes, int off,\nint len) {\nCRC32 crc32 = new CRC32();\ncrc32.update(bytes, off, len);\nnameCRC32 = crc32.getValue();\nunicodeName = text.getBytes(\"UTF-8\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:assembleData()V",
                                    "method_body": "private void assembleData() {\nif (unicodeName == null) {\ndata = new byte[5 + unicodeName.length];\ndata[0] = 0x01;\nSystem.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4);\nSystem.arraycopy(unicodeName, 0, data, 5, unicodeName.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryData()[B",
                                    "method_body": "public byte[] getCentralDirectoryData() {\nif (data == null) {\nreturn data;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getCentralDirectoryLength() {\nif (data == null) {\nassembleData();\nreturn new ZipShort(data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn getCentralDirectoryData();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn getCentralDirectoryLength();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "public UnicodePathExtraField(String text, byte[] bytes, int off, int len) {\nsuper(text, bytes, off, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:appendSurrogate(Ljava/nio/ByteBuffer;C)V",
                                    "method_body": "static void appendSurrogate(ByteBuffer bb, char c) {\nbb.put((byte) '%');\nbb.put((byte) 'U');\nbb.put(HEX_DIGITS[(c >> 12)&0x0f]);\nbb.put(HEX_DIGITS[(c >> 8)&0x0f]);\nbb.put(HEX_DIGITS[(c >> 4)&0x0f]);\nbb.put(HEX_DIGITS[c & 0x0f]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:growBuffer(Ljava/nio/ByteBuffer;I)Ljava/nio/ByteBuffer;",
                                    "method_body": "static ByteBuffer growBuffer(ByteBuffer b, int newCapacity) {\nb.limit(b.position());\nb.rewind();\nint c2 = b.capacity() * 2;\nByteBuffer on = ByteBuffer.allocate(c2 < newCapacity ? newCapacity : c2);\non.put(b);\nreturn on;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:<init>(Ljava/nio/charset/Charset;)V",
                                    "method_body": "public NioZipEncoding(Charset charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:canEncode(Ljava/lang/String;)Z",
                                    "method_body": "public boolean canEncode(String name) {\nCharsetEncoder enc = this.charset.newEncoder();\nenc.onMalformedInput(CodingErrorAction.REPORT);\nenc.onUnmappableCharacter(CodingErrorAction.REPORT);\nreturn enc.canEncode(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(String name) {\nCharsetEncoder enc = this.charset.newEncoder();\nenc.onMalformedInput(CodingErrorAction.REPORT);\nenc.onUnmappableCharacter(CodingErrorAction.REPORT);\nCharBuffer cb = CharBuffer.wrap(name);\nByteBuffer out = ByteBuffer.allocate(name.length()\nwhile (cb.remaining() > 0) {\nCoderResult res = enc.encode(cb, out,true);\nif (res.isUnmappable() || res.isMalformed()) {\nif (res.length() * 6 > out.remaining()) {\nfor (int i=0; i<res.length(); ++i) {\nZipEncodingHelper.appendSurrogate(out,cb.get());\n} else if (res.isOverflow()) {\nout = ZipEncodingHelper.growBuffer(out, 0);\n} else if (res.isUnderflow()) {\nenc.flush(out);\nbreak;\n}\nout.limit(out.position());\nout.rewind();\nreturn out;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testUtf8FileRoundtripNoEFSExplicitUnicodeExtra",
                            "test_body": "48: public void testUtf8FileRoundtripNoEFSExplicitUnicodeExtra()\n49: throws IOException {\n50: testFileRoundtrip(UTF_8, false, true);\n51: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipArchiveOutputStream(File file) throws IOException {\nOutputStream o = null;\nRandomAccessFile _raf = null;\n_raf = new RandomAccessFile(file, \"rw\");\n_raf.setLength(0);\n}\nout = o;\nraf = _raf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes();\nstatic final byte[] DD_SIG = ZipLong.getBytes(0X08074B50L);\nstatic final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes();\nstatic final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif(entry != null) {\ncdOffset = written;\nfor (Iterator i = entries.iterator(); i.hasNext(); ) {\nwriteCentralFileHeader((ZipArchiveEntry) i.next());\ncdLength = written - cdOffset;\nwriteCentralDirectoryEnd();\noffsets.clear();\nentries.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (entry == null) {\nreturn;\nlong realCrc = crc.getValue();\ncrc.reset();\nif (entry.getMethod() == DEFLATED) {\ndef.finish();\nwhile (!def.finished()) {\ndeflate();\nentry.setSize(ZipUtil.adjustToLong(def.getTotalIn()));\nentry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut()));\nentry.setCrc(realCrc);\ndef.reset();\nwritten += entry.getCompressedSize();\nif (raf != null) {\nlong save = raf.getFilePointer();\nraf.seek(localDataStart);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\nraf.seek(save);\nwriteDataDescriptor(entry);\nentry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\ncloseArchiveEntry();\nentry = ((ZipArchiveEntry) archiveEntry);\nentries.add(entry);\nif (entry.getMethod() == -1) { // not specified\nentry.setMethod(method);\nif (entry.getTime() == -1) { // not specified\nentry.setTime(System.currentTimeMillis());\nif (entry.getMethod() == STORED && raf == null) {\nif (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\nwriteLocalFileHeader(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nfinish();\nif (raf != null) {\nraf.close();\nif (out != null) {\nout.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflate()V",
                                    "method_body": "protected final void deflate() throws IOException {\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\nboolean encodable = zipEncoding.canEncode(ze.getName());\nif (!encodable && fallbackToUTF8) {\nentryEncoding = zipEncoding;\nByteBuffer name = entryEncoding.encode(ze.getName());\nif (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\nze.addExtraField(new UnicodePathExtraField(ze.getName(),\nString comm = ze.getComment();\nif (comm != null && !\"\".equals(comm)) {\noffsets.put(ze, ZipLong.getBytes(written));\nwriteOut(LFH_SIG);\nwritten += WORD;\nfinal int zipMethod = ze.getMethod();\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\nwritten += WORD;\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\nlocalDataStart = written;\nif (zipMethod == DEFLATED || raf != null) {\nwriteOut(LZERO);\nwriteOut(LZERO);\nwriteOut(LZERO);\nwritten += 12;\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\nbyte[] extra = ze.getLocalFileDataExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\nwriteOut(extra);\nwritten += extra.length;\ndataStart = written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\nwriteOut(CFH_SIG);\nwritten += WORD;\nwriteOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\nwritten += SHORT;\nfinal int zipMethod = ze.getMethod();\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\nwritten += WORD;\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getCompressedSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\nwritten += 12;\nif (!encodable && fallbackToUTF8) {\nentryEncoding = zipEncoding;\nByteBuffer name = entryEncoding.encode(ze.getName());\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\nbyte[] extra = ze.getCentralDirectoryExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\nString comm = ze.getComment();\nif (comm == null) {\ncomm = \"\";\nByteBuffer commentB = entryEncoding.encode(comm);\nwriteOut(ZipShort.getBytes(commentB.limit()));\nwritten += SHORT;\nwriteOut(ZERO);\nwritten += SHORT;\nwriteOut(ZipShort.getBytes(ze.getInternalAttributes()));\nwritten += SHORT;\nwriteOut(ZipLong.getBytes(ze.getExternalAttributes()));\nwritten += WORD;\nwriteOut((byte[]) offsets.get(ze));\nwritten += WORD;\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\nwriteOut(extra);\nwritten += extra.length;\nwriteOut(commentB.array(), commentB.arrayOffset(), commentB.limit());\nwritten += commentB.limit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryEnd()V",
                                    "method_body": "protected void writeCentralDirectoryEnd() throws IOException {\nwriteOut(EOCD_SIG);\nwriteOut(ZERO);\nwriteOut(ZERO);\nbyte[] num = ZipShort.getBytes(entries.size());\nwriteOut(num);\nwriteOut(num);\nwriteOut(ZipLong.getBytes(cdLength));\nwriteOut(ZipLong.getBytes(cdOffset));\nByteBuffer data = this.zipEncoding.encode(comment);\nwriteOut(ZipShort.getBytes(data.limit()));\nwriteOut(data.array(), data.arrayOffset(), data.limit());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([B)V",
                                    "method_body": "protected final void writeOut(byte[] data) throws IOException {\nwriteOut(data, 0, data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([BII)V",
                                    "method_body": "protected final void writeOut(byte[] data, int offset, int length)\nif (raf != null) {\nraf.write(data, offset, length);\nout.write(data, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeVersionNeededToExtractAndGeneralPurposeBits(IZ)V",
                                    "method_body": "private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\nint versionNeededToExtract = 10;\nint generalPurposeFlag = (useEFS || utfFallback) ? EFS_FLAG : 0;\nif (zipMethod == DEFLATED && raf == null) {\nversionNeededToExtract =  20;\ngeneralPurposeFlag |= 8;\nwriteOut(ZipShort.getBytes(versionNeededToExtract));\nwriteOut(ZipShort.getBytes(generalPurposeFlag));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map simpleEncodings;\nsimpleEncodings = new HashMap();\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\nif (name == null) {\nSimpleEncodingHolder h =\nif (h!=null) {\nreturn h.getEncoding();\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\nreturn UTF8.equalsIgnoreCase(encoding)\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:canEncode(Ljava/lang/String;)Z",
                                    "method_body": "public boolean canEncode(String name) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(String name) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn ByteBuffer.wrap(name.getBytes(this.charset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "public static final int PLATFORM_UNIX = 3;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate LinkedHashMap/*<ZipShort, ZipExtraField>*/ extraFields = null;\nprivate String name = null;\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getInternalAttributes()I",
                                    "method_body": "public int getInternalAttributes() {\nreturn internalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExternalAttributes()J",
                                    "method_body": "public long getExternalAttributes() {\nreturn externalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields() {\nif (extraFields == null) {\nreturn new ZipExtraField[0];\nZipExtraField[] result = new ZipExtraField[extraFields.size()];\nreturn (ZipExtraField[]) extraFields.values().toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
                                    "method_body": "public byte[] getLocalFileDataExtra() {\nbyte[] extra = getExtra();\nreturn extra != null ? extra : new byte[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getCentralDirectoryExtra()[B",
                                    "method_body": "public byte[] getCentralDirectoryExtra() {\nreturn ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes(I)[B",
                                    "method_body": "public static byte[] getBytes(int value) {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(J)[B",
                                    "method_body": "public static byte[] toDosTime(long t) {\nCalendar c = Calendar.getInstance();\nc.setTimeInMillis(t);\nint year = c.get(Calendar.YEAR);\nif (year < 1980) {\nint month = c.get(Calendar.MONTH) + 1;\nlong value =  ((year - 1980) << 25)\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:adjustToLong(I)J",
                                    "method_body": "public static long adjustToLong(int i) {\nif (i < 0) {\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\nimplementations = new HashMap();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class c) {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeCentralDirectoryData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getCentralDirectoryLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\nbyte[] local = data[i].getCentralDirectoryData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\npublic JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<init>(Ljava/lang/String;)V",
                                    "method_body": "private UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
                                    "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS =\npublic static final UnicodeExtraFieldPolicy NEVER =\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nprivate UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\nthrows IOException {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = new RandomAccessFile(f, \"r\");\nboolean success = false;\nMap entriesWithoutEFS = populateFromCentralDirectory();\nif (!success) {\narchive.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
                                    "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map populateFromCentralDirectory()\nHashMap noEFS = new HashMap();\npositionAtCentralDirectory();\nbyte[] cfh = new byte[CFH_LEN];\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nfinal long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\nif (sig != cfhSig && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nboolean found = false;\nlong off = archive.length() - MIN_EOCD_SIZE;\nlong stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE);\nif (off >= 0) {\narchive.seek(off);\nbyte[] sig = ZipArchiveOutputStream.EOCD_SIG;\nint curr = archive.read();\nwhile (off >= stopSearching && curr != -1) {\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\nif (!found) {\narchive.seek(off + CFD_LOCATOR_OFFSET);\nbyte[] cfdOffset = new byte[WORD];\narchive.readFully(cfdOffset);\narchive.seek(ZipLong.getValue(cfdOffset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:startsWithLocalFileHeader()Z",
                                    "method_body": "private boolean startsWithLocalFileHeader() throws IOException {\narchive.seek(0);\nfinal byte[] start = new byte[WORD];\narchive.readFully(start);\nfor (int i = 0; i < start.length; i++) {\nif (start[i] != ZipArchiveOutputStream.LFH_SIG[i]) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setEncoding(Ljava/lang/String;)V",
                                    "method_body": "public void setEncoding(final String encoding) {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nuseEFS &= ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setUseLanguageEncodingFlag(Z)V",
                                    "method_body": "public void setUseLanguageEncodingFlag(boolean b) {\nuseEFS = b && ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setCreateUnicodeExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveOutputStream$UnicodeExtraFieldPolicy;)V",
                                    "method_body": "public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b) {\ncreateUnicodeExtraFields = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int offset, int length) throws IOException {\nif (entry.getMethod() == DEFLATED) {\nif (length > 0) {\nif (!def.finished()) {\nif (length <= DEFLATER_BLOCK_SIZE) {\ndef.setInput(b, offset, length);\ndeflateUntilInputIsNeeded();\ncrc.update(b, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflateUntilInputIsNeeded()V",
                                    "method_body": "private void deflateUntilInputIsNeeded() throws IOException {\nwhile (!def.needsInput()) {\ndeflate();\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testCP437FileRoundtripImplicitUnicodeExtra",
                            "test_body": "73: public void testCP437FileRoundtripImplicitUnicodeExtra()\n74: throws IOException {\n75: testFileRoundtrip(CP437, false, false);\n76: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipArchiveOutputStream(File file) throws IOException {\nOutputStream o = null;\nRandomAccessFile _raf = null;\n_raf = new RandomAccessFile(file, \"rw\");\n_raf.setLength(0);\n}\nout = o;\nraf = _raf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes();\nstatic final byte[] DD_SIG = ZipLong.getBytes(0X08074B50L);\nstatic final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes();\nstatic final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif(entry != null) {\ncdOffset = written;\nfor (Iterator i = entries.iterator(); i.hasNext(); ) {\nwriteCentralFileHeader((ZipArchiveEntry) i.next());\ncdLength = written - cdOffset;\nwriteCentralDirectoryEnd();\noffsets.clear();\nentries.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (entry == null) {\nreturn;\nlong realCrc = crc.getValue();\ncrc.reset();\nif (entry.getMethod() == DEFLATED) {\ndef.finish();\nwhile (!def.finished()) {\ndeflate();\nentry.setSize(ZipUtil.adjustToLong(def.getTotalIn()));\nentry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut()));\nentry.setCrc(realCrc);\ndef.reset();\nwritten += entry.getCompressedSize();\nif (raf != null) {\nlong save = raf.getFilePointer();\nraf.seek(localDataStart);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\nraf.seek(save);\nwriteDataDescriptor(entry);\nentry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\ncloseArchiveEntry();\nentry = ((ZipArchiveEntry) archiveEntry);\nentries.add(entry);\nif (entry.getMethod() == -1) { // not specified\nentry.setMethod(method);\nif (entry.getTime() == -1) { // not specified\nentry.setTime(System.currentTimeMillis());\nif (entry.getMethod() == STORED && raf == null) {\nif (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\nwriteLocalFileHeader(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nfinish();\nif (raf != null) {\nraf.close();\nif (out != null) {\nout.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflate()V",
                                    "method_body": "protected final void deflate() throws IOException {\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\nboolean encodable = zipEncoding.canEncode(ze.getName());\nif (!encodable && fallbackToUTF8) {\nentryEncoding = zipEncoding;\nByteBuffer name = entryEncoding.encode(ze.getName());\nif (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\nze.addExtraField(new UnicodePathExtraField(ze.getName(),\nString comm = ze.getComment();\nif (comm != null && !\"\".equals(comm)) {\noffsets.put(ze, ZipLong.getBytes(written));\nwriteOut(LFH_SIG);\nwritten += WORD;\nfinal int zipMethod = ze.getMethod();\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\nwritten += WORD;\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\nlocalDataStart = written;\nif (zipMethod == DEFLATED || raf != null) {\nwriteOut(LZERO);\nwriteOut(LZERO);\nwriteOut(LZERO);\nwritten += 12;\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\nbyte[] extra = ze.getLocalFileDataExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\nwriteOut(extra);\nwritten += extra.length;\ndataStart = written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\nwriteOut(CFH_SIG);\nwritten += WORD;\nwriteOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\nwritten += SHORT;\nfinal int zipMethod = ze.getMethod();\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\nwritten += WORD;\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getCompressedSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\nwritten += 12;\nif (!encodable && fallbackToUTF8) {\nentryEncoding = zipEncoding;\nByteBuffer name = entryEncoding.encode(ze.getName());\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\nbyte[] extra = ze.getCentralDirectoryExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\nString comm = ze.getComment();\nif (comm == null) {\ncomm = \"\";\nByteBuffer commentB = entryEncoding.encode(comm);\nwriteOut(ZipShort.getBytes(commentB.limit()));\nwritten += SHORT;\nwriteOut(ZERO);\nwritten += SHORT;\nwriteOut(ZipShort.getBytes(ze.getInternalAttributes()));\nwritten += SHORT;\nwriteOut(ZipLong.getBytes(ze.getExternalAttributes()));\nwritten += WORD;\nwriteOut((byte[]) offsets.get(ze));\nwritten += WORD;\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\nwriteOut(extra);\nwritten += extra.length;\nwriteOut(commentB.array(), commentB.arrayOffset(), commentB.limit());\nwritten += commentB.limit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryEnd()V",
                                    "method_body": "protected void writeCentralDirectoryEnd() throws IOException {\nwriteOut(EOCD_SIG);\nwriteOut(ZERO);\nwriteOut(ZERO);\nbyte[] num = ZipShort.getBytes(entries.size());\nwriteOut(num);\nwriteOut(num);\nwriteOut(ZipLong.getBytes(cdLength));\nwriteOut(ZipLong.getBytes(cdOffset));\nByteBuffer data = this.zipEncoding.encode(comment);\nwriteOut(ZipShort.getBytes(data.limit()));\nwriteOut(data.array(), data.arrayOffset(), data.limit());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([B)V",
                                    "method_body": "protected final void writeOut(byte[] data) throws IOException {\nwriteOut(data, 0, data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([BII)V",
                                    "method_body": "protected final void writeOut(byte[] data, int offset, int length)\nif (raf != null) {\nraf.write(data, offset, length);\nout.write(data, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeVersionNeededToExtractAndGeneralPurposeBits(IZ)V",
                                    "method_body": "private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\nint versionNeededToExtract = 10;\nint generalPurposeFlag = (useEFS || utfFallback) ? EFS_FLAG : 0;\nif (zipMethod == DEFLATED && raf == null) {\nversionNeededToExtract =  20;\ngeneralPurposeFlag |= 8;\nwriteOut(ZipShort.getBytes(versionNeededToExtract));\nwriteOut(ZipShort.getBytes(generalPurposeFlag));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map simpleEncodings;\nsimpleEncodings = new HashMap();\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\nif (name == null) {\nSimpleEncodingHolder h =\nif (h!=null) {\nreturn h.getEncoding();\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\nreturn UTF8.equalsIgnoreCase(encoding)\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "public static final int PLATFORM_UNIX = 3;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate LinkedHashMap/*<ZipShort, ZipExtraField>*/ extraFields = null;\nprivate String name = null;\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getInternalAttributes()I",
                                    "method_body": "public int getInternalAttributes() {\nreturn internalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExternalAttributes()J",
                                    "method_body": "public long getExternalAttributes() {\nreturn externalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
                                    "method_body": "public byte[] getLocalFileDataExtra() {\nbyte[] extra = getExtra();\nreturn extra != null ? extra : new byte[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getCentralDirectoryExtra()[B",
                                    "method_body": "public byte[] getCentralDirectoryExtra() {\nreturn ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes(I)[B",
                                    "method_body": "public static byte[] getBytes(int value) {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(J)[B",
                                    "method_body": "public static byte[] toDosTime(long t) {\nCalendar c = Calendar.getInstance();\nc.setTimeInMillis(t);\nint year = c.get(Calendar.YEAR);\nif (year < 1980) {\nint month = c.get(Calendar.MONTH) + 1;\nlong value =  ((year - 1980) << 25)\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:adjustToLong(I)J",
                                    "method_body": "public static long adjustToLong(int i) {\nif (i < 0) {\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\nimplementations = new HashMap();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class c) {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeCentralDirectoryData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getCentralDirectoryLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\nbyte[] local = data[i].getCentralDirectoryData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\npublic JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<init>(Ljava/lang/String;)V",
                                    "method_body": "private UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
                                    "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS =\npublic static final UnicodeExtraFieldPolicy NEVER =\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nprivate UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\nthrows IOException {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = new RandomAccessFile(f, \"r\");\nboolean success = false;\nMap entriesWithoutEFS = populateFromCentralDirectory();\nif (!success) {\narchive.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
                                    "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map populateFromCentralDirectory()\nHashMap noEFS = new HashMap();\npositionAtCentralDirectory();\nbyte[] cfh = new byte[CFH_LEN];\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nfinal long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\nif (sig != cfhSig && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nboolean found = false;\nlong off = archive.length() - MIN_EOCD_SIZE;\nlong stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE);\nif (off >= 0) {\narchive.seek(off);\nbyte[] sig = ZipArchiveOutputStream.EOCD_SIG;\nint curr = archive.read();\nwhile (off >= stopSearching && curr != -1) {\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\nif (!found) {\narchive.seek(off + CFD_LOCATOR_OFFSET);\nbyte[] cfdOffset = new byte[WORD];\narchive.readFully(cfdOffset);\narchive.seek(ZipLong.getValue(cfdOffset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:startsWithLocalFileHeader()Z",
                                    "method_body": "private boolean startsWithLocalFileHeader() throws IOException {\narchive.seek(0);\nfinal byte[] start = new byte[WORD];\narchive.readFully(start);\nfor (int i = 0; i < start.length; i++) {\nif (start[i] != ZipArchiveOutputStream.LFH_SIG[i]) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setEncoding(Ljava/lang/String;)V",
                                    "method_body": "public void setEncoding(final String encoding) {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nuseEFS &= ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setUseLanguageEncodingFlag(Z)V",
                                    "method_body": "public void setUseLanguageEncodingFlag(boolean b) {\nuseEFS = b && ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setCreateUnicodeExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveOutputStream$UnicodeExtraFieldPolicy;)V",
                                    "method_body": "public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b) {\ncreateUnicodeExtraFields = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int offset, int length) throws IOException {\nif (entry.getMethod() == DEFLATED) {\nif (length > 0) {\nif (!def.finished()) {\nif (length <= DEFLATER_BLOCK_SIZE) {\ndef.setInput(b, offset, length);\ndeflateUntilInputIsNeeded();\ncrc.update(b, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflateUntilInputIsNeeded()V",
                                    "method_body": "private void deflateUntilInputIsNeeded() throws IOException {\nwhile (!def.needsInput()) {\ndeflate();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:addExtraField(Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void addExtraField(ZipExtraField ze) {\nif (extraFields == null) {\nextraFields = new LinkedHashMap();\nextraFields.put(ze.getHeaderId(), ze);\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "protected AbstractUnicodeExtraField(String text, byte[] bytes, int off,\nint len) {\nCRC32 crc32 = new CRC32();\ncrc32.update(bytes, off, len);\nnameCRC32 = crc32.getValue();\nunicodeName = text.getBytes(\"UTF-8\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:assembleData()V",
                                    "method_body": "private void assembleData() {\nif (unicodeName == null) {\ndata = new byte[5 + unicodeName.length];\ndata[0] = 0x01;\nSystem.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4);\nSystem.arraycopy(unicodeName, 0, data, 5, unicodeName.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryData()[B",
                                    "method_body": "public byte[] getCentralDirectoryData() {\nif (data == null) {\nreturn data;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getCentralDirectoryLength() {\nif (data == null) {\nassembleData();\nreturn new ZipShort(data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn getCentralDirectoryData();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn getCentralDirectoryLength();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "public UnicodePathExtraField(String text, byte[] bytes, int off, int len) {\nsuper(text, bytes, off, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:appendSurrogate(Ljava/nio/ByteBuffer;C)V",
                                    "method_body": "static void appendSurrogate(ByteBuffer bb, char c) {\nbb.put((byte) '%');\nbb.put((byte) 'U');\nbb.put(HEX_DIGITS[(c >> 12)&0x0f]);\nbb.put(HEX_DIGITS[(c >> 8)&0x0f]);\nbb.put(HEX_DIGITS[(c >> 4)&0x0f]);\nbb.put(HEX_DIGITS[c & 0x0f]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:getEncoding()Lorg/apache/commons/compress/archivers/zip/Simple8BitZipEncoding;",
                                    "method_body": "public synchronized Simple8BitZipEncoding getEncoding() {\nif (this.encoding == null) {\nthis.encoding = new Simple8BitZipEncoding(this.highChars);\nreturn this.encoding;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding:<init>([C)V",
                                    "method_body": "public Simple8BitZipEncoding(char[] highChars) {\nthis.highChars = (char[]) highChars.clone();\nList temp = new ArrayList(this.highChars.length);\nbyte code = 127;\nfor (int i = 0; i < this.highChars.length; ++i) {\ntemp.add(new Simple8BitChar(++code, this.highChars[i]));\nCollections.sort(temp);\nthis.reverseMapping = Collections.unmodifiableList(temp);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding:canEncodeChar(C)Z",
                                    "method_body": "public boolean canEncodeChar(char c) {\nif (c >= 0 && c < 128) {\nreturn true;\nSimple8BitChar r = this.encodeHighChar(c);\nreturn r != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding:pushEncodedChar(Ljava/nio/ByteBuffer;C)Z",
                                    "method_body": "public boolean pushEncodedChar(ByteBuffer bb, char c) {\nif (c >= 0 && c < 128) {\nbb.put((byte) c);\nreturn true;\nSimple8BitChar r = this.encodeHighChar(c);\nif (r == null) {\nreturn false;\nbb.put(r.code);\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding:encodeHighChar(C)Lorg/apache/commons/compress/archivers/zip/Simple8BitZipEncoding$Simple8BitChar;",
                                    "method_body": "private Simple8BitChar encodeHighChar(char c) {\nint i0 = 0;\nint i1 = this.reverseMapping.size();\nwhile (i1 > i0) {\nint i = i0 + (i1 - i0) / 2;\nSimple8BitChar m = (Simple8BitChar) this.reverseMapping.get(i);\nif (m.unicode == c) {\nreturn m;\nif (m.unicode < c) {\ni0 = i + 1;\ni1 = i;\n}\nif (i0 >= this.reverseMapping.size()) {\nSimple8BitChar r = (Simple8BitChar) this.reverseMapping.get(i0);\nif (r.unicode != c) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding:canEncode(Ljava/lang/String;)Z",
                                    "method_body": "public boolean canEncode(String name) {\nfor (int i=0;i<name.length();++i) {\nchar c = name.charAt(i);\nif (!this.canEncodeChar(c)) {\nreturn false;\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(String name) {\nByteBuffer out = ByteBuffer.allocate(name.length()\nfor (int i=0;i<name.length();++i) {\nchar c = name.charAt(i);\nif (out.remaining() < 6) {\nif (!this.pushEncodedChar(out,c)) {\nZipEncodingHelper.appendSurrogate(out,c);\nout.limit(out.position());\nout.rewind();\nreturn out;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding$Simple8BitChar:<init>(BC)V",
                                    "method_body": "Simple8BitChar(byte code, char unicode) {\nthis.code = code;\nthis.unicode = unicode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding$Simple8BitChar:compareTo(Ljava/lang/Object;)I",
                                    "method_body": "public int compareTo(Object o) {\nSimple8BitChar a = (Simple8BitChar) o;\nreturn this.unicode - a.unicode;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 5,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.Maven221MultiVolumeTest.testRead7ZipMultiVolumeArchiveForStream",
                            "test_body": "69: public void testRead7ZipMultiVolumeArchiveForStream() throws IOException,\n70: URISyntaxException {\n71: 72: URL zip = getClass().getResource(\"/apache-maven-2.2.1.zip.001\");\n73: FileInputStream archive = new FileInputStream(\n74: new File(new URI(zip.toString())));\n75: ZipArchiveInputStream zi = null;\n76: try {\n77: zi = new ZipArchiveInputStream(archive,null,false);\n78: 79: // these are the entries that are supposed to be processed\n80: // correctly without any problems\n81: for (int i = 0; i < ENTRIES.length; i++) {\n82: assertEquals(ENTRIES[i], zi.getNextEntry().getName());\n83: }\n84: 85: // this is the last entry that is truncated\n86: ArchiveEntry lastEntry = zi.getNextEntry();\n87: assertEquals(LAST_ENTRY_NAME, lastEntry.getName());\n88: byte [] buffer = new byte [4096];\n89: 90: // before the fix, we'd get 0 bytes on this read and all\n91: // subsequent reads thus a client application might enter\n92: // an infinite loop after the fix, we should get an\n93: // exception\n94: try {\n95: int read = 0;\n96: while ((read = zi.read(buffer)) > 0) { }\n97: fail(\"shouldn't be able to read from truncated entry\");\n98: } catch (IOException e) {\n99: assertEquals(\"Truncated ZIP file\", e.getMessage());\n100: }\n101: 102: // and now we get another entry, which should also yield\n103: // an exception\n104: try {\n105: zi.getNextEntry();\n106: fail(\"shouldn't be able to read another entry from truncated\"\n107: + \" file\");\n108: } catch (IOException e) {\n109: // this is to be expected\n110: }\n111: } finally {\n112: if (zi != null) {\n113: zi.close();\n114: }\n115: }\n116: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream,\nboolean useUnicodeExtraFields) {\nzipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\nin = new PushbackInputStream(inputStream, buf.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:getNextZipEntry()Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;",
                                    "method_body": "public ZipArchiveEntry getNextZipEntry() throws IOException {\nif (closed || hitCentralDirectory) {\nif (current != null) {\ncloseEntry();\nbyte[] lfh = new byte[LFH_LEN];\nreadFully(lfh);\n}\nZipLong sig = new ZipLong(lfh);\nif (sig.equals(ZipLong.CFH_SIG)) {\nif (!sig.equals(ZipLong.LFH_SIG)) {\nint off = WORD;\ncurrent = new ZipArchiveEntry();\nint versionMadeBy = ZipShort.getValue(lfh, off);\noff += SHORT;\ncurrent.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT)\nfinal int generalPurposeFlag = ZipShort.getValue(lfh, off);\nfinal boolean hasEFS =\nfinal ZipEncoding entryEncoding =\nhasDataDescriptor = (generalPurposeFlag & 8) != 0;\noff += SHORT;\ncurrent.setMethod(ZipShort.getValue(lfh, off));\noff += SHORT;\nlong time = ZipUtil.dosToJavaTime(ZipLong.getValue(lfh, off));\ncurrent.setTime(time);\noff += WORD;\nif (!hasDataDescriptor) {\ncurrent.setCrc(ZipLong.getValue(lfh, off));\noff += WORD;\ncurrent.setCompressedSize(ZipLong.getValue(lfh, off));\noff += WORD;\ncurrent.setSize(ZipLong.getValue(lfh, off));\noff += WORD;\nint fileNameLen = ZipShort.getValue(lfh, off);\noff += SHORT;\nint extraLen = ZipShort.getValue(lfh, off);\noff += SHORT;\nbyte[] fileName = new byte[fileNameLen];\nreadFully(fileName);\ncurrent.setName(entryEncoding.decode(fileName));\nbyte[] extraData = new byte[extraLen];\nreadFully(extraData);\ncurrent.setExtra(extraData);\nif (!hasEFS && useUnicodeExtraFields) {\nreturn current;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:getNextEntry()Lorg/apache/commons/compress/archivers/ArchiveEntry;",
                                    "method_body": "public ArchiveEntry getNextEntry() throws IOException {\nreturn getNextZipEntry();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] buffer, int start, int length) throws IOException {\nif (closed) {\nif (inf.finished() || current == null) {\nreturn -1;\nif (start <= buffer.length && length >= 0 && start >= 0\nif (current.getMethod() == ZipArchiveOutputStream.STORED) {\nint csize = (int) current.getSize();\nif (readBytesOfEntry >= csize) {\nreturn -1;\nif (inf.needsInput()) {\nfill();\nif (lengthOfLastRead > 0) {\nbytesReadFromStream += lengthOfLastRead;\nint read = 0;\nread = inf.inflate(buffer, start, length);\n}\nif (read == 0 && inf.finished()) {\ncrc.update(buffer, start, read);\nreturn read;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!closed) {\nclosed = true;\nin.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:skip(J)J",
                                    "method_body": "public long skip(long value) throws IOException {\nif (value >= 0) {\nlong skipped = 0;\nbyte[] b = new byte[1024];\nwhile (skipped != value) {\nlong rem = value - skipped;\nint x = read(b, 0, (int) (b.length > rem ? rem : b.length));\nif (x == -1) {\nreturn skipped;\nskipped += x;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:closeEntry()V",
                                    "method_body": "private void closeEntry() throws IOException {\nif (closed) {\nif (current == null) {\nskip(Long.MAX_VALUE);\nif (current.getMethod() == ZipArchiveOutputStream.DEFLATED) {\ninB = inf.getTotalIn();\ninB = readBytesOfEntry;\nint diff = 0;\nif ((diff = bytesReadFromStream - inB) != 0) {\n((PushbackInputStream) in).unread(buf,\nif (hasDataDescriptor) {\ninf.reset();\nreadBytesOfEntry = offsetInBuffer = bytesReadFromStream =\ncrc.reset();\ncurrent = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:fill()V",
                                    "method_body": "private void fill() throws IOException {\nif (closed) {\nif ((lengthOfLastRead = in.read(buf)) > 0) {\ninf.setInput(buf, 0, lengthOfLastRead);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readFully([B)V",
                                    "method_body": "private void readFully(byte[] b) throws IOException {\nint count = 0, x = 0;\nwhile (count != b.length) {\ncount += x = in.read(b, count, b.length - count);\nif (x == -1) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>([B)V",
                                    "method_body": "public ZipLong (byte[] bytes) {\nthis(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>([BI)V",
                                    "method_body": "public ZipLong (byte[] bytes, int offset) {\nvalue = ZipLong.getValue(bytes, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue()J",
                                    "method_body": "public long getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object o) {\nif (o == null || !(o instanceof ZipLong)) {\nreturn value == ((ZipLong) o).getValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map simpleEncodings;\nsimpleEncodings = new HashMap();\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\nencoding = System.getProperty(\"file.encoding\");\nreturn UTF8.equalsIgnoreCase(encoding)\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data,this.charset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "protected ZipArchiveEntry() {\nsuper(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setPlatform(I)V",
                                    "method_body": "protected void setPlatform(int platform) {\nthis.platform = platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void setExtraFields(ZipExtraField[] fields) {\nextraFields = new LinkedHashMap();\nfor (int i = 0; i < fields.length; i++) {\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields() {\nif (extraFields == null) {\nZipExtraField[] result = new ZipExtraField[extraFields.size()];\nreturn (ZipExtraField[]) extraFields.values().toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra([B)V",
                                    "method_body": "public void setExtra(byte[] extra) throws RuntimeException {\nZipExtraField[] local = ExtraFieldUtils.parse(extra, true);\nmergeExtraFields(local, true);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "protected void setName(String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:mergeExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;Z)V",
                                    "method_body": "private void mergeExtraFields(ZipExtraField[] f, boolean local)\nif (extraFields == null) {\nsetExtraFields(f);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\npublic JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([BI)I",
                                    "method_body": "public static int getValue(byte[] bytes, int offset) {\nint value = (bytes[offset + 1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\nimplementations = new HashMap();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class c) {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:parse([BZ)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField[] parse(byte[] data, boolean local)\nList v = new ArrayList();\nint start = 0;\nwhile (start <= data.length - WORD) {\nZipExtraField[] result = new ZipExtraField[v.size()];\nreturn (ZipExtraField[]) v.toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:dosToJavaTime(J)J",
                                    "method_body": "public static long dosToJavaTime(long dosTime) {\nCalendar cal = Calendar.getInstance();\ncal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\ncal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\ncal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);\ncal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);\ncal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);\ncal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);\nreturn cal.getTime().getTime();\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 6,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveEntryTest.testNotEquals",
                            "test_body": "227: public void testNotEquals() {\n228: ZipArchiveEntry entry1 = new ZipArchiveEntry(\"foo\");\n229: ZipArchiveEntry entry2 = new ZipArchiveEntry(\"bar\");\n230: assertFalse(entry1.equals(entry2));\n231: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/util/zip/ZipEntry;)V",
                                    "method_body": "private int method = -1;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate LinkedHashMap/*<ZipShort, ZipExtraField>*/ extraFields = null;\nprivate String name = null;\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object obj) {\nif (this == obj) {\nif (obj == null || getClass() != obj.getClass()) {\nZipArchiveEntry other = (ZipArchiveEntry) obj;\nif (name == null) {\nif (other.name != null) {\nreturn true;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 7,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarUtilsTest.testRoundTripNames",
                            "test_body": "120: public void testRoundTripNames(){\n121: checkName(\"\");\n122: checkName(\"The quick brown fox\\n\");\n123: checkName(\"\\177\");\n124: // checkName(\"\\0\"); // does not work, because NUL is ignored\n125: // COMPRESS-114\n126: checkName(\"0302-0601-3\u00b1\u00b1\u00b1F06\u00b1W220\u00b1ZB\u00b1LALALA\u00b1\u00b1\u00b1\u00b1\u00b1\u00b1\u00b1\u00b1\u00b1\u00b1CAN\u00b1\u00b1DC\u00b1\u00b1\u00b104\u00b1060302\u00b1MOE.model\");\n127: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BII)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset, final int length) {\nStringBuffer result = new StringBuffer(length);\nint          end = offset + length;\nfor (int i = offset; i < end; ++i) {\nif (buffer[i] == 0) {\nbreak;\nresult.append((char) buffer[i]);\nreturn result.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatNameBytes(Ljava/lang/String;[BII)I",
                                    "method_body": "public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {\nfor (i = 0; i < length && i < name.length(); ++i) {\nbuf[offset + i] = (byte) name.charAt(i);\nfor (; i < length; ++i) {\nbuf[offset + i] = 0;\nreturn offset + length;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 8,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarUtilsTest.testParseOctalInvalid",
                            "test_body": "61: public void testParseOctalInvalid() throws Exception{\n62: byte [] buffer;\n63: buffer=new byte[0]; // empty byte array\n64: try {\n65: TarUtils.parseOctal(buffer,0, buffer.length);\n66: fail(\"Expected IllegalArgumentException - should be at least 2 bytes long\");\n67: } catch (IllegalArgumentException expected) {\n68: }\n69: buffer=new byte[]{0}; // 1-byte array\n70: try {\n71: TarUtils.parseOctal(buffer,0, buffer.length);\n72: fail(\"Expected IllegalArgumentException - should be at least 2 bytes long\");\n73: } catch (IllegalArgumentException expected) {\n74: }\n75: buffer=new byte[]{0,0,' '}; // not all NULs\n76: try {\n77: TarUtils.parseOctal(buffer,0, buffer.length);\n78: fail(\"Expected IllegalArgumentException - not all NULs\");\n79: } catch (IllegalArgumentException expected) {\n80: }\n81: buffer=new byte[]{' ',0,0,0}; // not all NULs\n82: try {\n83: TarUtils.parseOctal(buffer,0, buffer.length);\n84: fail(\"Expected IllegalArgumentException - not all NULs\");\n85: } catch (IllegalArgumentException expected) {\n86: }\n87: buffer = \"abcdef \".getBytes(\"UTF-8\"); // Invalid input\n88: try {\n89: TarUtils.parseOctal(buffer,0, buffer.length);\n90: fail(\"Expected IllegalArgumentException\");\n91: } catch (IllegalArgumentException expected) {\n92: }\n93: buffer = \"77777777777\".getBytes(\"UTF-8\"); // Invalid input - no trailer\n94: try {\n95: TarUtils.parseOctal(buffer,0, buffer.length);\n96: fail(\"Expected IllegalArgumentException - no trailer\");\n97: } catch (IllegalArgumentException expected) {\n98: }\n99: buffer = \" 0 07 \".getBytes(\"UTF-8\"); // Invalid - embedded space\n100: try {\n101: TarUtils.parseOctal(buffer,0, buffer.length);\n102: fail(\"Expected IllegalArgumentException - embedded space\");\n103: } catch (IllegalArgumentException expected) {\n104: }\n105: buffer = \" 0\\00007 \".getBytes(\"UTF-8\"); // Invalid - embedded NUL\n106: try {\n107: TarUtils.parseOctal(buffer,0, buffer.length);\n108: fail(\"Expected IllegalArgumentException - embedded NUL\");\n109: } catch (IllegalArgumentException expected) {\n110: }\n111: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nboolean stillPadding = true;\nint     end = offset + length;\nint     start = offset;\nfor (int i = start; i < end; i++){\nreturn result;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 9,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest.testCount",
                            "test_body": "31: public void testCount() throws Exception {\n32: File f = File.createTempFile(\"commons-compress-tarcount\", \".tar\");\n33: f.deleteOnExit();\n34: FileOutputStream fos = new FileOutputStream(f);\n35: 36: ArchiveOutputStream tarOut = new ArchiveStreamFactory()\n37: .createArchiveOutputStream(ArchiveStreamFactory.TAR, fos);\n38: 39: File file1 = getFile(\"test1.xml\");\n40: TarArchiveEntry sEntry = new TarArchiveEntry(file1);\n41: tarOut.putArchiveEntry(sEntry);\n42: 43: FileInputStream in = new FileInputStream(file1);\n44: byte[] buf = new byte[8192];\n45: 46: int read = 0;\n47: while ((read = in.read(buf)) > 0) {\n48: tarOut.write(buf, 0, read);\n49: }\n50: 51: in.close();\n52: tarOut.closeArchiveEntry();\n53: tarOut.close();\n54: 55: assertEquals(f.length(), tarOut.getBytesWritten());\n56: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveOutputStream(Ljava/lang/String;Ljava/io/OutputStream;)Lorg/apache/commons/compress/archivers/ArchiveOutputStream;",
                                    "method_body": "public ArchiveOutputStream createArchiveOutputStream(\nif (archiverName == null) {\nif (out == null) {\nif (AR.equalsIgnoreCase(archiverName)) {\nif (ZIP.equalsIgnoreCase(archiverName)) {\nif (TAR.equalsIgnoreCase(archiverName)) {\nreturn new TarArchiveOutputStream(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveOutputStream:<init>()V",
                                    "method_body": "private final byte[] oneByte = new byte[1];\nprivate long bytesWritten = 0;\n* {@link #closeArchiveEntry()} to complete the process."
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveOutputStream:count(I)V",
                                    "method_body": "protected void count(int written) {\ncount((long) written);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveOutputStream:count(J)V",
                                    "method_body": "protected void count(long written) {\nif (written != -1) {\nbytesWritten = bytesWritten + written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveOutputStream:getBytesWritten()J",
                                    "method_body": "public long getBytesWritten() {\nreturn bytesWritten;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public TarArchiveOutputStream(OutputStream os) {\nthis(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;II)V",
                                    "method_body": "public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) {\nout = new CountingOutputStream(os);\nthis.buffer = new TarBuffer(out, blockSize, recordSize);\nthis.assemLen = 0;\nthis.assemBuf = new byte[recordSize];\nthis.recordBuf = new byte[recordSize];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif (finished) {\nif(haveUnclosedEntry) {\nwriteEOFRecord();\nwriteEOFRecord();\nbuffer.flushBlock();\nfinished = true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif(!finished) {\nfinish();\nif (!closed) {\nbuffer.close();\nout.close();\nclosed = true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\nif(finished) {\nTarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\nif (entry.getName().length() >= TarConstants.NAMELEN) {\nentry.writeEntryHeader(recordBuf);\nbuffer.writeRecord(recordBuf);\ncurrBytes = 0;\nif (entry.isDirectory()) {\ncurrSize = entry.getSize();\ncurrName = entry.getName();\nhaveUnclosedEntry = true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif(finished) {\nif (!haveUnclosedEntry){\nif (assemLen > 0) {\nfor (int i = assemLen; i < assemBuf.length; ++i) {\nassemBuf[i] = 0;\nbuffer.writeRecord(assemBuf);\ncurrBytes += assemLen;\nassemLen = 0;\nif (currBytes < currSize) {\nhaveUnclosedEntry = false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\nif ((currBytes + numToWrite) > currSize) {\nif (assemLen > 0) {\nwhile (numToWrite > 0) {\nif (numToWrite < recordBuf.length) {\nSystem.arraycopy(wBuf, wOffset, assemBuf, assemLen,\nassemLen += numToWrite;\nbreak;\ncount(numToWrite);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:writeEOFRecord()V",
                                    "method_body": "private void writeEOFRecord() throws IOException {\nfor (int i = 0; i < recordBuf.length; ++i) {\nrecordBuf[i] = 0;\nbuffer.writeRecord(recordBuf);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "private final AtomicLong bytesWritten = new AtomicLong();\nsuper(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int off, int len) throws IOException {\nout.write(b, off, len);\ncount(len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:count(J)V",
                                    "method_body": "protected void count(long written) {\nif (written != -1) {\nbytesWritten.addAndGet(written);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/OutputStream;II)V",
                                    "method_body": "public TarBuffer(OutputStream outStream, int blockSize, int recordSize) {\nthis.inStream = null;\nthis.outStream = outStream;\nthis.initialize(blockSize, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:initialize(II)V",
                                    "method_body": "private void initialize(int blockSize, int recordSize) {\nthis.blockSize = blockSize;\nthis.recordSize = recordSize;\nthis.recsPerBlock = (this.blockSize / this.recordSize);\nthis.blockBuffer = new byte[this.blockSize];\nif (this.inStream != null) {\nthis.currBlkIdx = 0;\nthis.currRecIdx = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:writeRecord([B)V",
                                    "method_body": "public void writeRecord(byte[] record) throws IOException {\nif (outStream == null) {\nif (record.length != recordSize) {\nif (currRecIdx >= recsPerBlock) {\nSystem.arraycopy(record, 0, blockBuffer,\ncurrRecIdx++;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:writeBlock()V",
                                    "method_body": "private void writeBlock() throws IOException {\nif (outStream == null) {\noutStream.write(blockBuffer, 0, blockSize);\noutStream.flush();\ncurrRecIdx = 0;\ncurrBlkIdx++;\nArrays.fill(blockBuffer, (byte) 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:flushBlock()V",
                                    "method_body": "void flushBlock() throws IOException {\nif (outStream == null) {\nif (currRecIdx > 0) {\nwriteBlock();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:close()V",
                                    "method_body": "public void close() throws IOException {\nif (outStream != null) {\nflushBlock();\nif (outStream != System.out\noutStream.close();\noutStream = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry () {\nthis.magic = MAGIC_POSIX;\nthis.version = VERSION_POSIX;\nthis.name = \"\";\nthis.linkName = \"\";\nString user = System.getProperty(\"user.name\", \"\");\nif (user.length() > MAX_NAMELEN) {\nthis.userId = 0;\nthis.groupId = 0;\nthis.userName = user;\nthis.groupName = \"\";\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/io/File;)V",
                                    "method_body": "public TarArchiveEntry(File file) {\nthis(file, normalizeFileName(file.getPath(), false));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/io/File;Ljava/lang/String;)V",
                                    "method_body": "public TarArchiveEntry(File file, String fileName) {\nthis();\nthis.file = file;\nthis.linkName = \"\";\nif (file.isDirectory()) {\nthis.mode = DEFAULT_FILE_MODE;\nthis.linkFlag = LF_NORMAL;\nthis.size = file.length();\nthis.name = fileName;\nthis.modTime = file.lastModified() / MILLIS_PER_SECOND;\nthis.devMajor = 0;\nthis.devMinor = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nif (file != null) {\nreturn file.isDirectory();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:writeEntryHeader([B)V",
                                    "method_body": "public void writeEntryHeader(byte[] outbuf) {\nint offset = 0;\noffset = TarUtils.formatNameBytes(name, outbuf, offset, NAMELEN);\noffset = TarUtils.formatOctalBytes(mode, outbuf, offset, MODELEN);\noffset = TarUtils.formatOctalBytes(userId, outbuf, offset, UIDLEN);\noffset = TarUtils.formatOctalBytes(groupId, outbuf, offset, GIDLEN);\noffset = TarUtils.formatLongOctalBytes(size, outbuf, offset, SIZELEN);\noffset = TarUtils.formatLongOctalBytes(modTime, outbuf, offset, MODTIMELEN);\nint csOffset = offset;\nfor (int c = 0; c < CHKSUMLEN; ++c) {\noutbuf[offset++] = (byte) ' ';\noutbuf[offset++] = linkFlag;\noffset = TarUtils.formatNameBytes(linkName, outbuf, offset, NAMELEN);\noffset = TarUtils.formatNameBytes(magic, outbuf, offset, MAGICLEN);\noffset = TarUtils.formatNameBytes(version, outbuf, offset, VERSIONLEN);\noffset = TarUtils.formatNameBytes(userName, outbuf, offset, UNAMELEN);\noffset = TarUtils.formatNameBytes(groupName, outbuf, offset, GNAMELEN);\noffset = TarUtils.formatOctalBytes(devMajor, outbuf, offset, DEVLEN);\noffset = TarUtils.formatOctalBytes(devMinor, outbuf, offset, DEVLEN);\nwhile (offset < outbuf.length) {\noutbuf[offset++] = 0;\nlong chk = TarUtils.computeCheckSum(outbuf);\nTarUtils.formatCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:normalizeFileName(Ljava/lang/String;Z)Ljava/lang/String;",
                                    "method_body": "private static String normalizeFileName(String fileName,\nString osname = System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH);\nif (osname != null) {\nif (osname.startsWith(\"windows\")) {\n} else if (osname.indexOf(\"netware\") > -1) {\nfileName = fileName.replace(File.separatorChar, '/');\nwhile (!preserveLeadingSlashes && fileName.startsWith(\"/\")) {\nreturn fileName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatNameBytes(Ljava/lang/String;[BII)I",
                                    "method_body": "public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {\nfor (i = 0; i < length && i < name.length(); ++i) {\nbuf[offset + i] = (byte) name.charAt(i);\nfor (; i < length; ++i) {\nbuf[offset + i] = 0;\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatUnsignedOctalString(J[BII)V",
                                    "method_body": "public static void formatUnsignedOctalString(final long value, byte[] buffer,\nint remaining = length;\nremaining--;\nif (value == 0) {\nbuffer[offset + remaining--] = (byte) '0';\nlong val = value;\nfor (; remaining >= 0 && val != 0; --remaining) {\nbuffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));\nval = val >>> 3;\nif (val != 0){\nfor (; remaining >= 0; --remaining) { // leading zeros\nbuffer[offset + remaining] = (byte) '0';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatOctalBytes(J[BII)I",
                                    "method_body": "public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {\nint idx=length-2; // For space and trailing null\nformatUnsignedOctalString(value, buf, offset, idx);\nbuf[offset + idx++] = (byte) ' '; // Trailing space\nbuf[offset + idx]   = 0; // Trailing null\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatLongOctalBytes(J[BII)I",
                                    "method_body": "public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {\nint idx=length-1; // For space\nformatUnsignedOctalString(value, buf, offset, idx);\nbuf[offset + idx] = (byte) ' '; // Trailing space\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatCheckSumOctalBytes(J[BII)I",
                                    "method_body": "public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {\nint idx=length-2; // for NUL and space\nformatUnsignedOctalString(value, buf, offset, idx);\nbuf[offset + idx++]   = 0; // Trailing null\nbuf[offset + idx]     = (byte) ' '; // Trailing space\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:computeCheckSum([B)J",
                                    "method_body": "public static long computeCheckSum(final byte[] buf) {\nlong sum = 0;\nfor (int i = 0; i < buf.length; ++i) {\nsum += BYTE_MASK & buf[i];\nreturn sum;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 10,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testReadWinZipArchive",
                            "test_body": "126: public void testReadWinZipArchive() throws IOException, URISyntaxException {\n127: URL zip = getClass().getResource(\"/utf8-winzip-test.zip\");\n128: File archive = new File(new URI(zip.toString()));\n129: ZipFile zf = null;\n130: try {\n131: zf = new ZipFile(archive, null, true);\n132: assertCanRead(zf, ASCII_TXT);\n133: assertCanRead(zf, EURO_FOR_DOLLAR_TXT);\n134: assertCanRead(zf, OIL_BARREL_TXT);\n135: } finally {\n136: ZipFile.closeQuietly(zf);\n137: }\n138: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int BYTE_1 = 1;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes();\nstatic final byte[] DD_SIG = ZipLong.DD_SIG.getBytes();\nstatic final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes();\nstatic final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\nstatic final byte[] ZIP64_EOCD_SIG = ZipLong.getBytes(0X06064B50L);\nstatic final byte[] ZIP64_EOCD_LOC_SIG = ZipLong.getBytes(0X07064B50L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "static final String UTF8 = \"UTF8\";\nstatic final ZipEncoding UTF8_ZIP_ENCODING = new FallbackZipEncoding(UTF8);\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\nencoding = System.getProperty(\"file.encoding\");\nreturn UTF8.equalsIgnoreCase(encoding)\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data,this.charset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/util/zip/ZipEntry;)V",
                                    "method_body": "private long size = SIZE_UNKNOWN;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate LinkedHashMap<ZipShort, ZipExtraField> extraFields = null;\nprivate UnparseableExtraFieldData unparseableExtra = null;\nprivate String name = null;\nprivate byte[] rawName = null;\nprivate GeneralPurposeBit gpb = new GeneralPurposeBit();\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "protected ZipArchiveEntry() {\nthis(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getMethod()I",
                                    "method_body": "public int getMethod() {\nreturn method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setMethod(I)V",
                                    "method_body": "public void setMethod(int method) {\nif (method < 0) {\nthis.method = method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setInternalAttributes(I)V",
                                    "method_body": "public void setInternalAttributes(int value) {\ninternalAttributes = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExternalAttributes(J)V",
                                    "method_body": "public void setExternalAttributes(long value) {\nexternalAttributes = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setPlatform(I)V",
                                    "method_body": "protected void setPlatform(int platform) {\nthis.platform = platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void setExtraFields(ZipExtraField[] fields) {\nextraFields = new LinkedHashMap<ZipShort, ZipExtraField>();\nfor (int i = 0; i < fields.length; i++) {\nif (fields[i] instanceof UnparseableExtraFieldData) {\nextraFields.put(fields[i].getHeaderId(), fields[i]);\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields(Z)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields(boolean includeUnparseable) {\nif (extraFields == null) {\nList<ZipExtraField> result =\nif (includeUnparseable && unparseableExtra != null) {\nreturn result.toArray(new ZipExtraField[0]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField getExtraField(ZipShort type) {\nif (extraFields != null) {\nreturn extraFields.get(type);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra([B)V",
                                    "method_body": "public void setExtra(byte[] extra) throws RuntimeException {\nZipExtraField[] local =\nmergeExtraFields(local, true);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields(true)));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setCentralDirectoryExtra([B)V",
                                    "method_body": "public void setCentralDirectoryExtra(byte[] b) {\nZipExtraField[] central =\nmergeExtraFields(central, false);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "protected void setName(String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nif (size < 0) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;[B)V",
                                    "method_body": "protected void setName(String name, byte[] rawName) {\nsetName(name);\nthis.rawName = rawName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getGeneralPurposeBit()Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "public GeneralPurposeBit getGeneralPurposeBit() {\nreturn gpb;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setGeneralPurposeBit(Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;)V",
                                    "method_body": "public void setGeneralPurposeBit(GeneralPurposeBit b) {\ngpb = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:mergeExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;Z)V",
                                    "method_body": "private void mergeExtraFields(ZipExtraField[] f, boolean local)\nif (extraFields == null) {\nsetExtraFields(f);\nfor (int i = 0; i < f.length; i++) {\nif (f[i] instanceof UnparseableExtraFieldData) {\nexisting = getExtraField(f[i].getHeaderId());\nif (existing == null) {\nif (local) {\nbyte[] b = f[i].getLocalFileDataData();\nexisting.parseFromLocalFileData(b, 0, b.length);\n} else {\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:<init>()V",
                                    "method_body": "public static final int UFT8_NAMES_FLAG = 1 << 11;\nprivate boolean languageEncodingFlag = false;\nprivate boolean dataDescriptorFlag = false;\nprivate boolean encryptionFlag = false;\nprivate boolean strongEncryptionFlag = false;\npublic GeneralPurposeBit() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesUTF8ForNames()Z",
                                    "method_body": "public boolean usesUTF8ForNames() {\nreturn languageEncodingFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useUTF8ForNames(Z)V",
                                    "method_body": "public void useUTF8ForNames(boolean b) {\nlanguageEncodingFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useDataDescriptor(Z)V",
                                    "method_body": "public void useDataDescriptor(boolean b) {\ndataDescriptorFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesEncryption()Z",
                                    "method_body": "public boolean usesEncryption() {\nreturn encryptionFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useEncryption(Z)V",
                                    "method_body": "public void useEncryption(boolean b) {\nencryptionFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useStrongEncryption(Z)V",
                                    "method_body": "public void useStrongEncryption(boolean b) {\nstrongEncryptionFlag = b;\nif (b) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:parse([BI)Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "public static GeneralPurposeBit parse(final byte[] data, final int offset) {\nfinal int generalPurposeFlag = ZipShort.getValue(data, offset);\nGeneralPurposeBit b = new GeneralPurposeBit();\nb.useDataDescriptor((generalPurposeFlag & DATA_DESCRIPTOR_FLAG) != 0);\nb.useUTF8ForNames((generalPurposeFlag & UFT8_NAMES_FLAG) != 0);\nb.useStrongEncryption((generalPurposeFlag & STRONG_ENCRYPTION_FLAG)\nb.useEncryption((generalPurposeFlag & ENCRYPTION_FLAG) != 0);\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>([BI)V",
                                    "method_body": "public ZipShort (byte[] bytes, int offset) {\nvalue = ZipShort.getValue(bytes, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([BI)I",
                                    "method_body": "public static int getValue(byte[] bytes, int offset) {\nint value = (bytes[offset + 1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([B)I",
                                    "method_body": "public static int getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object o) {\nif (o == null || !(o instanceof ZipShort)) {\nreturn value == ((ZipShort) o).getValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:dosToJavaTime(J)J",
                                    "method_body": "public static long dosToJavaTime(long dosTime) {\nCalendar cal = Calendar.getInstance();\ncal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\ncal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\ncal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);\ncal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);\ncal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);\ncal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);\nreturn cal.getTime().getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:setNameAndCommentFromExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;[B[B)V",
                                    "method_body": "static void setNameAndCommentFromExtraFields(ZipArchiveEntry ze,\nUnicodePathExtraField name = (UnicodePathExtraField)\nString originalName = ze.getName();\nString newName = getUnicodeStringIfOriginalMatches(name,\nif (newName != null && !originalName.equals(newName)) {\nze.setName(newName);\nif (commentBytes != null && commentBytes.length > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:getUnicodeStringIfOriginalMatches(Lorg/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField;[B)Ljava/lang/String;",
                                    "method_body": "String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f,\nif (f != null) {\nCRC32 crc32 = new CRC32();\ncrc32.update(orig);\nlong origCRC32 = crc32.getValue();\nif (origCRC32 == f.getNameCRC32()) {\nreturn ZipEncodingHelper\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:copy([B)[B",
                                    "method_body": "static byte[] copy(byte[] from) {\nif (from != null) {\nbyte[] to = new byte[from.length];\nSystem.arraycopy(from, 0, to, 0, to.length);\nreturn to;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:supportsEncryptionOf(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private static boolean supportsEncryptionOf(ZipArchiveEntry entry) {\nreturn !entry.getGeneralPurposeBit().usesEncryption();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:supportsMethodOf(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private static boolean supportsMethodOf(ZipArchiveEntry entry) {\nreturn entry.getMethod() == ZipArchiveEntry.STORED\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:checkRequestedFeatures(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "static void checkRequestedFeatures(ZipArchiveEntry ze)\nif (!supportsEncryptionOf(ze)) {\nif (!supportsMethodOf(ze)) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<init>(I)V",
                                    "method_body": "private UnparseableExtraField(int k) {\nkey = k;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<clinit>()V",
                                    "method_body": "public static final UnparseableExtraField READ\nprivate UnparseableExtraField(int k) {\nkey = k;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\nimplementations = new HashMap<ZipShort, Class<?>>();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\nregister(Zip64ExtendedInformationExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class<?> c) {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:createExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField createExtraField(ZipShort headerId)\nClass<?> c = implementations.get(headerId);\nif (c != null) {\nreturn (ZipExtraField) c.newInstance();\nUnrecognizedExtraField u = new UnrecognizedExtraField();\nu.setHeaderId(headerId);\nreturn u;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:parse([BZLorg/apache/commons/compress/archivers/zip/ExtraFieldUtils$UnparseableExtraField;)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField[] parse(byte[] data, boolean local,\nList<ZipExtraField> v = new ArrayList<ZipExtraField>();\nint start = 0;\nwhile (start <= data.length - WORD) {\nZipShort headerId = new ZipShort(data, start);\nint length = (new ZipShort(data, start + 2)).getValue();\nif (start + WORD + length > data.length) {\nZipExtraField ze = createExtraField(headerId);\nif (local) {\nze.parseFromLocalFileData(data, start + WORD, length);\nze.parseFromCentralDirectoryData(data, start + WORD,\nv.add(ze);\n}\nstart += (length + WORD);\n}\nZipExtraField[] result = new ZipExtraField[v.size()];\nreturn v.toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nfinal boolean lastIsUnparseableHolder = data.length > 0\nint regularExtraFieldCount =\nint sum = WORD * regularExtraFieldCount;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\nif (lastIsUnparseableHolder) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\npublic JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:assembleData()V",
                                    "method_body": "private void assembleData() {\nif (unicodeName == null) {\ndata = new byte[5 + unicodeName.length];\ndata[0] = 0x01;\nSystem.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4);\nSystem.arraycopy(unicodeName, 0, data, 5, unicodeName.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getNameCRC32()J",
                                    "method_body": "public long getNameCRC32() {\nreturn nameCRC32;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getUnicodeName()[B",
                                    "method_body": "public byte[] getUnicodeName() {\nbyte[] b = null;\nif (unicodeName != null) {\nb = new byte[unicodeName.length];\nSystem.arraycopy(unicodeName, 0, b, 0, b.length);\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryData()[B",
                                    "method_body": "public byte[] getCentralDirectoryData() {\nif (data == null) {\nthis.assembleData();\nbyte[] b = null;\nif (data != null) {\nb = new byte[data.length];\nSystem.arraycopy(data, 0, b, 0, b.length);\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getCentralDirectoryLength() {\nif (data == null) {\nassembleData();\nreturn new ZipShort(data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn getCentralDirectoryData();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn getCentralDirectoryLength();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:parseFromLocalFileData([BII)V",
                                    "method_body": "public void parseFromLocalFileData(byte[] buffer, int offset, int length)\nif (length < 5) {\nint version = buffer[offset];\nif (version != 0x01) {\nnameCRC32 = ZipLong.getValue(buffer, offset + 1);\nunicodeName = new byte[length - 5];\nSystem.arraycopy(buffer, offset + 5, unicodeName, 0, length - 5);\ndata = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:parseFromCentralDirectoryData([BII)V",
                                    "method_body": "public void parseFromCentralDirectoryData(byte[] buffer, int offset,\nparseFromLocalFileData(buffer, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<init>()V",
                                    "method_body": "public Zip64ExtendedInformationExtraField() { }\npublic Zip64ExtendedInformationExtraField() { }"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<clinit>()V",
                                    "method_body": "static final ZipShort HEADER_ID = new ZipShort(0x0001);\n* parseFromCentralDirectoryData} so it can be reused when ZipFile"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\nthrows IOException {\nthis.archiveName = f.getAbsolutePath();\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = new RandomAccessFile(f, \"r\");\nboolean success = false;\nMap<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag =\nresolveLocalFileHeaderData(entriesWithoutUTF8Flag);\nsuccess = true;\nif (!success) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<clinit>()V",
                                    "method_body": "private static final int CFH_LEN =\nprivate static final long CFH_SIG =\nHashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\npositionAtCentralDirectory();\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nif (sig != CFH_SIG && startsWithLocalFileHeader()) {\nwhile (sig == CFH_SIG) {\nreadCentralDirectoryEntry(noUTF8Flag);\narchive.readFully(signatureBytes);\nsig = ZipLong.getValue(signatureBytes);\nreturn noUTF8Flag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:close()V",
                                    "method_body": "public void close() throws IOException {\nclosed = true;\narchive.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
                                    "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\nzipfile.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:getEntry(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;",
                                    "method_body": "public ZipArchiveEntry getEntry(String name) {\nreturn nameMap.get(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:getInputStream(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Ljava/io/InputStream;",
                                    "method_body": "public InputStream getInputStream(ZipArchiveEntry ze)\nOffsetEntry offsetEntry = entries.get(ze);\nif (offsetEntry == null) {\nreturn null;\nZipUtil.checkRequestedFeatures(ze);\nlong start = offsetEntry.dataOffset;\nBoundedInputStream bis =\nswitch (ze.getMethod()) {\nreturn bis;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory()\nHashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\npositionAtCentralDirectory();\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nif (sig != CFH_SIG && startsWithLocalFileHeader()) {\nwhile (sig == CFH_SIG) {\nreadCentralDirectoryEntry(noUTF8Flag);\narchive.readFully(signatureBytes);\nsig = ZipLong.getValue(signatureBytes);\nreturn noUTF8Flag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:readCentralDirectoryEntry(Ljava/util/Map;)V",
                                    "method_body": "private void\nbyte[] cfh = new byte[CFH_LEN];\narchive.readFully(cfh);\nint off = 0;\nZipArchiveEntry ze = new ZipArchiveEntry();\nint versionMadeBy = ZipShort.getValue(cfh, off);\noff += SHORT;\nze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\noff += SHORT; // skip version info\nfinal GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(cfh, off);\nfinal boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\nfinal ZipEncoding entryEncoding =\nze.setGeneralPurposeBit(gpFlag);\noff += SHORT;\nze.setMethod(ZipShort.getValue(cfh, off));\noff += SHORT;\nlong time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\nze.setTime(time);\noff += WORD;\nze.setCrc(ZipLong.getValue(cfh, off));\noff += WORD;\nze.setCompressedSize(ZipLong.getValue(cfh, off));\noff += WORD;\nze.setSize(ZipLong.getValue(cfh, off));\noff += WORD;\nint fileNameLen = ZipShort.getValue(cfh, off);\noff += SHORT;\nint extraLen = ZipShort.getValue(cfh, off);\noff += SHORT;\nint commentLen = ZipShort.getValue(cfh, off);\noff += SHORT;\nint diskStart = ZipShort.getValue(cfh, off);\noff += SHORT;\nze.setInternalAttributes(ZipShort.getValue(cfh, off));\noff += SHORT;\nze.setExternalAttributes(ZipLong.getValue(cfh, off));\noff += WORD;\nbyte[] fileName = new byte[fileNameLen];\narchive.readFully(fileName);\nze.setName(entryEncoding.decode(fileName), fileName);\nOffsetEntry offset = new OffsetEntry();\noffset.headerOffset = ZipLong.getValue(cfh, off);\nentries.put(ze, offset);\nnameMap.put(ze.getName(), ze);\nbyte[] cdExtraData = new byte[extraLen];\narchive.readFully(cdExtraData);\nze.setCentralDirectoryExtra(cdExtraData);\nsetSizesAndOffsetFromZip64Extra(ze, offset, diskStart);\nbyte[] comment = new byte[commentLen];\narchive.readFully(comment);\nze.setComment(entryEncoding.decode(comment));\nif (!hasUTF8Flag && useUnicodeExtraFields) {\nnoUTF8Flag.put(ze, new NameAndComment(fileName, comment));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:setSizesAndOffsetFromZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Lorg/apache/commons/compress/archivers/zip/ZipFile$OffsetEntry;I)V",
                                    "method_body": "private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze,\nZip64ExtendedInformationExtraField z64 =\nif (z64 != null) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nboolean found = tryToLocateSignature(MIN_EOCD_SIZE + ZIP64_EOCDL_LENGTH,\nif (!found) {\npositionAtCentralDirectory32();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory32()V",
                                    "method_body": "private void positionAtCentralDirectory32()\nboolean found = tryToLocateSignature(MIN_EOCD_SIZE, MAX_EOCD_SIZE,\nif (!found) {\nskipBytes(CFD_LOCATOR_OFFSET);\nbyte[] cfdOffset = new byte[WORD];\narchive.readFully(cfdOffset);\narchive.seek(ZipLong.getValue(cfdOffset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:tryToLocateSignature(JJ[B)Z",
                                    "method_body": "private boolean tryToLocateSignature(long minDistanceFromEnd,\nboolean found = false;\nlong off = archive.length() - minDistanceFromEnd;\nfinal long stopSearching =\nif (off >= 0) {\nfor (; off >= stopSearching; off--) {\narchive.seek(off);\nint curr = archive.read();\nif (curr == -1) {\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\nif (found) {\narchive.seek(off);\nreturn found;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:skipBytes(I)V",
                                    "method_body": "private void skipBytes(final int count) throws IOException {\nint totalSkipped = 0;\nwhile (totalSkipped < count) {\nint skippedNow = archive.skipBytes(count - totalSkipped);\nif (skippedNow <= 0) {\ntotalSkipped += skippedNow;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:resolveLocalFileHeaderData(Ljava/util/Map;)V",
                                    "method_body": "private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\nfor (ZipArchiveEntry ze : entries.keySet()) {\nOffsetEntry offsetEntry = entries.get(ze);\nlong offset = offsetEntry.headerOffset;\narchive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\nbyte[] b = new byte[SHORT];\narchive.readFully(b);\nint fileNameLen = ZipShort.getValue(b);\narchive.readFully(b);\nint extraFieldLen = ZipShort.getValue(b);\nint lenToSkip = fileNameLen;\nwhile (lenToSkip > 0) {\nint skipped = archive.skipBytes(lenToSkip);\nif (skipped <= 0) {\nlenToSkip -= skipped;\n}\nbyte[] localExtraData = new byte[extraFieldLen];\narchive.readFully(localExtraData);\nze.setExtra(localExtraData);\noffsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\nif (entriesWithoutUTF8Flag.containsKey(ze)) {\nString orig = ze.getName();\nNameAndComment nc = entriesWithoutUTF8Flag.get(ze);\nZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\nif (!orig.equals(ze.getName())) {\nnameMap.remove(orig);\nnameMap.put(ze.getName(), ze);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$OffsetEntry:access$002(Lorg/apache/commons/compress/archivers/zip/ZipFile$OffsetEntry;J)J",
                                    "method_body": "private static final int HASH_SIZE = 509;\nprivate final Map<ZipArchiveEntry, OffsetEntry> entries =\nprivate final Map<String, ZipArchiveEntry> nameMap =\nprivate static final class OffsetEntry {\nprivate long headerOffset = -1;\nprivate long dataOffset = -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$OffsetEntry:<init>()V",
                                    "method_body": "private static final int HASH_SIZE = 509;\nprivate final Map<ZipArchiveEntry, OffsetEntry> entries =\nprivate final Map<String, ZipArchiveEntry> nameMap =\nprivate static final class OffsetEntry {\nprivate long headerOffset = -1;\nprivate long dataOffset = -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$NameAndComment:<init>([B[B)V",
                                    "method_body": "private NameAndComment(byte[] name, byte[] comment) {\nthis.name = name;\nthis.comment = comment;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setHeaderId(Lorg/apache/commons/compress/archivers/zip/ZipShort;)V",
                                    "method_body": "public void setHeaderId(ZipShort headerId) {\nthis.headerId = headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setLocalFileDataData([B)V",
                                    "method_body": "public void setLocalFileDataData(byte[] data) {\nlocalData = ZipUtil.copy(data);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn new ZipShort(localData.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn ZipUtil.copy(localData);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setCentralDirectoryData([B)V",
                                    "method_body": "public void setCentralDirectoryData(byte[] data) {\ncentralData = ZipUtil.copy(data);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:parseFromCentralDirectoryData([BII)V",
                                    "method_body": "public void parseFromCentralDirectoryData(byte[] data, int offset,\nbyte[] tmp = new byte[length];\nSystem.arraycopy(data, offset, tmp, 0, length);\nsetCentralDirectoryData(tmp);\nif (localData == null) {\nsetLocalFileDataData(tmp);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$BoundedInputStream:<init>(Lorg/apache/commons/compress/archivers/zip/ZipFile;JJ)V",
                                    "method_body": "BoundedInputStream(long start, long remaining) {\nthis.remaining = remaining;\nloc = start;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$BoundedInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (remaining-- <= 0) {\nsynchronized (archive) {\narchive.seek(loc++);\nreturn archive.read();\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 11,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest.shortTextFilesAreNoTARs",
                            "test_body": "32: public void shortTextFilesAreNoTARs() throws Exception {\n33: try {\n34: new ArchiveStreamFactory()\n35: .createArchiveInputStream(new ByteArrayInputStream(\"This certainly is not a tar archive, really, no kidding\".getBytes()));\n36: fail(\"created an input stream for a non-archive\");\n37: } catch (ArchiveException ae) {\n38: assertTrue(ae.getMessage().startsWith(\"No Archiver found\"));\n39: }\n40: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveInputStream(Ljava/io/InputStream;)Lorg/apache/commons/compress/archivers/ArchiveInputStream;",
                                    "method_body": "public ArchiveInputStream createArchiveInputStream(final InputStream in)\nif (in == null) {\nif (!in.markSupported()) {\nfinal byte[] signature = new byte[12];\nin.mark(signature.length);\nint signatureLength = in.read(signature);\nin.reset();\nif (ZipArchiveInputStream.matches(signature, signatureLength)) {\n} else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n} else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n} else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\nfinal byte[] dumpsig = new byte[32];\nin.mark(dumpsig.length);\nsignatureLength = in.read(dumpsig);\nin.reset();\nif (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\nfinal byte[] tarheader = new byte[512];\nin.mark(tarheader.length);\nsignatureLength = in.read(tarheader);\nin.reset();\nif (TarArchiveInputStream.matches(tarheader, signatureLength)) {\nTarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\ntais.getNextEntry();\nreturn new TarArchiveInputStream(in);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < 6) {\nif (signature[0] == 0x71 && (signature[1] & 0xFF) == 0xc7) {\nif (signature[1] == 0x71 && (signature[0] & 0xFF) == 0xc7) {\nif (signature[0] != 0x30) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] buffer, int length) {\nif (length < 32) {\nif (length >= DumpArchiveConstants.TP_SIZE) {\nreturn DumpArchiveConstants.NFS_MAGIC == DumpArchiveUtil.convert32(buffer,\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert32([BI)I",
                                    "method_body": "public static final int convert32(byte[] buffer, int offset) {\nint i = 0;\ni = buffer[offset + 3] << 24;\ni += (buffer[offset + 2] << 16) & 0x00FF0000;\ni += (buffer[offset + 1] << 8) & 0x0000FF00;\ni += buffer[offset] & 0x000000FF;\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<clinit>()V",
                                    "method_body": "private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\nprivate static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\nprivate static final byte[] DD = ZipLong.DD_SIG.getBytes();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < ZipArchiveOutputStream.LFH_SIG.length) {\nreturn checksig(signature, ZipArchiveOutputStream.LFH_SIG) // normal file\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:checksig([B[B)Z",
                                    "method_body": "private static boolean checksig(byte[] signature, byte[] expected){\nfor (int i = 0; i < expected.length; i++) {\nif (signature[i] != expected[i]) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int BYTE_1 = 1;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes();\nstatic final byte[] DD_SIG = ZipLong.DD_SIG.getBytes();\nstatic final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes();\nstatic final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\nstatic final byte[] ZIP64_EOCD_SIG = ZipLong.getBytes(0X06064B50L);\nstatic final byte[] ZIP64_EOCD_LOC_SIG = ZipLong.getBytes(0X07064B50L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length ) {\nreturn ZipArchiveInputStream.matches(signature, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:<clinit>()V",
                                    "method_body": "static final String BSD_LONGNAME_PREFIX = \"#1/\";\nprivate static final int BSD_LONGNAME_PREFIX_LEN =\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < 8) {\nif (signature[0] != 0x21) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarBuffer(InputStream inStream, int blockSize, int recordSize) {\nthis.inStream = inStream;\nthis.outStream = null;\nthis.initialize(blockSize, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:initialize(II)V",
                                    "method_body": "private void initialize(int blockSize, int recordSize) {\nthis.blockSize = blockSize;\nthis.recordSize = recordSize;\nthis.recsPerBlock = (this.blockSize / this.recordSize);\nthis.blockBuffer = new byte[this.blockSize];\nif (this.inStream != null) {\nthis.currBlkIdx = -1;\nthis.currRecIdx = this.recsPerBlock;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:getRecordSize()I",
                                    "method_body": "public int getRecordSize() {\nreturn this.recordSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:isEOFRecord([B)Z",
                                    "method_body": "public boolean isEOFRecord(byte[] record) {\nfor (int i = 0, sz = getRecordSize(); i < sz; ++i) {\nif (record[i] != 0) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:readRecord()[B",
                                    "method_body": "public byte[] readRecord() throws IOException {\nif (inStream == null) {\nif (currRecIdx >= recsPerBlock && !readBlock()) {\nbyte[] result = new byte[recordSize];\nSystem.arraycopy(blockBuffer,\ncurrRecIdx++;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:readBlock()Z",
                                    "method_body": "private boolean readBlock() throws IOException {\nif (inStream == null) {\ncurrRecIdx = 0;\nint offset = 0;\nint bytesNeeded = blockSize;\nwhile (bytesNeeded > 0) {\nlong numBytes = inStream.read(blockBuffer, offset,\nif (numBytes == -1) {\nif (offset == 0) {\nArrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\nbreak;\noffset += numBytes;\nbytesNeeded -= numBytes;\nif (numBytes != blockSize) {\n}\ncurrBlkIdx++;\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry () {\nthis.magic = MAGIC_POSIX;\nthis.version = VERSION_POSIX;\nthis.name = \"\";\nthis.linkName = \"\";\nString user = System.getProperty(\"user.name\", \"\");\nif (user.length() > MAX_NAMELEN) {\nthis.userId = 0;\nthis.groupId = 0;\nthis.userName = user;\nthis.groupName = \"\";\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>([B)V",
                                    "method_body": "public TarArchiveEntry(byte[] headerBuf) {\nthis();\nparseTarHeader(headerBuf);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNUSparse()Z",
                                    "method_body": "public boolean isGNUSparse() {\nreturn linkFlag == LF_GNUTYPE_SPARSE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongNameEntry()Z",
                                    "method_body": "public boolean isGNULongNameEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGNAME\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isPaxHeader()Z",
                                    "method_body": "public boolean isPaxHeader(){\nreturn linkFlag == LF_PAX_EXTENDED_HEADER_LC\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nif (file != null) {\nif (linkFlag == LF_DIR) {\nif (getName().endsWith(\"/\")) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([B)V",
                                    "method_body": "public void parseTarHeader(byte[] header) {\nint offset = 0;\nname = TarUtils.parseName(header, offset, NAMELEN);\noffset += NAMELEN;\nmode = (int) TarUtils.parseOctal(header, offset, MODELEN);\noffset += MODELEN;\nuserId = (int) TarUtils.parseOctal(header, offset, UIDLEN);\noffset += UIDLEN;\ngroupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);\noffset += GIDLEN;\nsize = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\noffset += SIZELEN;\nmodTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\noffset += MODTIMELEN;\noffset += CHKSUMLEN;\nlinkFlag = header[offset++];\nlinkName = TarUtils.parseName(header, offset, NAMELEN);\noffset += NAMELEN;\nmagic = TarUtils.parseName(header, offset, MAGICLEN);\noffset += MAGICLEN;\nversion = TarUtils.parseName(header, offset, VERSIONLEN);\noffset += VERSIONLEN;\nuserName = TarUtils.parseName(header, offset, UNAMELEN);\noffset += UNAMELEN;\ngroupName = TarUtils.parseName(header, offset, GNAMELEN);\noffset += GNAMELEN;\ndevMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\noffset += DEVLEN;\ndevMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\noffset += DEVLEN;\nint type = evaluateType(header);\nswitch (type) {\nString prefix = TarUtils.parseName(header, offset, PREFIXLEN);\nif (isDirectory() && !name.endsWith(\"/\")){\nif (prefix.length() > 0){\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:evaluateType([B)I",
                                    "method_body": "private int evaluateType(byte[] header) {\nfinal ByteBuffer magic = ByteBuffer.wrap(header, MAGIC_OFFSET, MAGICLEN);\nif (magic.compareTo(ByteBuffer.wrap(MAGIC_GNU.getBytes())) == 0)\nif (magic.compareTo(ByteBuffer.wrap(MAGIC_POSIX.getBytes())) == 0)\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\nif (length < 2){\nboolean allNUL = true;\nfor (int i = start; i < end; i++){\nif (buffer[i] != 0){\nif (allNUL) {\nreturn 0L;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctalOrBinary([BII)J",
                                    "method_body": "public static long parseOctalOrBinary(final byte[] buffer, final int offset,\nif ((buffer[offset] & 0x80) == 0) {\nreturn parseOctal(buffer, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BII)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset, final int length) {\nStringBuffer result = new StringBuffer(length);\nint          end = offset + length;\nfor (int i = offset; i < end; ++i) {\nbyte b = buffer[i];\nif (b == 0) { // Trailing null\nbreak;\nresult.append((char) (b & 0xFF)); // Allow for sign-extension\nreturn result.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is) {\nthis(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\nthis.buffer = new TarBuffer(is, blockSize, recordSize);\nthis.readBuf = null;\nthis.hasHitEOF = false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextTarEntry()Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;",
                                    "method_body": "public TarArchiveEntry getNextTarEntry() throws IOException {\nif (hasHitEOF) {\nif (currEntry != null) {\nbyte[] headerBuf = getRecord();\nif (hasHitEOF) {\ncurrEntry = new TarArchiveEntry(headerBuf);\nentryOffset = 0;\nentrySize = currEntry.getSize();\nif (currEntry.isGNULongNameEntry()) {\nif (currEntry.isPaxHeader()){ // Process Pax headers\nif (currEntry.isGNUSparse()){ // Process sparse files\nentrySize = currEntry.getSize();\nreturn currEntry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getRecord()[B",
                                    "method_body": "private byte[] getRecord() throws IOException {\nif (hasHitEOF) {\nbyte[] headerBuf = buffer.readRecord();\nif (headerBuf == null) {\n} else if (buffer.isEOFRecord(headerBuf)) {\nreturn hasHitEOF ? null : headerBuf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextEntry()Lorg/apache/commons/compress/archivers/ArchiveEntry;",
                                    "method_body": "public ArchiveEntry getNextEntry() throws IOException {\nreturn getNextTarEntry();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < TarConstants.VERSION_OFFSET+TarConstants.VERSIONLEN) {\nreturn false;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 12,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.TarTestCase.testCOMPRESS178",
                            "test_body": "304: public void testCOMPRESS178() throws Exception {\n305: final File input = getFile(\"COMPRESS-178.tar\");\n306: final InputStream is = new FileInputStream(input);\n307: final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"tar\", is);\n308: try {\n309: in.getNextEntry();\n310: fail(\"Expected IOException\");\n311: } catch (IOException e) {\n312: Throwable t = e.getCause();\n313: assertTrue(\"Expected cause = IllegalArgumentException\", t instanceof IllegalArgumentException);\n314: }\n315: in.close();\n316: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveInputStream(Ljava/lang/String;Ljava/io/InputStream;)Lorg/apache/commons/compress/archivers/ArchiveInputStream;",
                                    "method_body": "public ArchiveInputStream createArchiveInputStream(\nif (archiverName == null) {\nif (in == null) {\nif (AR.equalsIgnoreCase(archiverName)) {\nif (ZIP.equalsIgnoreCase(archiverName)) {\nif (TAR.equalsIgnoreCase(archiverName)) {\nreturn new TarArchiveInputStream(in);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarBuffer(InputStream inStream, int blockSize, int recordSize) {\nthis.inStream = inStream;\nthis.outStream = null;\nthis.initialize(blockSize, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:initialize(II)V",
                                    "method_body": "private void initialize(int blockSize, int recordSize) {\nthis.blockSize = blockSize;\nthis.recordSize = recordSize;\nthis.recsPerBlock = (this.blockSize / this.recordSize);\nthis.blockBuffer = new byte[this.blockSize];\nif (this.inStream != null) {\nthis.currBlkIdx = -1;\nthis.currRecIdx = this.recsPerBlock;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:getRecordSize()I",
                                    "method_body": "public int getRecordSize() {\nreturn this.recordSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:isEOFRecord([B)Z",
                                    "method_body": "public boolean isEOFRecord(byte[] record) {\nfor (int i = 0, sz = getRecordSize(); i < sz; ++i) {\nif (record[i] != 0) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:readRecord()[B",
                                    "method_body": "public byte[] readRecord() throws IOException {\nif (inStream == null) {\nif (currRecIdx >= recsPerBlock && !readBlock()) {\nbyte[] result = new byte[recordSize];\nSystem.arraycopy(blockBuffer,\ncurrRecIdx++;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:readBlock()Z",
                                    "method_body": "private boolean readBlock() throws IOException {\nif (inStream == null) {\ncurrRecIdx = 0;\nint offset = 0;\nint bytesNeeded = blockSize;\nwhile (bytesNeeded > 0) {\nlong numBytes = inStream.read(blockBuffer, offset,\nif (numBytes == -1) {\noffset += numBytes;\nbytesNeeded -= numBytes;\nif (numBytes != blockSize) {\n}\ncurrBlkIdx++;\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry () {\nthis.magic = MAGIC_POSIX;\nthis.version = VERSION_POSIX;\nthis.name = \"\";\nthis.linkName = \"\";\nString user = System.getProperty(\"user.name\", \"\");\nif (user.length() > MAX_NAMELEN) {\nthis.userId = 0;\nthis.groupId = 0;\nthis.userName = user;\nthis.groupName = \"\";\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>([B)V",
                                    "method_body": "public TarArchiveEntry(byte[] headerBuf) {\nthis();\nparseTarHeader(headerBuf);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([B)V",
                                    "method_body": "public void parseTarHeader(byte[] header) {\nint offset = 0;\nname = TarUtils.parseName(header, offset, NAMELEN);\noffset += NAMELEN;\nmode = (int) TarUtils.parseOctal(header, offset, MODELEN);\noffset += MODELEN;\nuserId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\noffset += UIDLEN;\ngroupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\nif (length < 2){\nboolean allNUL = true;\nfor (int i = start; i < end; i++){\nif (buffer[i] != 0){\nallNUL = false;\nbreak;\nif (allNUL) {\nwhile (start < end){\nif (buffer[start] == ' '){\ntrailer = buffer[end-1];\nif (trailer == 0 || trailer == ' '){\nend--;\ntrailer = buffer[end-1];\nif (trailer == 0 || trailer == ' '){\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\nif (currentByte < '0' || currentByte > '7'){\nthrow new IllegalArgumentException(\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctalOrBinary([BII)J",
                                    "method_body": "public static long parseOctalOrBinary(final byte[] buffer, final int offset,\nif ((buffer[offset] & 0x80) == 0) {\nreturn parseOctal(buffer, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:exceptionMessage([BIIIB)Ljava/lang/String;",
                                    "method_body": "private static String exceptionMessage(byte[] buffer, final int offset,\nString string = new String(buffer, offset, length);\nstring=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed\nfinal String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;\nreturn s;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BII)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset, final int length) {\nStringBuffer result = new StringBuffer(length);\nint          end = offset + length;\nfor (int i = offset; i < end; ++i) {\nbyte b = buffer[i];\nif (b == 0) { // Trailing null\nbreak;\nresult.append((char) (b & 0xFF)); // Allow for sign-extension\nreturn result.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is) {\nthis(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\nthis.buffer = new TarBuffer(is, blockSize, recordSize);\nthis.readBuf = null;\nthis.hasHitEOF = false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextTarEntry()Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;",
                                    "method_body": "public TarArchiveEntry getNextTarEntry() throws IOException {\nif (hasHitEOF) {\nif (currEntry != null) {\nbyte[] headerBuf = getRecord();\nif (hasHitEOF) {\ncurrEntry = new TarArchiveEntry(headerBuf);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getRecord()[B",
                                    "method_body": "private byte[] getRecord() throws IOException {\nif (hasHitEOF) {\nbyte[] headerBuf = buffer.readRecord();\nif (headerBuf == null) {\n} else if (buffer.isEOFRecord(headerBuf)) {\nreturn hasHitEOF ? null : headerBuf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextEntry()Lorg/apache/commons/compress/archivers/ArchiveEntry;",
                                    "method_body": "public ArchiveEntry getNextEntry() throws IOException {\nreturn getNextTarEntry();\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 13,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest.winzipBackSlashWorkaround",
                            "test_body": "35: public void winzipBackSlashWorkaround() throws Exception {\n36: URL zip = getClass().getResource(\"/test-winzip.zip\");\n37: ZipArchiveInputStream in = null;\n38: try {\n39: in = new ZipArchiveInputStream(new FileInputStream(new File(new URI(zip.toString()))));\n40: ZipArchiveEntry zae = in.getNextZipEntry();\n41: zae = in.getNextZipEntry();\n42: zae = in.getNextZipEntry();\n43: assertEquals(\"\\u00e4/\", zae.getName());\n44: } finally {\n45: if (in != null) {\n46: in.close();\n47: }\n48: }\n49: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int BYTE_1 = 1;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\nsimpleEncodings = new HashMap<String, SimpleEncodingHolder>();\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\nreturn UTF8.equalsIgnoreCase(encoding)\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data,this.charset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/util/zip/ZipEntry;)V",
                                    "method_body": "private long size = SIZE_UNKNOWN;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate LinkedHashMap<ZipShort, ZipExtraField> extraFields = null;\nprivate UnparseableExtraFieldData unparseableExtra = null;\nprivate String name = null;\nprivate byte[] rawName = null;\nprivate GeneralPurposeBit gpb = new GeneralPurposeBit();\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "protected ZipArchiveEntry() {\nthis(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setMethod(I)V",
                                    "method_body": "public void setMethod(int method) {\nif (method < 0) {\nthis.method = method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setPlatform(I)V",
                                    "method_body": "protected void setPlatform(int platform) {\nthis.platform = platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void setExtraFields(ZipExtraField[] fields) {\nextraFields = new LinkedHashMap<ZipShort, ZipExtraField>();\nfor (int i = 0; i < fields.length; i++) {\nif (fields[i] instanceof UnparseableExtraFieldData) {\nextraFields.put(fields[i].getHeaderId(), fields[i]);\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields(Z)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields(boolean includeUnparseable) {\nif (extraFields == null) {\nList<ZipExtraField> result =\nif (includeUnparseable && unparseableExtra != null) {\nreturn result.toArray(new ZipExtraField[0]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField getExtraField(ZipShort type) {\nif (extraFields != null) {\nreturn extraFields.get(type);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra([B)V",
                                    "method_body": "public void setExtra(byte[] extra) throws RuntimeException {\nZipExtraField[] local =\nmergeExtraFields(local, true);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields(true)));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "protected void setName(String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nif (size < 0) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;[B)V",
                                    "method_body": "protected void setName(String name, byte[] rawName) {\nsetName(name);\nthis.rawName = rawName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setGeneralPurposeBit(Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;)V",
                                    "method_body": "public void setGeneralPurposeBit(GeneralPurposeBit b) {\ngpb = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:<init>()V",
                                    "method_body": "public static final int UFT8_NAMES_FLAG = 1 << 11;\nprivate boolean languageEncodingFlag = false;\nprivate boolean dataDescriptorFlag = false;\nprivate boolean encryptionFlag = false;\nprivate boolean strongEncryptionFlag = false;\npublic GeneralPurposeBit() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesUTF8ForNames()Z",
                                    "method_body": "public boolean usesUTF8ForNames() {\nreturn languageEncodingFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useUTF8ForNames(Z)V",
                                    "method_body": "public void useUTF8ForNames(boolean b) {\nlanguageEncodingFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useDataDescriptor(Z)V",
                                    "method_body": "public void useDataDescriptor(boolean b) {\ndataDescriptorFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useEncryption(Z)V",
                                    "method_body": "public void useEncryption(boolean b) {\nencryptionFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useStrongEncryption(Z)V",
                                    "method_body": "public void useStrongEncryption(boolean b) {\nstrongEncryptionFlag = b;\nif (b) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:parse([BI)Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "public static GeneralPurposeBit parse(final byte[] data, final int offset) {\nfinal int generalPurposeFlag = ZipShort.getValue(data, offset);\nGeneralPurposeBit b = new GeneralPurposeBit();\nb.useDataDescriptor((generalPurposeFlag & DATA_DESCRIPTOR_FLAG) != 0);\nb.useUTF8ForNames((generalPurposeFlag & UFT8_NAMES_FLAG) != 0);\nb.useStrongEncryption((generalPurposeFlag & STRONG_ENCRYPTION_FLAG)\nb.useEncryption((generalPurposeFlag & ENCRYPTION_FLAG) != 0);\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\npublic JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>([BI)V",
                                    "method_body": "public ZipShort (byte[] bytes, int offset) {\nvalue = ZipShort.getValue(bytes, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([BI)I",
                                    "method_body": "public static int getValue(byte[] bytes, int offset) {\nint value = (bytes[offset + 1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object o) {\nif (o == null || !(o instanceof ZipShort)) {\nreturn value == ((ZipShort) o).getValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\nimplementations = new HashMap<ZipShort, Class<?>>();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\nregister(Zip64ExtendedInformationExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class<?> c) {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:parse([BZLorg/apache/commons/compress/archivers/zip/ExtraFieldUtils$UnparseableExtraField;)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField[] parse(byte[] data, boolean local,\nList<ZipExtraField> v = new ArrayList<ZipExtraField>();\nint start = 0;\nwhile (start <= data.length - WORD) {\nZipShort headerId = new ZipShort(data, start);\nint length = (new ZipShort(data, start + 2)).getValue();\nif (start + WORD + length > data.length) {\nZipExtraField ze = createExtraField(headerId);\nif (local) {\nze.parseFromLocalFileData(data, start + WORD, length);\nze.parseFromCentralDirectoryData(data, start + WORD,\nv.add(ze);\n}\nstart += (length + WORD);\n}\nZipExtraField[] result = new ZipExtraField[v.size()];\nreturn v.toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nfinal boolean lastIsUnparseableHolder = data.length > 0\nint regularExtraFieldCount =\nint sum = WORD * regularExtraFieldCount;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\nif (lastIsUnparseableHolder) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:assembleData()V",
                                    "method_body": "private void assembleData() {\nif (unicodeName == null) {\ndata = new byte[5 + unicodeName.length];\ndata[0] = 0x01;\nSystem.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4);\nSystem.arraycopy(unicodeName, 0, data, 5, unicodeName.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getNameCRC32()J",
                                    "method_body": "public long getNameCRC32() {\nreturn nameCRC32;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getUnicodeName()[B",
                                    "method_body": "public byte[] getUnicodeName() {\nbyte[] b = null;\nif (unicodeName != null) {\nb = new byte[unicodeName.length];\nSystem.arraycopy(unicodeName, 0, b, 0, b.length);\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryData()[B",
                                    "method_body": "public byte[] getCentralDirectoryData() {\nif (data == null) {\nthis.assembleData();\nbyte[] b = null;\nif (data != null) {\nb = new byte[data.length];\nSystem.arraycopy(data, 0, b, 0, b.length);\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getCentralDirectoryLength() {\nif (data == null) {\nassembleData();\nreturn new ZipShort(data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn getCentralDirectoryData();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn getCentralDirectoryLength();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:parseFromLocalFileData([BII)V",
                                    "method_body": "public void parseFromLocalFileData(byte[] buffer, int offset, int length)\nif (length < 5) {\nint version = buffer[offset];\nif (version != 0x01) {\nnameCRC32 = ZipLong.getValue(buffer, offset + 1);\nunicodeName = new byte[length - 5];\nSystem.arraycopy(buffer, offset + 5, unicodeName, 0, length - 5);\ndata = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<init>()V",
                                    "method_body": "public Zip64ExtendedInformationExtraField() { }\npublic Zip64ExtendedInformationExtraField() { }"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<clinit>()V",
                                    "method_body": "static final ZipShort HEADER_ID = new ZipShort(0x0001);\n* parseFromCentralDirectoryData} so it can be reused when ZipFile"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:dosToJavaTime(J)J",
                                    "method_body": "public static long dosToJavaTime(long dosTime) {\nCalendar cal = Calendar.getInstance();\ncal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\ncal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\ncal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);\ncal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);\ncal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);\ncal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);\nreturn cal.getTime().getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:setNameAndCommentFromExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;[B[B)V",
                                    "method_body": "static void setNameAndCommentFromExtraFields(ZipArchiveEntry ze,\nUnicodePathExtraField name = (UnicodePathExtraField)\nString originalName = ze.getName();\nString newName = getUnicodeStringIfOriginalMatches(name,\nif (newName != null && !originalName.equals(newName)) {\nze.setName(newName);\nif (commentBytes != null && commentBytes.length > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:getUnicodeStringIfOriginalMatches(Lorg/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField;[B)Ljava/lang/String;",
                                    "method_body": "String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f,\nif (f != null) {\nCRC32 crc32 = new CRC32();\ncrc32.update(orig);\nlong origCRC32 = crc32.getValue();\nif (origCRC32 == f.getNameCRC32()) {\nreturn ZipEncodingHelper\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<init>(I)V",
                                    "method_body": "private UnparseableExtraField(int k) {\nkey = k;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<clinit>()V",
                                    "method_body": "public static final int THROW_KEY = 0;\npublic static final UnparseableExtraField THROW\npublic static final UnparseableExtraField SKIP\n* UnparseableExtraFieldData UnparseableExtraFieldData}."
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream) {\nthis(inputStream, ZipEncodingHelper.UTF8, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream,\nthis(inputStream, encoding, useUnicodeExtraFields, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;ZZ)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream,\nboolean allowStoredEntriesWithDataDescriptor) {\nzipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\nin = new PushbackInputStream(inputStream, buf.buf.length);\nthis.allowStoredEntriesWithDataDescriptor =\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<clinit>()V",
                                    "method_body": "private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\nprivate static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\nprivate static final byte[] DD = ZipLong.DD_SIG.getBytes();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:getNextZipEntry()Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;",
                                    "method_body": "public ZipArchiveEntry getNextZipEntry() throws IOException {\nif (closed || hitCentralDirectory) {\nif (current != null) {\ncloseEntry();\nbyte[] lfh = new byte[LFH_LEN];\nreadFully(lfh);\n}\nZipLong sig = new ZipLong(lfh);\nif (sig.equals(ZipLong.CFH_SIG)) {\nif (!sig.equals(ZipLong.LFH_SIG)) {\nint off = WORD;\ncurrent = new CurrentEntry();\nint versionMadeBy = ZipShort.getValue(lfh, off);\noff += SHORT;\ncurrent.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT)\nfinal GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(lfh, off);\nfinal boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\nfinal ZipEncoding entryEncoding =\ncurrent.hasDataDescriptor = gpFlag.usesDataDescriptor();\ncurrent.entry.setGeneralPurposeBit(gpFlag);\noff += SHORT;\ncurrent.entry.setMethod(ZipShort.getValue(lfh, off));\noff += SHORT;\nlong time = ZipUtil.dosToJavaTime(ZipLong.getValue(lfh, off));\ncurrent.entry.setTime(time);\noff += WORD;\nZipLong size = null, cSize = null;\nif (!current.hasDataDescriptor) {\ncurrent.entry.setCrc(ZipLong.getValue(lfh, off));\noff += WORD;\ncSize = new ZipLong(lfh, off);\noff += WORD;\nsize = new ZipLong(lfh, off);\noff += WORD;\nint fileNameLen = ZipShort.getValue(lfh, off);\noff += SHORT;\nint extraLen = ZipShort.getValue(lfh, off);\noff += SHORT;\nbyte[] fileName = new byte[fileNameLen];\nreadFully(fileName);\ncurrent.entry.setName(entryEncoding.decode(fileName), fileName);\nbyte[] extraData = new byte[extraLen];\nreadFully(extraData);\ncurrent.entry.setExtra(extraData);\nif (!hasUTF8Flag && useUnicodeExtraFields) {\nZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName,\nprocessZip64Extra(size, cSize);\nreturn current.entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:processZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipLong;Lorg/apache/commons/compress/archivers/zip/ZipLong;)V",
                                    "method_body": "private void processZip64Extra(ZipLong size, ZipLong cSize) {\nZip64ExtendedInformationExtraField z64 =\ncurrent.usesZip64 = z64 != null;\nif (!current.hasDataDescriptor) {\nif (current.usesZip64 && (cSize.equals(ZipLong.ZIP64_MAGIC)\ncurrent.entry.setCompressedSize(cSize.getValue());\ncurrent.entry.setSize(size.getValue());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!closed) {\nclosed = true;\nin.close();\ninf.end();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:closeEntry()V",
                                    "method_body": "private void closeEntry() throws IOException {\nif (closed) {\nif (current == null) {\nif (current.bytesReadFromStream <= current.entry.getCompressedSize()\ndrainCurrentEntryData();\nif (lastStoredEntry == null && current.hasDataDescriptor) {\ninf.reset();\nbuf.reset();\ncrc.reset();\ncurrent = null;\nlastStoredEntry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:drainCurrentEntryData()V",
                                    "method_body": "private void drainCurrentEntryData() throws IOException {\nlong remaining = current.entry.getCompressedSize()\nwhile (remaining > 0) {\nlong n = in.read(buf.buf, 0, (int) Math.min(buf.buf.length,\nif (n < 0) {\ncount(n);\nremaining -= n;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readFully([B)V",
                                    "method_body": "private void readFully(byte[] b) throws IOException {\nint count = 0, x = 0;\nwhile (count != b.length) {\ncount += x = in.read(b, count, b.length - count);\nif (x == -1) {\ncount(x);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>([B)V",
                                    "method_body": "public ZipLong (byte[] bytes) {\nthis(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>([BI)V",
                                    "method_body": "public ZipLong (byte[] bytes, int offset) {\nvalue = ZipLong.getValue(bytes, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue()J",
                                    "method_body": "public long getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object o) {\nif (o == null || !(o instanceof ZipLong)) {\nreturn value == ((ZipLong) o).getValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesDataDescriptor()Z",
                                    "method_body": "public boolean usesDataDescriptor() {\nreturn dataDescriptorFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream$Buffer:access$1000(Lorg/apache/commons/compress/archivers/zip/ZipArchiveInputStream$Buffer;)V",
                                    "method_body": "private final ZipArchiveEntry entry = new ZipArchiveEntry();\nprivate static final class Buffer {\nprivate final byte[] buf = new byte[ZipArchiveOutputStream.BUFFER_SIZE];\nprivate int offsetInBuffer = 0;\nprivate int lengthOfLastRead = 0;\noffsetInBuffer = lengthOfLastRead = 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream$Buffer:<init>()V",
                                    "method_body": "private final ZipArchiveEntry entry = new ZipArchiveEntry();\nprivate static final class Buffer {\nprivate final byte[] buf = new byte[ZipArchiveOutputStream.BUFFER_SIZE];\nprivate int offsetInBuffer = 0;\nprivate int lengthOfLastRead = 0;\noffsetInBuffer = lengthOfLastRead = 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream$Buffer:reset()V",
                                    "method_body": "private void reset() {\noffsetInBuffer = lengthOfLastRead = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream$CurrentEntry:<init>()V",
                                    "method_body": "private final ZipArchiveEntry entry = new ZipArchiveEntry();\nprivate static final class Buffer {\nprivate final byte[] buf = new byte[ZipArchiveOutputStream.BUFFER_SIZE];\nprivate int offsetInBuffer = 0;\nprivate int lengthOfLastRead = 0;\noffsetInBuffer = lengthOfLastRead = 0;\n}\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.ZipFileTest.testWinzipBackSlashWorkaround",
                            "test_body": "145: public void testWinzipBackSlashWorkaround() throws Exception {\n146: URL zip = getClass().getResource(\"/test-winzip.zip\");\n147: File archive = new File(new URI(zip.toString()));\n148: zf = new ZipFile(archive);\n149: assertNull(zf.getEntry(\"\\u00e4\\\\\\u00fc.txt\"));\n150: assertNotNull(zf.getEntry(\"\\u00e4/\\u00fc.txt\"));\n151: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int BYTE_1 = 1;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes();\nstatic final byte[] DD_SIG = ZipLong.DD_SIG.getBytes();\nstatic final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes();\nstatic final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\nstatic final byte[] ZIP64_EOCD_SIG = ZipLong.getBytes(0X06064B50L);\nstatic final byte[] ZIP64_EOCD_LOC_SIG = ZipLong.getBytes(0X07064B50L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\nsimpleEncodings = new HashMap<String, SimpleEncodingHolder>();\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\nreturn UTF8.equalsIgnoreCase(encoding)\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data,this.charset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/util/zip/ZipEntry;)V",
                                    "method_body": "private long size = SIZE_UNKNOWN;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate LinkedHashMap<ZipShort, ZipExtraField> extraFields = null;\nprivate UnparseableExtraFieldData unparseableExtra = null;\nprivate String name = null;\nprivate byte[] rawName = null;\nprivate GeneralPurposeBit gpb = new GeneralPurposeBit();\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "protected ZipArchiveEntry() {\nthis(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setMethod(I)V",
                                    "method_body": "public void setMethod(int method) {\nif (method < 0) {\nthis.method = method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setInternalAttributes(I)V",
                                    "method_body": "public void setInternalAttributes(int value) {\ninternalAttributes = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExternalAttributes(J)V",
                                    "method_body": "public void setExternalAttributes(long value) {\nexternalAttributes = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setPlatform(I)V",
                                    "method_body": "protected void setPlatform(int platform) {\nthis.platform = platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void setExtraFields(ZipExtraField[] fields) {\nextraFields = new LinkedHashMap<ZipShort, ZipExtraField>();\nfor (int i = 0; i < fields.length; i++) {\nif (fields[i] instanceof UnparseableExtraFieldData) {\nextraFields.put(fields[i].getHeaderId(), fields[i]);\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields(Z)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields(boolean includeUnparseable) {\nif (extraFields == null) {\nList<ZipExtraField> result =\nif (includeUnparseable && unparseableExtra != null) {\nreturn result.toArray(new ZipExtraField[0]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField getExtraField(ZipShort type) {\nif (extraFields != null) {\nreturn extraFields.get(type);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra([B)V",
                                    "method_body": "public void setExtra(byte[] extra) throws RuntimeException {\nZipExtraField[] local =\nmergeExtraFields(local, true);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields(true)));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setCentralDirectoryExtra([B)V",
                                    "method_body": "public void setCentralDirectoryExtra(byte[] b) {\nZipExtraField[] central =\nmergeExtraFields(central, false);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "protected void setName(String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nif (size < 0) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;[B)V",
                                    "method_body": "protected void setName(String name, byte[] rawName) {\nsetName(name);\nthis.rawName = rawName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setGeneralPurposeBit(Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;)V",
                                    "method_body": "public void setGeneralPurposeBit(GeneralPurposeBit b) {\ngpb = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:mergeExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;Z)V",
                                    "method_body": "private void mergeExtraFields(ZipExtraField[] f, boolean local)\nif (extraFields == null) {\nsetExtraFields(f);\nfor (int i = 0; i < f.length; i++) {\nif (f[i] instanceof UnparseableExtraFieldData) {\nexisting = getExtraField(f[i].getHeaderId());\nif (existing == null) {\nif (local) {\nbyte[] b = f[i].getLocalFileDataData();\nexisting.parseFromLocalFileData(b, 0, b.length);\n} else {\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:<init>()V",
                                    "method_body": "public static final int UFT8_NAMES_FLAG = 1 << 11;\nprivate boolean languageEncodingFlag = false;\nprivate boolean dataDescriptorFlag = false;\nprivate boolean encryptionFlag = false;\nprivate boolean strongEncryptionFlag = false;\npublic GeneralPurposeBit() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesUTF8ForNames()Z",
                                    "method_body": "public boolean usesUTF8ForNames() {\nreturn languageEncodingFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useUTF8ForNames(Z)V",
                                    "method_body": "public void useUTF8ForNames(boolean b) {\nlanguageEncodingFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useDataDescriptor(Z)V",
                                    "method_body": "public void useDataDescriptor(boolean b) {\ndataDescriptorFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useEncryption(Z)V",
                                    "method_body": "public void useEncryption(boolean b) {\nencryptionFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useStrongEncryption(Z)V",
                                    "method_body": "public void useStrongEncryption(boolean b) {\nstrongEncryptionFlag = b;\nif (b) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:parse([BI)Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "public static GeneralPurposeBit parse(final byte[] data, final int offset) {\nfinal int generalPurposeFlag = ZipShort.getValue(data, offset);\nGeneralPurposeBit b = new GeneralPurposeBit();\nb.useDataDescriptor((generalPurposeFlag & DATA_DESCRIPTOR_FLAG) != 0);\nb.useUTF8ForNames((generalPurposeFlag & UFT8_NAMES_FLAG) != 0);\nb.useStrongEncryption((generalPurposeFlag & STRONG_ENCRYPTION_FLAG)\nb.useEncryption((generalPurposeFlag & ENCRYPTION_FLAG) != 0);\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\npublic JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>([BI)V",
                                    "method_body": "public ZipShort (byte[] bytes, int offset) {\nvalue = ZipShort.getValue(bytes, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([BI)I",
                                    "method_body": "public static int getValue(byte[] bytes, int offset) {\nint value = (bytes[offset + 1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([B)I",
                                    "method_body": "public static int getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object o) {\nif (o == null || !(o instanceof ZipShort)) {\nreturn value == ((ZipShort) o).getValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\nimplementations = new HashMap<ZipShort, Class<?>>();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\nregister(Zip64ExtendedInformationExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class<?> c) {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:createExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField createExtraField(ZipShort headerId)\nClass<?> c = implementations.get(headerId);\nif (c != null) {\nreturn (ZipExtraField) c.newInstance();\nUnrecognizedExtraField u = new UnrecognizedExtraField();\nu.setHeaderId(headerId);\nreturn u;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:parse([BZLorg/apache/commons/compress/archivers/zip/ExtraFieldUtils$UnparseableExtraField;)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField[] parse(byte[] data, boolean local,\nList<ZipExtraField> v = new ArrayList<ZipExtraField>();\nint start = 0;\nwhile (start <= data.length - WORD) {\nZipShort headerId = new ZipShort(data, start);\nint length = (new ZipShort(data, start + 2)).getValue();\nif (start + WORD + length > data.length) {\nZipExtraField ze = createExtraField(headerId);\nif (local) {\nze.parseFromLocalFileData(data, start + WORD, length);\nze.parseFromCentralDirectoryData(data, start + WORD,\nv.add(ze);\n}\nstart += (length + WORD);\n}\nZipExtraField[] result = new ZipExtraField[v.size()];\nreturn v.toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nfinal boolean lastIsUnparseableHolder = data.length > 0\nint regularExtraFieldCount =\nint sum = WORD * regularExtraFieldCount;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\nif (lastIsUnparseableHolder) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:assembleData()V",
                                    "method_body": "private void assembleData() {\nif (unicodeName == null) {\ndata = new byte[5 + unicodeName.length];\ndata[0] = 0x01;\nSystem.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4);\nSystem.arraycopy(unicodeName, 0, data, 5, unicodeName.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getNameCRC32()J",
                                    "method_body": "public long getNameCRC32() {\nreturn nameCRC32;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getUnicodeName()[B",
                                    "method_body": "public byte[] getUnicodeName() {\nbyte[] b = null;\nif (unicodeName != null) {\nb = new byte[unicodeName.length];\nSystem.arraycopy(unicodeName, 0, b, 0, b.length);\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryData()[B",
                                    "method_body": "public byte[] getCentralDirectoryData() {\nif (data == null) {\nthis.assembleData();\nbyte[] b = null;\nif (data != null) {\nb = new byte[data.length];\nSystem.arraycopy(data, 0, b, 0, b.length);\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getCentralDirectoryLength() {\nif (data == null) {\nassembleData();\nreturn new ZipShort(data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn getCentralDirectoryData();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn getCentralDirectoryLength();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:parseFromLocalFileData([BII)V",
                                    "method_body": "public void parseFromLocalFileData(byte[] buffer, int offset, int length)\nif (length < 5) {\nint version = buffer[offset];\nif (version != 0x01) {\nnameCRC32 = ZipLong.getValue(buffer, offset + 1);\nunicodeName = new byte[length - 5];\nSystem.arraycopy(buffer, offset + 5, unicodeName, 0, length - 5);\ndata = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:parseFromCentralDirectoryData([BII)V",
                                    "method_body": "public void parseFromCentralDirectoryData(byte[] buffer, int offset,\nparseFromLocalFileData(buffer, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<init>()V",
                                    "method_body": "public Zip64ExtendedInformationExtraField() { }\npublic Zip64ExtendedInformationExtraField() { }"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<clinit>()V",
                                    "method_body": "static final ZipShort HEADER_ID = new ZipShort(0x0001);\n* parseFromCentralDirectoryData} so it can be reused when ZipFile"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:dosToJavaTime(J)J",
                                    "method_body": "public static long dosToJavaTime(long dosTime) {\nCalendar cal = Calendar.getInstance();\ncal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\ncal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\ncal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);\ncal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);\ncal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);\ncal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);\nreturn cal.getTime().getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:setNameAndCommentFromExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;[B[B)V",
                                    "method_body": "static void setNameAndCommentFromExtraFields(ZipArchiveEntry ze,\nUnicodePathExtraField name = (UnicodePathExtraField)\nString originalName = ze.getName();\nString newName = getUnicodeStringIfOriginalMatches(name,\nif (newName != null && !originalName.equals(newName)) {\nze.setName(newName);\nif (commentBytes != null && commentBytes.length > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:getUnicodeStringIfOriginalMatches(Lorg/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField;[B)Ljava/lang/String;",
                                    "method_body": "String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f,\nif (f != null) {\nCRC32 crc32 = new CRC32();\ncrc32.update(orig);\nlong origCRC32 = crc32.getValue();\nif (origCRC32 == f.getNameCRC32()) {\nreturn ZipEncodingHelper\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:copy([B)[B",
                                    "method_body": "static byte[] copy(byte[] from) {\nif (from != null) {\nbyte[] to = new byte[from.length];\nSystem.arraycopy(from, 0, to, 0, to.length);\nreturn to;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<init>(I)V",
                                    "method_body": "private UnparseableExtraField(int k) {\nkey = k;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<clinit>()V",
                                    "method_body": "public static final int THROW_KEY = 0;\npublic static final UnparseableExtraField THROW\npublic static final UnparseableExtraField SKIP\n* UnparseableExtraFieldData UnparseableExtraFieldData}."
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipFile(File f) throws IOException {\nthis(f, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;)V",
                                    "method_body": "public ZipFile(File f, String encoding) throws IOException {\nthis(f, encoding, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\nthrows IOException {\nthis.archiveName = f.getAbsolutePath();\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = new RandomAccessFile(f, \"r\");\nboolean success = false;\nMap<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag =\nresolveLocalFileHeaderData(entriesWithoutUTF8Flag);\nsuccess = true;\nif (!success) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<clinit>()V",
                                    "method_body": "private static final int CFH_LEN =\nprivate static final long CFH_SIG =\nHashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\npositionAtCentralDirectory();\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nif (sig != CFH_SIG && startsWithLocalFileHeader()) {\nwhile (sig == CFH_SIG) {\nreadCentralDirectoryEntry(noUTF8Flag);\narchive.readFully(signatureBytes);\nsig = ZipLong.getValue(signatureBytes);\nreturn noUTF8Flag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:close()V",
                                    "method_body": "public void close() throws IOException {\nclosed = true;\narchive.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
                                    "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\nzipfile.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:getEntry(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;",
                                    "method_body": "public ZipArchiveEntry getEntry(String name) {\nreturn nameMap.get(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory()\nHashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\npositionAtCentralDirectory();\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nif (sig != CFH_SIG && startsWithLocalFileHeader()) {\nwhile (sig == CFH_SIG) {\nreadCentralDirectoryEntry(noUTF8Flag);\narchive.readFully(signatureBytes);\nsig = ZipLong.getValue(signatureBytes);\nreturn noUTF8Flag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:readCentralDirectoryEntry(Ljava/util/Map;)V",
                                    "method_body": "private void\nbyte[] cfh = new byte[CFH_LEN];\narchive.readFully(cfh);\nint off = 0;\nZipArchiveEntry ze = new ZipArchiveEntry();\nint versionMadeBy = ZipShort.getValue(cfh, off);\noff += SHORT;\nze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\noff += SHORT; // skip version info\nfinal GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(cfh, off);\nfinal boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\nfinal ZipEncoding entryEncoding =\nze.setGeneralPurposeBit(gpFlag);\noff += SHORT;\nze.setMethod(ZipShort.getValue(cfh, off));\noff += SHORT;\nlong time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\nze.setTime(time);\noff += WORD;\nze.setCrc(ZipLong.getValue(cfh, off));\noff += WORD;\nze.setCompressedSize(ZipLong.getValue(cfh, off));\noff += WORD;\nze.setSize(ZipLong.getValue(cfh, off));\noff += WORD;\nint fileNameLen = ZipShort.getValue(cfh, off);\noff += SHORT;\nint extraLen = ZipShort.getValue(cfh, off);\noff += SHORT;\nint commentLen = ZipShort.getValue(cfh, off);\noff += SHORT;\nint diskStart = ZipShort.getValue(cfh, off);\noff += SHORT;\nze.setInternalAttributes(ZipShort.getValue(cfh, off));\noff += SHORT;\nze.setExternalAttributes(ZipLong.getValue(cfh, off));\noff += WORD;\nbyte[] fileName = new byte[fileNameLen];\narchive.readFully(fileName);\nze.setName(entryEncoding.decode(fileName), fileName);\nOffsetEntry offset = new OffsetEntry();\noffset.headerOffset = ZipLong.getValue(cfh, off);\nentries.put(ze, offset);\nnameMap.put(ze.getName(), ze);\nbyte[] cdExtraData = new byte[extraLen];\narchive.readFully(cdExtraData);\nze.setCentralDirectoryExtra(cdExtraData);\nsetSizesAndOffsetFromZip64Extra(ze, offset, diskStart);\nbyte[] comment = new byte[commentLen];\narchive.readFully(comment);\nze.setComment(entryEncoding.decode(comment));\nif (!hasUTF8Flag && useUnicodeExtraFields) {\nnoUTF8Flag.put(ze, new NameAndComment(fileName, comment));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:setSizesAndOffsetFromZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Lorg/apache/commons/compress/archivers/zip/ZipFile$OffsetEntry;I)V",
                                    "method_body": "private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze,\nZip64ExtendedInformationExtraField z64 =\nif (z64 != null) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nboolean found = tryToLocateSignature(MIN_EOCD_SIZE + ZIP64_EOCDL_LENGTH,\nif (!found) {\npositionAtCentralDirectory32();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory32()V",
                                    "method_body": "private void positionAtCentralDirectory32()\nboolean found = tryToLocateSignature(MIN_EOCD_SIZE, MAX_EOCD_SIZE,\nif (!found) {\nskipBytes(CFD_LOCATOR_OFFSET);\nbyte[] cfdOffset = new byte[WORD];\narchive.readFully(cfdOffset);\narchive.seek(ZipLong.getValue(cfdOffset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:tryToLocateSignature(JJ[B)Z",
                                    "method_body": "private boolean tryToLocateSignature(long minDistanceFromEnd,\nboolean found = false;\nlong off = archive.length() - minDistanceFromEnd;\nfinal long stopSearching =\nif (off >= 0) {\nfor (; off >= stopSearching; off--) {\narchive.seek(off);\nint curr = archive.read();\nif (curr == -1) {\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\nif (found) {\narchive.seek(off);\nreturn found;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:skipBytes(I)V",
                                    "method_body": "private void skipBytes(final int count) throws IOException {\nint totalSkipped = 0;\nwhile (totalSkipped < count) {\nint skippedNow = archive.skipBytes(count - totalSkipped);\nif (skippedNow <= 0) {\ntotalSkipped += skippedNow;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:resolveLocalFileHeaderData(Ljava/util/Map;)V",
                                    "method_body": "private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\nMap<ZipArchiveEntry, OffsetEntry> origMap =\nentries.clear();\nfor (ZipArchiveEntry ze : origMap.keySet()) {\nOffsetEntry offsetEntry = origMap.get(ze);\nlong offset = offsetEntry.headerOffset;\narchive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\nbyte[] b = new byte[SHORT];\narchive.readFully(b);\nint fileNameLen = ZipShort.getValue(b);\narchive.readFully(b);\nint extraFieldLen = ZipShort.getValue(b);\nint lenToSkip = fileNameLen;\nwhile (lenToSkip > 0) {\nint skipped = archive.skipBytes(lenToSkip);\nif (skipped <= 0) {\nlenToSkip -= skipped;\n}\nbyte[] localExtraData = new byte[extraFieldLen];\narchive.readFully(localExtraData);\nze.setExtra(localExtraData);\noffsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\nif (entriesWithoutUTF8Flag.containsKey(ze)) {\nString orig = ze.getName();\nNameAndComment nc = entriesWithoutUTF8Flag.get(ze);\nZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\nif (!orig.equals(ze.getName())) {\nnameMap.remove(orig);\nnameMap.put(ze.getName(), ze);\nentries.put(ze, offsetEntry);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$OffsetEntry:access$002(Lorg/apache/commons/compress/archivers/zip/ZipFile$OffsetEntry;J)J",
                                    "method_body": "private static final int HASH_SIZE = 509;\nprivate final Map<ZipArchiveEntry, OffsetEntry> entries =\nprivate final Map<String, ZipArchiveEntry> nameMap =\nprivate static final class OffsetEntry {\nprivate long headerOffset = -1;\nprivate long dataOffset = -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$OffsetEntry:<init>()V",
                                    "method_body": "private static final int HASH_SIZE = 509;\nprivate final Map<ZipArchiveEntry, OffsetEntry> entries =\nprivate final Map<String, ZipArchiveEntry> nameMap =\nprivate static final class OffsetEntry {\nprivate long headerOffset = -1;\nprivate long dataOffset = -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$NameAndComment:<init>([B[B)V",
                                    "method_body": "private NameAndComment(byte[] name, byte[] comment) {\nthis.name = name;\nthis.comment = comment;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setHeaderId(Lorg/apache/commons/compress/archivers/zip/ZipShort;)V",
                                    "method_body": "public void setHeaderId(ZipShort headerId) {\nthis.headerId = headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setLocalFileDataData([B)V",
                                    "method_body": "public void setLocalFileDataData(byte[] data) {\nlocalData = ZipUtil.copy(data);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn new ZipShort(localData.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn ZipUtil.copy(localData);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setCentralDirectoryData([B)V",
                                    "method_body": "public void setCentralDirectoryData(byte[] data) {\ncentralData = ZipUtil.copy(data);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:parseFromCentralDirectoryData([BII)V",
                                    "method_body": "public void parseFromCentralDirectoryData(byte[] data, int offset,\nbyte[] tmp = new byte[length];\nSystem.arraycopy(data, offset, tmp, 0, length);\nsetCentralDirectoryData(tmp);\nif (localData == null) {\nsetLocalFileDataData(tmp);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 14,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest.workaroundForBrokenTimeHeader",
                            "test_body": "51: public void workaroundForBrokenTimeHeader() throws Exception {\n52: URL tar = getClass().getResource(\"/simple-aix-native-tar.tar\");\n53: TarArchiveInputStream in = null;\n54: try {\n55: in = new TarArchiveInputStream(new FileInputStream(new File(new URI(tar.toString()))));\n56: TarArchiveEntry tae = in.getNextTarEntry();\n57: tae = in.getNextTarEntry();\n58: assertEquals(\"sample/link-to-txt-file.lnk\", tae.getName());\n59: assertEquals(new Date(0), tae.getLastModifiedDate());\n60: assertTrue(tae.isSymbolicLink());\n61: } finally {\n62: if (in != null) {\n63: in.close();\n64: }\n65: }\n66: }        \n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarBuffer(InputStream inStream, int blockSize, int recordSize) {\nthis(inStream, null, blockSize, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/InputStream;Ljava/io/OutputStream;II)V",
                                    "method_body": "private TarBuffer(InputStream inStream, OutputStream outStream, int blockSize, int recordSize) {\nthis.inStream = inStream;\nthis.outStream = outStream;\nthis.blockSize = blockSize;\nthis.recordSize = recordSize;\nthis.recsPerBlock = (this.blockSize / this.recordSize);\nthis.blockBuffer = new byte[this.blockSize];\nif (this.inStream != null) {\nthis.currBlkIdx = -1;\nthis.currRecIdx = this.recsPerBlock;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:getRecordSize()I",
                                    "method_body": "public int getRecordSize() {\nreturn this.recordSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:isEOFRecord([B)Z",
                                    "method_body": "public boolean isEOFRecord(byte[] record) {\nfor (int i = 0, sz = getRecordSize(); i < sz; ++i) {\nif (record[i] != 0) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:readRecord()[B",
                                    "method_body": "public byte[] readRecord() throws IOException {\nif (inStream == null) {\nif (currRecIdx >= recsPerBlock && !readBlock()) {\nbyte[] result = new byte[recordSize];\nSystem.arraycopy(blockBuffer,\ncurrRecIdx++;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:readBlock()Z",
                                    "method_body": "private boolean readBlock() throws IOException {\nif (inStream == null) {\ncurrRecIdx = 0;\nint offset = 0;\nint bytesNeeded = blockSize;\nwhile (bytesNeeded > 0) {\nlong numBytes = inStream.read(blockBuffer, offset,\nif (numBytes == -1) {\noffset += numBytes;\nbytesNeeded -= numBytes;\nif (numBytes != blockSize) {\n}\ncurrBlkIdx++;\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:close()V",
                                    "method_body": "public void close() throws IOException {\nif (outStream != null) {\n} else if (inStream != null) {\nif (inStream != System.in) {\ninStream.close();\ninStream = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry () {\nthis.magic = MAGIC_POSIX;\nthis.version = VERSION_POSIX;\nthis.name = \"\";\nthis.linkName = \"\";\nString user = System.getProperty(\"user.name\", \"\");\nif (user.length() > MAX_NAMELEN) {\nthis.userId = 0;\nthis.groupId = 0;\nthis.userName = user;\nthis.groupName = \"\";\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>([B)V",
                                    "method_body": "public TarArchiveEntry(byte[] headerBuf) {\nthis();\nparseTarHeader(headerBuf);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNUSparse()Z",
                                    "method_body": "public boolean isGNUSparse() {\nreturn linkFlag == LF_GNUTYPE_SPARSE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongNameEntry()Z",
                                    "method_body": "public boolean isGNULongNameEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGNAME\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isPaxHeader()Z",
                                    "method_body": "public boolean isPaxHeader(){\nreturn linkFlag == LF_PAX_EXTENDED_HEADER_LC\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nif (file != null) {\nif (linkFlag == LF_DIR) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([B)V",
                                    "method_body": "public void parseTarHeader(byte[] header) {\nint offset = 0;\nname = TarUtils.parseName(header, offset, NAMELEN);\noffset += NAMELEN;\nmode = (int) TarUtils.parseOctal(header, offset, MODELEN);\noffset += MODELEN;\nuserId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\noffset += UIDLEN;\ngroupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\noffset += GIDLEN;\nsize = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\noffset += SIZELEN;\nmodTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\noffset += MODTIMELEN;\noffset += CHKSUMLEN;\nlinkFlag = header[offset++];\nlinkName = TarUtils.parseName(header, offset, NAMELEN);\noffset += NAMELEN;\nmagic = TarUtils.parseName(header, offset, MAGICLEN);\noffset += MAGICLEN;\nversion = TarUtils.parseName(header, offset, VERSIONLEN);\noffset += VERSIONLEN;\nuserName = TarUtils.parseName(header, offset, UNAMELEN);\noffset += UNAMELEN;\ngroupName = TarUtils.parseName(header, offset, GNAMELEN);\noffset += GNAMELEN;\ndevMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\noffset += DEVLEN;\ndevMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\noffset += DEVLEN;\nint type = evaluateType(header);\nswitch (type) {\nString prefix = TarUtils.parseName(header, offset, PREFIXLEN);\nif (isDirectory() && !name.endsWith(\"/\")){\nif (prefix.length() > 0){\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:evaluateType([B)I",
                                    "method_body": "private int evaluateType(byte[] header) {\nfinal ByteBuffer magic = ByteBuffer.wrap(header, MAGIC_OFFSET, MAGICLEN);\nif (magic.compareTo(ByteBuffer.wrap(MAGIC_GNU.getBytes())) == 0)\nif (magic.compareTo(ByteBuffer.wrap(MAGIC_POSIX.getBytes())) == 0)\nreturn FORMAT_POSIX;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\nif (length < 2){\nboolean allNUL = true;\nfor (int i = start; i < end; i++){\nif (buffer[i] != 0){\nallNUL = false;\nbreak;\nif (allNUL) {\nwhile (start < end){\nif (buffer[start] == ' '){\ntrailer = buffer[end-1];\nif (trailer == 0 || trailer == ' '){\nend--;\ntrailer = buffer[end-1];\nif (trailer == 0 || trailer == ' '){\nend--;\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\nif (currentByte < '0' || currentByte > '7'){\nthrow new IllegalArgumentException(\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctalOrBinary([BII)J",
                                    "method_body": "public static long parseOctalOrBinary(final byte[] buffer, final int offset,\nif ((buffer[offset] & 0x80) == 0) {\nreturn parseOctal(buffer, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:exceptionMessage([BIIIB)Ljava/lang/String;",
                                    "method_body": "private static String exceptionMessage(byte[] buffer, final int offset,\nString string = new String(buffer, offset, length);\nstring=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed\nfinal String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;\nreturn s;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BII)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset, final int length) {\nStringBuffer result = new StringBuffer(length);\nint          end = offset + length;\nfor (int i = offset; i < end; ++i) {\nbyte b = buffer[i];\nif (b == 0) { // Trailing null\nbreak;\nresult.append((char) (b & 0xFF)); // Allow for sign-extension\nreturn result.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is) {\nthis(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\nthis.buffer = new TarBuffer(is, blockSize, recordSize);\nthis.readBuf = null;\nthis.hasHitEOF = false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nbuffer.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextTarEntry()Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;",
                                    "method_body": "public TarArchiveEntry getNextTarEntry() throws IOException {\nif (hasHitEOF) {\nif (currEntry != null) {\nlong numToSkip = entrySize - entryOffset;\nwhile (numToSkip > 0) {\nreadBuf = null;\nbyte[] headerBuf = getRecord();\nif (hasHitEOF) {\ncurrEntry = new TarArchiveEntry(headerBuf);\n} catch (IllegalArgumentException e) {\nIOException ioe = new IOException(\"Error detected parsing the header\");\nioe.initCause(e);\nthrow ioe;\n}\nentryOffset = 0;\nentrySize = currEntry.getSize();\nif (currEntry.isGNULongNameEntry()) {\nif (currEntry.isPaxHeader()){ // Process Pax headers\nif (currEntry.isGNUSparse()){ // Process sparse files\nentrySize = currEntry.getSize();\nreturn currEntry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getRecord()[B",
                                    "method_body": "private byte[] getRecord() throws IOException {\nif (hasHitEOF) {\nbyte[] headerBuf = buffer.readRecord();\nif (headerBuf == null) {\n} else if (buffer.isEOFRecord(headerBuf)) {\nreturn hasHitEOF ? null : headerBuf;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 15,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveEntryTest.testNullCommentEqualsEmptyComment",
                            "test_body": "243: public void testNullCommentEqualsEmptyComment() {\n244: ZipArchiveEntry entry1 = new ZipArchiveEntry(\"foo\");\n245: ZipArchiveEntry entry2 = new ZipArchiveEntry(\"foo\");\n246: ZipArchiveEntry entry3 = new ZipArchiveEntry(\"foo\");\n247: entry1.setComment(null);\n248: entry2.setComment(\"\");\n249: entry3.setComment(\"bar\");\n250: assertEquals(entry1, entry2);\n251: assertFalse(entry1.equals(entry3));\n252: assertFalse(entry2.equals(entry3));\n253: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/util/zip/ZipEntry;)V",
                                    "method_body": "private long size = SIZE_UNKNOWN;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate LinkedHashMap<ZipShort, ZipExtraField> extraFields = null;\nprivate UnparseableExtraFieldData unparseableExtra = null;\nprivate String name = null;\nprivate byte[] rawName = null;\nprivate GeneralPurposeBit gpb = new GeneralPurposeBit();\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "protected void setName(String name) {\nif (name != null && getPlatform() == PLATFORM_FAT\nname = name.replace('\\\\', '/');\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object obj) {\nif (this == obj) {\nif (obj == null || getClass() != obj.getClass()) {\nZipArchiveEntry other = (ZipArchiveEntry) obj;\nString myName = getName();\nString otherName = other.getName();\nif (myName == null) {\n} else if (!myName.equals(otherName)) {\nString myComment = getComment();\nString otherComment = other.getComment();\nif (myComment == null) {\nif (otherComment != null) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:<init>()V",
                                    "method_body": "public static final int UFT8_NAMES_FLAG = 1 << 11;\nprivate boolean languageEncodingFlag = false;\nprivate boolean dataDescriptorFlag = false;\nprivate boolean encryptionFlag = false;\nprivate boolean strongEncryptionFlag = false;\npublic GeneralPurposeBit() {\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 16,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest.aiffFilesAreNoTARs",
                            "test_body": "51: public void aiffFilesAreNoTARs() throws Exception {\n52: InputStream is = null;\n53: try {\n54: is = new BufferedInputStream(new FileInputStream(\"src/test/resources/testAIFF.aif\"));\n55: new ArchiveStreamFactory().createArchiveInputStream(is);\n56: fail(\"created an input stream for a non-archive\");\n57: } catch (ArchiveException ae) {\n58: assertTrue(ae.getMessage().startsWith(\"No Archiver found\"));\n59: } finally {\n60: if (is != null) {\n61: is.close();\n62: }\n63: }\n64: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveInputStream(Ljava/io/InputStream;)Lorg/apache/commons/compress/archivers/ArchiveInputStream;",
                                    "method_body": "public ArchiveInputStream createArchiveInputStream(final InputStream in)\nif (in == null) {\nif (!in.markSupported()) {\nfinal byte[] signature = new byte[12];\nin.mark(signature.length);\nint signatureLength = in.read(signature);\nin.reset();\nif (ZipArchiveInputStream.matches(signature, signatureLength)) {\n} else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n} else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n} else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\nfinal byte[] dumpsig = new byte[32];\nin.mark(dumpsig.length);\nsignatureLength = in.read(dumpsig);\nin.reset();\nif (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\nfinal byte[] tarheader = new byte[512];\nin.mark(tarheader.length);\nsignatureLength = in.read(tarheader);\nin.reset();\nif (TarArchiveInputStream.matches(tarheader, signatureLength)) {\nif (signatureLength >= 512) {\nTarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\ntais.getNextEntry();\nreturn new TarArchiveInputStream(in);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:matchAsciiBuffer(Ljava/lang/String;[BII)Z",
                                    "method_body": "public static boolean matchAsciiBuffer(\nbuffer1 = expected.getBytes(\"ASCII\");\n}\nreturn isEqual(buffer1, 0, buffer1.length, buffer, offset, length, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isEqual([BII[BIIZ)Z",
                                    "method_body": "public static boolean isEqual(\nint minLen=length1 < length2 ? length1 : length2;\nfor (int i=0; i < minLen; i++){\nif (buffer1[offset1+i] != buffer2[offset2+i]){\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < 6) {\nif (signature[0] == 0x71 && (signature[1] & 0xFF) == 0xc7) {\nif (signature[1] == 0x71 && (signature[0] & 0xFF) == 0xc7) {\nif (signature[0] != 0x30) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<clinit>()V",
                                    "method_body": "private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\nprivate static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\nprivate static final byte[] DD = ZipLong.DD_SIG.getBytes();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < ZipArchiveOutputStream.LFH_SIG.length) {\nreturn checksig(signature, ZipArchiveOutputStream.LFH_SIG) // normal file\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:checksig([B[B)Z",
                                    "method_body": "private static boolean checksig(byte[] signature, byte[] expected){\nfor (int i = 0; i < expected.length; i++) {\nif (signature[i] != expected[i]) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int BYTE_1 = 1;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes();\nstatic final byte[] DD_SIG = ZipLong.DD_SIG.getBytes();\nstatic final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes();\nstatic final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\nstatic final byte[] ZIP64_EOCD_SIG = ZipLong.getBytes(0X06064B50L);\nstatic final byte[] ZIP64_EOCD_LOC_SIG = ZipLong.getBytes(0X07064B50L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length ) {\nreturn ZipArchiveInputStream.matches(signature, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:<clinit>()V",
                                    "method_body": "static final String BSD_LONGNAME_PREFIX = \"#1/\";\nprivate static final int BSD_LONGNAME_PREFIX_LEN =\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < 8) {\nif (signature[0] != 0x21) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] buffer, int length) {\nif (length < 32) {\nif (length >= DumpArchiveConstants.TP_SIZE) {\nreturn DumpArchiveConstants.NFS_MAGIC == DumpArchiveUtil.convert32(buffer,\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert32([BI)I",
                                    "method_body": "public static final int convert32(byte[] buffer, int offset) {\nint i = 0;\ni = buffer[offset + 3] << 24;\ni += (buffer[offset + 2] << 16) & 0x00FF0000;\ni += (buffer[offset + 1] << 8) & 0x0000FF00;\ni += buffer[offset] & 0x000000FF;\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\nsimpleEncodings = new HashMap<String, SimpleEncodingHolder>();\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\nencoding = System.getProperty(\"file.encoding\");\nreturn UTF8.equalsIgnoreCase(encoding)\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data,this.charset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarBuffer(InputStream inStream, int blockSize, int recordSize) {\nthis(inStream, null, blockSize, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/InputStream;Ljava/io/OutputStream;II)V",
                                    "method_body": "private TarBuffer(InputStream inStream, OutputStream outStream, int blockSize, int recordSize) {\nthis.inStream = inStream;\nthis.outStream = outStream;\nthis.blockSize = blockSize;\nthis.recordSize = recordSize;\nthis.recsPerBlock = (this.blockSize / this.recordSize);\nthis.blockBuffer = new byte[this.blockSize];\nif (this.inStream != null) {\nthis.currBlkIdx = -1;\nthis.currRecIdx = this.recsPerBlock;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:getRecordSize()I",
                                    "method_body": "public int getRecordSize() {\nreturn this.recordSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:isEOFRecord([B)Z",
                                    "method_body": "public boolean isEOFRecord(byte[] record) {\nfor (int i = 0, sz = getRecordSize(); i < sz; ++i) {\nif (record[i] != 0) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:readRecord()[B",
                                    "method_body": "public byte[] readRecord() throws IOException {\nif (inStream == null) {\nif (currRecIdx >= recsPerBlock && !readBlock()) {\nbyte[] result = new byte[recordSize];\nSystem.arraycopy(blockBuffer,\ncurrRecIdx++;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:readBlock()Z",
                                    "method_body": "private boolean readBlock() throws IOException {\nif (inStream == null) {\ncurrRecIdx = 0;\nint offset = 0;\nint bytesNeeded = blockSize;\nwhile (bytesNeeded > 0) {\nlong numBytes = inStream.read(blockBuffer, offset,\nif (numBytes == -1) {\nif (offset == 0) {\nArrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\nbreak;\noffset += numBytes;\nbytesNeeded -= numBytes;\nif (numBytes != blockSize) {\n}\ncurrBlkIdx++;\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry() {\nthis.magic = MAGIC_POSIX;\nthis.version = VERSION_POSIX;\nthis.name = \"\";\nthis.linkName = \"\";\nString user = System.getProperty(\"user.name\", \"\");\nif (user.length() > MAX_NAMELEN) {\nthis.userId = 0;\nthis.groupId = 0;\nthis.userName = user;\nthis.groupName = \"\";\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public TarArchiveEntry(byte[] headerBuf, ZipEncoding encoding)\nthis();\nparseTarHeader(headerBuf, encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNUSparse()Z",
                                    "method_body": "public boolean isGNUSparse() {\nreturn linkFlag == LF_GNUTYPE_SPARSE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongNameEntry()Z",
                                    "method_body": "public boolean isGNULongNameEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGNAME\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isPaxHeader()Z",
                                    "method_body": "public boolean isPaxHeader(){\nreturn linkFlag == LF_PAX_EXTENDED_HEADER_LC\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nif (file != null) {\nif (linkFlag == LF_DIR) {\nif (getName().endsWith(\"/\")) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public void parseTarHeader(byte[] header, ZipEncoding encoding)\nparseTarHeader(header, encoding, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;Z)V",
                                    "method_body": "private void parseTarHeader(byte[] header, ZipEncoding encoding,\nint offset = 0;\nname = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\noffset += NAMELEN;\nmode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN);\noffset += MODELEN;\nuserId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\noffset += UIDLEN;\ngroupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\noffset += GIDLEN;\nsize = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\noffset += SIZELEN;\nmodTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN);\noffset += MODTIMELEN;\ncheckSumOK = TarUtils.verifyCheckSum(header);\noffset += CHKSUMLEN;\nlinkFlag = header[offset++];\nlinkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\noffset += NAMELEN;\nmagic = TarUtils.parseName(header, offset, MAGICLEN);\noffset += MAGICLEN;\nversion = TarUtils.parseName(header, offset, VERSIONLEN);\noffset += VERSIONLEN;\nuserName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)\noffset += UNAMELEN;\ngroupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN)\noffset += GNAMELEN;\ndevMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\ndevMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\nint type = evaluateType(header);\nswitch (type) {\nString prefix = oldStyle\nif (isDirectory() && !name.endsWith(\"/\")){\nif (prefix.length() > 0){\nname = prefix + \"/\" + name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:evaluateType([B)I",
                                    "method_body": "private int evaluateType(byte[] header) {\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_GNU, header, MAGIC_OFFSET, MAGICLEN)) {\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_POSIX, header, MAGIC_OFFSET, MAGICLEN)) {\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:<clinit>()V",
                                    "method_body": "private static final int BYTE_MASK = 255;\nstatic final ZipEncoding DEFAULT_ENCODING =\nstatic final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\nif (length < 2){\nif (buffer[start] == 0) {\nreturn 0L;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctalOrBinary([BII)J",
                                    "method_body": "public static long parseOctalOrBinary(final byte[] buffer, final int offset,\nif ((buffer[offset] & 0x80) == 0) {\nreturn parseOctal(buffer, offset, length);\nfinal boolean negative = buffer[offset] == (byte) 0xff;\nif (length < 9) {\nreturn parseBinaryLong(buffer, offset, length, negative);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseBinaryLong([BIIZ)J",
                                    "method_body": "private static long parseBinaryLong(final byte[] buffer, final int offset,\nif (length >= 9) {\nlong val = 0;\nfor (int i = 1; i < length; i++) {\nval = (val << 8) + (buffer[offset + i] & 0xff);\nif (negative) {\nreturn negative ? -val : val;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BII)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset, final int length) {\nreturn parseName(buffer, offset, length, DEFAULT_ENCODING);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BIILorg/apache/commons/compress/archivers/zip/ZipEncoding;)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset,\nint len = length;\nfor (; len > 0; len--) {\nif (buffer[offset + len - 1] != 0) {\nbreak;\nif (len > 0) {\nbyte[] b = new byte[len];\nSystem.arraycopy(buffer, offset, b, 0, len);\nreturn encoding.decode(b);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:verifyCheckSum([B)Z",
                                    "method_body": "public static boolean verifyCheckSum(byte[] header) {\nlong storedSum = 0;\nlong unsignedSum = 0;\nlong signedSum = 0;\nint digits = 0;\nfor (int i = 0; i < header.length; i++) {\nbyte b = header[i];\nif (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\nif ('0' <= b && b <= '7' && digits++ < 6) {\n} else if (digits > 0) {\nb = ' ';\nunsignedSum += 0xff & b;\nsignedSum += b;\nreturn storedSum == unsignedSum || storedSum == signedSum\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is) {\nthis(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\nthis(is, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;IILjava/lang/String;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize,\nString encoding) {\nthis.buffer = new TarBuffer(is, blockSize, recordSize);\nthis.readBuf = null;\nthis.hasHitEOF = false;\nthis.encoding = ZipEncodingHelper.getZipEncoding(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextTarEntry()Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;",
                                    "method_body": "public TarArchiveEntry getNextTarEntry() throws IOException {\nif (hasHitEOF) {\nif (currEntry != null) {\nbyte[] headerBuf = getRecord();\nif (hasHitEOF) {\ncurrEntry = new TarArchiveEntry(headerBuf, encoding);\n}\nentryOffset = 0;\nentrySize = currEntry.getSize();\nif (currEntry.isGNULongNameEntry()) {\nif (currEntry.isPaxHeader()){ // Process Pax headers\nif (currEntry.isGNUSparse()){ // Process sparse files\nentrySize = currEntry.getSize();\nreturn currEntry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getRecord()[B",
                                    "method_body": "private byte[] getRecord() throws IOException {\nif (hasHitEOF) {\nbyte[] headerBuf = buffer.readRecord();\nif (headerBuf == null) {\n} else if (buffer.isEOFRecord(headerBuf)) {\nreturn hasHitEOF ? null : headerBuf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextEntry()Lorg/apache/commons/compress/archivers/ArchiveEntry;",
                                    "method_body": "public ArchiveEntry getNextEntry() throws IOException {\nreturn getNextTarEntry();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < TarConstants.VERSION_OFFSET+TarConstants.VERSIONLEN) {\nif (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_POSIX,\nif (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_GNU,\nif (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_ANT,\nreturn false;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 17,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest.testCompress197",
                            "test_body": "126: public void testCompress197() throws Exception {\n127: TarArchiveInputStream tar = getTestStream(\"/COMPRESS-197.tar\");\n128: try {\n129: TarArchiveEntry entry = tar.getNextTarEntry();\n130: while (entry != null) {\n131: entry = tar.getNextTarEntry();\n132: }\n133: } catch (IOException e) {\n134: fail(\"COMPRESS-197: \" + e.getMessage());\n135: } finally {\n136: tar.close();\n137: }\n138: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\nsimpleEncodings = new HashMap<String, SimpleEncodingHolder>();\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\nencoding = System.getProperty(\"file.encoding\");\nreturn UTF8.equalsIgnoreCase(encoding)\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data,this.charset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarBuffer(InputStream inStream, int blockSize, int recordSize) {\nthis(inStream, null, blockSize, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/InputStream;Ljava/io/OutputStream;II)V",
                                    "method_body": "private TarBuffer(InputStream inStream, OutputStream outStream, int blockSize, int recordSize) {\nthis.inStream = inStream;\nthis.outStream = outStream;\nthis.blockSize = blockSize;\nthis.recordSize = recordSize;\nthis.recsPerBlock = (this.blockSize / this.recordSize);\nthis.blockBuffer = new byte[this.blockSize];\nif (this.inStream != null) {\nthis.currBlkIdx = -1;\nthis.currRecIdx = this.recsPerBlock;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:getRecordSize()I",
                                    "method_body": "public int getRecordSize() {\nreturn this.recordSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:isEOFRecord([B)Z",
                                    "method_body": "public boolean isEOFRecord(byte[] record) {\nfor (int i = 0, sz = getRecordSize(); i < sz; ++i) {\nif (record[i] != 0) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:readRecord()[B",
                                    "method_body": "public byte[] readRecord() throws IOException {\nif (inStream == null) {\nif (currRecIdx >= recsPerBlock && !readBlock()) {\nbyte[] result = new byte[recordSize];\nSystem.arraycopy(blockBuffer,\ncurrRecIdx++;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:readBlock()Z",
                                    "method_body": "private boolean readBlock() throws IOException {\nif (inStream == null) {\ncurrRecIdx = 0;\nint offset = 0;\nint bytesNeeded = blockSize;\nwhile (bytesNeeded > 0) {\nlong numBytes = inStream.read(blockBuffer, offset,\nif (numBytes == -1) {\nif (offset == 0) {\nArrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\nbreak;\noffset += numBytes;\nbytesNeeded -= numBytes;\nif (numBytes != blockSize) {\n}\ncurrBlkIdx++;\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:close()V",
                                    "method_body": "public void close() throws IOException {\nif (outStream != null) {\n} else if (inStream != null) {\nif (inStream != System.in) {\ninStream.close();\ninStream = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry() {\nthis.magic = MAGIC_POSIX;\nthis.version = VERSION_POSIX;\nthis.name = \"\";\nthis.linkName = \"\";\nString user = System.getProperty(\"user.name\", \"\");\nif (user.length() > MAX_NAMELEN) {\nthis.userId = 0;\nthis.groupId = 0;\nthis.userName = user;\nthis.groupName = \"\";\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public TarArchiveEntry(byte[] headerBuf, ZipEncoding encoding)\nthis();\nparseTarHeader(headerBuf, encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public void parseTarHeader(byte[] header, ZipEncoding encoding)\nparseTarHeader(header, encoding, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;Z)V",
                                    "method_body": "private void parseTarHeader(byte[] header, ZipEncoding encoding,\nint offset = 0;\nname = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\noffset += NAMELEN;\nmode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN);\noffset += MODELEN;\nuserId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:<clinit>()V",
                                    "method_body": "private static final int BYTE_MASK = 255;\nstatic final ZipEncoding DEFAULT_ENCODING =\nstatic final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\nif (length < 2){\nif (buffer[start] == 0) {\nwhile (start < end){\nif (buffer[start] == ' '){\ntrailer = buffer[end-1];\nif (trailer == 0 || trailer == ' '){\nend--;\ntrailer = buffer[end - 1];\nif (trailer == 0 || trailer == ' '){\nend--;\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\nif (currentByte < '0' || currentByte > '7'){\nthrow new IllegalArgumentException(\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctalOrBinary([BII)J",
                                    "method_body": "public static long parseOctalOrBinary(final byte[] buffer, final int offset,\nif ((buffer[offset] & 0x80) == 0) {\nreturn parseOctal(buffer, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:exceptionMessage([BIIIB)Ljava/lang/String;",
                                    "method_body": "private static String exceptionMessage(byte[] buffer, final int offset,\nString string = new String(buffer, offset, length); // TODO default charset?\nstring=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed\nfinal String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;\nreturn s;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BIILorg/apache/commons/compress/archivers/zip/ZipEncoding;)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset,\nint len = length;\nfor (; len > 0; len--) {\nif (buffer[offset + len - 1] != 0) {\nbreak;\nif (len > 0) {\nbyte[] b = new byte[len];\nSystem.arraycopy(buffer, offset, b, 0, len);\nreturn encoding.decode(b);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is) {\nthis(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\nthis(is, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;IILjava/lang/String;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize,\nString encoding) {\nthis.buffer = new TarBuffer(is, blockSize, recordSize);\nthis.readBuf = null;\nthis.hasHitEOF = false;\nthis.encoding = ZipEncodingHelper.getZipEncoding(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nbuffer.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextTarEntry()Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;",
                                    "method_body": "public TarArchiveEntry getNextTarEntry() throws IOException {\nif (hasHitEOF) {\nif (currEntry != null) {\nbyte[] headerBuf = getRecord();\nif (hasHitEOF) {\ncurrEntry = new TarArchiveEntry(headerBuf, encoding);\n} catch (IllegalArgumentException e) {\nIOException ioe = new IOException(\"Error detected parsing the header\");\nioe.initCause(e);\nthrow ioe;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getRecord()[B",
                                    "method_body": "private byte[] getRecord() throws IOException {\nif (hasHitEOF) {\nbyte[] headerBuf = buffer.readRecord();\nif (headerBuf == null) {\n} else if (buffer.isEOFRecord(headerBuf)) {\nreturn hasHitEOF ? null : headerBuf;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 18,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest.testWriteNonAsciiDirectoryNamePosixMode",
                            "test_body": "412: public void testWriteNonAsciiDirectoryNamePosixMode() throws Exception {\n413: String n = \"f\\u00f6\\u00f6/\";\n414: TarArchiveEntry t = new TarArchiveEntry(n);\n415: ByteArrayOutputStream bos = new ByteArrayOutputStream();\n416: TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n417: tos.setAddPaxHeadersForNonAsciiNames(true);\n418: tos.putArchiveEntry(t);\n419: tos.closeArchiveEntry();\n420: tos.close();\n421: byte[] data = bos.toByteArray();\n422: TarArchiveInputStream tin =\n423: new TarArchiveInputStream(new ByteArrayInputStream(data));\n424: TarArchiveEntry e = tin.getNextTarEntry();\n425: assertEquals(n, e.getName());\n426: assertTrue(e.isDirectory());\n427: tin.close();\n428: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveOutputStream:<init>()V",
                                    "method_body": "private final byte[] oneByte = new byte[1];\nprivate long bytesWritten = 0;\n* {@link #closeArchiveEntry()} to complete the process."
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\nMap<String, SimpleEncodingHolder> se =\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\nif (name == null) {\nSimpleEncodingHolder h = simpleEncodings.get(name);\nif (h!=null) {\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\nencoding = System.getProperty(\"file.encoding\");\nreturn UTF8.equalsIgnoreCase(encoding)\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(String name) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn ByteBuffer.wrap(name.getBytes(this.charset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public TarArchiveOutputStream(OutputStream os) {\nthis(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;II)V",
                                    "method_body": "public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) {\nthis(os, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;IILjava/lang/String;)V",
                                    "method_body": "public TarArchiveOutputStream(OutputStream os, int blockSize,\nint recordSize, String encoding) {\nout = new CountingOutputStream(os);\nthis.encoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.buffer = new TarBuffer(out, blockSize, recordSize);\nthis.assemLen = 0;\nthis.assemBuf = new byte[recordSize];\nthis.recordBuf = new byte[recordSize];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<clinit>()V",
                                    "method_body": "public static final int LONGFILE_ERROR = 0;\nprivate int       longFileMode = LONGFILE_ERROR;\nprivate int       bigNumberMode = BIGNUMBER_ERROR;\nprivate boolean closed = false;\nprivate boolean haveUnclosedEntry = false;\nprivate boolean finished = false;\nprivate boolean addPaxHeadersForNonAsciiNames = false;\nprivate static final ZipEncoding ASCII =\nthis(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:setAddPaxHeadersForNonAsciiNames(Z)V",
                                    "method_body": "public void setAddPaxHeadersForNonAsciiNames(boolean b) {\naddPaxHeadersForNonAsciiNames = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\nif(finished) {\nTarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\nMap<String, String> paxHeaders = new HashMap<String, String>();\nfinal String entryName = entry.getName();\nfinal ByteBuffer encodedName = encoding.encode(entryName);\nfinal int nameLen = encodedName.limit() - encodedName.position();\nboolean paxHeaderContainsPath = false;\nif (nameLen >= TarConstants.NAMELEN) {\nif (bigNumberMode == BIGNUMBER_POSIX) {\n} else if (bigNumberMode != BIGNUMBER_STAR) {\nfailForBigNumbers(entry);\nif (addPaxHeadersForNonAsciiNames && !paxHeaderContainsPath\npaxHeaders.put(\"path\", entryName);\nif (addPaxHeadersForNonAsciiNames\nif (paxHeaders.size() > 0) {\nwritePaxHeaders(entryName, paxHeaders);\nentry.writeEntryHeader(recordBuf, encoding,\nbuffer.writeRecord(recordBuf);\ncurrBytes = 0;\nif (entry.isDirectory()) {\ncurrSize = 0;\ncurrName = entryName;\nhaveUnclosedEntry = true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\nif ((currBytes + numToWrite) > currSize) {\nthrow new IOException(\"request to write '\" + numToWrite\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:writePaxHeaders(Ljava/lang/String;Ljava/util/Map;)V",
                                    "method_body": "void writePaxHeaders(String entryName,\nString name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\nif (name.length() >= TarConstants.NAMELEN) {\nTarArchiveEntry pex = new TarArchiveEntry(name,\nStringWriter w = new StringWriter();\nfor (Map.Entry<String, String> h : headers.entrySet()) {\nString key = h.getKey();\nString value = h.getValue();\nint len = key.length() + value.length()\nString line = len + \" \" + key + \"=\" + value + \"\\n\";\nint actualLength = line.getBytes(CharsetNames.UTF_8).length;\nwhile (len != actualLength) {\nlen = actualLength;\nline = len + \" \" + key + \"=\" + value + \"\\n\";\nactualLength = line.getBytes(CharsetNames.UTF_8).length;\nw.write(line);\n}\nbyte[] data = w.toString().getBytes(CharsetNames.UTF_8);\npex.setSize(data.length);\nputArchiveEntry(pex);\nwrite(data);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:stripTo7Bits(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private String stripTo7Bits(String name) {\nfinal int length = name.length();\nStringBuffer result = new StringBuffer(length);\nfor (int i = 0; i < length; i++) {\nchar stripped = (char) (name.charAt(i) & 0x7F);\nif (stripped != 0) { // would be read as Trailing null\nresult.append(stripped);\nreturn result.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:failForBigNumbers(Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;)V",
                                    "method_body": "private void failForBigNumbers(TarArchiveEntry entry) {\nfailForBigNumber(\"entry size\", entry.getSize(), TarConstants.MAXSIZE);\nfailForBigNumber(\"group id\", entry.getGroupId(), TarConstants.MAXID);\nfailForBigNumber(\"last modification time\",\nfailForBigNumber(\"user id\", entry.getUserId(), TarConstants.MAXID);\nfailForBigNumber(\"mode\", entry.getMode(), TarConstants.MAXID);\nfailForBigNumber(\"major device number\", entry.getDevMajor(),\nfailForBigNumber(\"minor device number\", entry.getDevMinor(),\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:failForBigNumber(Ljava/lang/String;JJ)V",
                                    "method_body": "private void failForBigNumber(String field, long value, long maxValue) {\nif (value < 0 || value > maxValue) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:<init>(Ljava/nio/charset/Charset;)V",
                                    "method_body": "public NioZipEncoding(Charset charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:canEncode(Ljava/lang/String;)Z",
                                    "method_body": "public boolean canEncode(String name) {\nCharsetEncoder enc = this.charset.newEncoder();\nenc.onMalformedInput(CodingErrorAction.REPORT);\nenc.onUnmappableCharacter(CodingErrorAction.REPORT);\nreturn enc.canEncode(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public CountingOutputStream(final OutputStream out) {\nsuper(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/OutputStream;II)V",
                                    "method_body": "public TarBuffer(OutputStream outStream, int blockSize, int recordSize) {\nthis(null, outStream, blockSize, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/InputStream;Ljava/io/OutputStream;II)V",
                                    "method_body": "private TarBuffer(InputStream inStream, OutputStream outStream, int blockSize, int recordSize) {\nthis.inStream = inStream;\nthis.outStream = outStream;\nthis.blockSize = blockSize;\nthis.recordSize = recordSize;\nthis.recsPerBlock = (this.blockSize / this.recordSize);\nthis.blockBuffer = new byte[this.blockSize];\nif (this.inStream != null) {\nthis.currBlkIdx = 0;\nthis.currRecIdx = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:writeRecord([B)V",
                                    "method_body": "public void writeRecord(byte[] record) throws IOException {\nif (outStream == null) {\nif (record.length != recordSize) {\nif (currRecIdx >= recsPerBlock) {\nSystem.arraycopy(record, 0, blockBuffer,\ncurrRecIdx++;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry() {\nthis.magic = MAGIC_POSIX;\nthis.version = VERSION_POSIX;\nthis.name = \"\";\nthis.linkName = \"\";\nString user = System.getProperty(\"user.name\", \"\");\nif (user.length() > MAX_NAMELEN) {\nthis.userId = 0;\nthis.groupId = 0;\nthis.userName = user;\nthis.groupName = \"\";\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public TarArchiveEntry(String name) {\nthis(name, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/lang/String;Z)V",
                                    "method_body": "public TarArchiveEntry(String name, boolean preserveLeadingSlashes) {\nthis();\nname = normalizeFileName(name, preserveLeadingSlashes);\nboolean isDir = name.endsWith(\"/\");\nthis.devMajor = 0;\nthis.devMinor = 0;\nthis.name = name;\nthis.mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE;\nthis.linkFlag = isDir ? LF_DIR : LF_NORMAL;\nthis.userId = 0;\nthis.groupId = 0;\nthis.size = 0;\nthis.modTime = (new Date()).getTime() / MILLIS_PER_SECOND;\nthis.linkName = \"\";\nthis.userName = \"\";\nthis.groupName = \"\";\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/lang/String;B)V",
                                    "method_body": "public TarArchiveEntry(String name, byte linkFlag) {\nthis(name);\nthis.linkFlag = linkFlag;\nif (linkFlag == LF_GNUTYPE_LONGNAME) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getUserId()I",
                                    "method_body": "public int getUserId() {\nreturn userId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getGroupId()I",
                                    "method_body": "public int getGroupId() {\nreturn groupId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getModTime()Ljava/util/Date;",
                                    "method_body": "public Date getModTime() {\nreturn new Date(modTime * MILLIS_PER_SECOND);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getMode()I",
                                    "method_body": "public int getMode() {\nreturn mode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nif (size < 0){\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getDevMajor()I",
                                    "method_body": "public int getDevMajor() {\nreturn devMajor;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getDevMinor()I",
                                    "method_body": "public int getDevMinor() {\nreturn devMinor;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nif (file != null) {\nif (linkFlag == LF_DIR) {\nif (getName().endsWith(\"/\")) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isSymbolicLink()Z",
                                    "method_body": "public boolean isSymbolicLink() {\nreturn linkFlag == LF_SYMLINK;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isLink()Z",
                                    "method_body": "public boolean isLink() {\nreturn linkFlag == LF_LINK;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:writeEntryHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;Z)V",
                                    "method_body": "public void writeEntryHeader(byte[] outbuf, ZipEncoding encoding,\nint offset = 0;\noffset = TarUtils.formatNameBytes(name, outbuf, offset, NAMELEN,\noffset = writeEntryHeaderField(mode, outbuf, offset, MODELEN, starMode);\noffset = writeEntryHeaderField(userId, outbuf, offset, UIDLEN,\noffset = writeEntryHeaderField(groupId, outbuf, offset, GIDLEN,\noffset = writeEntryHeaderField(size, outbuf, offset, SIZELEN, starMode);\noffset = writeEntryHeaderField(modTime, outbuf, offset, MODTIMELEN,\nint csOffset = offset;\nfor (int c = 0; c < CHKSUMLEN; ++c) {\noutbuf[offset++] = (byte) ' ';\noutbuf[offset++] = linkFlag;\noffset = TarUtils.formatNameBytes(linkName, outbuf, offset, NAMELEN,\noffset = TarUtils.formatNameBytes(magic, outbuf, offset, MAGICLEN);\noffset = TarUtils.formatNameBytes(version, outbuf, offset, VERSIONLEN);\noffset = TarUtils.formatNameBytes(userName, outbuf, offset, UNAMELEN,\noffset = TarUtils.formatNameBytes(groupName, outbuf, offset, GNAMELEN,\noffset = writeEntryHeaderField(devMajor, outbuf, offset, DEVLEN,\noffset = writeEntryHeaderField(devMinor, outbuf, offset, DEVLEN,\nwhile (offset < outbuf.length) {\noutbuf[offset++] = 0;\nlong chk = TarUtils.computeCheckSum(outbuf);\nTarUtils.formatCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:writeEntryHeaderField(J[BIIZ)I",
                                    "method_body": "private int writeEntryHeaderField(long value, byte[] outbuf, int offset,\nif (!starMode && (value < 0\nreturn TarUtils.formatLongOctalOrBinaryBytes(value, outbuf, offset,\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:normalizeFileName(Ljava/lang/String;Z)Ljava/lang/String;",
                                    "method_body": "private static String normalizeFileName(String fileName,\nString osname = System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH);\nif (osname != null) {\nif (osname.startsWith(\"windows\")) {\n} else if (osname.indexOf(\"netware\") > -1) {\nfileName = fileName.replace(File.separatorChar, '/');\nwhile (!preserveLeadingSlashes && fileName.startsWith(\"/\")) {\nreturn fileName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:<clinit>()V",
                                    "method_body": "private static final int BYTE_MASK = 255;\nstatic final ZipEncoding DEFAULT_ENCODING =\nstatic final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatNameBytes(Ljava/lang/String;[BII)I",
                                    "method_body": "public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {\nreturn formatNameBytes(name, buf, offset, length, DEFAULT_ENCODING);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatNameBytes(Ljava/lang/String;[BIILorg/apache/commons/compress/archivers/zip/ZipEncoding;)I",
                                    "method_body": "public static int formatNameBytes(String name, byte[] buf, final int offset,\nint len = name.length();\nByteBuffer b = encoding.encode(name);\nwhile (b.limit() > length && len > 0) {\nfinal int limit = b.limit() - b.position();\nSystem.arraycopy(b.array(), b.arrayOffset(), buf, offset, limit);\nfor (int i = limit; i < length; ++i) {\nbuf[offset + i] = 0;\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatUnsignedOctalString(J[BII)V",
                                    "method_body": "public static void formatUnsignedOctalString(final long value, byte[] buffer,\nint remaining = length;\nremaining--;\nif (value == 0) {\nbuffer[offset + remaining--] = (byte) '0';\nlong val = value;\nfor (; remaining >= 0 && val != 0; --remaining) {\nbuffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));\nval = val >>> 3;\nif (val != 0){\nfor (; remaining >= 0; --remaining) { // leading zeros\nbuffer[offset + remaining] = (byte) '0';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatLongOctalBytes(J[BII)I",
                                    "method_body": "public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {\nint idx=length-1; // For space\nformatUnsignedOctalString(value, buf, offset, idx);\nbuf[offset + idx] = (byte) ' '; // Trailing space\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatLongOctalOrBinaryBytes(J[BII)I",
                                    "method_body": "public static int formatLongOctalOrBinaryBytes(\nfinal long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\nfinal boolean negative = value < 0;\nif (!negative && value <= maxAsOctalChar) { // OK to store as octal chars\nreturn formatLongOctalBytes(value, buf, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatCheckSumOctalBytes(J[BII)I",
                                    "method_body": "public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {\nint idx=length-2; // for NUL and space\nformatUnsignedOctalString(value, buf, offset, idx);\nbuf[offset + idx++]   = 0; // Trailing null\nbuf[offset + idx]     = (byte) ' '; // Trailing space\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:computeCheckSum([B)J",
                                    "method_body": "public static long computeCheckSum(final byte[] buf) {\nlong sum = 0;\nfor (int i = 0; i < buf.length; ++i) {\nsum += BYTE_MASK & buf[i];\nreturn sum;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 19,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.ZipFileTest.testExcessDataInZip64ExtraField",
                            "test_body": "232: public void testExcessDataInZip64ExtraField() throws Exception {\n233: File archive = getFile(\"COMPRESS-228.zip\");\n234: zf = new ZipFile(archive);\n235: // actually, if we get here, the test already has passed\n236: 237: ZipArchiveEntry ze = zf.getEntry(\"src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\");\n238: assertEquals(26101, ze.getSize());\n239: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>([BI)V",
                                    "method_body": "public ZipLong (byte[] bytes, int offset) {\nvalue = ZipLong.getValue(bytes, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "public static final int EFS_FLAG = GeneralPurposeBit.UFT8_NAMES_FLAG;\nprivate static final byte[] EMPTY = new byte[0];\nprivate static final byte[] ZERO = {0, 0};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final byte[] HEX_DIGITS =\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\nreturn UTF8.equalsIgnoreCase(encoding)\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data,this.charset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/util/zip/ZipEntry;)V",
                                    "method_body": "private long size = SIZE_UNKNOWN;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate LinkedHashMap<ZipShort, ZipExtraField> extraFields = null;\nprivate UnparseableExtraFieldData unparseableExtra = null;\nprivate String name = null;\nprivate byte[] rawName = null;\nprivate GeneralPurposeBit gpb = new GeneralPurposeBit();\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "protected ZipArchiveEntry() {\nthis(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<clinit>()V",
                                    "method_body": "public static final int PLATFORM_UNIX = 3;\nprivate static final byte[] EMPTY = new byte[0];\n* The {@link java.util.zip.ZipEntry} base class only supports"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setMethod(I)V",
                                    "method_body": "public void setMethod(int method) {\nif (method < 0) {\nthis.method = method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setInternalAttributes(I)V",
                                    "method_body": "public void setInternalAttributes(int value) {\ninternalAttributes = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExternalAttributes(J)V",
                                    "method_body": "public void setExternalAttributes(long value) {\nexternalAttributes = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setPlatform(I)V",
                                    "method_body": "protected void setPlatform(int platform) {\nthis.platform = platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void setExtraFields(ZipExtraField[] fields) {\nextraFields = new LinkedHashMap<ZipShort, ZipExtraField>();\nfor (ZipExtraField field : fields) {\nif (field instanceof UnparseableExtraFieldData) {\nextraFields.put(field.getHeaderId(), field);\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields(Z)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields(boolean includeUnparseable) {\nif (extraFields == null) {\nList<ZipExtraField> result =\nif (includeUnparseable && unparseableExtra != null) {\nreturn result.toArray(new ZipExtraField[0]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField getExtraField(ZipShort type) {\nif (extraFields != null) {\nreturn extraFields.get(type);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields(true)));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setCentralDirectoryExtra([B)V",
                                    "method_body": "public void setCentralDirectoryExtra(byte[] b) {\nZipExtraField[] central =\nmergeExtraFields(central, false);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "protected void setName(String name) {\nif (name != null && getPlatform() == PLATFORM_FAT\nname = name.replace('\\\\', '/');\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nif (size < 0) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;[B)V",
                                    "method_body": "protected void setName(String name, byte[] rawName) {\nsetName(name);\nthis.rawName = rawName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setGeneralPurposeBit(Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;)V",
                                    "method_body": "public void setGeneralPurposeBit(GeneralPurposeBit b) {\ngpb = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:mergeExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;Z)V",
                                    "method_body": "private void mergeExtraFields(ZipExtraField[] f, boolean local)\nif (extraFields == null) {\nsetExtraFields(f);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:<init>()V",
                                    "method_body": "public static final int UFT8_NAMES_FLAG = 1 << 11;\nprivate boolean languageEncodingFlag = false;\nprivate boolean dataDescriptorFlag = false;\nprivate boolean encryptionFlag = false;\nprivate boolean strongEncryptionFlag = false;\npublic GeneralPurposeBit() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesUTF8ForNames()Z",
                                    "method_body": "public boolean usesUTF8ForNames() {\nreturn languageEncodingFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useUTF8ForNames(Z)V",
                                    "method_body": "public void useUTF8ForNames(boolean b) {\nlanguageEncodingFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useDataDescriptor(Z)V",
                                    "method_body": "public void useDataDescriptor(boolean b) {\ndataDescriptorFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useEncryption(Z)V",
                                    "method_body": "public void useEncryption(boolean b) {\nencryptionFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useStrongEncryption(Z)V",
                                    "method_body": "public void useStrongEncryption(boolean b) {\nstrongEncryptionFlag = b;\nif (b) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:parse([BI)Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "public static GeneralPurposeBit parse(final byte[] data, final int offset) {\nfinal int generalPurposeFlag = ZipShort.getValue(data, offset);\nGeneralPurposeBit b = new GeneralPurposeBit();\nb.useDataDescriptor((generalPurposeFlag & DATA_DESCRIPTOR_FLAG) != 0);\nb.useUTF8ForNames((generalPurposeFlag & UFT8_NAMES_FLAG) != 0);\nb.useStrongEncryption((generalPurposeFlag & STRONG_ENCRYPTION_FLAG)\nb.useEncryption((generalPurposeFlag & ENCRYPTION_FLAG) != 0);\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>([BI)V",
                                    "method_body": "public ZipShort (byte[] bytes, int offset) {\nvalue = ZipShort.getValue(bytes, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([BI)I",
                                    "method_body": "public static int getValue(byte[] bytes, int offset) {\nint value = (bytes[offset + 1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object o) {\nif (o == null || !(o instanceof ZipShort)) {\nreturn value == ((ZipShort) o).getValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:dosToJavaTime(J)J",
                                    "method_body": "public static long dosToJavaTime(long dosTime) {\nCalendar cal = Calendar.getInstance();\ncal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\ncal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\ncal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);\ncal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);\ncal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);\ncal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);\nreturn cal.getTime().getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:copy([B)[B",
                                    "method_body": "static byte[] copy(byte[] from) {\nif (from != null) {\nbyte[] to = new byte[from.length];\nSystem.arraycopy(from, 0, to, 0, to.length);\nreturn to;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<init>(I)V",
                                    "method_body": "private UnparseableExtraField(int k) {\nkey = k;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<clinit>()V",
                                    "method_body": "public static final int THROW_KEY = 0;\npublic static final UnparseableExtraField THROW\npublic static final UnparseableExtraField SKIP\n* UnparseableExtraFieldData UnparseableExtraFieldData}."
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\nimplementations = new ConcurrentHashMap<ZipShort, Class<?>>();\nregister(AsiExtraField.class);\nregister(X5455_ExtendedTimestamp.class);\nregister(X7875_NewUnix.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\nregister(Zip64ExtendedInformationExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class<?> c) {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:createExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField createExtraField(ZipShort headerId)\nClass<?> c = implementations.get(headerId);\nif (c != null) {\nreturn (ZipExtraField) c.newInstance();\nUnrecognizedExtraField u = new UnrecognizedExtraField();\nu.setHeaderId(headerId);\nreturn u;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:parse([BZLorg/apache/commons/compress/archivers/zip/ExtraFieldUtils$UnparseableExtraField;)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField[] parse(byte[] data, boolean local,\nList<ZipExtraField> v = new ArrayList<ZipExtraField>();\nint start = 0;\nwhile (start <= data.length - WORD) {\nZipShort headerId = new ZipShort(data, start);\nint length = (new ZipShort(data, start + 2)).getValue();\nif (start + WORD + length > data.length) {\nZipExtraField ze = createExtraField(headerId);\nif (local) {\nze.parseFromCentralDirectoryData(data, start + WORD,\nv.add(ze);\n}\nstart += (length + WORD);\n}\nZipExtraField[] result = new ZipExtraField[v.size()];\nreturn v.toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nfinal boolean lastIsUnparseableHolder = data.length > 0\nint regularExtraFieldCount =\nint sum = WORD * regularExtraFieldCount;\nfor (ZipExtraField element : data) {\nsum += element.getLocalFileDataLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\nif (lastIsUnparseableHolder) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<init>()V",
                                    "method_body": "public X5455_ExtendedTimestamp() {}\npublic X5455_ExtendedTimestamp() {}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x5455);\npublic X5455_ExtendedTimestamp() {}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<init>()V",
                                    "method_body": "public X7875_NewUnix() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x7875);\nprivate static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);\nprivate int version = 1; // always '1' according to current info-zip spec.\npublic X7875_NewUnix() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:reset()V",
                                    "method_body": "private void reset() {\nuid = ONE_THOUSAND;\ngid = ONE_THOUSAND;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\npublic JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<init>()V",
                                    "method_body": "public Zip64ExtendedInformationExtraField() { }\npublic Zip64ExtendedInformationExtraField() { }"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<clinit>()V",
                                    "method_body": "static final ZipShort HEADER_ID = new ZipShort(0x0001);\nprivate static final byte[] EMPTY = new byte[0];\n* parseFromCentralDirectoryData} so it can be reused when ZipFile"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn new ZipShort(size != null ? 2 * DWORD : 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nif (size != null || compressedSize != null) {\nif (size == null || compressedSize == null) {\nbyte[] data = new byte[2 * DWORD];\naddSizes(data);\nreturn data;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:parseFromLocalFileData([BII)V",
                                    "method_body": "public void parseFromLocalFileData(byte[] buffer, int offset, int length)\nif (length == 0) {\nif (length < 2 * DWORD) {\nsize = new ZipEightByteInteger(buffer, offset);\noffset += DWORD;\ncompressedSize = new ZipEightByteInteger(buffer, offset);\noffset += DWORD;\nint remaining = length - 2 * DWORD;\nif (remaining >= DWORD) {\nrelativeHeaderOffset = new ZipEightByteInteger(buffer, offset);\noffset += DWORD;\nremaining -= DWORD;\nif (remaining >= WORD) {\ndiskStart = new ZipLong(buffer, offset);\noffset += WORD;\nremaining -= WORD;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:parseFromCentralDirectoryData([BII)V",
                                    "method_body": "public void parseFromCentralDirectoryData(byte[] buffer, int offset,\nrawCentralDirectoryData = new byte[length];\nSystem.arraycopy(buffer, offset, rawCentralDirectoryData, 0, length);\nif (length >= 3 * DWORD + WORD) {\nparseFromLocalFileData(buffer, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:reparseCentralDirectoryData(ZZZZ)V",
                                    "method_body": "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\nif (rawCentralDirectoryData != null) {\nint expectedLength = (hasUncompressedSize ? DWORD : 0)\nif (rawCentralDirectoryData.length != expectedLength) {\nthrow new ZipException(\"central directory zip64 extended\"\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:addSizes([B)I",
                                    "method_body": "private int addSizes(byte[] data) {\nint off = 0;\nif (size != null) {\nSystem.arraycopy(size.getBytes(), 0, data, 0, DWORD);\noff += DWORD;\nif (compressedSize != null) {\nSystem.arraycopy(compressedSize.getBytes(), 0, data, off, DWORD);\noff += DWORD;\nreturn off;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipFile(File f) throws IOException {\nthis(f, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;)V",
                                    "method_body": "public ZipFile(File f, String encoding) throws IOException {\nthis(f, encoding, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "private long headerOffset = -1;\nprivate long dataOffset = -1;\nprivate final byte[] DWORD_BUF = new byte[DWORD];\nprivate final byte[] WORD_BUF = new byte[WORD];\nprivate final byte[] CFH_BUF = new byte[CFH_LEN];\nprivate final byte[] SHORT_BUF = new byte[SHORT];\nthis(f, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<clinit>()V",
                                    "method_body": "private static final int CFH_LEN =\nprivate static final long CFH_SIG =\nHashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\npositionAtCentralDirectory();\narchive.readFully(WORD_BUF);\nlong sig = ZipLong.getValue(WORD_BUF);\nif (sig != CFH_SIG && startsWithLocalFileHeader()) {\nwhile (sig == CFH_SIG) {\nreadCentralDirectoryEntry(noUTF8Flag);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
                                    "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory()\nHashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\npositionAtCentralDirectory();\narchive.readFully(WORD_BUF);\nlong sig = ZipLong.getValue(WORD_BUF);\nif (sig != CFH_SIG && startsWithLocalFileHeader()) {\nwhile (sig == CFH_SIG) {\nreadCentralDirectoryEntry(noUTF8Flag);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:readCentralDirectoryEntry(Ljava/util/Map;)V",
                                    "method_body": "private void\narchive.readFully(CFH_BUF);\nint off = 0;\nOffsetEntry offset = new OffsetEntry();\nEntry ze = new Entry(offset);\nint versionMadeBy = ZipShort.getValue(CFH_BUF, off);\noff += SHORT;\nze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\noff += SHORT; // skip version info\nfinal GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(CFH_BUF, off);\nfinal boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\nfinal ZipEncoding entryEncoding =\nze.setGeneralPurposeBit(gpFlag);\noff += SHORT;\nze.setMethod(ZipShort.getValue(CFH_BUF, off));\noff += SHORT;\nlong time = ZipUtil.dosToJavaTime(ZipLong.getValue(CFH_BUF, off));\nze.setTime(time);\noff += WORD;\nze.setCrc(ZipLong.getValue(CFH_BUF, off));\noff += WORD;\nze.setCompressedSize(ZipLong.getValue(CFH_BUF, off));\noff += WORD;\nze.setSize(ZipLong.getValue(CFH_BUF, off));\noff += WORD;\nint fileNameLen = ZipShort.getValue(CFH_BUF, off);\noff += SHORT;\nint extraLen = ZipShort.getValue(CFH_BUF, off);\noff += SHORT;\nint commentLen = ZipShort.getValue(CFH_BUF, off);\noff += SHORT;\nint diskStart = ZipShort.getValue(CFH_BUF, off);\noff += SHORT;\nze.setInternalAttributes(ZipShort.getValue(CFH_BUF, off));\noff += SHORT;\nze.setExternalAttributes(ZipLong.getValue(CFH_BUF, off));\noff += WORD;\nbyte[] fileName = new byte[fileNameLen];\narchive.readFully(fileName);\nze.setName(entryEncoding.decode(fileName), fileName);\noffset.headerOffset = ZipLong.getValue(CFH_BUF, off);\nentries.add(ze);\nbyte[] cdExtraData = new byte[extraLen];\narchive.readFully(cdExtraData);\nze.setCentralDirectoryExtra(cdExtraData);\nsetSizesAndOffsetFromZip64Extra(ze, offset, diskStart);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:setSizesAndOffsetFromZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Lorg/apache/commons/compress/archivers/zip/ZipFile$OffsetEntry;I)V",
                                    "method_body": "private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze,\nZip64ExtendedInformationExtraField z64 =\nif (z64 != null) {\nboolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\nboolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\nboolean hasRelativeHeaderOffset =\nz64.reparseCentralDirectoryData(hasUncompressedSize,\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\npositionAtEndOfCentralDirectoryRecord();\nboolean found = false;\nboolean searchedForZip64EOCD =\nif (searchedForZip64EOCD) {\narchive.seek(archive.getFilePointer() - ZIP64_EOCDL_LENGTH);\narchive.readFully(WORD_BUF);\nfound = Arrays.equals(ZipArchiveOutputStream.ZIP64_EOCD_LOC_SIG,\nif (!found) {\npositionAtCentralDirectory64();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory64()V",
                                    "method_body": "private void positionAtCentralDirectory64()\nskipBytes(ZIP64_EOCDL_LOCATOR_OFFSET\narchive.readFully(DWORD_BUF);\narchive.seek(ZipEightByteInteger.getLongValue(DWORD_BUF));\narchive.readFully(WORD_BUF);\nif (!Arrays.equals(WORD_BUF, ZipArchiveOutputStream.ZIP64_EOCD_SIG)) {\nskipBytes(ZIP64_EOCD_CFD_LOCATOR_OFFSET\narchive.readFully(DWORD_BUF);\narchive.seek(ZipEightByteInteger.getLongValue(DWORD_BUF));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtEndOfCentralDirectoryRecord()V",
                                    "method_body": "private void positionAtEndOfCentralDirectoryRecord()\nboolean found = tryToLocateSignature(MIN_EOCD_SIZE, MAX_EOCD_SIZE,\nif (!found) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:tryToLocateSignature(JJ[B)Z",
                                    "method_body": "private boolean tryToLocateSignature(long minDistanceFromEnd,\nboolean found = false;\nlong off = archive.length() - minDistanceFromEnd;\nfinal long stopSearching =\nif (off >= 0) {\nfor (; off >= stopSearching; off--) {\narchive.seek(off);\nint curr = archive.read();\nif (curr == -1) {\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\nif (found) {\narchive.seek(off);\nreturn found;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:skipBytes(I)V",
                                    "method_body": "private void skipBytes(final int count) throws IOException {\nint totalSkipped = 0;\nwhile (totalSkipped < count) {\nint skippedNow = archive.skipBytes(count - totalSkipped);\nif (skippedNow <= 0) {\ntotalSkipped += skippedNow;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$OffsetEntry:access$002(Lorg/apache/commons/compress/archivers/zip/ZipFile$OffsetEntry;J)J",
                                    "method_body": "private static final int HASH_SIZE = 509;\nprivate final List<ZipArchiveEntry> entries =\nprivate final Map<String, Deque<ZipArchiveEntry>> nameMap =\nprivate static final class OffsetEntry {\nprivate long headerOffset = -1;\nprivate long dataOffset = -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$OffsetEntry:<init>()V",
                                    "method_body": "private static final int HASH_SIZE = 509;\nprivate final List<ZipArchiveEntry> entries =\nprivate final Map<String, Deque<ZipArchiveEntry>> nameMap =\nprivate static final class OffsetEntry {\nprivate long headerOffset = -1;\nprivate long dataOffset = -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$Entry:<init>(Lorg/apache/commons/compress/archivers/zip/ZipFile$OffsetEntry;)V",
                                    "method_body": "Entry(OffsetEntry offset) {\nthis.offsetEntry = offset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setHeaderId(Lorg/apache/commons/compress/archivers/zip/ZipShort;)V",
                                    "method_body": "public void setHeaderId(ZipShort headerId) {\nthis.headerId = headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setLocalFileDataData([B)V",
                                    "method_body": "public void setLocalFileDataData(byte[] data) {\nlocalData = ZipUtil.copy(data);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn new ZipShort(localData.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn ZipUtil.copy(localData);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setCentralDirectoryData([B)V",
                                    "method_body": "public void setCentralDirectoryData(byte[] data) {\ncentralData = ZipUtil.copy(data);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:parseFromCentralDirectoryData([BII)V",
                                    "method_body": "public void parseFromCentralDirectoryData(byte[] data, int offset,\nbyte[] tmp = new byte[length];\nSystem.arraycopy(data, offset, tmp, 0, length);\nsetCentralDirectoryData(tmp);\nif (localData == null) {\nsetLocalFileDataData(tmp);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<init>(J)V",
                                    "method_body": "public ZipEightByteInteger(long value) {\nthis(BigInteger.valueOf(value));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<init>(Ljava/math/BigInteger;)V",
                                    "method_body": "public ZipEightByteInteger(BigInteger value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<init>([BI)V",
                                    "method_body": "public ZipEightByteInteger (byte[] bytes, int offset) {\nvalue = ZipEightByteInteger.getValue(bytes, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\npublic static final ZipEightByteInteger ZERO = new ZipEightByteInteger(0);\nthis(BigInteger.valueOf(value));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipEightByteInteger.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:getBytes(Ljava/math/BigInteger;)[B",
                                    "method_body": "public static byte[] getBytes(BigInteger value) {\nbyte[] result = new byte[8];\nlong val = value.longValue();\nresult[0] = (byte) ((val & BYTE_MASK));\nresult[BYTE_1] = (byte) ((val & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((val & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((val & BYTE_3_MASK) >> BYTE_3_SHIFT);\nresult[BYTE_4] = (byte) ((val & BYTE_4_MASK) >> BYTE_4_SHIFT);\nresult[BYTE_5] = (byte) ((val & BYTE_5_MASK) >> BYTE_5_SHIFT);\nresult[BYTE_6] = (byte) ((val & BYTE_6_MASK) >> BYTE_6_SHIFT);\nresult[BYTE_7] = (byte) ((val & BYTE_7_MASK) >> BYTE_7_SHIFT);\nif (value.testBit(LEFTMOST_BIT_SHIFT)) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:getLongValue([BI)J",
                                    "method_body": "public static long getLongValue(byte[] bytes, int offset) {\nreturn getValue(bytes, offset).longValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:getValue([BI)Ljava/math/BigInteger;",
                                    "method_body": "public static BigInteger getValue(byte[] bytes, int offset) {\nlong value = ((long) bytes[offset + BYTE_7] << BYTE_7_SHIFT) & BYTE_7_MASK;\nvalue += ((long) bytes[offset + BYTE_6] << BYTE_6_SHIFT) & BYTE_6_MASK;\nvalue += ((long) bytes[offset + BYTE_5] << BYTE_5_SHIFT) & BYTE_5_MASK;\nvalue += ((long) bytes[offset + BYTE_4] << BYTE_4_SHIFT) & BYTE_4_MASK;\nvalue += ((long) bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += ((long) bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += ((long) bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += ((long) bytes[offset] & BYTE_MASK);\nBigInteger val = BigInteger.valueOf(value);\nreturn (bytes[offset + BYTE_7] & LEFTMOST_BIT) == LEFTMOST_BIT\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:getLongValue([B)J",
                                    "method_body": "public static long getLongValue(byte[] bytes) {\nreturn getLongValue(bytes, 0);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 20,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStreamTest.testCpioUnarchiveCreatedByRedlineRpm",
                            "test_body": "49: public void testCpioUnarchiveCreatedByRedlineRpm() throws Exception {\n50: CpioArchiveInputStream in =\n51: new CpioArchiveInputStream(new FileInputStream(getFile(\"redline.cpio\")));\n52: CpioArchiveEntry entry= null;\n53: 54: int count = 0;\n55: while ((entry = (CpioArchiveEntry) in.getNextEntry()) != null) {\n56: count++;\n57: }\n58: in.close();\n59: 60: assertEquals(count, 1);\n61: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:<init>(S)V",
                                    "method_body": "public CpioArchiveEntry(final short format) {\nswitch (format) {\nthis.headerSize = 110;\nthis.alignmentBoundary = 4;\nbreak;\nthis.fileFormat = format;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:checkNewFormat()V",
                                    "method_body": "private void checkNewFormat() {\nif ((this.fileFormat & FORMAT_NEW_MASK) == 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn this.filesize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getFormat()S",
                                    "method_body": "public short getFormat() {\nreturn this.fileFormat;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getHeaderPadCount()I",
                                    "method_body": "public int getHeaderPadCount(){\nif (this.alignmentBoundary == 0) { return 0; }\nint size = this.headerSize+this.name.length()+1; // Name has terminating null\nint remain = size % this.alignmentBoundary;\nif (remain > 0){\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getDataPadCount()I",
                                    "method_body": "public int getDataPadCount(){\nif (this.alignmentBoundary == 0) { return 0; }\nlong size = this.filesize;\nint remain = (int) (size % this.alignmentBoundary);\nif (remain > 0){\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn this.name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setChksum(J)V",
                                    "method_body": "public void setChksum(final long chksum) {\ncheckNewFormat();\nthis.chksum = chksum;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setDeviceMaj(J)V",
                                    "method_body": "public void setDeviceMaj(final long maj) {\ncheckNewFormat();\nthis.maj = maj;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setDeviceMin(J)V",
                                    "method_body": "public void setDeviceMin(final long min) {\ncheckNewFormat();\nthis.min = min;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(final long size) {\nif (size < 0 || size > 0xFFFFFFFFL) {\nthis.filesize = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setGID(J)V",
                                    "method_body": "public void setGID(final long gid) {\nthis.gid = gid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setInode(J)V",
                                    "method_body": "public void setInode(final long inode) {\nthis.inode = inode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setMode(J)V",
                                    "method_body": "public void setMode(final long mode) {\nfinal long maskedMode = mode & S_IFMT;\nswitch ((int) maskedMode) {\nbreak;\nthrow new IllegalArgumentException(\nthis.mode = mode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "public void setName(final String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setNumberOfLinks(J)V",
                                    "method_body": "public void setNumberOfLinks(final long nlink) {\nthis.nlink = nlink;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setRemoteDeviceMaj(J)V",
                                    "method_body": "public void setRemoteDeviceMaj(final long rmaj) {\ncheckNewFormat();\nthis.rmaj = rmaj;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setRemoteDeviceMin(J)V",
                                    "method_body": "public void setRemoteDeviceMin(final long rmin) {\ncheckNewFormat();\nthis.rmin = rmin;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setTime(J)V",
                                    "method_body": "public void setTime(final long time) {\nthis.mtime = time;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setUID(J)V",
                                    "method_body": "public void setUID(final long uid) {\nthis.uid = uid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:toAsciiString([B)Ljava/lang/String;",
                                    "method_body": "public static String toAsciiString(final byte[] inputBytes){\nreturn new String(inputBytes, \"ASCII\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioUtil:byteArray2long([BZ)J",
                                    "method_body": "static long byteArray2long(final byte[] number, final boolean swapHalfWord) {\nif (number.length % 2 != 0) {\nlong ret = 0;\nint pos = 0;\nbyte tmp_number[] = new byte[number.length];\nSystem.arraycopy(number, 0, tmp_number, 0, number.length);\nif (!swapHalfWord) {\nbyte tmp = 0;\nfor (pos = 0; pos < tmp_number.length; pos++) {\ntmp = tmp_number[pos];\ntmp_number[pos++] = tmp_number[pos];\ntmp_number[pos] = tmp;\nret = tmp_number[0] & 0xFF;\nfor (pos = 1; pos < tmp_number.length; pos++) {\nret <<= 8;\nret |= tmp_number[pos] & 0xFF;\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public CpioArchiveInputStream(final InputStream in) {\nthis(in, BLOCK_SIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:<init>(Ljava/io/InputStream;I)V",
                                    "method_body": "private boolean closed = false;\nprivate long entryBytesRead = 0;\nprivate boolean entryEOF = false;\nprivate final byte tmpbuf[] = new byte[4096];\nprivate long crc = 0;\nprivate final byte[] TWO_BYTES_BUF = new byte[2];\nprivate final byte[] FOUR_BYTES_BUF = new byte[4];\nprivate final byte[] SIX_BYTES_BUF = new byte[6];\n* CpioConstants#BLOCK_SIZE BLOCK_SIZE}."
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:closeEntry()V",
                                    "method_body": "private void closeEntry() throws IOException {\nensureOpen();\nwhile (read(this.tmpbuf, 0, this.tmpbuf.length) != -1) { // NOPMD\nthis.entryEOF = true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:ensureOpen()V",
                                    "method_body": "private void ensureOpen() throws IOException {\nif (this.closed) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:getNextCPIOEntry()Lorg/apache/commons/compress/archivers/cpio/CpioArchiveEntry;",
                                    "method_body": "public CpioArchiveEntry getNextCPIOEntry() throws IOException {\nensureOpen();\nif (this.entry != null) {\ncloseEntry();\nreadFully(TWO_BYTES_BUF, 0, TWO_BYTES_BUF.length);\nif (CpioUtil.byteArray2long(TWO_BYTES_BUF, false) == MAGIC_OLD_BINARY) {\n} else if (CpioUtil.byteArray2long(TWO_BYTES_BUF, true)\nSystem.arraycopy(TWO_BYTES_BUF, 0, SIX_BYTES_BUF, 0,\nreadFully(SIX_BYTES_BUF, TWO_BYTES_BUF.length,\nString magicString = ArchiveUtils.toAsciiString(SIX_BYTES_BUF);\nif (magicString.equals(MAGIC_NEW)) {\nthis.entry = readNewEntry(false);\nthis.entryBytesRead = 0;\nthis.entryEOF = false;\nthis.crc = 0;\nif (this.entry.getName().equals(CPIO_TRAILER)) {\nreturn this.entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:skip(I)V",
                                    "method_body": "private void skip(int bytes) throws IOException{\nif (bytes > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:read([BII)I",
                                    "method_body": "public int read(final byte[] b, final int off, final int len)\nensureOpen();\nif (off < 0 || len < 0 || off > b.length - len) {\n} else if (len == 0) {\nif (this.entry == null || this.entryEOF) {\nif (this.entryBytesRead == this.entry.getSize()) {\nskip(entry.getDataPadCount());\nthis.entryEOF = true;\nif (this.entry.getFormat() == FORMAT_NEW_CRC\nreturn -1; // EOF for this entry\nint tmplength = (int) Math.min(len, this.entry.getSize()\nif (tmplength < 0) {\nint tmpread = readFully(b, off, tmplength);\nif (this.entry.getFormat() == FORMAT_NEW_CRC) {\nthis.entryBytesRead += tmpread;\nreturn tmpread;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:readFully([BII)I",
                                    "method_body": "private final int readFully(final byte[] b, final int off, final int len)\nif (len < 0) {\nint n = 0;\nwhile (n < len) {\nint count = this.in.read(b, off + n, len - n);\ncount(count);\nif (count < 0) {\nn += count;\n}\nreturn n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:readAsciiLong(II)J",
                                    "method_body": "private long readAsciiLong(final int length, final int radix)\nbyte tmpBuffer[] = new byte[length];\nreadFully(tmpBuffer, 0, tmpBuffer.length);\nreturn Long.parseLong(ArchiveUtils.toAsciiString(tmpBuffer), radix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:readNewEntry(Z)Lorg/apache/commons/compress/archivers/cpio/CpioArchiveEntry;",
                                    "method_body": "private CpioArchiveEntry readNewEntry(final boolean hasCrc)\nif (hasCrc) {\nret = new CpioArchiveEntry(FORMAT_NEW);\nret.setInode(readAsciiLong(8, 16));\nlong mode = readAsciiLong(8, 16);\nif (mode != 0){\nret.setMode(mode);\nret.setUID(readAsciiLong(8, 16));\nret.setGID(readAsciiLong(8, 16));\nret.setNumberOfLinks(readAsciiLong(8, 16));\nret.setTime(readAsciiLong(8, 16));\nret.setSize(readAsciiLong(8, 16));\nret.setDeviceMaj(readAsciiLong(8, 16));\nret.setDeviceMin(readAsciiLong(8, 16));\nret.setRemoteDeviceMaj(readAsciiLong(8, 16));\nret.setRemoteDeviceMin(readAsciiLong(8, 16));\nlong namesize = readAsciiLong(8, 16);\nret.setChksum(readAsciiLong(8, 16));\nString name = readCString((int) namesize);\nret.setName(name);\nif (mode == 0 && !name.equals(CPIO_TRAILER)){\nskip(ret.getHeaderPadCount());\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:readCString(I)Ljava/lang/String;",
                                    "method_body": "private String readCString(final int length) throws IOException {\nbyte tmpBuffer[] = new byte[length];\nreadFully(tmpBuffer, 0, tmpBuffer.length);\nreturn new String(tmpBuffer, 0, tmpBuffer.length - 1); // TODO default charset?\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:getNextEntry()Lorg/apache/commons/compress/archivers/cpio/CpioArchiveEntry;",
                                    "method_body": "public CpioArchiveEntry getNextEntry() throws IOException {\nreturn getNextCPIOEntry();\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 21,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest.testSixFilesSomeNotEmpty",
                            "test_body": "178: public void testSixFilesSomeNotEmpty() throws Exception {\n179: testCompress252(6, 2);\n180: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:<init>()V",
                                    "method_body": "public SevenZArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "public void setName(String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:hasStream()Z",
                                    "method_body": "public boolean hasStream() {\nreturn hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasStream(Z)V",
                                    "method_body": "public void setHasStream(boolean hasStream) {\nthis.hasStream = hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nreturn isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setDirectory(Z)V",
                                    "method_body": "public void setDirectory(boolean isDirectory) {\nthis.isDirectory = isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isAntiItem()Z",
                                    "method_body": "public boolean isAntiItem() {\nreturn isAntiItem;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasCreationDate()Z",
                                    "method_body": "public boolean getHasCreationDate() {\nreturn hasCreationDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasLastModifiedDate()Z",
                                    "method_body": "public boolean getHasLastModifiedDate() {\nreturn hasLastModifiedDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getLastModifiedDate()Ljava/util/Date;",
                                    "method_body": "public Date getLastModifiedDate() {\nif (hasLastModifiedDate) {\nreturn ntfsTimeToJavaTime(lastModifiedDate);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setLastModifiedDate(Ljava/util/Date;)V",
                                    "method_body": "public void setLastModifiedDate(Date lastModifiedDate) {\nhasLastModifiedDate = lastModifiedDate != null;\nif (hasLastModifiedDate) {\nthis.lastModifiedDate = javaTimeToNtfsTime(lastModifiedDate);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasAccessDate()Z",
                                    "method_body": "public boolean getHasAccessDate() {\nreturn hasAccessDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasWindowsAttributes()Z",
                                    "method_body": "public boolean getHasWindowsAttributes() {\nreturn hasWindowsAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasCrc(Z)V",
                                    "method_body": "public void setHasCrc(boolean hasCrc) {\nthis.hasCrc = hasCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCompressedSize(J)V",
                                    "method_body": "void setCompressedSize(long size) {\nthis.compressedSize = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:ntfsTimeToJavaTime(J)Ljava/util/Date;",
                                    "method_body": "public static Date ntfsTimeToJavaTime(final long ntfsTime) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nfinal long realTime = ntfsEpoch.getTimeInMillis() + (ntfsTime / (10*1000));\nreturn new Date(realTime);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:javaTimeToNtfsTime(Ljava/util/Date;)J",
                                    "method_body": "public static long javaTimeToNtfsTime(final Date date) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nreturn ((date.getTime() - ntfsEpoch.getTimeInMillis())* 1000 * 10);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:<init>(Ljava/io/File;)V",
                                    "method_body": "private final RandomAccessFile file;\nprivate final List<SevenZArchiveEntry> files = new ArrayList<SevenZArchiveEntry>();\nprivate int numNonEmptyStreams = 0;\nprivate CRC32 crc32 = new CRC32();\nprivate CRC32 compressedCrc32 = new CRC32();\nprivate long fileBytesWritten = 0;\nprivate boolean finished = false;\nprivate SevenZMethod contentCompression = SevenZMethod.LZMA2;\npublic SevenZOutputFile(final File filename) throws IOException {\nfile = new RandomAccessFile(filename, \"rw\");\nfile.seek(SevenZFile.SIGNATURE_HEADER_SIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!finished) {\nfinish();\nfile.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:createArchiveEntry(Ljava/io/File;Ljava/lang/String;)Lorg/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry;",
                                    "method_body": "public SevenZArchiveEntry createArchiveEntry(final File inputFile,\nfinal SevenZArchiveEntry entry = new SevenZArchiveEntry();\nentry.setDirectory(inputFile.isDirectory());\nentry.setName(entryName);\nentry.setLastModifiedDate(new Date(inputFile.lastModified()));\nreturn entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\nfinal SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;\nfiles.add(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (currentOutputStream != null) {\ncurrentOutputStream.flush();\ncurrentOutputStream.close();\nfinal SevenZArchiveEntry entry = files.get(files.size() - 1);\nif (fileBytesWritten > 0) {\nentry.setHasStream(true);\n++numNonEmptyStreams;\nentry.setSize(currentOutputStream.getBytesWritten());\nentry.setCompressedSize(fileBytesWritten);\nentry.setCrcValue(crc32.getValue());\nentry.setCompressedCrcValue(compressedCrc32.getValue());\nentry.setHasCrc(true);\nentry.setHasStream(false);\nentry.setSize(0);\nentry.setCompressedSize(0);\nentry.setHasCrc(false);\ncurrentOutputStream = null;\ncrc32.reset();\ncompressedCrc32.reset();\nfileBytesWritten = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([B)V",
                                    "method_body": "public void write(final byte[] b) throws IOException {\nwrite(b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int off, final int len) throws IOException {\nif (len > 0) {\ngetCurrentOutputStream().write(b, off, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif (finished) {\nfinished = true;\nfinal long headerPosition = file.getFilePointer();\nfinal ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();\nfinal DataOutputStream header = new DataOutputStream(headerBaos);\nwriteHeader(header);\nheader.flush();\nfinal byte[] headerBytes = headerBaos.toByteArray();\nfile.write(headerBytes);\nfinal CRC32 crc32 = new CRC32();\nfile.seek(0);\nfile.write(SevenZFile.sevenZSignature);\nfile.write(0);\nfile.write(2);\nfinal ByteArrayOutputStream startHeaderBaos = new ByteArrayOutputStream();\nfinal DataOutputStream startHeaderStream = new DataOutputStream(startHeaderBaos);\nstartHeaderStream.writeLong(Long.reverseBytes(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE));\nstartHeaderStream.writeLong(Long.reverseBytes(0xffffFFFFL & headerBytes.length));\ncrc32.reset();\ncrc32.update(headerBytes);\nstartHeaderStream.writeInt(Integer.reverseBytes((int)crc32.getValue()));\nstartHeaderStream.flush();\nfinal byte[] startHeaderBytes = startHeaderBaos.toByteArray();\ncrc32.reset();\ncrc32.update(startHeaderBytes);\nfile.writeInt(Integer.reverseBytes((int) crc32.getValue()));\nfile.write(startHeaderBytes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeHeader(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeHeader(final DataOutput header) throws IOException {\nheader.write(NID.kHeader);\nheader.write(NID.kMainStreamsInfo);\nwriteStreamsInfo(header);\nwriteFilesInfo(header);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeStreamsInfo(final DataOutput header) throws IOException {\nif (numNonEmptyStreams > 0) {\nwritePackInfo(header);\nwriteUnpackInfo(header);\nwriteSubStreamsInfo(header);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeSubStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeSubStreamsInfo(final DataOutput header) throws IOException {\nheader.write(NID.kSubStreamsInfo);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFilesInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFilesInfo(final DataOutput header) throws IOException {\nheader.write(NID.kFilesInfo);\nwriteUint64(header, files.size());\nwriteFileEmptyStreams(header);\nwriteFileEmptyFiles(header);\nwriteFileAntiItems(header);\nwriteFileNames(header);\nwriteFileCTimes(header);\nwriteFileATimes(header);\nwriteFileMTimes(header);\nwriteFileWindowsAttributes(header);\nheader.write(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyStreams(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyStreams(final DataOutput header) throws IOException {\nboolean hasEmptyStreams = false;\nfor (final SevenZArchiveEntry entry : files) {\nif (!entry.hasStream()) {\nhasEmptyStreams = true;\nbreak;\nif (hasEmptyStreams) {\nheader.write(NID.kEmptyStream);\nfinal BitSet emptyStreams = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nemptyStreams.set(i, !files.get(i).hasStream());\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyStreams, files.size());\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyFiles(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyFiles(final DataOutput header) throws IOException {\nboolean hasEmptyFiles = false;\nint emptyStreamCounter = 0;\nfinal BitSet emptyFiles = new BitSet(0);\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isDir = files.get(i).isDirectory();\nemptyFiles.set(emptyStreamCounter++, !isDir);\nhasEmptyFiles |= !isDir;\nif (hasEmptyFiles) {\nheader.write(NID.kEmptyFile);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyFiles, emptyStreamCounter);\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileAntiItems(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileAntiItems(final DataOutput header) throws IOException {\nboolean hasAntiItems = false;\nfinal BitSet antiItems = new BitSet(0);\nint antiItemCounter = 0;\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isAnti = files.get(i).isAntiItem();\nantiItems.set(antiItemCounter++, isAnti);\nhasAntiItems |= isAnti;\nif (hasAntiItems) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileNames(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileNames(final DataOutput header) throws IOException {\nheader.write(NID.kName);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nout.write(entry.getName().getBytes(\"UTF-16LE\"));\nout.writeShort(0);\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileCTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileCTimes(final DataOutput header) throws IOException {\nint numCreationDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasCreationDate()) {\n}\nif (numCreationDates > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileATimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileATimes(final DataOutput header) throws IOException {\nint numAccessDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasAccessDate()) {\n}\nif (numAccessDates > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileMTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileMTimes(final DataOutput header) throws IOException {\nint numLastModifiedDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\n++numLastModifiedDates;\n}\nif (numLastModifiedDates > 0) {\nheader.write(NID.kMTime);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numLastModifiedDates != files.size()) {\nout.write(0);\nfinal BitSet mTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nmTimes.set(i, files.get(i).getHasLastModifiedDate());\nwriteBits(out, mTimes, files.size());\n} else {\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\nout.writeLong(Long.reverseBytes(\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileWindowsAttributes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileWindowsAttributes(final DataOutput header) throws IOException {\nint numWindowsAttributes = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasWindowsAttributes()) {\n}\nif (numWindowsAttributes > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeUint64(Ljava/io/DataOutput;J)V",
                                    "method_body": "private void writeUint64(final DataOutput header, long value) throws IOException {\nint firstByte = 0;\nint mask = 0x80;\nfor (i = 0; i < 8; i++) {\nif (value < ((1L << ( 7  * (i + 1))))) {\nfirstByte |= (value >>> (8 * i));\nbreak;\nfirstByte |= mask;\nmask >>>= 1;\nheader.write(firstByte);\nfor (; i > 0; i--) {\nheader.write((int) (0xff & value));\nvalue >>>= 8;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeBits(Ljava/io/DataOutput;Ljava/util/BitSet;I)V",
                                    "method_body": "private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\nint cache = 0;\nint shift = 7;\nfor (int i = 0; i < length; i++) {\ncache |= ((bits.get(i) ? 1 : 0) << shift);\n--shift;\nif (shift == 0) {\nheader.write(cache);\nshift = 7;\ncache = 0;\nif (length > 0 && shift > 0) {\nheader.write(cache);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:<init>(Ljava/lang/String;I[B)V",
                                    "method_body": "private SevenZMethod(byte[] id) {\nthis.id = id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;[B)V",
                                    "method_body": "public SevenZFile(final File filename, final byte[] password) throws IOException {\nboolean succeeded = false;\nthis.file = new RandomAccessFile(filename, \"r\");\narchive = readHeaders(password);\nif (!succeeded) {\nthis.file.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZFile(final File filename) throws IOException {\nthis(filename, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<clinit>()V",
                                    "method_body": "static final int SIGNATURE_HEADER_SIZE = 32;\nprivate int currentEntryIndex = -1;\nprivate int currentFolderIndex = -1;\nprivate InputStream currentFolderInputStream = null;\nprivate InputStream currentEntryInputStream = null;\nstatic final byte[] sevenZSignature = {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeaders([B)Lorg/apache/commons/compress/archivers/sevenz/Archive;",
                                    "method_body": "private Archive readHeaders(byte[] password) throws IOException {\nfinal byte[] signature = new byte[6];\nfile.readFully(signature);\nif (!Arrays.equals(signature, sevenZSignature)) {\nfinal byte archiveVersionMajor = file.readByte();\nfinal byte archiveVersionMinor = file.readByte();\nif (archiveVersionMajor != 0) {\nfinal long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\nfinal StartHeader startHeader = readStartHeader(startHeaderCrc);\nfinal int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\nif (nextHeaderSizeInt != startHeader.nextHeaderSize) {\nfile.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\nfinal byte[] nextHeader = new byte[nextHeaderSizeInt];\nfile.readFully(nextHeader);\nfinal CRC32 crc = new CRC32();\ncrc.update(nextHeader);\nif (startHeader.nextHeaderCrc != crc.getValue()) {\nfinal ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\nDataInputStream nextHeaderInputStream = new DataInputStream(\nArchive archive = new Archive();\nint nid = nextHeaderInputStream.readUnsignedByte();\nif (nid == NID.kEncodedHeader) {\nif (nid == NID.kHeader) {\nreadHeader(nextHeaderInputStream, archive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStartHeader(J)Lorg/apache/commons/compress/archivers/sevenz/StartHeader;",
                                    "method_body": "private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\nfinal StartHeader startHeader = new StartHeader();\nDataInputStream dataInputStream = null;\ndataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\nstartHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\nreturn startHeader;\nif (dataInputStream != null) {\ndataInputStream.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeader(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readHeader(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\nif (nid == NID.kArchiveProperties) {\nif (nid == NID.kAdditionalStreamsInfo) {\nif (nid == NID.kMainStreamsInfo) {\nreadStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid == NID.kFilesInfo) {\nreadFilesInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated header\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\nif (nid == NID.kPackInfo) {\nreadPackInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid == NID.kUnpackInfo) {\nreadUnpackInfo(header, archive);\nnid = header.readUnsignedByte();\narchive.folders = new Folder[0];\nif (nid == NID.kSubStreamsInfo) {\nreadSubStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid != NID.kEnd) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readSubStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nfor (final Folder folder : archive.folders) {\nfolder.numUnpackSubStreams = 1;\nint totalUnpackStreams = archive.folders.length;\nint nid = header.readUnsignedByte();\nif (nid == NID.kNumUnpackStream) {\nfinal SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\nsubStreamsInfo.unpackSizes = new long[totalUnpackStreams];\nsubStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\nsubStreamsInfo.crcs = new long[totalUnpackStreams];\nint nextUnpackStream = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams == 0) {\nlong sum = 0;\nif (nid == NID.kSize) {\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;\nif (nid == NID.kSize) {\nint numDigests = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {\nif (nid == NID.kCRC) {\nif (nid != NID.kEnd) {\narchive.subStreamsInfo = subStreamsInfo;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readBits(final DataInput header, final int size) throws IOException {\nfinal BitSet bits = new BitSet(size);\nint mask = 0;\nint cache = 0;\nfor (int i = 0; i < size; i++) {\nif (mask == 0) {\nmask = 0x80;\ncache = header.readUnsignedByte();\nbits.set(i, (cache & mask) != 0);\nmask >>>= 1;\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFilesInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readFilesInfo(final DataInput header, final Archive archive) throws IOException {\nfinal long numFiles = readUint64(header);\nfinal SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\nfor (int i = 0; i < files.length; i++) {\nfiles[i] = new SevenZArchiveEntry();\nBitSet isEmptyStream = null;\nBitSet isEmptyFile = null;\nBitSet isAnti = null;\nfinal int propertyType = header.readUnsignedByte();\nif (propertyType == 0) {\nbreak;\nlong size = readUint64(header);\nswitch (propertyType) {\nisEmptyStream = readBits(header, files.length);\nbreak;\nif (isEmptyStream == null) { // protect against NPE\nisEmptyFile = readBits(header, isEmptyStream.cardinality());\nbreak;\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nif (((size - 1) & 1) != 0) {\nfinal byte[] names = new byte[(int)(size - 1)];\nheader.readFully(names);\nint nextFile = 0;\nint nextName = 0;\nfor (int i = 0; i < names.length; i += 2) {\nif (names[i] == 0 && names[i+1] == 0) {\nfiles[nextFile++].setName(new String(names, nextName, i-nextName, CharsetNames.UTF_16LE));\nnextName = i + 2;\nif (nextName != names.length || nextFile != files.length) {\nbreak;\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasLastModifiedDate(timesDefined.get(i));\nif (files[i].getHasLastModifiedDate()) {\nfiles[i].setLastModifiedDate(Long.reverseBytes(header.readLong()));\nbreak;\nthrow new IOException(\"Unknown property \" + propertyType);\n}\nint nonEmptyFileCounter = 0;\nint emptyFileCounter = 0;\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasStream((isEmptyStream == null) ? true : !isEmptyStream.get(i));\nif (files[i].hasStream()) {\nfiles[i].setDirectory(false);\nfiles[i].setAntiItem(false);\nfiles[i].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nfiles[i].setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nfiles[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\nfiles[i].setDirectory((isEmptyFile == null) ? true : !isEmptyFile.get(emptyFileCounter));\nfiles[i].setAntiItem((isAnti == null) ? false : isAnti.get(emptyFileCounter));\nfiles[i].setHasCrc(false);\nfiles[i].setSize(0);\n++emptyFileCounter;\narchive.files = files;\ncalculateStreamMap(archive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUint64(Ljava/io/DataInput;)J",
                                    "method_body": "private static long readUint64(final DataInput in) throws IOException {\nlong firstByte = in.readUnsignedByte();\nint mask = 0x80;\nlong value = 0;\nfor (int i = 0; i < 8; i++) {\nif ((firstByte & mask) == 0) {\nreturn value | ((firstByte & (mask - 1)) << (8 * i));\nlong nextByte = in.readUnsignedByte();\nvalue |= (nextByte << (8 * i));\nmask >>>= 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;JJ)V",
                                    "method_body": "public ChecksumVerifyingInputStream(final Checksum checksum, final InputStream in,\nfinal long size, final long expectedChecksum) {\nthis.checksum = checksum;\nthis.in = in;\nthis.expectedChecksum = expectedChecksum;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining <= 0) {\nint ret = in.read();\nif (ret >= 0) {\nchecksum.update(ret);\n--bytesRemaining;\nif (bytesRemaining == 0 && expectedChecksum != checksum.getValue()) {\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nint ret = in.read(b, off, len);\nif (ret >= 0) {\nchecksum.update(b, off, ret);\nbytesRemaining -= ret;\nif (bytesRemaining <= 0 && expectedChecksum != checksum.getValue()) {\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nin.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CRC32VerifyingInputStream:<init>(Ljava/io/InputStream;JJ)V",
                                    "method_body": "public CRC32VerifyingInputStream(final InputStream in, final long size, final long expectedCrc32) {\nsuper(new CRC32(), in, size, expectedCrc32);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:<init>(Ljava/io/RandomAccessFile;J)V",
                                    "method_body": "public BoundedRandomAccessFileInputStream(final RandomAccessFile file,\nfinal long size) {\nthis.file = file;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining > 0) {\n--bytesRemaining;\nreturn file.read();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif (bytesRemaining == 0) {\nint bytesToRead = len;\nif (bytesToRead > bytesRemaining) {\nfinal int bytesRead = file.read(b, off, bytesToRead);\nif (bytesRead >= 0) {\nbytesRemaining -= bytesRead;\nreturn bytesRead;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:close()V",
                                    "method_body": "public void close() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setAntiItem(Z)V",
                                    "method_body": "public void setAntiItem(boolean isAntiItem) {\nthis.isAntiItem = isAntiItem;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getCrcValue()J",
                                    "method_body": "public long getCrcValue() {\nreturn crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCrcValue(J)V",
                                    "method_body": "public void setCrcValue(long crc) {\nthis.crc = crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getCompressedCrcValue()J",
                                    "method_body": "long getCompressedCrcValue() {\nreturn compressedCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCompressedCrcValue(J)V",
                                    "method_body": "void setCompressedCrcValue(long crc) {\nthis.compressedCrc = crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getCompressedSize()J",
                                    "method_body": "long getCompressedSize() {\nreturn compressedSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:getCurrentOutputStream()Ljava/io/OutputStream;",
                                    "method_body": "private OutputStream getCurrentOutputStream() throws IOException {\nif (currentOutputStream == null) {\ncurrentOutputStream = setupFileOutputStream();\nreturn currentOutputStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:setupFileOutputStream()Lorg/apache/commons/compress/utils/CountingOutputStream;",
                                    "method_body": "private CountingOutputStream setupFileOutputStream() throws IOException {\nOutputStream out = new OutputStreamWrapper();\nreturn new CountingOutputStream(Coders\nsuper.write(b, off, len);\ncrc32.update(b, off, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writePackInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writePackInfo(final DataOutput header) throws IOException {\nheader.write(NID.kPackInfo);\nwriteUint64(header, 0);\nwriteUint64(header, 0xffffFFFFL & numNonEmptyStreams);\nheader.write(NID.kSize);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nwriteUint64(header, entry.getCompressedSize());\n}\nheader.write(NID.kCRC);\nheader.write(1);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nheader.writeInt(Integer.reverseBytes((int) entry.getCompressedCrcValue()));\n}\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeUnpackInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeUnpackInfo(final DataOutput header) throws IOException {\nheader.write(NID.kUnpackInfo);\nheader.write(NID.kFolder);\nwriteUint64(header, numNonEmptyStreams);\nheader.write(0);\nfor (int i = 0; i < numNonEmptyStreams; i++) {\nwriteFolder(header);\nheader.write(NID.kCodersUnpackSize);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nwriteUint64(header, entry.getSize());\n}\nheader.write(NID.kCRC);\nheader.write(1);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nheader.writeInt(Integer.reverseBytes((int) entry.getCrcValue()));\n}\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFolder(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFolder(final DataOutput header) throws IOException {\nwriteUint64(header, 1);\nbyte[] id = contentCompression.getId();\nbyte[] properties = contentCompression.getProperties();\nint codecFlags = id.length;\nif (properties.length > 0) {\ncodecFlags |= 0x20;\nheader.write(codecFlags);\nheader.write(id);\nif (properties.length > 0) {\nheader.write(properties.length);\nheader.write(properties);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:getId()[B",
                                    "method_body": "byte[] getId() {\nbyte[] copy = new byte[id.length];\nSystem.arraycopy(id, 0, copy, 0, id.length);\nreturn copy;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod$1:getProperties()[B",
                                    "method_body": "byte[] getProperties() {\nint dictSize = LZMA2Options.DICT_SIZE_DEFAULT;\nint lead = Integer.numberOfLeadingZeros(dictSize);\nint secondBit = (dictSize >>> (30 - lead)) - 2;\nreturn new byte[] {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readPackInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readPackInfo(final DataInput header, final Archive archive) throws IOException {\narchive.packPos = readUint64(header);\nfinal long numPackStreams = readUint64(header);\nint nid = header.readUnsignedByte();\nif (nid == NID.kSize) {\narchive.packSizes = new long[(int)numPackStreams];\nfor (int i = 0; i < archive.packSizes.length; i++) {\narchive.packSizes[i] = readUint64(header);\nnid = header.readUnsignedByte();\nif (nid == NID.kCRC) {\narchive.packCrcsDefined = readAllOrBits(header, (int)numPackStreams);\narchive.packCrcs = new long[(int)numPackStreams];\nfor (int i = 0; i < (int)numPackStreams; i++) {\nif (archive.packCrcsDefined.get(i)) {\narchive.packCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\nnid = header.readUnsignedByte();\nif (nid != NID.kEnd) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUnpackInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readUnpackInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\nif (nid != NID.kFolder) {\nfinal long numFolders = readUint64(header);\nfinal Folder[] folders = new Folder[(int)numFolders];\narchive.folders = folders;\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nfor (int i = 0; i < (int)numFolders; i++) {\nfolders[i] = readFolder(header);\nnid = header.readUnsignedByte();\nif (nid != NID.kCodersUnpackSize) {\nfor (final Folder folder : folders) {\nfolder.unpackSizes = new long[(int)folder.totalOutputStreams];\nfor (int i = 0; i < folder.totalOutputStreams; i++) {\nfolder.unpackSizes[i] = readUint64(header);\nnid = header.readUnsignedByte();\nif (nid == NID.kCRC) {\nfinal BitSet crcsDefined = readAllOrBits(header, (int)numFolders);\nfor (int i = 0; i < (int)numFolders; i++) {\nif (crcsDefined.get(i)) {\nfolders[i].hasCrc = true;\nfolders[i].crc = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\nnid = header.readUnsignedByte();\nif (nid != NID.kEnd) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFolder(Ljava/io/DataInput;)Lorg/apache/commons/compress/archivers/sevenz/Folder;",
                                    "method_body": "private Folder readFolder(final DataInput header) throws IOException {\nfinal Folder folder = new Folder();\nfinal long numCoders = readUint64(header);\nfinal Coder[] coders = new Coder[(int)numCoders];\nlong totalInStreams = 0;\nlong totalOutStreams = 0;\nfor (int i = 0; i < coders.length; i++) {\ncoders[i] = new Coder();\nint bits = header.readUnsignedByte();\nfinal int idSize = bits & 0xf;\nfinal boolean isSimple = ((bits & 0x10) == 0);\nfinal boolean hasAttributes = ((bits & 0x20) != 0);\nfinal boolean moreAlternativeMethods = ((bits & 0x80) != 0);\ncoders[i].decompressionMethodId = new byte[idSize];\nheader.readFully(coders[i].decompressionMethodId);\nif (isSimple) {\ncoders[i].numInStreams = 1;\ncoders[i].numOutStreams = 1;\ntotalInStreams += coders[i].numInStreams;\ntotalOutStreams += coders[i].numOutStreams;\nif (hasAttributes) {\nfinal long propertiesSize = readUint64(header);\ncoders[i].properties = new byte[(int)propertiesSize];\nheader.readFully(coders[i].properties);\nwhile (moreAlternativeMethods) {\nfolder.coders = coders;\nfolder.totalInputStreams = totalInStreams;\nfolder.totalOutputStreams = totalOutStreams;\nif (totalOutStreams == 0) {\nfinal long numBindPairs = totalOutStreams - 1;\nfinal BindPair[] bindPairs = new BindPair[(int)numBindPairs];\nfor (int i = 0; i < bindPairs.length; i++) {\nfolder.bindPairs = bindPairs;\nif (totalInStreams < numBindPairs) {\nfinal long numPackedStreams = totalInStreams - numBindPairs;\nfinal long packedStreams[] = new long[(int)numPackedStreams];\nif (numPackedStreams == 1) {\nfor (i = 0; i < (int)totalInStreams; i++) {\nif (folder.findBindPairForInStream(i) < 0) {\nbreak;\nif (i == (int)totalInStreams) {\npackedStreams[0] = i;\n} else {\nfolder.packedStreams = packedStreams;\nreturn folder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readAllOrBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readAllOrBits(final DataInput header, final int size) throws IOException {\nfinal int areAllDefined = header.readUnsignedByte();\nif (areAllDefined != 0) {\nbits = new BitSet(size);\nfor (int i = 0; i < size; i++) {\nbits.set(i, true);\nbits = readBits(header, size);\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:calculateStreamMap(Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void calculateStreamMap(final Archive archive) throws IOException {\nfinal StreamMap streamMap = new StreamMap();\nint nextFolderPackStreamIndex = 0;\nfinal int numFolders = (archive.folders != null) ? archive.folders.length : 0;\nstreamMap.folderFirstPackStreamIndex = new int[numFolders];\nfor (int i = 0; i < numFolders; i++) {\nstreamMap.folderFirstPackStreamIndex[i] = nextFolderPackStreamIndex;\nnextFolderPackStreamIndex += archive.folders[i].packedStreams.length;\nlong nextPackStreamOffset = 0;\nfinal int numPackSizes = (archive.packSizes != null) ? archive.packSizes.length : 0;\nstreamMap.packStreamOffsets = new long[numPackSizes];\nfor (int i = 0; i < numPackSizes; i++) {\nstreamMap.packStreamOffsets[i] = nextPackStreamOffset;\nnextPackStreamOffset += archive.packSizes[i];\nstreamMap.folderFirstFileIndex = new int[numFolders];\nstreamMap.fileFolderIndex = new int[archive.files.length];\nint nextFolderIndex = 0;\nint nextFolderUnpackStreamIndex = 0;\nfor (int i = 0; i < archive.files.length; i++) {\nif (!archive.files[i].hasStream() && nextFolderUnpackStreamIndex == 0) {\nstreamMap.fileFolderIndex[i] = -1;\ncontinue;\nif (nextFolderUnpackStreamIndex == 0) {\nfor (; nextFolderIndex < archive.folders.length; ++nextFolderIndex) {\nstreamMap.folderFirstFileIndex[nextFolderIndex] = i;\nif (archive.folders[nextFolderIndex].numUnpackSubStreams > 0) {\nbreak;\nif (nextFolderIndex >= archive.folders.length) {\nstreamMap.fileFolderIndex[i] = nextFolderIndex;\nif (!archive.files[i].hasStream()) {\n++nextFolderUnpackStreamIndex;\nif (nextFolderUnpackStreamIndex >= archive.folders[nextFolderIndex].numUnpackSubStreams) {\n++nextFolderIndex;\nnextFolderUnpackStreamIndex = 0;\narchive.streamMap = streamMap;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:write(I)V",
                                    "method_body": "public void write(final int b) throws IOException {\nfile.write(b);\ncompressedCrc32.update(b);\nfileBytesWritten++;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int off, final int len)\nfile.write(b, off, len);\ncompressedCrc32.update(b, off, len);\nfileBytesWritten += len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:flush()V",
                                    "method_body": "public void flush() throws IOException {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:close()V",
                                    "method_body": "public void close() throws IOException {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public CountingOutputStream(final OutputStream out) {\nsuper(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int off, int len) throws IOException {\nout.write(b, off, len);\ncount(len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:count(J)V",
                                    "method_body": "protected void count(long written) {\nif (written != -1) {\nbytesWritten += written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:getBytesWritten()J",
                                    "method_body": "public long getBytesWritten() {\nreturn bytesWritten;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$1:write([BII)V",
                                    "method_body": "private CountingOutputStream setupFileOutputStream() throws IOException {\nOutputStream out = new OutputStreamWrapper();\nreturn new CountingOutputStream(Coders\nsuper.write(b, off, len);\ncrc32.update(b, off, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders:<clinit>()V",
                                    "method_body": "static CoderId[] coderTable = new CoderId[] {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders:addEncoder(Ljava/io/OutputStream;Lorg/apache/commons/compress/archivers/sevenz/SevenZMethod;[B)Ljava/io/OutputStream;",
                                    "method_body": "static OutputStream addEncoder(final OutputStream out, final SevenZMethod method,\nfor (final CoderId coderId : coderTable) {\nif (coderId.method.equals(method)) {\nreturn coderId.coder.encode(out, password);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$CoderId:<init>(Lorg/apache/commons/compress/archivers/sevenz/SevenZMethod;Lorg/apache/commons/compress/archivers/sevenz/Coders$CoderBase;)V",
                                    "method_body": "CoderId(SevenZMethod method, final CoderBase coder) {\nthis.method = method;\nthis.coder = coder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$CoderBase:<init>()V",
                                    "method_body": "final SevenZMethod method;\nstatic abstract class CoderBase {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.LZMA2Decoder:encode(Ljava/io/OutputStream;[B)Ljava/io/OutputStream;",
                                    "method_body": "OutputStream encode(final OutputStream out, final byte[] password)\nLZMA2Options options = new LZMA2Options();\noptions.setDictSize(LZMA2Options.DICT_SIZE_DEFAULT);\nFinishableOutputStream wrapped = new FinishableWrapperOutputStream(out);\nreturn options.getOutputStream(wrapped);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:findBindPairForInStream(I)I",
                                    "method_body": "int findBindPairForInStream(final int index) {\nfor (int i = 0; i < bindPairs.length; i++) {\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:findBindPairForOutStream(I)I",
                                    "method_body": "int findBindPairForOutStream(final int index) {\nfor (int i = 0; i < bindPairs.length; i++) {\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:getUnpackSize()J",
                                    "method_body": "long getUnpackSize() {\nif (totalOutputStreams == 0) {\nfor (int i = ((int)totalOutputStreams) - 1; i >= 0; i--) {\nif (findBindPairForOutStream(i) < 0) {\nreturn unpackSizes[i];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coder:<init>()V",
                                    "method_body": "byte[] decompressionMethodId;\nbyte[] properties = null;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest.testSevenFilesSomeNotEmpty",
                            "test_body": "186: public void testSevenFilesSomeNotEmpty() throws Exception {\n187: testCompress252(7, 2);\n188: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:<init>()V",
                                    "method_body": "public SevenZArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "public void setName(String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:hasStream()Z",
                                    "method_body": "public boolean hasStream() {\nreturn hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasStream(Z)V",
                                    "method_body": "public void setHasStream(boolean hasStream) {\nthis.hasStream = hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nreturn isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setDirectory(Z)V",
                                    "method_body": "public void setDirectory(boolean isDirectory) {\nthis.isDirectory = isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isAntiItem()Z",
                                    "method_body": "public boolean isAntiItem() {\nreturn isAntiItem;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasCreationDate()Z",
                                    "method_body": "public boolean getHasCreationDate() {\nreturn hasCreationDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasLastModifiedDate()Z",
                                    "method_body": "public boolean getHasLastModifiedDate() {\nreturn hasLastModifiedDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getLastModifiedDate()Ljava/util/Date;",
                                    "method_body": "public Date getLastModifiedDate() {\nif (hasLastModifiedDate) {\nreturn ntfsTimeToJavaTime(lastModifiedDate);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setLastModifiedDate(Ljava/util/Date;)V",
                                    "method_body": "public void setLastModifiedDate(Date lastModifiedDate) {\nhasLastModifiedDate = lastModifiedDate != null;\nif (hasLastModifiedDate) {\nthis.lastModifiedDate = javaTimeToNtfsTime(lastModifiedDate);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasAccessDate()Z",
                                    "method_body": "public boolean getHasAccessDate() {\nreturn hasAccessDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasWindowsAttributes()Z",
                                    "method_body": "public boolean getHasWindowsAttributes() {\nreturn hasWindowsAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasCrc(Z)V",
                                    "method_body": "public void setHasCrc(boolean hasCrc) {\nthis.hasCrc = hasCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCompressedSize(J)V",
                                    "method_body": "void setCompressedSize(long size) {\nthis.compressedSize = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:ntfsTimeToJavaTime(J)Ljava/util/Date;",
                                    "method_body": "public static Date ntfsTimeToJavaTime(final long ntfsTime) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nfinal long realTime = ntfsEpoch.getTimeInMillis() + (ntfsTime / (10*1000));\nreturn new Date(realTime);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:javaTimeToNtfsTime(Ljava/util/Date;)J",
                                    "method_body": "public static long javaTimeToNtfsTime(final Date date) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nreturn ((date.getTime() - ntfsEpoch.getTimeInMillis())* 1000 * 10);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:<init>(Ljava/io/File;)V",
                                    "method_body": "private final RandomAccessFile file;\nprivate final List<SevenZArchiveEntry> files = new ArrayList<SevenZArchiveEntry>();\nprivate int numNonEmptyStreams = 0;\nprivate CRC32 crc32 = new CRC32();\nprivate CRC32 compressedCrc32 = new CRC32();\nprivate long fileBytesWritten = 0;\nprivate boolean finished = false;\nprivate SevenZMethod contentCompression = SevenZMethod.LZMA2;\npublic SevenZOutputFile(final File filename) throws IOException {\nfile = new RandomAccessFile(filename, \"rw\");\nfile.seek(SevenZFile.SIGNATURE_HEADER_SIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!finished) {\nfinish();\nfile.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:createArchiveEntry(Ljava/io/File;Ljava/lang/String;)Lorg/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry;",
                                    "method_body": "public SevenZArchiveEntry createArchiveEntry(final File inputFile,\nfinal SevenZArchiveEntry entry = new SevenZArchiveEntry();\nentry.setDirectory(inputFile.isDirectory());\nentry.setName(entryName);\nentry.setLastModifiedDate(new Date(inputFile.lastModified()));\nreturn entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\nfinal SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;\nfiles.add(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (currentOutputStream != null) {\ncurrentOutputStream.flush();\ncurrentOutputStream.close();\nfinal SevenZArchiveEntry entry = files.get(files.size() - 1);\nif (fileBytesWritten > 0) {\nentry.setHasStream(true);\n++numNonEmptyStreams;\nentry.setSize(currentOutputStream.getBytesWritten());\nentry.setCompressedSize(fileBytesWritten);\nentry.setCrcValue(crc32.getValue());\nentry.setCompressedCrcValue(compressedCrc32.getValue());\nentry.setHasCrc(true);\nentry.setHasStream(false);\nentry.setSize(0);\nentry.setCompressedSize(0);\nentry.setHasCrc(false);\ncurrentOutputStream = null;\ncrc32.reset();\ncompressedCrc32.reset();\nfileBytesWritten = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([B)V",
                                    "method_body": "public void write(final byte[] b) throws IOException {\nwrite(b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int off, final int len) throws IOException {\nif (len > 0) {\ngetCurrentOutputStream().write(b, off, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif (finished) {\nfinished = true;\nfinal long headerPosition = file.getFilePointer();\nfinal ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();\nfinal DataOutputStream header = new DataOutputStream(headerBaos);\nwriteHeader(header);\nheader.flush();\nfinal byte[] headerBytes = headerBaos.toByteArray();\nfile.write(headerBytes);\nfinal CRC32 crc32 = new CRC32();\nfile.seek(0);\nfile.write(SevenZFile.sevenZSignature);\nfile.write(0);\nfile.write(2);\nfinal ByteArrayOutputStream startHeaderBaos = new ByteArrayOutputStream();\nfinal DataOutputStream startHeaderStream = new DataOutputStream(startHeaderBaos);\nstartHeaderStream.writeLong(Long.reverseBytes(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE));\nstartHeaderStream.writeLong(Long.reverseBytes(0xffffFFFFL & headerBytes.length));\ncrc32.reset();\ncrc32.update(headerBytes);\nstartHeaderStream.writeInt(Integer.reverseBytes((int)crc32.getValue()));\nstartHeaderStream.flush();\nfinal byte[] startHeaderBytes = startHeaderBaos.toByteArray();\ncrc32.reset();\ncrc32.update(startHeaderBytes);\nfile.writeInt(Integer.reverseBytes((int) crc32.getValue()));\nfile.write(startHeaderBytes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeHeader(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeHeader(final DataOutput header) throws IOException {\nheader.write(NID.kHeader);\nheader.write(NID.kMainStreamsInfo);\nwriteStreamsInfo(header);\nwriteFilesInfo(header);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeStreamsInfo(final DataOutput header) throws IOException {\nif (numNonEmptyStreams > 0) {\nwritePackInfo(header);\nwriteUnpackInfo(header);\nwriteSubStreamsInfo(header);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeSubStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeSubStreamsInfo(final DataOutput header) throws IOException {\nheader.write(NID.kSubStreamsInfo);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFilesInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFilesInfo(final DataOutput header) throws IOException {\nheader.write(NID.kFilesInfo);\nwriteUint64(header, files.size());\nwriteFileEmptyStreams(header);\nwriteFileEmptyFiles(header);\nwriteFileAntiItems(header);\nwriteFileNames(header);\nwriteFileCTimes(header);\nwriteFileATimes(header);\nwriteFileMTimes(header);\nwriteFileWindowsAttributes(header);\nheader.write(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyStreams(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyStreams(final DataOutput header) throws IOException {\nboolean hasEmptyStreams = false;\nfor (final SevenZArchiveEntry entry : files) {\nif (!entry.hasStream()) {\nhasEmptyStreams = true;\nbreak;\nif (hasEmptyStreams) {\nheader.write(NID.kEmptyStream);\nfinal BitSet emptyStreams = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nemptyStreams.set(i, !files.get(i).hasStream());\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyStreams, files.size());\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyFiles(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyFiles(final DataOutput header) throws IOException {\nboolean hasEmptyFiles = false;\nint emptyStreamCounter = 0;\nfinal BitSet emptyFiles = new BitSet(0);\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isDir = files.get(i).isDirectory();\nemptyFiles.set(emptyStreamCounter++, !isDir);\nhasEmptyFiles |= !isDir;\nif (hasEmptyFiles) {\nheader.write(NID.kEmptyFile);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyFiles, emptyStreamCounter);\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileAntiItems(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileAntiItems(final DataOutput header) throws IOException {\nboolean hasAntiItems = false;\nfinal BitSet antiItems = new BitSet(0);\nint antiItemCounter = 0;\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isAnti = files.get(i).isAntiItem();\nantiItems.set(antiItemCounter++, isAnti);\nhasAntiItems |= isAnti;\nif (hasAntiItems) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileNames(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileNames(final DataOutput header) throws IOException {\nheader.write(NID.kName);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nout.write(entry.getName().getBytes(\"UTF-16LE\"));\nout.writeShort(0);\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileCTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileCTimes(final DataOutput header) throws IOException {\nint numCreationDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasCreationDate()) {\n}\nif (numCreationDates > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileATimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileATimes(final DataOutput header) throws IOException {\nint numAccessDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasAccessDate()) {\n}\nif (numAccessDates > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileMTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileMTimes(final DataOutput header) throws IOException {\nint numLastModifiedDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\n++numLastModifiedDates;\n}\nif (numLastModifiedDates > 0) {\nheader.write(NID.kMTime);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numLastModifiedDates != files.size()) {\nout.write(0);\nfinal BitSet mTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nmTimes.set(i, files.get(i).getHasLastModifiedDate());\nwriteBits(out, mTimes, files.size());\n} else {\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\nout.writeLong(Long.reverseBytes(\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileWindowsAttributes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileWindowsAttributes(final DataOutput header) throws IOException {\nint numWindowsAttributes = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasWindowsAttributes()) {\n}\nif (numWindowsAttributes > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeUint64(Ljava/io/DataOutput;J)V",
                                    "method_body": "private void writeUint64(final DataOutput header, long value) throws IOException {\nint firstByte = 0;\nint mask = 0x80;\nfor (i = 0; i < 8; i++) {\nif (value < ((1L << ( 7  * (i + 1))))) {\nfirstByte |= (value >>> (8 * i));\nbreak;\nfirstByte |= mask;\nmask >>>= 1;\nheader.write(firstByte);\nfor (; i > 0; i--) {\nheader.write((int) (0xff & value));\nvalue >>>= 8;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeBits(Ljava/io/DataOutput;Ljava/util/BitSet;I)V",
                                    "method_body": "private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\nint cache = 0;\nint shift = 7;\nfor (int i = 0; i < length; i++) {\ncache |= ((bits.get(i) ? 1 : 0) << shift);\n--shift;\nif (shift == 0) {\nheader.write(cache);\nshift = 7;\ncache = 0;\nif (length > 0 && shift > 0) {\nheader.write(cache);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:<init>(Ljava/lang/String;I[B)V",
                                    "method_body": "private SevenZMethod(byte[] id) {\nthis.id = id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;[B)V",
                                    "method_body": "public SevenZFile(final File filename, final byte[] password) throws IOException {\nboolean succeeded = false;\nthis.file = new RandomAccessFile(filename, \"r\");\narchive = readHeaders(password);\nif (!succeeded) {\nthis.file.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZFile(final File filename) throws IOException {\nthis(filename, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<clinit>()V",
                                    "method_body": "static final int SIGNATURE_HEADER_SIZE = 32;\nprivate int currentEntryIndex = -1;\nprivate int currentFolderIndex = -1;\nprivate InputStream currentFolderInputStream = null;\nprivate InputStream currentEntryInputStream = null;\nstatic final byte[] sevenZSignature = {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeaders([B)Lorg/apache/commons/compress/archivers/sevenz/Archive;",
                                    "method_body": "private Archive readHeaders(byte[] password) throws IOException {\nfinal byte[] signature = new byte[6];\nfile.readFully(signature);\nif (!Arrays.equals(signature, sevenZSignature)) {\nfinal byte archiveVersionMajor = file.readByte();\nfinal byte archiveVersionMinor = file.readByte();\nif (archiveVersionMajor != 0) {\nfinal long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\nfinal StartHeader startHeader = readStartHeader(startHeaderCrc);\nfinal int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\nif (nextHeaderSizeInt != startHeader.nextHeaderSize) {\nfile.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\nfinal byte[] nextHeader = new byte[nextHeaderSizeInt];\nfile.readFully(nextHeader);\nfinal CRC32 crc = new CRC32();\ncrc.update(nextHeader);\nif (startHeader.nextHeaderCrc != crc.getValue()) {\nfinal ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\nDataInputStream nextHeaderInputStream = new DataInputStream(\nArchive archive = new Archive();\nint nid = nextHeaderInputStream.readUnsignedByte();\nif (nid == NID.kEncodedHeader) {\nif (nid == NID.kHeader) {\nreadHeader(nextHeaderInputStream, archive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStartHeader(J)Lorg/apache/commons/compress/archivers/sevenz/StartHeader;",
                                    "method_body": "private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\nfinal StartHeader startHeader = new StartHeader();\nDataInputStream dataInputStream = null;\ndataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\nstartHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\nreturn startHeader;\nif (dataInputStream != null) {\ndataInputStream.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\nif (nid == NID.kPackInfo) {\nreadPackInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid == NID.kUnpackInfo) {\nreadUnpackInfo(header, archive);\nnid = header.readUnsignedByte();\narchive.folders = new Folder[0];\nif (nid == NID.kSubStreamsInfo) {\nreadSubStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid != NID.kEnd) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readSubStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nfor (final Folder folder : archive.folders) {\nfolder.numUnpackSubStreams = 1;\nint totalUnpackStreams = archive.folders.length;\nint nid = header.readUnsignedByte();\nif (nid == NID.kNumUnpackStream) {\nfinal SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\nsubStreamsInfo.unpackSizes = new long[totalUnpackStreams];\nsubStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\nsubStreamsInfo.crcs = new long[totalUnpackStreams];\nint nextUnpackStream = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams == 0) {\nlong sum = 0;\nif (nid == NID.kSize) {\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;\nif (nid == NID.kSize) {\nint numDigests = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {\nif (nid == NID.kCRC) {\nif (nid != NID.kEnd) {\narchive.subStreamsInfo = subStreamsInfo;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readBits(final DataInput header, final int size) throws IOException {\nfinal BitSet bits = new BitSet(size);\nint mask = 0;\nint cache = 0;\nfor (int i = 0; i < size; i++) {\nif (mask == 0) {\nmask = 0x80;\ncache = header.readUnsignedByte();\nbits.set(i, (cache & mask) != 0);\nmask >>>= 1;\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFilesInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readFilesInfo(final DataInput header, final Archive archive) throws IOException {\nfinal long numFiles = readUint64(header);\nfinal SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\nfor (int i = 0; i < files.length; i++) {\nfiles[i] = new SevenZArchiveEntry();\nBitSet isEmptyStream = null;\nBitSet isEmptyFile = null;\nBitSet isAnti = null;\nfinal int propertyType = header.readUnsignedByte();\nif (propertyType == 0) {\nbreak;\nlong size = readUint64(header);\nswitch (propertyType) {\nisEmptyStream = readBits(header, files.length);\nbreak;\nif (isEmptyStream == null) { // protect against NPE\nisEmptyFile = readBits(header, isEmptyStream.cardinality());\nbreak;\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nif (((size - 1) & 1) != 0) {\nfinal byte[] names = new byte[(int)(size - 1)];\nheader.readFully(names);\nint nextFile = 0;\nint nextName = 0;\nfor (int i = 0; i < names.length; i += 2) {\nif (names[i] == 0 && names[i+1] == 0) {\nfiles[nextFile++].setName(new String(names, nextName, i-nextName, CharsetNames.UTF_16LE));\nnextName = i + 2;\nif (nextName != names.length || nextFile != files.length) {\nbreak;\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasLastModifiedDate(timesDefined.get(i));\nif (files[i].getHasLastModifiedDate()) {\nfiles[i].setLastModifiedDate(Long.reverseBytes(header.readLong()));\nbreak;\nthrow new IOException(\"Unknown property \" + propertyType);\n}\nint nonEmptyFileCounter = 0;\nint emptyFileCounter = 0;\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasStream((isEmptyStream == null) ? true : !isEmptyStream.get(i));\nif (files[i].hasStream()) {\nfiles[i].setDirectory(false);\nfiles[i].setAntiItem(false);\nfiles[i].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nfiles[i].setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nfiles[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\nfiles[i].setDirectory((isEmptyFile == null) ? true : !isEmptyFile.get(emptyFileCounter));\nfiles[i].setAntiItem((isAnti == null) ? false : isAnti.get(emptyFileCounter));\nfiles[i].setHasCrc(false);\nfiles[i].setSize(0);\n++emptyFileCounter;\narchive.files = files;\ncalculateStreamMap(archive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUint64(Ljava/io/DataInput;)J",
                                    "method_body": "private static long readUint64(final DataInput in) throws IOException {\nlong firstByte = in.readUnsignedByte();\nint mask = 0x80;\nlong value = 0;\nfor (int i = 0; i < 8; i++) {\nif ((firstByte & mask) == 0) {\nreturn value | ((firstByte & (mask - 1)) << (8 * i));\nlong nextByte = in.readUnsignedByte();\nvalue |= (nextByte << (8 * i));\nmask >>>= 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;JJ)V",
                                    "method_body": "public ChecksumVerifyingInputStream(final Checksum checksum, final InputStream in,\nfinal long size, final long expectedChecksum) {\nthis.checksum = checksum;\nthis.in = in;\nthis.expectedChecksum = expectedChecksum;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining <= 0) {\nint ret = in.read();\nif (ret >= 0) {\nchecksum.update(ret);\n--bytesRemaining;\nif (bytesRemaining == 0 && expectedChecksum != checksum.getValue()) {\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nint ret = in.read(b, off, len);\nif (ret >= 0) {\nchecksum.update(b, off, ret);\nbytesRemaining -= ret;\nif (bytesRemaining <= 0 && expectedChecksum != checksum.getValue()) {\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nin.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CRC32VerifyingInputStream:<init>(Ljava/io/InputStream;JJ)V",
                                    "method_body": "public CRC32VerifyingInputStream(final InputStream in, final long size, final long expectedCrc32) {\nsuper(new CRC32(), in, size, expectedCrc32);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:<init>(Ljava/io/RandomAccessFile;J)V",
                                    "method_body": "public BoundedRandomAccessFileInputStream(final RandomAccessFile file,\nfinal long size) {\nthis.file = file;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining > 0) {\n--bytesRemaining;\nreturn file.read();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif (bytesRemaining == 0) {\nint bytesToRead = len;\nif (bytesToRead > bytesRemaining) {\nfinal int bytesRead = file.read(b, off, bytesToRead);\nif (bytesRead >= 0) {\nbytesRemaining -= bytesRead;\nreturn bytesRead;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:close()V",
                                    "method_body": "public void close() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getCrcValue()J",
                                    "method_body": "public long getCrcValue() {\nreturn crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCrcValue(J)V",
                                    "method_body": "public void setCrcValue(long crc) {\nthis.crc = crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getCompressedCrcValue()J",
                                    "method_body": "long getCompressedCrcValue() {\nreturn compressedCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCompressedCrcValue(J)V",
                                    "method_body": "void setCompressedCrcValue(long crc) {\nthis.compressedCrc = crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getCompressedSize()J",
                                    "method_body": "long getCompressedSize() {\nreturn compressedSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:getCurrentOutputStream()Ljava/io/OutputStream;",
                                    "method_body": "private OutputStream getCurrentOutputStream() throws IOException {\nif (currentOutputStream == null) {\ncurrentOutputStream = setupFileOutputStream();\nreturn currentOutputStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:setupFileOutputStream()Lorg/apache/commons/compress/utils/CountingOutputStream;",
                                    "method_body": "private CountingOutputStream setupFileOutputStream() throws IOException {\nOutputStream out = new OutputStreamWrapper();\nreturn new CountingOutputStream(Coders\nsuper.write(b, off, len);\ncrc32.update(b, off, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writePackInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writePackInfo(final DataOutput header) throws IOException {\nheader.write(NID.kPackInfo);\nwriteUint64(header, 0);\nwriteUint64(header, 0xffffFFFFL & numNonEmptyStreams);\nheader.write(NID.kSize);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nwriteUint64(header, entry.getCompressedSize());\n}\nheader.write(NID.kCRC);\nheader.write(1);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nheader.writeInt(Integer.reverseBytes((int) entry.getCompressedCrcValue()));\n}\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeUnpackInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeUnpackInfo(final DataOutput header) throws IOException {\nheader.write(NID.kUnpackInfo);\nheader.write(NID.kFolder);\nwriteUint64(header, numNonEmptyStreams);\nheader.write(0);\nfor (int i = 0; i < numNonEmptyStreams; i++) {\nwriteFolder(header);\nheader.write(NID.kCodersUnpackSize);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nwriteUint64(header, entry.getSize());\n}\nheader.write(NID.kCRC);\nheader.write(1);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nheader.writeInt(Integer.reverseBytes((int) entry.getCrcValue()));\n}\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFolder(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFolder(final DataOutput header) throws IOException {\nwriteUint64(header, 1);\nbyte[] id = contentCompression.getId();\nbyte[] properties = contentCompression.getProperties();\nint codecFlags = id.length;\nif (properties.length > 0) {\ncodecFlags |= 0x20;\nheader.write(codecFlags);\nheader.write(id);\nif (properties.length > 0) {\nheader.write(properties.length);\nheader.write(properties);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:getId()[B",
                                    "method_body": "byte[] getId() {\nbyte[] copy = new byte[id.length];\nSystem.arraycopy(id, 0, copy, 0, id.length);\nreturn copy;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod$1:getProperties()[B",
                                    "method_body": "byte[] getProperties() {\nint dictSize = LZMA2Options.DICT_SIZE_DEFAULT;\nint lead = Integer.numberOfLeadingZeros(dictSize);\nint secondBit = (dictSize >>> (30 - lead)) - 2;\nreturn new byte[] {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readPackInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readPackInfo(final DataInput header, final Archive archive) throws IOException {\narchive.packPos = readUint64(header);\nfinal long numPackStreams = readUint64(header);\nint nid = header.readUnsignedByte();\nif (nid == NID.kSize) {\narchive.packSizes = new long[(int)numPackStreams];\nfor (int i = 0; i < archive.packSizes.length; i++) {\narchive.packSizes[i] = readUint64(header);\nnid = header.readUnsignedByte();\nif (nid == NID.kCRC) {\narchive.packCrcsDefined = readAllOrBits(header, (int)numPackStreams);\narchive.packCrcs = new long[(int)numPackStreams];\nfor (int i = 0; i < (int)numPackStreams; i++) {\nif (archive.packCrcsDefined.get(i)) {\narchive.packCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\nnid = header.readUnsignedByte();\nif (nid != NID.kEnd) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUnpackInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readUnpackInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\nif (nid != NID.kFolder) {\nfinal long numFolders = readUint64(header);\nfinal Folder[] folders = new Folder[(int)numFolders];\narchive.folders = folders;\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nfor (int i = 0; i < (int)numFolders; i++) {\nfolders[i] = readFolder(header);\nnid = header.readUnsignedByte();\nif (nid != NID.kCodersUnpackSize) {\nfor (final Folder folder : folders) {\nfolder.unpackSizes = new long[(int)folder.totalOutputStreams];\nfor (int i = 0; i < folder.totalOutputStreams; i++) {\nfolder.unpackSizes[i] = readUint64(header);\nnid = header.readUnsignedByte();\nif (nid == NID.kCRC) {\nfinal BitSet crcsDefined = readAllOrBits(header, (int)numFolders);\nfor (int i = 0; i < (int)numFolders; i++) {\nif (crcsDefined.get(i)) {\nfolders[i].hasCrc = true;\nfolders[i].crc = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\nnid = header.readUnsignedByte();\nif (nid != NID.kEnd) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFolder(Ljava/io/DataInput;)Lorg/apache/commons/compress/archivers/sevenz/Folder;",
                                    "method_body": "private Folder readFolder(final DataInput header) throws IOException {\nfinal Folder folder = new Folder();\nfinal long numCoders = readUint64(header);\nfinal Coder[] coders = new Coder[(int)numCoders];\nlong totalInStreams = 0;\nlong totalOutStreams = 0;\nfor (int i = 0; i < coders.length; i++) {\ncoders[i] = new Coder();\nint bits = header.readUnsignedByte();\nfinal int idSize = bits & 0xf;\nfinal boolean isSimple = ((bits & 0x10) == 0);\nfinal boolean hasAttributes = ((bits & 0x20) != 0);\nfinal boolean moreAlternativeMethods = ((bits & 0x80) != 0);\ncoders[i].decompressionMethodId = new byte[idSize];\nheader.readFully(coders[i].decompressionMethodId);\nif (isSimple) {\ncoders[i].numInStreams = 1;\ncoders[i].numOutStreams = 1;\ntotalInStreams += coders[i].numInStreams;\ntotalOutStreams += coders[i].numOutStreams;\nif (hasAttributes) {\nfinal long propertiesSize = readUint64(header);\ncoders[i].properties = new byte[(int)propertiesSize];\nheader.readFully(coders[i].properties);\nwhile (moreAlternativeMethods) {\nfolder.coders = coders;\nfolder.totalInputStreams = totalInStreams;\nfolder.totalOutputStreams = totalOutStreams;\nif (totalOutStreams == 0) {\nfinal long numBindPairs = totalOutStreams - 1;\nfinal BindPair[] bindPairs = new BindPair[(int)numBindPairs];\nfor (int i = 0; i < bindPairs.length; i++) {\nfolder.bindPairs = bindPairs;\nif (totalInStreams < numBindPairs) {\nfinal long numPackedStreams = totalInStreams - numBindPairs;\nfinal long packedStreams[] = new long[(int)numPackedStreams];\nif (numPackedStreams == 1) {\nfor (i = 0; i < (int)totalInStreams; i++) {\nif (folder.findBindPairForInStream(i) < 0) {\nbreak;\nif (i == (int)totalInStreams) {\npackedStreams[0] = i;\n} else {\nfolder.packedStreams = packedStreams;\nreturn folder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readAllOrBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readAllOrBits(final DataInput header, final int size) throws IOException {\nfinal int areAllDefined = header.readUnsignedByte();\nif (areAllDefined != 0) {\nbits = new BitSet(size);\nfor (int i = 0; i < size; i++) {\nbits.set(i, true);\nbits = readBits(header, size);\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:write(I)V",
                                    "method_body": "public void write(final int b) throws IOException {\nfile.write(b);\ncompressedCrc32.update(b);\nfileBytesWritten++;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int off, final int len)\nfile.write(b, off, len);\ncompressedCrc32.update(b, off, len);\nfileBytesWritten += len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:flush()V",
                                    "method_body": "public void flush() throws IOException {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:close()V",
                                    "method_body": "public void close() throws IOException {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public CountingOutputStream(final OutputStream out) {\nsuper(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int off, int len) throws IOException {\nout.write(b, off, len);\ncount(len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:count(J)V",
                                    "method_body": "protected void count(long written) {\nif (written != -1) {\nbytesWritten += written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:getBytesWritten()J",
                                    "method_body": "public long getBytesWritten() {\nreturn bytesWritten;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$1:write([BII)V",
                                    "method_body": "private CountingOutputStream setupFileOutputStream() throws IOException {\nOutputStream out = new OutputStreamWrapper();\nreturn new CountingOutputStream(Coders\nsuper.write(b, off, len);\ncrc32.update(b, off, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders:<clinit>()V",
                                    "method_body": "static CoderId[] coderTable = new CoderId[] {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders:addEncoder(Ljava/io/OutputStream;Lorg/apache/commons/compress/archivers/sevenz/SevenZMethod;[B)Ljava/io/OutputStream;",
                                    "method_body": "static OutputStream addEncoder(final OutputStream out, final SevenZMethod method,\nfor (final CoderId coderId : coderTable) {\nif (coderId.method.equals(method)) {\nreturn coderId.coder.encode(out, password);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$CoderId:<init>(Lorg/apache/commons/compress/archivers/sevenz/SevenZMethod;Lorg/apache/commons/compress/archivers/sevenz/Coders$CoderBase;)V",
                                    "method_body": "CoderId(SevenZMethod method, final CoderBase coder) {\nthis.method = method;\nthis.coder = coder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$CoderBase:<init>()V",
                                    "method_body": "final SevenZMethod method;\nstatic abstract class CoderBase {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.LZMA2Decoder:encode(Ljava/io/OutputStream;[B)Ljava/io/OutputStream;",
                                    "method_body": "OutputStream encode(final OutputStream out, final byte[] password)\nLZMA2Options options = new LZMA2Options();\noptions.setDictSize(LZMA2Options.DICT_SIZE_DEFAULT);\nFinishableOutputStream wrapped = new FinishableWrapperOutputStream(out);\nreturn options.getOutputStream(wrapped);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:findBindPairForInStream(I)I",
                                    "method_body": "int findBindPairForInStream(final int index) {\nfor (int i = 0; i < bindPairs.length; i++) {\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:findBindPairForOutStream(I)I",
                                    "method_body": "int findBindPairForOutStream(final int index) {\nfor (int i = 0; i < bindPairs.length; i++) {\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:getUnpackSize()J",
                                    "method_body": "long getUnpackSize() {\nif (totalOutputStreams == 0) {\nfor (int i = ((int)totalOutputStreams) - 1; i >= 0; i--) {\nif (findBindPairForOutStream(i) < 0) {\nreturn unpackSizes[i];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coder:<init>()V",
                                    "method_body": "byte[] decompressionMethodId;\nbyte[] properties = null;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest.testNineFilesSomeNotEmpty",
                            "test_body": "202: public void testNineFilesSomeNotEmpty() throws Exception {\n203: testCompress252(9, 2);\n204: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:<init>()V",
                                    "method_body": "public SevenZArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "public void setName(String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:hasStream()Z",
                                    "method_body": "public boolean hasStream() {\nreturn hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasStream(Z)V",
                                    "method_body": "public void setHasStream(boolean hasStream) {\nthis.hasStream = hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nreturn isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setDirectory(Z)V",
                                    "method_body": "public void setDirectory(boolean isDirectory) {\nthis.isDirectory = isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isAntiItem()Z",
                                    "method_body": "public boolean isAntiItem() {\nreturn isAntiItem;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasCreationDate()Z",
                                    "method_body": "public boolean getHasCreationDate() {\nreturn hasCreationDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasLastModifiedDate()Z",
                                    "method_body": "public boolean getHasLastModifiedDate() {\nreturn hasLastModifiedDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getLastModifiedDate()Ljava/util/Date;",
                                    "method_body": "public Date getLastModifiedDate() {\nif (hasLastModifiedDate) {\nreturn ntfsTimeToJavaTime(lastModifiedDate);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setLastModifiedDate(Ljava/util/Date;)V",
                                    "method_body": "public void setLastModifiedDate(Date lastModifiedDate) {\nhasLastModifiedDate = lastModifiedDate != null;\nif (hasLastModifiedDate) {\nthis.lastModifiedDate = javaTimeToNtfsTime(lastModifiedDate);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasAccessDate()Z",
                                    "method_body": "public boolean getHasAccessDate() {\nreturn hasAccessDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasWindowsAttributes()Z",
                                    "method_body": "public boolean getHasWindowsAttributes() {\nreturn hasWindowsAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasCrc(Z)V",
                                    "method_body": "public void setHasCrc(boolean hasCrc) {\nthis.hasCrc = hasCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCompressedSize(J)V",
                                    "method_body": "void setCompressedSize(long size) {\nthis.compressedSize = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:ntfsTimeToJavaTime(J)Ljava/util/Date;",
                                    "method_body": "public static Date ntfsTimeToJavaTime(final long ntfsTime) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nfinal long realTime = ntfsEpoch.getTimeInMillis() + (ntfsTime / (10*1000));\nreturn new Date(realTime);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:javaTimeToNtfsTime(Ljava/util/Date;)J",
                                    "method_body": "public static long javaTimeToNtfsTime(final Date date) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nreturn ((date.getTime() - ntfsEpoch.getTimeInMillis())* 1000 * 10);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:<init>(Ljava/io/File;)V",
                                    "method_body": "private final RandomAccessFile file;\nprivate final List<SevenZArchiveEntry> files = new ArrayList<SevenZArchiveEntry>();\nprivate int numNonEmptyStreams = 0;\nprivate CRC32 crc32 = new CRC32();\nprivate CRC32 compressedCrc32 = new CRC32();\nprivate long fileBytesWritten = 0;\nprivate boolean finished = false;\nprivate SevenZMethod contentCompression = SevenZMethod.LZMA2;\npublic SevenZOutputFile(final File filename) throws IOException {\nfile = new RandomAccessFile(filename, \"rw\");\nfile.seek(SevenZFile.SIGNATURE_HEADER_SIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!finished) {\nfinish();\nfile.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:createArchiveEntry(Ljava/io/File;Ljava/lang/String;)Lorg/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry;",
                                    "method_body": "public SevenZArchiveEntry createArchiveEntry(final File inputFile,\nfinal SevenZArchiveEntry entry = new SevenZArchiveEntry();\nentry.setDirectory(inputFile.isDirectory());\nentry.setName(entryName);\nentry.setLastModifiedDate(new Date(inputFile.lastModified()));\nreturn entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\nfinal SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;\nfiles.add(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (currentOutputStream != null) {\ncurrentOutputStream.flush();\ncurrentOutputStream.close();\nfinal SevenZArchiveEntry entry = files.get(files.size() - 1);\nif (fileBytesWritten > 0) {\nentry.setHasStream(true);\n++numNonEmptyStreams;\nentry.setSize(currentOutputStream.getBytesWritten());\nentry.setCompressedSize(fileBytesWritten);\nentry.setCrcValue(crc32.getValue());\nentry.setCompressedCrcValue(compressedCrc32.getValue());\nentry.setHasCrc(true);\nentry.setHasStream(false);\nentry.setSize(0);\nentry.setCompressedSize(0);\nentry.setHasCrc(false);\ncurrentOutputStream = null;\ncrc32.reset();\ncompressedCrc32.reset();\nfileBytesWritten = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([B)V",
                                    "method_body": "public void write(final byte[] b) throws IOException {\nwrite(b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int off, final int len) throws IOException {\nif (len > 0) {\ngetCurrentOutputStream().write(b, off, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif (finished) {\nfinished = true;\nfinal long headerPosition = file.getFilePointer();\nfinal ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();\nfinal DataOutputStream header = new DataOutputStream(headerBaos);\nwriteHeader(header);\nheader.flush();\nfinal byte[] headerBytes = headerBaos.toByteArray();\nfile.write(headerBytes);\nfinal CRC32 crc32 = new CRC32();\nfile.seek(0);\nfile.write(SevenZFile.sevenZSignature);\nfile.write(0);\nfile.write(2);\nfinal ByteArrayOutputStream startHeaderBaos = new ByteArrayOutputStream();\nfinal DataOutputStream startHeaderStream = new DataOutputStream(startHeaderBaos);\nstartHeaderStream.writeLong(Long.reverseBytes(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE));\nstartHeaderStream.writeLong(Long.reverseBytes(0xffffFFFFL & headerBytes.length));\ncrc32.reset();\ncrc32.update(headerBytes);\nstartHeaderStream.writeInt(Integer.reverseBytes((int)crc32.getValue()));\nstartHeaderStream.flush();\nfinal byte[] startHeaderBytes = startHeaderBaos.toByteArray();\ncrc32.reset();\ncrc32.update(startHeaderBytes);\nfile.writeInt(Integer.reverseBytes((int) crc32.getValue()));\nfile.write(startHeaderBytes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeHeader(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeHeader(final DataOutput header) throws IOException {\nheader.write(NID.kHeader);\nheader.write(NID.kMainStreamsInfo);\nwriteStreamsInfo(header);\nwriteFilesInfo(header);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeStreamsInfo(final DataOutput header) throws IOException {\nif (numNonEmptyStreams > 0) {\nwritePackInfo(header);\nwriteUnpackInfo(header);\nwriteSubStreamsInfo(header);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeSubStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeSubStreamsInfo(final DataOutput header) throws IOException {\nheader.write(NID.kSubStreamsInfo);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFilesInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFilesInfo(final DataOutput header) throws IOException {\nheader.write(NID.kFilesInfo);\nwriteUint64(header, files.size());\nwriteFileEmptyStreams(header);\nwriteFileEmptyFiles(header);\nwriteFileAntiItems(header);\nwriteFileNames(header);\nwriteFileCTimes(header);\nwriteFileATimes(header);\nwriteFileMTimes(header);\nwriteFileWindowsAttributes(header);\nheader.write(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyStreams(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyStreams(final DataOutput header) throws IOException {\nboolean hasEmptyStreams = false;\nfor (final SevenZArchiveEntry entry : files) {\nif (!entry.hasStream()) {\nhasEmptyStreams = true;\nbreak;\nif (hasEmptyStreams) {\nheader.write(NID.kEmptyStream);\nfinal BitSet emptyStreams = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nemptyStreams.set(i, !files.get(i).hasStream());\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyStreams, files.size());\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyFiles(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyFiles(final DataOutput header) throws IOException {\nboolean hasEmptyFiles = false;\nint emptyStreamCounter = 0;\nfinal BitSet emptyFiles = new BitSet(0);\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isDir = files.get(i).isDirectory();\nemptyFiles.set(emptyStreamCounter++, !isDir);\nhasEmptyFiles |= !isDir;\nif (hasEmptyFiles) {\nheader.write(NID.kEmptyFile);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyFiles, emptyStreamCounter);\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileAntiItems(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileAntiItems(final DataOutput header) throws IOException {\nboolean hasAntiItems = false;\nfinal BitSet antiItems = new BitSet(0);\nint antiItemCounter = 0;\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isAnti = files.get(i).isAntiItem();\nantiItems.set(antiItemCounter++, isAnti);\nhasAntiItems |= isAnti;\nif (hasAntiItems) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileNames(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileNames(final DataOutput header) throws IOException {\nheader.write(NID.kName);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nout.write(entry.getName().getBytes(\"UTF-16LE\"));\nout.writeShort(0);\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileCTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileCTimes(final DataOutput header) throws IOException {\nint numCreationDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasCreationDate()) {\n}\nif (numCreationDates > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileATimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileATimes(final DataOutput header) throws IOException {\nint numAccessDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasAccessDate()) {\n}\nif (numAccessDates > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileMTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileMTimes(final DataOutput header) throws IOException {\nint numLastModifiedDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\n++numLastModifiedDates;\n}\nif (numLastModifiedDates > 0) {\nheader.write(NID.kMTime);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numLastModifiedDates != files.size()) {\nout.write(0);\nfinal BitSet mTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nmTimes.set(i, files.get(i).getHasLastModifiedDate());\nwriteBits(out, mTimes, files.size());\n} else {\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\nout.writeLong(Long.reverseBytes(\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileWindowsAttributes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileWindowsAttributes(final DataOutput header) throws IOException {\nint numWindowsAttributes = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasWindowsAttributes()) {\n}\nif (numWindowsAttributes > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeUint64(Ljava/io/DataOutput;J)V",
                                    "method_body": "private void writeUint64(final DataOutput header, long value) throws IOException {\nint firstByte = 0;\nint mask = 0x80;\nfor (i = 0; i < 8; i++) {\nif (value < ((1L << ( 7  * (i + 1))))) {\nfirstByte |= (value >>> (8 * i));\nbreak;\nfirstByte |= mask;\nmask >>>= 1;\nheader.write(firstByte);\nfor (; i > 0; i--) {\nheader.write((int) (0xff & value));\nvalue >>>= 8;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeBits(Ljava/io/DataOutput;Ljava/util/BitSet;I)V",
                                    "method_body": "private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\nint cache = 0;\nint shift = 7;\nfor (int i = 0; i < length; i++) {\ncache |= ((bits.get(i) ? 1 : 0) << shift);\n--shift;\nif (shift == 0) {\nheader.write(cache);\nshift = 7;\ncache = 0;\nif (length > 0 && shift > 0) {\nheader.write(cache);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:<init>(Ljava/lang/String;I[B)V",
                                    "method_body": "private SevenZMethod(byte[] id) {\nthis.id = id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;[B)V",
                                    "method_body": "public SevenZFile(final File filename, final byte[] password) throws IOException {\nboolean succeeded = false;\nthis.file = new RandomAccessFile(filename, \"r\");\narchive = readHeaders(password);\nif (!succeeded) {\nthis.file.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZFile(final File filename) throws IOException {\nthis(filename, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<clinit>()V",
                                    "method_body": "static final int SIGNATURE_HEADER_SIZE = 32;\nprivate int currentEntryIndex = -1;\nprivate int currentFolderIndex = -1;\nprivate InputStream currentFolderInputStream = null;\nprivate InputStream currentEntryInputStream = null;\nstatic final byte[] sevenZSignature = {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeaders([B)Lorg/apache/commons/compress/archivers/sevenz/Archive;",
                                    "method_body": "private Archive readHeaders(byte[] password) throws IOException {\nfinal byte[] signature = new byte[6];\nfile.readFully(signature);\nif (!Arrays.equals(signature, sevenZSignature)) {\nfinal byte archiveVersionMajor = file.readByte();\nfinal byte archiveVersionMinor = file.readByte();\nif (archiveVersionMajor != 0) {\nfinal long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\nfinal StartHeader startHeader = readStartHeader(startHeaderCrc);\nfinal int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\nif (nextHeaderSizeInt != startHeader.nextHeaderSize) {\nfile.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\nfinal byte[] nextHeader = new byte[nextHeaderSizeInt];\nfile.readFully(nextHeader);\nfinal CRC32 crc = new CRC32();\ncrc.update(nextHeader);\nif (startHeader.nextHeaderCrc != crc.getValue()) {\nfinal ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\nDataInputStream nextHeaderInputStream = new DataInputStream(\nArchive archive = new Archive();\nint nid = nextHeaderInputStream.readUnsignedByte();\nif (nid == NID.kEncodedHeader) {\nif (nid == NID.kHeader) {\nreadHeader(nextHeaderInputStream, archive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStartHeader(J)Lorg/apache/commons/compress/archivers/sevenz/StartHeader;",
                                    "method_body": "private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\nfinal StartHeader startHeader = new StartHeader();\nDataInputStream dataInputStream = null;\ndataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\nstartHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\nreturn startHeader;\nif (dataInputStream != null) {\ndataInputStream.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\nif (nid == NID.kPackInfo) {\nreadPackInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid == NID.kUnpackInfo) {\nreadUnpackInfo(header, archive);\nnid = header.readUnsignedByte();\narchive.folders = new Folder[0];\nif (nid == NID.kSubStreamsInfo) {\nreadSubStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid != NID.kEnd) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readSubStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nfor (final Folder folder : archive.folders) {\nfolder.numUnpackSubStreams = 1;\nint totalUnpackStreams = archive.folders.length;\nint nid = header.readUnsignedByte();\nif (nid == NID.kNumUnpackStream) {\nfinal SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\nsubStreamsInfo.unpackSizes = new long[totalUnpackStreams];\nsubStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\nsubStreamsInfo.crcs = new long[totalUnpackStreams];\nint nextUnpackStream = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams == 0) {\nlong sum = 0;\nif (nid == NID.kSize) {\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;\nif (nid == NID.kSize) {\nint numDigests = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {\nif (nid == NID.kCRC) {\nif (nid != NID.kEnd) {\narchive.subStreamsInfo = subStreamsInfo;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readBits(final DataInput header, final int size) throws IOException {\nfinal BitSet bits = new BitSet(size);\nint mask = 0;\nint cache = 0;\nfor (int i = 0; i < size; i++) {\nif (mask == 0) {\nmask = 0x80;\ncache = header.readUnsignedByte();\nbits.set(i, (cache & mask) != 0);\nmask >>>= 1;\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFilesInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readFilesInfo(final DataInput header, final Archive archive) throws IOException {\nfinal long numFiles = readUint64(header);\nfinal SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\nfor (int i = 0; i < files.length; i++) {\nfiles[i] = new SevenZArchiveEntry();\nBitSet isEmptyStream = null;\nBitSet isEmptyFile = null;\nBitSet isAnti = null;\nfinal int propertyType = header.readUnsignedByte();\nif (propertyType == 0) {\nbreak;\nlong size = readUint64(header);\nswitch (propertyType) {\nisEmptyStream = readBits(header, files.length);\nbreak;\nif (isEmptyStream == null) { // protect against NPE\nisEmptyFile = readBits(header, isEmptyStream.cardinality());\nbreak;\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nif (((size - 1) & 1) != 0) {\nfinal byte[] names = new byte[(int)(size - 1)];\nheader.readFully(names);\nint nextFile = 0;\nint nextName = 0;\nfor (int i = 0; i < names.length; i += 2) {\nif (names[i] == 0 && names[i+1] == 0) {\nfiles[nextFile++].setName(new String(names, nextName, i-nextName, CharsetNames.UTF_16LE));\nnextName = i + 2;\nif (nextName != names.length || nextFile != files.length) {\nbreak;\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasLastModifiedDate(timesDefined.get(i));\nif (files[i].getHasLastModifiedDate()) {\nfiles[i].setLastModifiedDate(Long.reverseBytes(header.readLong()));\nbreak;\nthrow new IOException(\"Unknown property \" + propertyType);\n}\nint nonEmptyFileCounter = 0;\nint emptyFileCounter = 0;\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasStream((isEmptyStream == null) ? true : !isEmptyStream.get(i));\nif (files[i].hasStream()) {\nfiles[i].setDirectory(false);\nfiles[i].setAntiItem(false);\nfiles[i].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nfiles[i].setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nfiles[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\nfiles[i].setDirectory((isEmptyFile == null) ? true : !isEmptyFile.get(emptyFileCounter));\nfiles[i].setAntiItem((isAnti == null) ? false : isAnti.get(emptyFileCounter));\nfiles[i].setHasCrc(false);\nfiles[i].setSize(0);\n++emptyFileCounter;\narchive.files = files;\ncalculateStreamMap(archive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUint64(Ljava/io/DataInput;)J",
                                    "method_body": "private static long readUint64(final DataInput in) throws IOException {\nlong firstByte = in.readUnsignedByte();\nint mask = 0x80;\nlong value = 0;\nfor (int i = 0; i < 8; i++) {\nif ((firstByte & mask) == 0) {\nreturn value | ((firstByte & (mask - 1)) << (8 * i));\nlong nextByte = in.readUnsignedByte();\nvalue |= (nextByte << (8 * i));\nmask >>>= 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;JJ)V",
                                    "method_body": "public ChecksumVerifyingInputStream(final Checksum checksum, final InputStream in,\nfinal long size, final long expectedChecksum) {\nthis.checksum = checksum;\nthis.in = in;\nthis.expectedChecksum = expectedChecksum;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining <= 0) {\nint ret = in.read();\nif (ret >= 0) {\nchecksum.update(ret);\n--bytesRemaining;\nif (bytesRemaining == 0 && expectedChecksum != checksum.getValue()) {\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nint ret = in.read(b, off, len);\nif (ret >= 0) {\nchecksum.update(b, off, ret);\nbytesRemaining -= ret;\nif (bytesRemaining <= 0 && expectedChecksum != checksum.getValue()) {\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nin.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CRC32VerifyingInputStream:<init>(Ljava/io/InputStream;JJ)V",
                                    "method_body": "public CRC32VerifyingInputStream(final InputStream in, final long size, final long expectedCrc32) {\nsuper(new CRC32(), in, size, expectedCrc32);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:<init>(Ljava/io/RandomAccessFile;J)V",
                                    "method_body": "public BoundedRandomAccessFileInputStream(final RandomAccessFile file,\nfinal long size) {\nthis.file = file;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining > 0) {\n--bytesRemaining;\nreturn file.read();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif (bytesRemaining == 0) {\nint bytesToRead = len;\nif (bytesToRead > bytesRemaining) {\nfinal int bytesRead = file.read(b, off, bytesToRead);\nif (bytesRead >= 0) {\nbytesRemaining -= bytesRead;\nreturn bytesRead;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:close()V",
                                    "method_body": "public void close() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getCrcValue()J",
                                    "method_body": "public long getCrcValue() {\nreturn crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCrcValue(J)V",
                                    "method_body": "public void setCrcValue(long crc) {\nthis.crc = crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getCompressedCrcValue()J",
                                    "method_body": "long getCompressedCrcValue() {\nreturn compressedCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCompressedCrcValue(J)V",
                                    "method_body": "void setCompressedCrcValue(long crc) {\nthis.compressedCrc = crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getCompressedSize()J",
                                    "method_body": "long getCompressedSize() {\nreturn compressedSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:getCurrentOutputStream()Ljava/io/OutputStream;",
                                    "method_body": "private OutputStream getCurrentOutputStream() throws IOException {\nif (currentOutputStream == null) {\ncurrentOutputStream = setupFileOutputStream();\nreturn currentOutputStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:setupFileOutputStream()Lorg/apache/commons/compress/utils/CountingOutputStream;",
                                    "method_body": "private CountingOutputStream setupFileOutputStream() throws IOException {\nOutputStream out = new OutputStreamWrapper();\nreturn new CountingOutputStream(Coders\nsuper.write(b, off, len);\ncrc32.update(b, off, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writePackInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writePackInfo(final DataOutput header) throws IOException {\nheader.write(NID.kPackInfo);\nwriteUint64(header, 0);\nwriteUint64(header, 0xffffFFFFL & numNonEmptyStreams);\nheader.write(NID.kSize);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nwriteUint64(header, entry.getCompressedSize());\n}\nheader.write(NID.kCRC);\nheader.write(1);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nheader.writeInt(Integer.reverseBytes((int) entry.getCompressedCrcValue()));\n}\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeUnpackInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeUnpackInfo(final DataOutput header) throws IOException {\nheader.write(NID.kUnpackInfo);\nheader.write(NID.kFolder);\nwriteUint64(header, numNonEmptyStreams);\nheader.write(0);\nfor (int i = 0; i < numNonEmptyStreams; i++) {\nwriteFolder(header);\nheader.write(NID.kCodersUnpackSize);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nwriteUint64(header, entry.getSize());\n}\nheader.write(NID.kCRC);\nheader.write(1);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nheader.writeInt(Integer.reverseBytes((int) entry.getCrcValue()));\n}\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFolder(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFolder(final DataOutput header) throws IOException {\nwriteUint64(header, 1);\nbyte[] id = contentCompression.getId();\nbyte[] properties = contentCompression.getProperties();\nint codecFlags = id.length;\nif (properties.length > 0) {\ncodecFlags |= 0x20;\nheader.write(codecFlags);\nheader.write(id);\nif (properties.length > 0) {\nheader.write(properties.length);\nheader.write(properties);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:getId()[B",
                                    "method_body": "byte[] getId() {\nbyte[] copy = new byte[id.length];\nSystem.arraycopy(id, 0, copy, 0, id.length);\nreturn copy;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod$1:getProperties()[B",
                                    "method_body": "byte[] getProperties() {\nint dictSize = LZMA2Options.DICT_SIZE_DEFAULT;\nint lead = Integer.numberOfLeadingZeros(dictSize);\nint secondBit = (dictSize >>> (30 - lead)) - 2;\nreturn new byte[] {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readPackInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readPackInfo(final DataInput header, final Archive archive) throws IOException {\narchive.packPos = readUint64(header);\nfinal long numPackStreams = readUint64(header);\nint nid = header.readUnsignedByte();\nif (nid == NID.kSize) {\narchive.packSizes = new long[(int)numPackStreams];\nfor (int i = 0; i < archive.packSizes.length; i++) {\narchive.packSizes[i] = readUint64(header);\nnid = header.readUnsignedByte();\nif (nid == NID.kCRC) {\narchive.packCrcsDefined = readAllOrBits(header, (int)numPackStreams);\narchive.packCrcs = new long[(int)numPackStreams];\nfor (int i = 0; i < (int)numPackStreams; i++) {\nif (archive.packCrcsDefined.get(i)) {\narchive.packCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\nnid = header.readUnsignedByte();\nif (nid != NID.kEnd) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUnpackInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readUnpackInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\nif (nid != NID.kFolder) {\nfinal long numFolders = readUint64(header);\nfinal Folder[] folders = new Folder[(int)numFolders];\narchive.folders = folders;\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nfor (int i = 0; i < (int)numFolders; i++) {\nfolders[i] = readFolder(header);\nnid = header.readUnsignedByte();\nif (nid != NID.kCodersUnpackSize) {\nfor (final Folder folder : folders) {\nfolder.unpackSizes = new long[(int)folder.totalOutputStreams];\nfor (int i = 0; i < folder.totalOutputStreams; i++) {\nfolder.unpackSizes[i] = readUint64(header);\nnid = header.readUnsignedByte();\nif (nid == NID.kCRC) {\nfinal BitSet crcsDefined = readAllOrBits(header, (int)numFolders);\nfor (int i = 0; i < (int)numFolders; i++) {\nif (crcsDefined.get(i)) {\nfolders[i].hasCrc = true;\nfolders[i].crc = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\nnid = header.readUnsignedByte();\nif (nid != NID.kEnd) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFolder(Ljava/io/DataInput;)Lorg/apache/commons/compress/archivers/sevenz/Folder;",
                                    "method_body": "private Folder readFolder(final DataInput header) throws IOException {\nfinal Folder folder = new Folder();\nfinal long numCoders = readUint64(header);\nfinal Coder[] coders = new Coder[(int)numCoders];\nlong totalInStreams = 0;\nlong totalOutStreams = 0;\nfor (int i = 0; i < coders.length; i++) {\ncoders[i] = new Coder();\nint bits = header.readUnsignedByte();\nfinal int idSize = bits & 0xf;\nfinal boolean isSimple = ((bits & 0x10) == 0);\nfinal boolean hasAttributes = ((bits & 0x20) != 0);\nfinal boolean moreAlternativeMethods = ((bits & 0x80) != 0);\ncoders[i].decompressionMethodId = new byte[idSize];\nheader.readFully(coders[i].decompressionMethodId);\nif (isSimple) {\ncoders[i].numInStreams = 1;\ncoders[i].numOutStreams = 1;\ntotalInStreams += coders[i].numInStreams;\ntotalOutStreams += coders[i].numOutStreams;\nif (hasAttributes) {\nfinal long propertiesSize = readUint64(header);\ncoders[i].properties = new byte[(int)propertiesSize];\nheader.readFully(coders[i].properties);\nwhile (moreAlternativeMethods) {\nfolder.coders = coders;\nfolder.totalInputStreams = totalInStreams;\nfolder.totalOutputStreams = totalOutStreams;\nif (totalOutStreams == 0) {\nfinal long numBindPairs = totalOutStreams - 1;\nfinal BindPair[] bindPairs = new BindPair[(int)numBindPairs];\nfor (int i = 0; i < bindPairs.length; i++) {\nfolder.bindPairs = bindPairs;\nif (totalInStreams < numBindPairs) {\nfinal long numPackedStreams = totalInStreams - numBindPairs;\nfinal long packedStreams[] = new long[(int)numPackedStreams];\nif (numPackedStreams == 1) {\nfor (i = 0; i < (int)totalInStreams; i++) {\nif (folder.findBindPairForInStream(i) < 0) {\nbreak;\nif (i == (int)totalInStreams) {\npackedStreams[0] = i;\n} else {\nfolder.packedStreams = packedStreams;\nreturn folder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readAllOrBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readAllOrBits(final DataInput header, final int size) throws IOException {\nfinal int areAllDefined = header.readUnsignedByte();\nif (areAllDefined != 0) {\nbits = new BitSet(size);\nfor (int i = 0; i < size; i++) {\nbits.set(i, true);\nbits = readBits(header, size);\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:write(I)V",
                                    "method_body": "public void write(final int b) throws IOException {\nfile.write(b);\ncompressedCrc32.update(b);\nfileBytesWritten++;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int off, final int len)\nfile.write(b, off, len);\ncompressedCrc32.update(b, off, len);\nfileBytesWritten += len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:flush()V",
                                    "method_body": "public void flush() throws IOException {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:close()V",
                                    "method_body": "public void close() throws IOException {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public CountingOutputStream(final OutputStream out) {\nsuper(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int off, int len) throws IOException {\nout.write(b, off, len);\ncount(len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:count(J)V",
                                    "method_body": "protected void count(long written) {\nif (written != -1) {\nbytesWritten += written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:getBytesWritten()J",
                                    "method_body": "public long getBytesWritten() {\nreturn bytesWritten;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$1:write([BII)V",
                                    "method_body": "private CountingOutputStream setupFileOutputStream() throws IOException {\nOutputStream out = new OutputStreamWrapper();\nreturn new CountingOutputStream(Coders\nsuper.write(b, off, len);\ncrc32.update(b, off, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders:<clinit>()V",
                                    "method_body": "static CoderId[] coderTable = new CoderId[] {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders:addEncoder(Ljava/io/OutputStream;Lorg/apache/commons/compress/archivers/sevenz/SevenZMethod;[B)Ljava/io/OutputStream;",
                                    "method_body": "static OutputStream addEncoder(final OutputStream out, final SevenZMethod method,\nfor (final CoderId coderId : coderTable) {\nif (coderId.method.equals(method)) {\nreturn coderId.coder.encode(out, password);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$CoderId:<init>(Lorg/apache/commons/compress/archivers/sevenz/SevenZMethod;Lorg/apache/commons/compress/archivers/sevenz/Coders$CoderBase;)V",
                                    "method_body": "CoderId(SevenZMethod method, final CoderBase coder) {\nthis.method = method;\nthis.coder = coder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$CoderBase:<init>()V",
                                    "method_body": "final SevenZMethod method;\nstatic abstract class CoderBase {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.LZMA2Decoder:encode(Ljava/io/OutputStream;[B)Ljava/io/OutputStream;",
                                    "method_body": "OutputStream encode(final OutputStream out, final byte[] password)\nLZMA2Options options = new LZMA2Options();\noptions.setDictSize(LZMA2Options.DICT_SIZE_DEFAULT);\nFinishableOutputStream wrapped = new FinishableWrapperOutputStream(out);\nreturn options.getOutputStream(wrapped);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:findBindPairForInStream(I)I",
                                    "method_body": "int findBindPairForInStream(final int index) {\nfor (int i = 0; i < bindPairs.length; i++) {\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:findBindPairForOutStream(I)I",
                                    "method_body": "int findBindPairForOutStream(final int index) {\nfor (int i = 0; i < bindPairs.length; i++) {\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:getUnpackSize()J",
                                    "method_body": "long getUnpackSize() {\nif (totalOutputStreams == 0) {\nfor (int i = ((int)totalOutputStreams) - 1; i >= 0; i--) {\nif (findBindPairForOutStream(i) < 0) {\nreturn unpackSizes[i];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coder:<init>()V",
                                    "method_body": "byte[] decompressionMethodId;\nbyte[] properties = null;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest.testSevenEmptyFiles",
                            "test_body": "182: public void testSevenEmptyFiles() throws Exception {\n183: testCompress252(7, 0);\n184: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:<init>()V",
                                    "method_body": "public SevenZArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "public void setName(String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:hasStream()Z",
                                    "method_body": "public boolean hasStream() {\nreturn hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasStream(Z)V",
                                    "method_body": "public void setHasStream(boolean hasStream) {\nthis.hasStream = hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nreturn isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setDirectory(Z)V",
                                    "method_body": "public void setDirectory(boolean isDirectory) {\nthis.isDirectory = isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isAntiItem()Z",
                                    "method_body": "public boolean isAntiItem() {\nreturn isAntiItem;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasCreationDate()Z",
                                    "method_body": "public boolean getHasCreationDate() {\nreturn hasCreationDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasLastModifiedDate()Z",
                                    "method_body": "public boolean getHasLastModifiedDate() {\nreturn hasLastModifiedDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getLastModifiedDate()Ljava/util/Date;",
                                    "method_body": "public Date getLastModifiedDate() {\nif (hasLastModifiedDate) {\nreturn ntfsTimeToJavaTime(lastModifiedDate);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setLastModifiedDate(Ljava/util/Date;)V",
                                    "method_body": "public void setLastModifiedDate(Date lastModifiedDate) {\nhasLastModifiedDate = lastModifiedDate != null;\nif (hasLastModifiedDate) {\nthis.lastModifiedDate = javaTimeToNtfsTime(lastModifiedDate);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasAccessDate()Z",
                                    "method_body": "public boolean getHasAccessDate() {\nreturn hasAccessDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasWindowsAttributes()Z",
                                    "method_body": "public boolean getHasWindowsAttributes() {\nreturn hasWindowsAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasCrc(Z)V",
                                    "method_body": "public void setHasCrc(boolean hasCrc) {\nthis.hasCrc = hasCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCompressedSize(J)V",
                                    "method_body": "void setCompressedSize(long size) {\nthis.compressedSize = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:ntfsTimeToJavaTime(J)Ljava/util/Date;",
                                    "method_body": "public static Date ntfsTimeToJavaTime(final long ntfsTime) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nfinal long realTime = ntfsEpoch.getTimeInMillis() + (ntfsTime / (10*1000));\nreturn new Date(realTime);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:javaTimeToNtfsTime(Ljava/util/Date;)J",
                                    "method_body": "public static long javaTimeToNtfsTime(final Date date) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nreturn ((date.getTime() - ntfsEpoch.getTimeInMillis())* 1000 * 10);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:<init>(Ljava/io/File;)V",
                                    "method_body": "private final RandomAccessFile file;\nprivate final List<SevenZArchiveEntry> files = new ArrayList<SevenZArchiveEntry>();\nprivate int numNonEmptyStreams = 0;\nprivate CRC32 crc32 = new CRC32();\nprivate CRC32 compressedCrc32 = new CRC32();\nprivate long fileBytesWritten = 0;\nprivate boolean finished = false;\nprivate SevenZMethod contentCompression = SevenZMethod.LZMA2;\npublic SevenZOutputFile(final File filename) throws IOException {\nfile = new RandomAccessFile(filename, \"rw\");\nfile.seek(SevenZFile.SIGNATURE_HEADER_SIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!finished) {\nfinish();\nfile.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:createArchiveEntry(Ljava/io/File;Ljava/lang/String;)Lorg/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry;",
                                    "method_body": "public SevenZArchiveEntry createArchiveEntry(final File inputFile,\nfinal SevenZArchiveEntry entry = new SevenZArchiveEntry();\nentry.setDirectory(inputFile.isDirectory());\nentry.setName(entryName);\nentry.setLastModifiedDate(new Date(inputFile.lastModified()));\nreturn entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\nfinal SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;\nfiles.add(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (currentOutputStream != null) {\ncurrentOutputStream.flush();\ncurrentOutputStream.close();\nfinal SevenZArchiveEntry entry = files.get(files.size() - 1);\nif (fileBytesWritten > 0) {\nentry.setHasStream(true);\n++numNonEmptyStreams;\nentry.setSize(currentOutputStream.getBytesWritten());\nentry.setCompressedSize(fileBytesWritten);\nentry.setCrcValue(crc32.getValue());\nentry.setCompressedCrcValue(compressedCrc32.getValue());\nentry.setHasCrc(true);\nentry.setHasStream(false);\nentry.setSize(0);\nentry.setCompressedSize(0);\nentry.setHasCrc(false);\ncurrentOutputStream = null;\ncrc32.reset();\ncompressedCrc32.reset();\nfileBytesWritten = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([B)V",
                                    "method_body": "public void write(final byte[] b) throws IOException {\nwrite(b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int off, final int len) throws IOException {\nif (len > 0) {\ngetCurrentOutputStream().write(b, off, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif (finished) {\nfinished = true;\nfinal long headerPosition = file.getFilePointer();\nfinal ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();\nfinal DataOutputStream header = new DataOutputStream(headerBaos);\nwriteHeader(header);\nheader.flush();\nfinal byte[] headerBytes = headerBaos.toByteArray();\nfile.write(headerBytes);\nfinal CRC32 crc32 = new CRC32();\nfile.seek(0);\nfile.write(SevenZFile.sevenZSignature);\nfile.write(0);\nfile.write(2);\nfinal ByteArrayOutputStream startHeaderBaos = new ByteArrayOutputStream();\nfinal DataOutputStream startHeaderStream = new DataOutputStream(startHeaderBaos);\nstartHeaderStream.writeLong(Long.reverseBytes(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE));\nstartHeaderStream.writeLong(Long.reverseBytes(0xffffFFFFL & headerBytes.length));\ncrc32.reset();\ncrc32.update(headerBytes);\nstartHeaderStream.writeInt(Integer.reverseBytes((int)crc32.getValue()));\nstartHeaderStream.flush();\nfinal byte[] startHeaderBytes = startHeaderBaos.toByteArray();\ncrc32.reset();\ncrc32.update(startHeaderBytes);\nfile.writeInt(Integer.reverseBytes((int) crc32.getValue()));\nfile.write(startHeaderBytes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeHeader(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeHeader(final DataOutput header) throws IOException {\nheader.write(NID.kHeader);\nheader.write(NID.kMainStreamsInfo);\nwriteStreamsInfo(header);\nwriteFilesInfo(header);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeStreamsInfo(final DataOutput header) throws IOException {\nif (numNonEmptyStreams > 0) {\nwritePackInfo(header);\nwriteUnpackInfo(header);\nwriteSubStreamsInfo(header);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeSubStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeSubStreamsInfo(final DataOutput header) throws IOException {\nheader.write(NID.kSubStreamsInfo);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFilesInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFilesInfo(final DataOutput header) throws IOException {\nheader.write(NID.kFilesInfo);\nwriteUint64(header, files.size());\nwriteFileEmptyStreams(header);\nwriteFileEmptyFiles(header);\nwriteFileAntiItems(header);\nwriteFileNames(header);\nwriteFileCTimes(header);\nwriteFileATimes(header);\nwriteFileMTimes(header);\nwriteFileWindowsAttributes(header);\nheader.write(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyStreams(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyStreams(final DataOutput header) throws IOException {\nboolean hasEmptyStreams = false;\nfor (final SevenZArchiveEntry entry : files) {\nif (!entry.hasStream()) {\nhasEmptyStreams = true;\nbreak;\nif (hasEmptyStreams) {\nheader.write(NID.kEmptyStream);\nfinal BitSet emptyStreams = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nemptyStreams.set(i, !files.get(i).hasStream());\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyStreams, files.size());\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyFiles(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyFiles(final DataOutput header) throws IOException {\nboolean hasEmptyFiles = false;\nint emptyStreamCounter = 0;\nfinal BitSet emptyFiles = new BitSet(0);\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isDir = files.get(i).isDirectory();\nemptyFiles.set(emptyStreamCounter++, !isDir);\nhasEmptyFiles |= !isDir;\nif (hasEmptyFiles) {\nheader.write(NID.kEmptyFile);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyFiles, emptyStreamCounter);\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileAntiItems(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileAntiItems(final DataOutput header) throws IOException {\nboolean hasAntiItems = false;\nfinal BitSet antiItems = new BitSet(0);\nint antiItemCounter = 0;\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isAnti = files.get(i).isAntiItem();\nantiItems.set(antiItemCounter++, isAnti);\nhasAntiItems |= isAnti;\nif (hasAntiItems) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileNames(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileNames(final DataOutput header) throws IOException {\nheader.write(NID.kName);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nout.write(entry.getName().getBytes(\"UTF-16LE\"));\nout.writeShort(0);\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileCTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileCTimes(final DataOutput header) throws IOException {\nint numCreationDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasCreationDate()) {\n}\nif (numCreationDates > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileATimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileATimes(final DataOutput header) throws IOException {\nint numAccessDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasAccessDate()) {\n}\nif (numAccessDates > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileMTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileMTimes(final DataOutput header) throws IOException {\nint numLastModifiedDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\n++numLastModifiedDates;\n}\nif (numLastModifiedDates > 0) {\nheader.write(NID.kMTime);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numLastModifiedDates != files.size()) {\nout.write(0);\nfinal BitSet mTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nmTimes.set(i, files.get(i).getHasLastModifiedDate());\nwriteBits(out, mTimes, files.size());\n} else {\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\nout.writeLong(Long.reverseBytes(\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileWindowsAttributes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileWindowsAttributes(final DataOutput header) throws IOException {\nint numWindowsAttributes = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasWindowsAttributes()) {\n}\nif (numWindowsAttributes > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeUint64(Ljava/io/DataOutput;J)V",
                                    "method_body": "private void writeUint64(final DataOutput header, long value) throws IOException {\nint firstByte = 0;\nint mask = 0x80;\nfor (i = 0; i < 8; i++) {\nif (value < ((1L << ( 7  * (i + 1))))) {\nfirstByte |= (value >>> (8 * i));\nbreak;\nfirstByte |= mask;\nmask >>>= 1;\nheader.write(firstByte);\nfor (; i > 0; i--) {\nheader.write((int) (0xff & value));\nvalue >>>= 8;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeBits(Ljava/io/DataOutput;Ljava/util/BitSet;I)V",
                                    "method_body": "private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\nint cache = 0;\nint shift = 7;\nfor (int i = 0; i < length; i++) {\ncache |= ((bits.get(i) ? 1 : 0) << shift);\n--shift;\nif (shift == 0) {\nheader.write(cache);\nshift = 7;\ncache = 0;\nif (length > 0 && shift > 0) {\nheader.write(cache);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:<init>(Ljava/lang/String;I[B)V",
                                    "method_body": "private SevenZMethod(byte[] id) {\nthis.id = id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;[B)V",
                                    "method_body": "public SevenZFile(final File filename, final byte[] password) throws IOException {\nboolean succeeded = false;\nthis.file = new RandomAccessFile(filename, \"r\");\narchive = readHeaders(password);\nif (!succeeded) {\nthis.file.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZFile(final File filename) throws IOException {\nthis(filename, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<clinit>()V",
                                    "method_body": "static final int SIGNATURE_HEADER_SIZE = 32;\nprivate int currentEntryIndex = -1;\nprivate int currentFolderIndex = -1;\nprivate InputStream currentFolderInputStream = null;\nprivate InputStream currentEntryInputStream = null;\nstatic final byte[] sevenZSignature = {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeaders([B)Lorg/apache/commons/compress/archivers/sevenz/Archive;",
                                    "method_body": "private Archive readHeaders(byte[] password) throws IOException {\nfinal byte[] signature = new byte[6];\nfile.readFully(signature);\nif (!Arrays.equals(signature, sevenZSignature)) {\nfinal byte archiveVersionMajor = file.readByte();\nfinal byte archiveVersionMinor = file.readByte();\nif (archiveVersionMajor != 0) {\nfinal long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\nfinal StartHeader startHeader = readStartHeader(startHeaderCrc);\nfinal int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\nif (nextHeaderSizeInt != startHeader.nextHeaderSize) {\nfile.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\nfinal byte[] nextHeader = new byte[nextHeaderSizeInt];\nfile.readFully(nextHeader);\nfinal CRC32 crc = new CRC32();\ncrc.update(nextHeader);\nif (startHeader.nextHeaderCrc != crc.getValue()) {\nfinal ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\nDataInputStream nextHeaderInputStream = new DataInputStream(\nArchive archive = new Archive();\nint nid = nextHeaderInputStream.readUnsignedByte();\nif (nid == NID.kEncodedHeader) {\nif (nid == NID.kHeader) {\nreadHeader(nextHeaderInputStream, archive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStartHeader(J)Lorg/apache/commons/compress/archivers/sevenz/StartHeader;",
                                    "method_body": "private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\nfinal StartHeader startHeader = new StartHeader();\nDataInputStream dataInputStream = null;\ndataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\nstartHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\nreturn startHeader;\nif (dataInputStream != null) {\ndataInputStream.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\nif (nid == NID.kPackInfo) {\nreadPackInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid == NID.kUnpackInfo) {\nreadUnpackInfo(header, archive);\nnid = header.readUnsignedByte();\narchive.folders = new Folder[0];\nif (nid == NID.kSubStreamsInfo) {\nreadSubStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid != NID.kEnd) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readSubStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nfor (final Folder folder : archive.folders) {\nfolder.numUnpackSubStreams = 1;\nint totalUnpackStreams = archive.folders.length;\nint nid = header.readUnsignedByte();\nif (nid == NID.kNumUnpackStream) {\nfinal SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\nsubStreamsInfo.unpackSizes = new long[totalUnpackStreams];\nsubStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\nsubStreamsInfo.crcs = new long[totalUnpackStreams];\nint nextUnpackStream = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams == 0) {\nlong sum = 0;\nif (nid == NID.kSize) {\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;\nif (nid == NID.kSize) {\nint numDigests = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {\nif (nid == NID.kCRC) {\nif (nid != NID.kEnd) {\narchive.subStreamsInfo = subStreamsInfo;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readBits(final DataInput header, final int size) throws IOException {\nfinal BitSet bits = new BitSet(size);\nint mask = 0;\nint cache = 0;\nfor (int i = 0; i < size; i++) {\nif (mask == 0) {\nmask = 0x80;\ncache = header.readUnsignedByte();\nbits.set(i, (cache & mask) != 0);\nmask >>>= 1;\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFilesInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readFilesInfo(final DataInput header, final Archive archive) throws IOException {\nfinal long numFiles = readUint64(header);\nfinal SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\nfor (int i = 0; i < files.length; i++) {\nfiles[i] = new SevenZArchiveEntry();\nBitSet isEmptyStream = null;\nBitSet isEmptyFile = null;\nBitSet isAnti = null;\nfinal int propertyType = header.readUnsignedByte();\nif (propertyType == 0) {\nbreak;\nlong size = readUint64(header);\nswitch (propertyType) {\nisEmptyStream = readBits(header, files.length);\nbreak;\nif (isEmptyStream == null) { // protect against NPE\nisEmptyFile = readBits(header, isEmptyStream.cardinality());\nbreak;\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nif (((size - 1) & 1) != 0) {\nfinal byte[] names = new byte[(int)(size - 1)];\nheader.readFully(names);\nint nextFile = 0;\nint nextName = 0;\nfor (int i = 0; i < names.length; i += 2) {\nif (names[i] == 0 && names[i+1] == 0) {\nfiles[nextFile++].setName(new String(names, nextName, i-nextName, CharsetNames.UTF_16LE));\nnextName = i + 2;\nif (nextName != names.length || nextFile != files.length) {\nbreak;\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasLastModifiedDate(timesDefined.get(i));\nif (files[i].getHasLastModifiedDate()) {\nfiles[i].setLastModifiedDate(Long.reverseBytes(header.readLong()));\nbreak;\nthrow new IOException(\"Unknown property \" + propertyType);\n}\nint nonEmptyFileCounter = 0;\nint emptyFileCounter = 0;\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasStream((isEmptyStream == null) ? true : !isEmptyStream.get(i));\nif (files[i].hasStream()) {\nfiles[i].setDirectory(false);\nfiles[i].setAntiItem(false);\nfiles[i].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nfiles[i].setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nfiles[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\nfiles[i].setDirectory((isEmptyFile == null) ? true : !isEmptyFile.get(emptyFileCounter));\nfiles[i].setAntiItem((isAnti == null) ? false : isAnti.get(emptyFileCounter));\nfiles[i].setHasCrc(false);\nfiles[i].setSize(0);\n++emptyFileCounter;\narchive.files = files;\ncalculateStreamMap(archive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUint64(Ljava/io/DataInput;)J",
                                    "method_body": "private static long readUint64(final DataInput in) throws IOException {\nlong firstByte = in.readUnsignedByte();\nint mask = 0x80;\nlong value = 0;\nfor (int i = 0; i < 8; i++) {\nif ((firstByte & mask) == 0) {\nreturn value | ((firstByte & (mask - 1)) << (8 * i));\nlong nextByte = in.readUnsignedByte();\nvalue |= (nextByte << (8 * i));\nmask >>>= 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;JJ)V",
                                    "method_body": "public ChecksumVerifyingInputStream(final Checksum checksum, final InputStream in,\nfinal long size, final long expectedChecksum) {\nthis.checksum = checksum;\nthis.in = in;\nthis.expectedChecksum = expectedChecksum;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining <= 0) {\nint ret = in.read();\nif (ret >= 0) {\nchecksum.update(ret);\n--bytesRemaining;\nif (bytesRemaining == 0 && expectedChecksum != checksum.getValue()) {\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nint ret = in.read(b, off, len);\nif (ret >= 0) {\nchecksum.update(b, off, ret);\nbytesRemaining -= ret;\nif (bytesRemaining <= 0 && expectedChecksum != checksum.getValue()) {\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nin.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CRC32VerifyingInputStream:<init>(Ljava/io/InputStream;JJ)V",
                                    "method_body": "public CRC32VerifyingInputStream(final InputStream in, final long size, final long expectedCrc32) {\nsuper(new CRC32(), in, size, expectedCrc32);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:<init>(Ljava/io/RandomAccessFile;J)V",
                                    "method_body": "public BoundedRandomAccessFileInputStream(final RandomAccessFile file,\nfinal long size) {\nthis.file = file;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining > 0) {\n--bytesRemaining;\nreturn file.read();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif (bytesRemaining == 0) {\nint bytesToRead = len;\nif (bytesToRead > bytesRemaining) {\nfinal int bytesRead = file.read(b, off, bytesToRead);\nif (bytesRead >= 0) {\nbytesRemaining -= bytesRead;\nreturn bytesRead;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:close()V",
                                    "method_body": "public void close() {\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest.testSixEmptyFiles",
                            "test_body": "174: public void testSixEmptyFiles() throws Exception {\n175: testCompress252(6, 0);\n176: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:<init>()V",
                                    "method_body": "public SevenZArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "public void setName(String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:hasStream()Z",
                                    "method_body": "public boolean hasStream() {\nreturn hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasStream(Z)V",
                                    "method_body": "public void setHasStream(boolean hasStream) {\nthis.hasStream = hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nreturn isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setDirectory(Z)V",
                                    "method_body": "public void setDirectory(boolean isDirectory) {\nthis.isDirectory = isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isAntiItem()Z",
                                    "method_body": "public boolean isAntiItem() {\nreturn isAntiItem;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasCreationDate()Z",
                                    "method_body": "public boolean getHasCreationDate() {\nreturn hasCreationDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasLastModifiedDate()Z",
                                    "method_body": "public boolean getHasLastModifiedDate() {\nreturn hasLastModifiedDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getLastModifiedDate()Ljava/util/Date;",
                                    "method_body": "public Date getLastModifiedDate() {\nif (hasLastModifiedDate) {\nreturn ntfsTimeToJavaTime(lastModifiedDate);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setLastModifiedDate(Ljava/util/Date;)V",
                                    "method_body": "public void setLastModifiedDate(Date lastModifiedDate) {\nhasLastModifiedDate = lastModifiedDate != null;\nif (hasLastModifiedDate) {\nthis.lastModifiedDate = javaTimeToNtfsTime(lastModifiedDate);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasAccessDate()Z",
                                    "method_body": "public boolean getHasAccessDate() {\nreturn hasAccessDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasWindowsAttributes()Z",
                                    "method_body": "public boolean getHasWindowsAttributes() {\nreturn hasWindowsAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasCrc(Z)V",
                                    "method_body": "public void setHasCrc(boolean hasCrc) {\nthis.hasCrc = hasCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCompressedSize(J)V",
                                    "method_body": "void setCompressedSize(long size) {\nthis.compressedSize = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:ntfsTimeToJavaTime(J)Ljava/util/Date;",
                                    "method_body": "public static Date ntfsTimeToJavaTime(final long ntfsTime) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nfinal long realTime = ntfsEpoch.getTimeInMillis() + (ntfsTime / (10*1000));\nreturn new Date(realTime);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:javaTimeToNtfsTime(Ljava/util/Date;)J",
                                    "method_body": "public static long javaTimeToNtfsTime(final Date date) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nreturn ((date.getTime() - ntfsEpoch.getTimeInMillis())* 1000 * 10);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:<init>(Ljava/io/File;)V",
                                    "method_body": "private final RandomAccessFile file;\nprivate final List<SevenZArchiveEntry> files = new ArrayList<SevenZArchiveEntry>();\nprivate int numNonEmptyStreams = 0;\nprivate CRC32 crc32 = new CRC32();\nprivate CRC32 compressedCrc32 = new CRC32();\nprivate long fileBytesWritten = 0;\nprivate boolean finished = false;\nprivate SevenZMethod contentCompression = SevenZMethod.LZMA2;\npublic SevenZOutputFile(final File filename) throws IOException {\nfile = new RandomAccessFile(filename, \"rw\");\nfile.seek(SevenZFile.SIGNATURE_HEADER_SIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!finished) {\nfinish();\nfile.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:createArchiveEntry(Ljava/io/File;Ljava/lang/String;)Lorg/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry;",
                                    "method_body": "public SevenZArchiveEntry createArchiveEntry(final File inputFile,\nfinal SevenZArchiveEntry entry = new SevenZArchiveEntry();\nentry.setDirectory(inputFile.isDirectory());\nentry.setName(entryName);\nentry.setLastModifiedDate(new Date(inputFile.lastModified()));\nreturn entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\nfinal SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;\nfiles.add(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (currentOutputStream != null) {\ncurrentOutputStream.flush();\ncurrentOutputStream.close();\nfinal SevenZArchiveEntry entry = files.get(files.size() - 1);\nif (fileBytesWritten > 0) {\nentry.setHasStream(true);\n++numNonEmptyStreams;\nentry.setSize(currentOutputStream.getBytesWritten());\nentry.setCompressedSize(fileBytesWritten);\nentry.setCrcValue(crc32.getValue());\nentry.setCompressedCrcValue(compressedCrc32.getValue());\nentry.setHasCrc(true);\nentry.setHasStream(false);\nentry.setSize(0);\nentry.setCompressedSize(0);\nentry.setHasCrc(false);\ncurrentOutputStream = null;\ncrc32.reset();\ncompressedCrc32.reset();\nfileBytesWritten = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([B)V",
                                    "method_body": "public void write(final byte[] b) throws IOException {\nwrite(b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int off, final int len) throws IOException {\nif (len > 0) {\ngetCurrentOutputStream().write(b, off, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif (finished) {\nfinished = true;\nfinal long headerPosition = file.getFilePointer();\nfinal ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();\nfinal DataOutputStream header = new DataOutputStream(headerBaos);\nwriteHeader(header);\nheader.flush();\nfinal byte[] headerBytes = headerBaos.toByteArray();\nfile.write(headerBytes);\nfinal CRC32 crc32 = new CRC32();\nfile.seek(0);\nfile.write(SevenZFile.sevenZSignature);\nfile.write(0);\nfile.write(2);\nfinal ByteArrayOutputStream startHeaderBaos = new ByteArrayOutputStream();\nfinal DataOutputStream startHeaderStream = new DataOutputStream(startHeaderBaos);\nstartHeaderStream.writeLong(Long.reverseBytes(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE));\nstartHeaderStream.writeLong(Long.reverseBytes(0xffffFFFFL & headerBytes.length));\ncrc32.reset();\ncrc32.update(headerBytes);\nstartHeaderStream.writeInt(Integer.reverseBytes((int)crc32.getValue()));\nstartHeaderStream.flush();\nfinal byte[] startHeaderBytes = startHeaderBaos.toByteArray();\ncrc32.reset();\ncrc32.update(startHeaderBytes);\nfile.writeInt(Integer.reverseBytes((int) crc32.getValue()));\nfile.write(startHeaderBytes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeHeader(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeHeader(final DataOutput header) throws IOException {\nheader.write(NID.kHeader);\nheader.write(NID.kMainStreamsInfo);\nwriteStreamsInfo(header);\nwriteFilesInfo(header);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeStreamsInfo(final DataOutput header) throws IOException {\nif (numNonEmptyStreams > 0) {\nwritePackInfo(header);\nwriteUnpackInfo(header);\nwriteSubStreamsInfo(header);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeSubStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeSubStreamsInfo(final DataOutput header) throws IOException {\nheader.write(NID.kSubStreamsInfo);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFilesInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFilesInfo(final DataOutput header) throws IOException {\nheader.write(NID.kFilesInfo);\nwriteUint64(header, files.size());\nwriteFileEmptyStreams(header);\nwriteFileEmptyFiles(header);\nwriteFileAntiItems(header);\nwriteFileNames(header);\nwriteFileCTimes(header);\nwriteFileATimes(header);\nwriteFileMTimes(header);\nwriteFileWindowsAttributes(header);\nheader.write(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyStreams(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyStreams(final DataOutput header) throws IOException {\nboolean hasEmptyStreams = false;\nfor (final SevenZArchiveEntry entry : files) {\nif (!entry.hasStream()) {\nhasEmptyStreams = true;\nbreak;\nif (hasEmptyStreams) {\nheader.write(NID.kEmptyStream);\nfinal BitSet emptyStreams = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nemptyStreams.set(i, !files.get(i).hasStream());\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyStreams, files.size());\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyFiles(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyFiles(final DataOutput header) throws IOException {\nboolean hasEmptyFiles = false;\nint emptyStreamCounter = 0;\nfinal BitSet emptyFiles = new BitSet(0);\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isDir = files.get(i).isDirectory();\nemptyFiles.set(emptyStreamCounter++, !isDir);\nhasEmptyFiles |= !isDir;\nif (hasEmptyFiles) {\nheader.write(NID.kEmptyFile);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyFiles, emptyStreamCounter);\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileAntiItems(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileAntiItems(final DataOutput header) throws IOException {\nboolean hasAntiItems = false;\nfinal BitSet antiItems = new BitSet(0);\nint antiItemCounter = 0;\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isAnti = files.get(i).isAntiItem();\nantiItems.set(antiItemCounter++, isAnti);\nhasAntiItems |= isAnti;\nif (hasAntiItems) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileNames(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileNames(final DataOutput header) throws IOException {\nheader.write(NID.kName);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nout.write(entry.getName().getBytes(\"UTF-16LE\"));\nout.writeShort(0);\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileCTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileCTimes(final DataOutput header) throws IOException {\nint numCreationDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasCreationDate()) {\n}\nif (numCreationDates > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileATimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileATimes(final DataOutput header) throws IOException {\nint numAccessDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasAccessDate()) {\n}\nif (numAccessDates > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileMTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileMTimes(final DataOutput header) throws IOException {\nint numLastModifiedDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\n++numLastModifiedDates;\n}\nif (numLastModifiedDates > 0) {\nheader.write(NID.kMTime);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numLastModifiedDates != files.size()) {\nout.write(0);\nfinal BitSet mTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nmTimes.set(i, files.get(i).getHasLastModifiedDate());\nwriteBits(out, mTimes, files.size());\n} else {\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\nout.writeLong(Long.reverseBytes(\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileWindowsAttributes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileWindowsAttributes(final DataOutput header) throws IOException {\nint numWindowsAttributes = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasWindowsAttributes()) {\n}\nif (numWindowsAttributes > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeUint64(Ljava/io/DataOutput;J)V",
                                    "method_body": "private void writeUint64(final DataOutput header, long value) throws IOException {\nint firstByte = 0;\nint mask = 0x80;\nfor (i = 0; i < 8; i++) {\nif (value < ((1L << ( 7  * (i + 1))))) {\nfirstByte |= (value >>> (8 * i));\nbreak;\nfirstByte |= mask;\nmask >>>= 1;\nheader.write(firstByte);\nfor (; i > 0; i--) {\nheader.write((int) (0xff & value));\nvalue >>>= 8;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeBits(Ljava/io/DataOutput;Ljava/util/BitSet;I)V",
                                    "method_body": "private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\nint cache = 0;\nint shift = 7;\nfor (int i = 0; i < length; i++) {\ncache |= ((bits.get(i) ? 1 : 0) << shift);\n--shift;\nif (shift == 0) {\nheader.write(cache);\nshift = 7;\ncache = 0;\nif (length > 0 && shift > 0) {\nheader.write(cache);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:<init>(Ljava/lang/String;I[B)V",
                                    "method_body": "private SevenZMethod(byte[] id) {\nthis.id = id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;[B)V",
                                    "method_body": "public SevenZFile(final File filename, final byte[] password) throws IOException {\nboolean succeeded = false;\nthis.file = new RandomAccessFile(filename, \"r\");\narchive = readHeaders(password);\nif (!succeeded) {\nthis.file.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZFile(final File filename) throws IOException {\nthis(filename, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<clinit>()V",
                                    "method_body": "static final int SIGNATURE_HEADER_SIZE = 32;\nprivate int currentEntryIndex = -1;\nprivate int currentFolderIndex = -1;\nprivate InputStream currentFolderInputStream = null;\nprivate InputStream currentEntryInputStream = null;\nstatic final byte[] sevenZSignature = {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeaders([B)Lorg/apache/commons/compress/archivers/sevenz/Archive;",
                                    "method_body": "private Archive readHeaders(byte[] password) throws IOException {\nfinal byte[] signature = new byte[6];\nfile.readFully(signature);\nif (!Arrays.equals(signature, sevenZSignature)) {\nfinal byte archiveVersionMajor = file.readByte();\nfinal byte archiveVersionMinor = file.readByte();\nif (archiveVersionMajor != 0) {\nfinal long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\nfinal StartHeader startHeader = readStartHeader(startHeaderCrc);\nfinal int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\nif (nextHeaderSizeInt != startHeader.nextHeaderSize) {\nfile.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\nfinal byte[] nextHeader = new byte[nextHeaderSizeInt];\nfile.readFully(nextHeader);\nfinal CRC32 crc = new CRC32();\ncrc.update(nextHeader);\nif (startHeader.nextHeaderCrc != crc.getValue()) {\nfinal ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\nDataInputStream nextHeaderInputStream = new DataInputStream(\nArchive archive = new Archive();\nint nid = nextHeaderInputStream.readUnsignedByte();\nif (nid == NID.kEncodedHeader) {\nif (nid == NID.kHeader) {\nreadHeader(nextHeaderInputStream, archive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStartHeader(J)Lorg/apache/commons/compress/archivers/sevenz/StartHeader;",
                                    "method_body": "private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\nfinal StartHeader startHeader = new StartHeader();\nDataInputStream dataInputStream = null;\ndataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\nstartHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\nreturn startHeader;\nif (dataInputStream != null) {\ndataInputStream.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeader(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readHeader(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\nif (nid == NID.kArchiveProperties) {\nif (nid == NID.kAdditionalStreamsInfo) {\nif (nid == NID.kMainStreamsInfo) {\nreadStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid == NID.kFilesInfo) {\nreadFilesInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated header\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\nif (nid == NID.kPackInfo) {\nreadPackInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid == NID.kUnpackInfo) {\nreadUnpackInfo(header, archive);\nnid = header.readUnsignedByte();\narchive.folders = new Folder[0];\nif (nid == NID.kSubStreamsInfo) {\nreadSubStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid != NID.kEnd) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readSubStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nfor (final Folder folder : archive.folders) {\nfolder.numUnpackSubStreams = 1;\nint totalUnpackStreams = archive.folders.length;\nint nid = header.readUnsignedByte();\nif (nid == NID.kNumUnpackStream) {\nfinal SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\nsubStreamsInfo.unpackSizes = new long[totalUnpackStreams];\nsubStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\nsubStreamsInfo.crcs = new long[totalUnpackStreams];\nint nextUnpackStream = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams == 0) {\nlong sum = 0;\nif (nid == NID.kSize) {\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;\nif (nid == NID.kSize) {\nint numDigests = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {\nif (nid == NID.kCRC) {\nif (nid != NID.kEnd) {\narchive.subStreamsInfo = subStreamsInfo;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readBits(final DataInput header, final int size) throws IOException {\nfinal BitSet bits = new BitSet(size);\nint mask = 0;\nint cache = 0;\nfor (int i = 0; i < size; i++) {\nif (mask == 0) {\nmask = 0x80;\ncache = header.readUnsignedByte();\nbits.set(i, (cache & mask) != 0);\nmask >>>= 1;\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFilesInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readFilesInfo(final DataInput header, final Archive archive) throws IOException {\nfinal long numFiles = readUint64(header);\nfinal SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\nfor (int i = 0; i < files.length; i++) {\nfiles[i] = new SevenZArchiveEntry();\nBitSet isEmptyStream = null;\nBitSet isEmptyFile = null;\nBitSet isAnti = null;\nfinal int propertyType = header.readUnsignedByte();\nif (propertyType == 0) {\nbreak;\nlong size = readUint64(header);\nswitch (propertyType) {\nisEmptyStream = readBits(header, files.length);\nbreak;\nif (isEmptyStream == null) { // protect against NPE\nisEmptyFile = readBits(header, isEmptyStream.cardinality());\nbreak;\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nif (((size - 1) & 1) != 0) {\nfinal byte[] names = new byte[(int)(size - 1)];\nheader.readFully(names);\nint nextFile = 0;\nint nextName = 0;\nfor (int i = 0; i < names.length; i += 2) {\nif (names[i] == 0 && names[i+1] == 0) {\nfiles[nextFile++].setName(new String(names, nextName, i-nextName, CharsetNames.UTF_16LE));\nnextName = i + 2;\nif (nextName != names.length || nextFile != files.length) {\nbreak;\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasLastModifiedDate(timesDefined.get(i));\nif (files[i].getHasLastModifiedDate()) {\nfiles[i].setLastModifiedDate(Long.reverseBytes(header.readLong()));\nbreak;\nthrow new IOException(\"Unknown property \" + propertyType);\n}\nint nonEmptyFileCounter = 0;\nint emptyFileCounter = 0;\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasStream((isEmptyStream == null) ? true : !isEmptyStream.get(i));\nif (files[i].hasStream()) {\nfiles[i].setDirectory(false);\nfiles[i].setAntiItem(false);\nfiles[i].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nfiles[i].setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nfiles[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\nfiles[i].setDirectory((isEmptyFile == null) ? true : !isEmptyFile.get(emptyFileCounter));\nfiles[i].setAntiItem((isAnti == null) ? false : isAnti.get(emptyFileCounter));\nfiles[i].setHasCrc(false);\nfiles[i].setSize(0);\n++emptyFileCounter;\narchive.files = files;\ncalculateStreamMap(archive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUint64(Ljava/io/DataInput;)J",
                                    "method_body": "private static long readUint64(final DataInput in) throws IOException {\nlong firstByte = in.readUnsignedByte();\nint mask = 0x80;\nlong value = 0;\nfor (int i = 0; i < 8; i++) {\nif ((firstByte & mask) == 0) {\nreturn value | ((firstByte & (mask - 1)) << (8 * i));\nlong nextByte = in.readUnsignedByte();\nvalue |= (nextByte << (8 * i));\nmask >>>= 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;JJ)V",
                                    "method_body": "public ChecksumVerifyingInputStream(final Checksum checksum, final InputStream in,\nfinal long size, final long expectedChecksum) {\nthis.checksum = checksum;\nthis.in = in;\nthis.expectedChecksum = expectedChecksum;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining <= 0) {\nint ret = in.read();\nif (ret >= 0) {\nchecksum.update(ret);\n--bytesRemaining;\nif (bytesRemaining == 0 && expectedChecksum != checksum.getValue()) {\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nint ret = in.read(b, off, len);\nif (ret >= 0) {\nchecksum.update(b, off, ret);\nbytesRemaining -= ret;\nif (bytesRemaining <= 0 && expectedChecksum != checksum.getValue()) {\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nin.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CRC32VerifyingInputStream:<init>(Ljava/io/InputStream;JJ)V",
                                    "method_body": "public CRC32VerifyingInputStream(final InputStream in, final long size, final long expectedCrc32) {\nsuper(new CRC32(), in, size, expectedCrc32);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:<init>(Ljava/io/RandomAccessFile;J)V",
                                    "method_body": "public BoundedRandomAccessFileInputStream(final RandomAccessFile file,\nfinal long size) {\nthis.file = file;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining > 0) {\n--bytesRemaining;\nreturn file.read();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif (bytesRemaining == 0) {\nint bytesToRead = len;\nif (bytesToRead > bytesRemaining) {\nfinal int bytesRead = file.read(b, off, bytesToRead);\nif (bytesRead >= 0) {\nbytesRemaining -= bytesRead;\nreturn bytesRead;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:close()V",
                                    "method_body": "public void close() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setAntiItem(Z)V",
                                    "method_body": "public void setAntiItem(boolean isAntiItem) {\nthis.isAntiItem = isAntiItem;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest.testEightFilesSomeNotEmpty",
                            "test_body": "194: public void testEightFilesSomeNotEmpty() throws Exception {\n195: testCompress252(8, 2);\n196: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:<init>()V",
                                    "method_body": "public SevenZArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "public void setName(String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:hasStream()Z",
                                    "method_body": "public boolean hasStream() {\nreturn hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasStream(Z)V",
                                    "method_body": "public void setHasStream(boolean hasStream) {\nthis.hasStream = hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nreturn isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setDirectory(Z)V",
                                    "method_body": "public void setDirectory(boolean isDirectory) {\nthis.isDirectory = isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isAntiItem()Z",
                                    "method_body": "public boolean isAntiItem() {\nreturn isAntiItem;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasCreationDate()Z",
                                    "method_body": "public boolean getHasCreationDate() {\nreturn hasCreationDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasLastModifiedDate()Z",
                                    "method_body": "public boolean getHasLastModifiedDate() {\nreturn hasLastModifiedDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getLastModifiedDate()Ljava/util/Date;",
                                    "method_body": "public Date getLastModifiedDate() {\nif (hasLastModifiedDate) {\nreturn ntfsTimeToJavaTime(lastModifiedDate);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setLastModifiedDate(Ljava/util/Date;)V",
                                    "method_body": "public void setLastModifiedDate(Date lastModifiedDate) {\nhasLastModifiedDate = lastModifiedDate != null;\nif (hasLastModifiedDate) {\nthis.lastModifiedDate = javaTimeToNtfsTime(lastModifiedDate);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasAccessDate()Z",
                                    "method_body": "public boolean getHasAccessDate() {\nreturn hasAccessDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasWindowsAttributes()Z",
                                    "method_body": "public boolean getHasWindowsAttributes() {\nreturn hasWindowsAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasCrc(Z)V",
                                    "method_body": "public void setHasCrc(boolean hasCrc) {\nthis.hasCrc = hasCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCompressedSize(J)V",
                                    "method_body": "void setCompressedSize(long size) {\nthis.compressedSize = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:ntfsTimeToJavaTime(J)Ljava/util/Date;",
                                    "method_body": "public static Date ntfsTimeToJavaTime(final long ntfsTime) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nfinal long realTime = ntfsEpoch.getTimeInMillis() + (ntfsTime / (10*1000));\nreturn new Date(realTime);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:javaTimeToNtfsTime(Ljava/util/Date;)J",
                                    "method_body": "public static long javaTimeToNtfsTime(final Date date) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nreturn ((date.getTime() - ntfsEpoch.getTimeInMillis())* 1000 * 10);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:<init>(Ljava/io/File;)V",
                                    "method_body": "private final RandomAccessFile file;\nprivate final List<SevenZArchiveEntry> files = new ArrayList<SevenZArchiveEntry>();\nprivate int numNonEmptyStreams = 0;\nprivate CRC32 crc32 = new CRC32();\nprivate CRC32 compressedCrc32 = new CRC32();\nprivate long fileBytesWritten = 0;\nprivate boolean finished = false;\nprivate SevenZMethod contentCompression = SevenZMethod.LZMA2;\npublic SevenZOutputFile(final File filename) throws IOException {\nfile = new RandomAccessFile(filename, \"rw\");\nfile.seek(SevenZFile.SIGNATURE_HEADER_SIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!finished) {\nfinish();\nfile.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:createArchiveEntry(Ljava/io/File;Ljava/lang/String;)Lorg/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry;",
                                    "method_body": "public SevenZArchiveEntry createArchiveEntry(final File inputFile,\nfinal SevenZArchiveEntry entry = new SevenZArchiveEntry();\nentry.setDirectory(inputFile.isDirectory());\nentry.setName(entryName);\nentry.setLastModifiedDate(new Date(inputFile.lastModified()));\nreturn entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\nfinal SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;\nfiles.add(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (currentOutputStream != null) {\ncurrentOutputStream.flush();\ncurrentOutputStream.close();\nfinal SevenZArchiveEntry entry = files.get(files.size() - 1);\nif (fileBytesWritten > 0) {\nentry.setHasStream(true);\n++numNonEmptyStreams;\nentry.setSize(currentOutputStream.getBytesWritten());\nentry.setCompressedSize(fileBytesWritten);\nentry.setCrcValue(crc32.getValue());\nentry.setCompressedCrcValue(compressedCrc32.getValue());\nentry.setHasCrc(true);\nentry.setHasStream(false);\nentry.setSize(0);\nentry.setCompressedSize(0);\nentry.setHasCrc(false);\ncurrentOutputStream = null;\ncrc32.reset();\ncompressedCrc32.reset();\nfileBytesWritten = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([B)V",
                                    "method_body": "public void write(final byte[] b) throws IOException {\nwrite(b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int off, final int len) throws IOException {\nif (len > 0) {\ngetCurrentOutputStream().write(b, off, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif (finished) {\nfinished = true;\nfinal long headerPosition = file.getFilePointer();\nfinal ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();\nfinal DataOutputStream header = new DataOutputStream(headerBaos);\nwriteHeader(header);\nheader.flush();\nfinal byte[] headerBytes = headerBaos.toByteArray();\nfile.write(headerBytes);\nfinal CRC32 crc32 = new CRC32();\nfile.seek(0);\nfile.write(SevenZFile.sevenZSignature);\nfile.write(0);\nfile.write(2);\nfinal ByteArrayOutputStream startHeaderBaos = new ByteArrayOutputStream();\nfinal DataOutputStream startHeaderStream = new DataOutputStream(startHeaderBaos);\nstartHeaderStream.writeLong(Long.reverseBytes(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE));\nstartHeaderStream.writeLong(Long.reverseBytes(0xffffFFFFL & headerBytes.length));\ncrc32.reset();\ncrc32.update(headerBytes);\nstartHeaderStream.writeInt(Integer.reverseBytes((int)crc32.getValue()));\nstartHeaderStream.flush();\nfinal byte[] startHeaderBytes = startHeaderBaos.toByteArray();\ncrc32.reset();\ncrc32.update(startHeaderBytes);\nfile.writeInt(Integer.reverseBytes((int) crc32.getValue()));\nfile.write(startHeaderBytes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeHeader(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeHeader(final DataOutput header) throws IOException {\nheader.write(NID.kHeader);\nheader.write(NID.kMainStreamsInfo);\nwriteStreamsInfo(header);\nwriteFilesInfo(header);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeStreamsInfo(final DataOutput header) throws IOException {\nif (numNonEmptyStreams > 0) {\nwritePackInfo(header);\nwriteUnpackInfo(header);\nwriteSubStreamsInfo(header);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeSubStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeSubStreamsInfo(final DataOutput header) throws IOException {\nheader.write(NID.kSubStreamsInfo);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFilesInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFilesInfo(final DataOutput header) throws IOException {\nheader.write(NID.kFilesInfo);\nwriteUint64(header, files.size());\nwriteFileEmptyStreams(header);\nwriteFileEmptyFiles(header);\nwriteFileAntiItems(header);\nwriteFileNames(header);\nwriteFileCTimes(header);\nwriteFileATimes(header);\nwriteFileMTimes(header);\nwriteFileWindowsAttributes(header);\nheader.write(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyStreams(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyStreams(final DataOutput header) throws IOException {\nboolean hasEmptyStreams = false;\nfor (final SevenZArchiveEntry entry : files) {\nif (!entry.hasStream()) {\nhasEmptyStreams = true;\nbreak;\nif (hasEmptyStreams) {\nheader.write(NID.kEmptyStream);\nfinal BitSet emptyStreams = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nemptyStreams.set(i, !files.get(i).hasStream());\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyStreams, files.size());\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyFiles(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyFiles(final DataOutput header) throws IOException {\nboolean hasEmptyFiles = false;\nint emptyStreamCounter = 0;\nfinal BitSet emptyFiles = new BitSet(0);\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isDir = files.get(i).isDirectory();\nemptyFiles.set(emptyStreamCounter++, !isDir);\nhasEmptyFiles |= !isDir;\nif (hasEmptyFiles) {\nheader.write(NID.kEmptyFile);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyFiles, emptyStreamCounter);\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileAntiItems(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileAntiItems(final DataOutput header) throws IOException {\nboolean hasAntiItems = false;\nfinal BitSet antiItems = new BitSet(0);\nint antiItemCounter = 0;\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isAnti = files.get(i).isAntiItem();\nantiItems.set(antiItemCounter++, isAnti);\nhasAntiItems |= isAnti;\nif (hasAntiItems) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileNames(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileNames(final DataOutput header) throws IOException {\nheader.write(NID.kName);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nout.write(entry.getName().getBytes(\"UTF-16LE\"));\nout.writeShort(0);\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileCTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileCTimes(final DataOutput header) throws IOException {\nint numCreationDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasCreationDate()) {\n}\nif (numCreationDates > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileATimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileATimes(final DataOutput header) throws IOException {\nint numAccessDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasAccessDate()) {\n}\nif (numAccessDates > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileMTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileMTimes(final DataOutput header) throws IOException {\nint numLastModifiedDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\n++numLastModifiedDates;\n}\nif (numLastModifiedDates > 0) {\nheader.write(NID.kMTime);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numLastModifiedDates != files.size()) {\nout.write(0);\nfinal BitSet mTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nmTimes.set(i, files.get(i).getHasLastModifiedDate());\nwriteBits(out, mTimes, files.size());\n} else {\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\nout.writeLong(Long.reverseBytes(\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileWindowsAttributes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileWindowsAttributes(final DataOutput header) throws IOException {\nint numWindowsAttributes = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasWindowsAttributes()) {\n}\nif (numWindowsAttributes > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeUint64(Ljava/io/DataOutput;J)V",
                                    "method_body": "private void writeUint64(final DataOutput header, long value) throws IOException {\nint firstByte = 0;\nint mask = 0x80;\nfor (i = 0; i < 8; i++) {\nif (value < ((1L << ( 7  * (i + 1))))) {\nfirstByte |= (value >>> (8 * i));\nbreak;\nfirstByte |= mask;\nmask >>>= 1;\nheader.write(firstByte);\nfor (; i > 0; i--) {\nheader.write((int) (0xff & value));\nvalue >>>= 8;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeBits(Ljava/io/DataOutput;Ljava/util/BitSet;I)V",
                                    "method_body": "private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\nint cache = 0;\nint shift = 7;\nfor (int i = 0; i < length; i++) {\ncache |= ((bits.get(i) ? 1 : 0) << shift);\n--shift;\nif (shift == 0) {\nheader.write(cache);\nshift = 7;\ncache = 0;\nif (length > 0 && shift > 0) {\nheader.write(cache);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:<init>(Ljava/lang/String;I[B)V",
                                    "method_body": "private SevenZMethod(byte[] id) {\nthis.id = id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;[B)V",
                                    "method_body": "public SevenZFile(final File filename, final byte[] password) throws IOException {\nboolean succeeded = false;\nthis.file = new RandomAccessFile(filename, \"r\");\narchive = readHeaders(password);\nif (!succeeded) {\nthis.file.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZFile(final File filename) throws IOException {\nthis(filename, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<clinit>()V",
                                    "method_body": "static final int SIGNATURE_HEADER_SIZE = 32;\nprivate int currentEntryIndex = -1;\nprivate int currentFolderIndex = -1;\nprivate InputStream currentFolderInputStream = null;\nprivate InputStream currentEntryInputStream = null;\nstatic final byte[] sevenZSignature = {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeaders([B)Lorg/apache/commons/compress/archivers/sevenz/Archive;",
                                    "method_body": "private Archive readHeaders(byte[] password) throws IOException {\nfinal byte[] signature = new byte[6];\nfile.readFully(signature);\nif (!Arrays.equals(signature, sevenZSignature)) {\nfinal byte archiveVersionMajor = file.readByte();\nfinal byte archiveVersionMinor = file.readByte();\nif (archiveVersionMajor != 0) {\nfinal long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\nfinal StartHeader startHeader = readStartHeader(startHeaderCrc);\nfinal int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\nif (nextHeaderSizeInt != startHeader.nextHeaderSize) {\nfile.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\nfinal byte[] nextHeader = new byte[nextHeaderSizeInt];\nfile.readFully(nextHeader);\nfinal CRC32 crc = new CRC32();\ncrc.update(nextHeader);\nif (startHeader.nextHeaderCrc != crc.getValue()) {\nfinal ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\nDataInputStream nextHeaderInputStream = new DataInputStream(\nArchive archive = new Archive();\nint nid = nextHeaderInputStream.readUnsignedByte();\nif (nid == NID.kEncodedHeader) {\nif (nid == NID.kHeader) {\nreadHeader(nextHeaderInputStream, archive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStartHeader(J)Lorg/apache/commons/compress/archivers/sevenz/StartHeader;",
                                    "method_body": "private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\nfinal StartHeader startHeader = new StartHeader();\nDataInputStream dataInputStream = null;\ndataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\nstartHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\nreturn startHeader;\nif (dataInputStream != null) {\ndataInputStream.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeader(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readHeader(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\nif (nid == NID.kArchiveProperties) {\nif (nid == NID.kAdditionalStreamsInfo) {\nif (nid == NID.kMainStreamsInfo) {\nreadStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid == NID.kFilesInfo) {\nreadFilesInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated header\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\nif (nid == NID.kPackInfo) {\nreadPackInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid == NID.kUnpackInfo) {\nreadUnpackInfo(header, archive);\nnid = header.readUnsignedByte();\narchive.folders = new Folder[0];\nif (nid == NID.kSubStreamsInfo) {\nreadSubStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid != NID.kEnd) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readSubStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nfor (final Folder folder : archive.folders) {\nfolder.numUnpackSubStreams = 1;\nint totalUnpackStreams = archive.folders.length;\nint nid = header.readUnsignedByte();\nif (nid == NID.kNumUnpackStream) {\nfinal SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\nsubStreamsInfo.unpackSizes = new long[totalUnpackStreams];\nsubStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\nsubStreamsInfo.crcs = new long[totalUnpackStreams];\nint nextUnpackStream = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams == 0) {\nlong sum = 0;\nif (nid == NID.kSize) {\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;\nif (nid == NID.kSize) {\nint numDigests = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {\nif (nid == NID.kCRC) {\nif (nid != NID.kEnd) {\narchive.subStreamsInfo = subStreamsInfo;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readBits(final DataInput header, final int size) throws IOException {\nfinal BitSet bits = new BitSet(size);\nint mask = 0;\nint cache = 0;\nfor (int i = 0; i < size; i++) {\nif (mask == 0) {\nmask = 0x80;\ncache = header.readUnsignedByte();\nbits.set(i, (cache & mask) != 0);\nmask >>>= 1;\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFilesInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readFilesInfo(final DataInput header, final Archive archive) throws IOException {\nfinal long numFiles = readUint64(header);\nfinal SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\nfor (int i = 0; i < files.length; i++) {\nfiles[i] = new SevenZArchiveEntry();\nBitSet isEmptyStream = null;\nBitSet isEmptyFile = null;\nBitSet isAnti = null;\nfinal int propertyType = header.readUnsignedByte();\nif (propertyType == 0) {\nbreak;\nlong size = readUint64(header);\nswitch (propertyType) {\nisEmptyStream = readBits(header, files.length);\nbreak;\nif (isEmptyStream == null) { // protect against NPE\nisEmptyFile = readBits(header, isEmptyStream.cardinality());\nbreak;\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nif (((size - 1) & 1) != 0) {\nfinal byte[] names = new byte[(int)(size - 1)];\nheader.readFully(names);\nint nextFile = 0;\nint nextName = 0;\nfor (int i = 0; i < names.length; i += 2) {\nif (names[i] == 0 && names[i+1] == 0) {\nfiles[nextFile++].setName(new String(names, nextName, i-nextName, CharsetNames.UTF_16LE));\nnextName = i + 2;\nif (nextName != names.length || nextFile != files.length) {\nbreak;\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasLastModifiedDate(timesDefined.get(i));\nif (files[i].getHasLastModifiedDate()) {\nfiles[i].setLastModifiedDate(Long.reverseBytes(header.readLong()));\nbreak;\nthrow new IOException(\"Unknown property \" + propertyType);\n}\nint nonEmptyFileCounter = 0;\nint emptyFileCounter = 0;\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasStream((isEmptyStream == null) ? true : !isEmptyStream.get(i));\nif (files[i].hasStream()) {\nfiles[i].setDirectory(false);\nfiles[i].setAntiItem(false);\nfiles[i].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nfiles[i].setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nfiles[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\nfiles[i].setDirectory((isEmptyFile == null) ? true : !isEmptyFile.get(emptyFileCounter));\nfiles[i].setAntiItem((isAnti == null) ? false : isAnti.get(emptyFileCounter));\nfiles[i].setHasCrc(false);\nfiles[i].setSize(0);\n++emptyFileCounter;\narchive.files = files;\ncalculateStreamMap(archive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUint64(Ljava/io/DataInput;)J",
                                    "method_body": "private static long readUint64(final DataInput in) throws IOException {\nlong firstByte = in.readUnsignedByte();\nint mask = 0x80;\nlong value = 0;\nfor (int i = 0; i < 8; i++) {\nif ((firstByte & mask) == 0) {\nreturn value | ((firstByte & (mask - 1)) << (8 * i));\nlong nextByte = in.readUnsignedByte();\nvalue |= (nextByte << (8 * i));\nmask >>>= 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;JJ)V",
                                    "method_body": "public ChecksumVerifyingInputStream(final Checksum checksum, final InputStream in,\nfinal long size, final long expectedChecksum) {\nthis.checksum = checksum;\nthis.in = in;\nthis.expectedChecksum = expectedChecksum;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining <= 0) {\nint ret = in.read();\nif (ret >= 0) {\nchecksum.update(ret);\n--bytesRemaining;\nif (bytesRemaining == 0 && expectedChecksum != checksum.getValue()) {\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nint ret = in.read(b, off, len);\nif (ret >= 0) {\nchecksum.update(b, off, ret);\nbytesRemaining -= ret;\nif (bytesRemaining <= 0 && expectedChecksum != checksum.getValue()) {\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nin.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CRC32VerifyingInputStream:<init>(Ljava/io/InputStream;JJ)V",
                                    "method_body": "public CRC32VerifyingInputStream(final InputStream in, final long size, final long expectedCrc32) {\nsuper(new CRC32(), in, size, expectedCrc32);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:<init>(Ljava/io/RandomAccessFile;J)V",
                                    "method_body": "public BoundedRandomAccessFileInputStream(final RandomAccessFile file,\nfinal long size) {\nthis.file = file;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining > 0) {\n--bytesRemaining;\nreturn file.read();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif (bytesRemaining == 0) {\nint bytesToRead = len;\nif (bytesToRead > bytesRemaining) {\nfinal int bytesRead = file.read(b, off, bytesToRead);\nif (bytesRead >= 0) {\nbytesRemaining -= bytesRead;\nreturn bytesRead;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:close()V",
                                    "method_body": "public void close() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setAntiItem(Z)V",
                                    "method_body": "public void setAntiItem(boolean isAntiItem) {\nthis.isAntiItem = isAntiItem;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getCrcValue()J",
                                    "method_body": "public long getCrcValue() {\nreturn crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCrcValue(J)V",
                                    "method_body": "public void setCrcValue(long crc) {\nthis.crc = crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getCompressedCrcValue()J",
                                    "method_body": "long getCompressedCrcValue() {\nreturn compressedCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCompressedCrcValue(J)V",
                                    "method_body": "void setCompressedCrcValue(long crc) {\nthis.compressedCrc = crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getCompressedSize()J",
                                    "method_body": "long getCompressedSize() {\nreturn compressedSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:getCurrentOutputStream()Ljava/io/OutputStream;",
                                    "method_body": "private OutputStream getCurrentOutputStream() throws IOException {\nif (currentOutputStream == null) {\ncurrentOutputStream = setupFileOutputStream();\nreturn currentOutputStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:setupFileOutputStream()Lorg/apache/commons/compress/utils/CountingOutputStream;",
                                    "method_body": "private CountingOutputStream setupFileOutputStream() throws IOException {\nOutputStream out = new OutputStreamWrapper();\nreturn new CountingOutputStream(Coders\nsuper.write(b, off, len);\ncrc32.update(b, off, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writePackInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writePackInfo(final DataOutput header) throws IOException {\nheader.write(NID.kPackInfo);\nwriteUint64(header, 0);\nwriteUint64(header, 0xffffFFFFL & numNonEmptyStreams);\nheader.write(NID.kSize);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nwriteUint64(header, entry.getCompressedSize());\n}\nheader.write(NID.kCRC);\nheader.write(1);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nheader.writeInt(Integer.reverseBytes((int) entry.getCompressedCrcValue()));\n}\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeUnpackInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeUnpackInfo(final DataOutput header) throws IOException {\nheader.write(NID.kUnpackInfo);\nheader.write(NID.kFolder);\nwriteUint64(header, numNonEmptyStreams);\nheader.write(0);\nfor (int i = 0; i < numNonEmptyStreams; i++) {\nwriteFolder(header);\nheader.write(NID.kCodersUnpackSize);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nwriteUint64(header, entry.getSize());\n}\nheader.write(NID.kCRC);\nheader.write(1);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nheader.writeInt(Integer.reverseBytes((int) entry.getCrcValue()));\n}\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFolder(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFolder(final DataOutput header) throws IOException {\nwriteUint64(header, 1);\nbyte[] id = contentCompression.getId();\nbyte[] properties = contentCompression.getProperties();\nint codecFlags = id.length;\nif (properties.length > 0) {\ncodecFlags |= 0x20;\nheader.write(codecFlags);\nheader.write(id);\nif (properties.length > 0) {\nheader.write(properties.length);\nheader.write(properties);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:getId()[B",
                                    "method_body": "byte[] getId() {\nbyte[] copy = new byte[id.length];\nSystem.arraycopy(id, 0, copy, 0, id.length);\nreturn copy;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod$1:getProperties()[B",
                                    "method_body": "byte[] getProperties() {\nint dictSize = LZMA2Options.DICT_SIZE_DEFAULT;\nint lead = Integer.numberOfLeadingZeros(dictSize);\nint secondBit = (dictSize >>> (30 - lead)) - 2;\nreturn new byte[] {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readPackInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readPackInfo(final DataInput header, final Archive archive) throws IOException {\narchive.packPos = readUint64(header);\nfinal long numPackStreams = readUint64(header);\nint nid = header.readUnsignedByte();\nif (nid == NID.kSize) {\narchive.packSizes = new long[(int)numPackStreams];\nfor (int i = 0; i < archive.packSizes.length; i++) {\narchive.packSizes[i] = readUint64(header);\nnid = header.readUnsignedByte();\nif (nid == NID.kCRC) {\narchive.packCrcsDefined = readAllOrBits(header, (int)numPackStreams);\narchive.packCrcs = new long[(int)numPackStreams];\nfor (int i = 0; i < (int)numPackStreams; i++) {\nif (archive.packCrcsDefined.get(i)) {\narchive.packCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\nnid = header.readUnsignedByte();\nif (nid != NID.kEnd) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUnpackInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readUnpackInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\nif (nid != NID.kFolder) {\nfinal long numFolders = readUint64(header);\nfinal Folder[] folders = new Folder[(int)numFolders];\narchive.folders = folders;\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nfor (int i = 0; i < (int)numFolders; i++) {\nfolders[i] = readFolder(header);\nnid = header.readUnsignedByte();\nif (nid != NID.kCodersUnpackSize) {\nfor (final Folder folder : folders) {\nfolder.unpackSizes = new long[(int)folder.totalOutputStreams];\nfor (int i = 0; i < folder.totalOutputStreams; i++) {\nfolder.unpackSizes[i] = readUint64(header);\nnid = header.readUnsignedByte();\nif (nid == NID.kCRC) {\nfinal BitSet crcsDefined = readAllOrBits(header, (int)numFolders);\nfor (int i = 0; i < (int)numFolders; i++) {\nif (crcsDefined.get(i)) {\nfolders[i].hasCrc = true;\nfolders[i].crc = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\nnid = header.readUnsignedByte();\nif (nid != NID.kEnd) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFolder(Ljava/io/DataInput;)Lorg/apache/commons/compress/archivers/sevenz/Folder;",
                                    "method_body": "private Folder readFolder(final DataInput header) throws IOException {\nfinal Folder folder = new Folder();\nfinal long numCoders = readUint64(header);\nfinal Coder[] coders = new Coder[(int)numCoders];\nlong totalInStreams = 0;\nlong totalOutStreams = 0;\nfor (int i = 0; i < coders.length; i++) {\ncoders[i] = new Coder();\nint bits = header.readUnsignedByte();\nfinal int idSize = bits & 0xf;\nfinal boolean isSimple = ((bits & 0x10) == 0);\nfinal boolean hasAttributes = ((bits & 0x20) != 0);\nfinal boolean moreAlternativeMethods = ((bits & 0x80) != 0);\ncoders[i].decompressionMethodId = new byte[idSize];\nheader.readFully(coders[i].decompressionMethodId);\nif (isSimple) {\ncoders[i].numInStreams = 1;\ncoders[i].numOutStreams = 1;\ntotalInStreams += coders[i].numInStreams;\ntotalOutStreams += coders[i].numOutStreams;\nif (hasAttributes) {\nfinal long propertiesSize = readUint64(header);\ncoders[i].properties = new byte[(int)propertiesSize];\nheader.readFully(coders[i].properties);\nwhile (moreAlternativeMethods) {\nfolder.coders = coders;\nfolder.totalInputStreams = totalInStreams;\nfolder.totalOutputStreams = totalOutStreams;\nif (totalOutStreams == 0) {\nfinal long numBindPairs = totalOutStreams - 1;\nfinal BindPair[] bindPairs = new BindPair[(int)numBindPairs];\nfor (int i = 0; i < bindPairs.length; i++) {\nfolder.bindPairs = bindPairs;\nif (totalInStreams < numBindPairs) {\nfinal long numPackedStreams = totalInStreams - numBindPairs;\nfinal long packedStreams[] = new long[(int)numPackedStreams];\nif (numPackedStreams == 1) {\nfor (i = 0; i < (int)totalInStreams; i++) {\nif (folder.findBindPairForInStream(i) < 0) {\nbreak;\nif (i == (int)totalInStreams) {\npackedStreams[0] = i;\n} else {\nfolder.packedStreams = packedStreams;\nreturn folder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readAllOrBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readAllOrBits(final DataInput header, final int size) throws IOException {\nfinal int areAllDefined = header.readUnsignedByte();\nif (areAllDefined != 0) {\nbits = new BitSet(size);\nfor (int i = 0; i < size; i++) {\nbits.set(i, true);\nbits = readBits(header, size);\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:calculateStreamMap(Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void calculateStreamMap(final Archive archive) throws IOException {\nfinal StreamMap streamMap = new StreamMap();\nint nextFolderPackStreamIndex = 0;\nfinal int numFolders = (archive.folders != null) ? archive.folders.length : 0;\nstreamMap.folderFirstPackStreamIndex = new int[numFolders];\nfor (int i = 0; i < numFolders; i++) {\nstreamMap.folderFirstPackStreamIndex[i] = nextFolderPackStreamIndex;\nnextFolderPackStreamIndex += archive.folders[i].packedStreams.length;\nlong nextPackStreamOffset = 0;\nfinal int numPackSizes = (archive.packSizes != null) ? archive.packSizes.length : 0;\nstreamMap.packStreamOffsets = new long[numPackSizes];\nfor (int i = 0; i < numPackSizes; i++) {\nstreamMap.packStreamOffsets[i] = nextPackStreamOffset;\nnextPackStreamOffset += archive.packSizes[i];\nstreamMap.folderFirstFileIndex = new int[numFolders];\nstreamMap.fileFolderIndex = new int[archive.files.length];\nint nextFolderIndex = 0;\nint nextFolderUnpackStreamIndex = 0;\nfor (int i = 0; i < archive.files.length; i++) {\nif (!archive.files[i].hasStream() && nextFolderUnpackStreamIndex == 0) {\nstreamMap.fileFolderIndex[i] = -1;\ncontinue;\nif (nextFolderUnpackStreamIndex == 0) {\nfor (; nextFolderIndex < archive.folders.length; ++nextFolderIndex) {\nstreamMap.folderFirstFileIndex[nextFolderIndex] = i;\nif (archive.folders[nextFolderIndex].numUnpackSubStreams > 0) {\nbreak;\nif (nextFolderIndex >= archive.folders.length) {\nstreamMap.fileFolderIndex[i] = nextFolderIndex;\nif (!archive.files[i].hasStream()) {\n++nextFolderUnpackStreamIndex;\nif (nextFolderUnpackStreamIndex >= archive.folders[nextFolderIndex].numUnpackSubStreams) {\n++nextFolderIndex;\nnextFolderUnpackStreamIndex = 0;\narchive.streamMap = streamMap;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:write(I)V",
                                    "method_body": "public void write(final int b) throws IOException {\nfile.write(b);\ncompressedCrc32.update(b);\nfileBytesWritten++;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int off, final int len)\nfile.write(b, off, len);\ncompressedCrc32.update(b, off, len);\nfileBytesWritten += len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:flush()V",
                                    "method_body": "public void flush() throws IOException {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:close()V",
                                    "method_body": "public void close() throws IOException {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public CountingOutputStream(final OutputStream out) {\nsuper(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int off, int len) throws IOException {\nout.write(b, off, len);\ncount(len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:count(J)V",
                                    "method_body": "protected void count(long written) {\nif (written != -1) {\nbytesWritten += written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:getBytesWritten()J",
                                    "method_body": "public long getBytesWritten() {\nreturn bytesWritten;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$1:write([BII)V",
                                    "method_body": "private CountingOutputStream setupFileOutputStream() throws IOException {\nOutputStream out = new OutputStreamWrapper();\nreturn new CountingOutputStream(Coders\nsuper.write(b, off, len);\ncrc32.update(b, off, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders:<clinit>()V",
                                    "method_body": "static CoderId[] coderTable = new CoderId[] {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders:addEncoder(Ljava/io/OutputStream;Lorg/apache/commons/compress/archivers/sevenz/SevenZMethod;[B)Ljava/io/OutputStream;",
                                    "method_body": "static OutputStream addEncoder(final OutputStream out, final SevenZMethod method,\nfor (final CoderId coderId : coderTable) {\nif (coderId.method.equals(method)) {\nreturn coderId.coder.encode(out, password);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$CoderId:<init>(Lorg/apache/commons/compress/archivers/sevenz/SevenZMethod;Lorg/apache/commons/compress/archivers/sevenz/Coders$CoderBase;)V",
                                    "method_body": "CoderId(SevenZMethod method, final CoderBase coder) {\nthis.method = method;\nthis.coder = coder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$CoderBase:<init>()V",
                                    "method_body": "final SevenZMethod method;\nstatic abstract class CoderBase {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.LZMA2Decoder:encode(Ljava/io/OutputStream;[B)Ljava/io/OutputStream;",
                                    "method_body": "OutputStream encode(final OutputStream out, final byte[] password)\nLZMA2Options options = new LZMA2Options();\noptions.setDictSize(LZMA2Options.DICT_SIZE_DEFAULT);\nFinishableOutputStream wrapped = new FinishableWrapperOutputStream(out);\nreturn options.getOutputStream(wrapped);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:findBindPairForInStream(I)I",
                                    "method_body": "int findBindPairForInStream(final int index) {\nfor (int i = 0; i < bindPairs.length; i++) {\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:findBindPairForOutStream(I)I",
                                    "method_body": "int findBindPairForOutStream(final int index) {\nfor (int i = 0; i < bindPairs.length; i++) {\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:getUnpackSize()J",
                                    "method_body": "long getUnpackSize() {\nif (totalOutputStreams == 0) {\nfor (int i = ((int)totalOutputStreams) - 1; i >= 0; i--) {\nif (findBindPairForOutStream(i) < 0) {\nreturn unpackSizes[i];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coder:<init>()V",
                                    "method_body": "byte[] decompressionMethodId;\nbyte[] properties = null;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest.testNineEmptyFiles",
                            "test_body": "198: public void testNineEmptyFiles() throws Exception {\n199: testCompress252(9, 0);\n200: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:<init>()V",
                                    "method_body": "public SevenZArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "public void setName(String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:hasStream()Z",
                                    "method_body": "public boolean hasStream() {\nreturn hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasStream(Z)V",
                                    "method_body": "public void setHasStream(boolean hasStream) {\nthis.hasStream = hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nreturn isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setDirectory(Z)V",
                                    "method_body": "public void setDirectory(boolean isDirectory) {\nthis.isDirectory = isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isAntiItem()Z",
                                    "method_body": "public boolean isAntiItem() {\nreturn isAntiItem;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasCreationDate()Z",
                                    "method_body": "public boolean getHasCreationDate() {\nreturn hasCreationDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasLastModifiedDate()Z",
                                    "method_body": "public boolean getHasLastModifiedDate() {\nreturn hasLastModifiedDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getLastModifiedDate()Ljava/util/Date;",
                                    "method_body": "public Date getLastModifiedDate() {\nif (hasLastModifiedDate) {\nreturn ntfsTimeToJavaTime(lastModifiedDate);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setLastModifiedDate(Ljava/util/Date;)V",
                                    "method_body": "public void setLastModifiedDate(Date lastModifiedDate) {\nhasLastModifiedDate = lastModifiedDate != null;\nif (hasLastModifiedDate) {\nthis.lastModifiedDate = javaTimeToNtfsTime(lastModifiedDate);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasAccessDate()Z",
                                    "method_body": "public boolean getHasAccessDate() {\nreturn hasAccessDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasWindowsAttributes()Z",
                                    "method_body": "public boolean getHasWindowsAttributes() {\nreturn hasWindowsAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasCrc(Z)V",
                                    "method_body": "public void setHasCrc(boolean hasCrc) {\nthis.hasCrc = hasCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCompressedSize(J)V",
                                    "method_body": "void setCompressedSize(long size) {\nthis.compressedSize = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:ntfsTimeToJavaTime(J)Ljava/util/Date;",
                                    "method_body": "public static Date ntfsTimeToJavaTime(final long ntfsTime) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nfinal long realTime = ntfsEpoch.getTimeInMillis() + (ntfsTime / (10*1000));\nreturn new Date(realTime);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:javaTimeToNtfsTime(Ljava/util/Date;)J",
                                    "method_body": "public static long javaTimeToNtfsTime(final Date date) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nreturn ((date.getTime() - ntfsEpoch.getTimeInMillis())* 1000 * 10);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:<init>(Ljava/io/File;)V",
                                    "method_body": "private final RandomAccessFile file;\nprivate final List<SevenZArchiveEntry> files = new ArrayList<SevenZArchiveEntry>();\nprivate int numNonEmptyStreams = 0;\nprivate CRC32 crc32 = new CRC32();\nprivate CRC32 compressedCrc32 = new CRC32();\nprivate long fileBytesWritten = 0;\nprivate boolean finished = false;\nprivate SevenZMethod contentCompression = SevenZMethod.LZMA2;\npublic SevenZOutputFile(final File filename) throws IOException {\nfile = new RandomAccessFile(filename, \"rw\");\nfile.seek(SevenZFile.SIGNATURE_HEADER_SIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!finished) {\nfinish();\nfile.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:createArchiveEntry(Ljava/io/File;Ljava/lang/String;)Lorg/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry;",
                                    "method_body": "public SevenZArchiveEntry createArchiveEntry(final File inputFile,\nfinal SevenZArchiveEntry entry = new SevenZArchiveEntry();\nentry.setDirectory(inputFile.isDirectory());\nentry.setName(entryName);\nentry.setLastModifiedDate(new Date(inputFile.lastModified()));\nreturn entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\nfinal SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;\nfiles.add(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (currentOutputStream != null) {\ncurrentOutputStream.flush();\ncurrentOutputStream.close();\nfinal SevenZArchiveEntry entry = files.get(files.size() - 1);\nif (fileBytesWritten > 0) {\nentry.setHasStream(true);\n++numNonEmptyStreams;\nentry.setSize(currentOutputStream.getBytesWritten());\nentry.setCompressedSize(fileBytesWritten);\nentry.setCrcValue(crc32.getValue());\nentry.setCompressedCrcValue(compressedCrc32.getValue());\nentry.setHasCrc(true);\nentry.setHasStream(false);\nentry.setSize(0);\nentry.setCompressedSize(0);\nentry.setHasCrc(false);\ncurrentOutputStream = null;\ncrc32.reset();\ncompressedCrc32.reset();\nfileBytesWritten = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([B)V",
                                    "method_body": "public void write(final byte[] b) throws IOException {\nwrite(b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int off, final int len) throws IOException {\nif (len > 0) {\ngetCurrentOutputStream().write(b, off, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif (finished) {\nfinished = true;\nfinal long headerPosition = file.getFilePointer();\nfinal ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();\nfinal DataOutputStream header = new DataOutputStream(headerBaos);\nwriteHeader(header);\nheader.flush();\nfinal byte[] headerBytes = headerBaos.toByteArray();\nfile.write(headerBytes);\nfinal CRC32 crc32 = new CRC32();\nfile.seek(0);\nfile.write(SevenZFile.sevenZSignature);\nfile.write(0);\nfile.write(2);\nfinal ByteArrayOutputStream startHeaderBaos = new ByteArrayOutputStream();\nfinal DataOutputStream startHeaderStream = new DataOutputStream(startHeaderBaos);\nstartHeaderStream.writeLong(Long.reverseBytes(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE));\nstartHeaderStream.writeLong(Long.reverseBytes(0xffffFFFFL & headerBytes.length));\ncrc32.reset();\ncrc32.update(headerBytes);\nstartHeaderStream.writeInt(Integer.reverseBytes((int)crc32.getValue()));\nstartHeaderStream.flush();\nfinal byte[] startHeaderBytes = startHeaderBaos.toByteArray();\ncrc32.reset();\ncrc32.update(startHeaderBytes);\nfile.writeInt(Integer.reverseBytes((int) crc32.getValue()));\nfile.write(startHeaderBytes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeHeader(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeHeader(final DataOutput header) throws IOException {\nheader.write(NID.kHeader);\nheader.write(NID.kMainStreamsInfo);\nwriteStreamsInfo(header);\nwriteFilesInfo(header);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeStreamsInfo(final DataOutput header) throws IOException {\nif (numNonEmptyStreams > 0) {\nwritePackInfo(header);\nwriteUnpackInfo(header);\nwriteSubStreamsInfo(header);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeSubStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeSubStreamsInfo(final DataOutput header) throws IOException {\nheader.write(NID.kSubStreamsInfo);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFilesInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFilesInfo(final DataOutput header) throws IOException {\nheader.write(NID.kFilesInfo);\nwriteUint64(header, files.size());\nwriteFileEmptyStreams(header);\nwriteFileEmptyFiles(header);\nwriteFileAntiItems(header);\nwriteFileNames(header);\nwriteFileCTimes(header);\nwriteFileATimes(header);\nwriteFileMTimes(header);\nwriteFileWindowsAttributes(header);\nheader.write(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyStreams(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyStreams(final DataOutput header) throws IOException {\nboolean hasEmptyStreams = false;\nfor (final SevenZArchiveEntry entry : files) {\nif (!entry.hasStream()) {\nhasEmptyStreams = true;\nbreak;\nif (hasEmptyStreams) {\nheader.write(NID.kEmptyStream);\nfinal BitSet emptyStreams = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nemptyStreams.set(i, !files.get(i).hasStream());\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyStreams, files.size());\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyFiles(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyFiles(final DataOutput header) throws IOException {\nboolean hasEmptyFiles = false;\nint emptyStreamCounter = 0;\nfinal BitSet emptyFiles = new BitSet(0);\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isDir = files.get(i).isDirectory();\nemptyFiles.set(emptyStreamCounter++, !isDir);\nhasEmptyFiles |= !isDir;\nif (hasEmptyFiles) {\nheader.write(NID.kEmptyFile);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyFiles, emptyStreamCounter);\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileAntiItems(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileAntiItems(final DataOutput header) throws IOException {\nboolean hasAntiItems = false;\nfinal BitSet antiItems = new BitSet(0);\nint antiItemCounter = 0;\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isAnti = files.get(i).isAntiItem();\nantiItems.set(antiItemCounter++, isAnti);\nhasAntiItems |= isAnti;\nif (hasAntiItems) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileNames(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileNames(final DataOutput header) throws IOException {\nheader.write(NID.kName);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nout.write(entry.getName().getBytes(\"UTF-16LE\"));\nout.writeShort(0);\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileCTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileCTimes(final DataOutput header) throws IOException {\nint numCreationDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasCreationDate()) {\n}\nif (numCreationDates > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileATimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileATimes(final DataOutput header) throws IOException {\nint numAccessDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasAccessDate()) {\n}\nif (numAccessDates > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileMTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileMTimes(final DataOutput header) throws IOException {\nint numLastModifiedDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\n++numLastModifiedDates;\n}\nif (numLastModifiedDates > 0) {\nheader.write(NID.kMTime);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numLastModifiedDates != files.size()) {\nout.write(0);\nfinal BitSet mTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nmTimes.set(i, files.get(i).getHasLastModifiedDate());\nwriteBits(out, mTimes, files.size());\n} else {\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\nout.writeLong(Long.reverseBytes(\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileWindowsAttributes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileWindowsAttributes(final DataOutput header) throws IOException {\nint numWindowsAttributes = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasWindowsAttributes()) {\n}\nif (numWindowsAttributes > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeUint64(Ljava/io/DataOutput;J)V",
                                    "method_body": "private void writeUint64(final DataOutput header, long value) throws IOException {\nint firstByte = 0;\nint mask = 0x80;\nfor (i = 0; i < 8; i++) {\nif (value < ((1L << ( 7  * (i + 1))))) {\nfirstByte |= (value >>> (8 * i));\nbreak;\nfirstByte |= mask;\nmask >>>= 1;\nheader.write(firstByte);\nfor (; i > 0; i--) {\nheader.write((int) (0xff & value));\nvalue >>>= 8;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeBits(Ljava/io/DataOutput;Ljava/util/BitSet;I)V",
                                    "method_body": "private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\nint cache = 0;\nint shift = 7;\nfor (int i = 0; i < length; i++) {\ncache |= ((bits.get(i) ? 1 : 0) << shift);\n--shift;\nif (shift == 0) {\nheader.write(cache);\nshift = 7;\ncache = 0;\nif (length > 0 && shift > 0) {\nheader.write(cache);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:<init>(Ljava/lang/String;I[B)V",
                                    "method_body": "private SevenZMethod(byte[] id) {\nthis.id = id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;[B)V",
                                    "method_body": "public SevenZFile(final File filename, final byte[] password) throws IOException {\nboolean succeeded = false;\nthis.file = new RandomAccessFile(filename, \"r\");\narchive = readHeaders(password);\nif (!succeeded) {\nthis.file.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZFile(final File filename) throws IOException {\nthis(filename, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<clinit>()V",
                                    "method_body": "static final int SIGNATURE_HEADER_SIZE = 32;\nprivate int currentEntryIndex = -1;\nprivate int currentFolderIndex = -1;\nprivate InputStream currentFolderInputStream = null;\nprivate InputStream currentEntryInputStream = null;\nstatic final byte[] sevenZSignature = {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeaders([B)Lorg/apache/commons/compress/archivers/sevenz/Archive;",
                                    "method_body": "private Archive readHeaders(byte[] password) throws IOException {\nfinal byte[] signature = new byte[6];\nfile.readFully(signature);\nif (!Arrays.equals(signature, sevenZSignature)) {\nfinal byte archiveVersionMajor = file.readByte();\nfinal byte archiveVersionMinor = file.readByte();\nif (archiveVersionMajor != 0) {\nfinal long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\nfinal StartHeader startHeader = readStartHeader(startHeaderCrc);\nfinal int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\nif (nextHeaderSizeInt != startHeader.nextHeaderSize) {\nfile.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\nfinal byte[] nextHeader = new byte[nextHeaderSizeInt];\nfile.readFully(nextHeader);\nfinal CRC32 crc = new CRC32();\ncrc.update(nextHeader);\nif (startHeader.nextHeaderCrc != crc.getValue()) {\nfinal ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\nDataInputStream nextHeaderInputStream = new DataInputStream(\nArchive archive = new Archive();\nint nid = nextHeaderInputStream.readUnsignedByte();\nif (nid == NID.kEncodedHeader) {\nif (nid == NID.kHeader) {\nreadHeader(nextHeaderInputStream, archive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStartHeader(J)Lorg/apache/commons/compress/archivers/sevenz/StartHeader;",
                                    "method_body": "private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\nfinal StartHeader startHeader = new StartHeader();\nDataInputStream dataInputStream = null;\ndataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\nstartHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\nreturn startHeader;\nif (dataInputStream != null) {\ndataInputStream.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\nif (nid == NID.kPackInfo) {\nreadPackInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid == NID.kUnpackInfo) {\nreadUnpackInfo(header, archive);\nnid = header.readUnsignedByte();\narchive.folders = new Folder[0];\nif (nid == NID.kSubStreamsInfo) {\nreadSubStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid != NID.kEnd) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readSubStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nfor (final Folder folder : archive.folders) {\nfolder.numUnpackSubStreams = 1;\nint totalUnpackStreams = archive.folders.length;\nint nid = header.readUnsignedByte();\nif (nid == NID.kNumUnpackStream) {\nfinal SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\nsubStreamsInfo.unpackSizes = new long[totalUnpackStreams];\nsubStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\nsubStreamsInfo.crcs = new long[totalUnpackStreams];\nint nextUnpackStream = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams == 0) {\nlong sum = 0;\nif (nid == NID.kSize) {\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;\nif (nid == NID.kSize) {\nint numDigests = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {\nif (nid == NID.kCRC) {\nif (nid != NID.kEnd) {\narchive.subStreamsInfo = subStreamsInfo;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readBits(final DataInput header, final int size) throws IOException {\nfinal BitSet bits = new BitSet(size);\nint mask = 0;\nint cache = 0;\nfor (int i = 0; i < size; i++) {\nif (mask == 0) {\nmask = 0x80;\ncache = header.readUnsignedByte();\nbits.set(i, (cache & mask) != 0);\nmask >>>= 1;\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFilesInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readFilesInfo(final DataInput header, final Archive archive) throws IOException {\nfinal long numFiles = readUint64(header);\nfinal SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\nfor (int i = 0; i < files.length; i++) {\nfiles[i] = new SevenZArchiveEntry();\nBitSet isEmptyStream = null;\nBitSet isEmptyFile = null;\nBitSet isAnti = null;\nfinal int propertyType = header.readUnsignedByte();\nif (propertyType == 0) {\nbreak;\nlong size = readUint64(header);\nswitch (propertyType) {\nisEmptyStream = readBits(header, files.length);\nbreak;\nif (isEmptyStream == null) { // protect against NPE\nisEmptyFile = readBits(header, isEmptyStream.cardinality());\nbreak;\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nif (((size - 1) & 1) != 0) {\nfinal byte[] names = new byte[(int)(size - 1)];\nheader.readFully(names);\nint nextFile = 0;\nint nextName = 0;\nfor (int i = 0; i < names.length; i += 2) {\nif (names[i] == 0 && names[i+1] == 0) {\nfiles[nextFile++].setName(new String(names, nextName, i-nextName, CharsetNames.UTF_16LE));\nnextName = i + 2;\nif (nextName != names.length || nextFile != files.length) {\nbreak;\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasLastModifiedDate(timesDefined.get(i));\nif (files[i].getHasLastModifiedDate()) {\nfiles[i].setLastModifiedDate(Long.reverseBytes(header.readLong()));\nbreak;\nthrow new IOException(\"Unknown property \" + propertyType);\n}\nint nonEmptyFileCounter = 0;\nint emptyFileCounter = 0;\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasStream((isEmptyStream == null) ? true : !isEmptyStream.get(i));\nif (files[i].hasStream()) {\nfiles[i].setDirectory(false);\nfiles[i].setAntiItem(false);\nfiles[i].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nfiles[i].setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nfiles[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\nfiles[i].setDirectory((isEmptyFile == null) ? true : !isEmptyFile.get(emptyFileCounter));\nfiles[i].setAntiItem((isAnti == null) ? false : isAnti.get(emptyFileCounter));\nfiles[i].setHasCrc(false);\nfiles[i].setSize(0);\n++emptyFileCounter;\narchive.files = files;\ncalculateStreamMap(archive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUint64(Ljava/io/DataInput;)J",
                                    "method_body": "private static long readUint64(final DataInput in) throws IOException {\nlong firstByte = in.readUnsignedByte();\nint mask = 0x80;\nlong value = 0;\nfor (int i = 0; i < 8; i++) {\nif ((firstByte & mask) == 0) {\nreturn value | ((firstByte & (mask - 1)) << (8 * i));\nlong nextByte = in.readUnsignedByte();\nvalue |= (nextByte << (8 * i));\nmask >>>= 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;JJ)V",
                                    "method_body": "public ChecksumVerifyingInputStream(final Checksum checksum, final InputStream in,\nfinal long size, final long expectedChecksum) {\nthis.checksum = checksum;\nthis.in = in;\nthis.expectedChecksum = expectedChecksum;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining <= 0) {\nint ret = in.read();\nif (ret >= 0) {\nchecksum.update(ret);\n--bytesRemaining;\nif (bytesRemaining == 0 && expectedChecksum != checksum.getValue()) {\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nint ret = in.read(b, off, len);\nif (ret >= 0) {\nchecksum.update(b, off, ret);\nbytesRemaining -= ret;\nif (bytesRemaining <= 0 && expectedChecksum != checksum.getValue()) {\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nin.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CRC32VerifyingInputStream:<init>(Ljava/io/InputStream;JJ)V",
                                    "method_body": "public CRC32VerifyingInputStream(final InputStream in, final long size, final long expectedCrc32) {\nsuper(new CRC32(), in, size, expectedCrc32);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:<init>(Ljava/io/RandomAccessFile;J)V",
                                    "method_body": "public BoundedRandomAccessFileInputStream(final RandomAccessFile file,\nfinal long size) {\nthis.file = file;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining > 0) {\n--bytesRemaining;\nreturn file.read();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif (bytesRemaining == 0) {\nint bytesToRead = len;\nif (bytesToRead > bytesRemaining) {\nfinal int bytesRead = file.read(b, off, bytesToRead);\nif (bytesRead >= 0) {\nbytesRemaining -= bytesRead;\nreturn bytesRead;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:close()V",
                                    "method_body": "public void close() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setAntiItem(Z)V",
                                    "method_body": "public void setAntiItem(boolean isAntiItem) {\nthis.isAntiItem = isAntiItem;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasLastModifiedDate(Z)V",
                                    "method_body": "public void setHasLastModifiedDate(boolean hasLastModifiedDate) {\nthis.hasLastModifiedDate = hasLastModifiedDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setLastModifiedDate(J)V",
                                    "method_body": "public void setLastModifiedDate(long ntfsLastModifiedDate) {\nthis.lastModifiedDate = ntfsLastModifiedDate;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest.testEightEmptyFiles",
                            "test_body": "190: public void testEightEmptyFiles() throws Exception {\n191: testCompress252(8, 0);\n192: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:<init>()V",
                                    "method_body": "public SevenZArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "public void setName(String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:hasStream()Z",
                                    "method_body": "public boolean hasStream() {\nreturn hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasStream(Z)V",
                                    "method_body": "public void setHasStream(boolean hasStream) {\nthis.hasStream = hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nreturn isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setDirectory(Z)V",
                                    "method_body": "public void setDirectory(boolean isDirectory) {\nthis.isDirectory = isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isAntiItem()Z",
                                    "method_body": "public boolean isAntiItem() {\nreturn isAntiItem;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasCreationDate()Z",
                                    "method_body": "public boolean getHasCreationDate() {\nreturn hasCreationDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasLastModifiedDate()Z",
                                    "method_body": "public boolean getHasLastModifiedDate() {\nreturn hasLastModifiedDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getLastModifiedDate()Ljava/util/Date;",
                                    "method_body": "public Date getLastModifiedDate() {\nif (hasLastModifiedDate) {\nreturn ntfsTimeToJavaTime(lastModifiedDate);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setLastModifiedDate(Ljava/util/Date;)V",
                                    "method_body": "public void setLastModifiedDate(Date lastModifiedDate) {\nhasLastModifiedDate = lastModifiedDate != null;\nif (hasLastModifiedDate) {\nthis.lastModifiedDate = javaTimeToNtfsTime(lastModifiedDate);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasAccessDate()Z",
                                    "method_body": "public boolean getHasAccessDate() {\nreturn hasAccessDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasWindowsAttributes()Z",
                                    "method_body": "public boolean getHasWindowsAttributes() {\nreturn hasWindowsAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasCrc(Z)V",
                                    "method_body": "public void setHasCrc(boolean hasCrc) {\nthis.hasCrc = hasCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCompressedSize(J)V",
                                    "method_body": "void setCompressedSize(long size) {\nthis.compressedSize = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:ntfsTimeToJavaTime(J)Ljava/util/Date;",
                                    "method_body": "public static Date ntfsTimeToJavaTime(final long ntfsTime) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nfinal long realTime = ntfsEpoch.getTimeInMillis() + (ntfsTime / (10*1000));\nreturn new Date(realTime);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:javaTimeToNtfsTime(Ljava/util/Date;)J",
                                    "method_body": "public static long javaTimeToNtfsTime(final Date date) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nreturn ((date.getTime() - ntfsEpoch.getTimeInMillis())* 1000 * 10);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:<init>(Ljava/io/File;)V",
                                    "method_body": "private final RandomAccessFile file;\nprivate final List<SevenZArchiveEntry> files = new ArrayList<SevenZArchiveEntry>();\nprivate int numNonEmptyStreams = 0;\nprivate CRC32 crc32 = new CRC32();\nprivate CRC32 compressedCrc32 = new CRC32();\nprivate long fileBytesWritten = 0;\nprivate boolean finished = false;\nprivate SevenZMethod contentCompression = SevenZMethod.LZMA2;\npublic SevenZOutputFile(final File filename) throws IOException {\nfile = new RandomAccessFile(filename, \"rw\");\nfile.seek(SevenZFile.SIGNATURE_HEADER_SIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!finished) {\nfinish();\nfile.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:createArchiveEntry(Ljava/io/File;Ljava/lang/String;)Lorg/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry;",
                                    "method_body": "public SevenZArchiveEntry createArchiveEntry(final File inputFile,\nfinal SevenZArchiveEntry entry = new SevenZArchiveEntry();\nentry.setDirectory(inputFile.isDirectory());\nentry.setName(entryName);\nentry.setLastModifiedDate(new Date(inputFile.lastModified()));\nreturn entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\nfinal SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;\nfiles.add(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (currentOutputStream != null) {\ncurrentOutputStream.flush();\ncurrentOutputStream.close();\nfinal SevenZArchiveEntry entry = files.get(files.size() - 1);\nif (fileBytesWritten > 0) {\nentry.setHasStream(true);\n++numNonEmptyStreams;\nentry.setSize(currentOutputStream.getBytesWritten());\nentry.setCompressedSize(fileBytesWritten);\nentry.setCrcValue(crc32.getValue());\nentry.setCompressedCrcValue(compressedCrc32.getValue());\nentry.setHasCrc(true);\nentry.setHasStream(false);\nentry.setSize(0);\nentry.setCompressedSize(0);\nentry.setHasCrc(false);\ncurrentOutputStream = null;\ncrc32.reset();\ncompressedCrc32.reset();\nfileBytesWritten = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([B)V",
                                    "method_body": "public void write(final byte[] b) throws IOException {\nwrite(b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int off, final int len) throws IOException {\nif (len > 0) {\ngetCurrentOutputStream().write(b, off, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif (finished) {\nfinished = true;\nfinal long headerPosition = file.getFilePointer();\nfinal ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();\nfinal DataOutputStream header = new DataOutputStream(headerBaos);\nwriteHeader(header);\nheader.flush();\nfinal byte[] headerBytes = headerBaos.toByteArray();\nfile.write(headerBytes);\nfinal CRC32 crc32 = new CRC32();\nfile.seek(0);\nfile.write(SevenZFile.sevenZSignature);\nfile.write(0);\nfile.write(2);\nfinal ByteArrayOutputStream startHeaderBaos = new ByteArrayOutputStream();\nfinal DataOutputStream startHeaderStream = new DataOutputStream(startHeaderBaos);\nstartHeaderStream.writeLong(Long.reverseBytes(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE));\nstartHeaderStream.writeLong(Long.reverseBytes(0xffffFFFFL & headerBytes.length));\ncrc32.reset();\ncrc32.update(headerBytes);\nstartHeaderStream.writeInt(Integer.reverseBytes((int)crc32.getValue()));\nstartHeaderStream.flush();\nfinal byte[] startHeaderBytes = startHeaderBaos.toByteArray();\ncrc32.reset();\ncrc32.update(startHeaderBytes);\nfile.writeInt(Integer.reverseBytes((int) crc32.getValue()));\nfile.write(startHeaderBytes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeHeader(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeHeader(final DataOutput header) throws IOException {\nheader.write(NID.kHeader);\nheader.write(NID.kMainStreamsInfo);\nwriteStreamsInfo(header);\nwriteFilesInfo(header);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeStreamsInfo(final DataOutput header) throws IOException {\nif (numNonEmptyStreams > 0) {\nwritePackInfo(header);\nwriteUnpackInfo(header);\nwriteSubStreamsInfo(header);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeSubStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeSubStreamsInfo(final DataOutput header) throws IOException {\nheader.write(NID.kSubStreamsInfo);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFilesInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFilesInfo(final DataOutput header) throws IOException {\nheader.write(NID.kFilesInfo);\nwriteUint64(header, files.size());\nwriteFileEmptyStreams(header);\nwriteFileEmptyFiles(header);\nwriteFileAntiItems(header);\nwriteFileNames(header);\nwriteFileCTimes(header);\nwriteFileATimes(header);\nwriteFileMTimes(header);\nwriteFileWindowsAttributes(header);\nheader.write(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyStreams(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyStreams(final DataOutput header) throws IOException {\nboolean hasEmptyStreams = false;\nfor (final SevenZArchiveEntry entry : files) {\nif (!entry.hasStream()) {\nhasEmptyStreams = true;\nbreak;\nif (hasEmptyStreams) {\nheader.write(NID.kEmptyStream);\nfinal BitSet emptyStreams = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nemptyStreams.set(i, !files.get(i).hasStream());\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyStreams, files.size());\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyFiles(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyFiles(final DataOutput header) throws IOException {\nboolean hasEmptyFiles = false;\nint emptyStreamCounter = 0;\nfinal BitSet emptyFiles = new BitSet(0);\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isDir = files.get(i).isDirectory();\nemptyFiles.set(emptyStreamCounter++, !isDir);\nhasEmptyFiles |= !isDir;\nif (hasEmptyFiles) {\nheader.write(NID.kEmptyFile);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyFiles, emptyStreamCounter);\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileAntiItems(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileAntiItems(final DataOutput header) throws IOException {\nboolean hasAntiItems = false;\nfinal BitSet antiItems = new BitSet(0);\nint antiItemCounter = 0;\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isAnti = files.get(i).isAntiItem();\nantiItems.set(antiItemCounter++, isAnti);\nhasAntiItems |= isAnti;\nif (hasAntiItems) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileNames(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileNames(final DataOutput header) throws IOException {\nheader.write(NID.kName);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nout.write(entry.getName().getBytes(\"UTF-16LE\"));\nout.writeShort(0);\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileCTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileCTimes(final DataOutput header) throws IOException {\nint numCreationDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasCreationDate()) {\n}\nif (numCreationDates > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileATimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileATimes(final DataOutput header) throws IOException {\nint numAccessDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasAccessDate()) {\n}\nif (numAccessDates > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileMTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileMTimes(final DataOutput header) throws IOException {\nint numLastModifiedDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\n++numLastModifiedDates;\n}\nif (numLastModifiedDates > 0) {\nheader.write(NID.kMTime);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numLastModifiedDates != files.size()) {\nout.write(0);\nfinal BitSet mTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nmTimes.set(i, files.get(i).getHasLastModifiedDate());\nwriteBits(out, mTimes, files.size());\n} else {\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\nout.writeLong(Long.reverseBytes(\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileWindowsAttributes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileWindowsAttributes(final DataOutput header) throws IOException {\nint numWindowsAttributes = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasWindowsAttributes()) {\n}\nif (numWindowsAttributes > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeUint64(Ljava/io/DataOutput;J)V",
                                    "method_body": "private void writeUint64(final DataOutput header, long value) throws IOException {\nint firstByte = 0;\nint mask = 0x80;\nfor (i = 0; i < 8; i++) {\nif (value < ((1L << ( 7  * (i + 1))))) {\nfirstByte |= (value >>> (8 * i));\nbreak;\nfirstByte |= mask;\nmask >>>= 1;\nheader.write(firstByte);\nfor (; i > 0; i--) {\nheader.write((int) (0xff & value));\nvalue >>>= 8;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeBits(Ljava/io/DataOutput;Ljava/util/BitSet;I)V",
                                    "method_body": "private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\nint cache = 0;\nint shift = 7;\nfor (int i = 0; i < length; i++) {\ncache |= ((bits.get(i) ? 1 : 0) << shift);\n--shift;\nif (shift == 0) {\nheader.write(cache);\nshift = 7;\ncache = 0;\nif (length > 0 && shift > 0) {\nheader.write(cache);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:<init>(Ljava/lang/String;I[B)V",
                                    "method_body": "private SevenZMethod(byte[] id) {\nthis.id = id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;[B)V",
                                    "method_body": "public SevenZFile(final File filename, final byte[] password) throws IOException {\nboolean succeeded = false;\nthis.file = new RandomAccessFile(filename, \"r\");\narchive = readHeaders(password);\nif (!succeeded) {\nthis.file.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZFile(final File filename) throws IOException {\nthis(filename, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<clinit>()V",
                                    "method_body": "static final int SIGNATURE_HEADER_SIZE = 32;\nprivate int currentEntryIndex = -1;\nprivate int currentFolderIndex = -1;\nprivate InputStream currentFolderInputStream = null;\nprivate InputStream currentEntryInputStream = null;\nstatic final byte[] sevenZSignature = {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeaders([B)Lorg/apache/commons/compress/archivers/sevenz/Archive;",
                                    "method_body": "private Archive readHeaders(byte[] password) throws IOException {\nfinal byte[] signature = new byte[6];\nfile.readFully(signature);\nif (!Arrays.equals(signature, sevenZSignature)) {\nfinal byte archiveVersionMajor = file.readByte();\nfinal byte archiveVersionMinor = file.readByte();\nif (archiveVersionMajor != 0) {\nfinal long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\nfinal StartHeader startHeader = readStartHeader(startHeaderCrc);\nfinal int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\nif (nextHeaderSizeInt != startHeader.nextHeaderSize) {\nfile.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\nfinal byte[] nextHeader = new byte[nextHeaderSizeInt];\nfile.readFully(nextHeader);\nfinal CRC32 crc = new CRC32();\ncrc.update(nextHeader);\nif (startHeader.nextHeaderCrc != crc.getValue()) {\nfinal ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\nDataInputStream nextHeaderInputStream = new DataInputStream(\nArchive archive = new Archive();\nint nid = nextHeaderInputStream.readUnsignedByte();\nif (nid == NID.kEncodedHeader) {\nif (nid == NID.kHeader) {\nreadHeader(nextHeaderInputStream, archive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStartHeader(J)Lorg/apache/commons/compress/archivers/sevenz/StartHeader;",
                                    "method_body": "private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\nfinal StartHeader startHeader = new StartHeader();\nDataInputStream dataInputStream = null;\ndataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\nstartHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\nreturn startHeader;\nif (dataInputStream != null) {\ndataInputStream.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\nif (nid == NID.kPackInfo) {\nreadPackInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid == NID.kUnpackInfo) {\nreadUnpackInfo(header, archive);\nnid = header.readUnsignedByte();\narchive.folders = new Folder[0];\nif (nid == NID.kSubStreamsInfo) {\nreadSubStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid != NID.kEnd) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readSubStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nfor (final Folder folder : archive.folders) {\nfolder.numUnpackSubStreams = 1;\nint totalUnpackStreams = archive.folders.length;\nint nid = header.readUnsignedByte();\nif (nid == NID.kNumUnpackStream) {\nfinal SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\nsubStreamsInfo.unpackSizes = new long[totalUnpackStreams];\nsubStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\nsubStreamsInfo.crcs = new long[totalUnpackStreams];\nint nextUnpackStream = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams == 0) {\nlong sum = 0;\nif (nid == NID.kSize) {\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;\nif (nid == NID.kSize) {\nint numDigests = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {\nif (nid == NID.kCRC) {\nif (nid != NID.kEnd) {\narchive.subStreamsInfo = subStreamsInfo;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readBits(final DataInput header, final int size) throws IOException {\nfinal BitSet bits = new BitSet(size);\nint mask = 0;\nint cache = 0;\nfor (int i = 0; i < size; i++) {\nif (mask == 0) {\nmask = 0x80;\ncache = header.readUnsignedByte();\nbits.set(i, (cache & mask) != 0);\nmask >>>= 1;\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFilesInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readFilesInfo(final DataInput header, final Archive archive) throws IOException {\nfinal long numFiles = readUint64(header);\nfinal SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\nfor (int i = 0; i < files.length; i++) {\nfiles[i] = new SevenZArchiveEntry();\nBitSet isEmptyStream = null;\nBitSet isEmptyFile = null;\nBitSet isAnti = null;\nfinal int propertyType = header.readUnsignedByte();\nif (propertyType == 0) {\nbreak;\nlong size = readUint64(header);\nswitch (propertyType) {\nisEmptyStream = readBits(header, files.length);\nbreak;\nif (isEmptyStream == null) { // protect against NPE\nisEmptyFile = readBits(header, isEmptyStream.cardinality());\nbreak;\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nif (((size - 1) & 1) != 0) {\nfinal byte[] names = new byte[(int)(size - 1)];\nheader.readFully(names);\nint nextFile = 0;\nint nextName = 0;\nfor (int i = 0; i < names.length; i += 2) {\nif (names[i] == 0 && names[i+1] == 0) {\nfiles[nextFile++].setName(new String(names, nextName, i-nextName, CharsetNames.UTF_16LE));\nnextName = i + 2;\nif (nextName != names.length || nextFile != files.length) {\nbreak;\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasLastModifiedDate(timesDefined.get(i));\nif (files[i].getHasLastModifiedDate()) {\nfiles[i].setLastModifiedDate(Long.reverseBytes(header.readLong()));\nbreak;\nthrow new IOException(\"Unknown property \" + propertyType);\n}\nint nonEmptyFileCounter = 0;\nint emptyFileCounter = 0;\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasStream((isEmptyStream == null) ? true : !isEmptyStream.get(i));\nif (files[i].hasStream()) {\nfiles[i].setDirectory(false);\nfiles[i].setAntiItem(false);\nfiles[i].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nfiles[i].setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nfiles[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\nfiles[i].setDirectory((isEmptyFile == null) ? true : !isEmptyFile.get(emptyFileCounter));\nfiles[i].setAntiItem((isAnti == null) ? false : isAnti.get(emptyFileCounter));\nfiles[i].setHasCrc(false);\nfiles[i].setSize(0);\n++emptyFileCounter;\narchive.files = files;\ncalculateStreamMap(archive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUint64(Ljava/io/DataInput;)J",
                                    "method_body": "private static long readUint64(final DataInput in) throws IOException {\nlong firstByte = in.readUnsignedByte();\nint mask = 0x80;\nlong value = 0;\nfor (int i = 0; i < 8; i++) {\nif ((firstByte & mask) == 0) {\nreturn value | ((firstByte & (mask - 1)) << (8 * i));\nlong nextByte = in.readUnsignedByte();\nvalue |= (nextByte << (8 * i));\nmask >>>= 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;JJ)V",
                                    "method_body": "public ChecksumVerifyingInputStream(final Checksum checksum, final InputStream in,\nfinal long size, final long expectedChecksum) {\nthis.checksum = checksum;\nthis.in = in;\nthis.expectedChecksum = expectedChecksum;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining <= 0) {\nint ret = in.read();\nif (ret >= 0) {\nchecksum.update(ret);\n--bytesRemaining;\nif (bytesRemaining == 0 && expectedChecksum != checksum.getValue()) {\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nint ret = in.read(b, off, len);\nif (ret >= 0) {\nchecksum.update(b, off, ret);\nbytesRemaining -= ret;\nif (bytesRemaining <= 0 && expectedChecksum != checksum.getValue()) {\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nin.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CRC32VerifyingInputStream:<init>(Ljava/io/InputStream;JJ)V",
                                    "method_body": "public CRC32VerifyingInputStream(final InputStream in, final long size, final long expectedCrc32) {\nsuper(new CRC32(), in, size, expectedCrc32);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:<init>(Ljava/io/RandomAccessFile;J)V",
                                    "method_body": "public BoundedRandomAccessFileInputStream(final RandomAccessFile file,\nfinal long size) {\nthis.file = file;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining > 0) {\n--bytesRemaining;\nreturn file.read();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif (bytesRemaining == 0) {\nint bytesToRead = len;\nif (bytesToRead > bytesRemaining) {\nfinal int bytesRead = file.read(b, off, bytesToRead);\nif (bytesRead >= 0) {\nbytesRemaining -= bytesRead;\nreturn bytesRead;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:close()V",
                                    "method_body": "public void close() {\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 22,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.compressors.bzip2.PythonTruncatedBzip2Test.testPartialReadTruncatedData",
                            "test_body": "85: public void testPartialReadTruncatedData() throws IOException {\n86: //with BZ2File(self.filename) as f:\n87: //    self.assertEqual(f.read(len(self.TEXT)), self.TEXT)\n88: //    self.assertRaises(EOFError, f.read, 1)\n89: 90: final int length = TEXT.length();\n91: ByteBuffer buffer = ByteBuffer.allocate(length);\n92: bz2Channel.read(buffer);\n93: 94: assertArrayEquals(Arrays.copyOfRange(TEXT.getBytes(), 0, length),\n95: buffer.array());\n96: 97: // subsequent read should throw\n98: buffer = ByteBuffer.allocate(1);\n99: try {\n100: bz2Channel.read(buffer);\n101: Assert.fail(\"The read should have thrown.\");\n102: } catch (IOException e) {\n103: // pass\n104: }\n105: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.CompressorInputStream:count(I)V",
                                    "method_body": "protected void count(int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.CompressorInputStream:count(J)V",
                                    "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public BZip2CompressorOutputStream(final OutputStream out)\nthis(out, MAX_BLOCKSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:<init>(Ljava/io/OutputStream;I)V",
                                    "method_body": "public BZip2CompressorOutputStream(final OutputStream out, final int blockSize) throws IOException {\nif (blockSize < 1) {\nif (blockSize > 9) {\nthis.blockSize100k = blockSize;\nthis.out = out;\nthis.allowableBlockSize = (this.blockSize100k * BZip2Constants.BASEBLOCKSIZE) - 20;\ninit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:hbMakeCodeLengths([B[ILorg/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream$Data;II)V",
                                    "method_body": "private static void hbMakeCodeLengths(final byte[] len, final int[] freq,\nfinal int[] heap = dat.heap;\nfinal int[] weight = dat.weight;\nfinal int[] parent = dat.parent;\nfor (int i = alphaSize; --i >= 0;) {\nweight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;\nfor (boolean tooLong = true; tooLong;) {\ntooLong = false;\nint nNodes = alphaSize;\nint nHeap = 0;\nheap[0] = 0;\nweight[0] = 0;\nparent[0] = -2;\nfor (int i = 1; i <= alphaSize; i++) {\nparent[i] = -1;\nnHeap++;\nheap[nHeap] = i;\nint zz = nHeap;\nint tmp = heap[zz];\nwhile (weight[tmp] < weight[heap[zz >> 1]]) {\nheap[zz] = heap[zz >> 1];\nzz >>= 1;\nheap[zz] = tmp;\nwhile (nHeap > 1) {\nint n1 = heap[1];\nheap[1] = heap[nHeap];\nnHeap--;\nint yy = 0;\nint zz = 1;\nint tmp = heap[1];\nyy = zz << 1;\nif (yy > nHeap) {\nbreak;\nif ((yy < nHeap)\nyy++;\nif (weight[tmp] < weight[heap[yy]]) {\nbreak;\nheap[zz] = heap[yy];\nzz = yy;\nheap[zz] = tmp;\nint n2 = heap[1];\nheap[1] = heap[nHeap];\nnHeap--;\nyy = 0;\nzz = 1;\ntmp = heap[1];\nyy = zz << 1;\nif (yy > nHeap) {\nbreak;\nif ((yy < nHeap)\nyy++;\nif (weight[tmp] < weight[heap[yy]]) {\nbreak;\nheap[zz] = heap[yy];\nzz = yy;\nheap[zz] = tmp;\nnNodes++;\nparent[n1] = parent[n2] = nNodes;\nfinal int weight_n1 = weight[n1];\nfinal int weight_n2 = weight[n2];\nweight[nNodes] = ((weight_n1 & 0xffffff00)\nparent[nNodes] = -1;\nnHeap++;\nheap[nHeap] = nNodes;\ntmp = 0;\nzz = nHeap;\ntmp = heap[zz];\nfinal int weight_tmp = weight[tmp];\nwhile (weight_tmp < weight[heap[zz >> 1]]) {\nheap[zz] = heap[zz >> 1];\nzz >>= 1;\nheap[zz] = tmp;\n}\nfor (int i = 1; i <= alphaSize; i++) {\nint j = 0;\nint k = i;\nfor (int parent_k; (parent_k = parent[k]) >= 0;) {\nk = parent_k;\nj++;\nlen[i - 1] = (byte) j;\nif (j > maxLen) {\nif (tooLong) {\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:writeRun()V",
                                    "method_body": "private void writeRun() throws IOException {\nfinal int lastShadow = this.last;\nif (lastShadow < this.allowableBlockSize) {\nfinal int currentCharShadow = this.currentChar;\nfinal Data dataShadow = this.data;\ndataShadow.inUse[currentCharShadow] = true;\nfinal byte ch = (byte) currentCharShadow;\nint runLengthShadow = this.runLength;\nthis.crc.updateCRC(currentCharShadow, runLengthShadow);\nswitch (runLengthShadow) {\ndataShadow.block[lastShadow + 2] = ch;\nthis.last = lastShadow + 1;\nbreak;\ndataShadow.block[lastShadow + 2] = ch;\ndataShadow.block[lastShadow + 3] = ch;\nthis.last = lastShadow + 2;\nbreak;\nfinal byte[] block = dataShadow.block;\nblock[lastShadow + 2] = ch;\nblock[lastShadow + 3] = ch;\nblock[lastShadow + 4] = ch;\nthis.last = lastShadow + 3;\nbreak;\n} else {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif (out != null) {\nif (this.runLength > 0) {\nwriteRun();\nthis.currentChar = -1;\nendBlock();\nendCompression();\nthis.out = null;\nthis.data = null;\nthis.blockSorter = null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif (out != null) {\nOutputStream outShadow = this.out;\nfinish();\noutShadow.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:init()V",
                                    "method_body": "private void init() throws IOException {\nbsPutUByte('B');\nbsPutUByte('Z');\nthis.data = new Data(this.blockSize100k);\nthis.blockSorter = new BlockSort(this.data);\nbsPutUByte('h');\nbsPutUByte('0' + this.blockSize100k);\nthis.combinedCRC = 0;\ninitBlock();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:initBlock()V",
                                    "method_body": "private void initBlock() {\nthis.crc.initialiseCRC();\nthis.last = -1;\nboolean[] inUse = this.data.inUse;\nfor (int i = 256; --i >= 0;) {\ninUse[i] = false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:endBlock()V",
                                    "method_body": "private void endBlock() throws IOException {\nthis.blockCRC = this.crc.getFinalCRC();\nthis.combinedCRC = (this.combinedCRC << 1) | (this.combinedCRC >>> 31);\nthis.combinedCRC ^= this.blockCRC;\nif (this.last == -1) {\nblockSort();\nbsPutUByte(0x31);\nbsPutUByte(0x41);\nbsPutUByte(0x59);\nbsPutUByte(0x26);\nbsPutUByte(0x53);\nbsPutUByte(0x59);\nbsPutInt(this.blockCRC);\nbsW(1, 0);\nmoveToFrontCodeAndSend();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:endCompression()V",
                                    "method_body": "private void endCompression() throws IOException {\nbsPutUByte(0x17);\nbsPutUByte(0x72);\nbsPutUByte(0x45);\nbsPutUByte(0x38);\nbsPutUByte(0x50);\nbsPutUByte(0x90);\nbsPutInt(this.combinedCRC);\nbsFinishedWithStream();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:write([BII)V",
                                    "method_body": "public void write(final byte[] buf, int offs, final int len)\nif (offs < 0) {\nif (len < 0) {\nif (offs + len > buf.length) {\nif (this.out == null) {\nfor (int hi = offs + len; offs < hi;) {\nwrite0(buf[offs++]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:write0(I)V",
                                    "method_body": "private void write0(int b) throws IOException {\nif (this.currentChar != -1) {\nb &= 0xff;\nif (this.currentChar == b) {\nif (++this.runLength > 254) {\nwriteRun();\nthis.runLength = 1;\nthis.currentChar = b;\nthis.currentChar = b & 0xff;\nthis.runLength++;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:hbAssignCodes([I[BIII)V",
                                    "method_body": "private static void hbAssignCodes(final int[] code, final byte[] length,\nint vec = 0;\nfor (int n = minLen; n <= maxLen; n++) {\nfor (int i = 0; i < alphaSize; i++) {\nif ((length[i] & 0xff) == n) {\ncode[i] = vec;\nvec++;\nvec <<= 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:bsFinishedWithStream()V",
                                    "method_body": "private void bsFinishedWithStream() throws IOException {\nwhile (this.bsLive > 0) {\nint ch = this.bsBuff >> 24;\nthis.out.write(ch); // write 8-bit\nthis.bsBuff <<= 8;\nthis.bsLive -= 8;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:bsW(II)V",
                                    "method_body": "private void bsW(final int n, final int v) throws IOException {\nfinal OutputStream outShadow = this.out;\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\nthis.bsBuff = bsBuffShadow | (v << (32 - bsLiveShadow - n));\nthis.bsLive = bsLiveShadow + n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:bsPutUByte(I)V",
                                    "method_body": "private void bsPutUByte(final int c) throws IOException {\nbsW(8, c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:bsPutInt(I)V",
                                    "method_body": "private void bsPutInt(final int u) throws IOException {\nbsW(8, (u >> 24) & 0xff);\nbsW(8, (u >> 16) & 0xff);\nbsW(8, (u >> 8) & 0xff);\nbsW(8, u & 0xff);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues()V",
                                    "method_body": "private void sendMTFValues() throws IOException {\nfinal byte[][] len = this.data.sendMTFValues_len;\nfinal int alphaSize = this.nInUse + 2;\nfor (int t = N_GROUPS; --t >= 0;) {\nbyte[] len_t = len[t];\nfor (int v = alphaSize; --v >= 0;) {\nlen_t[v] = GREATER_ICOST;\n}\nfinal int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3\nsendMTFValues0(nGroups, alphaSize);\nfinal int nSelectors = sendMTFValues1(nGroups, alphaSize);\nsendMTFValues2(nGroups, nSelectors);\nsendMTFValues3(nGroups, alphaSize);\nsendMTFValues4();\nsendMTFValues5(nGroups, nSelectors);\nsendMTFValues6(nGroups, alphaSize);\nsendMTFValues7();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues0(II)V",
                                    "method_body": "private void sendMTFValues0(final int nGroups, final int alphaSize) {\nfinal byte[][] len = this.data.sendMTFValues_len;\nfinal int[] mtfFreq = this.data.mtfFreq;\nint remF = this.nMTF;\nint gs = 0;\nfor (int nPart = nGroups; nPart > 0; nPart--) {\nfinal int tFreq = remF / nPart;\nint ge = gs - 1;\nint aFreq = 0;\nfor (final int a = alphaSize - 1; (aFreq < tFreq) && (ge < a);) {\naFreq += mtfFreq[++ge];\nif ((ge > gs) && (nPart != nGroups) && (nPart != 1)\naFreq -= mtfFreq[ge--];\nfinal byte[] len_np = len[nPart - 1];\nfor (int v = alphaSize; --v >= 0;) {\nif ((v >= gs) && (v <= ge)) {\nlen_np[v] = LESSER_ICOST;\nlen_np[v] = GREATER_ICOST;\ngs = ge + 1;\nremF -= aFreq;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues1(II)I",
                                    "method_body": "private int sendMTFValues1(final int nGroups, final int alphaSize) {\nfinal Data dataShadow = this.data;\nfinal int[][] rfreq = dataShadow.sendMTFValues_rfreq;\nfinal int[] fave = dataShadow.sendMTFValues_fave;\nfinal short[] cost = dataShadow.sendMTFValues_cost;\nfinal char[] sfmap = dataShadow.sfmap;\nfinal byte[] selector = dataShadow.selector;\nfinal byte[][] len = dataShadow.sendMTFValues_len;\nfinal byte[] len_0 = len[0];\nfinal byte[] len_1 = len[1];\nfinal byte[] len_2 = len[2];\nfinal byte[] len_3 = len[3];\nfinal byte[] len_4 = len[4];\nfinal byte[] len_5 = len[5];\nfinal int nMTFShadow = this.nMTF;\nint nSelectors = 0;\nfor (int iter = 0; iter < N_ITERS; iter++) {\nfor (int t = nGroups; --t >= 0;) {\nfave[t] = 0;\nint[] rfreqt = rfreq[t];\nfor (int i = alphaSize; --i >= 0;) {\nrfreqt[i] = 0;\n}\nnSelectors = 0;\nfor (int gs = 0; gs < this.nMTF;) {\nfinal int ge = Math.min(gs + G_SIZE - 1, nMTFShadow - 1);\nif (nGroups == N_GROUPS) {\nfor (int t = nGroups; --t >= 0;) {\ncost[t] = 0;\nfor (int i = gs; i <= ge; i++) {\nfinal int icv = sfmap[i];\nfor (int t = nGroups; --t >= 0;) {\ncost[t] += len[t][icv] & 0xff;\nint bt = -1;\nfor (int t = nGroups, bc = 999999999; --t >= 0;) {\nfinal int cost_t = cost[t];\nif (cost_t < bc) {\nbc = cost_t;\nbt = t;\n}\nfave[bt]++;\nselector[nSelectors] = (byte) bt;\nnSelectors++;\nfinal int[] rfreq_bt = rfreq[bt];\nfor (int i = gs; i <= ge; i++) {\nrfreq_bt[sfmap[i]]++;\ngs = ge + 1;\n}\nfor (int t = 0; t < nGroups; t++) {\nhbMakeCodeLengths(len[t], rfreq[t], this.data, alphaSize, 20);\nreturn nSelectors;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues2(II)V",
                                    "method_body": "private void sendMTFValues2(final int nGroups, final int nSelectors) {\nfinal Data dataShadow = this.data;\nbyte[] pos = dataShadow.sendMTFValues2_pos;\nfor (int i = nGroups; --i >= 0;) {\npos[i] = (byte) i;\nfor (int i = 0; i < nSelectors; i++) {\nfinal byte ll_i = dataShadow.selector[i];\nbyte tmp = pos[0];\nint j = 0;\nwhile (ll_i != tmp) {\nj++;\nbyte tmp2 = tmp;\ntmp = pos[j];\npos[j] = tmp2;\n}\npos[0] = tmp;\ndataShadow.selectorMtf[i] = (byte) j;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues3(II)V",
                                    "method_body": "private void sendMTFValues3(final int nGroups, final int alphaSize) {\nint[][] code = this.data.sendMTFValues_code;\nbyte[][] len = this.data.sendMTFValues_len;\nfor (int t = 0; t < nGroups; t++) {\nint minLen = 32;\nint maxLen = 0;\nfinal byte[] len_t = len[t];\nfor (int i = alphaSize; --i >= 0;) {\nfinal int l = len_t[i] & 0xff;\nif (l > maxLen) {\nmaxLen = l;\nif (l < minLen) {\nminLen = l;\n}\nhbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues4()V",
                                    "method_body": "private void sendMTFValues4() throws IOException {\nfinal boolean[] inUse = this.data.inUse;\nfinal boolean[] inUse16 = this.data.sentMTFValues4_inUse16;\nfor (int i = 16; --i >= 0;) {\ninUse16[i] = false;\nfinal int i16 = i * 16;\nfor (int j = 16; --j >= 0;) {\nif (inUse[i16 + j]) {\ninUse16[i] = true;\n}\nfor (int i = 0; i < 16; i++) {\nbsW(1, inUse16[i] ? 1 : 0);\nfinal OutputStream outShadow = this.out;\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\nfor (int i = 0; i < 16; i++) {\nif (inUse16[i]) {\nfinal int i16 = i * 16;\nfor (int j = 0; j < 16; j++) {\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\nif (inUse[i16 + j]) {\nbsBuffShadow |= 1 << (32 - bsLiveShadow - 1);\nbsLiveShadow++;\nthis.bsBuff = bsBuffShadow;\nthis.bsLive = bsLiveShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues5(II)V",
                                    "method_body": "private void sendMTFValues5(final int nGroups, final int nSelectors)\nbsW(3, nGroups);\nbsW(15, nSelectors);\nfinal OutputStream outShadow = this.out;\nfinal byte[] selectorMtf = this.data.selectorMtf;\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\nfor (int i = 0; i < nSelectors; i++) {\nfor (int j = 0, hj = selectorMtf[i] & 0xff; j < hj; j++) {\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24);\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\nbsBuffShadow |= 1 << (32 - bsLiveShadow - 1);\nbsLiveShadow++;\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24);\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\nbsLiveShadow++;\nthis.bsBuff = bsBuffShadow;\nthis.bsLive = bsLiveShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues6(II)V",
                                    "method_body": "private void sendMTFValues6(final int nGroups, final int alphaSize)\nfinal byte[][] len = this.data.sendMTFValues_len;\nfinal OutputStream outShadow = this.out;\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\nfor (int t = 0; t < nGroups; t++) {\nbyte[] len_t = len[t];\nint curr = len_t[0] & 0xff;\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\nbsBuffShadow |= curr << (32 - bsLiveShadow - 5);\nbsLiveShadow += 5;\nfor (int i = 0; i < alphaSize; i++) {\nint lti = len_t[i] & 0xff;\nwhile (curr < lti) {\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\nbsBuffShadow |= 2 << (32 - bsLiveShadow - 2);\nbsLiveShadow += 2;\ncurr++; /* 10 */\nwhile (curr > lti) {\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\nbsBuffShadow |= 3 << (32 - bsLiveShadow - 2);\nbsLiveShadow += 2;\ncurr--; /* 11 */\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\nbsLiveShadow++;\nthis.bsBuff = bsBuffShadow;\nthis.bsLive = bsLiveShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues7()V",
                                    "method_body": "private void sendMTFValues7() throws IOException {\nfinal Data dataShadow = this.data;\nfinal byte[][] len = dataShadow.sendMTFValues_len;\nfinal int[][] code = dataShadow.sendMTFValues_code;\nfinal OutputStream outShadow = this.out;\nfinal byte[] selector = dataShadow.selector;\nfinal char[] sfmap = dataShadow.sfmap;\nfinal int nMTFShadow = this.nMTF;\nint selCtr = 0;\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\nfor (int gs = 0; gs < nMTFShadow;) {\nfinal int ge = Math.min(gs + G_SIZE - 1, nMTFShadow - 1);\nfinal int selector_selCtr = selector[selCtr] & 0xff;\nfinal int[] code_selCtr = code[selector_selCtr];\nfinal byte[] len_selCtr = len[selector_selCtr];\nwhile (gs <= ge) {\nfinal int sfmap_i = sfmap[gs];\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24);\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\nfinal int n = len_selCtr[sfmap_i] & 0xFF;\nbsBuffShadow |= code_selCtr[sfmap_i] << (32 - bsLiveShadow - n);\nbsLiveShadow += n;\ngs++;\n}\ngs = ge + 1;\nselCtr++;\n}\nthis.bsBuff = bsBuffShadow;\nthis.bsLive = bsLiveShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:moveToFrontCodeAndSend()V",
                                    "method_body": "private void moveToFrontCodeAndSend() throws IOException {\nbsW(24, this.data.origPtr);\ngenerateMTFValues();\nsendMTFValues();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:blockSort()V",
                                    "method_body": "private void blockSort() {\nblockSorter.blockSort(data, last);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:generateMTFValues()V",
                                    "method_body": "private void generateMTFValues() {\nfinal int lastShadow = this.last;\nfinal Data dataShadow = this.data;\nfinal boolean[] inUse = dataShadow.inUse;\nfinal byte[] block = dataShadow.block;\nfinal int[] fmap = dataShadow.fmap;\nfinal char[] sfmap = dataShadow.sfmap;\nfinal int[] mtfFreq = dataShadow.mtfFreq;\nfinal byte[] unseqToSeq = dataShadow.unseqToSeq;\nfinal byte[] yy = dataShadow.generateMTFValues_yy;\nint nInUseShadow = 0;\nfor (int i = 0; i < 256; i++) {\nif (inUse[i]) {\nunseqToSeq[i] = (byte) nInUseShadow;\nnInUseShadow++;\nthis.nInUse = nInUseShadow;\nfinal int eob = nInUseShadow + 1;\nfor (int i = eob; i >= 0; i--) {\nmtfFreq[i] = 0;\nfor (int i = nInUseShadow; --i >= 0;) {\nyy[i] = (byte) i;\nint wr = 0;\nint zPend = 0;\nfor (int i = 0; i <= lastShadow; i++) {\nfinal byte ll_i = unseqToSeq[block[fmap[i]] & 0xff];\nbyte tmp = yy[0];\nint j = 0;\nwhile (ll_i != tmp) {\nj++;\nbyte tmp2 = tmp;\ntmp = yy[j];\nyy[j] = tmp2;\n}\nyy[0] = tmp;\nif (j == 0) {\nzPend++;\nif (zPend > 0) {\nzPend--;\nif ((zPend & 1) == 0) {\nsfmap[wr] = RUNA;\nwr++;\nmtfFreq[RUNA]++;\nsfmap[wr] = RUNB;\nwr++;\nmtfFreq[RUNB]++;\nif (zPend >= 2) {\nzPend = (zPend - 2) >> 1;\nzPend = 0;\nsfmap[wr] = (char) (j + 1);\nwr++;\nmtfFreq[j + 1]++;\nif (zPend > 0) {\nzPend--;\nif ((zPend & 1) == 0) {\nsfmap[wr] = RUNA;\nwr++;\nmtfFreq[RUNA]++;\nif (zPend >= 2) {\nsfmap[wr] = (char) eob;\nmtfFreq[eob]++;\nthis.nMTF = wr + 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:<init>()V",
                                    "method_body": "CRC() {\ninitialiseCRC();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:<clinit>()V",
                                    "method_body": "private static final int crc32Table[] = {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:initialiseCRC()V",
                                    "method_body": "void initialiseCRC() {\nglobalCrc = 0xffffffff;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:getFinalCRC()I",
                                    "method_body": "int getFinalCRC() {\nreturn ~globalCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:updateCRC(I)V",
                                    "method_body": "void updateCRC(int inCh) {\nint temp = (globalCrc >> 24) ^ inCh;\nif (temp < 0) {\ntemp = 256 + temp;\nglobalCrc = (globalCrc << 8) ^ CRC.crc32Table[temp];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:updateCRC(II)V",
                                    "method_body": "void updateCRC(int inCh, int repeat) {\nint globalCrcShadow = this.globalCrc;\nwhile (repeat-- > 0) {\nint temp = (globalCrcShadow >> 24) ^ inCh;\nglobalCrcShadow = (globalCrcShadow << 8) ^ crc32Table[(temp >= 0)\n}\nthis.globalCrc = globalCrcShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream$Data:<init>(I)V",
                                    "method_body": "final boolean[] inUse = new boolean[256]; // 256 byte\nfinal byte[] unseqToSeq = new byte[256]; // 256 byte\nfinal int[] mtfFreq = new int[MAX_ALPHA_SIZE]; // 1032 byte\nfinal byte[] selector = new byte[MAX_SELECTORS]; // 18002 byte\nfinal byte[] selectorMtf = new byte[MAX_SELECTORS]; // 18002 byte\nfinal byte[] generateMTFValues_yy = new byte[256]; // 256 byte\nfinal byte[][] sendMTFValues_len = new byte[N_GROUPS][MAX_ALPHA_SIZE]; // 1548\nfinal int[][] sendMTFValues_rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192\nfinal int[] sendMTFValues_fave = new int[N_GROUPS]; // 24 byte\nfinal short[] sendMTFValues_cost = new short[N_GROUPS]; // 12 byte\nfinal int[][] sendMTFValues_code = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192\nfinal byte[] sendMTFValues2_pos = new byte[N_GROUPS]; // 6 byte\nfinal boolean[] sentMTFValues4_inUse16 = new boolean[16]; // 16 byte\nfinal int[] heap = new int[MAX_ALPHA_SIZE + 2]; // 1040 byte\nfinal int[] weight = new int[MAX_ALPHA_SIZE * 2]; // 2064 byte\nfinal int[] parent = new int[MAX_ALPHA_SIZE * 2]; // 2064 byte\nData(int blockSize100k) {\nfinal int n = blockSize100k * BZip2Constants.BASEBLOCKSIZE;\nthis.block = new byte[(n + 1 + NUM_OVERSHOOT_BYTES)];\nthis.fmap = new int[n];\nthis.sfmap = new char[2 * n];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:<init>(Lorg/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream$Data;)V",
                                    "method_body": "BlockSort(final BZip2CompressorOutputStream.Data data) {\nthis.quadrant = data.sfmap;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:<clinit>()V",
                                    "method_body": "private static final int[] INCS = { 1, 4, 13, 40, 121, 364, 1093, 3280,\n2391484 };"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:blockSort(Lorg/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream$Data;I)V",
                                    "method_body": "void blockSort(final BZip2CompressorOutputStream.Data data, final int last) {\nthis.workLimit = WORK_FACTOR * last;\nthis.workDone = 0;\nthis.firstAttempt = true;\nif (last + 1 < 10000) {\nfallbackSort(data, last);\nfinal int[] fmap = data.fmap;\ndata.origPtr = -1;\nfor (int i = 0; i <= last; i++) {\nif (fmap[i] == 0) {\ndata.origPtr = i;\nbreak;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fallbackSort(Lorg/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream$Data;I)V",
                                    "method_body": "final void fallbackSort(final BZip2CompressorOutputStream.Data data,\ndata.block[0] = data.block[last + 1];\nfallbackSort(data.fmap, data.block, last + 1);\nfor (int i = 0; i < last + 1; i++) {\n--data.fmap[i];\nfor (int i = 0; i < last + 1; i++) {\nif (data.fmap[i] == -1) {\ndata.fmap[i] = last;\nbreak;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fallbackSimpleSort([I[III)V",
                                    "method_body": "private void fallbackSimpleSort(int[] fmap,\nif (lo == hi) {\nreturn;\nif (hi - lo > 3) {\nfor (int i = hi - 4; i >= lo; i--) {\nint tmp = fmap[i];\nint ec_tmp = eclass[tmp];\nfor (j = i + 4; j <= hi && ec_tmp > eclass[fmap[j]];\nj += 4) {\nfmap[j - 4] = fmap[j];\nfmap[j - 4] = tmp;\nfor (int i = hi - 1; i >= lo; i--) {\nint tmp = fmap[i];\nint ec_tmp = eclass[tmp];\nfor (j = i + 1; j <= hi && ec_tmp > eclass[fmap[j]]; j++) {\nfmap[j - 1] = fmap[j];\nfmap[j-1] = tmp;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fswap([III)V",
                                    "method_body": "private void fswap(int[] fmap, int zz1, int zz2) {\nint zztmp = fmap[zz1];\nfmap[zz1] = fmap[zz2];\nfmap[zz2] = zztmp;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fvswap([IIII)V",
                                    "method_body": "private void fvswap(int[] fmap, int yyp1, int yyp2, int yyn) {\nwhile (yyn > 0) {\nfswap(fmap, yyp1, yyp2);\nyyp1++; yyp2++; yyn--;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fmin(II)I",
                                    "method_body": "private int fmin(int a, int b) {\nreturn a < b ? a : b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fpush(III)V",
                                    "method_body": "private void fpush(int sp, int lz, int hz) {\nstack_ll[sp] = lz;\nstack_hh[sp] = hz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fpop(I)[I",
                                    "method_body": "private int[] fpop(int sp) {\nreturn new int[] { stack_ll[sp], stack_hh[sp] };\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fallbackQSort3([I[III)V",
                                    "method_body": "private void fallbackQSort3(int[] fmap,\nlong r = 0;\nint sp = 0;\nfpush(sp++, loSt, hiSt);\nwhile (sp > 0) {\nint[] s = fpop(--sp);\nlo = s[0]; hi = s[1];\nif (hi - lo < FALLBACK_QSORT_SMALL_THRESH) {\nfallbackSimpleSort(fmap, eclass, lo, hi);\ncontinue;\nr = ((r * 7621) + 1) % 32768;\nlong r3 = r % 3, med;\nif (r3 == 0) {\nmed = eclass[fmap[lo]];\n} else if (r3 == 1) {\nmed = eclass[fmap[(lo + hi) >>> 1]];\nmed = eclass[fmap[hi]];\nunLo = ltLo = lo;\nunHi = gtHi = hi;\nif (unLo > unHi) {\nbreak;\nn = eclass[fmap[unLo]] - (int) med;\nif (n == 0) {\nfswap(fmap, unLo, ltLo);\nltLo++; unLo++;\ncontinue;\nif (n > 0) {\nbreak;\nunLo++;\nif (unLo > unHi) {\nbreak;\nn = eclass[fmap[unHi]] - (int) med;\nif (n == 0) {\nfswap(fmap, unHi, gtHi);\ngtHi--; unHi--;\ncontinue;\nif (n < 0) {\nbreak;\nunHi--;\nif (unLo > unHi) {\nbreak;\nfswap(fmap, unLo, unHi); unLo++; unHi--;\nif (gtHi < ltLo) {\ncontinue;\nn = fmin(ltLo - lo, unLo - ltLo);\nfvswap(fmap, lo, unLo - n, n);\nint m = fmin(hi - gtHi, gtHi - unHi);\nfvswap(fmap, unHi + 1, hi - m + 1, m);\nn = lo + unLo - ltLo - 1;\nm = hi - (gtHi - unHi) + 1;\nif (n - lo > hi - m) {\nfpush(sp++, lo, n);\nfpush(sp++, m, hi);\nfpush(sp++, m, hi);\nfpush(sp++, lo, n);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:getEclass()[I",
                                    "method_body": "private int[] getEclass() {\nreturn eclass == null\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fallbackSort([I[BI)V",
                                    "method_body": "final void fallbackSort(int[] fmap, byte[] block, int nblock) {\nfinal int[] ftab = new int[257];\nfinal int[] eclass = getEclass();\nfor (i = 0; i < nblock; i++) {\neclass[i] = 0;\nfor (i = 0; i < nblock; i++) {\nftab[block[i] & 0xff]++;\nfor (i = 1; i < 257;    i++) {\nftab[i] += ftab[i - 1];\nfor (i = 0; i < nblock; i++) {\nj = block[i] & 0xff;\nk = ftab[j] - 1;\nftab[j] = k;\nfmap[k] = i;\nnBhtab = 64 + nblock;\nBitSet bhtab = new BitSet(nBhtab);\nfor (i = 0; i < 256; i++) {\nbhtab.set(ftab[i]);\nfor (i = 0; i < 32; i++) {\nbhtab.set(nblock + 2 * i);\nbhtab.clear(nblock + 2 * i + 1);\nH = 1;\nj = 0;\nfor (i = 0; i < nblock; i++) {\nif (bhtab.get(i)) {\nj = i;\nk = fmap[i] - H;\nif (k < 0) {\nk += nblock;\neclass[k] = j;\nnNotDone = 0;\nr = -1;\nk = r + 1;\nk = bhtab.nextClearBit(k);\nl = k - 1;\nif (l >= nblock) {\nbreak;\nk = bhtab.nextSetBit(k + 1);\nr = k - 1;\nif (r >= nblock) {\nif (r > l) {\nnNotDone += (r - l + 1);\nfallbackQSort3(fmap, eclass, l, r);\ncc = -1;\nfor (i = l; i <= r; i++) {\ncc1 = eclass[fmap[i]];\nif (cc != cc1) {\nbhtab.set(i);\ncc = cc1;\nH *= 2;\nif (H > nblock || nNotDone == 0) {\nbreak;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:<init>(Ljava/io/InputStream;Z)V",
                                    "method_body": "public BZip2CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException {\nthis.in = in;\nthis.decompressConcatenated = decompressConcatenated;\ninit(true);\ninitBlock();\nsetupBlock();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:read([BII)I",
                                    "method_body": "public int read(final byte[] dest, final int offs, final int len)\nif (offs < 0) {\nif (len < 0) {\nif (offs + len > dest.length) {\nif (this.in == null) {\nfinal int hi = offs + len;\nint destOffs = offs;\nwhile (destOffs < hi && ((b = read0()) >= 0)) {\ndest[destOffs++] = (byte) b;\ncount(1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:makeMaps()V",
                                    "method_body": "private void makeMaps() {\nfinal boolean[] inUse = this.data.inUse;\nfinal byte[] seqToUnseq = this.data.seqToUnseq;\nint nInUseShadow = 0;\nfor (int i = 0; i < 256; i++) {\nif (inUse[i]) {\nseqToUnseq[nInUseShadow++] = (byte) i;\nthis.nInUse = nInUseShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:read0()I",
                                    "method_body": "private int read0() throws IOException {\nfinal int retChar = this.currentChar;\nswitch (currentState) {\nsetupNoRandPartB();\nbreak;\nreturn retChar;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:init(Z)Z",
                                    "method_body": "private boolean init(boolean isFirstStream) throws IOException {\nif (null == in) {\nint magic0 = this.in.read();\nif (magic0 == -1 && !isFirstStream) {\nint magic1 = this.in.read();\nint magic2 = this.in.read();\nif (magic0 != 'B' || magic1 != 'Z' || magic2 != 'h') {\nint blockSize = this.in.read();\nif ((blockSize < '1') || (blockSize > '9')) {\nthis.blockSize100k = blockSize - '0';\nthis.bsLive = 0;\nthis.computedCombinedCRC = 0;\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:initBlock()V",
                                    "method_body": "private void initBlock() throws IOException {\nmagic0 = bsGetUByte();\nmagic1 = bsGetUByte();\nmagic2 = bsGetUByte();\nmagic3 = bsGetUByte();\nmagic4 = bsGetUByte();\nmagic5 = bsGetUByte();\nif (magic0 != 0x17 || magic1 != 0x72 || magic2 != 0x45\nif (magic0 != 0x31 || // '1'\nthis.storedBlockCRC = bsGetInt();\nthis.blockRandomised = bsR(1) == 1;\nif (this.data == null) {\nthis.data = new Data(this.blockSize100k);\ngetAndMoveToFrontDecode();\nthis.crc.initialiseCRC();\nthis.currentState = START_BLOCK_STATE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:endBlock()V",
                                    "method_body": "private void endBlock() throws IOException {\nthis.computedBlockCRC = this.crc.getFinalCRC();\nif (this.storedBlockCRC != this.computedBlockCRC) {\nthis.computedCombinedCRC = (this.computedCombinedCRC << 1)\nthis.computedCombinedCRC ^= this.computedBlockCRC;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nInputStream inShadow = this.in;\nif (inShadow != null) {\nif (inShadow != System.in) {\ninShadow.close();\nthis.data = null;\nthis.in = null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsR(I)I",
                                    "method_body": "private int bsR(final int n) throws IOException {\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\nif (bsLiveShadow < n) {\nfinal InputStream inShadow = this.in;\nint thech = inShadow.read();\nif (thech < 0) {\nthrow new IOException(\"unexpected end of stream\");\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\n} while (bsLiveShadow < n);\nthis.bsBuff = bsBuffShadow;\nthis.bsLive = bsLiveShadow - n;\nreturn (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsGetBit()Z",
                                    "method_body": "private boolean bsGetBit() throws IOException {\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\nif (bsLiveShadow < 1) {\nint thech = this.in.read();\nif (thech < 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\nthis.bsBuff = bsBuffShadow;\nthis.bsLive = bsLiveShadow - 1;\nreturn ((bsBuffShadow >> (bsLiveShadow - 1)) & 1) != 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsGetUByte()C",
                                    "method_body": "private char bsGetUByte() throws IOException {\nreturn (char) bsR(8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsGetInt()I",
                                    "method_body": "private int bsGetInt() throws IOException {\nreturn (((((bsR(8) << 8) | bsR(8)) << 8) | bsR(8)) << 8) | bsR(8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:hbCreateDecodeTables([I[I[I[CIII)V",
                                    "method_body": "private static void hbCreateDecodeTables(final int[] limit,\nfor (int i = minLen, pp = 0; i <= maxLen; i++) {\nfor (int j = 0; j < alphaSize; j++) {\nif (length[j] == i) {\nperm[pp++] = j;\nfor (int i = MAX_CODE_LEN; --i > 0;) {\nbase[i] = 0;\nlimit[i] = 0;\nfor (int i = 0; i < alphaSize; i++) {\nbase[length[i] + 1]++;\nfor (int i = 1, b = base[0]; i < MAX_CODE_LEN; i++) {\nb += base[i];\nbase[i] = b;\nfor (int i = minLen, vec = 0, b = base[i]; i <= maxLen; i++) {\nfinal int nb = base[i + 1];\nvec += nb - b;\nb = nb;\nlimit[i] = vec - 1;\nvec <<= 1;\nfor (int i = minLen + 1; i <= maxLen; i++) {\nbase[i] = ((limit[i - 1] + 1) << 1) - base[i];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:recvDecodingTables()V",
                                    "method_body": "private void recvDecodingTables() throws IOException {\nfinal Data dataShadow = this.data;\nfinal boolean[] inUse = dataShadow.inUse;\nfinal byte[] pos = dataShadow.recvDecodingTables_pos;\nfinal byte[] selector = dataShadow.selector;\nfinal byte[] selectorMtf = dataShadow.selectorMtf;\nint inUse16 = 0;\nfor (int i = 0; i < 16; i++) {\nif (bsGetBit()) {\ninUse16 |= 1 << i;\nfor (int i = 256; --i >= 0;) {\ninUse[i] = false;\nfor (int i = 0; i < 16; i++) {\nif ((inUse16 & (1 << i)) != 0) {\nfinal int i16 = i << 4;\nfor (int j = 0; j < 16; j++) {\nif (bsGetBit()) {\ninUse[i16 + j] = true;\nmakeMaps();\nfinal int alphaSize = this.nInUse + 2;\nfinal int nGroups = bsR(3);\nfinal int nSelectors = bsR(15);\nfor (int i = 0; i < nSelectors; i++) {\nint j = 0;\nwhile (bsGetBit()) {\nj++;\nselectorMtf[i] = (byte) j;\nfor (int v = nGroups; --v >= 0;) {\npos[v] = (byte) v;\nfor (int i = 0; i < nSelectors; i++) {\nint v = selectorMtf[i] & 0xff;\nfinal byte tmp = pos[v];\nwhile (v > 0) {\npos[v] = pos[v - 1];\nv--;\npos[0] = tmp;\nselector[i] = tmp;\nfinal char[][] len = dataShadow.temp_charArray2d;\nfor (int t = 0; t < nGroups; t++) {\nint curr = bsR(5);\nfinal char[] len_t = len[t];\nfor (int i = 0; i < alphaSize; i++) {\nwhile (bsGetBit()) {\ncurr += bsGetBit() ? -1 : 1;\nlen_t[i] = (char) curr;\ncreateHuffmanDecodingTables(alphaSize, nGroups);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:createHuffmanDecodingTables(II)V",
                                    "method_body": "private void createHuffmanDecodingTables(final int alphaSize,\nfinal Data dataShadow = this.data;\nfinal char[][] len = dataShadow.temp_charArray2d;\nfinal int[] minLens = dataShadow.minLens;\nfinal int[][] limit = dataShadow.limit;\nfinal int[][] base = dataShadow.base;\nfinal int[][] perm = dataShadow.perm;\nfor (int t = 0; t < nGroups; t++) {\nint minLen = 32;\nint maxLen = 0;\nfinal char[] len_t = len[t];\nfor (int i = alphaSize; --i >= 0;) {\nfinal char lent = len_t[i];\nif (lent > maxLen) {\nmaxLen = lent;\nif (lent < minLen) {\nminLen = lent;\n}\nhbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen,\nminLens[t] = minLen;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:getAndMoveToFrontDecode()V",
                                    "method_body": "private void getAndMoveToFrontDecode() throws IOException {\nthis.origPtr = bsR(24);\nrecvDecodingTables();\nfinal InputStream inShadow = this.in;\nfinal Data dataShadow = this.data;\nfinal byte[] ll8 = dataShadow.ll8;\nfinal int[] unzftab = dataShadow.unzftab;\nfinal byte[] selector = dataShadow.selector;\nfinal byte[] seqToUnseq = dataShadow.seqToUnseq;\nfinal char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\nfinal int[] minLens = dataShadow.minLens;\nfinal int[][] limit = dataShadow.limit;\nfinal int[][] base = dataShadow.base;\nfinal int[][] perm = dataShadow.perm;\nfinal int limitLast = this.blockSize100k * 100000;\nfor (int i = 256; --i >= 0;) {\nyy[i] = (char) i;\nunzftab[i] = 0;\nint groupNo = 0;\nint groupPos = G_SIZE - 1;\nfinal int eob = this.nInUse + 1;\nint nextSym = getAndMoveToFrontDecode0(0);\nint bsBuffShadow = this.bsBuff;\nint bsLiveShadow = this.bsLive;\nint lastShadow = -1;\nint zt = selector[groupNo] & 0xff;\nint[] base_zt = base[zt];\nint[] limit_zt = limit[zt];\nint[] perm_zt = perm[zt];\nint minLens_zt = minLens[zt];\nwhile (nextSym != eob) {\nif ((nextSym == RUNA) || (nextSym == RUNB)) {\nint s = -1;\nfor (int n = 1; true; n <<= 1) {\nif (nextSym == RUNA) {\ns += n;\n} else if (nextSym == RUNB) {\ns += n << 1;\nif (groupPos == 0) {\ngroupPos = G_SIZE - 1;\nzt = selector[++groupNo] & 0xff;\nbase_zt = base[zt];\nlimit_zt = limit[zt];\nperm_zt = perm[zt];\nminLens_zt = minLens[zt];\ngroupPos--;\nint zn = minLens_zt;\nwhile (bsLiveShadow < zn) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\nint zvec = (bsBuffShadow >> (bsLiveShadow - zn))\nbsLiveShadow -= zn;\nwhile (zvec > limit_zt[zn]) {\nzn++;\nwhile (bsLiveShadow < 1) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\nbsLiveShadow--;\nzvec = (zvec << 1)\nnextSym = perm_zt[zvec - base_zt[zn]];\nfinal byte ch = seqToUnseq[yy[0]];\nunzftab[ch & 0xff] += s + 1;\nwhile (s-- >= 0) {\nll8[++lastShadow] = ch;\nif (lastShadow >= limitLast) {\n} else {\nif (++lastShadow >= limitLast) {\nfinal char tmp = yy[nextSym - 1];\nunzftab[seqToUnseq[tmp] & 0xff]++;\nll8[lastShadow] = seqToUnseq[tmp];\nif (nextSym <= 16) {\nfor (int j = nextSym - 1; j > 0;) {\nyy[j] = yy[--j];\nSystem.arraycopy(yy, 0, yy, 1, nextSym - 1);\nyy[0] = tmp;\nif (groupPos == 0) {\ngroupPos = G_SIZE - 1;\nzt = selector[++groupNo] & 0xff;\nbase_zt = base[zt];\nlimit_zt = limit[zt];\nperm_zt = perm[zt];\nminLens_zt = minLens[zt];\ngroupPos--;\nint zn = minLens_zt;\nwhile (bsLiveShadow < zn) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\nint zvec = (bsBuffShadow >> (bsLiveShadow - zn))\nbsLiveShadow -= zn;\nwhile (zvec > limit_zt[zn]) {\nzn++;\nwhile (bsLiveShadow < 1) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\nbsLiveShadow--;\nzvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\nnextSym = perm_zt[zvec - base_zt[zn]];\n}\nthis.last = lastShadow;\nthis.bsLive = bsLiveShadow;\nthis.bsBuff = bsBuffShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:getAndMoveToFrontDecode0(I)I",
                                    "method_body": "private int getAndMoveToFrontDecode0(final int groupNo) throws IOException {\nfinal InputStream inShadow = this.in;\nfinal Data dataShadow = this.data;\nfinal int zt = dataShadow.selector[groupNo] & 0xff;\nfinal int[] limit_zt = dataShadow.limit[zt];\nint zn = dataShadow.minLens[zt];\nint zvec = bsR(zn);\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\nwhile (zvec > limit_zt[zn]) {\nzn++;\nwhile (bsLiveShadow < 1) {\nbsLiveShadow--;\nzvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\nthis.bsLive = bsLiveShadow;\nthis.bsBuff = bsBuffShadow;\nreturn dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:setupBlock()I",
                                    "method_body": "private int setupBlock() throws IOException {\nif (currentState == EOF || this.data == null) {\nfinal int[] cftab = this.data.cftab;\nfinal int[] tt = this.data.initTT(this.last + 1);\nfinal byte[] ll8 = this.data.ll8;\ncftab[0] = 0;\nSystem.arraycopy(this.data.unzftab, 0, cftab, 1, 256);\nfor (int i = 1, c = cftab[0]; i <= 256; i++) {\nc += cftab[i];\ncftab[i] = c;\nfor (int i = 0, lastShadow = this.last; i <= lastShadow; i++) {\ntt[cftab[ll8[i] & 0xff]++] = i;\nif ((this.origPtr < 0) || (this.origPtr >= tt.length)) {\nthis.su_tPos = tt[this.origPtr];\nthis.su_count = 0;\nthis.su_i2 = 0;\nthis.su_ch2 = 256; /* not a char and not EOF */\nif (this.blockRandomised) {\nreturn setupNoRandPartA();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:setupNoRandPartA()I",
                                    "method_body": "private int setupNoRandPartA() throws IOException {\nif (this.su_i2 <= this.last) {\nthis.su_chPrev = this.su_ch2;\nint su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;\nthis.su_ch2 = su_ch2Shadow;\nthis.su_tPos = this.data.tt[this.su_tPos];\nthis.su_i2++;\nthis.currentChar = su_ch2Shadow;\nthis.currentState = NO_RAND_PART_B_STATE;\nthis.crc.updateCRC(su_ch2Shadow);\nreturn su_ch2Shadow;\nthis.currentState = NO_RAND_PART_A_STATE;\nendBlock();\ninitBlock();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:setupNoRandPartB()I",
                                    "method_body": "private int setupNoRandPartB() throws IOException {\nif (this.su_ch2 != this.su_chPrev) {\nthis.su_count = 1;\nreturn setupNoRandPartA();\n} else if (++this.su_count >= 4) {\nreturn setupNoRandPartA();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream$Data:<init>(I)V",
                                    "method_body": "Data(int blockSize100k) {\nthis.ll8 = new byte[blockSize100k * BZip2Constants.BASEBLOCKSIZE];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream$Data:initTT(I)[I",
                                    "method_body": "int[] initTT(int length) {\nint[] ttShadow = this.tt;\nif ((ttShadow == null) || (ttShadow.length < length)) {\nthis.tt = ttShadow = new int[length];\nreturn ttShadow;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 23,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.sevenz.SevenZFileTest.testCompressedHeaderWithNonDefaultDictionarySize",
                            "test_body": "78: public void testCompressedHeaderWithNonDefaultDictionarySize() throws Exception {\n79: SevenZFile sevenZFile = new SevenZFile(getFile(\"COMPRESS-256.7z\"));\n80: try {\n81: int count = 0;\n82: while (sevenZFile.getNextEntry() != null) {\n83: count++;\n84: }\n85: assertEquals(446, count);\n86: } finally {\n87: sevenZFile.close();\n88: }\n89: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:<init>(Ljava/lang/String;I[B)V",
                                    "method_body": "private SevenZMethod(byte[] id) {\nthis.id = id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:getId()[B",
                                    "method_body": "byte[] getId() {\nbyte[] copy = new byte[id.length];\nSystem.arraycopy(id, 0, copy, 0, id.length);\nreturn copy;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;[B)V",
                                    "method_body": "public SevenZFile(final File filename, final byte[] password) throws IOException {\nboolean succeeded = false;\nthis.file = new RandomAccessFile(filename, \"r\");\narchive = readHeaders(password);\nif (!succeeded) {\nthis.file.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZFile(final File filename) throws IOException {\nthis(filename, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<clinit>()V",
                                    "method_body": "static final int SIGNATURE_HEADER_SIZE = 32;\nprivate int currentEntryIndex = -1;\nprivate int currentFolderIndex = -1;\nprivate InputStream currentFolderInputStream = null;\nprivate InputStream currentEntryInputStream = null;\nstatic final byte[] sevenZSignature = {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeaders([B)Lorg/apache/commons/compress/archivers/sevenz/Archive;",
                                    "method_body": "private Archive readHeaders(byte[] password) throws IOException {\nfinal byte[] signature = new byte[6];\nfile.readFully(signature);\nif (!Arrays.equals(signature, sevenZSignature)) {\nfinal byte archiveVersionMajor = file.readByte();\nfinal byte archiveVersionMinor = file.readByte();\nif (archiveVersionMajor != 0) {\nfinal long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\nfinal StartHeader startHeader = readStartHeader(startHeaderCrc);\nfinal int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\nif (nextHeaderSizeInt != startHeader.nextHeaderSize) {\nfile.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\nfinal byte[] nextHeader = new byte[nextHeaderSizeInt];\nfile.readFully(nextHeader);\nfinal CRC32 crc = new CRC32();\ncrc.update(nextHeader);\nif (startHeader.nextHeaderCrc != crc.getValue()) {\nfinal ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\nDataInputStream nextHeaderInputStream = new DataInputStream(\nArchive archive = new Archive();\nint nid = nextHeaderInputStream.readUnsignedByte();\nif (nid == NID.kEncodedHeader) {\nnextHeaderInputStream =\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStartHeader(J)Lorg/apache/commons/compress/archivers/sevenz/StartHeader;",
                                    "method_body": "private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\nfinal StartHeader startHeader = new StartHeader();\nDataInputStream dataInputStream = null;\ndataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\nstartHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\nreturn startHeader;\nif (dataInputStream != null) {\ndataInputStream.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readEncodedHeader(Ljava/io/DataInputStream;Lorg/apache/commons/compress/archivers/sevenz/Archive;[B)Ljava/io/DataInputStream;",
                                    "method_body": "private DataInputStream readEncodedHeader(final DataInputStream header, final Archive archive,\nreadStreamsInfo(header, archive);\nfinal Folder folder = archive.folders[0];\nfinal int firstPackStreamIndex = 0;\nfinal long folderOffset = SIGNATURE_HEADER_SIZE + archive.packPos +\nfile.seek(folderOffset);\nInputStream inputStreamStack = new BoundedRandomAccessFileInputStream(file,\nfor (final Coder coder : folder.coders) {\nif (coder.numInStreams != 1 || coder.numOutStreams != 1) {\ninputStreamStack = Coders.addDecoder(inputStreamStack, coder, password);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\nif (nid == NID.kPackInfo) {\nreadPackInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid == NID.kUnpackInfo) {\nreadUnpackInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid == NID.kSubStreamsInfo) {\nif (nid != NID.kEnd) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readPackInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readPackInfo(final DataInput header, final Archive archive) throws IOException {\narchive.packPos = readUint64(header);\nfinal long numPackStreams = readUint64(header);\nint nid = header.readUnsignedByte();\nif (nid == NID.kSize) {\narchive.packSizes = new long[(int)numPackStreams];\nfor (int i = 0; i < archive.packSizes.length; i++) {\narchive.packSizes[i] = readUint64(header);\nnid = header.readUnsignedByte();\nif (nid == NID.kCRC) {\nif (nid != NID.kEnd) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUnpackInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readUnpackInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\nif (nid != NID.kFolder) {\nfinal long numFolders = readUint64(header);\nfinal Folder[] folders = new Folder[(int)numFolders];\narchive.folders = folders;\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nfor (int i = 0; i < (int)numFolders; i++) {\nfolders[i] = readFolder(header);\nnid = header.readUnsignedByte();\nif (nid != NID.kCodersUnpackSize) {\nfor (final Folder folder : folders) {\nfolder.unpackSizes = new long[(int)folder.totalOutputStreams];\nfor (int i = 0; i < folder.totalOutputStreams; i++) {\nfolder.unpackSizes[i] = readUint64(header);\nnid = header.readUnsignedByte();\nif (nid == NID.kCRC) {\nfinal BitSet crcsDefined = readAllOrBits(header, (int)numFolders);\nfor (int i = 0; i < (int)numFolders; i++) {\nif (crcsDefined.get(i)) {\nfolders[i].hasCrc = true;\nfolders[i].crc = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\nnid = header.readUnsignedByte();\nif (nid != NID.kEnd) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFolder(Ljava/io/DataInput;)Lorg/apache/commons/compress/archivers/sevenz/Folder;",
                                    "method_body": "private Folder readFolder(final DataInput header) throws IOException {\nfinal Folder folder = new Folder();\nfinal long numCoders = readUint64(header);\nfinal Coder[] coders = new Coder[(int)numCoders];\nlong totalInStreams = 0;\nlong totalOutStreams = 0;\nfor (int i = 0; i < coders.length; i++) {\ncoders[i] = new Coder();\nint bits = header.readUnsignedByte();\nfinal int idSize = bits & 0xf;\nfinal boolean isSimple = (bits & 0x10) == 0;\nfinal boolean hasAttributes = (bits & 0x20) != 0;\nfinal boolean moreAlternativeMethods = (bits & 0x80) != 0;\ncoders[i].decompressionMethodId = new byte[idSize];\nheader.readFully(coders[i].decompressionMethodId);\nif (isSimple) {\ncoders[i].numInStreams = 1;\ncoders[i].numOutStreams = 1;\ntotalInStreams += coders[i].numInStreams;\ntotalOutStreams += coders[i].numOutStreams;\nif (hasAttributes) {\nfinal long propertiesSize = readUint64(header);\ncoders[i].properties = new byte[(int)propertiesSize];\nheader.readFully(coders[i].properties);\nwhile (moreAlternativeMethods) {\nfolder.coders = coders;\nfolder.totalInputStreams = totalInStreams;\nfolder.totalOutputStreams = totalOutStreams;\nif (totalOutStreams == 0) {\nfinal long numBindPairs = totalOutStreams - 1;\nfinal BindPair[] bindPairs = new BindPair[(int)numBindPairs];\nfor (int i = 0; i < bindPairs.length; i++) {\nfolder.bindPairs = bindPairs;\nif (totalInStreams < numBindPairs) {\nfinal long numPackedStreams = totalInStreams - numBindPairs;\nfinal long packedStreams[] = new long[(int)numPackedStreams];\nif (numPackedStreams == 1) {\nfor (i = 0; i < (int)totalInStreams; i++) {\nif (folder.findBindPairForInStream(i) < 0) {\nbreak;\nif (i == (int)totalInStreams) {\npackedStreams[0] = i;\n} else {\nfolder.packedStreams = packedStreams;\nreturn folder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readAllOrBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readAllOrBits(final DataInput header, final int size) throws IOException {\nfinal int areAllDefined = header.readUnsignedByte();\nif (areAllDefined != 0) {\nbits = new BitSet(size);\nfor (int i = 0; i < size; i++) {\nbits.set(i, true);\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUint64(Ljava/io/DataInput;)J",
                                    "method_body": "private static long readUint64(final DataInput in) throws IOException {\nlong firstByte = in.readUnsignedByte();\nint mask = 0x80;\nlong value = 0;\nfor (int i = 0; i < 8; i++) {\nif ((firstByte & mask) == 0) {\nreturn value | ((firstByte & (mask - 1)) << (8 * i));\nlong nextByte = in.readUnsignedByte();\nvalue |= nextByte << (8 * i);\nmask >>>= 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;JJ)V",
                                    "method_body": "public ChecksumVerifyingInputStream(final Checksum checksum, final InputStream in,\nfinal long size, final long expectedChecksum) {\nthis.checksum = checksum;\nthis.in = in;\nthis.expectedChecksum = expectedChecksum;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining <= 0) {\nint ret = in.read();\nif (ret >= 0) {\nchecksum.update(ret);\n--bytesRemaining;\nif (bytesRemaining == 0 && expectedChecksum != checksum.getValue()) {\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nint ret = in.read(b, off, len);\nif (ret >= 0) {\nchecksum.update(b, off, ret);\nbytesRemaining -= ret;\nif (bytesRemaining <= 0 && expectedChecksum != checksum.getValue()) {\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nin.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CRC32VerifyingInputStream:<init>(Ljava/io/InputStream;JJ)V",
                                    "method_body": "public CRC32VerifyingInputStream(final InputStream in, final long size, final long expectedCrc32) {\nsuper(new CRC32(), in, size, expectedCrc32);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:<init>(Ljava/io/RandomAccessFile;J)V",
                                    "method_body": "public BoundedRandomAccessFileInputStream(final RandomAccessFile file,\nfinal long size) {\nthis.file = file;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining > 0) {\n--bytesRemaining;\nreturn file.read();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif (bytesRemaining == 0) {\nint bytesToRead = len;\nif (bytesToRead > bytesRemaining) {\nfinal int bytesRead = file.read(b, off, bytesToRead);\nif (bytesRead >= 0) {\nbytesRemaining -= bytesRead;\nreturn bytesRead;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:close()V",
                                    "method_body": "public void close() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders:<clinit>()V",
                                    "method_body": "static CoderId[] coderTable = new CoderId[] {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders:addDecoder(Ljava/io/InputStream;Lorg/apache/commons/compress/archivers/sevenz/Coder;[B)Ljava/io/InputStream;",
                                    "method_body": "static InputStream addDecoder(final InputStream is,\nfor (final CoderId coderId : coderTable) {\nif (Arrays.equals(coderId.method.getId(), coder.decompressionMethodId)) {\nreturn coderId.coder.decode(is, coder, password);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$CoderId:<init>(Lorg/apache/commons/compress/archivers/sevenz/SevenZMethod;Lorg/apache/commons/compress/archivers/sevenz/Coders$CoderBase;)V",
                                    "method_body": "CoderId(SevenZMethod method, final CoderBase coder) {\nthis.method = method;\nthis.coder = coder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$CoderBase:<init>()V",
                                    "method_body": "final SevenZMethod method;\nstatic abstract class CoderBase {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$LZMADecoder:decode(Ljava/io/InputStream;Lorg/apache/commons/compress/archivers/sevenz/Coder;[B)Ljava/io/InputStream;",
                                    "method_body": "InputStream decode(final InputStream in, final Coder coder,\nbyte propsByte = coder.properties[0];\nlong dictSize = coder.properties[1];\nfor (int i = 1; i < 4; i++) {\ndictSize |= (coder.properties[i + 1] << (8 * i));\nif (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\nreturn new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:findBindPairForInStream(I)I",
                                    "method_body": "int findBindPairForInStream(final int index) {\nfor (int i = 0; i < bindPairs.length; i++) {\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coder:<init>()V",
                                    "method_body": "byte[] decompressionMethodId;\nbyte[] properties = null;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 24,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarUtilsTest.testParseOctal",
                            "test_body": "46: public void testParseOctal() throws Exception{\n47: long value; \n48: byte [] buffer;\n49: final long MAX_OCTAL  = 077777777777L; // Allowed 11 digits\n50: final long MAX_OCTAL_OVERFLOW  = 0777777777777L; // in fact 12 for some implementations\n51: final String maxOctal = \"777777777777\"; // Maximum valid octal\n52: buffer = maxOctal.getBytes(CharsetNames.UTF_8);\n53: value = TarUtils.parseOctal(buffer,0, buffer.length);\n54: assertEquals(MAX_OCTAL_OVERFLOW, value);\n55: buffer[buffer.length - 1] = ' ';\n56: value = TarUtils.parseOctal(buffer,0, buffer.length);\n57: assertEquals(MAX_OCTAL, value);\n58: buffer[buffer.length-1]=0;\n59: value = TarUtils.parseOctal(buffer,0, buffer.length);\n60: assertEquals(MAX_OCTAL, value);\n61: buffer=new byte[]{0,0};\n62: value = TarUtils.parseOctal(buffer,0, buffer.length);\n63: assertEquals(0, value);\n64: buffer=new byte[]{0,' '};\n65: value = TarUtils.parseOctal(buffer,0, buffer.length);\n66: assertEquals(0, value);\n67: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\nMap<String, SimpleEncodingHolder> se =\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\ncharsetName = System.getProperty(\"file.encoding\");\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:<clinit>()V",
                                    "method_body": "private static final int BYTE_MASK = 255;\nstatic final ZipEncoding DEFAULT_ENCODING =\nstatic final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\nif (length < 2){\nif (buffer[start] == 0) {\nwhile (start < end){\nif (buffer[start] == ' '){\nbyte trailer = buffer[end - 1];\nif (trailer == 0 || trailer == ' '){\nthrow new IllegalArgumentException(\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:exceptionMessage([BIIIB)Ljava/lang/String;",
                                    "method_body": "private static String exceptionMessage(byte[] buffer, final int offset,\nString string = new String(buffer, offset, length);\nstring=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed\nfinal String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;\nreturn s;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 25,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest.testReadingOfFirstStoredEntry",
                            "test_body": "160: public void testReadingOfFirstStoredEntry() throws Exception {\n161: ZipArchiveInputStream in = new ZipArchiveInputStream(new FileInputStream(getFile(\"COMPRESS-264.zip\")));\n162: 163: try {\n164: ZipArchiveEntry ze = in.getNextZipEntry();\n165: assertEquals(5, ze.getSize());\n166: assertArrayEquals(new byte[] {'d', 'a', 't', 'a', '\\n'},\n167: IOUtils.toByteArray(in));\n168: } finally {\n169: in.close();\n170: }\n171: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\nMap<String, SimpleEncodingHolder> se =\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nfor (String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data,this.charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:copy(Ljava/io/InputStream;Ljava/io/OutputStream;)J",
                                    "method_body": "public static long copy(final InputStream input, final OutputStream output) throws IOException {\nreturn copy(input, output, 8024);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:copy(Ljava/io/InputStream;Ljava/io/OutputStream;I)J",
                                    "method_body": "public static long copy(final InputStream input, final OutputStream output, int buffersize) throws IOException {\nfinal byte[] buffer = new byte[buffersize];\nint n = 0;\nlong count=0;\nwhile (-1 != (n = input.read(buffer))) {\noutput.write(buffer, 0, n);\ncount += n;\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[B)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b) throws IOException {\nreturn readFully(input, b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b, int offset, int len)\nif (len < 0 || offset < 0 || len + offset > b.length) {\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\ncount += x;\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:toByteArray(Ljava/io/InputStream;)[B",
                                    "method_body": "public static byte[] toByteArray(final InputStream input) throws IOException {\nfinal ByteArrayOutputStream output = new ByteArrayOutputStream();\ncopy(input, output);\nreturn output.toByteArray();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream) {\nthis(inputStream, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream, String encoding) {\nthis(inputStream, encoding, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields) {\nthis(inputStream, encoding, useUnicodeExtraFields, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;ZZ)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream,\nboolean allowStoredEntriesWithDataDescriptor) {\nzipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\nin = new PushbackInputStream(inputStream, buf.capacity());\nthis.allowStoredEntriesWithDataDescriptor =\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<clinit>()V",
                                    "method_body": "private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\nprivate static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\nprivate static final byte[] DD = ZipLong.DD_SIG.getBytes();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:getNextZipEntry()Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;",
                                    "method_body": "public ZipArchiveEntry getNextZipEntry() throws IOException {\nboolean firstEntry = true;\nif (closed || hitCentralDirectory) {\nif (current != null) {\nif (firstEntry) {\nreadFirstLocalFileHeader(LFH_BUF);\n}\nZipLong sig = new ZipLong(LFH_BUF);\nif (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\nif (!sig.equals(ZipLong.LFH_SIG)) {\nint off = WORD;\ncurrent = new CurrentEntry();\nint versionMadeBy = ZipShort.getValue(LFH_BUF, off);\noff += SHORT;\ncurrent.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\nfinal GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\nfinal boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\nfinal ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\ncurrent.hasDataDescriptor = gpFlag.usesDataDescriptor();\ncurrent.entry.setGeneralPurposeBit(gpFlag);\noff += SHORT;\ncurrent.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\noff += SHORT;\nlong time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\ncurrent.entry.setTime(time);\noff += WORD;\nZipLong size = null, cSize = null;\nif (!current.hasDataDescriptor) {\ncurrent.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\noff += WORD;\ncSize = new ZipLong(LFH_BUF, off);\noff += WORD;\nsize = new ZipLong(LFH_BUF, off);\noff += WORD;\nint fileNameLen = ZipShort.getValue(LFH_BUF, off);\noff += SHORT;\nint extraLen = ZipShort.getValue(LFH_BUF, off);\noff += SHORT;\nbyte[] fileName = new byte[fileNameLen];\nreadFully(fileName);\ncurrent.entry.setName(entryEncoding.decode(fileName), fileName);\nbyte[] extraData = new byte[extraLen];\nreadFully(extraData);\ncurrent.entry.setExtra(extraData);\nif (!hasUTF8Flag && useUnicodeExtraFields) {\nZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\nprocessZip64Extra(size, cSize);\nif (current.entry.getCompressedSize() != -1) {\nif (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n} else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\nentriesRead++;\nreturn current.entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readFirstLocalFileHeader([B)V",
                                    "method_body": "private void readFirstLocalFileHeader(byte[] lfh) throws IOException {\nreadFully(lfh);\nZipLong sig = new ZipLong(lfh);\nif (sig.equals(ZipLong.DD_SIG)) {\nif (sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER)) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:processZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipLong;Lorg/apache/commons/compress/archivers/zip/ZipLong;)V",
                                    "method_body": "private void processZip64Extra(ZipLong size, ZipLong cSize) {\nZip64ExtendedInformationExtraField z64 =\ncurrent.usesZip64 = z64 != null;\nif (!current.hasDataDescriptor) {\nif (z64 != null // same as current.usesZip64 but avoids NPE warning\ncurrent.entry.setCompressedSize(cSize.getValue());\ncurrent.entry.setSize(size.getValue());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] buffer, int offset, int length) throws IOException {\nif (closed) {\nif (current == null) {\nif (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\nZipUtil.checkRequestedFeatures(current.entry);\nif (!supportsDataDescriptorFor(current.entry)) {\nif (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\nread = readStored(buffer, offset, length);\nif (read >= 0) {\ncurrent.crc.update(buffer, offset, read);\nreturn read;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readStored([BII)I",
                                    "method_body": "private int readStored(byte[] buffer, int offset, int length) throws IOException {\nif (current.hasDataDescriptor) {\nlong csize = current.entry.getSize();\nif (current.bytesRead >= csize) {\nreturn -1;\nif (buf.position() >= buf.limit()) {\nint toRead = Math.min(buf.remaining(), length);\nif ((csize - current.bytesRead) < toRead) {\ntoRead = (int) (csize - current.bytesRead);\nbuf.get(buffer, offset, toRead);\ncurrent.bytesRead += toRead;\nreturn toRead;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!closed) {\nclosed = true;\nin.close();\ninf.end();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readFully([B)V",
                                    "method_body": "private void readFully(byte[] b) throws IOException {\nint count = IOUtils.readFully(in, b);\ncount(count);\nif (count < b.length) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:supportsDataDescriptorFor(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private boolean supportsDataDescriptorFor(ZipArchiveEntry entry) {\nreturn !entry.getGeneralPurposeBit().usesDataDescriptor()\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>([B)V",
                                    "method_body": "public ZipLong (byte[] bytes) {\nthis(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>([BI)V",
                                    "method_body": "public ZipLong (byte[] bytes, int offset) {\nvalue = ZipLong.getValue(bytes, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue()J",
                                    "method_body": "public long getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object o) {\nif (o == null || !(o instanceof ZipLong)) {\nreturn value == ((ZipLong) o).getValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream$CurrentEntry:<init>()V",
                                    "method_body": "private final ZipArchiveEntry entry = new ZipArchiveEntry();\nprivate final CRC32 crc = new CRC32();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/util/zip/ZipEntry;)V",
                                    "method_body": "private long size = SIZE_UNKNOWN;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate LinkedHashMap<ZipShort, ZipExtraField> extraFields = null;\nprivate UnparseableExtraFieldData unparseableExtra = null;\nprivate String name = null;\nprivate byte[] rawName = null;\nprivate GeneralPurposeBit gpb = new GeneralPurposeBit();\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "protected ZipArchiveEntry() {\nthis(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<clinit>()V",
                                    "method_body": "public static final int PLATFORM_UNIX = 3;\nprivate static final byte[] EMPTY = new byte[0];\n* The {@link java.util.zip.ZipEntry} base class only supports"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getMethod()I",
                                    "method_body": "public int getMethod() {\nreturn method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setMethod(I)V",
                                    "method_body": "public void setMethod(int method) {\nif (method < 0) {\nthis.method = method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setPlatform(I)V",
                                    "method_body": "protected void setPlatform(int platform) {\nthis.platform = platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void setExtraFields(ZipExtraField[] fields) {\nextraFields = new LinkedHashMap<ZipShort, ZipExtraField>();\nfor (ZipExtraField field : fields) {\nif (field instanceof UnparseableExtraFieldData) {\nextraFields.put(field.getHeaderId(), field);\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields(Z)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields(boolean includeUnparseable) {\nif (extraFields == null) {\nList<ZipExtraField> result =\nif (includeUnparseable && unparseableExtra != null) {\nreturn result.toArray(new ZipExtraField[0]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField getExtraField(ZipShort type) {\nif (extraFields != null) {\nreturn extraFields.get(type);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra([B)V",
                                    "method_body": "public void setExtra(byte[] extra) throws RuntimeException {\nZipExtraField[] local =\nmergeExtraFields(local, true);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields(true)));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "protected void setName(String name) {\nif (name != null && getPlatform() == PLATFORM_FAT\nname = name.replace('\\\\', '/');\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nif (size < 0) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;[B)V",
                                    "method_body": "protected void setName(String name, byte[] rawName) {\nsetName(name);\nthis.rawName = rawName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getGeneralPurposeBit()Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "public GeneralPurposeBit getGeneralPurposeBit() {\nreturn gpb;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setGeneralPurposeBit(Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;)V",
                                    "method_body": "public void setGeneralPurposeBit(GeneralPurposeBit b) {\ngpb = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:mergeExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;Z)V",
                                    "method_body": "private void mergeExtraFields(ZipExtraField[] f, boolean local)\nif (extraFields == null) {\nsetExtraFields(f);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:<init>()V",
                                    "method_body": "public static final int UFT8_NAMES_FLAG = 1 << 11;\nprivate boolean languageEncodingFlag = false;\nprivate boolean dataDescriptorFlag = false;\nprivate boolean encryptionFlag = false;\nprivate boolean strongEncryptionFlag = false;\npublic GeneralPurposeBit() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesUTF8ForNames()Z",
                                    "method_body": "public boolean usesUTF8ForNames() {\nreturn languageEncodingFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useUTF8ForNames(Z)V",
                                    "method_body": "public void useUTF8ForNames(boolean b) {\nlanguageEncodingFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesDataDescriptor()Z",
                                    "method_body": "public boolean usesDataDescriptor() {\nreturn dataDescriptorFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useDataDescriptor(Z)V",
                                    "method_body": "public void useDataDescriptor(boolean b) {\ndataDescriptorFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesEncryption()Z",
                                    "method_body": "public boolean usesEncryption() {\nreturn encryptionFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useEncryption(Z)V",
                                    "method_body": "public void useEncryption(boolean b) {\nencryptionFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useStrongEncryption(Z)V",
                                    "method_body": "public void useStrongEncryption(boolean b) {\nstrongEncryptionFlag = b;\nif (b) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:parse([BI)Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "public static GeneralPurposeBit parse(final byte[] data, final int offset) {\nfinal int generalPurposeFlag = ZipShort.getValue(data, offset);\nGeneralPurposeBit b = new GeneralPurposeBit();\nb.useDataDescriptor((generalPurposeFlag & DATA_DESCRIPTOR_FLAG) != 0);\nb.useUTF8ForNames((generalPurposeFlag & UFT8_NAMES_FLAG) != 0);\nb.useStrongEncryption((generalPurposeFlag & STRONG_ENCRYPTION_FLAG) != 0);\nb.useEncryption((generalPurposeFlag & ENCRYPTION_FLAG) != 0);\nb.slidingDictionarySize = (generalPurposeFlag & SLIDING_DICTIONARY_SIZE_FLAG) != 0 ? 8192 : 4096;\nb.numberOfShannonFanoTrees = (generalPurposeFlag & NUMBER_OF_SHANNON_FANO_TREES_FLAG) != 0 ? 3 : 2;\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>([BI)V",
                                    "method_body": "public ZipShort (byte[] bytes, int offset) {\nvalue = ZipShort.getValue(bytes, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([BI)I",
                                    "method_body": "public static int getValue(byte[] bytes, int offset) {\nint value = (bytes[offset + 1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object o) {\nif (o == null || !(o instanceof ZipShort)) {\nreturn value == ((ZipShort) o).getValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:reverse([B)[B",
                                    "method_body": "public static byte[] reverse(final byte[] array) {\nfinal int z = array.length - 1; // position of last element\nfor (int i = 0; i < array.length / 2; i++) {\nbyte x = array[i];\narray[i] = array[z - i];\narray[z - i] = x;\nreturn array;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:signedByteToUnsignedInt(B)I",
                                    "method_body": "public static int signedByteToUnsignedInt(byte b) {\nif (b >= 0) {\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:unsignedIntToSignedByte(I)B",
                                    "method_body": "public static byte unsignedIntToSignedByte(int i) {\nif (i > 255 || i < 0) {\nif (i < 128) {\nreturn (byte) i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:dosToJavaTime(J)J",
                                    "method_body": "public static long dosToJavaTime(long dosTime) {\nCalendar cal = Calendar.getInstance();\ncal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\ncal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\ncal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);\ncal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);\ncal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);\ncal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);\ncal.set(Calendar.MILLISECOND, 0);\nreturn cal.getTime().getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:setNameAndCommentFromExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;[B[B)V",
                                    "method_body": "static void setNameAndCommentFromExtraFields(ZipArchiveEntry ze,\nUnicodePathExtraField name = (UnicodePathExtraField)\nString originalName = ze.getName();\nString newName = getUnicodeStringIfOriginalMatches(name,\nif (newName != null && !originalName.equals(newName)) {\nif (commentBytes != null && commentBytes.length > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:getUnicodeStringIfOriginalMatches(Lorg/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField;[B)Ljava/lang/String;",
                                    "method_body": "String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f,\nif (f != null) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:supportsEncryptionOf(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private static boolean supportsEncryptionOf(ZipArchiveEntry entry) {\nreturn !entry.getGeneralPurposeBit().usesEncryption();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:supportsMethodOf(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private static boolean supportsMethodOf(ZipArchiveEntry entry) {\nreturn entry.getMethod() == ZipEntry.STORED\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:checkRequestedFeatures(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "static void checkRequestedFeatures(ZipArchiveEntry ze)\nif (!supportsEncryptionOf(ze)) {\nif (!supportsMethodOf(ze)) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<init>(I)V",
                                    "method_body": "private UnparseableExtraField(int k) {\nkey = k;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<clinit>()V",
                                    "method_body": "public static final UnparseableExtraField READ\nprivate UnparseableExtraField(int k) {\nkey = k;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\nimplementations = new ConcurrentHashMap<ZipShort, Class<?>>();\nregister(AsiExtraField.class);\nregister(X5455_ExtendedTimestamp.class);\nregister(X7875_NewUnix.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\nregister(Zip64ExtendedInformationExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class<?> c) {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:createExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField createExtraField(ZipShort headerId)\nClass<?> c = implementations.get(headerId);\nif (c != null) {\nreturn (ZipExtraField) c.newInstance();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:parse([BZLorg/apache/commons/compress/archivers/zip/ExtraFieldUtils$UnparseableExtraField;)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField[] parse(byte[] data, boolean local,\nList<ZipExtraField> v = new ArrayList<ZipExtraField>();\nint start = 0;\nwhile (start <= data.length - WORD) {\nZipShort headerId = new ZipShort(data, start);\nint length = new ZipShort(data, start + 2).getValue();\nif (start + WORD + length > data.length) {\nZipExtraField ze = createExtraField(headerId);\nif (local) {\nze.parseFromLocalFileData(data, start + WORD, length);\nv.add(ze);\n}\nstart += length + WORD;\n}\nZipExtraField[] result = new ZipExtraField[v.size()];\nreturn v.toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nfinal boolean lastIsUnparseableHolder = data.length > 0\nint regularExtraFieldCount =\nint sum = WORD * regularExtraFieldCount;\nfor (ZipExtraField element : data) {\nsum += element.getLocalFileDataLength().getValue();\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += local.length + WORD;\nif (lastIsUnparseableHolder) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<init>()V",
                                    "method_body": "public X5455_ExtendedTimestamp() {}\npublic X5455_ExtendedTimestamp() {}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x5455);\npublic X5455_ExtendedTimestamp() {}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn new ZipShort(1 +\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nbyte[] data = new byte[getLocalFileDataLength().getValue()];\nint pos = 0;\ndata[pos++] = 0;\nif (bit0_modifyTimePresent) {\ndata[0] |= MODIFY_TIME_BIT;\nSystem.arraycopy(modifyTime.getBytes(), 0, data, pos, 4);\npos += 4;\nif (bit1_accessTimePresent && accessTime != null) {\ndata[0] |= ACCESS_TIME_BIT;\nSystem.arraycopy(accessTime.getBytes(), 0, data, pos, 4);\npos += 4;\nif (bit2_createTimePresent && createTime != null) {\nreturn data;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:parseFromLocalFileData([BII)V",
                                    "method_body": "public void parseFromLocalFileData(\nreset();\nfinal int len = offset + length;\nsetFlags(data[offset++]);\nif (bit0_modifyTimePresent) {\nmodifyTime = new ZipLong(data, offset);\noffset += 4;\nif (bit1_accessTimePresent && offset + 4 <= len) {\naccessTime = new ZipLong(data, offset);\noffset += 4;\nif (bit2_createTimePresent && offset + 4 <= len) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:reset()V",
                                    "method_body": "private void reset() {\nsetFlags((byte) 0);\nthis.modifyTime = null;\nthis.accessTime = null;\nthis.createTime = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:setFlags(B)V",
                                    "method_body": "public void setFlags(byte flags) {\nthis.flags = flags;\nthis.bit0_modifyTimePresent = (flags & MODIFY_TIME_BIT) == MODIFY_TIME_BIT;\nthis.bit1_accessTimePresent = (flags & ACCESS_TIME_BIT) == ACCESS_TIME_BIT;\nthis.bit2_createTimePresent = (flags & CREATE_TIME_BIT) == CREATE_TIME_BIT;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<init>()V",
                                    "method_body": "public X7875_NewUnix() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x7875);\nprivate static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);\nprivate int version = 1; // always '1' according to current info-zip spec.\npublic X7875_NewUnix() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nint uidSize = trimLeadingZeroesForceMinLength(uid.toByteArray()).length;\nint gidSize = trimLeadingZeroesForceMinLength(gid.toByteArray()).length;\nreturn new ZipShort(3 + uidSize + gidSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nbyte[] uidBytes = uid.toByteArray();\nbyte[] gidBytes = gid.toByteArray();\nuidBytes = trimLeadingZeroesForceMinLength(uidBytes);\ngidBytes = trimLeadingZeroesForceMinLength(gidBytes);\nbyte[] data = new byte[3 + uidBytes.length + gidBytes.length];\nreverse(uidBytes);\nreverse(gidBytes);\nint pos = 0;\ndata[pos++] = unsignedIntToSignedByte(version);\ndata[pos++] = unsignedIntToSignedByte(uidBytes.length);\nSystem.arraycopy(uidBytes, 0, data, pos, uidBytes.length);\npos += uidBytes.length;\ndata[pos++] = unsignedIntToSignedByte(gidBytes.length);\nSystem.arraycopy(gidBytes, 0, data, pos, gidBytes.length);\nreturn data;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:parseFromLocalFileData([BII)V",
                                    "method_body": "public void parseFromLocalFileData(\nreset();\nthis.version = signedByteToUnsignedInt(data[offset++]);\nint uidSize = signedByteToUnsignedInt(data[offset++]);\nbyte[] uidBytes = new byte[uidSize];\nSystem.arraycopy(data, offset, uidBytes, 0, uidSize);\noffset += uidSize;\nthis.uid = new BigInteger(1, reverse(uidBytes)); // sign-bit forced positive\nint gidSize = signedByteToUnsignedInt(data[offset++]);\nbyte[] gidBytes = new byte[gidSize];\nSystem.arraycopy(data, offset, gidBytes, 0, gidSize);\nthis.gid = new BigInteger(1, reverse(gidBytes)); // sign-bit forced positive\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:reset()V",
                                    "method_body": "private void reset() {\nuid = ONE_THOUSAND;\ngid = ONE_THOUSAND;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:trimLeadingZeroesForceMinLength([B)[B",
                                    "method_body": "static byte[] trimLeadingZeroesForceMinLength(byte[] array) {\nif (array == null) {\nint pos = 0;\nfor (byte b : array) {\nif (b == 0) {\nfinal int MIN_LENGTH = 1;\nbyte[] trimmedArray = new byte[Math.max(MIN_LENGTH, array.length - pos)];\nint startPos = trimmedArray.length - (array.length - pos);\nSystem.arraycopy(array, pos, trimmedArray, startPos, trimmedArray.length - startPos);\nreturn trimmedArray;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\npublic JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<init>()V",
                                    "method_body": "public Zip64ExtendedInformationExtraField() { }\npublic Zip64ExtendedInformationExtraField() { }"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<clinit>()V",
                                    "method_body": "static final ZipShort HEADER_ID = new ZipShort(0x0001);\nprivate static final byte[] EMPTY = new byte[0];\n* parseFromCentralDirectoryData} so it can be reused when ZipFile"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:<init>(Ljava/lang/String;II)V",
                                    "method_body": "ZipMethod(int code) {\nthis.code = code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:<clinit>()V",
                                    "method_body": "private final int code;\nMap<Integer, ZipMethod> cte = new HashMap<Integer, ZipMethod>();\nfor (ZipMethod method : values()) {\ncte.put(Integer.valueOf(method.getCode()), method);\ncodeToEnum = Collections.unmodifiableMap(cte);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:getCode()I",
                                    "method_body": "public int getCode() {\nreturn code;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 26,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.utils.IOUtilsTest.skipUsingSkipAndRead",
                            "test_body": "57: public void skipUsingSkipAndRead() throws Exception {\n58: skip(new StreamWrapper() {\n59: public InputStream wrap(final InputStream toWrap) {\n60: return new FilterInputStream(toWrap) {\n61: boolean skipped;\n62: public long skip(long s) throws IOException {\n63: if (!skipped) {\n64: toWrap.skip(5);\n65: skipped = true;\n66: return 5;\n67: }\n68: return 0;\n69: }\n70: };\n71: }\n72: });\n73: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:skip(Ljava/io/InputStream;J)J",
                                    "method_body": "public static long skip(InputStream input, long numToSkip) throws IOException {\nlong available = numToSkip;\nwhile (numToSkip > 0) {\nlong skipped = input.skip(numToSkip);\nif (skipped == 0) {\nbreak;\nnumToSkip -= skipped;\n}\nreturn available - numToSkip;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.utils.IOUtilsTest.skipUsingRead",
                            "test_body": "44: public void skipUsingRead() throws Exception {\n45: skip(new StreamWrapper() {\n46: public InputStream wrap(InputStream toWrap) {\n47: return new FilterInputStream(toWrap) {\n48: public long skip(long s) {\n49: return 0;\n50: }\n51: };\n52: }\n53: });\n54: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:skip(Ljava/io/InputStream;J)J",
                                    "method_body": "public static long skip(InputStream input, long numToSkip) throws IOException {\nlong available = numToSkip;\nwhile (numToSkip > 0) {\nlong skipped = input.skip(numToSkip);\nif (skipped == 0) {\nbreak;\nnumToSkip -= skipped;\n}\nreturn available - numToSkip;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 27,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarUtilsTest.testParseOctal",
                            "test_body": "46: public void testParseOctal() throws Exception{\n47: long value; \n48: byte [] buffer;\n49: final long MAX_OCTAL  = 077777777777L; // Allowed 11 digits\n50: final long MAX_OCTAL_OVERFLOW  = 0777777777777L; // in fact 12 for some implementations\n51: final String maxOctal = \"777777777777\"; // Maximum valid octal\n52: buffer = maxOctal.getBytes(CharsetNames.UTF_8);\n53: value = TarUtils.parseOctal(buffer,0, buffer.length);\n54: assertEquals(MAX_OCTAL_OVERFLOW, value);\n55: buffer[buffer.length - 1] = ' ';\n56: value = TarUtils.parseOctal(buffer,0, buffer.length);\n57: assertEquals(MAX_OCTAL, value);\n58: buffer[buffer.length-1]=0;\n59: value = TarUtils.parseOctal(buffer,0, buffer.length);\n60: assertEquals(MAX_OCTAL, value);\n61: buffer=new byte[]{0,0};\n62: value = TarUtils.parseOctal(buffer,0, buffer.length);\n63: assertEquals(0, value);\n64: buffer=new byte[]{0,' '};\n65: value = TarUtils.parseOctal(buffer,0, buffer.length);\n66: assertEquals(0, value);\n67: buffer=new byte[]{' ',0};\n68: value = TarUtils.parseOctal(buffer,0, buffer.length);\n69: assertEquals(0, value);\n70: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\nMap<String, SimpleEncodingHolder> se =\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\ncharsetName = System.getProperty(\"file.encoding\");\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:<clinit>()V",
                                    "method_body": "private static final int BYTE_MASK = 255;\nstatic final ZipEncoding DEFAULT_ENCODING =\nstatic final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\nif (length < 2){\nif (buffer[start] == 0) {\nreturn 0L;\nwhile (start < end){\nif (buffer[start] == ' '){\nstart++;\nbyte trailer = buffer[end - 1];\nwhile (start < end && (trailer == 0 || trailer == ' ')) {\nend--;\ntrailer = buffer[end - 1];\nif (start == end) {\nthrow new IllegalArgumentException(\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\nif (currentByte < '0' || currentByte > '7'){\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:exceptionMessage([BIIIB)Ljava/lang/String;",
                                    "method_body": "private static String exceptionMessage(byte[] buffer, final int offset,\nString string = new String(buffer, offset, length);\nstring=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed\nfinal String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;\nreturn s;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 28,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest.shouldThrowAnExceptionOnTruncatedEntries",
                            "test_body": "213: public void shouldThrowAnExceptionOnTruncatedEntries() throws Exception {\n214: File dir = mkdir(\"COMPRESS-279\");\n215: TarArchiveInputStream is = getTestStream(\"/COMPRESS-279.tar\");\n216: FileOutputStream out = null;\n217: try {\n218: TarArchiveEntry entry = is.getNextTarEntry();\n219: int count = 0;\n220: while (entry != null) {\n221: out = new FileOutputStream(new File(dir, String.valueOf(count)));\n222: IOUtils.copy(is, out);\n223: out.close();\n224: out = null;\n225: count++;\n226: entry = is.getNextTarEntry();\n227: }\n228: } finally {\n229: is.close();\n230: if (out != null) {\n231: out.close();\n232: }\n233: }\n234: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\nMap<String, SimpleEncodingHolder> se =\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\ncharsetName = System.getProperty(\"file.encoding\");\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data,this.charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:matchAsciiBuffer(Ljava/lang/String;[BII)Z",
                                    "method_body": "public static boolean matchAsciiBuffer(\nbuffer1 = expected.getBytes(CharsetNames.US_ASCII);\n}\nreturn isEqual(buffer1, 0, buffer1.length, buffer, offset, length, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isEqual([BII[BIIZ)Z",
                                    "method_body": "public static boolean isEqual(\nint minLen=length1 < length2 ? length1 : length2;\nfor (int i=0; i < minLen; i++){\nif (buffer1[offset1+i] != buffer2[offset2+i]){\nif (length1 == length2){\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isArrayZero([BI)Z",
                                    "method_body": "public static boolean isArrayZero(byte[] a, int size) {\nfor (int i = 0; i < size; i++) {\nif (a[i] != 0) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:copy(Ljava/io/InputStream;Ljava/io/OutputStream;)J",
                                    "method_body": "public static long copy(final InputStream input, final OutputStream output) throws IOException {\nreturn copy(input, output, COPY_BUF_SIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:copy(Ljava/io/InputStream;Ljava/io/OutputStream;I)J",
                                    "method_body": "public static long copy(final InputStream input, final OutputStream output, int buffersize) throws IOException {\nfinal byte[] buffer = new byte[buffersize];\nint n = 0;\nlong count=0;\nwhile (-1 != (n = input.read(buffer))) {\noutput.write(buffer, 0, n);\ncount += n;\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:skip(Ljava/io/InputStream;J)J",
                                    "method_body": "public static long skip(InputStream input, long numToSkip) throws IOException {\nlong available = numToSkip;\nwhile (numToSkip > 0) {\nlong skipped = input.skip(numToSkip);\nif (skipped == 0) {\nnumToSkip -= skipped;\n}\nwhile (numToSkip > 0) {\nreturn available - numToSkip;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[B)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b) throws IOException {\nreturn readFully(input, b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b, int offset, int len)\nif (len < 0 || offset < 0 || len + offset > b.length) {\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\ncount += x;\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry() {\nString user = System.getProperty(\"user.name\", \"\");\nif (user.length() > MAX_NAMELEN) {\nthis.userName = user;\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/io/File;Ljava/lang/String;)V",
                                    "method_body": "private String name = \"\";\nprivate int userId = 0;\nprivate int groupId = 0;\nprivate long size = 0;\nprivate String linkName = \"\";\nprivate String magic = MAGIC_POSIX;\nprivate String version = VERSION_POSIX;\nprivate String groupName = \"\";\nprivate int devMajor = 0;\nprivate int devMinor = 0;\nprivate TarArchiveEntry() {\nString user = System.getProperty(\"user.name\", \"\");\nif (user.length() > MAX_NAMELEN) {\nthis.userName = user;\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public TarArchiveEntry(byte[] headerBuf, ZipEncoding encoding)\nthis();\nparseTarHeader(headerBuf, encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNUSparse()Z",
                                    "method_body": "public boolean isGNUSparse() {\nreturn linkFlag == LF_GNUTYPE_SPARSE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongLinkEntry()Z",
                                    "method_body": "public boolean isGNULongLinkEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGLINK\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongNameEntry()Z",
                                    "method_body": "public boolean isGNULongNameEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGNAME\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isPaxHeader()Z",
                                    "method_body": "public boolean isPaxHeader(){\nreturn linkFlag == LF_PAX_EXTENDED_HEADER_LC\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public void parseTarHeader(byte[] header, ZipEncoding encoding)\nparseTarHeader(header, encoding, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;Z)V",
                                    "method_body": "private void parseTarHeader(byte[] header, ZipEncoding encoding,\nint offset = 0;\nname = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\noffset += NAMELEN;\nmode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN);\noffset += MODELEN;\nuserId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\noffset += UIDLEN;\ngroupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\noffset += GIDLEN;\nsize = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\noffset += SIZELEN;\nmodTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN);\noffset += MODTIMELEN;\ncheckSumOK = TarUtils.verifyCheckSum(header);\noffset += CHKSUMLEN;\nlinkFlag = header[offset++];\nlinkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\noffset += NAMELEN;\nmagic = TarUtils.parseName(header, offset, MAGICLEN);\noffset += MAGICLEN;\nversion = TarUtils.parseName(header, offset, VERSIONLEN);\noffset += VERSIONLEN;\nuserName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)\noffset += UNAMELEN;\ngroupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN)\noffset += GNAMELEN;\ndevMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\ndevMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\nint type = evaluateType(header);\nswitch (type) {\noffset += ATIMELEN_GNU;\noffset += CTIMELEN_GNU;\noffset += OFFSETLEN_GNU;\noffset += LONGNAMESLEN_GNU;\noffset += PAD2LEN_GNU;\noffset += SPARSELEN_GNU;\nisExtended = TarUtils.parseBoolean(header, offset);\noffset += ISEXTENDEDLEN_GNU;\nrealSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU);\noffset += REALSIZELEN_GNU;\nbreak;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:evaluateType([B)I",
                                    "method_body": "private int evaluateType(byte[] header) {\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_GNU, header, MAGIC_OFFSET, MAGICLEN)) {\nreturn FORMAT_OLDGNU;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:<clinit>()V",
                                    "method_body": "private static final int BYTE_MASK = 255;\nstatic final ZipEncoding DEFAULT_ENCODING =\nstatic final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\nif (length < 2){\nif (buffer[start] == 0) {\nreturn 0L;\nwhile (start < end){\nif (buffer[start] == ' '){\nbyte trailer = buffer[end - 1];\nwhile (start < end && (trailer == 0 || trailer == ' ')) {\nend--;\ntrailer = buffer[end - 1];\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\nif (currentByte < '0' || currentByte > '7'){\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctalOrBinary([BII)J",
                                    "method_body": "public static long parseOctalOrBinary(final byte[] buffer, final int offset,\nif ((buffer[offset] & 0x80) == 0) {\nreturn parseOctal(buffer, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseBoolean([BI)Z",
                                    "method_body": "public static boolean parseBoolean(final byte[] buffer, final int offset) {\nreturn buffer[offset] == 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BII)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset, final int length) {\nreturn parseName(buffer, offset, length, DEFAULT_ENCODING);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BIILorg/apache/commons/compress/archivers/zip/ZipEncoding;)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset,\nint len = length;\nfor (; len > 0; len--) {\nif (buffer[offset + len - 1] != 0) {\nbreak;\nif (len > 0) {\nbyte[] b = new byte[len];\nSystem.arraycopy(buffer, offset, b, 0, len);\nreturn encoding.decode(b);\nreturn \"\";\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:verifyCheckSum([B)Z",
                                    "method_body": "public static boolean verifyCheckSum(byte[] header) {\nlong storedSum = 0;\nlong unsignedSum = 0;\nlong signedSum = 0;\nint digits = 0;\nfor (int i = 0; i < header.length; i++) {\nbyte b = header[i];\nif (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\nif ('0' <= b && b <= '7' && digits++ < 6) {\nstoredSum = storedSum * 8 + b - '0';\n} else if (digits > 0) {\ndigits = 6; // only look at the first octal digit sequence\nb = ' ';\nunsignedSum += 0xff & b;\nsignedSum += b;\nreturn storedSum == unsignedSum || storedSum == signedSum\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is) {\nthis(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\nthis(is, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;IILjava/lang/String;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize,\nString encoding) {\nthis.is = is;\nthis.hasHitEOF = false;\nthis.encoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.recordSize = recordSize;\nthis.blockSize = blockSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nis.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:available()I",
                                    "method_body": "public int available() throws IOException {\nif (entrySize - entryOffset > Integer.MAX_VALUE) {\nreturn (int) (entrySize - entryOffset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:skip(J)J",
                                    "method_body": "public long skip(long numToSkip) throws IOException {\nlong available = entrySize - entryOffset;\nnumToSkip = Math.min(numToSkip, available);\nlong skipped = IOUtils.skip(is, numToSkip);\ncount(skipped);\nentryOffset += skipped;\nreturn skipped;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextTarEntry()Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;",
                                    "method_body": "public TarArchiveEntry getNextTarEntry() throws IOException {\nif (hasHitEOF) {\nreturn null;\nif (currEntry != null) {\nskip(Long.MAX_VALUE);\nskipRecordPadding();\nbyte[] headerBuf = getRecord();\nif (headerBuf == null) {\ncurrEntry = new TarArchiveEntry(headerBuf, encoding);\n}\nentryOffset = 0;\nentrySize = currEntry.getSize();\nif (currEntry.isGNULongLinkEntry()) {\nif (currEntry.isGNULongNameEntry()) {\nif (currEntry.isPaxHeader()){ // Process Pax headers\nif (currEntry.isGNUSparse()){ // Process sparse files\nentrySize = currEntry.getSize();\nreturn currEntry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:skipRecordPadding()V",
                                    "method_body": "private void skipRecordPadding() throws IOException {\nif (this.entrySize > 0 && this.entrySize % this.recordSize != 0) {\nlong numRecords = (this.entrySize / this.recordSize) + 1;\nlong padding = (numRecords * this.recordSize) - this.entrySize;\nlong skipped = IOUtils.skip(is, padding);\ncount(skipped);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getRecord()[B",
                                    "method_body": "private byte[] getRecord() throws IOException {\nbyte[] headerBuf = readRecord();\nhasHitEOF = isEOFRecord(headerBuf);\nif (hasHitEOF && headerBuf != null) {\nreturn headerBuf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:isEOFRecord([B)Z",
                                    "method_body": "protected boolean isEOFRecord(byte[] record) {\nreturn record == null || ArchiveUtils.isArrayZero(record, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:readRecord()[B",
                                    "method_body": "protected byte[] readRecord() throws IOException {\nbyte[] record = new byte[recordSize];\nint readNow = IOUtils.readFully(is, record);\ncount(readNow);\nif (readNow != recordSize) {\nreturn record;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] buf, int offset, int numToRead) throws IOException {\nint totalRead = 0;\nif (hasHitEOF || entryOffset >= entrySize) {\nreturn -1;\nif (currEntry == null) {\nnumToRead = Math.min(numToRead, available());\ntotalRead = is.read(buf, offset, numToRead);\ncount(totalRead);\nif (totalRead == -1) {\nhasHitEOF = true;\nentryOffset += totalRead;\nreturn totalRead;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 29,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest.testEncodingInputStream",
                            "test_body": "307: public void testEncodingInputStream() throws Exception {\n308: int failed = 0;\n309: for(int i = 1; i <= TESTS.length; i++) {\n310: TestData test = TESTS[i-1];\n311: ArchiveInputStream ais = getInputStreamFor(test.type, test.testFile, test.fac);\n312: final String field = getField(ais,test.fieldName);\n313: if (!eq(test.expectedEncoding,field)) {\n314: System.out.println(\"Failed test \" + i + \". expected: \" + test.expectedEncoding + \" actual: \" + field + \" type: \" + test.type);\n315: failed++;\n316: }\n317: }\n318: if (failed > 0) {\n319: fail(\"Tests failed: \" + failed);\n320: }\n321: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:pushedBackBytes(J)V",
                                    "method_body": "protected void pushedBackBytes(long pushedBack) {\nbytesRead -= pushedBack;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>()V",
                                    "method_body": "public ArchiveStreamFactory() {\nthis(null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ArchiveStreamFactory(String encoding) {\nsuper();\nthis.encoding = encoding;\nthis.entryEncoding = encoding;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:setEntryEncoding(Ljava/lang/String;)V",
                                    "method_body": "public void setEntryEncoding(String entryEncoding) {\nif (encoding != null) {\nthis.entryEncoding = entryEncoding;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveInputStream(Ljava/lang/String;Ljava/io/InputStream;)Lorg/apache/commons/compress/archivers/ArchiveInputStream;",
                                    "method_body": "public ArchiveInputStream createArchiveInputStream(\nif (archiverName == null) {\nif (in == null) {\nif (AR.equalsIgnoreCase(archiverName)) {\nif (ARJ.equalsIgnoreCase(archiverName)) {\nif (entryEncoding != null) {\nreturn new ArjArchiveInputStream(in, entryEncoding);\nreturn new ArjArchiveInputStream(in);\nif (ZIP.equalsIgnoreCase(archiverName)) {\nif (entryEncoding != null) {\nreturn new ZipArchiveInputStream(in, entryEncoding);\nreturn new ZipArchiveInputStream(in);\nif (TAR.equalsIgnoreCase(archiverName)) {\nif (entryEncoding != null) {\nreturn new TarArchiveInputStream(in, entryEncoding);\nreturn new TarArchiveInputStream(in);\nif (JAR.equalsIgnoreCase(archiverName)) {\nif (entryEncoding != null) {\nreturn new JarArchiveInputStream(in, entryEncoding);\nreturn new JarArchiveInputStream(in);\nif (CPIO.equalsIgnoreCase(archiverName)) {\nif (entryEncoding != null) {\nreturn new CpioArchiveInputStream(in, entryEncoding);\nreturn new CpioArchiveInputStream(in);\nif (DUMP.equalsIgnoreCase(archiverName)) {\nif (entryEncoding != null) {\nreturn new DumpArchiveInputStream(in, entryEncoding);\nreturn new DumpArchiveInputStream(in);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\nMap<String, SimpleEncodingHolder> se =\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\nif (name == null) {\nSimpleEncodingHolder h = simpleEncodings.get(name);\nif (h!=null) {\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\ncharsetName = System.getProperty(\"file.encoding\");\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\nfor (String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data,this.charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:<init>(Ljava/nio/charset/Charset;)V",
                                    "method_body": "public NioZipEncoding(Charset charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nreturn this.charset.newDecoder()\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b, int offset, int len)\nif (len < 0 || offset < 0 || len + offset > b.length) {\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\ncount += x;\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public CpioArchiveInputStream(final InputStream in) {\nthis(in, BLOCK_SIZE, CharsetNames.US_ASCII);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public CpioArchiveInputStream(final InputStream in, String encoding) {\nthis(in, BLOCK_SIZE, encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:<init>(Ljava/io/InputStream;ILjava/lang/String;)V",
                                    "method_body": "public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\nthis.in = in;\nthis.blockSize = blockSize;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream) {\nthis(inputStream, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream, String encoding) {\nthis(inputStream, encoding, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields) {\nthis(inputStream, encoding, useUnicodeExtraFields, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;ZZ)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream,\nboolean allowStoredEntriesWithDataDescriptor) {\nzipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\nin = new PushbackInputStream(inputStream, buf.capacity());\nthis.allowStoredEntriesWithDataDescriptor =\nbuf.limit(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<clinit>()V",
                                    "method_body": "private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\nprivate static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\nprivate static final byte[] DD = ZipLong.DD_SIG.getBytes();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nputLong(value, result, 0);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:putLong(J[BI)V",
                                    "method_body": "public static void putLong(long value, byte[] buf, int offset) {\nbuf[offset++] = (byte) ((value & BYTE_MASK));\nbuf[offset++] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nbuf[offset++] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nbuf[offset] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public JarArchiveInputStream( final InputStream inputStream ) {\nsuper(inputStream);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public JarArchiveInputStream( final InputStream inputStream, final String encoding ) {\nsuper(inputStream, encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public ArjArchiveInputStream(final InputStream inputStream,\nfinal String charsetName) throws ArchiveException {\nin = new DataInputStream(inputStream);\nthis.charsetName = charsetName;\nmainHeader = readMainHeader();\nif ((mainHeader.arjFlags & MainHeader.Flags.GARBLED) != 0) {\nif ((mainHeader.arjFlags & MainHeader.Flags.VOLUME) != 0) {\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public ArjArchiveInputStream(final InputStream inputStream)\nthis(inputStream, \"CP437\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:read8(Ljava/io/DataInputStream;)I",
                                    "method_body": "private int read8(final DataInputStream dataIn) throws IOException {\nint value = dataIn.readUnsignedByte();\ncount(1);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:read16(Ljava/io/DataInputStream;)I",
                                    "method_body": "private int read16(final DataInputStream dataIn) throws IOException {\nfinal int value = dataIn.readUnsignedShort();\ncount(2);\nreturn Integer.reverseBytes(value) >>> 16;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:read32(Ljava/io/DataInputStream;)I",
                                    "method_body": "private int read32(final DataInputStream dataIn) throws IOException {\nfinal int value = dataIn.readInt();\ncount(4);\nreturn Integer.reverseBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:readString(Ljava/io/DataInputStream;)Ljava/lang/String;",
                                    "method_body": "private String readString(final DataInputStream dataIn) throws IOException {\nfinal ByteArrayOutputStream buffer = new ByteArrayOutputStream();\nwhile ((nextByte = dataIn.readUnsignedByte()) != 0) {\nbuffer.write(nextByte);\nif (charsetName != null) {\nreturn new String(buffer.toByteArray(), charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:readFully(Ljava/io/DataInputStream;[B)V",
                                    "method_body": "private void readFully(final DataInputStream dataIn, byte[] b)\ndataIn.readFully(b);\ncount(b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:readHeader()[B",
                                    "method_body": "private byte[] readHeader() throws IOException {\nboolean found = false;\nbyte[] basicHeaderBytes = null;\nint first = 0;\nint second = read8(in);\nfirst = second;\nsecond = read8(in);\n} while (first != ARJ_MAGIC_1 && second != ARJ_MAGIC_2);\nfinal int basicHeaderSize = read16(in);\nif (basicHeaderSize == 0) {\nif (basicHeaderSize <= 2600) {\nbasicHeaderBytes = new byte[basicHeaderSize];\nreadFully(in, basicHeaderBytes);\nfinal long basicHeaderCrc32 = read32(in) & 0xFFFFFFFFL;\nfinal CRC32 crc32 = new CRC32();\ncrc32.update(basicHeaderBytes);\nif (basicHeaderCrc32 == crc32.getValue()) {\nfound = true;\n} while (!found);\nreturn basicHeaderBytes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:readMainHeader()Lorg/apache/commons/compress/archivers/arj/MainHeader;",
                                    "method_body": "private MainHeader readMainHeader() throws IOException {\nfinal byte[] basicHeaderBytes = readHeader();\nif (basicHeaderBytes == null) {\nfinal DataInputStream basicHeader = new DataInputStream(\nfinal int firstHeaderSize = basicHeader.readUnsignedByte();\nfinal byte[] firstHeaderBytes = new byte[firstHeaderSize - 1];\nbasicHeader.readFully(firstHeaderBytes);\nfinal DataInputStream firstHeader = new DataInputStream(\nfinal MainHeader hdr = new MainHeader();\nhdr.archiverVersionNumber = firstHeader.readUnsignedByte();\nhdr.minVersionToExtract = firstHeader.readUnsignedByte();\nhdr.hostOS = firstHeader.readUnsignedByte();\nhdr.arjFlags = firstHeader.readUnsignedByte();\nhdr.securityVersion = firstHeader.readUnsignedByte();\nhdr.fileType = firstHeader.readUnsignedByte();\nhdr.reserved = firstHeader.readUnsignedByte();\nhdr.dateTimeCreated = read32(firstHeader);\nhdr.dateTimeModified = read32(firstHeader);\nhdr.archiveSize = 0xffffFFFFL & read32(firstHeader);\nhdr.securityEnvelopeFilePosition = read32(firstHeader);\nhdr.fileSpecPosition = read16(firstHeader);\nhdr.securityEnvelopeLength = read16(firstHeader);\npushedBackBytes(20); // count has already counted them via readFully\nhdr.encryptionVersion = firstHeader.readUnsignedByte();\nhdr.lastChapter = firstHeader.readUnsignedByte();\nif (firstHeaderSize >= 33) {\nhdr.arjProtectionFactor = firstHeader.readUnsignedByte();\nhdr.arjFlags2 = firstHeader.readUnsignedByte();\nfirstHeader.readUnsignedByte();\nfirstHeader.readUnsignedByte();\nhdr.name = readString(basicHeader);\nhdr.comment = readString(basicHeader);\nfinal  int extendedHeaderSize = read16(in);\nif (extendedHeaderSize > 0) {\nreturn hdr;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public DumpArchiveInputStream(InputStream is) throws ArchiveException {\nthis(is, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public DumpArchiveInputStream(InputStream is, String encoding)\nthrows ArchiveException {\nthis.raw = new TapeInputStream(is);\nthis.hasHitEOF = false;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nbyte[] headerBytes = raw.readRecord();\nif (!DumpArchiveUtil.verify(headerBytes)) {\nsummary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\nraw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\nblockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\nreadCLRI();\nreadBITS();\n}\nDirent root = new Dirent(2, 2, 4, \".\");\nnames.put(2, root);\nqueue = new PriorityQueue<DumpArchiveEntry>(10,\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:readCLRI()V",
                                    "method_body": "private void readCLRI() throws IOException {\nbyte[] buffer = raw.readRecord();\nif (!DumpArchiveUtil.verify(buffer)) {\nactive = DumpArchiveEntry.parse(buffer);\nif (DumpArchiveConstants.SEGMENT_TYPE.CLRI != active.getHeaderType()) {\nif (raw.skip(DumpArchiveConstants.TP_SIZE * active.getHeaderCount())\nreadIdx = active.getHeaderCount();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:readBITS()V",
                                    "method_body": "private void readBITS() throws IOException {\nbyte[] buffer = raw.readRecord();\nif (!DumpArchiveUtil.verify(buffer)) {\nactive = DumpArchiveEntry.parse(buffer);\nif (DumpArchiveConstants.SEGMENT_TYPE.BITS != active.getHeaderType()) {\nif (raw.skip(DumpArchiveConstants.TP_SIZE * active.getHeaderCount())\nreadIdx = active.getHeaderCount();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:calculateChecksum([B)I",
                                    "method_body": "public static int calculateChecksum(byte[] buffer) {\nint calc = 0;\nfor (int i = 0; i < 256; i++) {\ncalc += DumpArchiveUtil.convert32(buffer, 4 * i);\nreturn DumpArchiveConstants.CHECKSUM -\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:verify([B)Z",
                                    "method_body": "public static final boolean verify(byte[] buffer) {\nint magic = convert32(buffer, 24);\nif (magic != DumpArchiveConstants.NFS_MAGIC) {\nint checksum = convert32(buffer, 28);\nif (checksum != calculateChecksum(buffer)) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert64([BI)J",
                                    "method_body": "public static final long convert64(byte[] buffer, int offset) {\nlong i = 0;\ni += (((long) buffer[offset + 7]) << 56);\ni += (((long) buffer[offset + 6] << 48) & 0x00FF000000000000L);\ni += (((long) buffer[offset + 5] << 40) & 0x0000FF0000000000L);\ni += (((long) buffer[offset + 4] << 32) & 0x000000FF00000000L);\ni += (((long) buffer[offset + 3] << 24) & 0x00000000FF000000L);\ni += (((long) buffer[offset + 2] << 16) & 0x0000000000FF0000L);\ni += (((long) buffer[offset + 1] << 8) & 0x000000000000FF00L);\ni += (buffer[offset] & 0x00000000000000FFL);\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert32([BI)I",
                                    "method_body": "public static final int convert32(byte[] buffer, int offset) {\nint i = 0;\ni = buffer[offset + 3] << 24;\ni += (buffer[offset + 2] << 16) & 0x00FF0000;\ni += (buffer[offset + 1] << 8) & 0x0000FF00;\ni += buffer[offset] & 0x000000FF;\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert16([BI)I",
                                    "method_body": "public static final int convert16(byte[] buffer, int offset) {\nint i = 0;\ni += (buffer[offset + 1] << 8) & 0x0000FF00;\ni += buffer[offset] & 0x000000FF;\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:decode(Lorg/apache/commons/compress/archivers/zip/ZipEncoding;[BII)Ljava/lang/String;",
                                    "method_body": "static String decode(ZipEncoding encoding, byte[] b, int offset, int len)\nbyte[] copy = new byte[len];\nSystem.arraycopy(b, offset, copy, 0, len);\nreturn encoding.decode(copy);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "private byte[] blockBuffer = new byte[DumpArchiveConstants.TP_SIZE];\nprivate int currBlkIdx = -1;\nprivate int blockSize = DumpArchiveConstants.TP_SIZE;\nprivate int readOffset = DumpArchiveConstants.TP_SIZE;\nprivate boolean isCompressed = false;\nprivate long bytesRead = 0;\nsuper(in);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:resetBlockSize(IZ)V",
                                    "method_body": "public void resetBlockSize(int recsPerBlock, boolean isCompressed)\nthis.isCompressed = isCompressed;\nblockSize = recordSize * recsPerBlock;\nbyte[] oldBuffer = blockBuffer;\nblockBuffer = new byte[blockSize];\nSystem.arraycopy(oldBuffer, 0, blockBuffer, 0, recordSize);\nreadFully(blockBuffer, recordSize, blockSize - recordSize);\nthis.currBlkIdx = 0;\nthis.readOffset = recordSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif ((len % recordSize) != 0) {\nint bytes = 0;\nwhile (bytes < len) {\nif ((readOffset == blockSize) && !readBlock(true)) {\nint n = 0;\nif ((readOffset + (len - bytes)) <= blockSize) {\nn = len - bytes;\nSystem.arraycopy(blockBuffer, readOffset, b, off, n);\nreadOffset += n;\nbytes += n;\noff += n;\n}\nreturn bytes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:skip(J)J",
                                    "method_body": "public long skip(long len) throws IOException {\nif ((len % recordSize) != 0) {\nlong bytes = 0;\nwhile (bytes < len) {\nif ((readOffset == blockSize) &&\nlong n = 0;\nif ((readOffset + (len - bytes)) <= blockSize) {\nn = len - bytes;\nn = blockSize - readOffset;\nreadOffset += n;\nbytes += n;\n}\nreturn bytes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:readRecord()[B",
                                    "method_body": "public byte[] readRecord() throws IOException {\nbyte[] result = new byte[recordSize];\nif (-1 == read(result, 0, result.length)) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:readBlock(Z)Z",
                                    "method_body": "private boolean readBlock(boolean decompress) throws IOException {\nboolean success = true;\nif (in == null) {\nif (!isCompressed || (currBlkIdx == -1)) {\nsuccess = readFully(blockBuffer, 0, blockSize);\nbytesRead += blockSize;\ncurrBlkIdx++;\nreadOffset = 0;\nreturn success;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:readFully([BII)Z",
                                    "method_body": "private boolean readFully(byte[] b, int off, int len)\nint count = IOUtils.readFully(in, b, off, len);\nif (count < len) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveSummary:<init>([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "DumpArchiveSummary(byte[] buffer, ZipEncoding encoding) throws IOException {\ndumpDate = 1000L * DumpArchiveUtil.convert32(buffer, 4);\npreviousDumpDate = 1000L * DumpArchiveUtil.convert32(buffer, 8);\nvolume = DumpArchiveUtil.convert32(buffer, 12);\nlabel = DumpArchiveUtil.decode(encoding, buffer, 676, DumpArchiveConstants.LBLSIZE).trim();\nlevel = DumpArchiveUtil.convert32(buffer, 692);\nfilesys = DumpArchiveUtil.decode(encoding, buffer, 696, DumpArchiveConstants.NAMELEN).trim();\ndevname = DumpArchiveUtil.decode(encoding, buffer, 760, DumpArchiveConstants.NAMELEN).trim();\nhostname = DumpArchiveUtil.decode(encoding, buffer, 824, DumpArchiveConstants.NAMELEN).trim();\nflags = DumpArchiveUtil.convert32(buffer, 888);\nfirstrec = DumpArchiveUtil.convert32(buffer, 892);\nntrec = DumpArchiveUtil.convert32(buffer, 896);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveSummary:getNTRec()I",
                                    "method_body": "public int getNTRec() {\nreturn ntrec;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveSummary:isCompressed()Z",
                                    "method_body": "public boolean isCompressed() {\nreturn (flags & 0x0080) == 0x0080;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:<init>()V",
                                    "method_body": "public DumpArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:<init>(Ljava/lang/String;Ljava/lang/String;ILorg/apache/commons/compress/archivers/dump/DumpArchiveEntry$TYPE;)V",
                                    "method_body": "private String name;\nprivate TYPE type = TYPE.UNKNOWN;\nprivate Set<PERMISSION> permissions = Collections.emptySet();\nprivate final DumpArchiveSummary summary = null;\nprivate final TapeSegmentHeader header = new TapeSegmentHeader();\npublic DumpArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:getHeaderType()Lorg/apache/commons/compress/archivers/dump/DumpArchiveConstants$SEGMENT_TYPE;",
                                    "method_body": "public DumpArchiveConstants.SEGMENT_TYPE getHeaderType() {\nreturn header.getType();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:getHeaderCount()I",
                                    "method_body": "public int getHeaderCount() {\nreturn header.getCount();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:parse([B)Lorg/apache/commons/compress/archivers/dump/DumpArchiveEntry;",
                                    "method_body": "static DumpArchiveEntry parse(byte[] buffer) {\nDumpArchiveEntry entry = new DumpArchiveEntry();\nTapeSegmentHeader header = entry.header;\nheader.type = DumpArchiveConstants.SEGMENT_TYPE.find(DumpArchiveUtil.convert32(\nheader.volume = DumpArchiveUtil.convert32(buffer, 12);\nentry.ino = header.ino = DumpArchiveUtil.convert32(buffer, 20);\nint m = DumpArchiveUtil.convert16(buffer, 32);\nentry.setType(TYPE.find((m >> 12) & 0x0F));\nentry.setMode(m);\nentry.nlink = DumpArchiveUtil.convert16(buffer, 34);\nentry.setSize(DumpArchiveUtil.convert64(buffer, 40));\nlong t = (1000L * DumpArchiveUtil.convert32(buffer, 48)) +\nentry.setAccessTime(new Date(t));\nt = (1000L * DumpArchiveUtil.convert32(buffer, 56)) +\nentry.setLastModifiedDate(new Date(t));\nt = (1000L * DumpArchiveUtil.convert32(buffer, 64)) +\nentry.ctime = t;\nentry.generation = DumpArchiveUtil.convert32(buffer, 140);\nentry.setUserId(DumpArchiveUtil.convert32(buffer, 144));\nentry.setGroupId(DumpArchiveUtil.convert32(buffer, 148));\nheader.count = DumpArchiveUtil.convert32(buffer, 160);\nheader.holes = 0;\nfor (int i = 0; (i < 512) && (i < header.count); i++) {\nif (buffer[164 + i] == 0) {\nheader.holes++;\nSystem.arraycopy(buffer, 164, header.cdata, 0, 512);\nentry.volume = header.getVolume();\nreturn entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setType(Lorg/apache/commons/compress/archivers/dump/DumpArchiveEntry$TYPE;)V",
                                    "method_body": "public void setType(TYPE type) {\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setMode(I)V",
                                    "method_body": "public void setMode(int mode) {\nthis.mode = mode & 07777;\nthis.permissions = PERMISSION.find(mode);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setLastModifiedDate(Ljava/util/Date;)V",
                                    "method_body": "public void setLastModifiedDate(Date mtime) {\nthis.mtime = mtime.getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setAccessTime(Ljava/util/Date;)V",
                                    "method_body": "public void setAccessTime(Date atime) {\nthis.atime = atime.getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setUserId(I)V",
                                    "method_body": "public void setUserId(int uid) {\nthis.uid = uid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setGroupId(I)V",
                                    "method_body": "public void setGroupId(int gid) {\nthis.gid = gid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TYPE:<init>(Ljava/lang/String;II)V",
                                    "method_body": "private TYPE(int code) {\nthis.code = code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TYPE:find(I)Lorg/apache/commons/compress/archivers/dump/DumpArchiveEntry$TYPE;",
                                    "method_body": "public static TYPE find(int code) {\nTYPE type = UNKNOWN;\nfor (TYPE t : TYPE.values()) {\nif (code == t.code) {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TapeSegmentHeader:<init>()V",
                                    "method_body": "private DumpArchiveConstants.SEGMENT_TYPE type;\nprivate final byte[] cdata = new byte[512]; // map of any 'holes'\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TapeSegmentHeader:getType()Lorg/apache/commons/compress/archivers/dump/DumpArchiveConstants$SEGMENT_TYPE;",
                                    "method_body": "public DumpArchiveConstants.SEGMENT_TYPE getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TapeSegmentHeader:getVolume()I",
                                    "method_body": "public int getVolume() {\nreturn volume;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TapeSegmentHeader:getCount()I",
                                    "method_body": "public int getCount() {\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveConstants$SEGMENT_TYPE:<init>(Ljava/lang/String;II)V",
                                    "method_body": "private SEGMENT_TYPE(int code) {\nthis.code = code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveConstants$SEGMENT_TYPE:find(I)Lorg/apache/commons/compress/archivers/dump/DumpArchiveConstants$SEGMENT_TYPE;",
                                    "method_body": "public static SEGMENT_TYPE find(int code) {\nfor (SEGMENT_TYPE t : values()) {\nif (t.code == code) {\nreturn t;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$PERMISSION:<init>(Ljava/lang/String;II)V",
                                    "method_body": "private PERMISSION(int code) {\nthis.code = code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$PERMISSION:find(I)Ljava/util/Set;",
                                    "method_body": "public static Set<PERMISSION> find(int code) {\nSet<PERMISSION> set = new HashSet<PERMISSION>();\nfor (PERMISSION p : PERMISSION.values()) {\nif ((code & p.code) == p.code) {\nif (set.isEmpty()) {\nreturn Collections.emptySet();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.Dirent:<init>(IIILjava/lang/String;)V",
                                    "method_body": "Dirent(int ino, int parentIno, int type, String name) {\nthis.ino = ino;\nthis.parentIno = parentIno;\nthis.type = type;\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is) {\nthis(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, String encoding) {\nthis(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE,\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\nthis(is, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;IILjava/lang/String;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize,\nString encoding) {\nthis.is = is;\nthis.hasHitEOF = false;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.recordSize = recordSize;\nthis.blockSize = blockSize;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest.testEncodingOutputStream",
                            "test_body": "324: public void testEncodingOutputStream() throws Exception {\n325: int failed = 0;\n326: for(int i = 1; i <= TESTS.length; i++) {\n327: TestData test = TESTS[i-1];\n328: if (test.hasOutputStream) {\n329: ArchiveOutputStream ais = getOutputStreamFor(test.type, test.fac);\n330: final String field = getField(ais, test.fieldName);\n331: if (!eq(test.expectedEncoding, field)) {\n332: System.out.println(\"Failed test \" + i + \". expected: \" + test.expectedEncoding + \" actual: \" + field + \" type: \" + test.type);\n333: failed++;\n334: }\n335: }\n336: }\n337: if (failed > 0) {\n338: fail(\"Tests failed: \" + failed);\n339: }\n340: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:pushedBackBytes(J)V",
                                    "method_body": "protected void pushedBackBytes(long pushedBack) {\nbytesRead -= pushedBack;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>()V",
                                    "method_body": "public ArchiveStreamFactory() {\nthis(null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ArchiveStreamFactory(String encoding) {\nsuper();\nthis.encoding = encoding;\nthis.entryEncoding = encoding;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:setEntryEncoding(Ljava/lang/String;)V",
                                    "method_body": "public void setEntryEncoding(String entryEncoding) {\nif (encoding != null) {\nthis.entryEncoding = entryEncoding;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\nMap<String, SimpleEncodingHolder> se =\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\nif (name == null) {\nSimpleEncodingHolder h = simpleEncodings.get(name);\nif (h!=null) {\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\ncharsetName = System.getProperty(\"file.encoding\");\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\nfor (String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data,this.charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:<init>(Ljava/nio/charset/Charset;)V",
                                    "method_body": "public NioZipEncoding(Charset charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b, int offset, int len)\nif (len < 0 || offset < 0 || len + offset > b.length) {\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\ncount += x;\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public CpioArchiveInputStream(final InputStream in) {\nthis(in, BLOCK_SIZE, CharsetNames.US_ASCII);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:<init>(Ljava/io/InputStream;ILjava/lang/String;)V",
                                    "method_body": "public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\nthis.in = in;\nthis.blockSize = blockSize;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream) {\nthis(inputStream, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream, String encoding) {\nthis(inputStream, encoding, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields) {\nthis(inputStream, encoding, useUnicodeExtraFields, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;ZZ)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream,\nboolean allowStoredEntriesWithDataDescriptor) {\nzipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\nin = new PushbackInputStream(inputStream, buf.capacity());\nthis.allowStoredEntriesWithDataDescriptor =\nbuf.limit(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<clinit>()V",
                                    "method_body": "private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\nprivate static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\nprivate static final byte[] DD = ZipLong.DD_SIG.getBytes();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nputLong(value, result, 0);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:putLong(J[BI)V",
                                    "method_body": "public static void putLong(long value, byte[] buf, int offset) {\nbuf[offset++] = (byte) ((value & BYTE_MASK));\nbuf[offset++] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nbuf[offset++] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nbuf[offset] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public JarArchiveInputStream( final InputStream inputStream ) {\nsuper(inputStream);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public ArjArchiveInputStream(final InputStream inputStream,\nfinal String charsetName) throws ArchiveException {\nin = new DataInputStream(inputStream);\nthis.charsetName = charsetName;\nmainHeader = readMainHeader();\nif ((mainHeader.arjFlags & MainHeader.Flags.GARBLED) != 0) {\nif ((mainHeader.arjFlags & MainHeader.Flags.VOLUME) != 0) {\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public ArjArchiveInputStream(final InputStream inputStream)\nthis(inputStream, \"CP437\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:read8(Ljava/io/DataInputStream;)I",
                                    "method_body": "private int read8(final DataInputStream dataIn) throws IOException {\nint value = dataIn.readUnsignedByte();\ncount(1);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:read16(Ljava/io/DataInputStream;)I",
                                    "method_body": "private int read16(final DataInputStream dataIn) throws IOException {\nfinal int value = dataIn.readUnsignedShort();\ncount(2);\nreturn Integer.reverseBytes(value) >>> 16;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:read32(Ljava/io/DataInputStream;)I",
                                    "method_body": "private int read32(final DataInputStream dataIn) throws IOException {\nfinal int value = dataIn.readInt();\ncount(4);\nreturn Integer.reverseBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:readString(Ljava/io/DataInputStream;)Ljava/lang/String;",
                                    "method_body": "private String readString(final DataInputStream dataIn) throws IOException {\nfinal ByteArrayOutputStream buffer = new ByteArrayOutputStream();\nwhile ((nextByte = dataIn.readUnsignedByte()) != 0) {\nbuffer.write(nextByte);\nif (charsetName != null) {\nreturn new String(buffer.toByteArray(), charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:readFully(Ljava/io/DataInputStream;[B)V",
                                    "method_body": "private void readFully(final DataInputStream dataIn, byte[] b)\ndataIn.readFully(b);\ncount(b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:readHeader()[B",
                                    "method_body": "private byte[] readHeader() throws IOException {\nboolean found = false;\nbyte[] basicHeaderBytes = null;\nint first = 0;\nint second = read8(in);\nfirst = second;\nsecond = read8(in);\n} while (first != ARJ_MAGIC_1 && second != ARJ_MAGIC_2);\nfinal int basicHeaderSize = read16(in);\nif (basicHeaderSize == 0) {\nif (basicHeaderSize <= 2600) {\nbasicHeaderBytes = new byte[basicHeaderSize];\nreadFully(in, basicHeaderBytes);\nfinal long basicHeaderCrc32 = read32(in) & 0xFFFFFFFFL;\nfinal CRC32 crc32 = new CRC32();\ncrc32.update(basicHeaderBytes);\nif (basicHeaderCrc32 == crc32.getValue()) {\nfound = true;\n} while (!found);\nreturn basicHeaderBytes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:readMainHeader()Lorg/apache/commons/compress/archivers/arj/MainHeader;",
                                    "method_body": "private MainHeader readMainHeader() throws IOException {\nfinal byte[] basicHeaderBytes = readHeader();\nif (basicHeaderBytes == null) {\nfinal DataInputStream basicHeader = new DataInputStream(\nfinal int firstHeaderSize = basicHeader.readUnsignedByte();\nfinal byte[] firstHeaderBytes = new byte[firstHeaderSize - 1];\nbasicHeader.readFully(firstHeaderBytes);\nfinal DataInputStream firstHeader = new DataInputStream(\nfinal MainHeader hdr = new MainHeader();\nhdr.archiverVersionNumber = firstHeader.readUnsignedByte();\nhdr.minVersionToExtract = firstHeader.readUnsignedByte();\nhdr.hostOS = firstHeader.readUnsignedByte();\nhdr.arjFlags = firstHeader.readUnsignedByte();\nhdr.securityVersion = firstHeader.readUnsignedByte();\nhdr.fileType = firstHeader.readUnsignedByte();\nhdr.reserved = firstHeader.readUnsignedByte();\nhdr.dateTimeCreated = read32(firstHeader);\nhdr.dateTimeModified = read32(firstHeader);\nhdr.archiveSize = 0xffffFFFFL & read32(firstHeader);\nhdr.securityEnvelopeFilePosition = read32(firstHeader);\nhdr.fileSpecPosition = read16(firstHeader);\nhdr.securityEnvelopeLength = read16(firstHeader);\npushedBackBytes(20); // count has already counted them via readFully\nhdr.encryptionVersion = firstHeader.readUnsignedByte();\nhdr.lastChapter = firstHeader.readUnsignedByte();\nif (firstHeaderSize >= 33) {\nhdr.arjProtectionFactor = firstHeader.readUnsignedByte();\nhdr.arjFlags2 = firstHeader.readUnsignedByte();\nfirstHeader.readUnsignedByte();\nfirstHeader.readUnsignedByte();\nhdr.name = readString(basicHeader);\nhdr.comment = readString(basicHeader);\nfinal  int extendedHeaderSize = read16(in);\nif (extendedHeaderSize > 0) {\nreturn hdr;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public DumpArchiveInputStream(InputStream is) throws ArchiveException {\nthis(is, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public DumpArchiveInputStream(InputStream is, String encoding)\nthrows ArchiveException {\nthis.raw = new TapeInputStream(is);\nthis.hasHitEOF = false;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nbyte[] headerBytes = raw.readRecord();\nif (!DumpArchiveUtil.verify(headerBytes)) {\nsummary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\nraw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\nblockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\nreadCLRI();\nreadBITS();\n}\nDirent root = new Dirent(2, 2, 4, \".\");\nnames.put(2, root);\nqueue = new PriorityQueue<DumpArchiveEntry>(10,\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:readCLRI()V",
                                    "method_body": "private void readCLRI() throws IOException {\nbyte[] buffer = raw.readRecord();\nif (!DumpArchiveUtil.verify(buffer)) {\nactive = DumpArchiveEntry.parse(buffer);\nif (DumpArchiveConstants.SEGMENT_TYPE.CLRI != active.getHeaderType()) {\nif (raw.skip(DumpArchiveConstants.TP_SIZE * active.getHeaderCount())\nreadIdx = active.getHeaderCount();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:readBITS()V",
                                    "method_body": "private void readBITS() throws IOException {\nbyte[] buffer = raw.readRecord();\nif (!DumpArchiveUtil.verify(buffer)) {\nactive = DumpArchiveEntry.parse(buffer);\nif (DumpArchiveConstants.SEGMENT_TYPE.BITS != active.getHeaderType()) {\nif (raw.skip(DumpArchiveConstants.TP_SIZE * active.getHeaderCount())\nreadIdx = active.getHeaderCount();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:calculateChecksum([B)I",
                                    "method_body": "public static int calculateChecksum(byte[] buffer) {\nint calc = 0;\nfor (int i = 0; i < 256; i++) {\ncalc += DumpArchiveUtil.convert32(buffer, 4 * i);\nreturn DumpArchiveConstants.CHECKSUM -\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:verify([B)Z",
                                    "method_body": "public static final boolean verify(byte[] buffer) {\nint magic = convert32(buffer, 24);\nif (magic != DumpArchiveConstants.NFS_MAGIC) {\nint checksum = convert32(buffer, 28);\nif (checksum != calculateChecksum(buffer)) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert64([BI)J",
                                    "method_body": "public static final long convert64(byte[] buffer, int offset) {\nlong i = 0;\ni += (((long) buffer[offset + 7]) << 56);\ni += (((long) buffer[offset + 6] << 48) & 0x00FF000000000000L);\ni += (((long) buffer[offset + 5] << 40) & 0x0000FF0000000000L);\ni += (((long) buffer[offset + 4] << 32) & 0x000000FF00000000L);\ni += (((long) buffer[offset + 3] << 24) & 0x00000000FF000000L);\ni += (((long) buffer[offset + 2] << 16) & 0x0000000000FF0000L);\ni += (((long) buffer[offset + 1] << 8) & 0x000000000000FF00L);\ni += (buffer[offset] & 0x00000000000000FFL);\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert32([BI)I",
                                    "method_body": "public static final int convert32(byte[] buffer, int offset) {\nint i = 0;\ni = buffer[offset + 3] << 24;\ni += (buffer[offset + 2] << 16) & 0x00FF0000;\ni += (buffer[offset + 1] << 8) & 0x0000FF00;\ni += buffer[offset] & 0x000000FF;\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert16([BI)I",
                                    "method_body": "public static final int convert16(byte[] buffer, int offset) {\nint i = 0;\ni += (buffer[offset + 1] << 8) & 0x0000FF00;\ni += buffer[offset] & 0x000000FF;\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:decode(Lorg/apache/commons/compress/archivers/zip/ZipEncoding;[BII)Ljava/lang/String;",
                                    "method_body": "static String decode(ZipEncoding encoding, byte[] b, int offset, int len)\nbyte[] copy = new byte[len];\nSystem.arraycopy(b, offset, copy, 0, len);\nreturn encoding.decode(copy);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "private byte[] blockBuffer = new byte[DumpArchiveConstants.TP_SIZE];\nprivate int currBlkIdx = -1;\nprivate int blockSize = DumpArchiveConstants.TP_SIZE;\nprivate int readOffset = DumpArchiveConstants.TP_SIZE;\nprivate boolean isCompressed = false;\nprivate long bytesRead = 0;\nsuper(in);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:resetBlockSize(IZ)V",
                                    "method_body": "public void resetBlockSize(int recsPerBlock, boolean isCompressed)\nthis.isCompressed = isCompressed;\nblockSize = recordSize * recsPerBlock;\nbyte[] oldBuffer = blockBuffer;\nblockBuffer = new byte[blockSize];\nSystem.arraycopy(oldBuffer, 0, blockBuffer, 0, recordSize);\nreadFully(blockBuffer, recordSize, blockSize - recordSize);\nthis.currBlkIdx = 0;\nthis.readOffset = recordSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif ((len % recordSize) != 0) {\nint bytes = 0;\nwhile (bytes < len) {\nif ((readOffset == blockSize) && !readBlock(true)) {\nint n = 0;\nif ((readOffset + (len - bytes)) <= blockSize) {\nn = len - bytes;\nSystem.arraycopy(blockBuffer, readOffset, b, off, n);\nreadOffset += n;\nbytes += n;\noff += n;\n}\nreturn bytes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:skip(J)J",
                                    "method_body": "public long skip(long len) throws IOException {\nif ((len % recordSize) != 0) {\nlong bytes = 0;\nwhile (bytes < len) {\nif ((readOffset == blockSize) &&\nlong n = 0;\nif ((readOffset + (len - bytes)) <= blockSize) {\nn = len - bytes;\nn = blockSize - readOffset;\nreadOffset += n;\nbytes += n;\n}\nreturn bytes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:readRecord()[B",
                                    "method_body": "public byte[] readRecord() throws IOException {\nbyte[] result = new byte[recordSize];\nif (-1 == read(result, 0, result.length)) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:readBlock(Z)Z",
                                    "method_body": "private boolean readBlock(boolean decompress) throws IOException {\nboolean success = true;\nif (in == null) {\nif (!isCompressed || (currBlkIdx == -1)) {\nsuccess = readFully(blockBuffer, 0, blockSize);\nbytesRead += blockSize;\ncurrBlkIdx++;\nreadOffset = 0;\nreturn success;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:readFully([BII)Z",
                                    "method_body": "private boolean readFully(byte[] b, int off, int len)\nint count = IOUtils.readFully(in, b, off, len);\nif (count < len) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveSummary:<init>([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "DumpArchiveSummary(byte[] buffer, ZipEncoding encoding) throws IOException {\ndumpDate = 1000L * DumpArchiveUtil.convert32(buffer, 4);\npreviousDumpDate = 1000L * DumpArchiveUtil.convert32(buffer, 8);\nvolume = DumpArchiveUtil.convert32(buffer, 12);\nlabel = DumpArchiveUtil.decode(encoding, buffer, 676, DumpArchiveConstants.LBLSIZE).trim();\nlevel = DumpArchiveUtil.convert32(buffer, 692);\nfilesys = DumpArchiveUtil.decode(encoding, buffer, 696, DumpArchiveConstants.NAMELEN).trim();\ndevname = DumpArchiveUtil.decode(encoding, buffer, 760, DumpArchiveConstants.NAMELEN).trim();\nhostname = DumpArchiveUtil.decode(encoding, buffer, 824, DumpArchiveConstants.NAMELEN).trim();\nflags = DumpArchiveUtil.convert32(buffer, 888);\nfirstrec = DumpArchiveUtil.convert32(buffer, 892);\nntrec = DumpArchiveUtil.convert32(buffer, 896);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveSummary:getNTRec()I",
                                    "method_body": "public int getNTRec() {\nreturn ntrec;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveSummary:isCompressed()Z",
                                    "method_body": "public boolean isCompressed() {\nreturn (flags & 0x0080) == 0x0080;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:<init>()V",
                                    "method_body": "public DumpArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:<init>(Ljava/lang/String;Ljava/lang/String;ILorg/apache/commons/compress/archivers/dump/DumpArchiveEntry$TYPE;)V",
                                    "method_body": "private String name;\nprivate TYPE type = TYPE.UNKNOWN;\nprivate Set<PERMISSION> permissions = Collections.emptySet();\nprivate final DumpArchiveSummary summary = null;\nprivate final TapeSegmentHeader header = new TapeSegmentHeader();\npublic DumpArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:getHeaderType()Lorg/apache/commons/compress/archivers/dump/DumpArchiveConstants$SEGMENT_TYPE;",
                                    "method_body": "public DumpArchiveConstants.SEGMENT_TYPE getHeaderType() {\nreturn header.getType();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:getHeaderCount()I",
                                    "method_body": "public int getHeaderCount() {\nreturn header.getCount();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:parse([B)Lorg/apache/commons/compress/archivers/dump/DumpArchiveEntry;",
                                    "method_body": "static DumpArchiveEntry parse(byte[] buffer) {\nDumpArchiveEntry entry = new DumpArchiveEntry();\nTapeSegmentHeader header = entry.header;\nheader.type = DumpArchiveConstants.SEGMENT_TYPE.find(DumpArchiveUtil.convert32(\nheader.volume = DumpArchiveUtil.convert32(buffer, 12);\nentry.ino = header.ino = DumpArchiveUtil.convert32(buffer, 20);\nint m = DumpArchiveUtil.convert16(buffer, 32);\nentry.setType(TYPE.find((m >> 12) & 0x0F));\nentry.setMode(m);\nentry.nlink = DumpArchiveUtil.convert16(buffer, 34);\nentry.setSize(DumpArchiveUtil.convert64(buffer, 40));\nlong t = (1000L * DumpArchiveUtil.convert32(buffer, 48)) +\nentry.setAccessTime(new Date(t));\nt = (1000L * DumpArchiveUtil.convert32(buffer, 56)) +\nentry.setLastModifiedDate(new Date(t));\nt = (1000L * DumpArchiveUtil.convert32(buffer, 64)) +\nentry.ctime = t;\nentry.generation = DumpArchiveUtil.convert32(buffer, 140);\nentry.setUserId(DumpArchiveUtil.convert32(buffer, 144));\nentry.setGroupId(DumpArchiveUtil.convert32(buffer, 148));\nheader.count = DumpArchiveUtil.convert32(buffer, 160);\nheader.holes = 0;\nfor (int i = 0; (i < 512) && (i < header.count); i++) {\nif (buffer[164 + i] == 0) {\nheader.holes++;\nSystem.arraycopy(buffer, 164, header.cdata, 0, 512);\nentry.volume = header.getVolume();\nreturn entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setType(Lorg/apache/commons/compress/archivers/dump/DumpArchiveEntry$TYPE;)V",
                                    "method_body": "public void setType(TYPE type) {\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setMode(I)V",
                                    "method_body": "public void setMode(int mode) {\nthis.mode = mode & 07777;\nthis.permissions = PERMISSION.find(mode);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setLastModifiedDate(Ljava/util/Date;)V",
                                    "method_body": "public void setLastModifiedDate(Date mtime) {\nthis.mtime = mtime.getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setAccessTime(Ljava/util/Date;)V",
                                    "method_body": "public void setAccessTime(Date atime) {\nthis.atime = atime.getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setUserId(I)V",
                                    "method_body": "public void setUserId(int uid) {\nthis.uid = uid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setGroupId(I)V",
                                    "method_body": "public void setGroupId(int gid) {\nthis.gid = gid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TYPE:<init>(Ljava/lang/String;II)V",
                                    "method_body": "private TYPE(int code) {\nthis.code = code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TYPE:find(I)Lorg/apache/commons/compress/archivers/dump/DumpArchiveEntry$TYPE;",
                                    "method_body": "public static TYPE find(int code) {\nTYPE type = UNKNOWN;\nfor (TYPE t : TYPE.values()) {\nif (code == t.code) {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TapeSegmentHeader:<init>()V",
                                    "method_body": "private DumpArchiveConstants.SEGMENT_TYPE type;\nprivate final byte[] cdata = new byte[512]; // map of any 'holes'\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TapeSegmentHeader:getType()Lorg/apache/commons/compress/archivers/dump/DumpArchiveConstants$SEGMENT_TYPE;",
                                    "method_body": "public DumpArchiveConstants.SEGMENT_TYPE getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TapeSegmentHeader:getVolume()I",
                                    "method_body": "public int getVolume() {\nreturn volume;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TapeSegmentHeader:getCount()I",
                                    "method_body": "public int getCount() {\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveConstants$SEGMENT_TYPE:<init>(Ljava/lang/String;II)V",
                                    "method_body": "private SEGMENT_TYPE(int code) {\nthis.code = code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveConstants$SEGMENT_TYPE:find(I)Lorg/apache/commons/compress/archivers/dump/DumpArchiveConstants$SEGMENT_TYPE;",
                                    "method_body": "public static SEGMENT_TYPE find(int code) {\nfor (SEGMENT_TYPE t : values()) {\nif (t.code == code) {\nreturn t;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$PERMISSION:<init>(Ljava/lang/String;II)V",
                                    "method_body": "private PERMISSION(int code) {\nthis.code = code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$PERMISSION:find(I)Ljava/util/Set;",
                                    "method_body": "public static Set<PERMISSION> find(int code) {\nSet<PERMISSION> set = new HashSet<PERMISSION>();\nfor (PERMISSION p : PERMISSION.values()) {\nif ((code & p.code) == p.code) {\nif (set.isEmpty()) {\nreturn Collections.emptySet();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.Dirent:<init>(IIILjava/lang/String;)V",
                                    "method_body": "Dirent(int ino, int parentIno, int type, String name) {\nthis.ino = ino;\nthis.parentIno = parentIno;\nthis.type = type;\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is) {\nthis(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\nthis(is, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;IILjava/lang/String;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize,\nString encoding) {\nthis.is = is;\nthis.hasHitEOF = false;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.recordSize = recordSize;\nthis.blockSize = blockSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes();\nstatic final byte[] DD_SIG = ZipLong.DD_SIG.getBytes();\nstatic final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes();\nstatic final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\nstatic final byte[] ZIP64_EOCD_SIG = ZipLong.getBytes(0X06064B50L);\nstatic final byte[] ZIP64_EOCD_LOC_SIG = ZipLong.getBytes(0X07064B50L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveOutputStream(Ljava/lang/String;Ljava/io/OutputStream;)Lorg/apache/commons/compress/archivers/ArchiveOutputStream;",
                                    "method_body": "public ArchiveOutputStream createArchiveOutputStream(\nif (archiverName == null) {\nif (out == null) {\nif (AR.equalsIgnoreCase(archiverName)) {\nif (ZIP.equalsIgnoreCase(archiverName)) {\nZipArchiveOutputStream zip = new ZipArchiveOutputStream(out);\nif (entryEncoding != null) {\nzip.setEncoding(entryEncoding);\nreturn zip;\nif (TAR.equalsIgnoreCase(archiverName)) {\nif (entryEncoding != null) {\nreturn new TarArchiveOutputStream(out, entryEncoding);\nreturn new TarArchiveOutputStream(out);\nif (JAR.equalsIgnoreCase(archiverName)) {\nreturn new JarArchiveOutputStream(out);\nif (CPIO.equalsIgnoreCase(archiverName)) {\nif (entryEncoding != null) {\nreturn new CpioArchiveOutputStream(out, entryEncoding);\nreturn new CpioArchiveOutputStream(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveOutputStream:<init>()V",
                                    "method_body": "private final byte[] oneByte = new byte[1];\nprivate long bytesWritten = 0;\n* {@link #closeArchiveEntry()} to complete the process."
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:<init>(Ljava/io/OutputStream;S)V",
                                    "method_body": "public CpioArchiveOutputStream(final OutputStream out, final short format) {\nthis(out, format, BLOCK_SIZE, CharsetNames.US_ASCII);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:<init>(Ljava/io/OutputStream;SILjava/lang/String;)V",
                                    "method_body": "private final short entryFormat;\nprivate final HashMap<String, CpioArchiveEntry> names =\nprivate long crc = 0;\nprivate long nextArtificalDeviceAndInode = 1;\n* blocksize of {@link CpioConstants#BLOCK_SIZE BLOCK_SIZE} and"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public CpioArchiveOutputStream(final OutputStream out) {\nthis(out, FORMAT_NEW);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:<init>(Ljava/io/OutputStream;Ljava/lang/String;)V",
                                    "method_body": "public CpioArchiveOutputStream(final OutputStream out, String encoding) {\nthis(out, FORMAT_NEW, BLOCK_SIZE, encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "private long bytesWritten = 0;\nsuper(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public ZipArchiveOutputStream(OutputStream out) {\nthis.out = out;\nthis.raf = null;\ndef = new Deflater(level, true);\nstreamCompressor = StreamCompressor.create(out, def);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/File;)V",
                                    "method_body": "private ZipEncoding zipEncoding =\nprivate boolean useUTF8Flag = true;\nprivate boolean fallbackToUTF8 = false;\nprivate UnicodeExtraFieldPolicy createUnicodeExtraFields = UnicodeExtraFieldPolicy.NEVER;\nprivate boolean hasUsedZip64 = false;\nprivate Zip64Mode zip64Mode = Zip64Mode.AsNeeded;\nprivate final byte[] copyBuffer = new byte[32768];\nprivate final Calendar calendarInstance = Calendar.getInstance();\npublic ZipArchiveOutputStream(OutputStream out) {\nthis.out = out;\nthis.raf = null;\ndef = new Deflater(level, true);\nstreamCompressor = StreamCompressor.create(out, def);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setEncoding(Ljava/lang/String;)V",
                                    "method_body": "public void setEncoding(final String encoding) {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nif (useUTF8Flag && !ZipEncodingHelper.isUTF8(encoding)) {\nuseUTF8Flag = false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public JarArchiveOutputStream(final OutputStream out) {\nsuper(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveOutputStream:<init>(Ljava/io/OutputStream;Ljava/lang/String;)V",
                                    "method_body": "private boolean jarMarkerAdded = false;\nsuper(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<init>(Ljava/lang/String;)V",
                                    "method_body": "private UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
                                    "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS = new UnicodeExtraFieldPolicy(\"always\");\npublic static final UnicodeExtraFieldPolicy NEVER = new UnicodeExtraFieldPolicy(\"never\");\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nprivate UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:<init>(Ljava/util/zip/Deflater;)V",
                                    "method_body": "StreamCompressor(Deflater deflater) {\nthis.def = deflater;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:create(Ljava/io/OutputStream;Ljava/util/zip/Deflater;)Lorg/apache/commons/compress/archivers/zip/StreamCompressor;",
                                    "method_body": "static StreamCompressor create(OutputStream os, Deflater deflater) {\nreturn new OutputStreamCompressor(deflater, os);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor$OutputStreamCompressor:<init>(Ljava/util/zip/Deflater;Ljava/io/OutputStream;)V",
                                    "method_body": "public OutputStreamCompressor(Deflater deflater, OutputStream os) {\nsuper(deflater);\nthis.os = os;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public TarArchiveOutputStream(OutputStream os) {\nthis(os, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;Ljava/lang/String;)V",
                                    "method_body": "public TarArchiveOutputStream(OutputStream os, String encoding) {\nthis(os, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE, encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;II)V",
                                    "method_body": "public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) {\nthis(os, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;IILjava/lang/String;)V",
                                    "method_body": "public static final int LONGFILE_ERROR = 0;\nprivate int       longFileMode = LONGFILE_ERROR;\nprivate int       bigNumberMode = BIGNUMBER_ERROR;\nprivate boolean closed = false;\nprivate boolean haveUnclosedEntry = false;\nprivate boolean finished = false;\nprivate boolean addPaxHeadersForNonAsciiNames = false;\nprivate static final ZipEncoding ASCII =\nthis(os, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<clinit>()V",
                                    "method_body": "public static final int LONGFILE_ERROR = 0;\nprivate int       longFileMode = LONGFILE_ERROR;\nprivate int       bigNumberMode = BIGNUMBER_ERROR;\nprivate boolean closed = false;\nprivate boolean haveUnclosedEntry = false;\nprivate boolean finished = false;\nprivate boolean addPaxHeadersForNonAsciiNames = false;\nprivate static final ZipEncoding ASCII =\nthis(os, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest.testEncodingInputStreamAutodetect",
                            "test_body": "290: public void testEncodingInputStreamAutodetect() throws Exception {\n291: int failed = 0;\n292: for(int i = 1; i <= TESTS.length; i++) {\n293: TestData test = TESTS[i-1];\n294: ArchiveInputStream ais = getInputStreamFor(test.testFile, test.fac);\n295: final String field = getField(ais,test.fieldName);\n296: if (!eq(test.expectedEncoding,field)) {\n297: System.out.println(\"Failed test \" + i + \". expected: \" + test.expectedEncoding + \" actual: \" + field + \" type: \" + test.type);\n298: failed++;\n299: }\n300: }\n301: if (failed > 0) {\n302: fail(\"Tests failed: \" + failed);\n303: }\n304: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:pushedBackBytes(J)V",
                                    "method_body": "protected void pushedBackBytes(long pushedBack) {\nbytesRead -= pushedBack;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>()V",
                                    "method_body": "public ArchiveStreamFactory() {\nthis(null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ArchiveStreamFactory(String encoding) {\nsuper();\nthis.encoding = encoding;\nthis.entryEncoding = encoding;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:setEntryEncoding(Ljava/lang/String;)V",
                                    "method_body": "public void setEntryEncoding(String entryEncoding) {\nif (encoding != null) {\nthis.entryEncoding = entryEncoding;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\nMap<String, SimpleEncodingHolder> se =\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\nif (name == null) {\nSimpleEncodingHolder h = simpleEncodings.get(name);\nif (h!=null) {\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\ncharsetName = System.getProperty(\"file.encoding\");\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\nfor (String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data,this.charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:<init>(Ljava/nio/charset/Charset;)V",
                                    "method_body": "public NioZipEncoding(Charset charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nreturn this.charset.newDecoder()\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b, int offset, int len)\nif (len < 0 || offset < 0 || len + offset > b.length) {\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\ncount += x;\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public CpioArchiveInputStream(final InputStream in) {\nthis(in, BLOCK_SIZE, CharsetNames.US_ASCII);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public CpioArchiveInputStream(final InputStream in, String encoding) {\nthis(in, BLOCK_SIZE, encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:<init>(Ljava/io/InputStream;ILjava/lang/String;)V",
                                    "method_body": "public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\nthis.in = in;\nthis.blockSize = blockSize;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream) {\nthis(inputStream, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream, String encoding) {\nthis(inputStream, encoding, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields) {\nthis(inputStream, encoding, useUnicodeExtraFields, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;ZZ)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream,\nboolean allowStoredEntriesWithDataDescriptor) {\nzipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\nin = new PushbackInputStream(inputStream, buf.capacity());\nthis.allowStoredEntriesWithDataDescriptor =\nbuf.limit(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<clinit>()V",
                                    "method_body": "private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\nprivate static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\nprivate static final byte[] DD = ZipLong.DD_SIG.getBytes();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nputLong(value, result, 0);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:putLong(J[BI)V",
                                    "method_body": "public static void putLong(long value, byte[] buf, int offset) {\nbuf[offset++] = (byte) ((value & BYTE_MASK));\nbuf[offset++] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nbuf[offset++] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nbuf[offset] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public JarArchiveInputStream( final InputStream inputStream ) {\nsuper(inputStream);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public ArjArchiveInputStream(final InputStream inputStream,\nfinal String charsetName) throws ArchiveException {\nin = new DataInputStream(inputStream);\nthis.charsetName = charsetName;\nmainHeader = readMainHeader();\nif ((mainHeader.arjFlags & MainHeader.Flags.GARBLED) != 0) {\nif ((mainHeader.arjFlags & MainHeader.Flags.VOLUME) != 0) {\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public ArjArchiveInputStream(final InputStream inputStream)\nthis(inputStream, \"CP437\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:read8(Ljava/io/DataInputStream;)I",
                                    "method_body": "private int read8(final DataInputStream dataIn) throws IOException {\nint value = dataIn.readUnsignedByte();\ncount(1);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:read16(Ljava/io/DataInputStream;)I",
                                    "method_body": "private int read16(final DataInputStream dataIn) throws IOException {\nfinal int value = dataIn.readUnsignedShort();\ncount(2);\nreturn Integer.reverseBytes(value) >>> 16;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:read32(Ljava/io/DataInputStream;)I",
                                    "method_body": "private int read32(final DataInputStream dataIn) throws IOException {\nfinal int value = dataIn.readInt();\ncount(4);\nreturn Integer.reverseBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:readString(Ljava/io/DataInputStream;)Ljava/lang/String;",
                                    "method_body": "private String readString(final DataInputStream dataIn) throws IOException {\nfinal ByteArrayOutputStream buffer = new ByteArrayOutputStream();\nwhile ((nextByte = dataIn.readUnsignedByte()) != 0) {\nbuffer.write(nextByte);\nif (charsetName != null) {\nreturn new String(buffer.toByteArray(), charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:readFully(Ljava/io/DataInputStream;[B)V",
                                    "method_body": "private void readFully(final DataInputStream dataIn, byte[] b)\ndataIn.readFully(b);\ncount(b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:readHeader()[B",
                                    "method_body": "private byte[] readHeader() throws IOException {\nboolean found = false;\nbyte[] basicHeaderBytes = null;\nint first = 0;\nint second = read8(in);\nfirst = second;\nsecond = read8(in);\n} while (first != ARJ_MAGIC_1 && second != ARJ_MAGIC_2);\nfinal int basicHeaderSize = read16(in);\nif (basicHeaderSize == 0) {\nif (basicHeaderSize <= 2600) {\nbasicHeaderBytes = new byte[basicHeaderSize];\nreadFully(in, basicHeaderBytes);\nfinal long basicHeaderCrc32 = read32(in) & 0xFFFFFFFFL;\nfinal CRC32 crc32 = new CRC32();\ncrc32.update(basicHeaderBytes);\nif (basicHeaderCrc32 == crc32.getValue()) {\nfound = true;\n} while (!found);\nreturn basicHeaderBytes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:readMainHeader()Lorg/apache/commons/compress/archivers/arj/MainHeader;",
                                    "method_body": "private MainHeader readMainHeader() throws IOException {\nfinal byte[] basicHeaderBytes = readHeader();\nif (basicHeaderBytes == null) {\nfinal DataInputStream basicHeader = new DataInputStream(\nfinal int firstHeaderSize = basicHeader.readUnsignedByte();\nfinal byte[] firstHeaderBytes = new byte[firstHeaderSize - 1];\nbasicHeader.readFully(firstHeaderBytes);\nfinal DataInputStream firstHeader = new DataInputStream(\nfinal MainHeader hdr = new MainHeader();\nhdr.archiverVersionNumber = firstHeader.readUnsignedByte();\nhdr.minVersionToExtract = firstHeader.readUnsignedByte();\nhdr.hostOS = firstHeader.readUnsignedByte();\nhdr.arjFlags = firstHeader.readUnsignedByte();\nhdr.securityVersion = firstHeader.readUnsignedByte();\nhdr.fileType = firstHeader.readUnsignedByte();\nhdr.reserved = firstHeader.readUnsignedByte();\nhdr.dateTimeCreated = read32(firstHeader);\nhdr.dateTimeModified = read32(firstHeader);\nhdr.archiveSize = 0xffffFFFFL & read32(firstHeader);\nhdr.securityEnvelopeFilePosition = read32(firstHeader);\nhdr.fileSpecPosition = read16(firstHeader);\nhdr.securityEnvelopeLength = read16(firstHeader);\npushedBackBytes(20); // count has already counted them via readFully\nhdr.encryptionVersion = firstHeader.readUnsignedByte();\nhdr.lastChapter = firstHeader.readUnsignedByte();\nif (firstHeaderSize >= 33) {\nhdr.arjProtectionFactor = firstHeader.readUnsignedByte();\nhdr.arjFlags2 = firstHeader.readUnsignedByte();\nfirstHeader.readUnsignedByte();\nfirstHeader.readUnsignedByte();\nhdr.name = readString(basicHeader);\nhdr.comment = readString(basicHeader);\nfinal  int extendedHeaderSize = read16(in);\nif (extendedHeaderSize > 0) {\nreturn hdr;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public DumpArchiveInputStream(InputStream is) throws ArchiveException {\nthis(is, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public DumpArchiveInputStream(InputStream is, String encoding)\nthrows ArchiveException {\nthis.raw = new TapeInputStream(is);\nthis.hasHitEOF = false;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nbyte[] headerBytes = raw.readRecord();\nif (!DumpArchiveUtil.verify(headerBytes)) {\nsummary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\nraw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\nblockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\nreadCLRI();\nreadBITS();\n}\nDirent root = new Dirent(2, 2, 4, \".\");\nnames.put(2, root);\nqueue = new PriorityQueue<DumpArchiveEntry>(10,\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:readCLRI()V",
                                    "method_body": "private void readCLRI() throws IOException {\nbyte[] buffer = raw.readRecord();\nif (!DumpArchiveUtil.verify(buffer)) {\nactive = DumpArchiveEntry.parse(buffer);\nif (DumpArchiveConstants.SEGMENT_TYPE.CLRI != active.getHeaderType()) {\nif (raw.skip(DumpArchiveConstants.TP_SIZE * active.getHeaderCount())\nreadIdx = active.getHeaderCount();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:readBITS()V",
                                    "method_body": "private void readBITS() throws IOException {\nbyte[] buffer = raw.readRecord();\nif (!DumpArchiveUtil.verify(buffer)) {\nactive = DumpArchiveEntry.parse(buffer);\nif (DumpArchiveConstants.SEGMENT_TYPE.BITS != active.getHeaderType()) {\nif (raw.skip(DumpArchiveConstants.TP_SIZE * active.getHeaderCount())\nreadIdx = active.getHeaderCount();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:calculateChecksum([B)I",
                                    "method_body": "public static int calculateChecksum(byte[] buffer) {\nint calc = 0;\nfor (int i = 0; i < 256; i++) {\ncalc += DumpArchiveUtil.convert32(buffer, 4 * i);\nreturn DumpArchiveConstants.CHECKSUM -\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:verify([B)Z",
                                    "method_body": "public static final boolean verify(byte[] buffer) {\nint magic = convert32(buffer, 24);\nif (magic != DumpArchiveConstants.NFS_MAGIC) {\nint checksum = convert32(buffer, 28);\nif (checksum != calculateChecksum(buffer)) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert64([BI)J",
                                    "method_body": "public static final long convert64(byte[] buffer, int offset) {\nlong i = 0;\ni += (((long) buffer[offset + 7]) << 56);\ni += (((long) buffer[offset + 6] << 48) & 0x00FF000000000000L);\ni += (((long) buffer[offset + 5] << 40) & 0x0000FF0000000000L);\ni += (((long) buffer[offset + 4] << 32) & 0x000000FF00000000L);\ni += (((long) buffer[offset + 3] << 24) & 0x00000000FF000000L);\ni += (((long) buffer[offset + 2] << 16) & 0x0000000000FF0000L);\ni += (((long) buffer[offset + 1] << 8) & 0x000000000000FF00L);\ni += (buffer[offset] & 0x00000000000000FFL);\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert32([BI)I",
                                    "method_body": "public static final int convert32(byte[] buffer, int offset) {\nint i = 0;\ni = buffer[offset + 3] << 24;\ni += (buffer[offset + 2] << 16) & 0x00FF0000;\ni += (buffer[offset + 1] << 8) & 0x0000FF00;\ni += buffer[offset] & 0x000000FF;\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert16([BI)I",
                                    "method_body": "public static final int convert16(byte[] buffer, int offset) {\nint i = 0;\ni += (buffer[offset + 1] << 8) & 0x0000FF00;\ni += buffer[offset] & 0x000000FF;\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:decode(Lorg/apache/commons/compress/archivers/zip/ZipEncoding;[BII)Ljava/lang/String;",
                                    "method_body": "static String decode(ZipEncoding encoding, byte[] b, int offset, int len)\nbyte[] copy = new byte[len];\nSystem.arraycopy(b, offset, copy, 0, len);\nreturn encoding.decode(copy);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "private byte[] blockBuffer = new byte[DumpArchiveConstants.TP_SIZE];\nprivate int currBlkIdx = -1;\nprivate int blockSize = DumpArchiveConstants.TP_SIZE;\nprivate int readOffset = DumpArchiveConstants.TP_SIZE;\nprivate boolean isCompressed = false;\nprivate long bytesRead = 0;\nsuper(in);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:resetBlockSize(IZ)V",
                                    "method_body": "public void resetBlockSize(int recsPerBlock, boolean isCompressed)\nthis.isCompressed = isCompressed;\nblockSize = recordSize * recsPerBlock;\nbyte[] oldBuffer = blockBuffer;\nblockBuffer = new byte[blockSize];\nSystem.arraycopy(oldBuffer, 0, blockBuffer, 0, recordSize);\nreadFully(blockBuffer, recordSize, blockSize - recordSize);\nthis.currBlkIdx = 0;\nthis.readOffset = recordSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif ((len % recordSize) != 0) {\nint bytes = 0;\nwhile (bytes < len) {\nif ((readOffset == blockSize) && !readBlock(true)) {\nint n = 0;\nif ((readOffset + (len - bytes)) <= blockSize) {\nn = len - bytes;\nSystem.arraycopy(blockBuffer, readOffset, b, off, n);\nreadOffset += n;\nbytes += n;\noff += n;\n}\nreturn bytes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:skip(J)J",
                                    "method_body": "public long skip(long len) throws IOException {\nif ((len % recordSize) != 0) {\nlong bytes = 0;\nwhile (bytes < len) {\nif ((readOffset == blockSize) &&\nlong n = 0;\nif ((readOffset + (len - bytes)) <= blockSize) {\nn = len - bytes;\nn = blockSize - readOffset;\nreadOffset += n;\nbytes += n;\n}\nreturn bytes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:readRecord()[B",
                                    "method_body": "public byte[] readRecord() throws IOException {\nbyte[] result = new byte[recordSize];\nif (-1 == read(result, 0, result.length)) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:readBlock(Z)Z",
                                    "method_body": "private boolean readBlock(boolean decompress) throws IOException {\nboolean success = true;\nif (in == null) {\nif (!isCompressed || (currBlkIdx == -1)) {\nsuccess = readFully(blockBuffer, 0, blockSize);\nbytesRead += blockSize;\ncurrBlkIdx++;\nreadOffset = 0;\nreturn success;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:readFully([BII)Z",
                                    "method_body": "private boolean readFully(byte[] b, int off, int len)\nint count = IOUtils.readFully(in, b, off, len);\nif (count < len) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveSummary:<init>([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "DumpArchiveSummary(byte[] buffer, ZipEncoding encoding) throws IOException {\ndumpDate = 1000L * DumpArchiveUtil.convert32(buffer, 4);\npreviousDumpDate = 1000L * DumpArchiveUtil.convert32(buffer, 8);\nvolume = DumpArchiveUtil.convert32(buffer, 12);\nlabel = DumpArchiveUtil.decode(encoding, buffer, 676, DumpArchiveConstants.LBLSIZE).trim();\nlevel = DumpArchiveUtil.convert32(buffer, 692);\nfilesys = DumpArchiveUtil.decode(encoding, buffer, 696, DumpArchiveConstants.NAMELEN).trim();\ndevname = DumpArchiveUtil.decode(encoding, buffer, 760, DumpArchiveConstants.NAMELEN).trim();\nhostname = DumpArchiveUtil.decode(encoding, buffer, 824, DumpArchiveConstants.NAMELEN).trim();\nflags = DumpArchiveUtil.convert32(buffer, 888);\nfirstrec = DumpArchiveUtil.convert32(buffer, 892);\nntrec = DumpArchiveUtil.convert32(buffer, 896);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveSummary:getNTRec()I",
                                    "method_body": "public int getNTRec() {\nreturn ntrec;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveSummary:isCompressed()Z",
                                    "method_body": "public boolean isCompressed() {\nreturn (flags & 0x0080) == 0x0080;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:<init>()V",
                                    "method_body": "public DumpArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:<init>(Ljava/lang/String;Ljava/lang/String;ILorg/apache/commons/compress/archivers/dump/DumpArchiveEntry$TYPE;)V",
                                    "method_body": "private String name;\nprivate TYPE type = TYPE.UNKNOWN;\nprivate Set<PERMISSION> permissions = Collections.emptySet();\nprivate final DumpArchiveSummary summary = null;\nprivate final TapeSegmentHeader header = new TapeSegmentHeader();\npublic DumpArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:getHeaderType()Lorg/apache/commons/compress/archivers/dump/DumpArchiveConstants$SEGMENT_TYPE;",
                                    "method_body": "public DumpArchiveConstants.SEGMENT_TYPE getHeaderType() {\nreturn header.getType();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:getHeaderCount()I",
                                    "method_body": "public int getHeaderCount() {\nreturn header.getCount();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:parse([B)Lorg/apache/commons/compress/archivers/dump/DumpArchiveEntry;",
                                    "method_body": "static DumpArchiveEntry parse(byte[] buffer) {\nDumpArchiveEntry entry = new DumpArchiveEntry();\nTapeSegmentHeader header = entry.header;\nheader.type = DumpArchiveConstants.SEGMENT_TYPE.find(DumpArchiveUtil.convert32(\nheader.volume = DumpArchiveUtil.convert32(buffer, 12);\nentry.ino = header.ino = DumpArchiveUtil.convert32(buffer, 20);\nint m = DumpArchiveUtil.convert16(buffer, 32);\nentry.setType(TYPE.find((m >> 12) & 0x0F));\nentry.setMode(m);\nentry.nlink = DumpArchiveUtil.convert16(buffer, 34);\nentry.setSize(DumpArchiveUtil.convert64(buffer, 40));\nlong t = (1000L * DumpArchiveUtil.convert32(buffer, 48)) +\nentry.setAccessTime(new Date(t));\nt = (1000L * DumpArchiveUtil.convert32(buffer, 56)) +\nentry.setLastModifiedDate(new Date(t));\nt = (1000L * DumpArchiveUtil.convert32(buffer, 64)) +\nentry.ctime = t;\nentry.generation = DumpArchiveUtil.convert32(buffer, 140);\nentry.setUserId(DumpArchiveUtil.convert32(buffer, 144));\nentry.setGroupId(DumpArchiveUtil.convert32(buffer, 148));\nheader.count = DumpArchiveUtil.convert32(buffer, 160);\nheader.holes = 0;\nfor (int i = 0; (i < 512) && (i < header.count); i++) {\nif (buffer[164 + i] == 0) {\nheader.holes++;\nSystem.arraycopy(buffer, 164, header.cdata, 0, 512);\nentry.volume = header.getVolume();\nreturn entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setType(Lorg/apache/commons/compress/archivers/dump/DumpArchiveEntry$TYPE;)V",
                                    "method_body": "public void setType(TYPE type) {\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setMode(I)V",
                                    "method_body": "public void setMode(int mode) {\nthis.mode = mode & 07777;\nthis.permissions = PERMISSION.find(mode);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setLastModifiedDate(Ljava/util/Date;)V",
                                    "method_body": "public void setLastModifiedDate(Date mtime) {\nthis.mtime = mtime.getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setAccessTime(Ljava/util/Date;)V",
                                    "method_body": "public void setAccessTime(Date atime) {\nthis.atime = atime.getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setUserId(I)V",
                                    "method_body": "public void setUserId(int uid) {\nthis.uid = uid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setGroupId(I)V",
                                    "method_body": "public void setGroupId(int gid) {\nthis.gid = gid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TYPE:<init>(Ljava/lang/String;II)V",
                                    "method_body": "private TYPE(int code) {\nthis.code = code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TYPE:find(I)Lorg/apache/commons/compress/archivers/dump/DumpArchiveEntry$TYPE;",
                                    "method_body": "public static TYPE find(int code) {\nTYPE type = UNKNOWN;\nfor (TYPE t : TYPE.values()) {\nif (code == t.code) {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TapeSegmentHeader:<init>()V",
                                    "method_body": "private DumpArchiveConstants.SEGMENT_TYPE type;\nprivate final byte[] cdata = new byte[512]; // map of any 'holes'\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TapeSegmentHeader:getType()Lorg/apache/commons/compress/archivers/dump/DumpArchiveConstants$SEGMENT_TYPE;",
                                    "method_body": "public DumpArchiveConstants.SEGMENT_TYPE getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TapeSegmentHeader:getVolume()I",
                                    "method_body": "public int getVolume() {\nreturn volume;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TapeSegmentHeader:getCount()I",
                                    "method_body": "public int getCount() {\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveConstants$SEGMENT_TYPE:<init>(Ljava/lang/String;II)V",
                                    "method_body": "private SEGMENT_TYPE(int code) {\nthis.code = code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveConstants$SEGMENT_TYPE:find(I)Lorg/apache/commons/compress/archivers/dump/DumpArchiveConstants$SEGMENT_TYPE;",
                                    "method_body": "public static SEGMENT_TYPE find(int code) {\nfor (SEGMENT_TYPE t : values()) {\nif (t.code == code) {\nreturn t;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$PERMISSION:<init>(Ljava/lang/String;II)V",
                                    "method_body": "private PERMISSION(int code) {\nthis.code = code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$PERMISSION:find(I)Ljava/util/Set;",
                                    "method_body": "public static Set<PERMISSION> find(int code) {\nSet<PERMISSION> set = new HashSet<PERMISSION>();\nfor (PERMISSION p : PERMISSION.values()) {\nif ((code & p.code) == p.code) {\nif (set.isEmpty()) {\nreturn Collections.emptySet();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.Dirent:<init>(IIILjava/lang/String;)V",
                                    "method_body": "Dirent(int ino, int parentIno, int type, String name) {\nthis.ino = ino;\nthis.parentIno = parentIno;\nthis.type = type;\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is) {\nthis(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, String encoding) {\nthis(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE,\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\nthis(is, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;IILjava/lang/String;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize,\nString encoding) {\nthis.is = is;\nthis.hasHitEOF = false;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.recordSize = recordSize;\nthis.blockSize = blockSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveInputStream(Ljava/io/InputStream;)Lorg/apache/commons/compress/archivers/ArchiveInputStream;",
                                    "method_body": "public ArchiveInputStream createArchiveInputStream(final InputStream in)\nif (in == null) {\nif (!in.markSupported()) {\nfinal byte[] signature = new byte[12];\nin.mark(signature.length);\nint signatureLength = IOUtils.readFully(in, signature);\nin.reset();\nif (ZipArchiveInputStream.matches(signature, signatureLength)) {\nif (entryEncoding != null) {\nreturn new ZipArchiveInputStream(in, entryEncoding);\nreturn new ZipArchiveInputStream(in);\n} else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n} else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n} else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\nif (entryEncoding != null) {\nreturn new CpioArchiveInputStream(in, entryEncoding);\nreturn new CpioArchiveInputStream(in);\n} else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\nreturn new ArjArchiveInputStream(in);\n} else if (SevenZFile.matches(signature, signatureLength)) {\nfinal byte[] dumpsig = new byte[32];\nin.mark(dumpsig.length);\nsignatureLength = IOUtils.readFully(in, dumpsig);\nin.reset();\nif (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\nreturn new DumpArchiveInputStream(in, entryEncoding);\nfinal byte[] tarheader = new byte[512];\nin.mark(tarheader.length);\nsignatureLength = IOUtils.readFully(in, tarheader);\nin.reset();\nif (TarArchiveInputStream.matches(tarheader, signatureLength)) {\nreturn new TarArchiveInputStream(in, entryEncoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:matchAsciiBuffer(Ljava/lang/String;[BII)Z",
                                    "method_body": "public static boolean matchAsciiBuffer(\nbuffer1 = expected.getBytes(CharsetNames.US_ASCII);\n}\nreturn isEqual(buffer1, 0, buffer1.length, buffer, offset, length, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isEqual([BII[BIIZ)Z",
                                    "method_body": "public static boolean isEqual(\nint minLen=length1 < length2 ? length1 : length2;\nfor (int i=0; i < minLen; i++){\nif (buffer1[offset1+i] != buffer2[offset2+i]){\nreturn false;\nif (length1 == length2){\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[B)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b) throws IOException {\nreturn readFully(input, b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < 6) {\nif (signature[0] == 0x71 && (signature[1] & 0xFF) == 0xc7) {\nif (signature[1] == 0x71 && (signature[0] & 0xFF) == 0xc7) {\nif (signature[0] != 0x30) {\nreturn false;\nif (signature[1] != 0x37) {\nif (signature[2] != 0x30) {\nif (signature[3] != 0x37) {\nif (signature[4] != 0x30) {\nif (signature[5] == 0x31) {\nif (signature[5] == 0x32) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<clinit>()V",
                                    "method_body": "static final int SIGNATURE_HEADER_SIZE = 32;\nstatic final byte[] sevenZSignature = {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < sevenZSignature.length) {\nfor (int i = 0; i < sevenZSignature.length; i++) {\nif (signature[i] != sevenZSignature[i]) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < ZipArchiveOutputStream.LFH_SIG.length) {\nreturn checksig(signature, ZipArchiveOutputStream.LFH_SIG) // normal file\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:checksig([B[B)Z",
                                    "method_body": "private static boolean checksig(byte[] signature, byte[] expected) {\nfor (int i = 0; i < expected.length; i++) {\nif (signature[i] != expected[i]) {\nreturn false;\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes();\nstatic final byte[] DD_SIG = ZipLong.DD_SIG.getBytes();\nstatic final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes();\nstatic final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\nstatic final byte[] ZIP64_EOCD_SIG = ZipLong.getBytes(0X06064B50L);\nstatic final byte[] ZIP64_EOCD_LOC_SIG = ZipLong.getBytes(0X07064B50L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length ) {\nreturn ZipArchiveInputStream.matches(signature, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:<clinit>()V",
                                    "method_body": "static final String BSD_LONGNAME_PREFIX = \"#1/\";\nprivate static final int BSD_LONGNAME_PREFIX_LEN =\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < 8) {\nif (signature[0] != 0x21) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(final byte[] signature, final int length) {\nreturn length >= 2 &&\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] buffer, int length) {\nif (length < 32) {\nif (length >= DumpArchiveConstants.TP_SIZE) {\nreturn DumpArchiveConstants.NFS_MAGIC == DumpArchiveUtil.convert32(buffer,\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < TarConstants.VERSION_OFFSET+TarConstants.VERSIONLEN) {\nif (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_POSIX,\nif (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_GNU,\nreturn true;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 30,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStreamTest.readOfLength0ShouldReturn0",
                            "test_body": "46: public void readOfLength0ShouldReturn0() throws Exception {\n47: // Create a big random piece of data\n48: byte[] rawData = new byte[1048576];\n49: for (int i=0; i < rawData.length; ++i) {\n50: rawData[i] = (byte) Math.floor(Math.random()*256);\n51: }\n52: 53: // Compress it\n54: ByteArrayOutputStream baos = new ByteArrayOutputStream();\n55: BZip2CompressorOutputStream bzipOut = new BZip2CompressorOutputStream(baos);\n56: bzipOut.write(rawData);\n57: bzipOut.flush();\n58: bzipOut.close();\n59: baos.flush();\n60: baos.close();\n61: 62: // Try to read it back in\n63: ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n64: BZip2CompressorInputStream bzipIn = new BZip2CompressorInputStream(bais);\n65: byte[] buffer = new byte[1024];\n66: Assert.assertEquals(1024, bzipIn.read(buffer, 0, 1024));\n67: Assert.assertEquals(0, bzipIn.read(buffer, 1024, 0));\n68: Assert.assertEquals(1024, bzipIn.read(buffer, 0, 1024));\n69: bzipIn.close();\n70: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public BZip2CompressorOutputStream(final OutputStream out)\nthis(out, MAX_BLOCKSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:<init>(Ljava/io/OutputStream;I)V",
                                    "method_body": "public BZip2CompressorOutputStream(final OutputStream out, final int blockSize) throws IOException {\nif (blockSize < 1) {\nif (blockSize > 9) {\nthis.blockSize100k = blockSize;\nthis.out = out;\nthis.allowableBlockSize = (this.blockSize100k * BZip2Constants.BASEBLOCKSIZE) - 20;\ninit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:hbMakeCodeLengths([B[ILorg/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream$Data;II)V",
                                    "method_body": "private static void hbMakeCodeLengths(final byte[] len, final int[] freq,\nfinal int[] heap = dat.heap;\nfinal int[] weight = dat.weight;\nfinal int[] parent = dat.parent;\nfor (int i = alphaSize; --i >= 0;) {\nweight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;\nfor (boolean tooLong = true; tooLong;) {\ntooLong = false;\nint nNodes = alphaSize;\nint nHeap = 0;\nheap[0] = 0;\nweight[0] = 0;\nparent[0] = -2;\nfor (int i = 1; i <= alphaSize; i++) {\nparent[i] = -1;\nnHeap++;\nheap[nHeap] = i;\nint zz = nHeap;\nint tmp = heap[zz];\nwhile (weight[tmp] < weight[heap[zz >> 1]]) {\nheap[zz] = heap[zz >> 1];\nzz >>= 1;\nheap[zz] = tmp;\nwhile (nHeap > 1) {\nint n1 = heap[1];\nheap[1] = heap[nHeap];\nnHeap--;\nint yy = 0;\nint zz = 1;\nint tmp = heap[1];\nyy = zz << 1;\nif (yy > nHeap) {\nbreak;\nif ((yy < nHeap)\nyy++;\nif (weight[tmp] < weight[heap[yy]]) {\nbreak;\nheap[zz] = heap[yy];\nzz = yy;\nheap[zz] = tmp;\nint n2 = heap[1];\nheap[1] = heap[nHeap];\nnHeap--;\nyy = 0;\nzz = 1;\ntmp = heap[1];\nyy = zz << 1;\nif (yy > nHeap) {\nbreak;\nif ((yy < nHeap)\nyy++;\nif (weight[tmp] < weight[heap[yy]]) {\nbreak;\nheap[zz] = heap[yy];\nzz = yy;\nheap[zz] = tmp;\nnNodes++;\nparent[n1] = parent[n2] = nNodes;\nfinal int weight_n1 = weight[n1];\nfinal int weight_n2 = weight[n2];\nweight[nNodes] = ((weight_n1 & 0xffffff00)\nparent[nNodes] = -1;\nnHeap++;\nheap[nHeap] = nNodes;\ntmp = 0;\nzz = nHeap;\ntmp = heap[zz];\nfinal int weight_tmp = weight[tmp];\nwhile (weight_tmp < weight[heap[zz >> 1]]) {\nheap[zz] = heap[zz >> 1];\nzz >>= 1;\nheap[zz] = tmp;\n}\nfor (int i = 1; i <= alphaSize; i++) {\nint j = 0;\nint k = i;\nfor (int parent_k; (parent_k = parent[k]) >= 0;) {\nk = parent_k;\nj++;\nlen[i - 1] = (byte) j;\nif (j > maxLen) {\nif (tooLong) {\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:writeRun()V",
                                    "method_body": "private void writeRun() throws IOException {\nfinal int lastShadow = this.last;\nif (lastShadow < this.allowableBlockSize) {\nfinal int currentCharShadow = this.currentChar;\nfinal Data dataShadow = this.data;\ndataShadow.inUse[currentCharShadow] = true;\nfinal byte ch = (byte) currentCharShadow;\nint runLengthShadow = this.runLength;\nthis.crc.updateCRC(currentCharShadow, runLengthShadow);\nswitch (runLengthShadow) {\ndataShadow.block[lastShadow + 2] = ch;\nthis.last = lastShadow + 1;\nbreak;\ndataShadow.block[lastShadow + 2] = ch;\ndataShadow.block[lastShadow + 3] = ch;\nthis.last = lastShadow + 2;\nbreak;\nfinal byte[] block = dataShadow.block;\nblock[lastShadow + 2] = ch;\nblock[lastShadow + 3] = ch;\nblock[lastShadow + 4] = ch;\nthis.last = lastShadow + 3;\nbreak;\n} else {\nendBlock();\ninitBlock();\nwriteRun();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif (out != null) {\nif (this.runLength > 0) {\nwriteRun();\nthis.currentChar = -1;\nendBlock();\nendCompression();\nthis.out = null;\nthis.data = null;\nthis.blockSorter = null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif (out != null) {\nOutputStream outShadow = this.out;\nfinish();\noutShadow.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:flush()V",
                                    "method_body": "public void flush() throws IOException {\nOutputStream outShadow = this.out;\nif (outShadow != null) {\noutShadow.flush();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:init()V",
                                    "method_body": "private void init() throws IOException {\nbsPutUByte('B');\nbsPutUByte('Z');\nthis.data = new Data(this.blockSize100k);\nthis.blockSorter = new BlockSort(this.data);\nbsPutUByte('h');\nbsPutUByte('0' + this.blockSize100k);\nthis.combinedCRC = 0;\ninitBlock();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:initBlock()V",
                                    "method_body": "private void initBlock() {\nthis.crc.initialiseCRC();\nthis.last = -1;\nboolean[] inUse = this.data.inUse;\nfor (int i = 256; --i >= 0;) {\ninUse[i] = false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:endBlock()V",
                                    "method_body": "private void endBlock() throws IOException {\nthis.blockCRC = this.crc.getFinalCRC();\nthis.combinedCRC = (this.combinedCRC << 1) | (this.combinedCRC >>> 31);\nthis.combinedCRC ^= this.blockCRC;\nif (this.last == -1) {\nblockSort();\nbsPutUByte(0x31);\nbsPutUByte(0x41);\nbsPutUByte(0x59);\nbsPutUByte(0x26);\nbsPutUByte(0x53);\nbsPutUByte(0x59);\nbsPutInt(this.blockCRC);\nbsW(1, 0);\nmoveToFrontCodeAndSend();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:endCompression()V",
                                    "method_body": "private void endCompression() throws IOException {\nbsPutUByte(0x17);\nbsPutUByte(0x72);\nbsPutUByte(0x45);\nbsPutUByte(0x38);\nbsPutUByte(0x50);\nbsPutUByte(0x90);\nbsPutInt(this.combinedCRC);\nbsFinishedWithStream();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:write([BII)V",
                                    "method_body": "public void write(final byte[] buf, int offs, final int len)\nif (offs < 0) {\nif (len < 0) {\nif (offs + len > buf.length) {\nif (this.out == null) {\nfor (int hi = offs + len; offs < hi;) {\nwrite0(buf[offs++]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:write0(I)V",
                                    "method_body": "private void write0(int b) throws IOException {\nif (this.currentChar != -1) {\nb &= 0xff;\nif (this.currentChar == b) {\nif (++this.runLength > 254) {\nwriteRun();\nthis.runLength = 1;\nthis.currentChar = b;\nthis.currentChar = b & 0xff;\nthis.runLength++;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:hbAssignCodes([I[BIII)V",
                                    "method_body": "private static void hbAssignCodes(final int[] code, final byte[] length,\nint vec = 0;\nfor (int n = minLen; n <= maxLen; n++) {\nfor (int i = 0; i < alphaSize; i++) {\nif ((length[i] & 0xff) == n) {\ncode[i] = vec;\nvec++;\nvec <<= 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:bsFinishedWithStream()V",
                                    "method_body": "private void bsFinishedWithStream() throws IOException {\nwhile (this.bsLive > 0) {\nint ch = this.bsBuff >> 24;\nthis.out.write(ch); // write 8-bit\nthis.bsBuff <<= 8;\nthis.bsLive -= 8;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:bsW(II)V",
                                    "method_body": "private void bsW(final int n, final int v) throws IOException {\nfinal OutputStream outShadow = this.out;\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\nthis.bsBuff = bsBuffShadow | (v << (32 - bsLiveShadow - n));\nthis.bsLive = bsLiveShadow + n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:bsPutUByte(I)V",
                                    "method_body": "private void bsPutUByte(final int c) throws IOException {\nbsW(8, c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:bsPutInt(I)V",
                                    "method_body": "private void bsPutInt(final int u) throws IOException {\nbsW(8, (u >> 24) & 0xff);\nbsW(8, (u >> 16) & 0xff);\nbsW(8, (u >> 8) & 0xff);\nbsW(8, u & 0xff);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues()V",
                                    "method_body": "private void sendMTFValues() throws IOException {\nfinal byte[][] len = this.data.sendMTFValues_len;\nfinal int alphaSize = this.nInUse + 2;\nfor (int t = N_GROUPS; --t >= 0;) {\nbyte[] len_t = len[t];\nfor (int v = alphaSize; --v >= 0;) {\nlen_t[v] = GREATER_ICOST;\n}\nfinal int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3\nsendMTFValues0(nGroups, alphaSize);\nfinal int nSelectors = sendMTFValues1(nGroups, alphaSize);\nsendMTFValues2(nGroups, nSelectors);\nsendMTFValues3(nGroups, alphaSize);\nsendMTFValues4();\nsendMTFValues5(nGroups, nSelectors);\nsendMTFValues6(nGroups, alphaSize);\nsendMTFValues7();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues0(II)V",
                                    "method_body": "private void sendMTFValues0(final int nGroups, final int alphaSize) {\nfinal byte[][] len = this.data.sendMTFValues_len;\nfinal int[] mtfFreq = this.data.mtfFreq;\nint remF = this.nMTF;\nint gs = 0;\nfor (int nPart = nGroups; nPart > 0; nPart--) {\nfinal int tFreq = remF / nPart;\nint ge = gs - 1;\nint aFreq = 0;\nfor (final int a = alphaSize - 1; (aFreq < tFreq) && (ge < a);) {\naFreq += mtfFreq[++ge];\nif ((ge > gs) && (nPart != nGroups) && (nPart != 1)\naFreq -= mtfFreq[ge--];\nfinal byte[] len_np = len[nPart - 1];\nfor (int v = alphaSize; --v >= 0;) {\nif ((v >= gs) && (v <= ge)) {\nlen_np[v] = LESSER_ICOST;\nlen_np[v] = GREATER_ICOST;\ngs = ge + 1;\nremF -= aFreq;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues1(II)I",
                                    "method_body": "private int sendMTFValues1(final int nGroups, final int alphaSize) {\nfinal Data dataShadow = this.data;\nfinal int[][] rfreq = dataShadow.sendMTFValues_rfreq;\nfinal int[] fave = dataShadow.sendMTFValues_fave;\nfinal short[] cost = dataShadow.sendMTFValues_cost;\nfinal char[] sfmap = dataShadow.sfmap;\nfinal byte[] selector = dataShadow.selector;\nfinal byte[][] len = dataShadow.sendMTFValues_len;\nfinal byte[] len_0 = len[0];\nfinal byte[] len_1 = len[1];\nfinal byte[] len_2 = len[2];\nfinal byte[] len_3 = len[3];\nfinal byte[] len_4 = len[4];\nfinal byte[] len_5 = len[5];\nfinal int nMTFShadow = this.nMTF;\nint nSelectors = 0;\nfor (int iter = 0; iter < N_ITERS; iter++) {\nfor (int t = nGroups; --t >= 0;) {\nfave[t] = 0;\nint[] rfreqt = rfreq[t];\nfor (int i = alphaSize; --i >= 0;) {\nrfreqt[i] = 0;\n}\nnSelectors = 0;\nfor (int gs = 0; gs < this.nMTF;) {\nfinal int ge = Math.min(gs + G_SIZE - 1, nMTFShadow - 1);\nif (nGroups == N_GROUPS) {\nshort cost0 = 0;\nshort cost1 = 0;\nshort cost2 = 0;\nshort cost3 = 0;\nshort cost4 = 0;\nshort cost5 = 0;\nfor (int i = gs; i <= ge; i++) {\nfinal int icv = sfmap[i];\ncost0 += len_0[icv] & 0xff;\ncost1 += len_1[icv] & 0xff;\ncost2 += len_2[icv] & 0xff;\ncost3 += len_3[icv] & 0xff;\ncost4 += len_4[icv] & 0xff;\ncost5 += len_5[icv] & 0xff;\ncost[0] = cost0;\ncost[1] = cost1;\ncost[2] = cost2;\ncost[3] = cost3;\ncost[4] = cost4;\ncost[5] = cost5;\n} else {\nint bt = -1;\nfor (int t = nGroups, bc = 999999999; --t >= 0;) {\nfinal int cost_t = cost[t];\nif (cost_t < bc) {\nbc = cost_t;\nbt = t;\n}\nfave[bt]++;\nselector[nSelectors] = (byte) bt;\nnSelectors++;\nfinal int[] rfreq_bt = rfreq[bt];\nfor (int i = gs; i <= ge; i++) {\nrfreq_bt[sfmap[i]]++;\ngs = ge + 1;\n}\nfor (int t = 0; t < nGroups; t++) {\nhbMakeCodeLengths(len[t], rfreq[t], this.data, alphaSize, 20);\nreturn nSelectors;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues2(II)V",
                                    "method_body": "private void sendMTFValues2(final int nGroups, final int nSelectors) {\nfinal Data dataShadow = this.data;\nbyte[] pos = dataShadow.sendMTFValues2_pos;\nfor (int i = nGroups; --i >= 0;) {\npos[i] = (byte) i;\nfor (int i = 0; i < nSelectors; i++) {\nfinal byte ll_i = dataShadow.selector[i];\nbyte tmp = pos[0];\nint j = 0;\nwhile (ll_i != tmp) {\nj++;\nbyte tmp2 = tmp;\ntmp = pos[j];\npos[j] = tmp2;\n}\npos[0] = tmp;\ndataShadow.selectorMtf[i] = (byte) j;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues3(II)V",
                                    "method_body": "private void sendMTFValues3(final int nGroups, final int alphaSize) {\nint[][] code = this.data.sendMTFValues_code;\nbyte[][] len = this.data.sendMTFValues_len;\nfor (int t = 0; t < nGroups; t++) {\nint minLen = 32;\nint maxLen = 0;\nfinal byte[] len_t = len[t];\nfor (int i = alphaSize; --i >= 0;) {\nfinal int l = len_t[i] & 0xff;\nif (l > maxLen) {\nmaxLen = l;\nif (l < minLen) {\nminLen = l;\n}\nhbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues4()V",
                                    "method_body": "private void sendMTFValues4() throws IOException {\nfinal boolean[] inUse = this.data.inUse;\nfinal boolean[] inUse16 = this.data.sentMTFValues4_inUse16;\nfor (int i = 16; --i >= 0;) {\ninUse16[i] = false;\nfinal int i16 = i * 16;\nfor (int j = 16; --j >= 0;) {\nif (inUse[i16 + j]) {\ninUse16[i] = true;\n}\nfor (int i = 0; i < 16; i++) {\nbsW(1, inUse16[i] ? 1 : 0);\nfinal OutputStream outShadow = this.out;\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\nfor (int i = 0; i < 16; i++) {\nif (inUse16[i]) {\nfinal int i16 = i * 16;\nfor (int j = 0; j < 16; j++) {\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\nif (inUse[i16 + j]) {\nbsBuffShadow |= 1 << (32 - bsLiveShadow - 1);\nbsLiveShadow++;\nthis.bsBuff = bsBuffShadow;\nthis.bsLive = bsLiveShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues5(II)V",
                                    "method_body": "private void sendMTFValues5(final int nGroups, final int nSelectors)\nbsW(3, nGroups);\nbsW(15, nSelectors);\nfinal OutputStream outShadow = this.out;\nfinal byte[] selectorMtf = this.data.selectorMtf;\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\nfor (int i = 0; i < nSelectors; i++) {\nfor (int j = 0, hj = selectorMtf[i] & 0xff; j < hj; j++) {\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24);\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\nbsBuffShadow |= 1 << (32 - bsLiveShadow - 1);\nbsLiveShadow++;\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24);\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\nbsLiveShadow++;\nthis.bsBuff = bsBuffShadow;\nthis.bsLive = bsLiveShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues6(II)V",
                                    "method_body": "private void sendMTFValues6(final int nGroups, final int alphaSize)\nfinal byte[][] len = this.data.sendMTFValues_len;\nfinal OutputStream outShadow = this.out;\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\nfor (int t = 0; t < nGroups; t++) {\nbyte[] len_t = len[t];\nint curr = len_t[0] & 0xff;\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\nbsBuffShadow |= curr << (32 - bsLiveShadow - 5);\nbsLiveShadow += 5;\nfor (int i = 0; i < alphaSize; i++) {\nint lti = len_t[i] & 0xff;\nwhile (curr < lti) {\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\nbsBuffShadow |= 2 << (32 - bsLiveShadow - 2);\nbsLiveShadow += 2;\ncurr++; /* 10 */\nwhile (curr > lti) {\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\nbsBuffShadow |= 3 << (32 - bsLiveShadow - 2);\nbsLiveShadow += 2;\ncurr--; /* 11 */\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\nbsLiveShadow++;\nthis.bsBuff = bsBuffShadow;\nthis.bsLive = bsLiveShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues7()V",
                                    "method_body": "private void sendMTFValues7() throws IOException {\nfinal Data dataShadow = this.data;\nfinal byte[][] len = dataShadow.sendMTFValues_len;\nfinal int[][] code = dataShadow.sendMTFValues_code;\nfinal OutputStream outShadow = this.out;\nfinal byte[] selector = dataShadow.selector;\nfinal char[] sfmap = dataShadow.sfmap;\nfinal int nMTFShadow = this.nMTF;\nint selCtr = 0;\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\nfor (int gs = 0; gs < nMTFShadow;) {\nfinal int ge = Math.min(gs + G_SIZE - 1, nMTFShadow - 1);\nfinal int selector_selCtr = selector[selCtr] & 0xff;\nfinal int[] code_selCtr = code[selector_selCtr];\nfinal byte[] len_selCtr = len[selector_selCtr];\nwhile (gs <= ge) {\nfinal int sfmap_i = sfmap[gs];\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24);\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\nfinal int n = len_selCtr[sfmap_i] & 0xFF;\nbsBuffShadow |= code_selCtr[sfmap_i] << (32 - bsLiveShadow - n);\nbsLiveShadow += n;\ngs++;\n}\ngs = ge + 1;\nselCtr++;\n}\nthis.bsBuff = bsBuffShadow;\nthis.bsLive = bsLiveShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:moveToFrontCodeAndSend()V",
                                    "method_body": "private void moveToFrontCodeAndSend() throws IOException {\nbsW(24, this.data.origPtr);\ngenerateMTFValues();\nsendMTFValues();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:blockSort()V",
                                    "method_body": "private void blockSort() {\nblockSorter.blockSort(data, last);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:generateMTFValues()V",
                                    "method_body": "private void generateMTFValues() {\nfinal int lastShadow = this.last;\nfinal Data dataShadow = this.data;\nfinal boolean[] inUse = dataShadow.inUse;\nfinal byte[] block = dataShadow.block;\nfinal int[] fmap = dataShadow.fmap;\nfinal char[] sfmap = dataShadow.sfmap;\nfinal int[] mtfFreq = dataShadow.mtfFreq;\nfinal byte[] unseqToSeq = dataShadow.unseqToSeq;\nfinal byte[] yy = dataShadow.generateMTFValues_yy;\nint nInUseShadow = 0;\nfor (int i = 0; i < 256; i++) {\nif (inUse[i]) {\nunseqToSeq[i] = (byte) nInUseShadow;\nnInUseShadow++;\nthis.nInUse = nInUseShadow;\nfinal int eob = nInUseShadow + 1;\nfor (int i = eob; i >= 0; i--) {\nmtfFreq[i] = 0;\nfor (int i = nInUseShadow; --i >= 0;) {\nyy[i] = (byte) i;\nint wr = 0;\nint zPend = 0;\nfor (int i = 0; i <= lastShadow; i++) {\nfinal byte ll_i = unseqToSeq[block[fmap[i]] & 0xff];\nbyte tmp = yy[0];\nint j = 0;\nwhile (ll_i != tmp) {\nj++;\nbyte tmp2 = tmp;\ntmp = yy[j];\nyy[j] = tmp2;\n}\nyy[0] = tmp;\nif (j == 0) {\nzPend++;\nif (zPend > 0) {\nzPend--;\nif ((zPend & 1) == 0) {\nsfmap[wr] = RUNA;\nwr++;\nmtfFreq[RUNA]++;\nsfmap[wr] = RUNB;\nwr++;\nmtfFreq[RUNB]++;\nif (zPend >= 2) {\nzPend = 0;\nsfmap[wr] = (char) (j + 1);\nwr++;\nmtfFreq[j + 1]++;\nif (zPend > 0) {\nsfmap[wr] = (char) eob;\nmtfFreq[eob]++;\nthis.nMTF = wr + 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:<init>()V",
                                    "method_body": "CRC() {\ninitialiseCRC();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:<clinit>()V",
                                    "method_body": "private static final int crc32Table[] = {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:initialiseCRC()V",
                                    "method_body": "void initialiseCRC() {\nglobalCrc = 0xffffffff;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:getFinalCRC()I",
                                    "method_body": "int getFinalCRC() {\nreturn ~globalCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:updateCRC(I)V",
                                    "method_body": "void updateCRC(int inCh) {\nint temp = (globalCrc >> 24) ^ inCh;\nif (temp < 0) {\ntemp = 256 + temp;\nglobalCrc = (globalCrc << 8) ^ CRC.crc32Table[temp];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:updateCRC(II)V",
                                    "method_body": "void updateCRC(int inCh, int repeat) {\nint globalCrcShadow = this.globalCrc;\nwhile (repeat-- > 0) {\nint temp = (globalCrcShadow >> 24) ^ inCh;\nglobalCrcShadow = (globalCrcShadow << 8) ^ crc32Table[(temp >= 0)\n}\nthis.globalCrc = globalCrcShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream$Data:<init>(I)V",
                                    "method_body": "final boolean[] inUse = new boolean[256]; // 256 byte\nfinal byte[] unseqToSeq = new byte[256]; // 256 byte\nfinal int[] mtfFreq = new int[MAX_ALPHA_SIZE]; // 1032 byte\nfinal byte[] selector = new byte[MAX_SELECTORS]; // 18002 byte\nfinal byte[] selectorMtf = new byte[MAX_SELECTORS]; // 18002 byte\nfinal byte[] generateMTFValues_yy = new byte[256]; // 256 byte\nfinal byte[][] sendMTFValues_len = new byte[N_GROUPS][MAX_ALPHA_SIZE]; // 1548\nfinal int[][] sendMTFValues_rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192\nfinal int[] sendMTFValues_fave = new int[N_GROUPS]; // 24 byte\nfinal short[] sendMTFValues_cost = new short[N_GROUPS]; // 12 byte\nfinal int[][] sendMTFValues_code = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192\nfinal byte[] sendMTFValues2_pos = new byte[N_GROUPS]; // 6 byte\nfinal boolean[] sentMTFValues4_inUse16 = new boolean[16]; // 16 byte\nfinal int[] heap = new int[MAX_ALPHA_SIZE + 2]; // 1040 byte\nfinal int[] weight = new int[MAX_ALPHA_SIZE * 2]; // 2064 byte\nfinal int[] parent = new int[MAX_ALPHA_SIZE * 2]; // 2064 byte\nData(int blockSize100k) {\nfinal int n = blockSize100k * BZip2Constants.BASEBLOCKSIZE;\nthis.block = new byte[(n + 1 + NUM_OVERSHOOT_BYTES)];\nthis.fmap = new int[n];\nthis.sfmap = new char[2 * n];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:<init>(Lorg/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream$Data;)V",
                                    "method_body": "private static final int QSORT_STACK_SIZE = 1000;\nprivate final int[] stack_ll = new int[STACK_SIZE]; // 4000 byte\nprivate final int[] stack_hh = new int[STACK_SIZE]; // 4000 byte\nprivate final int[] stack_dd = new int[QSORT_STACK_SIZE]; // 4000 byte\nprivate final int[] mainSort_runningOrder = new int[256]; // 1024 byte\nprivate final int[] mainSort_copy = new int[256]; // 1024 byte\nprivate final boolean[] mainSort_bigDone = new boolean[256]; // 256 byte\nprivate final int[] ftab = new int[65537]; // 262148 byte\nBlockSort(final BZip2CompressorOutputStream.Data data) {\nthis.quadrant = data.sfmap;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:<clinit>()V",
                                    "method_body": "private static final int[] INCS = { 1, 4, 13, 40, 121, 364, 1093, 3280,\n2391484 };"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:blockSort(Lorg/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream$Data;I)V",
                                    "method_body": "void blockSort(final BZip2CompressorOutputStream.Data data, final int last) {\nthis.workLimit = WORK_FACTOR * last;\nthis.workDone = 0;\nthis.firstAttempt = true;\nif (last + 1 < 10000) {\nmainSort(data, last);\nif (this.firstAttempt && (this.workDone > this.workLimit)) {\nfinal int[] fmap = data.fmap;\ndata.origPtr = -1;\nfor (int i = 0; i <= last; i++) {\nif (fmap[i] == 0) {\ndata.origPtr = i;\nbreak;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:mainSimpleSort(Lorg/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream$Data;IIII)Z",
                                    "method_body": "private boolean mainSimpleSort(final BZip2CompressorOutputStream.Data dataShadow,\nfinal int bigN = hi - lo + 1;\nif (bigN < 2) {\nreturn this.firstAttempt && (this.workDone > this.workLimit);\nint hp = 0;\nwhile (INCS[hp] < bigN) {\nhp++;\nfinal int[] fmap = dataShadow.fmap;\nfinal char[] quadrant = this.quadrant;\nfinal byte[] block = dataShadow.block;\nfinal int lastPlus1 = lastShadow + 1;\nfinal boolean firstAttemptShadow = this.firstAttempt;\nfinal int workLimitShadow = this.workLimit;\nint workDoneShadow = this.workDone;\nHP: while (--hp >= 0) {\nfinal int h = INCS[hp];\nfinal int mj = lo + h - 1;\nfor (int i = lo + h; i <= hi;) {\nfor (int k = 3; (i <= hi) && (--k >= 0); i++) {\nfinal int v = fmap[i];\nfinal int vd = v + d;\nint j = i;\nboolean onceRunned = false;\nint a = 0;\nif (onceRunned) {\nfmap[j] = a;\nif ((j -= h) <= mj) {\nbreak HAMMER;\nonceRunned = true;\na = fmap[j - h];\nint i1 = a + d;\nint i2 = vd;\nif (block[i1 + 1] == block[i2 + 1]) {\nif (block[i1 + 2] == block[i2 + 2]) {\nif (block[i1 + 3] == block[i2 + 3]) {\n} else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff)) {\ncontinue HAMMER;\n} else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff)) {\ncontinue HAMMER;\n} else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff)) {\ncontinue HAMMER;\nfmap[j] = v;\nif (firstAttemptShadow && (i <= hi)\n}\nthis.workDone = workDoneShadow;\nreturn firstAttemptShadow && (workDoneShadow > workLimitShadow);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:vswap([IIII)V",
                                    "method_body": "private static void vswap(int[] fmap, int p1, int p2, int n) {\nn += p1;\nwhile (p1 < n) {\nint t = fmap[p1];\nfmap[p1++] = fmap[p2];\nfmap[p2++] = t;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:med3(BBB)B",
                                    "method_body": "private static byte med3(byte a, byte b, byte c) {\nreturn (a < b) ? (b < c ? b : a < c ? c : a) : (b > c ? b : a > c ? c\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:mainQSort3(Lorg/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream$Data;IIII)V",
                                    "method_body": "private void mainQSort3(final BZip2CompressorOutputStream.Data dataShadow,\nfinal int[] stack_ll = this.stack_ll;\nfinal int[] stack_hh = this.stack_hh;\nfinal int[] stack_dd = this.stack_dd;\nfinal int[] fmap = dataShadow.fmap;\nfinal byte[] block = dataShadow.block;\nstack_ll[0] = loSt;\nstack_hh[0] = hiSt;\nstack_dd[0] = dSt;\nfor (int sp = 1; --sp >= 0;) {\nfinal int lo = stack_ll[sp];\nfinal int hi = stack_hh[sp];\nfinal int d = stack_dd[sp];\nif ((hi - lo < SMALL_THRESH) || (d > DEPTH_THRESH)) {\nif (mainSimpleSort(dataShadow, lo, hi, d, last)) {\nfinal int d1 = d + 1;\nfinal int med = med3(block[fmap[lo] + d1],\nint unLo = lo;\nint unHi = hi;\nint ltLo = lo;\nint gtHi = hi;\nwhile (unLo <= unHi) {\nfinal int n = (block[fmap[unLo] + d1] & 0xff)\nif (n == 0) {\nfinal int temp = fmap[unLo];\nfmap[unLo++] = fmap[ltLo];\nfmap[ltLo++] = temp;\n} else if (n < 0) {\nunLo++;\n}\nwhile (unLo <= unHi) {\nfinal int n = (block[fmap[unHi] + d1] & 0xff)\nif (n == 0) {\nfinal int temp = fmap[unHi];\nfmap[unHi--] = fmap[gtHi];\nfmap[gtHi--] = temp;\n} else if (n > 0) {\nunHi--;\n}\nif (unLo <= unHi) {\nfinal int temp = fmap[unLo];\nfmap[unLo++] = fmap[unHi];\nfmap[unHi--] = temp;\n} else {\nif (gtHi < ltLo) {\nint n = ((ltLo - lo) < (unLo - ltLo)) ? (ltLo - lo)\nvswap(fmap, lo, unLo - n, n);\nint m = ((hi - gtHi) < (gtHi - unHi)) ? (hi - gtHi)\nvswap(fmap, unLo, hi - m + 1, m);\nn = lo + unLo - ltLo - 1;\nm = hi - (gtHi - unHi) + 1;\nstack_ll[sp] = lo;\nstack_hh[sp] = n;\nstack_dd[sp] = d;\nsp++;\nstack_ll[sp] = n + 1;\nstack_hh[sp] = m - 1;\nstack_dd[sp] = d1;\nsp++;\nstack_ll[sp] = m;\nstack_hh[sp] = hi;\nstack_dd[sp] = d;\nsp++;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:mainSort(Lorg/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream$Data;I)V",
                                    "method_body": "final void mainSort(final BZip2CompressorOutputStream.Data dataShadow,\nfinal int[] runningOrder = this.mainSort_runningOrder;\nfinal int[] copy = this.mainSort_copy;\nfinal boolean[] bigDone = this.mainSort_bigDone;\nfinal int[] ftab = this.ftab;\nfinal byte[] block = dataShadow.block;\nfinal int[] fmap = dataShadow.fmap;\nfinal char[] quadrant = this.quadrant;\nfinal int workLimitShadow = this.workLimit;\nfinal boolean firstAttemptShadow = this.firstAttempt;\nfor (int i = 65537; --i >= 0;) {\nftab[i] = 0;\nfor (int i = 0; i < BZip2Constants.NUM_OVERSHOOT_BYTES; i++) {\nblock[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];\nfor (int i = lastShadow + BZip2Constants.NUM_OVERSHOOT_BYTES +1; --i >= 0;) {\nquadrant[i] = 0;\nblock[0] = block[lastShadow + 1];\nint c1 = block[0] & 0xff;\nfor (int i = 0; i <= lastShadow; i++) {\nfinal int c2 = block[i + 1] & 0xff;\nftab[(c1 << 8) + c2]++;\nc1 = c2;\nfor (int i = 1; i <= 65536; i++) {\nftab[i] += ftab[i - 1];\nc1 = block[1] & 0xff;\nfor (int i = 0; i < lastShadow; i++) {\nfinal int c2 = block[i + 2] & 0xff;\nfmap[--ftab[(c1 << 8) + c2]] = i;\nc1 = c2;\nfmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;\nfor (int i = 256; --i >= 0;) {\nbigDone[i] = false;\nrunningOrder[i] = i;\nfor (int h = 364; h != 1;) {\nh /= 3;\nfor (int i = h; i <= 255; i++) {\nfinal int vv = runningOrder[i];\nfinal int a = ftab[(vv + 1) << 8] - ftab[vv << 8];\nfinal int b = h - 1;\nint j = i;\nfor (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j\nrunningOrder[j] = ro;\nj -= h;\nif (j <= b) {\nbreak;\nrunningOrder[j] = vv;\nfor (int i = 0; i <= 255; i++) {\nfinal int ss = runningOrder[i];\nfor (int j = 0; j <= 255; j++) {\nfinal int sb = (ss << 8) + j;\nfinal int ftab_sb = ftab[sb];\nif ((ftab_sb & SETMASK) != SETMASK) {\nfinal int lo = ftab_sb & CLEARMASK;\nfinal int hi = (ftab[sb + 1] & CLEARMASK) - 1;\nif (hi > lo) {\nmainQSort3(dataShadow, lo, hi, 2, lastShadow);\nif (firstAttemptShadow\nftab[sb] = ftab_sb | SETMASK;\nfor (int j = 0; j <= 255; j++) {\ncopy[j] = ftab[(j << 8) + ss] & CLEARMASK;\nfor (int j = ftab[ss << 8] & CLEARMASK, hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++) {\nfinal int fmap_j = fmap[j];\nc1 = block[fmap_j] & 0xff;\nif (!bigDone[c1]) {\nfmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);\ncopy[c1]++;\nfor (int j = 256; --j >= 0;) {\nftab[(j << 8) + ss] |= SETMASK;\nbigDone[ss] = true;\nif (i < 255) {\nfinal int bbStart = ftab[ss << 8] & CLEARMASK;\nfinal int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\nint shifts = 0;\nwhile ((bbSize >> shifts) > 65534) {\nfor (int j = 0; j < bbSize; j++) {\nfinal int a2update = fmap[bbStart + j];\nfinal char qVal = (char) (j >> shifts);\nquadrant[a2update] = qVal;\nif (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {\nquadrant[a2update + lastShadow + 1] = qVal;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.CompressorInputStream:<init>()V",
                                    "method_body": "private long bytesRead = 0;\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.CompressorInputStream:count(I)V",
                                    "method_body": "protected void count(int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.CompressorInputStream:count(J)V",
                                    "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public BZip2CompressorInputStream(final InputStream in) throws IOException {\nthis(in, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:<init>(Ljava/io/InputStream;Z)V",
                                    "method_body": "public BZip2CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException {\nthis.in = in;\nthis.decompressConcatenated = decompressConcatenated;\ninit(true);\ninitBlock();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:read([BII)I",
                                    "method_body": "public int read(final byte[] dest, final int offs, final int len)\nif (offs < 0) {\nif (len < 0) {\nif (offs + len > dest.length) {\nif (this.in == null) {\nfinal int hi = offs + len;\nint destOffs = offs;\nwhile (destOffs < hi && ((b = read0()) >= 0)) {\ndest[destOffs++] = (byte) b;\ncount(1);\nint c = (destOffs == offs) ? -1 : (destOffs - offs);\nreturn c;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:makeMaps()V",
                                    "method_body": "private void makeMaps() {\nfinal boolean[] inUse = this.data.inUse;\nfinal byte[] seqToUnseq = this.data.seqToUnseq;\nint nInUseShadow = 0;\nfor (int i = 0; i < 256; i++) {\nif (inUse[i]) {\nseqToUnseq[nInUseShadow++] = (byte) i;\nthis.nInUse = nInUseShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:read0()I",
                                    "method_body": "private int read0() throws IOException {\nswitch (currentState) {\nreturn setupBlock();\nreturn setupNoRandPartB();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:init(Z)Z",
                                    "method_body": "private boolean init(boolean isFirstStream) throws IOException {\nif (null == in) {\nint magic0 = this.in.read();\nif (magic0 == -1 && !isFirstStream) {\nint magic1 = this.in.read();\nint magic2 = this.in.read();\nif (magic0 != 'B' || magic1 != 'Z' || magic2 != 'h') {\nint blockSize = this.in.read();\nif ((blockSize < '1') || (blockSize > '9')) {\nthis.blockSize100k = blockSize - '0';\nthis.bsLive = 0;\nthis.computedCombinedCRC = 0;\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:initBlock()V",
                                    "method_body": "private void initBlock() throws IOException {\nmagic0 = bsGetUByte();\nmagic1 = bsGetUByte();\nmagic2 = bsGetUByte();\nmagic3 = bsGetUByte();\nmagic4 = bsGetUByte();\nmagic5 = bsGetUByte();\nif (magic0 != 0x17 || magic1 != 0x72 || magic2 != 0x45\nif (magic0 != 0x31 || // '1'\nthis.storedBlockCRC = bsGetInt();\nthis.blockRandomised = bsR(1) == 1;\nif (this.data == null) {\nthis.data = new Data(this.blockSize100k);\ngetAndMoveToFrontDecode();\nthis.crc.initialiseCRC();\nthis.currentState = START_BLOCK_STATE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsR(I)I",
                                    "method_body": "private int bsR(final int n) throws IOException {\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\nif (bsLiveShadow < n) {\nfinal InputStream inShadow = this.in;\nint thech = inShadow.read();\nif (thech < 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\n} while (bsLiveShadow < n);\nthis.bsBuff = bsBuffShadow;\nthis.bsLive = bsLiveShadow - n;\nreturn (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsGetBit()Z",
                                    "method_body": "private boolean bsGetBit() throws IOException {\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\nif (bsLiveShadow < 1) {\nint thech = this.in.read();\nif (thech < 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\nthis.bsBuff = bsBuffShadow;\nthis.bsLive = bsLiveShadow - 1;\nreturn ((bsBuffShadow >> (bsLiveShadow - 1)) & 1) != 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsGetUByte()C",
                                    "method_body": "private char bsGetUByte() throws IOException {\nreturn (char) bsR(8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsGetInt()I",
                                    "method_body": "private int bsGetInt() throws IOException {\nreturn (((((bsR(8) << 8) | bsR(8)) << 8) | bsR(8)) << 8) | bsR(8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:hbCreateDecodeTables([I[I[I[CIII)V",
                                    "method_body": "private static void hbCreateDecodeTables(final int[] limit,\nfor (int i = minLen, pp = 0; i <= maxLen; i++) {\nfor (int j = 0; j < alphaSize; j++) {\nif (length[j] == i) {\nperm[pp++] = j;\nfor (int i = MAX_CODE_LEN; --i > 0;) {\nbase[i] = 0;\nlimit[i] = 0;\nfor (int i = 0; i < alphaSize; i++) {\nbase[length[i] + 1]++;\nfor (int i = 1, b = base[0]; i < MAX_CODE_LEN; i++) {\nb += base[i];\nbase[i] = b;\nfor (int i = minLen, vec = 0, b = base[i]; i <= maxLen; i++) {\nfinal int nb = base[i + 1];\nvec += nb - b;\nb = nb;\nlimit[i] = vec - 1;\nvec <<= 1;\nfor (int i = minLen + 1; i <= maxLen; i++) {\nbase[i] = ((limit[i - 1] + 1) << 1) - base[i];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:recvDecodingTables()V",
                                    "method_body": "private void recvDecodingTables() throws IOException {\nfinal Data dataShadow = this.data;\nfinal boolean[] inUse = dataShadow.inUse;\nfinal byte[] pos = dataShadow.recvDecodingTables_pos;\nfinal byte[] selector = dataShadow.selector;\nfinal byte[] selectorMtf = dataShadow.selectorMtf;\nint inUse16 = 0;\nfor (int i = 0; i < 16; i++) {\nif (bsGetBit()) {\ninUse16 |= 1 << i;\nfor (int i = 256; --i >= 0;) {\ninUse[i] = false;\nfor (int i = 0; i < 16; i++) {\nif ((inUse16 & (1 << i)) != 0) {\nfinal int i16 = i << 4;\nfor (int j = 0; j < 16; j++) {\nif (bsGetBit()) {\ninUse[i16 + j] = true;\nmakeMaps();\nfinal int alphaSize = this.nInUse + 2;\nfinal int nGroups = bsR(3);\nfinal int nSelectors = bsR(15);\nfor (int i = 0; i < nSelectors; i++) {\nint j = 0;\nwhile (bsGetBit()) {\nj++;\nselectorMtf[i] = (byte) j;\nfor (int v = nGroups; --v >= 0;) {\npos[v] = (byte) v;\nfor (int i = 0; i < nSelectors; i++) {\nint v = selectorMtf[i] & 0xff;\nfinal byte tmp = pos[v];\nwhile (v > 0) {\npos[v] = pos[v - 1];\nv--;\npos[0] = tmp;\nselector[i] = tmp;\nfinal char[][] len = dataShadow.temp_charArray2d;\nfor (int t = 0; t < nGroups; t++) {\nint curr = bsR(5);\nfinal char[] len_t = len[t];\nfor (int i = 0; i < alphaSize; i++) {\nwhile (bsGetBit()) {\ncurr += bsGetBit() ? -1 : 1;\nlen_t[i] = (char) curr;\ncreateHuffmanDecodingTables(alphaSize, nGroups);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:createHuffmanDecodingTables(II)V",
                                    "method_body": "private void createHuffmanDecodingTables(final int alphaSize,\nfinal Data dataShadow = this.data;\nfinal char[][] len = dataShadow.temp_charArray2d;\nfinal int[] minLens = dataShadow.minLens;\nfinal int[][] limit = dataShadow.limit;\nfinal int[][] base = dataShadow.base;\nfinal int[][] perm = dataShadow.perm;\nfor (int t = 0; t < nGroups; t++) {\nint minLen = 32;\nint maxLen = 0;\nfinal char[] len_t = len[t];\nfor (int i = alphaSize; --i >= 0;) {\nfinal char lent = len_t[i];\nif (lent > maxLen) {\nmaxLen = lent;\nif (lent < minLen) {\nminLen = lent;\n}\nhbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen,\nminLens[t] = minLen;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:getAndMoveToFrontDecode()V",
                                    "method_body": "private void getAndMoveToFrontDecode() throws IOException {\nthis.origPtr = bsR(24);\nrecvDecodingTables();\nfinal InputStream inShadow = this.in;\nfinal Data dataShadow = this.data;\nfinal byte[] ll8 = dataShadow.ll8;\nfinal int[] unzftab = dataShadow.unzftab;\nfinal byte[] selector = dataShadow.selector;\nfinal byte[] seqToUnseq = dataShadow.seqToUnseq;\nfinal char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\nfinal int[] minLens = dataShadow.minLens;\nfinal int[][] limit = dataShadow.limit;\nfinal int[][] base = dataShadow.base;\nfinal int[][] perm = dataShadow.perm;\nfinal int limitLast = this.blockSize100k * 100000;\nfor (int i = 256; --i >= 0;) {\nyy[i] = (char) i;\nunzftab[i] = 0;\nint groupNo = 0;\nint groupPos = G_SIZE - 1;\nfinal int eob = this.nInUse + 1;\nint nextSym = getAndMoveToFrontDecode0(0);\nint bsBuffShadow = this.bsBuff;\nint bsLiveShadow = this.bsLive;\nint lastShadow = -1;\nint zt = selector[groupNo] & 0xff;\nint[] base_zt = base[zt];\nint[] limit_zt = limit[zt];\nint[] perm_zt = perm[zt];\nint minLens_zt = minLens[zt];\nwhile (nextSym != eob) {\nif ((nextSym == RUNA) || (nextSym == RUNB)) {\nint s = -1;\nfor (int n = 1; true; n <<= 1) {\nif (nextSym == RUNA) {\ns += n;\n} else if (nextSym == RUNB) {\ns += n << 1;\nif (groupPos == 0) {\ngroupPos = G_SIZE - 1;\nzt = selector[++groupNo] & 0xff;\nbase_zt = base[zt];\nlimit_zt = limit[zt];\nperm_zt = perm[zt];\nminLens_zt = minLens[zt];\ngroupPos--;\nint zn = minLens_zt;\nwhile (bsLiveShadow < zn) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\nint zvec = (bsBuffShadow >> (bsLiveShadow - zn))\nbsLiveShadow -= zn;\nwhile (zvec > limit_zt[zn]) {\nzn++;\nwhile (bsLiveShadow < 1) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\nbsLiveShadow--;\nzvec = (zvec << 1)\nnextSym = perm_zt[zvec - base_zt[zn]];\nfinal byte ch = seqToUnseq[yy[0]];\nunzftab[ch & 0xff] += s + 1;\nwhile (s-- >= 0) {\nll8[++lastShadow] = ch;\nif (lastShadow >= limitLast) {\n} else {\nif (++lastShadow >= limitLast) {\nfinal char tmp = yy[nextSym - 1];\nunzftab[seqToUnseq[tmp] & 0xff]++;\nll8[lastShadow] = seqToUnseq[tmp];\nif (nextSym <= 16) {\nfor (int j = nextSym - 1; j > 0;) {\nyy[j] = yy[--j];\nSystem.arraycopy(yy, 0, yy, 1, nextSym - 1);\nyy[0] = tmp;\nif (groupPos == 0) {\ngroupPos = G_SIZE - 1;\nzt = selector[++groupNo] & 0xff;\nbase_zt = base[zt];\nlimit_zt = limit[zt];\nperm_zt = perm[zt];\nminLens_zt = minLens[zt];\ngroupPos--;\nint zn = minLens_zt;\nwhile (bsLiveShadow < zn) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\nint zvec = (bsBuffShadow >> (bsLiveShadow - zn))\nbsLiveShadow -= zn;\nwhile (zvec > limit_zt[zn]) {\nzn++;\nwhile (bsLiveShadow < 1) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\nbsLiveShadow--;\nzvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\nnextSym = perm_zt[zvec - base_zt[zn]];\n}\nthis.last = lastShadow;\nthis.bsLive = bsLiveShadow;\nthis.bsBuff = bsBuffShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:getAndMoveToFrontDecode0(I)I",
                                    "method_body": "private int getAndMoveToFrontDecode0(final int groupNo) throws IOException {\nfinal InputStream inShadow = this.in;\nfinal Data dataShadow = this.data;\nfinal int zt = dataShadow.selector[groupNo] & 0xff;\nfinal int[] limit_zt = dataShadow.limit[zt];\nint zn = dataShadow.minLens[zt];\nint zvec = bsR(zn);\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\nwhile (zvec > limit_zt[zn]) {\nzn++;\nwhile (bsLiveShadow < 1) {\nbsLiveShadow--;\nzvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\nthis.bsLive = bsLiveShadow;\nthis.bsBuff = bsBuffShadow;\nreturn dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:setupBlock()I",
                                    "method_body": "private int setupBlock() throws IOException {\nif (currentState == EOF || this.data == null) {\nfinal int[] cftab = this.data.cftab;\nfinal int[] tt = this.data.initTT(this.last + 1);\nfinal byte[] ll8 = this.data.ll8;\ncftab[0] = 0;\nSystem.arraycopy(this.data.unzftab, 0, cftab, 1, 256);\nfor (int i = 1, c = cftab[0]; i <= 256; i++) {\nc += cftab[i];\ncftab[i] = c;\nfor (int i = 0, lastShadow = this.last; i <= lastShadow; i++) {\ntt[cftab[ll8[i] & 0xff]++] = i;\nif ((this.origPtr < 0) || (this.origPtr >= tt.length)) {\nthis.su_tPos = tt[this.origPtr];\nthis.su_count = 0;\nthis.su_i2 = 0;\nthis.su_ch2 = 256; /* not a char and not EOF */\nif (this.blockRandomised) {\nreturn setupNoRandPartA();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:setupNoRandPartA()I",
                                    "method_body": "private int setupNoRandPartA() throws IOException {\nif (this.su_i2 <= this.last) {\nthis.su_chPrev = this.su_ch2;\nint su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;\nthis.su_ch2 = su_ch2Shadow;\nthis.su_tPos = this.data.tt[this.su_tPos];\nthis.su_i2++;\nthis.currentState = NO_RAND_PART_B_STATE;\nthis.crc.updateCRC(su_ch2Shadow);\nreturn su_ch2Shadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:setupNoRandPartB()I",
                                    "method_body": "private int setupNoRandPartB() throws IOException {\nif (this.su_ch2 != this.su_chPrev) {\nthis.su_count = 1;\nreturn setupNoRandPartA();\n} else if (++this.su_count >= 4) {\nreturn setupNoRandPartA();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream$Data:<init>(I)V",
                                    "method_body": "final boolean[] inUse = new boolean[256]; // 256 byte\nfinal byte[] seqToUnseq = new byte[256]; // 256 byte\nfinal byte[] selector = new byte[MAX_SELECTORS]; // 18002 byte\nfinal byte[] selectorMtf = new byte[MAX_SELECTORS]; // 18002 byte\nfinal int[] unzftab = new int[256]; // 1024 byte\nfinal int[][] limit = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte\nfinal int[][] base = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte\nfinal int[][] perm = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte\nfinal int[] minLens = new int[N_GROUPS]; // 24 byte\nfinal int[] cftab = new int[257]; // 1028 byte\nfinal char[] getAndMoveToFrontDecode_yy = new char[256]; // 512 byte\nfinal char[][] temp_charArray2d = new char[N_GROUPS][MAX_ALPHA_SIZE]; // 3096\nfinal byte[] recvDecodingTables_pos = new byte[N_GROUPS]; // 6 byte\nData(int blockSize100k) {\nthis.ll8 = new byte[blockSize100k * BZip2Constants.BASEBLOCKSIZE];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream$Data:initTT(I)[I",
                                    "method_body": "int[] initTT(int length) {\nint[] ttShadow = this.tt;\nif ((ttShadow == null) || (ttShadow.length < length)) {\nthis.tt = ttShadow = new int[length];\nreturn ttShadow;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 31,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarUtilsTest.testParseOctalInvalid",
                            "test_body": "79: public void testParseOctalInvalid() throws Exception{\n80: byte [] buffer;\n81: buffer=new byte[0]; // empty byte array\n82: try {\n83: TarUtils.parseOctal(buffer,0, buffer.length);\n84: fail(\"Expected IllegalArgumentException - should be at least 2 bytes long\");\n85: } catch (IllegalArgumentException expected) {\n86: }\n87: buffer=new byte[]{0}; // 1-byte array\n88: try {\n89: TarUtils.parseOctal(buffer,0, buffer.length);\n90: fail(\"Expected IllegalArgumentException - should be at least 2 bytes long\");\n91: } catch (IllegalArgumentException expected) {\n92: }\n93: buffer = \"abcdef \".getBytes(CharsetNames.UTF_8); // Invalid input\n94: try {\n95: TarUtils.parseOctal(buffer,0, buffer.length);\n96: fail(\"Expected IllegalArgumentException\");\n97: } catch (IllegalArgumentException expected) {\n98: }\n99: buffer = \" 0 07 \".getBytes(CharsetNames.UTF_8); // Invalid - embedded space\n100: try {\n101: TarUtils.parseOctal(buffer,0, buffer.length);\n102: fail(\"Expected IllegalArgumentException - embedded space\");\n103: } catch (IllegalArgumentException expected) {\n104: }\n105: buffer = \" 0\\00007 \".getBytes(CharsetNames.UTF_8); // Invalid - embedded NUL\n106: try {\n107: TarUtils.parseOctal(buffer,0, buffer.length);\n108: fail(\"Expected IllegalArgumentException - embedded NUL\");\n109: } catch (IllegalArgumentException expected) {\n110: }\n111: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\nMap<String, SimpleEncodingHolder> se =\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\ncharsetName = System.getProperty(\"file.encoding\");\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:<clinit>()V",
                                    "method_body": "private static final int BYTE_MASK = 255;\nstatic final ZipEncoding DEFAULT_ENCODING =\nstatic final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\nif (length < 2){\nthrow new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\nif (buffer[start] == 0) {\nreturn 0L;\nwhile (start < end){\nif (buffer[start] == ' '){\nstart++;\nbyte trailer = buffer[end - 1];\nwhile (start < end && (trailer == 0 || trailer == ' ')) {\nend--;\ntrailer = buffer[end - 1];\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\nif (currentByte == 0) {\nbreak;\nif (currentByte < '0' || currentByte > '7'){\nthrow new IllegalArgumentException(\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:exceptionMessage([BIIIB)Ljava/lang/String;",
                                    "method_body": "private static String exceptionMessage(byte[] buffer, final int offset,\nString string = new String(buffer, offset, length);\nstring=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed\nfinal String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;\nreturn s;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.TarTestCase.testCOMPRESS178",
                            "test_body": "319: public void testCOMPRESS178() throws Exception {\n320: final File input = getFile(\"COMPRESS-178.tar\");\n321: final InputStream is = new FileInputStream(input);\n322: final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"tar\", is);\n323: try {\n324: in.getNextEntry();\n325: fail(\"Expected IOException\");\n326: } catch (IOException e) {\n327: Throwable t = e.getCause();\n328: assertTrue(\"Expected cause = IllegalArgumentException\", t instanceof IllegalArgumentException);\n329: }\n330: in.close();\n331: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\nMap<String, SimpleEncodingHolder> se =\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\ncharsetName = System.getProperty(\"file.encoding\");\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:<clinit>()V",
                                    "method_body": "private static final int BYTE_MASK = 255;\nstatic final ZipEncoding DEFAULT_ENCODING =\nstatic final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\nif (length < 2){\nthrow new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\nif (buffer[start] == 0) {\nreturn 0L;\nwhile (start < end){\nif (buffer[start] == ' '){\nstart++;\nbyte trailer = buffer[end - 1];\nwhile (start < end && (trailer == 0 || trailer == ' ')) {\nend--;\ntrailer = buffer[end - 1];\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\nif (currentByte == 0) {\nbreak;\nif (currentByte < '0' || currentByte > '7'){\nthrow new IllegalArgumentException(\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>()V",
                                    "method_body": "public ArchiveStreamFactory() {\nthis(null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>(Ljava/lang/String;)V",
                                    "method_body": "public static final String SEVEN_Z = \"7z\";\nprivate volatile String entryEncoding = null;\nthis(null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveInputStream(Ljava/lang/String;Ljava/io/InputStream;)Lorg/apache/commons/compress/archivers/ArchiveInputStream;",
                                    "method_body": "public ArchiveInputStream createArchiveInputStream(\nif (archiverName == null) {\nif (in == null) {\nif (AR.equalsIgnoreCase(archiverName)) {\nif (ARJ.equalsIgnoreCase(archiverName)) {\nif (ZIP.equalsIgnoreCase(archiverName)) {\nif (TAR.equalsIgnoreCase(archiverName)) {\nif (entryEncoding != null) {\nreturn new TarArchiveInputStream(in);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data,this.charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:matchAsciiBuffer(Ljava/lang/String;[BII)Z",
                                    "method_body": "public static boolean matchAsciiBuffer(\nbuffer1 = expected.getBytes(CharsetNames.US_ASCII);\n}\nreturn isEqual(buffer1, 0, buffer1.length, buffer, offset, length, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isEqual([BII[BIIZ)Z",
                                    "method_body": "public static boolean isEqual(\nint minLen=length1 < length2 ? length1 : length2;\nfor (int i=0; i < minLen; i++){\nif (buffer1[offset1+i] != buffer2[offset2+i]){\nif (length1 == length2){\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isArrayZero([BI)Z",
                                    "method_body": "public static boolean isArrayZero(byte[] a, int size) {\nfor (int i = 0; i < size; i++) {\nif (a[i] != 0) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[B)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b) throws IOException {\nreturn readFully(input, b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b, int offset, int len)\nif (len < 0 || offset < 0 || len + offset > b.length) {\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\ncount += x;\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry() {\nString user = System.getProperty(\"user.name\", \"\");\nif (user.length() > MAX_NAMELEN) {\nthis.userName = user;\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/io/File;Ljava/lang/String;)V",
                                    "method_body": "private String name = \"\";\nprivate int userId = 0;\nprivate int groupId = 0;\nprivate long size = 0;\nprivate String linkName = \"\";\nprivate String magic = MAGIC_POSIX;\nprivate String version = VERSION_POSIX;\nprivate String groupName = \"\";\nprivate int devMajor = 0;\nprivate int devMinor = 0;\nprivate TarArchiveEntry() {\nString user = System.getProperty(\"user.name\", \"\");\nif (user.length() > MAX_NAMELEN) {\nthis.userName = user;\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public TarArchiveEntry(byte[] headerBuf, ZipEncoding encoding)\nthis();\nparseTarHeader(headerBuf, encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNUSparse()Z",
                                    "method_body": "public boolean isGNUSparse() {\nreturn linkFlag == LF_GNUTYPE_SPARSE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongLinkEntry()Z",
                                    "method_body": "public boolean isGNULongLinkEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGLINK\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongNameEntry()Z",
                                    "method_body": "public boolean isGNULongNameEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGNAME\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isPaxHeader()Z",
                                    "method_body": "public boolean isPaxHeader(){\nreturn linkFlag == LF_PAX_EXTENDED_HEADER_LC\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public void parseTarHeader(byte[] header, ZipEncoding encoding)\nparseTarHeader(header, encoding, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;Z)V",
                                    "method_body": "private void parseTarHeader(byte[] header, ZipEncoding encoding,\nint offset = 0;\nname = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\noffset += NAMELEN;\nmode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN);\noffset += MODELEN;\nuserId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\noffset += UIDLEN;\ngroupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\noffset += GIDLEN;\nsize = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\noffset += SIZELEN;\nmodTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN);\noffset += MODTIMELEN;\ncheckSumOK = TarUtils.verifyCheckSum(header);\noffset += CHKSUMLEN;\nlinkFlag = header[offset++];\nlinkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\noffset += NAMELEN;\nmagic = TarUtils.parseName(header, offset, MAGICLEN);\noffset += MAGICLEN;\nversion = TarUtils.parseName(header, offset, VERSIONLEN);\noffset += VERSIONLEN;\nuserName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)\noffset += UNAMELEN;\ngroupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN)\noffset += GNAMELEN;\ndevMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\ndevMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\nint type = evaluateType(header);\nswitch (type) {\noffset += ATIMELEN_GNU;\noffset += CTIMELEN_GNU;\noffset += OFFSETLEN_GNU;\noffset += LONGNAMESLEN_GNU;\noffset += PAD2LEN_GNU;\noffset += SPARSELEN_GNU;\nisExtended = TarUtils.parseBoolean(header, offset);\noffset += ISEXTENDEDLEN_GNU;\nrealSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU);\noffset += REALSIZELEN_GNU;\nbreak;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:evaluateType([B)I",
                                    "method_body": "private int evaluateType(byte[] header) {\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_GNU, header, MAGIC_OFFSET, MAGICLEN)) {\nreturn FORMAT_OLDGNU;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctalOrBinary([BII)J",
                                    "method_body": "public static long parseOctalOrBinary(final byte[] buffer, final int offset,\nif ((buffer[offset] & 0x80) == 0) {\nreturn parseOctal(buffer, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseBoolean([BI)Z",
                                    "method_body": "public static boolean parseBoolean(final byte[] buffer, final int offset) {\nreturn buffer[offset] == 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BII)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset, final int length) {\nreturn parseName(buffer, offset, length, DEFAULT_ENCODING);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BIILorg/apache/commons/compress/archivers/zip/ZipEncoding;)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset,\nint len = length;\nfor (; len > 0; len--) {\nif (buffer[offset + len - 1] != 0) {\nbreak;\nif (len > 0) {\nbyte[] b = new byte[len];\nSystem.arraycopy(buffer, offset, b, 0, len);\nreturn encoding.decode(b);\nreturn \"\";\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:verifyCheckSum([B)Z",
                                    "method_body": "public static boolean verifyCheckSum(byte[] header) {\nlong storedSum = 0;\nlong unsignedSum = 0;\nlong signedSum = 0;\nint digits = 0;\nfor (int i = 0; i < header.length; i++) {\nbyte b = header[i];\nif (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\nif ('0' <= b && b <= '7' && digits++ < 6) {\nstoredSum = storedSum * 8 + b - '0';\n} else if (digits > 0) {\ndigits = 6; // only look at the first octal digit sequence\nb = ' ';\nunsignedSum += 0xff & b;\nsignedSum += b;\nreturn storedSum == unsignedSum || storedSum == signedSum\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is) {\nthis(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\nthis(is, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;IILjava/lang/String;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize,\nString encoding) {\nthis.is = is;\nthis.hasHitEOF = false;\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.recordSize = recordSize;\nthis.blockSize = blockSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextTarEntry()Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;",
                                    "method_body": "public TarArchiveEntry getNextTarEntry() throws IOException {\nif (hasHitEOF) {\nif (currEntry != null) {\nbyte[] headerBuf = getRecord();\nif (headerBuf == null) {\ncurrEntry = new TarArchiveEntry(headerBuf, zipEncoding);\n}\nentryOffset = 0;\nentrySize = currEntry.getSize();\nif (currEntry.isGNULongLinkEntry()) {\nif (currEntry.isGNULongNameEntry()) {\nif (currEntry.isPaxHeader()){ // Process Pax headers\nif (currEntry.isGNUSparse()){ // Process sparse files\nentrySize = currEntry.getSize();\nreturn currEntry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getRecord()[B",
                                    "method_body": "private byte[] getRecord() throws IOException {\nbyte[] headerBuf = readRecord();\nhasHitEOF = isEOFRecord(headerBuf);\nif (hasHitEOF && headerBuf != null) {\nreturn headerBuf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:isEOFRecord([B)Z",
                                    "method_body": "protected boolean isEOFRecord(byte[] record) {\nreturn record == null || ArchiveUtils.isArrayZero(record, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:readRecord()[B",
                                    "method_body": "protected byte[] readRecord() throws IOException {\nbyte[] record = new byte[recordSize];\nint readNow = IOUtils.readFully(is, record);\ncount(readNow);\nif (readNow != recordSize) {\nreturn record;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextEntry()Lorg/apache/commons/compress/archivers/ArchiveEntry;",
                                    "method_body": "public ArchiveEntry getNextEntry() throws IOException {\nreturn getNextTarEntry();\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 32,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest.shouldReadBigGid",
                            "test_body": "239: public void shouldReadBigGid() throws Exception {\n240: ByteArrayOutputStream bos = new ByteArrayOutputStream();\n241: TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n242: tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX);\n243: TarArchiveEntry t = new TarArchiveEntry(\"name\");\n244: t.setGroupId(4294967294l);\n245: t.setSize(1);\n246: tos.putArchiveEntry(t);\n247: tos.write(30);\n248: tos.closeArchiveEntry();\n249: tos.close();\n250: byte[] data = bos.toByteArray();\n251: ByteArrayInputStream bis = new ByteArrayInputStream(data);\n252: TarArchiveInputStream tis =\n253: new TarArchiveInputStream(bis);\n254: t = tis.getNextTarEntry();\n255: assertEquals(4294967294l, t.getLongGroupId());\n256: tis.close();\n257: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nint num = read(SINGLE, 0, 1);\nreturn num == -1 ? -1 : SINGLE[0] & BYTE_MASK;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveOutputStream:<init>()V",
                                    "method_body": "private final byte[] oneByte = new byte[1];\nprivate long bytesWritten = 0;\n* {@link #closeArchiveEntry()} to complete the process."
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveOutputStream:write(I)V",
                                    "method_body": "public void write(int b) throws IOException {\noneByte[0] = (byte) (b & BYTE_MASK);\nwrite(oneByte, 0, 1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\nMap<String, SimpleEncodingHolder> se =\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\nif (name == null) {\nSimpleEncodingHolder h = simpleEncodings.get(name);\nif (h!=null) {\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\ncharsetName = Charset.defaultCharset().name();\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\nfor (String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(String name) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn ByteBuffer.wrap(name.getBytes(this.charsetName));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data,this.charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:<init>(Ljava/nio/charset/Charset;)V",
                                    "method_body": "public NioZipEncoding(Charset charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:matchAsciiBuffer(Ljava/lang/String;[BII)Z",
                                    "method_body": "public static boolean matchAsciiBuffer(\nbuffer1 = expected.getBytes(CharsetNames.US_ASCII);\n}\nreturn isEqual(buffer1, 0, buffer1.length, buffer, offset, length, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isEqual([BII[BIIZ)Z",
                                    "method_body": "public static boolean isEqual(\nint minLen=length1 < length2 ? length1 : length2;\nfor (int i=0; i < minLen; i++){\nif (buffer1[offset1+i] != buffer2[offset2+i]){\nreturn false;\nif (length1 == length2){\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isArrayZero([BI)Z",
                                    "method_body": "public static boolean isArrayZero(byte[] a, int size) {\nfor (int i = 0; i < size; i++) {\nif (a[i] != 0) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:skip(Ljava/io/InputStream;J)J",
                                    "method_body": "public static long skip(InputStream input, long numToSkip) throws IOException {\nlong available = numToSkip;\nwhile (numToSkip > 0) {\nlong skipped = input.skip(numToSkip);\nif (skipped == 0) {\nbreak;\nnumToSkip -= skipped;\n}\nwhile (numToSkip > 0) {\nint read = readFully(input, SKIP_BUF, 0,\nif (read < 1) {\nbreak;\nreturn available - numToSkip;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[B)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b) throws IOException {\nreturn readFully(input, b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b, int offset, int len)\nif (len < 0 || offset < 0 || len + offset > b.length) {\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\nbreak;\ncount += x;\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public CountingOutputStream(final OutputStream out) {\nsuper(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:write([B)V",
                                    "method_body": "public void write(byte[] b) throws IOException {\nwrite(b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int off, int len) throws IOException {\nout.write(b, off, len);\ncount(len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:count(J)V",
                                    "method_body": "protected void count(long written) {\nif (written != -1) {\nbytesWritten += written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public TarArchiveOutputStream(OutputStream os) {\nthis(os, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;II)V",
                                    "method_body": "public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) {\nthis(os, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;IILjava/lang/String;)V",
                                    "method_body": "public static final int LONGFILE_ERROR = 0;\nprivate int       longFileMode = LONGFILE_ERROR;\nprivate int       bigNumberMode = BIGNUMBER_ERROR;\nprivate boolean closed = false;\nprivate boolean haveUnclosedEntry = false;\nprivate boolean finished = false;\nprivate boolean addPaxHeadersForNonAsciiNames = false;\nprivate static final ZipEncoding ASCII =\nthis(os, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<clinit>()V",
                                    "method_body": "public static final int LONGFILE_ERROR = 0;\nprivate int       longFileMode = LONGFILE_ERROR;\nprivate int       bigNumberMode = BIGNUMBER_ERROR;\nprivate boolean closed = false;\nprivate boolean haveUnclosedEntry = false;\nprivate boolean finished = false;\nprivate boolean addPaxHeadersForNonAsciiNames = false;\nprivate static final ZipEncoding ASCII =\nthis(os, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:setBigNumberMode(I)V",
                                    "method_body": "public void setBigNumberMode(int bigNumberMode) {\nthis.bigNumberMode = bigNumberMode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif (finished) {\nif (haveUnclosedEntry) {\nwriteEOFRecord();\nwriteEOFRecord();\npadAsNeeded();\nout.flush();\nfinished = true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!finished) {\nfinish();\nif (!closed) {\nout.close();\nclosed = true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\nif (finished) {\nTarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\nMap<String, String> paxHeaders = new HashMap<String, String>();\nfinal String entryName = entry.getName();\nboolean paxHeaderContainsPath = handleLongName(entry, entryName, paxHeaders, \"path\",\nfinal String linkName = entry.getLinkName();\nboolean paxHeaderContainsLinkPath = linkName != null && linkName.length() > 0\nif (bigNumberMode == BIGNUMBER_POSIX) {\naddPaxHeadersForBigNumbers(paxHeaders, entry);\nif (addPaxHeadersForNonAsciiNames && !paxHeaderContainsPath\nif (addPaxHeadersForNonAsciiNames && !paxHeaderContainsLinkPath\nif (paxHeaders.size() > 0) {\nwritePaxHeaders(entry, entryName, paxHeaders);\nentry.writeEntryHeader(recordBuf, zipEncoding,\nwriteRecord(recordBuf);\ncurrBytes = 0;\nif (entry.isDirectory()) {\ncurrSize = entry.getSize();\ncurrName = entryName;\nhaveUnclosedEntry = true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (finished) {\nif (!haveUnclosedEntry){\nif (assemLen > 0) {\nfor (int i = assemLen; i < assemBuf.length; ++i) {\nassemBuf[i] = 0;\nwriteRecord(assemBuf);\ncurrBytes += assemLen;\nassemLen = 0;\nif (currBytes < currSize) {\nhaveUnclosedEntry = false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\nif (!haveUnclosedEntry) {\nif (currBytes + numToWrite > currSize) {\nif (assemLen > 0) {\nwhile (numToWrite > 0) {\nif (numToWrite < recordBuf.length) {\nSystem.arraycopy(wBuf, wOffset, assemBuf, assemLen,\nassemLen += numToWrite;\nbreak;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:writePaxHeaders(Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;Ljava/lang/String;Ljava/util/Map;)V",
                                    "method_body": "void writePaxHeaders(TarArchiveEntry entry,\nString name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\nif (name.length() >= TarConstants.NAMELEN) {\nTarArchiveEntry pex = new TarArchiveEntry(name,\ntransferModTime(entry, pex);\nStringWriter w = new StringWriter();\nfor (Map.Entry<String, String> h : headers.entrySet()) {\nString key = h.getKey();\nString value = h.getValue();\nint len = key.length() + value.length()\nString line = len + \" \" + key + \"=\" + value + \"\\n\";\nint actualLength = line.getBytes(CharsetNames.UTF_8).length;\nwhile (len != actualLength) {\nw.write(line);\n}\nbyte[] data = w.toString().getBytes(CharsetNames.UTF_8);\npex.setSize(data.length);\nputArchiveEntry(pex);\nwrite(data);\ncloseArchiveEntry();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:stripTo7Bits(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private String stripTo7Bits(String name) {\nfinal int length = name.length();\nStringBuilder result = new StringBuilder(length);\nfor (int i = 0; i < length; i++) {\nchar stripped = (char) (name.charAt(i) & 0x7F);\nif (shouldBeReplaced(stripped)) {\nresult.append(stripped);\nreturn result.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:shouldBeReplaced(C)Z",
                                    "method_body": "private boolean shouldBeReplaced(char c) {\nreturn c == 0 // would be read as Trailing null\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:writeEOFRecord()V",
                                    "method_body": "private void writeEOFRecord() throws IOException {\nArrays.fill(recordBuf, (byte) 0);\nwriteRecord(recordBuf);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:writeRecord([B)V",
                                    "method_body": "private void writeRecord(byte[] record) throws IOException {\nif (record.length != recordSize) {\nout.write(record);\nrecordsWritten++;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:padAsNeeded()V",
                                    "method_body": "private void padAsNeeded() throws IOException {\nint start = recordsWritten % recordsPerBlock;\nif (start != 0) {\nfor (int i = start; i < recordsPerBlock; i++) {\nwriteEOFRecord();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:addPaxHeadersForBigNumbers(Ljava/util/Map;Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;)V",
                                    "method_body": "private void addPaxHeadersForBigNumbers(Map<String, String> paxHeaders,\naddPaxHeaderForBigNumber(paxHeaders, \"size\", entry.getSize(),\naddPaxHeaderForBigNumber(paxHeaders, \"gid\", entry.getLongGroupId(),\naddPaxHeaderForBigNumber(paxHeaders, \"mtime\",\naddPaxHeaderForBigNumber(paxHeaders, \"uid\", entry.getLongUserId(),\naddPaxHeaderForBigNumber(paxHeaders, \"SCHILY.devmajor\",\naddPaxHeaderForBigNumber(paxHeaders, \"SCHILY.devminor\",\nfailForBigNumber(\"mode\", entry.getMode(), TarConstants.MAXID);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:addPaxHeaderForBigNumber(Ljava/util/Map;Ljava/lang/String;JJ)V",
                                    "method_body": "private void addPaxHeaderForBigNumber(Map<String, String> paxHeaders,\nif (value < 0 || value > maxValue) {\npaxHeaders.put(header, String.valueOf(value));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:failForBigNumber(Ljava/lang/String;JJ)V",
                                    "method_body": "private void failForBigNumber(String field, long value, long maxValue) {\nfailForBigNumber(field, value, maxValue, \"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:failForBigNumber(Ljava/lang/String;JJLjava/lang/String;)V",
                                    "method_body": "private void failForBigNumber(String field, long value, long maxValue, String additionalMsg) {\nif (value < 0 || value > maxValue) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:handleLongName(Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;Ljava/lang/String;Ljava/util/Map;Ljava/lang/String;BLjava/lang/String;)Z",
                                    "method_body": "private boolean handleLongName(TarArchiveEntry entry , String name,\nfinal ByteBuffer encodedName = zipEncoding.encode(name);\nfinal int len = encodedName.limit() - encodedName.position();\nif (len >= TarConstants.NAMELEN) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:transferModTime(Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;)V",
                                    "method_body": "private void transferModTime(TarArchiveEntry from, TarArchiveEntry to) {\nDate fromModTime = from.getModTime();\nlong fromModTimeSeconds = fromModTime.getTime() / 1000;\nif (fromModTimeSeconds < 0 || fromModTimeSeconds > TarConstants.MAXSIZE) {\nto.setModTime(fromModTime);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry() {\nString user = System.getProperty(\"user.name\", \"\");\nif (user.length() > MAX_NAMELEN) {\nthis.userName = user;\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/io/File;Ljava/lang/String;)V",
                                    "method_body": "private String name = \"\";\nprivate long userId = 0;\nprivate long groupId = 0;\nprivate long size = 0;\nprivate String linkName = \"\";\nprivate String magic = MAGIC_POSIX;\nprivate String version = VERSION_POSIX;\nprivate String groupName = \"\";\nprivate int devMajor = 0;\nprivate int devMinor = 0;\nprivate TarArchiveEntry() {\nString user = System.getProperty(\"user.name\", \"\");\nif (user.length() > MAX_NAMELEN) {\nthis.userName = user;\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public TarArchiveEntry(String name) {\nthis(name, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/lang/String;Z)V",
                                    "method_body": "public TarArchiveEntry(String name, boolean preserveLeadingSlashes) {\nthis();\nname = normalizeFileName(name, preserveLeadingSlashes);\nboolean isDir = name.endsWith(\"/\");\nthis.name = name;\nthis.mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE;\nthis.linkFlag = isDir ? LF_DIR : LF_NORMAL;\nthis.modTime = new Date().getTime() / MILLIS_PER_SECOND;\nthis.userName = \"\";\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/lang/String;B)V",
                                    "method_body": "public TarArchiveEntry(String name, byte linkFlag) {\nthis(name, linkFlag, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/lang/String;BZ)V",
                                    "method_body": "public TarArchiveEntry(String name, byte linkFlag, boolean preserveLeadingSlashes) {\nthis(name, preserveLeadingSlashes);\nthis.linkFlag = linkFlag;\nif (linkFlag == LF_GNUTYPE_LONGNAME) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public TarArchiveEntry(byte[] headerBuf, ZipEncoding encoding)\nthis();\nparseTarHeader(headerBuf, encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getLinkName()Ljava/lang/String;",
                                    "method_body": "public String getLinkName() {\nreturn linkName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getLongUserId()J",
                                    "method_body": "public long getLongUserId() {\nreturn userId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getLongGroupId()J",
                                    "method_body": "public long getLongGroupId() {\nreturn groupId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:setGroupId(J)V",
                                    "method_body": "public void setGroupId(long groupId) {\nthis.groupId = groupId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:setModTime(Ljava/util/Date;)V",
                                    "method_body": "public void setModTime(Date time) {\nmodTime = time.getTime() / MILLIS_PER_SECOND;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getModTime()Ljava/util/Date;",
                                    "method_body": "public Date getModTime() {\nreturn new Date(modTime * MILLIS_PER_SECOND);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getMode()I",
                                    "method_body": "public int getMode() {\nreturn mode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nif (size < 0){\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getDevMajor()I",
                                    "method_body": "public int getDevMajor() {\nreturn devMajor;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getDevMinor()I",
                                    "method_body": "public int getDevMinor() {\nreturn devMinor;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNUSparse()Z",
                                    "method_body": "public boolean isGNUSparse() {\nreturn linkFlag == LF_GNUTYPE_SPARSE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongLinkEntry()Z",
                                    "method_body": "public boolean isGNULongLinkEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGLINK\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongNameEntry()Z",
                                    "method_body": "public boolean isGNULongNameEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGNAME\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isPaxHeader()Z",
                                    "method_body": "public boolean isPaxHeader(){\nreturn linkFlag == LF_PAX_EXTENDED_HEADER_LC\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nif (file != null) {\nif (linkFlag == LF_DIR) {\nif (getName().endsWith(\"/\")) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:writeEntryHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;Z)V",
                                    "method_body": "public void writeEntryHeader(byte[] outbuf, ZipEncoding encoding,\nint offset = 0;\noffset = TarUtils.formatNameBytes(name, outbuf, offset, NAMELEN,\noffset = writeEntryHeaderField(mode, outbuf, offset, MODELEN, starMode);\noffset = writeEntryHeaderField(userId, outbuf, offset, UIDLEN,\noffset = writeEntryHeaderField(groupId, outbuf, offset, GIDLEN,\noffset = writeEntryHeaderField(size, outbuf, offset, SIZELEN, starMode);\noffset = writeEntryHeaderField(modTime, outbuf, offset, MODTIMELEN,\nint csOffset = offset;\nfor (int c = 0; c < CHKSUMLEN; ++c) {\noutbuf[offset++] = (byte) ' ';\noutbuf[offset++] = linkFlag;\noffset = TarUtils.formatNameBytes(linkName, outbuf, offset, NAMELEN,\noffset = TarUtils.formatNameBytes(magic, outbuf, offset, MAGICLEN);\noffset = TarUtils.formatNameBytes(version, outbuf, offset, VERSIONLEN);\noffset = TarUtils.formatNameBytes(userName, outbuf, offset, UNAMELEN,\noffset = TarUtils.formatNameBytes(groupName, outbuf, offset, GNAMELEN,\noffset = writeEntryHeaderField(devMajor, outbuf, offset, DEVLEN,\noffset = writeEntryHeaderField(devMinor, outbuf, offset, DEVLEN,\nwhile (offset < outbuf.length) {\noutbuf[offset++] = 0;\nlong chk = TarUtils.computeCheckSum(outbuf);\nTarUtils.formatCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:writeEntryHeaderField(J[BIIZ)I",
                                    "method_body": "private int writeEntryHeaderField(long value, byte[] outbuf, int offset,\nif (!starMode && (value < 0\nreturn TarUtils.formatLongOctalBytes(0, outbuf, offset, length);\nreturn TarUtils.formatLongOctalOrBinaryBytes(value, outbuf, offset,\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public void parseTarHeader(byte[] header, ZipEncoding encoding)\nparseTarHeader(header, encoding, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;Z)V",
                                    "method_body": "private void parseTarHeader(byte[] header, ZipEncoding encoding,\nint offset = 0;\nname = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\noffset += NAMELEN;\nmode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN);\noffset += MODELEN;\nuserId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\noffset += UIDLEN;\ngroupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\noffset += GIDLEN;\nsize = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\noffset += SIZELEN;\nmodTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN);\noffset += MODTIMELEN;\ncheckSumOK = TarUtils.verifyCheckSum(header);\noffset += CHKSUMLEN;\nlinkFlag = header[offset++];\nlinkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\noffset += NAMELEN;\nmagic = TarUtils.parseName(header, offset, MAGICLEN);\noffset += MAGICLEN;\nversion = TarUtils.parseName(header, offset, VERSIONLEN);\noffset += VERSIONLEN;\nuserName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)\noffset += UNAMELEN;\ngroupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN)\noffset += GNAMELEN;\ndevMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\ndevMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\nint type = evaluateType(header);\nswitch (type) {\nString prefix = oldStyle\nif (isDirectory() && !name.endsWith(\"/\")){\nif (prefix.length() > 0){\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:normalizeFileName(Ljava/lang/String;Z)Ljava/lang/String;",
                                    "method_body": "private static String normalizeFileName(String fileName,\nString osname = System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH);\nif (osname != null) {\nif (osname.startsWith(\"windows\")) {\n} else if (osname.contains(\"netware\")) {\nfileName = fileName.replace(File.separatorChar, '/');\nwhile (!preserveLeadingSlashes && fileName.startsWith(\"/\")) {\nreturn fileName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:evaluateType([B)I",
                                    "method_body": "private int evaluateType(byte[] header) {\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_GNU, header, MAGIC_OFFSET, MAGICLEN)) {\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_POSIX, header, MAGIC_OFFSET, MAGICLEN)) {\nreturn FORMAT_POSIX;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:<clinit>()V",
                                    "method_body": "private static final int BYTE_MASK = 255;\nstatic final ZipEncoding DEFAULT_ENCODING =\nstatic final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\nif (length < 2){\nif (buffer[start] == 0) {\nwhile (start < end){\nif (buffer[start] == ' '){\nbyte trailer = buffer[end - 1];\nwhile (start < end && (trailer == 0 || trailer == ' ')) {\nend--;\ntrailer = buffer[end - 1];\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\nif (currentByte < '0' || currentByte > '7'){\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctalOrBinary([BII)J",
                                    "method_body": "public static long parseOctalOrBinary(final byte[] buffer, final int offset,\nif ((buffer[offset] & 0x80) == 0) {\nreturn parseOctal(buffer, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BII)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset, final int length) {\nreturn parseName(buffer, offset, length, DEFAULT_ENCODING);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BIILorg/apache/commons/compress/archivers/zip/ZipEncoding;)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset,\nint len = length;\nfor (; len > 0; len--) {\nif (buffer[offset + len - 1] != 0) {\nbreak;\nif (len > 0) {\nbyte[] b = new byte[len];\nSystem.arraycopy(buffer, offset, b, 0, len);\nreturn encoding.decode(b);\nreturn \"\";\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatNameBytes(Ljava/lang/String;[BII)I",
                                    "method_body": "public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {\nreturn formatNameBytes(name, buf, offset, length, DEFAULT_ENCODING);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatNameBytes(Ljava/lang/String;[BIILorg/apache/commons/compress/archivers/zip/ZipEncoding;)I",
                                    "method_body": "public static int formatNameBytes(String name, byte[] buf, final int offset,\nint len = name.length();\nByteBuffer b = encoding.encode(name);\nwhile (b.limit() > length && len > 0) {\nfinal int limit = b.limit() - b.position();\nSystem.arraycopy(b.array(), b.arrayOffset(), buf, offset, limit);\nfor (int i = limit; i < length; ++i) {\nbuf[offset + i] = 0;\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatUnsignedOctalString(J[BII)V",
                                    "method_body": "public static void formatUnsignedOctalString(final long value, byte[] buffer,\nint remaining = length;\nremaining--;\nif (value == 0) {\nbuffer[offset + remaining--] = (byte) '0';\nlong val = value;\nfor (; remaining >= 0 && val != 0; --remaining) {\nbuffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));\nval = val >>> 3;\nif (val != 0){\nfor (; remaining >= 0; --remaining) { // leading zeros\nbuffer[offset + remaining] = (byte) '0';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatLongOctalBytes(J[BII)I",
                                    "method_body": "public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {\nint idx=length-1; // For space\nformatUnsignedOctalString(value, buf, offset, idx);\nbuf[offset + idx] = (byte) ' '; // Trailing space\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatLongOctalOrBinaryBytes(J[BII)I",
                                    "method_body": "public static int formatLongOctalOrBinaryBytes(\nfinal long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\nfinal boolean negative = value < 0;\nif (!negative && value <= maxAsOctalChar) { // OK to store as octal chars\nreturn formatLongOctalBytes(value, buf, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatCheckSumOctalBytes(J[BII)I",
                                    "method_body": "public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {\nint idx=length-2; // for NUL and space\nformatUnsignedOctalString(value, buf, offset, idx);\nbuf[offset + idx++]   = 0; // Trailing null\nbuf[offset + idx]     = (byte) ' '; // Trailing space\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:computeCheckSum([B)J",
                                    "method_body": "public static long computeCheckSum(final byte[] buf) {\nlong sum = 0;\nfor (byte element : buf) {\nsum += BYTE_MASK & element;\nreturn sum;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:verifyCheckSum([B)Z",
                                    "method_body": "public static boolean verifyCheckSum(byte[] header) {\nlong storedSum = 0;\nlong unsignedSum = 0;\nlong signedSum = 0;\nint digits = 0;\nfor (int i = 0; i < header.length; i++) {\nbyte b = header[i];\nif (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\nif ('0' <= b && b <= '7' && digits++ < 6) {\nstoredSum = storedSum * 8 + b - '0';\n} else if (digits > 0) {\ndigits = 6; // only look at the first octal digit sequence\nb = ' ';\nunsignedSum += 0xff & b;\nsignedSum += b;\nreturn storedSum == unsignedSum || storedSum == signedSum\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is) {\nthis(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\nthis(is, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;IILjava/lang/String;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize,\nString encoding) {\nthis.is = is;\nthis.hasHitEOF = false;\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.recordSize = recordSize;\nthis.blockSize = blockSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:available()I",
                                    "method_body": "public int available() throws IOException {\nif (entrySize - entryOffset > Integer.MAX_VALUE) {\nreturn (int) (entrySize - entryOffset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:skip(J)J",
                                    "method_body": "public long skip(final long n) throws IOException {\nif (n <= 0) {\nfinal long available = entrySize - entryOffset;\nfinal long skipped = is.skip(Math.min(n, available));\ncount(skipped);\nentryOffset += skipped;\nreturn skipped;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextTarEntry()Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;",
                                    "method_body": "public TarArchiveEntry getNextTarEntry() throws IOException {\nif (hasHitEOF) {\nif (currEntry != null) {\nIOUtils.skip(this, Long.MAX_VALUE);\nskipRecordPadding();\nbyte[] headerBuf = getRecord();\nif (headerBuf == null) {\ncurrEntry = new TarArchiveEntry(headerBuf, zipEncoding);\n}\nentryOffset = 0;\nentrySize = currEntry.getSize();\nif (currEntry.isGNULongLinkEntry()) {\nif (currEntry.isGNULongNameEntry()) {\nif (currEntry.isPaxHeader()){ // Process Pax headers\npaxHeaders();\nif (currEntry.isGNUSparse()){ // Process sparse files\nentrySize = currEntry.getSize();\nreturn currEntry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:skipRecordPadding()V",
                                    "method_body": "private void skipRecordPadding() throws IOException {\nif (this.entrySize > 0 && this.entrySize % this.recordSize != 0) {\nlong numRecords = (this.entrySize / this.recordSize) + 1;\nlong padding = (numRecords * this.recordSize) - this.entrySize;\nlong skipped = IOUtils.skip(is, padding);\ncount(skipped);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getRecord()[B",
                                    "method_body": "private byte[] getRecord() throws IOException {\nbyte[] headerBuf = readRecord();\nhasHitEOF = isEOFRecord(headerBuf);\nif (hasHitEOF && headerBuf != null) {\nreturn headerBuf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:isEOFRecord([B)Z",
                                    "method_body": "protected boolean isEOFRecord(byte[] record) {\nreturn record == null || ArchiveUtils.isArrayZero(record, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:readRecord()[B",
                                    "method_body": "protected byte[] readRecord() throws IOException {\nbyte[] record = new byte[recordSize];\nint readNow = IOUtils.readFully(is, record);\ncount(readNow);\nif (readNow != recordSize) {\nreturn record;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:paxHeaders()V",
                                    "method_body": "private void paxHeaders() throws IOException{\nMap<String, String> headers = parsePaxHeaders(this);\ngetNextEntry(); // Get the actual file entry\napplyPaxHeadersToCurrentEntry(headers);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:parsePaxHeaders(Ljava/io/InputStream;)Ljava/util/Map;",
                                    "method_body": "Map<String, String> parsePaxHeaders(InputStream i) throws IOException {\nMap<String, String> headers = new HashMap<String, String>();\nint len = 0;\nint read = 0;\nwhile((ch = i.read()) != -1) {\nread++;\nif (ch == ' '){ // End of length string\nByteArrayOutputStream coll = new ByteArrayOutputStream();\nwhile((ch = i.read()) != -1) {\nread++;\nif (ch == '='){ // end of keyword\nString keyword = coll.toString(CharsetNames.UTF_8);\nfinal int restLen = len - read;\nbyte[] rest = new byte[restLen];\nint got = IOUtils.readFully(i, rest);\nif (got != restLen) {\nString value = new String(rest, 0,\nheaders.put(keyword, value);\nbreak;\ncoll.write((byte) ch);\nlen *= 10;\nlen += ch - '0';\nif (ch == -1){ // EOF\nbreak;\n}\nreturn headers;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:applyPaxHeadersToCurrentEntry(Ljava/util/Map;)V",
                                    "method_body": "private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\nfor (Entry<String, String> ent : headers.entrySet()){\nString key = ent.getKey();\nString val = ent.getValue();\nif (\"path\".equals(key)){\n} else if (\"linkpath\".equals(key)){\n} else if (\"gid\".equals(key)){\ncurrEntry.setGroupId(Integer.parseInt(val));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextEntry()Lorg/apache/commons/compress/archivers/ArchiveEntry;",
                                    "method_body": "public ArchiveEntry getNextEntry() throws IOException {\nreturn getNextTarEntry();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] buf, int offset, int numToRead) throws IOException {\nint totalRead = 0;\nif (hasHitEOF || entryOffset >= entrySize) {\nreturn -1;\nif (currEntry == null) {\nnumToRead = Math.min(numToRead, available());\ntotalRead = is.read(buf, offset, numToRead);\nif (totalRead == -1) {\ncount(totalRead);\nentryOffset += totalRead;\nreturn totalRead;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 33,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.compressors.DetectCompressorTestCase.testDetection",
                            "test_body": "91: public void testDetection() throws Exception {\n92: CompressorInputStream bzip2 = getStreamFor(\"bla.txt.bz2\"); \n93: assertNotNull(bzip2);\n94: assertTrue(bzip2 instanceof BZip2CompressorInputStream);\n95: 96: CompressorInputStream gzip = getStreamFor(\"bla.tgz\");\n97: assertNotNull(gzip);\n98: assertTrue(gzip instanceof GzipCompressorInputStream);\n99: 100: CompressorInputStream pack200 = getStreamFor(\"bla.pack\");\n101: assertNotNull(pack200);\n102: assertTrue(pack200 instanceof Pack200CompressorInputStream);\n103: 104: CompressorInputStream xz = getStreamFor(\"bla.tar.xz\");\n105: assertNotNull(xz);\n106: assertTrue(xz instanceof XZCompressorInputStream);\n107: 108: CompressorInputStream zlib = getStreamFor(\"bla.tar.deflatez\");\n109: assertNotNull(zlib);\n110: assertTrue(zlib instanceof DeflateCompressorInputStream);\n111: 112: try {\n113: factory.createCompressorInputStream(new ByteArrayInputStream(new byte[0]));\n114: fail(\"No exception thrown for an empty input stream\");\n115: } catch (CompressorException e) {\n116: // expected\n117: }\n118: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[B)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b) throws IOException {\nreturn readFully(input, b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b, int offset, int len)\nif (len < 0 || offset < 0 || len + offset > b.length) {\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\ncount += x;\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:<init>()V",
                                    "method_body": "CRC() {\ninitialiseCRC();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:<clinit>()V",
                                    "method_body": "private static final int crc32Table[] = {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:initialiseCRC()V",
                                    "method_body": "void initialiseCRC() {\nglobalCrc = 0xffffffff;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:<init>(Ljava/io/InputStream;Z)V",
                                    "method_body": "public BZip2CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException {\nthis.in = in;\nthis.decompressConcatenated = decompressConcatenated;\ninit(true);\ninitBlock();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:makeMaps()V",
                                    "method_body": "private void makeMaps() {\nfinal boolean[] inUse = this.data.inUse;\nfinal byte[] seqToUnseq = this.data.seqToUnseq;\nint nInUseShadow = 0;\nfor (int i = 0; i < 256; i++) {\nif (inUse[i]) {\nseqToUnseq[nInUseShadow++] = (byte) i;\nthis.nInUse = nInUseShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:init(Z)Z",
                                    "method_body": "private boolean init(boolean isFirstStream) throws IOException {\nif (null == in) {\nint magic0 = this.in.read();\nif (magic0 == -1 && !isFirstStream) {\nint magic1 = this.in.read();\nint magic2 = this.in.read();\nif (magic0 != 'B' || magic1 != 'Z' || magic2 != 'h') {\nint blockSize = this.in.read();\nif ((blockSize < '1') || (blockSize > '9')) {\nthis.blockSize100k = blockSize - '0';\nthis.bsLive = 0;\nthis.computedCombinedCRC = 0;\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:initBlock()V",
                                    "method_body": "private void initBlock() throws IOException {\nmagic0 = bsGetUByte();\nmagic1 = bsGetUByte();\nmagic2 = bsGetUByte();\nmagic3 = bsGetUByte();\nmagic4 = bsGetUByte();\nmagic5 = bsGetUByte();\nif (magic0 != 0x17 || magic1 != 0x72 || magic2 != 0x45\nif (magic0 != 0x31 || // '1'\nthis.storedBlockCRC = bsGetInt();\nthis.blockRandomised = bsR(1) == 1;\nif (this.data == null) {\nthis.data = new Data(this.blockSize100k);\ngetAndMoveToFrontDecode();\nthis.crc.initialiseCRC();\nthis.currentState = START_BLOCK_STATE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsR(I)I",
                                    "method_body": "private int bsR(final int n) throws IOException {\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\nif (bsLiveShadow < n) {\nfinal InputStream inShadow = this.in;\nint thech = inShadow.read();\nif (thech < 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\n} while (bsLiveShadow < n);\nthis.bsBuff = bsBuffShadow;\nthis.bsLive = bsLiveShadow - n;\nreturn (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsGetBit()Z",
                                    "method_body": "private boolean bsGetBit() throws IOException {\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\nif (bsLiveShadow < 1) {\nint thech = this.in.read();\nif (thech < 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\nthis.bsBuff = bsBuffShadow;\nthis.bsLive = bsLiveShadow - 1;\nreturn ((bsBuffShadow >> (bsLiveShadow - 1)) & 1) != 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsGetUByte()C",
                                    "method_body": "private char bsGetUByte() throws IOException {\nreturn (char) bsR(8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsGetInt()I",
                                    "method_body": "private int bsGetInt() throws IOException {\nreturn (((((bsR(8) << 8) | bsR(8)) << 8) | bsR(8)) << 8) | bsR(8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:hbCreateDecodeTables([I[I[I[CIII)V",
                                    "method_body": "private static void hbCreateDecodeTables(final int[] limit,\nfor (int i = minLen, pp = 0; i <= maxLen; i++) {\nfor (int j = 0; j < alphaSize; j++) {\nif (length[j] == i) {\nperm[pp++] = j;\nfor (int i = MAX_CODE_LEN; --i > 0;) {\nbase[i] = 0;\nlimit[i] = 0;\nfor (int i = 0; i < alphaSize; i++) {\nbase[length[i] + 1]++;\nfor (int i = 1, b = base[0]; i < MAX_CODE_LEN; i++) {\nb += base[i];\nbase[i] = b;\nfor (int i = minLen, vec = 0, b = base[i]; i <= maxLen; i++) {\nfinal int nb = base[i + 1];\nvec += nb - b;\nb = nb;\nlimit[i] = vec - 1;\nvec <<= 1;\nfor (int i = minLen + 1; i <= maxLen; i++) {\nbase[i] = ((limit[i - 1] + 1) << 1) - base[i];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:recvDecodingTables()V",
                                    "method_body": "private void recvDecodingTables() throws IOException {\nfinal Data dataShadow = this.data;\nfinal boolean[] inUse = dataShadow.inUse;\nfinal byte[] pos = dataShadow.recvDecodingTables_pos;\nfinal byte[] selector = dataShadow.selector;\nfinal byte[] selectorMtf = dataShadow.selectorMtf;\nint inUse16 = 0;\nfor (int i = 0; i < 16; i++) {\nif (bsGetBit()) {\ninUse16 |= 1 << i;\nfor (int i = 256; --i >= 0;) {\ninUse[i] = false;\nfor (int i = 0; i < 16; i++) {\nif ((inUse16 & (1 << i)) != 0) {\nfinal int i16 = i << 4;\nfor (int j = 0; j < 16; j++) {\nif (bsGetBit()) {\ninUse[i16 + j] = true;\nmakeMaps();\nfinal int alphaSize = this.nInUse + 2;\nfinal int nGroups = bsR(3);\nfinal int nSelectors = bsR(15);\nfor (int i = 0; i < nSelectors; i++) {\nint j = 0;\nwhile (bsGetBit()) {\nselectorMtf[i] = (byte) j;\nfor (int v = nGroups; --v >= 0;) {\npos[v] = (byte) v;\nfor (int i = 0; i < nSelectors; i++) {\nint v = selectorMtf[i] & 0xff;\nfinal byte tmp = pos[v];\nwhile (v > 0) {\npos[0] = tmp;\nselector[i] = tmp;\nfinal char[][] len = dataShadow.temp_charArray2d;\nfor (int t = 0; t < nGroups; t++) {\nint curr = bsR(5);\nfinal char[] len_t = len[t];\nfor (int i = 0; i < alphaSize; i++) {\nwhile (bsGetBit()) {\ncurr += bsGetBit() ? -1 : 1;\nlen_t[i] = (char) curr;\ncreateHuffmanDecodingTables(alphaSize, nGroups);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:createHuffmanDecodingTables(II)V",
                                    "method_body": "private void createHuffmanDecodingTables(final int alphaSize,\nfinal Data dataShadow = this.data;\nfinal char[][] len = dataShadow.temp_charArray2d;\nfinal int[] minLens = dataShadow.minLens;\nfinal int[][] limit = dataShadow.limit;\nfinal int[][] base = dataShadow.base;\nfinal int[][] perm = dataShadow.perm;\nfor (int t = 0; t < nGroups; t++) {\nint minLen = 32;\nint maxLen = 0;\nfinal char[] len_t = len[t];\nfor (int i = alphaSize; --i >= 0;) {\nfinal char lent = len_t[i];\nif (lent > maxLen) {\nmaxLen = lent;\nif (lent < minLen) {\nminLen = lent;\n}\nhbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen,\nminLens[t] = minLen;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:getAndMoveToFrontDecode()V",
                                    "method_body": "private void getAndMoveToFrontDecode() throws IOException {\nthis.origPtr = bsR(24);\nrecvDecodingTables();\nfinal InputStream inShadow = this.in;\nfinal Data dataShadow = this.data;\nfinal byte[] ll8 = dataShadow.ll8;\nfinal int[] unzftab = dataShadow.unzftab;\nfinal byte[] selector = dataShadow.selector;\nfinal byte[] seqToUnseq = dataShadow.seqToUnseq;\nfinal char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\nfinal int[] minLens = dataShadow.minLens;\nfinal int[][] limit = dataShadow.limit;\nfinal int[][] base = dataShadow.base;\nfinal int[][] perm = dataShadow.perm;\nfinal int limitLast = this.blockSize100k * 100000;\nfor (int i = 256; --i >= 0;) {\nyy[i] = (char) i;\nunzftab[i] = 0;\nint groupNo = 0;\nint groupPos = G_SIZE - 1;\nfinal int eob = this.nInUse + 1;\nint nextSym = getAndMoveToFrontDecode0(0);\nint bsBuffShadow = this.bsBuff;\nint bsLiveShadow = this.bsLive;\nint lastShadow = -1;\nint zt = selector[groupNo] & 0xff;\nint[] base_zt = base[zt];\nint[] limit_zt = limit[zt];\nint[] perm_zt = perm[zt];\nint minLens_zt = minLens[zt];\nwhile (nextSym != eob) {\nif ((nextSym == RUNA) || (nextSym == RUNB)) {\nint s = -1;\nfor (int n = 1; true; n <<= 1) {\nif (nextSym == RUNA) {\ns += n;\n} else if (nextSym == RUNB) {\nif (groupPos == 0) {\ngroupPos--;\nint zn = minLens_zt;\nwhile (bsLiveShadow < zn) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\nint zvec = (bsBuffShadow >> (bsLiveShadow - zn))\nbsLiveShadow -= zn;\nwhile (zvec > limit_zt[zn]) {\nzn++;\nwhile (bsLiveShadow < 1) {\nbsLiveShadow--;\nzvec = (zvec << 1)\nnextSym = perm_zt[zvec - base_zt[zn]];\nfinal byte ch = seqToUnseq[yy[0]];\nunzftab[ch & 0xff] += s + 1;\nwhile (s-- >= 0) {\nll8[++lastShadow] = ch;\nif (lastShadow >= limitLast) {\n} else {\nif (++lastShadow >= limitLast) {\nfinal char tmp = yy[nextSym - 1];\nunzftab[seqToUnseq[tmp] & 0xff]++;\nll8[lastShadow] = seqToUnseq[tmp];\nif (nextSym <= 16) {\nfor (int j = nextSym - 1; j > 0;) {\nyy[j] = yy[--j];\nyy[0] = tmp;\nif (groupPos == 0) {\ngroupPos--;\nint zn = minLens_zt;\nwhile (bsLiveShadow < zn) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\nint zvec = (bsBuffShadow >> (bsLiveShadow - zn))\nbsLiveShadow -= zn;\nwhile (zvec > limit_zt[zn]) {\nzn++;\nwhile (bsLiveShadow < 1) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\nbsLiveShadow--;\nzvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\nnextSym = perm_zt[zvec - base_zt[zn]];\n}\nthis.last = lastShadow;\nthis.bsLive = bsLiveShadow;\nthis.bsBuff = bsBuffShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:getAndMoveToFrontDecode0(I)I",
                                    "method_body": "private int getAndMoveToFrontDecode0(final int groupNo) throws IOException {\nfinal InputStream inShadow = this.in;\nfinal Data dataShadow = this.data;\nfinal int zt = dataShadow.selector[groupNo] & 0xff;\nfinal int[] limit_zt = dataShadow.limit[zt];\nint zn = dataShadow.minLens[zt];\nint zvec = bsR(zn);\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\nwhile (zvec > limit_zt[zn]) {\nzn++;\nwhile (bsLiveShadow < 1) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\nbsLiveShadow--;\nzvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\nthis.bsLive = bsLiveShadow;\nthis.bsBuff = bsBuffShadow;\nreturn dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < 3) {\nif (signature[0] != 'B') {\nreturn false;\nif (signature[1] != 'Z') {\nif (signature[2] != 'h') {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream$Data:<init>(I)V",
                                    "method_body": "final boolean[] inUse = new boolean[256]; // 256 byte\nfinal byte[] seqToUnseq = new byte[256]; // 256 byte\nfinal byte[] selector = new byte[MAX_SELECTORS]; // 18002 byte\nfinal byte[] selectorMtf = new byte[MAX_SELECTORS]; // 18002 byte\nfinal int[] unzftab = new int[256]; // 1024 byte\nfinal int[][] limit = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte\nfinal int[][] base = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte\nfinal int[][] perm = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte\nfinal int[] minLens = new int[N_GROUPS]; // 24 byte\nfinal int[] cftab = new int[257]; // 1028 byte\nfinal char[] getAndMoveToFrontDecode_yy = new char[256]; // 512 byte\nfinal char[][] temp_charArray2d = new char[N_GROUPS][MAX_ALPHA_SIZE]; // 3096\nfinal byte[] recvDecodingTables_pos = new byte[N_GROUPS]; // 6 byte\nData(int blockSize100k) {\nthis.ll8 = new byte[blockSize100k * BZip2Constants.BASEBLOCKSIZE];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream:<init>(Ljava/io/InputStream;Z)V",
                                    "method_body": "private static final int FHCRC = 0x02;\nprivate final byte[] buf = new byte[8192];\nprivate int bufUsed = 0;\nprivate Inflater inf = new Inflater(true);\nprivate final CRC32 crc = new CRC32();\nprivate boolean endReached = false;\nprivate final byte[] oneByte = new byte[1];\nprivate final GzipParameters parameters = new GzipParameters();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream:init(Z)Z",
                                    "method_body": "private boolean init(boolean isFirstMember) throws IOException {\nassert isFirstMember || decompressConcatenated;\nint magic0 = in.read();\nint magic1 = in.read();\nif (magic0 == -1 && !isFirstMember) {\nif (magic0 != 31 || magic1 != 139) {\nDataInputStream inData = new DataInputStream(in);\nint method = inData.readUnsignedByte();\nif (method != Deflater.DEFLATED) {\nint flg = inData.readUnsignedByte();\nif ((flg & FRESERVED) != 0) {\nparameters.setModificationTime(readLittleEndianInt(inData) * 1000);\nswitch (inData.readUnsignedByte()) { // extra flags\nparameters.setOperatingSystem(inData.readUnsignedByte());\nif ((flg & FEXTRA) != 0) {\nif ((flg & FNAME) != 0) {\nif ((flg & FCOMMENT) != 0) {\nif ((flg & FHCRC) != 0) {\ninf.reset();\ncrc.reset();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream:readLittleEndianInt(Ljava/io/DataInputStream;)J",
                                    "method_body": "private long readLittleEndianInt(DataInputStream inData) throws IOException {\nreturn inData.readUnsignedByte()\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < 2) {\nif (signature[0] != 31) {\nreturn false;\nif (signature[1] != -117) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.gzip.GzipParameters:<init>()V",
                                    "method_body": "private int compressionLevel = Deflater.DEFAULT_COMPRESSION;\nprivate int operatingSystem = 255; // Unknown OS by default\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.gzip.GzipParameters:setModificationTime(J)V",
                                    "method_body": "public void setModificationTime(long modificationTime) {\nthis.modificationTime = modificationTime;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.gzip.GzipParameters:setOperatingSystem(I)V",
                                    "method_body": "public void setOperatingSystem(int operatingSystem) {\nthis.operatingSystem = operatingSystem;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.CompressorStreamFactory:<init>()V",
                                    "method_body": "public CompressorStreamFactory() {\nthis.decompressUntilEOF = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.CompressorStreamFactory:<init>(Z)V",
                                    "method_body": "public CompressorStreamFactory(boolean decompressUntilEOF) {\nthis.decompressUntilEOF = Boolean.valueOf(decompressUntilEOF);\nthis.decompressConcatenated = decompressUntilEOF;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.CompressorStreamFactory:setDecompressConcatenated(Z)V",
                                    "method_body": "public void setDecompressConcatenated(boolean decompressConcatenated) {\nif (this.decompressUntilEOF != null) {\nthis.decompressConcatenated = decompressConcatenated;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.CompressorStreamFactory:createCompressorInputStream(Ljava/io/InputStream;)Lorg/apache/commons/compress/compressors/CompressorInputStream;",
                                    "method_body": "public CompressorInputStream createCompressorInputStream(final InputStream in)\nif (in == null) {\nif (!in.markSupported()) {\nfinal byte[] signature = new byte[12];\nin.mark(signature.length);\nint signatureLength = IOUtils.readFully(in, signature);\nin.reset();\nif (BZip2CompressorInputStream.matches(signature, signatureLength)) {\nreturn new BZip2CompressorInputStream(in, decompressConcatenated);\nif (GzipCompressorInputStream.matches(signature, signatureLength)) {\nreturn new GzipCompressorInputStream(in, decompressConcatenated);\nif (Pack200CompressorInputStream.matches(signature, signatureLength)) {\nreturn new Pack200CompressorInputStream(in);\nif (FramedSnappyCompressorInputStream.matches(signature, signatureLength)) {\nif (ZCompressorInputStream.matches(signature, signatureLength)) {\nif (XZUtils.matches(signature, signatureLength) &&\nreturn new XZCompressorInputStream(in, decompressConcatenated);\nif (LZMAUtils.matches(signature, signatureLength) &&\n}\nthrow new CompressorException(\"No Compressor found for the stream signature.\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.xz.XZCompressorInputStream:<init>(Ljava/io/InputStream;Z)V",
                                    "method_body": "public XZCompressorInputStream(InputStream inputStream,\nthrows IOException {\nif (decompressConcatenated) {\nin = new SingleXZInputStream(inputStream);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.xz.XZCompressorInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < XZ.HEADER_MAGIC.length) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.snappy.FramedSnappyCompressorInputStream:<clinit>()V",
                                    "method_body": "static final long MASK_OFFSET = 0xa282ead8L;\nprivate static final byte[] SZ_SIGNATURE = new byte[] {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.snappy.FramedSnappyCompressorInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < SZ_SIGNATURE.length) {\nbyte[] shortenedSig = signature;\nif (signature.length > SZ_SIGNATURE.length) {\nshortenedSig = new byte[SZ_SIGNATURE.length];\nSystem.arraycopy(signature, 0, shortenedSig, 0, SZ_SIGNATURE.length);\nreturn Arrays.equals(shortenedSig, SZ_SIGNATURE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.FileNameUtil:<init>(Ljava/util/Map;Ljava/lang/String;)V",
                                    "method_body": "public FileNameUtil(Map<String, String> uncompressSuffix,\nString defaultExtension) {\nthis.uncompressSuffix = Collections.unmodifiableMap(uncompressSuffix);\nint lc = Integer.MIN_VALUE, sc = Integer.MAX_VALUE;\nint lu = Integer.MIN_VALUE, su = Integer.MAX_VALUE;\nfor (Map.Entry<String, String> ent : uncompressSuffix.entrySet()) {\nint cl = ent.getKey().length();\nif (cl > lc) {\nlc = cl;\nif (cl < sc) {\nsc = cl;\nString u = ent.getValue();\nint ul = u.length();\nif (ul > 0) {\nif (!compressSuffix.containsKey(u)) {\ncompressSuffix.put(u, ent.getKey());\nif (ul > lu) {\nlu = ul;\nif (ul < su) {\nsu = ul;\n}\nlongestCompressedSuffix = lc;\nlongestUncompressedSuffix = lu;\nshortestCompressedSuffix = sc;\nshortestUncompressedSuffix = su;\nthis.defaultExtension = defaultExtension;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.xz.XZUtils:<clinit>()V",
                                    "method_body": "private static volatile CachedAvailability cachedXZAvailability;\nMap<String, String> uncompressSuffix = new HashMap<String, String>();\nuncompressSuffix.put(\".txz\", \".tar\");\nuncompressSuffix.put(\".xz\", \"\");\nuncompressSuffix.put(\"-xz\", \"\");\nfileNameUtil = new FileNameUtil(uncompressSuffix, \".xz\");\ncachedXZAvailability = CachedAvailability.DONT_CACHE;\nClass.forName(\"org.osgi.framework.BundleEvent\");\n} catch (Exception ex) {\nsetCacheXZAvailablity(true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.xz.XZUtils:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < HEADER_MAGIC.length) {\nfor (int i = 0; i < HEADER_MAGIC.length; ++i) {\nif (signature[i] != HEADER_MAGIC[i]) {\nreturn false;\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.xz.XZUtils:isXZCompressionAvailable()Z",
                                    "method_body": "public static boolean isXZCompressionAvailable() {\nfinal CachedAvailability cachedResult = cachedXZAvailability;\nif (cachedResult != CachedAvailability.DONT_CACHE) {\nreturn cachedResult == CachedAvailability.CACHED_AVAILABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.xz.XZUtils:internalIsXZCompressionAvailable()Z",
                                    "method_body": "private static boolean internalIsXZCompressionAvailable() {\nXZCompressorInputStream.matches(null, 0);\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.xz.XZUtils:setCacheXZAvailablity(Z)V",
                                    "method_body": "public static void setCacheXZAvailablity(boolean doCache) {\nif (!doCache) {\n} else if (cachedXZAvailability == CachedAvailability.DONT_CACHE) {\nfinal boolean hasXz = internalIsXZCompressionAvailable();\ncachedXZAvailability = hasXz ? CachedAvailability.CACHED_AVAILABLE\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.lzma.LZMAUtils:<clinit>()V",
                                    "method_body": "private static volatile CachedAvailability cachedLZMAAvailability;\nMap<String, String> uncompressSuffix = new HashMap<String, String>();\nuncompressSuffix.put(\".lzma\", \"\");\nuncompressSuffix.put(\"-lzma\", \"\");\nfileNameUtil = new FileNameUtil(uncompressSuffix, \".lzma\");\ncachedLZMAAvailability = CachedAvailability.DONT_CACHE;\nClass.forName(\"org.osgi.framework.BundleEvent\");\n} catch (Exception ex) {\nsetCacheLZMAAvailablity(true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.lzma.LZMAUtils:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < HEADER_MAGIC.length) {\nfor (int i = 0; i < HEADER_MAGIC.length; ++i) {\nif (signature[i] != HEADER_MAGIC[i]) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.lzma.LZMAUtils:internalIsLZMACompressionAvailable()Z",
                                    "method_body": "private static boolean internalIsLZMACompressionAvailable() {\nLZMACompressorInputStream.matches(null, 0);\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.lzma.LZMAUtils:setCacheLZMAAvailablity(Z)V",
                                    "method_body": "public static void setCacheLZMAAvailablity(boolean doCache) {\nif (!doCache) {\n} else if (cachedLZMAAvailability == CachedAvailability.DONT_CACHE) {\nfinal boolean hasLzma = internalIsLZMACompressionAvailable();\ncachedLZMAAvailability = hasLzma ? CachedAvailability.CACHED_AVAILABLE\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.lzma.LZMACompressorInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (signature == null || length < 3) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.pack200.Pack200CompressorInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public Pack200CompressorInputStream(final InputStream in)\nthis(in, Pack200Strategy.IN_MEMORY);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.pack200.Pack200CompressorInputStream:<init>(Ljava/io/InputStream;Lorg/apache/commons/compress/compressors/pack200/Pack200Strategy;)V",
                                    "method_body": "public Pack200CompressorInputStream(final InputStream in,\nthis(in, null, mode, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.pack200.Pack200CompressorInputStream:<init>(Ljava/io/InputStream;Ljava/io/File;Lorg/apache/commons/compress/compressors/pack200/Pack200Strategy;Ljava/util/Map;)V",
                                    "method_body": "private Pack200CompressorInputStream(final InputStream in, final File f,\nthrows IOException {\noriginalInput = in;\nstreamBridge = mode.newStreamBridge();\nJarOutputStream jarOut = new JarOutputStream(streamBridge);\nPack200.Unpacker u = Pack200.newUnpacker();\nif (props != null) {\nif (f == null) {\nu.unpack(new FilterInputStream(in) {\n}\njarOut.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.pack200.Pack200CompressorInputStream:<clinit>()V",
                                    "method_body": "private static final int SIG_LENGTH = CAFE_DOOD.length;\nif (length < SIG_LENGTH) {\nfor (int i = 0; i < SIG_LENGTH; i++) {\nif (signature[i] != CAFE_DOOD[i]) {\nreturn false;\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.pack200.Pack200CompressorInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < SIG_LENGTH) {\nfor (int i = 0; i < SIG_LENGTH; i++) {\nif (signature[i] != CAFE_DOOD[i]) {\nreturn false;\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.pack200.Pack200Strategy$1:newStreamBridge()Lorg/apache/commons/compress/compressors/pack200/StreamBridge;",
                                    "method_body": "StreamBridge newStreamBridge() {\nreturn new InMemoryCachingStreamBridge();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.pack200.StreamBridge:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "protected StreamBridge(OutputStream out) {\nsuper(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.pack200.InMemoryCachingStreamBridge:<init>()V",
                                    "method_body": "InMemoryCachingStreamBridge() {\nsuper(new ByteArrayOutputStream());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.pack200.Pack200CompressorInputStream$1:close()V",
                                    "method_body": "public void close() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.z.ZCompressorInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nreturn length > 3 && signature[0] == MAGIC_1 && signature[1] == (byte) MAGIC_2;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.CompressorException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public CompressorException(String message) {\nsuper(message);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 34,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.X7875_NewUnixTest.testParseReparse",
                            "test_body": "139: public void testParseReparse() throws ZipException {\n140: 141: // Version=1, Len=0, Len=0.\n142: final byte[] ZERO_LEN = {1, 0, 0};\n143: 144: // Version=1, Len=1, zero, Len=1, zero.\n145: final byte[] ZERO_UID_GID = {1, 1, 0, 1, 0};\n146: 147: // Version=1, Len=1, one, Len=1, one\n148: final byte[] ONE_UID_GID = {1, 1, 1, 1, 1};\n149: 150: // Version=1, Len=2, one thousand, Len=2, one thousand\n151: final byte[] ONE_THOUSAND_UID_GID = {1, 2, -24, 3, 2, -24, 3};\n152: 153: // (2^32 - 2).   I guess they avoid (2^32 - 1) since it's identical to -1 in\n154: // two's complement, and -1 often has a special meaning.\n155: final byte[] UNIX_MAX_UID_GID = {1, 4, -2, -1, -1, -1, 4, -2, -1, -1, -1};\n156: 157: // Version=1, Len=5, 2^32, Len=5, 2^32 + 1\n158: // Esoteric test:  can we handle 40 bit numbers?\n159: final byte[] LENGTH_5 = {1, 5, 0, 0, 0, 0, 1, 5, 1, 0, 0, 0, 1};\n160: 161: // Version=1, Len=8, 2^63 - 2, Len=8, 2^63 - 1\n162: // Esoteric test:  can we handle 64 bit numbers?\n163: final byte[] LENGTH_8 = {1, 8, -2, -1, -1, -1, -1, -1, -1, 127, 8, -1, -1, -1, -1, -1, -1, -1, 127};\n164: 165: final long TWO_TO_32 = 0x100000000L;\n166: final long MAX = TWO_TO_32 - 2;\n167: 168: parseReparse(0, 0, ZERO_LEN, 0, 0);\n169: parseReparse(0, 0, ZERO_UID_GID, 0, 0);\n170: parseReparse(1, 1, ONE_UID_GID, 1, 1);\n171: parseReparse(1000, 1000, ONE_THOUSAND_UID_GID, 1000, 1000);\n172: parseReparse(MAX, MAX, UNIX_MAX_UID_GID, MAX, MAX);\n173: parseReparse(-2, -2, UNIX_MAX_UID_GID, MAX, MAX);\n174: parseReparse(TWO_TO_32, TWO_TO_32 + 1, LENGTH_5, TWO_TO_32, TWO_TO_32 + 1);\n175: parseReparse(Long.MAX_VALUE - 1, Long.MAX_VALUE, LENGTH_8, Long.MAX_VALUE - 1, Long.MAX_VALUE);\n176: 177: // We never emit this, but we should be able to parse it:\n178: final byte[] SPURIOUS_ZEROES_1 = {1, 4, -1, 0, 0, 0, 4, -128, 0, 0, 0};\n179: final byte[] EXPECTED_1 = {1, 1, -1, 1, -128};\n180: xf.parseFromLocalFileData(SPURIOUS_ZEROES_1, 0, SPURIOUS_ZEROES_1.length);\n181: 182: assertEquals(255, xf.getUID());\n183: assertEquals(128, xf.getGID());\n184: assertTrue(Arrays.equals(EXPECTED_1, xf.getLocalFileDataData()));\n185: 186: final byte[] SPURIOUS_ZEROES_2 = {1, 4, -1, -1, 0, 0, 4, 1, 2, 0, 0};\n187: final byte[] EXPECTED_2 = {1, 2, -1, -1, 2, 1, 2};\n188: xf.parseFromLocalFileData(SPURIOUS_ZEROES_2, 0, SPURIOUS_ZEROES_2.length);\n189: 190: assertEquals(65535, xf.getUID());\n191: assertEquals(513, xf.getGID());\n192: assertTrue(Arrays.equals(EXPECTED_2, xf.getLocalFileDataData()));\n193: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nputLong(value, result, 0);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:putLong(J[BI)V",
                                    "method_body": "public static void putLong(long value, byte[] buf, int offset) {\nbuf[offset++] = (byte) ((value & BYTE_MASK));\nbuf[offset++] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nbuf[offset++] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nbuf[offset] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:reverse([B)[B",
                                    "method_body": "public static byte[] reverse(final byte[] array) {\nfinal int z = array.length - 1; // position of last element\nfor (int i = 0; i < array.length / 2; i++) {\nreturn array;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:bigToLong(Ljava/math/BigInteger;)J",
                                    "method_body": "static long bigToLong(BigInteger big) {\nif (big.bitLength() <= 63) { // bitLength() doesn't count the sign bit.\nreturn big.longValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:longToBig(J)Ljava/math/BigInteger;",
                                    "method_body": "static BigInteger longToBig(long l) {\nif (l < Integer.MIN_VALUE) {\n} else if (l < 0 && l >= Integer.MIN_VALUE) {\nreturn BigInteger.valueOf(l);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:signedByteToUnsignedInt(B)I",
                                    "method_body": "public static int signedByteToUnsignedInt(byte b) {\nif (b >= 0) {\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:unsignedIntToSignedByte(I)B",
                                    "method_body": "public static byte unsignedIntToSignedByte(int i) {\nif (i > 255 || i < 0) {\nif (i < 128) {\nreturn (byte) i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<init>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x7875);\nprivate static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);\nprivate int version = 1; // always '1' according to current info-zip spec.\npublic X7875_NewUnix() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x7875);\nprivate static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);\nprivate int version = 1; // always '1' according to current info-zip spec.\npublic X7875_NewUnix() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getUID()J",
                                    "method_body": "public long getUID() { return ZipUtil.bigToLong(uid); }\npublic long getUID() { return ZipUtil.bigToLong(uid); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getGID()J",
                                    "method_body": "public long getGID() { return ZipUtil.bigToLong(gid); }\npublic long getGID() { return ZipUtil.bigToLong(gid); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:setUID(J)V",
                                    "method_body": "public void setUID(long l) {\nthis.uid = ZipUtil.longToBig(l);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:setGID(J)V",
                                    "method_body": "public void setGID(long l) {\nthis.gid = ZipUtil.longToBig(l);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nint uidSize = trimLeadingZeroesForceMinLength(uid.toByteArray()).length;\nint gidSize = trimLeadingZeroesForceMinLength(gid.toByteArray()).length;\nreturn new ZipShort(3 + uidSize + gidSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getCentralDirectoryLength() {\nreturn getLocalFileDataLength();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nbyte[] uidBytes = uid.toByteArray();\nbyte[] gidBytes = gid.toByteArray();\nuidBytes = trimLeadingZeroesForceMinLength(uidBytes);\ngidBytes = trimLeadingZeroesForceMinLength(gidBytes);\nbyte[] data = new byte[3 + uidBytes.length + gidBytes.length];\nreverse(uidBytes);\nreverse(gidBytes);\nint pos = 0;\ndata[pos++] = unsignedIntToSignedByte(version);\ndata[pos++] = unsignedIntToSignedByte(uidBytes.length);\nSystem.arraycopy(uidBytes, 0, data, pos, uidBytes.length);\npos += uidBytes.length;\ndata[pos++] = unsignedIntToSignedByte(gidBytes.length);\nSystem.arraycopy(gidBytes, 0, data, pos, gidBytes.length);\nreturn data;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:parseFromLocalFileData([BII)V",
                                    "method_body": "public void parseFromLocalFileData(\nreset();\nthis.version = signedByteToUnsignedInt(data[offset++]);\nint uidSize = signedByteToUnsignedInt(data[offset++]);\nbyte[] uidBytes = new byte[uidSize];\nSystem.arraycopy(data, offset, uidBytes, 0, uidSize);\noffset += uidSize;\nthis.uid = new BigInteger(1, reverse(uidBytes)); // sign-bit forced positive\nint gidSize = signedByteToUnsignedInt(data[offset++]);\nbyte[] gidBytes = new byte[gidSize];\nSystem.arraycopy(data, offset, gidBytes, 0, gidSize);\nthis.gid = new BigInteger(1, reverse(gidBytes)); // sign-bit forced positive\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:reset()V",
                                    "method_body": "private void reset() {\nuid = ONE_THOUSAND;\ngid = ONE_THOUSAND;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:trimLeadingZeroesForceMinLength([B)[B",
                                    "method_body": "static byte[] trimLeadingZeroesForceMinLength(byte[] array) {\nif (array == null) {\nint pos = 0;\nfor (byte b : array) {\nif (b == 0) {\npos++;\nfinal int MIN_LENGTH = 1;\nbyte[] trimmedArray = new byte[Math.max(MIN_LENGTH, array.length - pos)];\nint startPos = trimmedArray.length - (array.length - pos);\nSystem.arraycopy(array, pos, trimmedArray, startPos, trimmedArray.length - startPos);\nreturn trimmedArray;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 35,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.DetectArchiverTestCase.testCOMPRESS335",
                            "test_body": "59: public void testCOMPRESS335() throws Exception {\n60: final ArchiveInputStream tar = getStreamFor(\"COMPRESS-335.tar\");\n61: assertNotNull(tar);\n62: assertTrue(tar instanceof TarArchiveInputStream);\n63: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>()V",
                                    "method_body": "public ArchiveStreamFactory() {\nthis(null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>(Ljava/lang/String;)V",
                                    "method_body": "public static final String SEVEN_Z = \"7z\";\nprivate volatile String entryEncoding = null;\nthis(null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveInputStream(Ljava/io/InputStream;)Lorg/apache/commons/compress/archivers/ArchiveInputStream;",
                                    "method_body": "public ArchiveInputStream createArchiveInputStream(final InputStream in)\nif (in == null) {\nif (!in.markSupported()) {\nfinal byte[] signature = new byte[12];\nin.mark(signature.length);\nint signatureLength = IOUtils.readFully(in, signature);\nin.reset();\nif (ZipArchiveInputStream.matches(signature, signatureLength)) {\n} else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n} else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n} else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n} else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n} else if (SevenZFile.matches(signature, signatureLength)) {\nfinal byte[] dumpsig = new byte[32];\nin.mark(dumpsig.length);\nsignatureLength = IOUtils.readFully(in, dumpsig);\nin.reset();\nif (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\nfinal byte[] tarheader = new byte[512];\nin.mark(tarheader.length);\nsignatureLength = IOUtils.readFully(in, tarheader);\nin.reset();\nif (TarArchiveInputStream.matches(tarheader, signatureLength)) {\nif (signatureLength >= 512) {\nTarArchiveInputStream tais = null;\ntais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\nif (tais.getNextTarEntry().isCheckSumOK()) {\nIOUtils.closeQuietly(tais);\n}\n}\nthrow new ArchiveException(\"No Archiver found for the stream signature\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\nMap<String, SimpleEncodingHolder> se =\nchar[] cp437_high_chars =\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\nchar[] cp850_high_chars =\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\ncharsetName = Charset.defaultCharset().name();\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data,this.charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:matchAsciiBuffer(Ljava/lang/String;[BII)Z",
                                    "method_body": "public static boolean matchAsciiBuffer(\nbuffer1 = expected.getBytes(CharsetNames.US_ASCII);\n}\nreturn isEqual(buffer1, 0, buffer1.length, buffer, offset, length, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isEqual([BII[BIIZ)Z",
                                    "method_body": "public static boolean isEqual(\nint minLen=length1 < length2 ? length1 : length2;\nfor (int i=0; i < minLen; i++){\nif (buffer1[offset1+i] != buffer2[offset2+i]){\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isArrayZero([BI)Z",
                                    "method_body": "public static boolean isArrayZero(byte[] a, int size) {\nfor (int i = 0; i < size; i++) {\nif (a[i] != 0) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[B)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b) throws IOException {\nreturn readFully(input, b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b, int offset, int len)\nif (len < 0 || offset < 0 || len + offset > b.length) {\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\ncount += x;\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:closeQuietly(Ljava/io/Closeable;)V",
                                    "method_body": "public static void closeQuietly(Closeable c) {\nif (c != null) {\nc.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < 6) {\nif (signature[0] == 0x71 && (signature[1] & 0xFF) == 0xc7) {\nif (signature[1] == 0x71 && (signature[0] & 0xFF) == 0xc7) {\nif (signature[0] != 0x30) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<clinit>()V",
                                    "method_body": "static final int SIGNATURE_HEADER_SIZE = 32;\nstatic final byte[] sevenZSignature = {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < sevenZSignature.length) {\nfor (int i = 0; i < sevenZSignature.length; i++) {\nif (signature[i] != sevenZSignature[i]) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<clinit>()V",
                                    "method_body": "private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\nprivate static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\nprivate static final byte[] DD = ZipLong.DD_SIG.getBytes();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < ZipArchiveOutputStream.LFH_SIG.length) {\nreturn checksig(signature, ZipArchiveOutputStream.LFH_SIG) // normal file\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:checksig([B[B)Z",
                                    "method_body": "private static boolean checksig(byte[] signature, byte[] expected) {\nfor (int i = 0; i < expected.length; i++) {\nif (signature[i] != expected[i]) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nputLong(value, result, 0);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:putLong(J[BI)V",
                                    "method_body": "public static void putLong(long value, byte[] buf, int offset) {\nbuf[offset++] = (byte) ((value & BYTE_MASK));\nbuf[offset++] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nbuf[offset++] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nbuf[offset] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes();\nstatic final byte[] DD_SIG = ZipLong.DD_SIG.getBytes();\nstatic final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes();\nstatic final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\nstatic final byte[] ZIP64_EOCD_SIG = ZipLong.getBytes(0X06064B50L);\nstatic final byte[] ZIP64_EOCD_LOC_SIG = ZipLong.getBytes(0X07064B50L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length ) {\nreturn ZipArchiveInputStream.matches(signature, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:<clinit>()V",
                                    "method_body": "static final String BSD_LONGNAME_PREFIX = \"#1/\";\nprivate static final int BSD_LONGNAME_PREFIX_LEN =\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < 8) {\nif (signature[0] != 0x21) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(final byte[] signature, final int length) {\nreturn length >= 2 &&\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] buffer, int length) {\nif (length < 32) {\nif (length >= DumpArchiveConstants.TP_SIZE) {\nreturn DumpArchiveConstants.NFS_MAGIC == DumpArchiveUtil.convert32(buffer,\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert32([BI)I",
                                    "method_body": "public static final int convert32(byte[] buffer, int offset) {\nint i = 0;\ni = buffer[offset + 3] << 24;\ni += (buffer[offset + 2] << 16) & 0x00FF0000;\ni += (buffer[offset + 1] << 8) & 0x0000FF00;\ni += buffer[offset] & 0x000000FF;\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ArchiveException(String message) {\nsuper(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry() {\nString user = System.getProperty(\"user.name\", \"\");\nif (user.length() > MAX_NAMELEN) {\nthis.userName = user;\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/io/File;Ljava/lang/String;)V",
                                    "method_body": "private String name = \"\";\nprivate long userId = 0;\nprivate long groupId = 0;\nprivate long size = 0;\nprivate String linkName = \"\";\nprivate String magic = MAGIC_POSIX;\nprivate String version = VERSION_POSIX;\nprivate String groupName = \"\";\nprivate int devMajor = 0;\nprivate int devMinor = 0;\nprivate TarArchiveEntry() {\nString user = System.getProperty(\"user.name\", \"\");\nif (user.length() > MAX_NAMELEN) {\nthis.userName = user;\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public TarArchiveEntry(byte[] headerBuf, ZipEncoding encoding)\nthis();\nparseTarHeader(headerBuf, encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isCheckSumOK()Z",
                                    "method_body": "public boolean isCheckSumOK() {\nreturn checkSumOK;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNUSparse()Z",
                                    "method_body": "public boolean isGNUSparse() {\nreturn linkFlag == LF_GNUTYPE_SPARSE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongLinkEntry()Z",
                                    "method_body": "public boolean isGNULongLinkEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGLINK;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongNameEntry()Z",
                                    "method_body": "public boolean isGNULongNameEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGNAME;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isPaxHeader()Z",
                                    "method_body": "public boolean isPaxHeader(){\nreturn linkFlag == LF_PAX_EXTENDED_HEADER_LC\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nif (file != null) {\nif (linkFlag == LF_DIR) {\nif (getName().endsWith(\"/\")) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public void parseTarHeader(byte[] header, ZipEncoding encoding)\nparseTarHeader(header, encoding, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;Z)V",
                                    "method_body": "private void parseTarHeader(byte[] header, ZipEncoding encoding,\nint offset = 0;\nname = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\noffset += NAMELEN;\nmode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN);\noffset += MODELEN;\nuserId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\noffset += UIDLEN;\ngroupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\noffset += GIDLEN;\nsize = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\noffset += SIZELEN;\nmodTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN);\noffset += MODTIMELEN;\ncheckSumOK = TarUtils.verifyCheckSum(header);\noffset += CHKSUMLEN;\nlinkFlag = header[offset++];\nlinkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\noffset += NAMELEN;\nmagic = TarUtils.parseName(header, offset, MAGICLEN);\noffset += MAGICLEN;\nversion = TarUtils.parseName(header, offset, VERSIONLEN);\noffset += VERSIONLEN;\nuserName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)\noffset += UNAMELEN;\ngroupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN)\noffset += GNAMELEN;\ndevMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\ndevMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\nint type = evaluateType(header);\nswitch (type) {\nString prefix = oldStyle\nif (isDirectory() && !name.endsWith(\"/\")){\nif (prefix.length() > 0){\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:evaluateType([B)I",
                                    "method_body": "private int evaluateType(byte[] header) {\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_GNU, header, MAGIC_OFFSET, MAGICLEN)) {\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_POSIX, header, MAGIC_OFFSET, MAGICLEN)) {\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:<clinit>()V",
                                    "method_body": "private static final int BYTE_MASK = 255;\nstatic final ZipEncoding DEFAULT_ENCODING =\nstatic final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\nif (length < 2){\nif (buffer[start] == 0) {\nreturn 0L;\nwhile (start < end){\nif (buffer[start] == ' '){\nbyte trailer = buffer[end - 1];\nwhile (start < end && (trailer == 0 || trailer == ' ')) {\nend--;\ntrailer = buffer[end - 1];\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\nif (currentByte < '0' || currentByte > '7'){\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctalOrBinary([BII)J",
                                    "method_body": "public static long parseOctalOrBinary(final byte[] buffer, final int offset,\nif ((buffer[offset] & 0x80) == 0) {\nreturn parseOctal(buffer, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BII)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset, final int length) {\nreturn parseName(buffer, offset, length, DEFAULT_ENCODING);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BIILorg/apache/commons/compress/archivers/zip/ZipEncoding;)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset,\nint len = length;\nfor (; len > 0; len--) {\nif (buffer[offset + len - 1] != 0) {\nbreak;\nif (len > 0) {\nbyte[] b = new byte[len];\nSystem.arraycopy(buffer, offset, b, 0, len);\nreturn encoding.decode(b);\nreturn \"\";\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:verifyCheckSum([B)Z",
                                    "method_body": "public static boolean verifyCheckSum(byte[] header) {\nlong storedSum = 0;\nlong unsignedSum = 0;\nlong signedSum = 0;\nint digits = 0;\nfor (int i = 0; i < header.length; i++) {\nbyte b = header[i];\nif (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\nif ('0' <= b && b <= '7' && digits++ < 6) {\nstoredSum = storedSum * 8 + b - '0';\n} else if (digits > 0) {\ndigits = 6;\nb = ' ';\nunsignedSum += 0xff & b;\nsignedSum += b;\nreturn storedSum == unsignedSum || storedSum == signedSum;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is) {\nthis(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\nthis(is, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;IILjava/lang/String;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize,\nString encoding) {\nthis.is = is;\nthis.hasHitEOF = false;\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.recordSize = recordSize;\nthis.blockSize = blockSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nis.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextTarEntry()Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;",
                                    "method_body": "public TarArchiveEntry getNextTarEntry() throws IOException {\nif (hasHitEOF) {\nif (currEntry != null) {\nbyte[] headerBuf = getRecord();\nif (headerBuf == null) {\ncurrEntry = new TarArchiveEntry(headerBuf, zipEncoding);\n}\nentryOffset = 0;\nentrySize = currEntry.getSize();\nif (currEntry.isGNULongLinkEntry()) {\nif (currEntry.isGNULongNameEntry()) {\nif (currEntry.isPaxHeader()){ // Process Pax headers\nif (currEntry.isGNUSparse()){ // Process sparse files\nentrySize = currEntry.getSize();\nreturn currEntry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getRecord()[B",
                                    "method_body": "private byte[] getRecord() throws IOException {\nbyte[] headerBuf = readRecord();\nhasHitEOF = isEOFRecord(headerBuf);\nif (hasHitEOF && headerBuf != null) {\nreturn headerBuf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:isEOFRecord([B)Z",
                                    "method_body": "protected boolean isEOFRecord(byte[] record) {\nreturn record == null || ArchiveUtils.isArrayZero(record, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:readRecord()[B",
                                    "method_body": "protected byte[] readRecord() throws IOException {\nbyte[] record = new byte[recordSize];\nint readNow = IOUtils.readFully(is, record);\ncount(readNow);\nif (readNow != recordSize) {\nreturn record;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < TarConstants.VERSION_OFFSET+TarConstants.VERSIONLEN) {\nif (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_POSIX,\nif (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_GNU,\nif (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_ANT,\nreturn false;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 36,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.sevenz.SevenZFileTest.readEntriesOfSize0",
                            "test_body": "267: public void readEntriesOfSize0() throws IOException {\n268: final SevenZFile sevenZFile = new SevenZFile(getFile(\"COMPRESS-348.7z\"));\n269: try {\n270: int entries = 0;\n271: SevenZArchiveEntry entry = sevenZFile.getNextEntry();\n272: while (entry != null) {\n273: entries++;\n274: int b = sevenZFile.read();\n275: if (\"2.txt\".equals(entry.getName()) || \"5.txt\".equals(entry.getName())) {\n276: assertEquals(-1, b);\n277: } else {\n278: assertNotEquals(-1, b);\n279: }\n280: entry = sevenZFile.getNextEntry();\n281: }\n282: assertEquals(5, entries);\n283: } finally {\n284: sevenZFile.close();\n285: }\n286: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>()V",
                                    "method_body": "public ArchiveStreamFactory() {\nthis(null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ArchiveStreamFactory(final String encoding) {\nsuper();\nthis.encoding = encoding;\nthis.entryEncoding = encoding;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:skip(Ljava/io/InputStream;J)J",
                                    "method_body": "public static long skip(final InputStream input, long numToSkip) throws IOException {\nfinal long available = numToSkip;\nwhile (numToSkip > 0) {\nfinal long skipped = input.skip(numToSkip);\nif (skipped == 0) {\nbreak;\nnumToSkip -= skipped;\n}\nwhile (numToSkip > 0) {\nfinal int read = readFully(input, SKIP_BUF, 0,\nif (read < 1) {\nbreak;\nreturn available - numToSkip;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(final InputStream input, final byte[] b, final int offset, final int len)\nif (len < 0 || offset < 0 || len + offset > b.length) {\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\nbreak;\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:<init>()V",
                                    "method_body": "public SevenZArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "public void setName(final String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:hasStream()Z",
                                    "method_body": "public boolean hasStream() {\nreturn hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasStream(Z)V",
                                    "method_body": "public void setHasStream(final boolean hasStream) {\nthis.hasStream = hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setDirectory(Z)V",
                                    "method_body": "public void setDirectory(final boolean isDirectory) {\nthis.isDirectory = isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setAntiItem(Z)V",
                                    "method_body": "public void setAntiItem(final boolean isAntiItem) {\nthis.isAntiItem = isAntiItem;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasLastModifiedDate()Z",
                                    "method_body": "public boolean getHasLastModifiedDate() {\nreturn hasLastModifiedDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasLastModifiedDate(Z)V",
                                    "method_body": "public void setHasLastModifiedDate(final boolean hasLastModifiedDate) {\nthis.hasLastModifiedDate = hasLastModifiedDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setLastModifiedDate(J)V",
                                    "method_body": "public void setLastModifiedDate(final long ntfsLastModifiedDate) {\nthis.lastModifiedDate = ntfsLastModifiedDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasWindowsAttributes()Z",
                                    "method_body": "public boolean getHasWindowsAttributes() {\nreturn hasWindowsAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasWindowsAttributes(Z)V",
                                    "method_body": "public void setHasWindowsAttributes(final boolean hasWindowsAttributes) {\nthis.hasWindowsAttributes = hasWindowsAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setWindowsAttributes(I)V",
                                    "method_body": "public void setWindowsAttributes(final int windowsAttributes) {\nthis.windowsAttributes = windowsAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasCrc()Z",
                                    "method_body": "public boolean getHasCrc() {\nreturn hasCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasCrc(Z)V",
                                    "method_body": "public void setHasCrc(final boolean hasCrc) {\nthis.hasCrc = hasCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getCrcValue()J",
                                    "method_body": "public long getCrcValue() {\nreturn crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCrcValue(J)V",
                                    "method_body": "public void setCrcValue(final long crc) {\nthis.crc = crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(final long size) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setContentMethods(Ljava/lang/Iterable;)V",
                                    "method_body": "public void setContentMethods(final Iterable<? extends SevenZMethodConfiguration> methods) {\nif (methods != null) {\nfinal LinkedList<SevenZMethodConfiguration> l = new LinkedList<SevenZMethodConfiguration>();\nfor (final SevenZMethodConfiguration m : methods) {\nl.addLast(m);\n}\ncontentMethods = Collections.unmodifiableList(l);\n} else {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getContentMethods()Ljava/lang/Iterable;",
                                    "method_body": "public Iterable<? extends SevenZMethodConfiguration> getContentMethods() {\nreturn contentMethods;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethodConfiguration:<init>(Lorg/apache/commons/compress/archivers/sevenz/SevenZMethod;Ljava/lang/Object;)V",
                                    "method_body": "public SevenZMethodConfiguration(final SevenZMethod method, final Object options) {\nthis.method = method;\nthis.options = options;\nif (options != null && !Coders.findByMethod(method).canAcceptOptions(options)) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:<init>(Ljava/lang/String;I[B)V",
                                    "method_body": "private SevenZMethod(final byte[] id) {\nthis.id = id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:byId([B)Lorg/apache/commons/compress/archivers/sevenz/SevenZMethod;",
                                    "method_body": "static SevenZMethod byId(final byte[] id) {\nfor (final SevenZMethod m : SevenZMethod.class.getEnumConstants()) {\nif (Arrays.equals(m.id, id)) {\nreturn m;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders:<clinit>()V",
                                    "method_body": "private static final Map<SevenZMethod, CoderBase> CODER_MAP = new HashMap<SevenZMethod, CoderBase>() {\n}};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders:findByMethod(Lorg/apache/commons/compress/archivers/sevenz/SevenZMethod;)Lorg/apache/commons/compress/archivers/sevenz/CoderBase;",
                                    "method_body": "static CoderBase findByMethod(final SevenZMethod method) {\nreturn CODER_MAP.get(method);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders:addDecoder(Ljava/lang/String;Ljava/io/InputStream;JLorg/apache/commons/compress/archivers/sevenz/Coder;[B)Ljava/io/InputStream;",
                                    "method_body": "static InputStream addDecoder(final String archiveName, final InputStream is, final long uncompressedLength,\nfinal CoderBase cb = findByMethod(SevenZMethod.byId(coder.decompressionMethodId));\nif (cb == null) {\nreturn cb.decode(archiveName, is, uncompressedLength, coder, password);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.CoderBase:<init>([Ljava/lang/Class;)V",
                                    "method_body": "protected CoderBase(final Class<?>... acceptableOptions) {\nthis.acceptableOptions = acceptableOptions;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.CoderBase:<clinit>()V",
                                    "method_body": "private final Class<?>[] acceptableOptions;\nprivate static final byte[] NONE = new byte[0];\nprotected CoderBase(final Class<?>... acceptableOptions) {\nthis.acceptableOptions = acceptableOptions;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.CoderBase:getOptionsFromCoder(Lorg/apache/commons/compress/archivers/sevenz/Coder;Ljava/io/InputStream;)Ljava/lang/Object;",
                                    "method_body": "Object getOptionsFromCoder(final Coder coder, final InputStream in) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$LZMADecoder:decode(Ljava/lang/String;Ljava/io/InputStream;JLorg/apache/commons/compress/archivers/sevenz/Coder;[B)Ljava/io/InputStream;",
                                    "method_body": "InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength,\nfinal byte propsByte = coder.properties[0];\nlong dictSize = coder.properties[1];\nfor (int i = 1; i < 4; i++) {\ndictSize |= (coder.properties[i + 1] & 0xffl) << (8 * i);\nif (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\nreturn new LZMAInputStream(in, uncompressedLength, propsByte, (int) dictSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.LZMA2Decoder:<init>()V",
                                    "method_body": "LZMA2Decoder() {\nsuper(LZMA2Options.class, Number.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$DeflateDecoder:<init>()V",
                                    "method_body": "DeflateDecoder() {\nsuper(Number.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$BZIP2Decoder:<init>()V",
                                    "method_body": "BZIP2Decoder() {\nsuper(Number.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$BCJDecoder:<init>(Lorg/tukaani/xz/FilterOptions;)V",
                                    "method_body": "BCJDecoder(final FilterOptions opts) {\nthis.opts = opts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.DeltaDecoder:<init>()V",
                                    "method_body": "DeltaDecoder() {\nsuper(Number.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;[B)V",
                                    "method_body": "public SevenZFile(final File filename, final byte[] password) throws IOException {\nboolean succeeded = false;\nthis.file = new RandomAccessFile(filename, \"r\");\nthis.fileName = filename.getAbsolutePath();\narchive = readHeaders(password);\nif (password != null) {\nthis.password = null;\nsucceeded = true;\nif (!succeeded) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZFile(final File filename) throws IOException {\nthis(filename, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<clinit>()V",
                                    "method_body": "static final int SIGNATURE_HEADER_SIZE = 32;\nprivate int currentEntryIndex = -1;\nprivate int currentFolderIndex = -1;\nprivate InputStream currentFolderInputStream = null;\nprivate final ArrayList<InputStream> deferredBlockStreams = new ArrayList<InputStream>();\nstatic final byte[] sevenZSignature = {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:close()V",
                                    "method_body": "public void close() throws IOException {\nif (file != null) {\nfile.close();\nfile = null;\nif (password != null) {\npassword = null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:getNextEntry()Lorg/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry;",
                                    "method_body": "public SevenZArchiveEntry getNextEntry() throws IOException {\nif (currentEntryIndex >= archive.files.length - 1) {\n++currentEntryIndex;\nfinal SevenZArchiveEntry entry = archive.files[currentEntryIndex];\nbuildDecodingStream();\nreturn entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeaders([B)Lorg/apache/commons/compress/archivers/sevenz/Archive;",
                                    "method_body": "private Archive readHeaders(final byte[] password) throws IOException {\nfinal byte[] signature = new byte[6];\nfile.readFully(signature);\nif (!Arrays.equals(signature, sevenZSignature)) {\nfinal byte archiveVersionMajor = file.readByte();\nfinal byte archiveVersionMinor = file.readByte();\nif (archiveVersionMajor != 0) {\nfinal long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\nfinal StartHeader startHeader = readStartHeader(startHeaderCrc);\nfinal int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\nif (nextHeaderSizeInt != startHeader.nextHeaderSize) {\nfile.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\nfinal byte[] nextHeader = new byte[nextHeaderSizeInt];\nfile.readFully(nextHeader);\nfinal CRC32 crc = new CRC32();\ncrc.update(nextHeader);\nif (startHeader.nextHeaderCrc != crc.getValue()) {\nfinal ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\nDataInputStream nextHeaderInputStream = new DataInputStream(\nArchive archive = new Archive();\nint nid = nextHeaderInputStream.readUnsignedByte();\nif (nid == NID.kEncodedHeader) {\nnextHeaderInputStream =\narchive = new Archive();\nnid = nextHeaderInputStream.readUnsignedByte();\nif (nid == NID.kHeader) {\nreadHeader(nextHeaderInputStream, archive);\nnextHeaderInputStream.close();\nreturn archive;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStartHeader(J)Lorg/apache/commons/compress/archivers/sevenz/StartHeader;",
                                    "method_body": "private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\nfinal StartHeader startHeader = new StartHeader();\nDataInputStream dataInputStream = null;\ndataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\nstartHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\nreturn startHeader;\nif (dataInputStream != null) {\ndataInputStream.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeader(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readHeader(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\nif (nid == NID.kArchiveProperties) {\nif (nid == NID.kAdditionalStreamsInfo) {\nif (nid == NID.kMainStreamsInfo) {\nreadStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid == NID.kFilesInfo) {\nreadFilesInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid != NID.kEnd) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readEncodedHeader(Ljava/io/DataInputStream;Lorg/apache/commons/compress/archivers/sevenz/Archive;[B)Ljava/io/DataInputStream;",
                                    "method_body": "private DataInputStream readEncodedHeader(final DataInputStream header, final Archive archive,\nreadStreamsInfo(header, archive);\nfinal Folder folder = archive.folders[0];\nfinal int firstPackStreamIndex = 0;\nfinal long folderOffset = SIGNATURE_HEADER_SIZE + archive.packPos +\nfile.seek(folderOffset);\nInputStream inputStreamStack = new BoundedRandomAccessFileInputStream(file,\nfor (final Coder coder : folder.getOrderedCoders()) {\nif (coder.numInStreams != 1 || coder.numOutStreams != 1) {\ninputStreamStack = Coders.addDecoder(fileName, inputStreamStack,\n}\nif (folder.hasCrc) {\ninputStreamStack = new CRC32VerifyingInputStream(inputStreamStack,\nfinal byte[] nextHeader = new byte[(int)folder.getUnpackSize()];\nfinal DataInputStream nextHeaderInputStream = new DataInputStream(inputStreamStack);\nnextHeaderInputStream.readFully(nextHeader);\nnextHeaderInputStream.close();\n}\nreturn new DataInputStream(new ByteArrayInputStream(nextHeader));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\nif (nid == NID.kPackInfo) {\nreadPackInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid == NID.kUnpackInfo) {\nreadUnpackInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid == NID.kSubStreamsInfo) {\nreadSubStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\nif (nid != NID.kEnd) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readPackInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readPackInfo(final DataInput header, final Archive archive) throws IOException {\narchive.packPos = readUint64(header);\nfinal long numPackStreams = readUint64(header);\nint nid = header.readUnsignedByte();\nif (nid == NID.kSize) {\narchive.packSizes = new long[(int)numPackStreams];\nfor (int i = 0; i < archive.packSizes.length; i++) {\narchive.packSizes[i] = readUint64(header);\nnid = header.readUnsignedByte();\nif (nid == NID.kCRC) {\nif (nid != NID.kEnd) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUnpackInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readUnpackInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\nif (nid != NID.kFolder) {\nfinal long numFolders = readUint64(header);\nfinal Folder[] folders = new Folder[(int)numFolders];\narchive.folders = folders;\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nfor (int i = 0; i < (int)numFolders; i++) {\nfolders[i] = readFolder(header);\nnid = header.readUnsignedByte();\nif (nid != NID.kCodersUnpackSize) {\nfor (final Folder folder : folders) {\nfolder.unpackSizes = new long[(int)folder.totalOutputStreams];\nfor (int i = 0; i < folder.totalOutputStreams; i++) {\nfolder.unpackSizes[i] = readUint64(header);\nnid = header.readUnsignedByte();\nif (nid == NID.kCRC) {\nfinal BitSet crcsDefined = readAllOrBits(header, (int)numFolders);\nfor (int i = 0; i < (int)numFolders; i++) {\nif (crcsDefined.get(i)) {\nfolders[i].hasCrc = true;\nfolders[i].crc = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\nnid = header.readUnsignedByte();\nif (nid != NID.kEnd) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readSubStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nfor (final Folder folder : archive.folders) {\nfolder.numUnpackSubStreams = 1;\nint totalUnpackStreams = archive.folders.length;\nint nid = header.readUnsignedByte();\nif (nid == NID.kNumUnpackStream) {\ntotalUnpackStreams = 0;\nfor (final Folder folder : archive.folders) {\nfinal long numStreams = readUint64(header);\nfolder.numUnpackSubStreams = (int)numStreams;\ntotalUnpackStreams += numStreams;\nnid = header.readUnsignedByte();\nfinal SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\nsubStreamsInfo.unpackSizes = new long[totalUnpackStreams];\nsubStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\nsubStreamsInfo.crcs = new long[totalUnpackStreams];\nint nextUnpackStream = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams == 0) {\nlong sum = 0;\nif (nid == NID.kSize) {\nfor (int i = 0; i < folder.numUnpackSubStreams - 1; i++) {\nfinal long size = readUint64(header);\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = size;\nsum += size;\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;\nif (nid == NID.kSize) {\nnid = header.readUnsignedByte();\nint numDigests = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {\nnumDigests += folder.numUnpackSubStreams;\nif (nid == NID.kCRC) {\nfinal BitSet hasMissingCrc = readAllOrBits(header, numDigests);\nfinal long[] missingCrcs = new long[numDigests];\nfor (int i = 0; i < numDigests; i++) {\nif (hasMissingCrc.get(i)) {\nmissingCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\nint nextCrc = 0;\nint nextMissingCrc = 0;\nfor (final Folder folder: archive.folders) {\nif (folder.numUnpackSubStreams == 1 && folder.hasCrc) {\nfor (int i = 0; i < folder.numUnpackSubStreams; i++) {\nsubStreamsInfo.hasCrc.set(nextCrc, hasMissingCrc.get(nextMissingCrc));\nsubStreamsInfo.crcs[nextCrc] = missingCrcs[nextMissingCrc];\n++nextCrc;\n++nextMissingCrc;\nnid = header.readUnsignedByte();\nif (nid != NID.kEnd) {\narchive.subStreamsInfo = subStreamsInfo;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFolder(Ljava/io/DataInput;)Lorg/apache/commons/compress/archivers/sevenz/Folder;",
                                    "method_body": "private Folder readFolder(final DataInput header) throws IOException {\nfinal Folder folder = new Folder();\nfinal long numCoders = readUint64(header);\nfinal Coder[] coders = new Coder[(int)numCoders];\nlong totalInStreams = 0;\nlong totalOutStreams = 0;\nfor (int i = 0; i < coders.length; i++) {\ncoders[i] = new Coder();\nfinal int bits = header.readUnsignedByte();\nfinal int idSize = bits & 0xf;\nfinal boolean isSimple = (bits & 0x10) == 0;\nfinal boolean hasAttributes = (bits & 0x20) != 0;\nfinal boolean moreAlternativeMethods = (bits & 0x80) != 0;\ncoders[i].decompressionMethodId = new byte[idSize];\nheader.readFully(coders[i].decompressionMethodId);\nif (isSimple) {\ncoders[i].numInStreams = 1;\ncoders[i].numOutStreams = 1;\ntotalInStreams += coders[i].numInStreams;\ntotalOutStreams += coders[i].numOutStreams;\nif (hasAttributes) {\nfinal long propertiesSize = readUint64(header);\ncoders[i].properties = new byte[(int)propertiesSize];\nheader.readFully(coders[i].properties);\nwhile (moreAlternativeMethods) {\nfolder.coders = coders;\nfolder.totalInputStreams = totalInStreams;\nfolder.totalOutputStreams = totalOutStreams;\nif (totalOutStreams == 0) {\nfinal long numBindPairs = totalOutStreams - 1;\nfinal BindPair[] bindPairs = new BindPair[(int)numBindPairs];\nfor (int i = 0; i < bindPairs.length; i++) {\nfolder.bindPairs = bindPairs;\nif (totalInStreams < numBindPairs) {\nfinal long numPackedStreams = totalInStreams - numBindPairs;\nfinal long packedStreams[] = new long[(int)numPackedStreams];\nif (numPackedStreams == 1) {\nfor (i = 0; i < (int)totalInStreams; i++) {\nif (folder.findBindPairForInStream(i) < 0) {\nbreak;\nif (i == (int)totalInStreams) {\npackedStreams[0] = i;\n} else {\nfolder.packedStreams = packedStreams;\nreturn folder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readAllOrBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readAllOrBits(final DataInput header, final int size) throws IOException {\nfinal int areAllDefined = header.readUnsignedByte();\nif (areAllDefined != 0) {\nbits = new BitSet(size);\nfor (int i = 0; i < size; i++) {\nbits.set(i, true);\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readBits(final DataInput header, final int size) throws IOException {\nfinal BitSet bits = new BitSet(size);\nint mask = 0;\nint cache = 0;\nfor (int i = 0; i < size; i++) {\nif (mask == 0) {\nmask = 0x80;\ncache = header.readUnsignedByte();\nbits.set(i, (cache & mask) != 0);\nmask >>>= 1;\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFilesInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readFilesInfo(final DataInput header, final Archive archive) throws IOException {\nfinal long numFiles = readUint64(header);\nfinal SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\nfor (int i = 0; i < files.length; i++) {\nfiles[i] = new SevenZArchiveEntry();\nBitSet isEmptyStream = null;\nBitSet isEmptyFile = null;\nBitSet isAnti = null;\nfinal int propertyType = header.readUnsignedByte();\nif (propertyType == 0) {\nbreak;\nfinal long size = readUint64(header);\nswitch (propertyType) {\nisEmptyStream = readBits(header, files.length);\nbreak;\nif (isEmptyStream == null) { // protect against NPE\nisEmptyFile = readBits(header, isEmptyStream.cardinality());\nbreak;\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nif (((size - 1) & 1) != 0) {\nfinal byte[] names = new byte[(int)(size - 1)];\nheader.readFully(names);\nint nextFile = 0;\nint nextName = 0;\nfor (int i = 0; i < names.length; i += 2) {\nif (names[i] == 0 && names[i+1] == 0) {\nfiles[nextFile++].setName(new String(names, nextName, i-nextName, CharsetNames.UTF_16LE));\nnextName = i + 2;\nif (nextName != names.length || nextFile != files.length) {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasLastModifiedDate(timesDefined.get(i));\nif (files[i].getHasLastModifiedDate()) {\nfiles[i].setLastModifiedDate(Long.reverseBytes(header.readLong()));\nbreak;\nfinal BitSet attributesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasWindowsAttributes(attributesDefined.get(i));\nif (files[i].getHasWindowsAttributes()) {\nfiles[i].setWindowsAttributes(Integer.reverseBytes(header.readInt()));\nbreak;\n}\nint nonEmptyFileCounter = 0;\nint emptyFileCounter = 0;\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasStream(isEmptyStream == null ? true : !isEmptyStream.get(i));\nif (files[i].hasStream()) {\nfiles[i].setDirectory(false);\nfiles[i].setAntiItem(false);\nfiles[i].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nfiles[i].setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nfiles[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\nfiles[i].setDirectory(isEmptyFile == null ? true : !isEmptyFile.get(emptyFileCounter));\nfiles[i].setAntiItem(isAnti == null ? false : isAnti.get(emptyFileCounter));\nfiles[i].setHasCrc(false);\nfiles[i].setSize(0);\n++emptyFileCounter;\narchive.files = files;\ncalculateStreamMap(archive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:calculateStreamMap(Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void calculateStreamMap(final Archive archive) throws IOException {\nfinal StreamMap streamMap = new StreamMap();\nint nextFolderPackStreamIndex = 0;\nfinal int numFolders = archive.folders != null ? archive.folders.length : 0;\nstreamMap.folderFirstPackStreamIndex = new int[numFolders];\nfor (int i = 0; i < numFolders; i++) {\nstreamMap.folderFirstPackStreamIndex[i] = nextFolderPackStreamIndex;\nnextFolderPackStreamIndex += archive.folders[i].packedStreams.length;\nlong nextPackStreamOffset = 0;\nfinal int numPackSizes = archive.packSizes != null ? archive.packSizes.length : 0;\nstreamMap.packStreamOffsets = new long[numPackSizes];\nfor (int i = 0; i < numPackSizes; i++) {\nstreamMap.packStreamOffsets[i] = nextPackStreamOffset;\nnextPackStreamOffset += archive.packSizes[i];\nstreamMap.folderFirstFileIndex = new int[numFolders];\nstreamMap.fileFolderIndex = new int[archive.files.length];\nint nextFolderIndex = 0;\nint nextFolderUnpackStreamIndex = 0;\nfor (int i = 0; i < archive.files.length; i++) {\nif (!archive.files[i].hasStream() && nextFolderUnpackStreamIndex == 0) {\nstreamMap.fileFolderIndex[i] = -1;\ncontinue;\nif (nextFolderUnpackStreamIndex == 0) {\nfor (; nextFolderIndex < archive.folders.length; ++nextFolderIndex) {\nstreamMap.folderFirstFileIndex[nextFolderIndex] = i;\nif (archive.folders[nextFolderIndex].numUnpackSubStreams > 0) {\nbreak;\nif (nextFolderIndex >= archive.folders.length) {\nstreamMap.fileFolderIndex[i] = nextFolderIndex;\nif (!archive.files[i].hasStream()) {\n++nextFolderUnpackStreamIndex;\nif (nextFolderUnpackStreamIndex >= archive.folders[nextFolderIndex].numUnpackSubStreams) {\n++nextFolderIndex;\nnextFolderUnpackStreamIndex = 0;\narchive.streamMap = streamMap;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:buildDecodingStream()V",
                                    "method_body": "private void buildDecodingStream() throws IOException {\nfinal int folderIndex = archive.streamMap.fileFolderIndex[currentEntryIndex];\nif (folderIndex < 0) {\ndeferredBlockStreams.clear();\nreturn;\nfinal SevenZArchiveEntry file = archive.files[currentEntryIndex];\nif (currentFolderIndex == folderIndex) {\nfile.setContentMethods(archive.files[currentEntryIndex - 1].getContentMethods());\ncurrentFolderIndex = folderIndex;\ndeferredBlockStreams.clear();\nif (currentFolderInputStream != null) {\ncurrentFolderInputStream.close();\ncurrentFolderInputStream = null;\nfinal Folder folder = archive.folders[folderIndex];\nfinal int firstPackStreamIndex = archive.streamMap.folderFirstPackStreamIndex[folderIndex];\nfinal long folderOffset = SIGNATURE_HEADER_SIZE + archive.packPos +\ncurrentFolderInputStream = buildDecoderStack(folder, folderOffset, firstPackStreamIndex, file);\nInputStream fileStream = new BoundedInputStream(currentFolderInputStream, file.getSize());\nif (file.getHasCrc()) {\nfileStream = new CRC32VerifyingInputStream(fileStream, file.getSize(), file.getCrcValue());\ndeferredBlockStreams.add(fileStream);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:buildDecoderStack(Lorg/apache/commons/compress/archivers/sevenz/Folder;JILorg/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry;)Ljava/io/InputStream;",
                                    "method_body": "private InputStream buildDecoderStack(final Folder folder, final long folderOffset,\nfile.seek(folderOffset);\nInputStream inputStreamStack =\nfinal LinkedList<SevenZMethodConfiguration> methods = new LinkedList<SevenZMethodConfiguration>();\nfor (final Coder coder : folder.getOrderedCoders()) {\nif (coder.numInStreams != 1 || coder.numOutStreams != 1) {\nfinal SevenZMethod method = SevenZMethod.byId(coder.decompressionMethodId);\ninputStreamStack = Coders.addDecoder(fileName, inputStreamStack,\nmethods.addFirst(new SevenZMethodConfiguration(method,\n}\nentry.setContentMethods(methods);\nif (folder.hasCrc) {\nreturn inputStreamStack;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:read()I",
                                    "method_body": "public int read() throws IOException {\nreturn getCurrentStream().read();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:getCurrentStream()Ljava/io/InputStream;",
                                    "method_body": "private InputStream getCurrentStream() throws IOException {\nif (deferredBlockStreams.isEmpty()) {\nthrow new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\nwhile (deferredBlockStreams.size() > 1) {\nfinal InputStream stream = deferredBlockStreams.remove(0);\nIOUtils.skip(stream, Long.MAX_VALUE);\nstream.close();\n}\nreturn deferredBlockStreams.get(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUint64(Ljava/io/DataInput;)J",
                                    "method_body": "private static long readUint64(final DataInput in) throws IOException {\nfinal long firstByte = in.readUnsignedByte();\nint mask = 0x80;\nlong value = 0;\nfor (int i = 0; i < 8; i++) {\nif ((firstByte & mask) == 0) {\nreturn value | ((firstByte & (mask - 1)) << (8 * i));\nfinal long nextByte = in.readUnsignedByte();\nvalue |= nextByte << (8 * i);\nmask >>>= 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;JJ)V",
                                    "method_body": "public ChecksumVerifyingInputStream(final Checksum checksum, final InputStream in,\nfinal long size, final long expectedChecksum) {\nthis.checksum = checksum;\nthis.in = in;\nthis.expectedChecksum = expectedChecksum;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining <= 0) {\nreturn -1;\nfinal int ret = in.read();\nif (ret >= 0) {\nchecksum.update(ret);\n--bytesRemaining;\nif (bytesRemaining == 0 && expectedChecksum != checksum.getValue()) {\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read([BII)I",
                                    "method_body": "public int read(final byte[] b, final int off, final int len) throws IOException {\nfinal int ret = in.read(b, off, len);\nif (ret >= 0) {\nchecksum.update(b, off, ret);\nbytesRemaining -= ret;\nif (bytesRemaining <= 0 && expectedChecksum != checksum.getValue()) {\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:skip(J)J",
                                    "method_body": "public long skip(final long n) throws IOException {\nif (read() >= 0) {\nreturn 1;\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nin.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CRC32VerifyingInputStream:<init>(Ljava/io/InputStream;JJ)V",
                                    "method_body": "public CRC32VerifyingInputStream(final InputStream in, final long size, final long expectedCrc32) {\nsuper(new CRC32(), in, size, expectedCrc32);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:<init>(Ljava/io/RandomAccessFile;J)V",
                                    "method_body": "public BoundedRandomAccessFileInputStream(final RandomAccessFile file,\nfinal long size) {\nthis.file = file;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining > 0) {\n--bytesRemaining;\nreturn file.read();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read([BII)I",
                                    "method_body": "public int read(final byte[] b, final int off, final int len) throws IOException {\nif (bytesRemaining == 0) {\nint bytesToRead = len;\nif (bytesToRead > bytesRemaining) {\nbytesToRead = (int) bytesRemaining;\nfinal int bytesRead = file.read(b, off, bytesToRead);\nif (bytesRead >= 0) {\nbytesRemaining -= bytesRead;\nreturn bytesRead;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:close()V",
                                    "method_body": "public void close() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:getOrderedCoders()Ljava/lang/Iterable;",
                                    "method_body": "Iterable<Coder> getOrderedCoders() {\nfinal LinkedList<Coder> l = new LinkedList<Coder>();\nint current = (int) packedStreams[0]; // more that 2^31 coders?\nwhile (current != -1) {\nl.addLast(coders[current]);\nfinal int pair = findBindPairForOutStream(current);\ncurrent = pair != -1 ? (int) bindPairs[pair].inIndex : -1;\n}\nreturn l;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:findBindPairForInStream(I)I",
                                    "method_body": "int findBindPairForInStream(final int index) {\nfor (int i = 0; i < bindPairs.length; i++) {\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:findBindPairForOutStream(I)I",
                                    "method_body": "int findBindPairForOutStream(final int index) {\nfor (int i = 0; i < bindPairs.length; i++) {\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:getUnpackSize()J",
                                    "method_body": "long getUnpackSize() {\nif (totalOutputStreams == 0) {\nfor (int i = ((int)totalOutputStreams) - 1; i >= 0; i--) {\nif (findBindPairForOutStream(i) < 0) {\nreturn unpackSizes[i];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:getUnpackSizeForCoder(Lorg/apache/commons/compress/archivers/sevenz/Coder;)J",
                                    "method_body": "long getUnpackSizeForCoder(final Coder coder) {\nif (coders != null) {\nfor (int i = 0; i < coders.length; i++) {\nif (coders[i] == coder) {\nreturn unpackSizes[i];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coder:<init>()V",
                                    "method_body": "byte[] decompressionMethodId;\nbyte[] properties = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.BoundedInputStream:<init>(Ljava/io/InputStream;J)V",
                                    "method_body": "public BoundedInputStream(final InputStream in, final long size) {\nthis.in = in;\nbytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.BoundedInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining > 0) {\n--bytesRemaining;\nreturn in.read();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.BoundedInputStream:read([BII)I",
                                    "method_body": "public int read(final byte[] b, final int off, final int len) throws IOException {\nif (bytesRemaining == 0) {\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.BoundedInputStream:close()V",
                                    "method_body": "public void close() {\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 37,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest.survivesBlankLinesInPaxHeader",
                            "test_body": "305: public void survivesBlankLinesInPaxHeader() throws Exception {\n306: final TarArchiveInputStream is = getTestStream(\"/COMPRESS-355.tar\");\n307: try {\n308: final TarArchiveEntry entry = is.getNextTarEntry();\n309: assertEquals(\"package/package.json\", entry.getName());\n310: assertNull(is.getNextTarEntry());\n311: } finally {\n312: is.close();\n313: }\n314: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nfinal int num = read(SINGLE, 0, 1);\nreturn num == -1 ? -1 : SINGLE[0] & BYTE_MASK;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(final int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(final long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\nfinal Map<String, SimpleEncodingHolder> se =\nfinal char[] cp437_high_chars =\nfinal SimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\nfinal char[] cp850_high_chars =\nfinal SimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(final String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\ncharsetName = Charset.defaultCharset().name();\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(final char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(final String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(final byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data,this.charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:matchAsciiBuffer(Ljava/lang/String;[BII)Z",
                                    "method_body": "public static boolean matchAsciiBuffer(\nbuffer1 = expected.getBytes(CharsetNames.US_ASCII);\n}\nreturn isEqual(buffer1, 0, buffer1.length, buffer, offset, length, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isEqual([BII[BIIZ)Z",
                                    "method_body": "public static boolean isEqual(\nfinal int minLen=length1 < length2 ? length1 : length2;\nfor (int i=0; i < minLen; i++){\nif (buffer1[offset1+i] != buffer2[offset2+i]){\nreturn false;\nif (length1 == length2){\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isArrayZero([BI)Z",
                                    "method_body": "public static boolean isArrayZero(final byte[] a, final int size) {\nfor (int i = 0; i < size; i++) {\nif (a[i] != 0) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[B)I",
                                    "method_body": "public static int readFully(final InputStream input, final byte[] b) throws IOException {\nreturn readFully(input, b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(final InputStream input, final byte[] b, final int offset, final int len)\nif (len < 0 || offset < 0 || len + offset > b.length) {\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\ncount += x;\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry() {\nString user = System.getProperty(\"user.name\", \"\");\nif (user.length() > MAX_NAMELEN) {\nthis.userName = user;\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/io/File;Ljava/lang/String;)V",
                                    "method_body": "private static final TarArchiveEntry[] EMPTY_TAR_ARCHIVE_ENTRIES = new TarArchiveEntry[0];\nprivate String name = \"\";\nprivate long userId = 0;\nprivate long groupId = 0;\nprivate long size = 0;\nprivate String linkName = \"\";\nprivate String magic = MAGIC_POSIX;\nprivate String version = VERSION_POSIX;\nprivate String groupName = \"\";\nprivate int devMajor = 0;\nprivate int devMinor = 0;\nprivate TarArchiveEntry() {\nString user = System.getProperty(\"user.name\", \"\");\nif (user.length() > MAX_NAMELEN) {\nthis.userName = user;\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public TarArchiveEntry(final byte[] headerBuf, final ZipEncoding encoding)\nthis();\nparseTarHeader(headerBuf, encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<clinit>()V",
                                    "method_body": "private static final TarArchiveEntry[] EMPTY_TAR_ARCHIVE_ENTRIES = new TarArchiveEntry[0];\nprivate String name = \"\";\nprivate long userId = 0;\nprivate long groupId = 0;\nprivate long size = 0;\nprivate String linkName = \"\";\nprivate String magic = MAGIC_POSIX;\nprivate String version = VERSION_POSIX;\nprivate String groupName = \"\";\nprivate int devMajor = 0;\nprivate int devMinor = 0;\nprivate TarArchiveEntry() {\nString user = System.getProperty(\"user.name\", \"\");\nif (user.length() > MAX_NAMELEN) {\nthis.userName = user;\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongLinkEntry()Z",
                                    "method_body": "public boolean isGNULongLinkEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGLINK;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongNameEntry()Z",
                                    "method_body": "public boolean isGNULongNameEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGNAME;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isPaxHeader()Z",
                                    "method_body": "public boolean isPaxHeader(){\nreturn linkFlag == LF_PAX_EXTENDED_HEADER_LC\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGlobalPaxHeader()Z",
                                    "method_body": "public boolean isGlobalPaxHeader(){\nreturn linkFlag == LF_PAX_GLOBAL_EXTENDED_HEADER;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nif (file != null) {\nif (linkFlag == LF_DIR) {\nif (getName().endsWith(\"/\")) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public void parseTarHeader(final byte[] header, final ZipEncoding encoding)\nparseTarHeader(header, encoding, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;Z)V",
                                    "method_body": "private void parseTarHeader(final byte[] header, final ZipEncoding encoding,\nint offset = 0;\nname = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\noffset += NAMELEN;\nmode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN);\noffset += MODELEN;\nuserId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\noffset += UIDLEN;\ngroupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\noffset += GIDLEN;\nsize = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\noffset += SIZELEN;\nmodTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN);\noffset += MODTIMELEN;\ncheckSumOK = TarUtils.verifyCheckSum(header);\noffset += CHKSUMLEN;\nlinkFlag = header[offset++];\nlinkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\noffset += NAMELEN;\nmagic = TarUtils.parseName(header, offset, MAGICLEN);\noffset += MAGICLEN;\nversion = TarUtils.parseName(header, offset, VERSIONLEN);\noffset += VERSIONLEN;\nuserName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)\noffset += UNAMELEN;\ngroupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN)\noffset += GNAMELEN;\ndevMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\ndevMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\nfinal int type = evaluateType(header);\nswitch (type) {\nfinal String prefix = oldStyle\nif (isDirectory() && !name.endsWith(\"/\")){\nif (prefix.length() > 0){\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:evaluateType([B)I",
                                    "method_body": "private int evaluateType(final byte[] header) {\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_GNU, header, MAGIC_OFFSET, MAGICLEN)) {\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_POSIX, header, MAGIC_OFFSET, MAGICLEN)) {\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_XSTAR, header, XSTAR_MAGIC_OFFSET,\nreturn FORMAT_POSIX;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:<clinit>()V",
                                    "method_body": "private static final int BYTE_MASK = 255;\nstatic final ZipEncoding DEFAULT_ENCODING =\nstatic final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\nif (length < 2){\nif (buffer[start] == 0) {\nwhile (start < end){\nif (buffer[start] == ' '){\nbyte trailer = buffer[end - 1];\nwhile (start < end && (trailer == 0 || trailer == ' ')) {\nend--;\ntrailer = buffer[end - 1];\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\nif (currentByte < '0' || currentByte > '7'){\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctalOrBinary([BII)J",
                                    "method_body": "public static long parseOctalOrBinary(final byte[] buffer, final int offset,\nif ((buffer[offset] & 0x80) == 0) {\nreturn parseOctal(buffer, offset, length);\nfinal boolean negative = buffer[offset] == (byte) 0xff;\nif (length < 9) {\nreturn parseBinaryLong(buffer, offset, length, negative);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseBinaryLong([BIIZ)J",
                                    "method_body": "private static long parseBinaryLong(final byte[] buffer, final int offset,\nif (length >= 9) {\nlong val = 0;\nfor (int i = 1; i < length; i++) {\nval = (val << 8) + (buffer[offset + i] & 0xff);\nif (negative) {\nreturn negative ? -val : val;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BII)Ljava/lang/String;",
                                    "method_body": "public static String parseName(final byte[] buffer, final int offset, final int length) {\nreturn parseName(buffer, offset, length, DEFAULT_ENCODING);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BIILorg/apache/commons/compress/archivers/zip/ZipEncoding;)Ljava/lang/String;",
                                    "method_body": "public static String parseName(final byte[] buffer, final int offset,\nint len = length;\nfor (; len > 0; len--) {\nif (buffer[offset + len - 1] != 0) {\nbreak;\nif (len > 0) {\nfinal byte[] b = new byte[len];\nSystem.arraycopy(buffer, offset, b, 0, len);\nreturn encoding.decode(b);\nreturn \"\";\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:verifyCheckSum([B)Z",
                                    "method_body": "public static boolean verifyCheckSum(final byte[] header) {\nfinal long storedSum = parseOctal(header, CHKSUM_OFFSET, CHKSUMLEN);\nlong unsignedSum = 0;\nlong signedSum = 0;\nfor (int i = 0; i < header.length; i++) {\nbyte b = header[i];\nif (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\nb = ' ';\nunsignedSum += 0xff & b;\nsignedSum += b;\nreturn storedSum == unsignedSum || storedSum == signedSum;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(final InputStream is) {\nthis(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(final InputStream is, final int blockSize, final int recordSize) {\nthis(is, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;IILjava/lang/String;)V",
                                    "method_body": "public TarArchiveInputStream(final InputStream is, final int blockSize, final int recordSize,\nfinal String encoding) {\nthis.is = is;\nthis.hasHitEOF = false;\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.recordSize = recordSize;\nthis.blockSize = blockSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nis.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:available()I",
                                    "method_body": "public int available() throws IOException {\nif (isDirectory()) {\nif (entrySize - entryOffset > Integer.MAX_VALUE) {\nreturn (int) (entrySize - entryOffset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextTarEntry()Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;",
                                    "method_body": "public TarArchiveEntry getNextTarEntry() throws IOException {\nif (hasHitEOF) {\nif (currEntry != null) {\nfinal byte[] headerBuf = getRecord();\nif (headerBuf == null) {\ncurrEntry = new TarArchiveEntry(headerBuf, zipEncoding);\n}\nentryOffset = 0;\nentrySize = currEntry.getSize();\nif (currEntry.isGNULongLinkEntry()) {\nif (currEntry.isGNULongNameEntry()) {\nif (currEntry.isGlobalPaxHeader()){ // Process Global Pax headers\nif (currEntry.isPaxHeader()){ // Process Pax headers\npaxHeaders();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getRecord()[B",
                                    "method_body": "private byte[] getRecord() throws IOException {\nbyte[] headerBuf = readRecord();\nhasHitEOF = isEOFRecord(headerBuf);\nif (hasHitEOF && headerBuf != null) {\nreturn headerBuf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:isEOFRecord([B)Z",
                                    "method_body": "protected boolean isEOFRecord(final byte[] record) {\nreturn record == null || ArchiveUtils.isArrayZero(record, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:readRecord()[B",
                                    "method_body": "protected byte[] readRecord() throws IOException {\nfinal byte[] record = new byte[recordSize];\nfinal int readNow = IOUtils.readFully(is, record);\ncount(readNow);\nif (readNow != recordSize) {\nreturn record;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:paxHeaders()V",
                                    "method_body": "private void paxHeaders() throws IOException{\nfinal Map<String, String> headers = parsePaxHeaders(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:parsePaxHeaders(Ljava/io/InputStream;)Ljava/util/Map;",
                                    "method_body": "Map<String, String> parsePaxHeaders(final InputStream i)\nfinal Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\nint len = 0;\nint read = 0;\nwhile((ch = i.read()) != -1) {\nread++;\nif (ch == ' '){\nfinal ByteArrayOutputStream coll = new ByteArrayOutputStream();\nwhile((ch = i.read()) != -1) {\nread++;\nif (ch == '='){ // end of keyword\nfinal String keyword = coll.toString(CharsetNames.UTF_8);\nfinal int restLen = len - read;\nif (restLen == 1) { // only NL\nheaders.remove(keyword);\nfinal byte[] rest = new byte[restLen];\nfinal int got = IOUtils.readFully(i, rest);\nif (got != restLen) {\nfinal String value = new String(rest, 0,\nheaders.put(keyword, value);\nbreak;\ncoll.write((byte) ch);\nlen *= 10;\nlen += ch - '0';\nif (ch == -1){ // EOF\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:isDirectory()Z",
                                    "method_body": "private boolean isDirectory() {\nreturn currEntry != null && currEntry.isDirectory();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:read([BII)I",
                                    "method_body": "public int read(final byte[] buf, final int offset, int numToRead) throws IOException {\nint totalRead = 0;\nif (hasHitEOF || isDirectory() || entryOffset >= entrySize) {\nif (currEntry == null) {\nnumToRead = Math.min(numToRead, available());\ntotalRead = is.read(buf, offset, numToRead);\nif (totalRead == -1) {\ncount(totalRead);\nentryOffset += totalRead;\nreturn totalRead;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 38,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest.survivesPaxHeaderWithNameEndingInSlash",
                            "test_body": "320: public void survivesPaxHeaderWithNameEndingInSlash() throws Exception {\n321: final TarArchiveInputStream is = getTestStream(\"/COMPRESS-356.tar\");\n322: try {\n323: final TarArchiveEntry entry = is.getNextTarEntry();\n324: assertEquals(\"package/package.json\", entry.getName());\n325: assertNull(is.getNextTarEntry());\n326: } finally {\n327: is.close();\n328: }\n329: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nfinal int num = read(SINGLE, 0, 1);\nreturn num == -1 ? -1 : SINGLE[0] & BYTE_MASK;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(final int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(final long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\nfinal Map<String, SimpleEncodingHolder> se =\nfinal char[] cp437_high_chars =\nfinal SimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\nfinal char[] cp850_high_chars =\nfinal SimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(final String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\ncharsetName = Charset.defaultCharset().name();\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(final char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(final String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(final byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data,this.charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:matchAsciiBuffer(Ljava/lang/String;[BII)Z",
                                    "method_body": "public static boolean matchAsciiBuffer(\nbuffer1 = expected.getBytes(CharsetNames.US_ASCII);\n}\nreturn isEqual(buffer1, 0, buffer1.length, buffer, offset, length, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isEqual([BII[BIIZ)Z",
                                    "method_body": "public static boolean isEqual(\nfinal int minLen=length1 < length2 ? length1 : length2;\nfor (int i=0; i < minLen; i++){\nif (buffer1[offset1+i] != buffer2[offset2+i]){\nreturn false;\nif (length1 == length2){\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isArrayZero([BI)Z",
                                    "method_body": "public static boolean isArrayZero(final byte[] a, final int size) {\nfor (int i = 0; i < size; i++) {\nif (a[i] != 0) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:skip(Ljava/io/InputStream;J)J",
                                    "method_body": "public static long skip(final InputStream input, long numToSkip) throws IOException {\nfinal long available = numToSkip;\nwhile (numToSkip > 0) {\nfinal long skipped = input.skip(numToSkip);\nif (skipped == 0) {\nbreak;\nwhile (numToSkip > 0) {\nfinal int read = readFully(input, SKIP_BUF, 0,\nif (read < 1) {\nbreak;\nreturn available - numToSkip;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[B)I",
                                    "method_body": "public static int readFully(final InputStream input, final byte[] b) throws IOException {\nreturn readFully(input, b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(final InputStream input, final byte[] b, final int offset, final int len)\nif (len < 0 || offset < 0 || len + offset > b.length) {\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\nbreak;\ncount += x;\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry() {\nString user = System.getProperty(\"user.name\", \"\");\nif (user.length() > MAX_NAMELEN) {\nthis.userName = user;\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/io/File;Ljava/lang/String;)V",
                                    "method_body": "private static final TarArchiveEntry[] EMPTY_TAR_ARCHIVE_ENTRIES = new TarArchiveEntry[0];\nprivate String name = \"\";\nprivate long userId = 0;\nprivate long groupId = 0;\nprivate long size = 0;\nprivate String linkName = \"\";\nprivate String magic = MAGIC_POSIX;\nprivate String version = VERSION_POSIX;\nprivate String groupName = \"\";\nprivate int devMajor = 0;\nprivate int devMinor = 0;\nprivate TarArchiveEntry() {\nString user = System.getProperty(\"user.name\", \"\");\nif (user.length() > MAX_NAMELEN) {\nthis.userName = user;\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public TarArchiveEntry(final byte[] headerBuf, final ZipEncoding encoding)\nthis();\nparseTarHeader(headerBuf, encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<clinit>()V",
                                    "method_body": "private static final TarArchiveEntry[] EMPTY_TAR_ARCHIVE_ENTRIES = new TarArchiveEntry[0];\nprivate String name = \"\";\nprivate long userId = 0;\nprivate long groupId = 0;\nprivate long size = 0;\nprivate String linkName = \"\";\nprivate String magic = MAGIC_POSIX;\nprivate String version = VERSION_POSIX;\nprivate String groupName = \"\";\nprivate int devMajor = 0;\nprivate int devMinor = 0;\nprivate TarArchiveEntry() {\nString user = System.getProperty(\"user.name\", \"\");\nif (user.length() > MAX_NAMELEN) {\nthis.userName = user;\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongLinkEntry()Z",
                                    "method_body": "public boolean isGNULongLinkEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGLINK;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongNameEntry()Z",
                                    "method_body": "public boolean isGNULongNameEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGNAME;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isPaxHeader()Z",
                                    "method_body": "public boolean isPaxHeader(){\nreturn linkFlag == LF_PAX_EXTENDED_HEADER_LC\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGlobalPaxHeader()Z",
                                    "method_body": "public boolean isGlobalPaxHeader(){\nreturn linkFlag == LF_PAX_GLOBAL_EXTENDED_HEADER;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nif (file != null) {\nif (linkFlag == LF_DIR) {\nif (getName().endsWith(\"/\")) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public void parseTarHeader(final byte[] header, final ZipEncoding encoding)\nparseTarHeader(header, encoding, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;Z)V",
                                    "method_body": "private void parseTarHeader(final byte[] header, final ZipEncoding encoding,\nint offset = 0;\nname = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\noffset += NAMELEN;\nmode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN);\noffset += MODELEN;\nuserId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\noffset += UIDLEN;\ngroupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\noffset += GIDLEN;\nsize = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\noffset += SIZELEN;\nmodTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN);\noffset += MODTIMELEN;\ncheckSumOK = TarUtils.verifyCheckSum(header);\noffset += CHKSUMLEN;\nlinkFlag = header[offset++];\nlinkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\noffset += NAMELEN;\nmagic = TarUtils.parseName(header, offset, MAGICLEN);\noffset += MAGICLEN;\nversion = TarUtils.parseName(header, offset, VERSIONLEN);\noffset += VERSIONLEN;\nuserName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)\noffset += UNAMELEN;\ngroupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN)\noffset += GNAMELEN;\ndevMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\ndevMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\nfinal int type = evaluateType(header);\nswitch (type) {\nfinal String prefix = oldStyle\nif (isDirectory() && !name.endsWith(\"/\")){\nif (prefix.length() > 0){\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:evaluateType([B)I",
                                    "method_body": "private int evaluateType(final byte[] header) {\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_GNU, header, MAGIC_OFFSET, MAGICLEN)) {\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_POSIX, header, MAGIC_OFFSET, MAGICLEN)) {\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_XSTAR, header, XSTAR_MAGIC_OFFSET,\nreturn FORMAT_POSIX;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:<clinit>()V",
                                    "method_body": "private static final int BYTE_MASK = 255;\nstatic final ZipEncoding DEFAULT_ENCODING =\nstatic final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\nif (length < 2){\nif (buffer[start] == 0) {\nwhile (start < end){\nif (buffer[start] == ' '){\nbyte trailer = buffer[end - 1];\nwhile (start < end && (trailer == 0 || trailer == ' ')) {\nend--;\ntrailer = buffer[end - 1];\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\nif (currentByte < '0' || currentByte > '7'){\nthrow new IllegalArgumentException(\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctalOrBinary([BII)J",
                                    "method_body": "public static long parseOctalOrBinary(final byte[] buffer, final int offset,\nif ((buffer[offset] & 0x80) == 0) {\nreturn parseOctal(buffer, offset, length);\nfinal boolean negative = buffer[offset] == (byte) 0xff;\nif (length < 9) {\nreturn parseBinaryLong(buffer, offset, length, negative);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseBinaryLong([BIIZ)J",
                                    "method_body": "private static long parseBinaryLong(final byte[] buffer, final int offset,\nif (length >= 9) {\nlong val = 0;\nfor (int i = 1; i < length; i++) {\nval = (val << 8) + (buffer[offset + i] & 0xff);\nif (negative) {\nreturn negative ? -val : val;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:exceptionMessage([BIIIB)Ljava/lang/String;",
                                    "method_body": "private static String exceptionMessage(final byte[] buffer, final int offset,\nString string = new String(buffer, offset, length);\nstring=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed\nfinal String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;\nreturn s;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BII)Ljava/lang/String;",
                                    "method_body": "public static String parseName(final byte[] buffer, final int offset, final int length) {\nreturn parseName(buffer, offset, length, DEFAULT_ENCODING);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BIILorg/apache/commons/compress/archivers/zip/ZipEncoding;)Ljava/lang/String;",
                                    "method_body": "public static String parseName(final byte[] buffer, final int offset,\nint len = length;\nfor (; len > 0; len--) {\nif (buffer[offset + len - 1] != 0) {\nbreak;\nif (len > 0) {\nfinal byte[] b = new byte[len];\nSystem.arraycopy(buffer, offset, b, 0, len);\nreturn encoding.decode(b);\nreturn \"\";\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:verifyCheckSum([B)Z",
                                    "method_body": "public static boolean verifyCheckSum(final byte[] header) {\nfinal long storedSum = parseOctal(header, CHKSUM_OFFSET, CHKSUMLEN);\nlong unsignedSum = 0;\nlong signedSum = 0;\nfor (int i = 0; i < header.length; i++) {\nbyte b = header[i];\nif (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\nb = ' ';\nunsignedSum += 0xff & b;\nsignedSum += b;\nreturn storedSum == unsignedSum || storedSum == signedSum;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(final InputStream is) {\nthis(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(final InputStream is, final int blockSize, final int recordSize) {\nthis(is, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;IILjava/lang/String;)V",
                                    "method_body": "public TarArchiveInputStream(final InputStream is, final int blockSize, final int recordSize,\nfinal String encoding) {\nthis.is = is;\nthis.hasHitEOF = false;\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.recordSize = recordSize;\nthis.blockSize = blockSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nis.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:skip(J)J",
                                    "method_body": "public long skip(final long n) throws IOException {\nif (n <= 0 || isDirectory()) {\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextTarEntry()Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;",
                                    "method_body": "public TarArchiveEntry getNextTarEntry() throws IOException {\nif (hasHitEOF) {\nif (currEntry != null) {\nIOUtils.skip(this, Long.MAX_VALUE);\nskipRecordPadding();\nfinal byte[] headerBuf = getRecord();\nif (headerBuf == null) {\ncurrEntry = new TarArchiveEntry(headerBuf, zipEncoding);\n} catch (final IllegalArgumentException e) {\nthrow new IOException(\"Error detected parsing the header\", e);\n}\nentryOffset = 0;\nentrySize = currEntry.getSize();\nif (currEntry.isGNULongLinkEntry()) {\nif (currEntry.isGNULongNameEntry()) {\nif (currEntry.isGlobalPaxHeader()){ // Process Global Pax headers\nif (currEntry.isPaxHeader()){ // Process Pax headers\npaxHeaders();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:skipRecordPadding()V",
                                    "method_body": "private void skipRecordPadding() throws IOException {\nif (!isDirectory() && this.entrySize > 0 && this.entrySize % this.recordSize != 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getRecord()[B",
                                    "method_body": "private byte[] getRecord() throws IOException {\nbyte[] headerBuf = readRecord();\nhasHitEOF = isEOFRecord(headerBuf);\nif (hasHitEOF && headerBuf != null) {\nreturn headerBuf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:isEOFRecord([B)Z",
                                    "method_body": "protected boolean isEOFRecord(final byte[] record) {\nreturn record == null || ArchiveUtils.isArrayZero(record, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:readRecord()[B",
                                    "method_body": "protected byte[] readRecord() throws IOException {\nfinal byte[] record = new byte[recordSize];\nfinal int readNow = IOUtils.readFully(is, record);\ncount(readNow);\nif (readNow != recordSize) {\nreturn record;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:paxHeaders()V",
                                    "method_body": "private void paxHeaders() throws IOException{\nfinal Map<String, String> headers = parsePaxHeaders(this);\ngetNextEntry(); // Get the actual file entry\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:parsePaxHeaders(Ljava/io/InputStream;)Ljava/util/Map;",
                                    "method_body": "Map<String, String> parsePaxHeaders(final InputStream i)\nfinal Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\nint len = 0;\nint read = 0;\nwhile((ch = i.read()) != -1) {\nif (ch == -1){ // EOF\nbreak;\nreturn headers;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:isDirectory()Z",
                                    "method_body": "private boolean isDirectory() {\nreturn currEntry != null && currEntry.isDirectory();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextEntry()Lorg/apache/commons/compress/archivers/ArchiveEntry;",
                                    "method_body": "public ArchiveEntry getNextEntry() throws IOException {\nreturn getNextTarEntry();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:read([BII)I",
                                    "method_body": "public int read(final byte[] buf, final int offset, int numToRead) throws IOException {\nint totalRead = 0;\nif (hasHitEOF || isDirectory() || entryOffset >= entrySize) {\nreturn -1;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 39,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.ArchiveUtilsTest.sanitizeShortensString",
                            "test_body": "71: public void sanitizeShortensString() {\n72: String input = \"012345678901234567890123456789012345678901234567890123456789\"\n73: + \"012345678901234567890123456789012345678901234567890123456789\"\n74: + \"012345678901234567890123456789012345678901234567890123456789\"\n75: + \"012345678901234567890123456789012345678901234567890123456789\"\n76: + \"012345678901234567890123456789012345678901234567890123456789\";\n77: String expected = \"012345678901234567890123456789012345678901234567890123456789\"\n78: + \"012345678901234567890123456789012345678901234567890123456789\"\n79: + \"012345678901234567890123456789012345678901234567890123456789\"\n80: + \"012345678901234567890123456789012345678901234567890123456789\"\n81: + \"012345678901...\";\n82: assertEquals(expected, ArchiveUtils.sanitize(input));\n83: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>()V",
                                    "method_body": "public ArchiveStreamFactory() {\nthis(null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ArchiveStreamFactory(final String encoding) {\nsuper();\nthis.encoding = encoding;\nthis.entryEncoding = encoding;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:sanitize(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public static String sanitize(String s) {\nfinal char[] chars = s.toCharArray();\nfinal int len = chars.length;\nfinal StringBuilder sb = new StringBuilder();\nfor (int i = 0; i < len; i++) {\nfinal char c = chars[i];\nif (!Character.isISOControl(c)) {\nCharacter.UnicodeBlock block = Character.UnicodeBlock.of(c);\nif (block != null && block != Character.UnicodeBlock.SPECIALS) {\nsb.append(c);\ncontinue;\nreturn sb.toString();\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 40,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.utils.BitInputStreamTest.bigEndianWithOverflow",
                            "test_body": "149: public void bigEndianWithOverflow() throws Exception {\n150: ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n151: 87, // 01010111\n152: 45, // 00101101\n153: 66, // 01000010\n154: 15, // 00001111\n155: 90, // 01011010\n156: 29, // 00011101\n157: 88, // 01011000\n158: 61, // 00111101\n159: 33, // 00100001\n160: 74  // 01001010\n161: });\n162: BitInputStream bin = new BitInputStream(in, ByteOrder.BIG_ENDIAN);\n163: assertEquals(10, // 01010\n164: bin.readBits(5));\n165: assertEquals(8274274654740644818l, //111-00101101-01000010-00001111-01011010-00011101-01011000-00111101-0010\n166: bin.readBits(63));\n167: assertEquals(330, // 0001-01001010\n168: bin.readBits(12));\n169: assertEquals(-1 , bin.readBits(1));\n170: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.utils.BitInputStream:<init>(Ljava/io/InputStream;Ljava/nio/ByteOrder;)V",
                                    "method_body": "private final InputStream in;\nprivate long bitsCached = 0;\nprivate int bitsCachedSize = 0;\npublic BitInputStream(final InputStream in, final ByteOrder byteOrder) {\nthis.in = in;\nthis.byteOrder = byteOrder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.BitInputStream:<clinit>()V",
                                    "method_body": "private static final int MAXIMUM_CACHE_SIZE = 63; // bits in long minus sign bit\nprivate static final long[] MASKS = new long[MAXIMUM_CACHE_SIZE + 1];\nfor (int i = 1; i <= MAXIMUM_CACHE_SIZE; i++) {\nMASKS[i] = (MASKS[i - 1] << 1) + 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.BitInputStream:readBits(I)J",
                                    "method_body": "public long readBits(final int count) throws IOException {\nif (count < 0 || count > MAXIMUM_CACHE_SIZE) {\nwhile (bitsCachedSize < count) {\nfinal long nextByte = in.read();\nif (nextByte < 0) {\nif (byteOrder == ByteOrder.LITTLE_ENDIAN) {\nbitsCached |= (nextByte << bitsCachedSize);\nbitsCached <<= 8;\nbitsCached |= nextByte;\nbitsCachedSize += 8;\n}\nif (byteOrder == ByteOrder.LITTLE_ENDIAN) {\nbitsOut = (bitsCached & MASKS[count]);\nbitsCached >>>= count;\nbitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\nbitsCachedSize -= count;\nreturn bitsOut;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.utils.BitInputStreamTest.littleEndianWithOverflow",
                            "test_body": "125: public void littleEndianWithOverflow() throws Exception {\n126: ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n127: 87, // 01010111\n128: 45, // 00101101\n129: 66, // 01000010\n130: 15, // 00001111\n131: 90, // 01011010\n132: 29, // 00011101\n133: 88, // 01011000\n134: 61, // 00111101\n135: 33, // 00100001\n136: 74  // 01001010\n137: });\n138: BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN);\n139: assertEquals(23, // 10111\n140: bin.readBits(5));\n141: assertEquals(714595605644185962l, // 0001-00111101-01011000-00011101-01011010-00001111-01000010-00101101-010\n142: bin.readBits(63));\n143: assertEquals(1186, // 01001010-0010\n144: bin.readBits(12));\n145: assertEquals(-1 , bin.readBits(1));\n146: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.utils.BitInputStream:<init>(Ljava/io/InputStream;Ljava/nio/ByteOrder;)V",
                                    "method_body": "private final InputStream in;\nprivate long bitsCached = 0;\nprivate int bitsCachedSize = 0;\npublic BitInputStream(final InputStream in, final ByteOrder byteOrder) {\nthis.in = in;\nthis.byteOrder = byteOrder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.BitInputStream:<clinit>()V",
                                    "method_body": "private static final int MAXIMUM_CACHE_SIZE = 63; // bits in long minus sign bit\nprivate static final long[] MASKS = new long[MAXIMUM_CACHE_SIZE + 1];\nfor (int i = 1; i <= MAXIMUM_CACHE_SIZE; i++) {\nMASKS[i] = (MASKS[i - 1] << 1) + 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.BitInputStream:readBits(I)J",
                                    "method_body": "public long readBits(final int count) throws IOException {\nif (count < 0 || count > MAXIMUM_CACHE_SIZE) {\nwhile (bitsCachedSize < count) {\nfinal long nextByte = in.read();\nif (nextByte < 0) {\nif (byteOrder == ByteOrder.LITTLE_ENDIAN) {\nbitsCached |= (nextByte << bitsCachedSize);\nbitsCached <<= 8;\nbitsCached |= nextByte;\nbitsCachedSize += 8;\n}\nif (byteOrder == ByteOrder.LITTLE_ENDIAN) {\nbitsOut = (bitsCached & MASKS[count]);\nbitsCached >>>= count;\nbitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\nbitsCachedSize -= count;\nreturn bitsOut;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 41,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest.testThrowOnInvalidEntry",
                            "test_body": "236: public void testThrowOnInvalidEntry() throws Exception {\n237: final InputStream is = ZipArchiveInputStreamTest.class\n238: .getResourceAsStream(\"/invalid-zip.zip\");\n239: final ZipArchiveInputStream zip = new ZipArchiveInputStream(is);\n240: 241: try {\n242: zip.getNextZipEntry();\n243: fail(\"IOException expected\");\n244: } catch (ZipException expected) {\n245: assertTrue(expected.getMessage().contains(\"Unexpected record signature\"));\n246: } finally {\n247: zip.close();\n248: }\n249: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(final int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(final long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\nfinal Map<String, SimpleEncodingHolder> se =\nfinal char[] cp437_high_chars =\nfinal SimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\nfinal char[] cp850_high_chars =\nfinal SimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(final String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nfor (final String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(final char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(final String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[B)I",
                                    "method_body": "public static int readFully(final InputStream input, final byte[] b) throws IOException {\nreturn readFully(input, b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(final InputStream input, final byte[] b, final int offset, final int len)\nif (len < 0 || offset < 0 || len + offset > b.length) {\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\ncount += x;\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public ZipArchiveInputStream(final InputStream inputStream) {\nthis(inputStream, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveInputStream(final InputStream inputStream, final String encoding) {\nthis(inputStream, encoding, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipArchiveInputStream(final InputStream inputStream, final String encoding, final boolean useUnicodeExtraFields) {\nthis(inputStream, encoding, useUnicodeExtraFields, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;ZZ)V",
                                    "method_body": "private final ZipEncoding zipEncoding;\nprivate final Inflater inf = new Inflater(true);\nprivate final ByteBuffer buf = ByteBuffer.allocate(ZipArchiveOutputStream.BUFFER_SIZE);\nprivate CurrentEntry current = null;\nprivate boolean closed = false;\nprivate boolean hitCentralDirectory = false;\nprivate ByteArrayInputStream lastStoredEntry = null;\nprivate boolean allowStoredEntriesWithDataDescriptor = false;\nprivate final byte[] LFH_BUF = new byte[LFH_LEN];\nprivate final byte[] SKIP_BUF = new byte[1024];\nprivate final byte[] SHORT_BUF = new byte[SHORT];\nprivate final byte[] WORD_BUF = new byte[WORD];\nprivate final byte[] TWO_DWORD_BUF = new byte[2 * DWORD];\nprivate int entriesRead = 0;\nthis(inputStream, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<clinit>()V",
                                    "method_body": "private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\nprivate static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\nprivate static final byte[] DD = ZipLong.DD_SIG.getBytes();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:getNextZipEntry()Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;",
                                    "method_body": "public ZipArchiveEntry getNextZipEntry() throws IOException {\nboolean firstEntry = true;\nif (closed || hitCentralDirectory) {\nif (current != null) {\ncloseEntry();\nfirstEntry = false;\nif (firstEntry) {\nreadFirstLocalFileHeader(LFH_BUF);\nreadFully(LFH_BUF);\n}\nfinal ZipLong sig = new ZipLong(LFH_BUF);\nif (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\nhitCentralDirectory = true;\nskipRemainderOfArchive();\nif (!sig.equals(ZipLong.LFH_SIG)) {\nreturn null;\nint off = WORD;\ncurrent = new CurrentEntry();\nfinal int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\noff += SHORT;\ncurrent.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\nfinal GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\nfinal boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\nfinal ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\ncurrent.hasDataDescriptor = gpFlag.usesDataDescriptor();\ncurrent.entry.setGeneralPurposeBit(gpFlag);\noff += SHORT;\ncurrent.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\noff += SHORT;\nfinal long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\ncurrent.entry.setTime(time);\noff += WORD;\nZipLong size = null, cSize = null;\nif (!current.hasDataDescriptor) {\noff += 3 * WORD;\nfinal int fileNameLen = ZipShort.getValue(LFH_BUF, off);\noff += SHORT;\nfinal int extraLen = ZipShort.getValue(LFH_BUF, off);\noff += SHORT;\nfinal byte[] fileName = new byte[fileNameLen];\nreadFully(fileName);\ncurrent.entry.setName(entryEncoding.decode(fileName), fileName);\nfinal byte[] extraData = new byte[extraLen];\nreadFully(extraData);\ncurrent.entry.setExtra(extraData);\nif (!hasUTF8Flag && useUnicodeExtraFields) {\nZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\nprocessZip64Extra(size, cSize);\nif (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {\nentriesRead++;\nreturn current.entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readFirstLocalFileHeader([B)V",
                                    "method_body": "private void readFirstLocalFileHeader(final byte[] lfh) throws IOException {\nreadFully(lfh);\nfinal ZipLong sig = new ZipLong(lfh);\nif (sig.equals(ZipLong.DD_SIG)) {\nif (sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER)) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!closed) {\nclosed = true;\nin.close();\ninf.end();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readFully([B)V",
                                    "method_body": "private void readFully(final byte[] b) throws IOException {\nfinal int count = IOUtils.readFully(in, b);\ncount(count);\nif (count < b.length) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(final long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>([B)V",
                                    "method_body": "public ZipLong (final byte[] bytes) {\nthis(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>([BI)V",
                                    "method_body": "public ZipLong (final byte[] bytes, final int offset) {\nvalue = ZipLong.getValue(bytes, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\npublic ZipLong(final long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue()J",
                                    "method_body": "public long getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(final long value) {\nfinal byte[] result = new byte[WORD];\nputLong(value, result, 0);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:putLong(J[BI)V",
                                    "method_body": "public static void putLong(final long value, final byte[] buf, int offset) {\nbuf[offset++] = (byte) ((value & BYTE_MASK));\nbuf[offset++] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nbuf[offset++] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nbuf[offset] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(final byte[] bytes, final int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(final Object o) {\nif (o == null || !(o instanceof ZipLong)) {\nreturn value == ((ZipLong) o).getValue();\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.ZipTestCase.testListAllFilesWithNestedArchive",
                            "test_body": "243: public void testListAllFilesWithNestedArchive() throws Exception {\n244: final File input = getFile(\"OSX_ArchiveWithNestedArchive.zip\");\n245: 246: final List<String> results = new ArrayList<>();\n247: final List<ZipException> expectedExceptions = new ArrayList<>();\n248: 249: final InputStream is = new FileInputStream(input);\n250: ArchiveInputStream in = null;\n251: try {\n252: in = new ArchiveStreamFactory().createArchiveInputStream(\"zip\", is);\n253: 254: ZipArchiveEntry entry = null;\n255: while ((entry = (ZipArchiveEntry) in.getNextEntry()) != null) {\n256: results.add(entry.getName());\n257: 258: final ArchiveInputStream nestedIn = new ArchiveStreamFactory().createArchiveInputStream(\"zip\", in);\n259: try {\n260: ZipArchiveEntry nestedEntry = null;\n261: while ((nestedEntry = (ZipArchiveEntry) nestedIn.getNextEntry()) != null) {\n262: results.add(nestedEntry.getName());\n263: }\n264: } catch (ZipException ex) {\n265: // expected since you cannot create a final ArchiveInputStream from test3.xml\n266: expectedExceptions.add(ex);\n267: }\n268: // nested stream must not be closed here\n269: }\n270: } finally {\n271: if (in != null) {\n272: in.close();\n273: }\n274: }\n275: is.close();\n276: 277: assertTrue(results.contains(\"NestedArchiv.zip\"));\n278: assertTrue(results.contains(\"test1.xml\"));\n279: assertTrue(results.contains(\"test2.xml\"));\n280: assertTrue(results.contains(\"test3.xml\"));\n281: assertEquals(1, expectedExceptions.size());\n282: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(final int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(final long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\nfinal Map<String, SimpleEncodingHolder> se =\nfinal char[] cp437_high_chars =\nfinal SimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\nfinal char[] cp850_high_chars =\nfinal SimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(final String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nfor (final String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(final char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(final String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[B)I",
                                    "method_body": "public static int readFully(final InputStream input, final byte[] b) throws IOException {\nreturn readFully(input, b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(final InputStream input, final byte[] b, final int offset, final int len)\nif (len < 0 || offset < 0 || len + offset > b.length) {\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\ncount += x;\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public ZipArchiveInputStream(final InputStream inputStream) {\nthis(inputStream, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveInputStream(final InputStream inputStream, final String encoding) {\nthis(inputStream, encoding, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipArchiveInputStream(final InputStream inputStream, final String encoding, final boolean useUnicodeExtraFields) {\nthis(inputStream, encoding, useUnicodeExtraFields, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;ZZ)V",
                                    "method_body": "private final ZipEncoding zipEncoding;\nprivate final Inflater inf = new Inflater(true);\nprivate final ByteBuffer buf = ByteBuffer.allocate(ZipArchiveOutputStream.BUFFER_SIZE);\nprivate CurrentEntry current = null;\nprivate boolean closed = false;\nprivate boolean hitCentralDirectory = false;\nprivate ByteArrayInputStream lastStoredEntry = null;\nprivate boolean allowStoredEntriesWithDataDescriptor = false;\nprivate final byte[] LFH_BUF = new byte[LFH_LEN];\nprivate final byte[] SKIP_BUF = new byte[1024];\nprivate final byte[] SHORT_BUF = new byte[SHORT];\nprivate final byte[] WORD_BUF = new byte[WORD];\nprivate final byte[] TWO_DWORD_BUF = new byte[2 * DWORD];\nprivate int entriesRead = 0;\nthis(inputStream, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<clinit>()V",
                                    "method_body": "private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\nprivate static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\nprivate static final byte[] DD = ZipLong.DD_SIG.getBytes();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:getNextZipEntry()Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;",
                                    "method_body": "public ZipArchiveEntry getNextZipEntry() throws IOException {\nboolean firstEntry = true;\nif (closed || hitCentralDirectory) {\nif (current != null) {\ncloseEntry();\nfirstEntry = false;\nif (firstEntry) {\nreadFirstLocalFileHeader(LFH_BUF);\nreadFully(LFH_BUF);\n}\nfinal ZipLong sig = new ZipLong(LFH_BUF);\nif (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\nhitCentralDirectory = true;\nskipRemainderOfArchive();\nif (!sig.equals(ZipLong.LFH_SIG)) {\nreturn null;\nint off = WORD;\ncurrent = new CurrentEntry();\nfinal int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\noff += SHORT;\ncurrent.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\nfinal GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\nfinal boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\nfinal ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\ncurrent.hasDataDescriptor = gpFlag.usesDataDescriptor();\ncurrent.entry.setGeneralPurposeBit(gpFlag);\noff += SHORT;\ncurrent.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\noff += SHORT;\nfinal long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\ncurrent.entry.setTime(time);\noff += WORD;\nZipLong size = null, cSize = null;\nif (!current.hasDataDescriptor) {\noff += 3 * WORD;\nfinal int fileNameLen = ZipShort.getValue(LFH_BUF, off);\noff += SHORT;\nfinal int extraLen = ZipShort.getValue(LFH_BUF, off);\noff += SHORT;\nfinal byte[] fileName = new byte[fileNameLen];\nreadFully(fileName);\ncurrent.entry.setName(entryEncoding.decode(fileName), fileName);\nfinal byte[] extraData = new byte[extraLen];\nreadFully(extraData);\ncurrent.entry.setExtra(extraData);\nif (!hasUTF8Flag && useUnicodeExtraFields) {\nZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\nprocessZip64Extra(size, cSize);\nif (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {\nentriesRead++;\nreturn current.entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readFirstLocalFileHeader([B)V",
                                    "method_body": "private void readFirstLocalFileHeader(final byte[] lfh) throws IOException {\nreadFully(lfh);\nfinal ZipLong sig = new ZipLong(lfh);\nif (sig.equals(ZipLong.DD_SIG)) {\nif (sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER)) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!closed) {\nclosed = true;\nin.close();\ninf.end();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readFully([B)V",
                                    "method_body": "private void readFully(final byte[] b) throws IOException {\nfinal int count = IOUtils.readFully(in, b);\ncount(count);\nif (count < b.length) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(final long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>([B)V",
                                    "method_body": "public ZipLong (final byte[] bytes) {\nthis(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>([BI)V",
                                    "method_body": "public ZipLong (final byte[] bytes, final int offset) {\nvalue = ZipLong.getValue(bytes, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\npublic ZipLong(final long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue()J",
                                    "method_body": "public long getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(final long value) {\nfinal byte[] result = new byte[WORD];\nputLong(value, result, 0);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:putLong(J[BI)V",
                                    "method_body": "public static void putLong(final long value, final byte[] buf, int offset) {\nbuf[offset++] = (byte) ((value & BYTE_MASK));\nbuf[offset++] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nbuf[offset++] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nbuf[offset] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(final byte[] bytes, final int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(final Object o) {\nif (o == null || !(o instanceof ZipLong)) {\nreturn value == ((ZipLong) o).getValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:pushedBackBytes(J)V",
                                    "method_body": "protected void pushedBackBytes(final long pushedBack) {\nbytesRead -= pushedBack;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>()V",
                                    "method_body": "public ArchiveStreamFactory() {\nthis(null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ArchiveStreamFactory(final String encoding) {\nsuper();\nthis.encoding = encoding;\nthis.entryEncoding = encoding;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<clinit>()V",
                                    "method_body": "private static final int TAR_HEADER_SIZE = 512;\nprivate static final ArchiveStreamFactory SINGLETON = new ArchiveStreamFactory();\n* Constant (value {@value}) used to identify the AR archive format."
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveInputStream(Ljava/lang/String;Ljava/io/InputStream;)Lorg/apache/commons/compress/archivers/ArchiveInputStream;",
                                    "method_body": "public ArchiveInputStream createArchiveInputStream(final String archiverName, final InputStream in)\nreturn createArchiveInputStream(archiverName, in, entryEncoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveInputStream(Ljava/lang/String;Ljava/io/InputStream;Ljava/lang/String;)Lorg/apache/commons/compress/archivers/ArchiveInputStream;",
                                    "method_body": "public ArchiveInputStream createArchiveInputStream(final String archiverName, final InputStream in,\nif (archiverName == null) {\nif (in == null) {\nif (AR.equalsIgnoreCase(archiverName)) {\nif (ARJ.equalsIgnoreCase(archiverName)) {\nif (ZIP.equalsIgnoreCase(archiverName)) {\nif (actualEncoding != null) {\nreturn new ZipArchiveInputStream(in);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(final byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data,this.charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:processZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipLong;Lorg/apache/commons/compress/archivers/zip/ZipLong;)V",
                                    "method_body": "private void processZip64Extra(final ZipLong size, final ZipLong cSize) {\nfinal Zip64ExtendedInformationExtraField z64 =\ncurrent.usesZip64 = z64 != null;\nif (!current.hasDataDescriptor) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:getNextEntry()Lorg/apache/commons/compress/archivers/ArchiveEntry;",
                                    "method_body": "public ArchiveEntry getNextEntry() throws IOException {\nreturn getNextZipEntry();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:read([BII)I",
                                    "method_body": "public int read(final byte[] buffer, final int offset, final int length) throws IOException {\nif (closed) {\nif (current == null) {\nif (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\nZipUtil.checkRequestedFeatures(current.entry);\nif (!supportsDataDescriptorFor(current.entry)) {\nif (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n} else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\nread = readDeflated(buffer, offset, length);\nif (read >= 0) {\ncurrent.crc.update(buffer, offset, read);\nreturn read;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readDeflated([BII)I",
                                    "method_body": "private int readDeflated(final byte[] buffer, final int offset, final int length) throws IOException {\nfinal int read = readFromInflater(buffer, offset, length);\nif (read <= 0) {\nif (inf.finished()) {\nreturn -1;\nreturn read;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readFromInflater([BII)I",
                                    "method_body": "private int readFromInflater(final byte[] buffer, final int offset, final int length) throws IOException {\nint read = 0;\nif (inf.needsInput()) {\nfinal int l = fill();\nif (l > 0) {\ncurrent.bytesReadFromStream += buf.limit();\nread = inf.inflate(buffer, offset, length);\n}\n} while (read == 0 && inf.needsInput());\nreturn read;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:skip(J)J",
                                    "method_body": "public long skip(final long value) throws IOException {\nif (value >= 0) {\nlong skipped = 0;\nwhile (skipped < value) {\nfinal long rem = value - skipped;\nfinal int x = read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));\nif (x == -1) {\nreturn skipped;\nskipped += x;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:closeEntry()V",
                                    "method_body": "private void closeEntry() throws IOException {\nif (closed) {\nif (current == null) {\nif (currentEntryHasOutstandingBytes()) {\nskip(Long.MAX_VALUE);\nfinal long inB = current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED\nfinal int diff = (int) (current.bytesReadFromStream - inB);\nif (diff > 0) {\npushback(buf.array(), buf.limit() - diff, diff);\ncurrent.bytesReadFromStream -= diff;\nif (currentEntryHasOutstandingBytes()) {\nif (lastStoredEntry == null && current.hasDataDescriptor) {\nreadDataDescriptor();\ninf.reset();\nbuf.clear().flip();\ncurrent = null;\nlastStoredEntry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:currentEntryHasOutstandingBytes()Z",
                                    "method_body": "private boolean currentEntryHasOutstandingBytes() {\nreturn current.bytesReadFromStream <= current.entry.getCompressedSize()\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:getBytesInflated()J",
                                    "method_body": "private long getBytesInflated() {\nlong inB = inf.getBytesRead();\nif (current.bytesReadFromStream >= TWO_EXP_32) {\nreturn inB;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:fill()I",
                                    "method_body": "private int fill() throws IOException {\nif (closed) {\nfinal int length = in.read(buf.array());\nif (length > 0) {\nbuf.limit(length);\ncount(buf.limit());\ninf.setInput(buf.array(), 0, buf.limit());\nreturn length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readDataDescriptor()V",
                                    "method_body": "private void readDataDescriptor() throws IOException {\nreadFully(WORD_BUF);\nZipLong val = new ZipLong(WORD_BUF);\nif (ZipLong.DD_SIG.equals(val)) {\nreadFully(WORD_BUF);\nval = new ZipLong(WORD_BUF);\ncurrent.entry.setCrc(val.getValue());\nreadFully(TWO_DWORD_BUF);\nfinal ZipLong potentialSig = new ZipLong(TWO_DWORD_BUF, DWORD);\nif (potentialSig.equals(ZipLong.CFH_SIG) || potentialSig.equals(ZipLong.LFH_SIG)) {\npushback(TWO_DWORD_BUF, DWORD, DWORD);\ncurrent.entry.setCompressedSize(ZipLong.getValue(TWO_DWORD_BUF));\ncurrent.entry.setSize(ZipLong.getValue(TWO_DWORD_BUF, WORD));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:supportsDataDescriptorFor(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private boolean supportsDataDescriptorFor(final ZipArchiveEntry entry) {\nreturn !entry.getGeneralPurposeBit().usesDataDescriptor()\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:pushback([BII)V",
                                    "method_body": "private void pushback(final byte[] buf, final int offset, final int length) throws IOException {\n((PushbackInputStream) in).unread(buf, offset, length);\npushedBackBytes(length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:skipRemainderOfArchive()V",
                                    "method_body": "private void skipRemainderOfArchive() throws IOException {\nrealSkip(entriesRead * CFH_LEN - LFH_LEN);\nfindEocdRecord();\nrealSkip(ZipFile.MIN_EOCD_SIZE - WORD /* signature */ - SHORT /* comment len */);\nreadFully(SHORT_BUF);\nrealSkip(ZipShort.getValue(SHORT_BUF));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:findEocdRecord()V",
                                    "method_body": "private void findEocdRecord() throws IOException {\nint currentByte = -1;\nboolean skipReadCall = false;\nwhile (skipReadCall || (currentByte = readOneByte()) > -1) {\nskipReadCall = false;\nif (!isFirstByteOfEocdSig(currentByte)) {\ncontinue;\ncurrentByte = readOneByte();\nif (currentByte != ZipArchiveOutputStream.EOCD_SIG[1]) {\ncurrentByte = readOneByte();\nif (currentByte != ZipArchiveOutputStream.EOCD_SIG[2]) {\ncurrentByte = readOneByte();\nif (currentByte == -1\nbreak;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:realSkip(J)V",
                                    "method_body": "private void realSkip(final long value) throws IOException {\nif (value >= 0) {\nlong skipped = 0;\nwhile (skipped < value) {\nfinal long rem = value - skipped;\nfinal int x = in.read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));\nif (x == -1) {\ncount(x);\nskipped += x;\n}\nreturn;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readOneByte()I",
                                    "method_body": "private int readOneByte() throws IOException {\nfinal int b = in.read();\nif (b != -1) {\ncount(1);\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:isFirstByteOfEocdSig(I)Z",
                                    "method_body": "private boolean isFirstByteOfEocdSig(final int b) {\nreturn b == ZipArchiveOutputStream.EOCD_SIG[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(final byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes();\nstatic final byte[] DD_SIG = ZipLong.DD_SIG.getBytes();\nstatic final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes();\nstatic final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\nstatic final byte[] ZIP64_EOCD_SIG = ZipLong.getBytes(0X06064B50L);\nstatic final byte[] ZIP64_EOCD_LOC_SIG = ZipLong.getBytes(0X07064B50L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream$CurrentEntry:<init>()V",
                                    "method_body": "private final ZipArchiveEntry entry = new ZipArchiveEntry();\nprivate final CRC32 crc = new CRC32();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(final String name) {\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/util/zip/ZipEntry;)V",
                                    "method_body": "private long size = SIZE_UNKNOWN;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate UnparseableExtraFieldData unparseableExtra = null;\nprivate String name = null;\nprivate byte[] rawName = null;\nprivate GeneralPurposeBit gpb = new GeneralPurposeBit();\nprivate static final ZipExtraField[] noExtraFields = new ZipExtraField[0];\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "protected ZipArchiveEntry() {\nthis(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<clinit>()V",
                                    "method_body": "private long size = SIZE_UNKNOWN;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate UnparseableExtraFieldData unparseableExtra = null;\nprivate String name = null;\nprivate byte[] rawName = null;\nprivate GeneralPurposeBit gpb = new GeneralPurposeBit();\nprivate static final ZipExtraField[] noExtraFields = new ZipExtraField[0];\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getMethod()I",
                                    "method_body": "public int getMethod() {\nreturn method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setMethod(I)V",
                                    "method_body": "public void setMethod(final int method) {\nif (method < 0) {\nthis.method = method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setPlatform(I)V",
                                    "method_body": "protected void setPlatform(final int platform) {\nthis.platform = platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void setExtraFields(final ZipExtraField[] fields) {\nfinal List<ZipExtraField> newFields = new ArrayList<>();\nfor (final ZipExtraField field : fields) {\nif (field instanceof UnparseableExtraFieldData) {\nnewFields.add( field);\nextraFields = newFields.toArray(new ZipExtraField[newFields.size()]);\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getAllExtraFieldsNoCopy()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "private ZipExtraField[] getAllExtraFieldsNoCopy() {\nif (extraFields == null) {\nreturn unparseableExtra != null ? getMergedFields() : extraFields;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField getExtraField(final ZipShort type) {\nif (extraFields != null) {\nfor (final ZipExtraField extraField : extraFields) {\nif (type.equals(extraField.getHeaderId())) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra([B)V",
                                    "method_body": "public void setExtra(final byte[] extra) throws RuntimeException {\nfinal ZipExtraField[] local =\nmergeExtraFields(local, true);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getAllExtraFieldsNoCopy()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "protected void setName(String name) {\nif (name != null && getPlatform() == PLATFORM_FAT\nname = name.replace('\\\\', '/');\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(final long size) {\nif (size < 0) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;[B)V",
                                    "method_body": "protected void setName(final String name, final byte[] rawName) {\nsetName(name);\nthis.rawName = rawName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getGeneralPurposeBit()Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "public GeneralPurposeBit getGeneralPurposeBit() {\nreturn gpb;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setGeneralPurposeBit(Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;)V",
                                    "method_body": "public void setGeneralPurposeBit(final GeneralPurposeBit b) {\ngpb = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:mergeExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;Z)V",
                                    "method_body": "private void mergeExtraFields(final ZipExtraField[] f, final boolean local)\nif (extraFields == null) {\nsetExtraFields(f);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:<init>()V",
                                    "method_body": "public static final int UFT8_NAMES_FLAG = 1 << 11;\nprivate boolean languageEncodingFlag = false;\nprivate boolean dataDescriptorFlag = false;\nprivate boolean encryptionFlag = false;\nprivate boolean strongEncryptionFlag = false;\npublic GeneralPurposeBit() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesUTF8ForNames()Z",
                                    "method_body": "public boolean usesUTF8ForNames() {\nreturn languageEncodingFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useUTF8ForNames(Z)V",
                                    "method_body": "public void useUTF8ForNames(final boolean b) {\nlanguageEncodingFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesDataDescriptor()Z",
                                    "method_body": "public boolean usesDataDescriptor() {\nreturn dataDescriptorFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useDataDescriptor(Z)V",
                                    "method_body": "public void useDataDescriptor(final boolean b) {\ndataDescriptorFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesEncryption()Z",
                                    "method_body": "public boolean usesEncryption() {\nreturn encryptionFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useEncryption(Z)V",
                                    "method_body": "public void useEncryption(final boolean b) {\nencryptionFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useStrongEncryption(Z)V",
                                    "method_body": "public void useStrongEncryption(final boolean b) {\nstrongEncryptionFlag = b;\nif (b) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:parse([BI)Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "public static GeneralPurposeBit parse(final byte[] data, final int offset) {\nfinal int generalPurposeFlag = ZipShort.getValue(data, offset);\nfinal GeneralPurposeBit b = new GeneralPurposeBit();\nb.useDataDescriptor((generalPurposeFlag & DATA_DESCRIPTOR_FLAG) != 0);\nb.useUTF8ForNames((generalPurposeFlag & UFT8_NAMES_FLAG) != 0);\nb.useStrongEncryption((generalPurposeFlag & STRONG_ENCRYPTION_FLAG) != 0);\nb.useEncryption((generalPurposeFlag & ENCRYPTION_FLAG) != 0);\nb.slidingDictionarySize = (generalPurposeFlag & SLIDING_DICTIONARY_SIZE_FLAG) != 0 ? 8192 : 4096;\nb.numberOfShannonFanoTrees = (generalPurposeFlag & NUMBER_OF_SHANNON_FANO_TREES_FLAG) != 0 ? 3 : 2;\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (final int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>([BI)V",
                                    "method_body": "public ZipShort (final byte[] bytes, final int offset) {\nvalue = ZipShort.getValue(bytes, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nfinal byte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([BI)I",
                                    "method_body": "public static int getValue(final byte[] bytes, final int offset) {\nint value = (bytes[offset + 1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([B)I",
                                    "method_body": "public static int getValue(final byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(final Object o) {\nif (o == null || !(o instanceof ZipShort)) {\nreturn value == ((ZipShort) o).getValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:dosToJavaTime(J)J",
                                    "method_body": "public static long dosToJavaTime(final long dosTime) {\nfinal Calendar cal = Calendar.getInstance();\ncal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\ncal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\ncal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);\ncal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);\ncal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);\ncal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);\ncal.set(Calendar.MILLISECOND, 0);\nreturn cal.getTime().getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:setNameAndCommentFromExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;[B[B)V",
                                    "method_body": "static void setNameAndCommentFromExtraFields(final ZipArchiveEntry ze,\nfinal UnicodePathExtraField name = (UnicodePathExtraField)\nfinal String originalName = ze.getName();\nfinal String newName = getUnicodeStringIfOriginalMatches(name,\nif (newName != null && !originalName.equals(newName)) {\nif (commentBytes != null && commentBytes.length > 0) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:getUnicodeStringIfOriginalMatches(Lorg/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField;[B)Ljava/lang/String;",
                                    "method_body": "String getUnicodeStringIfOriginalMatches(final AbstractUnicodeExtraField f,\nif (f != null) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:copy([B)[B",
                                    "method_body": "static byte[] copy(final byte[] from) {\nif (from != null) {\nfinal byte[] to = new byte[from.length];\nSystem.arraycopy(from, 0, to, 0, to.length);\nreturn to;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:supportsEncryptionOf(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private static boolean supportsEncryptionOf(final ZipArchiveEntry entry) {\nreturn !entry.getGeneralPurposeBit().usesEncryption();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:supportsMethodOf(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private static boolean supportsMethodOf(final ZipArchiveEntry entry) {\nreturn entry.getMethod() == ZipEntry.STORED\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:checkRequestedFeatures(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "static void checkRequestedFeatures(final ZipArchiveEntry ze)\nif (!supportsEncryptionOf(ze)) {\nif (!supportsMethodOf(ze)) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<init>(I)V",
                                    "method_body": "private UnparseableExtraField(final int k) {\nkey = k;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<clinit>()V",
                                    "method_body": "public static final UnparseableExtraField READ\nprivate UnparseableExtraField(final int k) {\nkey = k;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\nimplementations = new ConcurrentHashMap<>();\nregister(AsiExtraField.class);\nregister(X5455_ExtendedTimestamp.class);\nregister(X7875_NewUnix.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\nregister(Zip64ExtendedInformationExtraField.class);\nregister(X000A_NTFS.class);\nregister(X0014_X509Certificates.class);\nregister(X0015_CertificateIdForFile.class);\nregister(X0016_CertificateIdForCentralDirectory.class);\nregister(X0017_StrongEncryptionHeader.class);\nregister(X0019_EncryptionRecipientCertificateList.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(final Class<?> c) {\nfinal ZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:createExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField createExtraField(final ZipShort headerId)\nfinal Class<?> c = implementations.get(headerId);\nif (c != null) {\nfinal UnrecognizedExtraField u = new UnrecognizedExtraField();\nu.setHeaderId(headerId);\nreturn u;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:parse([BZLorg/apache/commons/compress/archivers/zip/ExtraFieldUtils$UnparseableExtraField;)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField[] parse(final byte[] data, final boolean local,\nfinal List<ZipExtraField> v = new ArrayList<>();\nint start = 0;\nwhile (start <= data.length - WORD) {\nfinal ZipShort headerId = new ZipShort(data, start);\nfinal int length = new ZipShort(data, start + 2).getValue();\nif (start + WORD + length > data.length) {\nfinal ZipExtraField ze = createExtraField(headerId);\nif (local) {\nze.parseFromLocalFileData(data, start + WORD, length);\nv.add(ze);\n}\nstart += length + WORD;\n}\nfinal ZipExtraField[] result = new ZipExtraField[v.size()];\nreturn v.toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data) {\nfinal boolean lastIsUnparseableHolder = data.length > 0\nfinal int regularExtraFieldCount =\nint sum = WORD * regularExtraFieldCount;\nfor (final ZipExtraField element : data) {\nsum += element.getLocalFileDataLength().getValue();\nfinal byte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\nstart += WORD;\nfinal byte[] local = data[i].getLocalFileDataData();\nif (local != null) {\nSystem.arraycopy(local, 0, result, start, local.length);\nstart += local.length;\nif (lastIsUnparseableHolder) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<init>()V",
                                    "method_body": "public X5455_ExtendedTimestamp() {}\npublic X5455_ExtendedTimestamp() {}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x5455);\npublic X5455_ExtendedTimestamp() {}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<init>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x7875);\nprivate static final ZipShort ZERO = new ZipShort(0);\nprivate static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);\nprivate int version = 1; // always '1' according to current info-zip spec.\npublic X7875_NewUnix() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x7875);\nprivate static final ZipShort ZERO = new ZipShort(0);\nprivate static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);\nprivate int version = 1; // always '1' according to current info-zip spec.\npublic X7875_NewUnix() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:reset()V",
                                    "method_body": "private void reset() {\nuid = ONE_THOUSAND;\ngid = ONE_THOUSAND;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\npublic JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<init>()V",
                                    "method_body": "public Zip64ExtendedInformationExtraField() { }\npublic Zip64ExtendedInformationExtraField() { }"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<clinit>()V",
                                    "method_body": "static final ZipShort HEADER_ID = new ZipShort(0x0001);\nprivate static final byte[] EMPTY = new byte[0];\n* parseFromCentralDirectoryData} so it can be reused when ZipFile"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X000A_NTFS:<init>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x000a);\nprivate static final ZipShort TIME_ATTR_TAG = new ZipShort(0x0001);\nprivate static final ZipShort TIME_ATTR_SIZE = new ZipShort(3 * 8);\nprivate ZipEightByteInteger modifyTime = ZipEightByteInteger.ZERO;\nprivate ZipEightByteInteger accessTime = ZipEightByteInteger.ZERO;\nprivate ZipEightByteInteger createTime = ZipEightByteInteger.ZERO;\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X000A_NTFS:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x000a);\nprivate static final ZipShort TIME_ATTR_TAG = new ZipShort(0x0001);\nprivate static final ZipShort TIME_ATTR_SIZE = new ZipShort(3 * 8);\nprivate ZipEightByteInteger modifyTime = ZipEightByteInteger.ZERO;\nprivate ZipEightByteInteger accessTime = ZipEightByteInteger.ZERO;\nprivate ZipEightByteInteger createTime = ZipEightByteInteger.ZERO;\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X000A_NTFS:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<init>(J)V",
                                    "method_body": "public ZipEightByteInteger(final long value) {\nthis(BigInteger.valueOf(value));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<init>(Ljava/math/BigInteger;)V",
                                    "method_body": "public ZipEightByteInteger(final BigInteger value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\npublic static final ZipEightByteInteger ZERO = new ZipEightByteInteger(0);\nthis(BigInteger.valueOf(value));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.PKWareExtraHeader:<init>(Lorg/apache/commons/compress/archivers/zip/ZipShort;)V",
                                    "method_body": "protected PKWareExtraHeader(final ZipShort headerId) {\nthis.headerId = headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.PKWareExtraHeader:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0014_X509Certificates:<init>()V",
                                    "method_body": "public X0014_X509Certificates() {\nsuper(new ZipShort(0x0014));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0015_CertificateIdForFile:<init>()V",
                                    "method_body": "public X0015_CertificateIdForFile() {\nsuper(new ZipShort(0x0015));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0016_CertificateIdForCentralDirectory:<init>()V",
                                    "method_body": "public X0016_CertificateIdForCentralDirectory() {\nsuper(new ZipShort(0x0016));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0017_StrongEncryptionHeader:<init>()V",
                                    "method_body": "public X0017_StrongEncryptionHeader() {\nsuper(new ZipShort(0x0017));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0019_EncryptionRecipientCertificateList:<init>()V",
                                    "method_body": "public X0019_EncryptionRecipientCertificateList() {\nsuper(new ZipShort(0x0019));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:<init>(Ljava/lang/String;I)V",
                                    "method_body": "private ZipMethod() {\nthis(UNKNOWN_CODE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:<init>(Ljava/lang/String;II)V",
                                    "method_body": "ZipMethod(final int code) {\nthis.code = code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:getCode()I",
                                    "method_body": "public int getCode() {\nreturn code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setHeaderId(Lorg/apache/commons/compress/archivers/zip/ZipShort;)V",
                                    "method_body": "public void setHeaderId(final ZipShort headerId) {\nthis.headerId = headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setLocalFileDataData([B)V",
                                    "method_body": "public void setLocalFileDataData(final byte[] data) {\nlocalData = ZipUtil.copy(data);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn new ZipShort(localData != null ? localData.length : 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn ZipUtil.copy(localData);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:parseFromLocalFileData([BII)V",
                                    "method_body": "public void parseFromLocalFileData(final byte[] data, final int offset, final int length) {\nfinal byte[] tmp = new byte[length];\nSystem.arraycopy(data, offset, tmp, 0, length);\nsetLocalFileDataData(tmp);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 42,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveEntryTest.isUnixSymlinkIsFalseIfMoreThanOneFlagIsSet",
                            "test_body": "277: public void isUnixSymlinkIsFalseIfMoreThanOneFlagIsSet() throws Exception {\n278: try (ZipFile zf = new ZipFile(getFile(\"COMPRESS-379.jar\"))) {\n279: ZipArchiveEntry ze = zf.getEntry(\"META-INF/maven/\");\n280: assertFalse(ze.isUnixSymlink());\n281: }\n282: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\nfinal Map<String, SimpleEncodingHolder> se =\nfinal char[] cp437_high_chars =\nfinal SimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\nfinal char[] cp850_high_chars =\nfinal SimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(final String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nfor (final String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(final char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(final String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(final byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data,this.charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/nio/channels/ReadableByteChannel;Ljava/nio/ByteBuffer;)V",
                                    "method_body": "public static void readFully(ReadableByteChannel channel, ByteBuffer b) throws IOException {\nfinal int expectedLength = b.remaining();\nint read = 0;\nwhile (read < expectedLength) {\nint readNow = channel.read(b);\nif (readNow <= 0) {\nread += readNow;\n}\nif (read < expectedLength) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(final long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\npublic ZipLong(final long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(final long value) {\nfinal byte[] result = new byte[WORD];\nputLong(value, result, 0);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:putLong(J[BI)V",
                                    "method_body": "public static void putLong(final long value, final byte[] buf, int offset) {\nbuf[offset++] = (byte) ((value & BYTE_MASK));\nbuf[offset++] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nbuf[offset++] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nbuf[offset] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(final byte[] bytes, final int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(final byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes(); //NOSONAR\nstatic final byte[] DD_SIG = ZipLong.DD_SIG.getBytes(); //NOSONAR\nstatic final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes(); //NOSONAR\nstatic final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L); //NOSONAR\nstatic final byte[] ZIP64_EOCD_SIG = ZipLong.getBytes(0X06064B50L); //NOSONAR\nstatic final byte[] ZIP64_EOCD_LOC_SIG = ZipLong.getBytes(0X07064B50L); //NOSONAR\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(final String name) {\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/util/zip/ZipEntry;)V",
                                    "method_body": "private long size = SIZE_UNKNOWN;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate UnparseableExtraFieldData unparseableExtra = null;\nprivate String name = null;\nprivate byte[] rawName = null;\nprivate GeneralPurposeBit gpb = new GeneralPurposeBit();\nprivate static final ZipExtraField[] noExtraFields = new ZipExtraField[0];\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "protected ZipArchiveEntry() {\nthis(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<clinit>()V",
                                    "method_body": "private long size = SIZE_UNKNOWN;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate UnparseableExtraFieldData unparseableExtra = null;\nprivate String name = null;\nprivate byte[] rawName = null;\nprivate GeneralPurposeBit gpb = new GeneralPurposeBit();\nprivate static final ZipExtraField[] noExtraFields = new ZipExtraField[0];\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setMethod(I)V",
                                    "method_body": "public void setMethod(final int method) {\nif (method < 0) {\nthis.method = method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setInternalAttributes(I)V",
                                    "method_body": "public void setInternalAttributes(final int value) {\ninternalAttributes = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExternalAttributes()J",
                                    "method_body": "public long getExternalAttributes() {\nreturn externalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExternalAttributes(J)V",
                                    "method_body": "public void setExternalAttributes(final long value) {\nexternalAttributes = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getUnixMode()I",
                                    "method_body": "public int getUnixMode() {\nreturn platform != PLATFORM_UNIX ? 0 :\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:isUnixSymlink()Z",
                                    "method_body": "public boolean isUnixSymlink() {\nreturn (getUnixMode() & UnixStat.LINK_FLAG) == UnixStat.LINK_FLAG;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setPlatform(I)V",
                                    "method_body": "protected void setPlatform(final int platform) {\nthis.platform = platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void setExtraFields(final ZipExtraField[] fields) {\nfinal List<ZipExtraField> newFields = new ArrayList<>();\nfor (final ZipExtraField field : fields) {\nextraFields = newFields.toArray(new ZipExtraField[newFields.size()]);\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getAllExtraFieldsNoCopy()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "private ZipExtraField[] getAllExtraFieldsNoCopy() {\nif (extraFields == null) {\nreturn unparseableExtra != null ? getMergedFields() : extraFields;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField getExtraField(final ZipShort type) {\nif (extraFields != null) {\nfor (final ZipExtraField extraField : extraFields) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra([B)V",
                                    "method_body": "public void setExtra(final byte[] extra) throws RuntimeException {\nfinal ZipExtraField[] local =\nmergeExtraFields(local, true);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getAllExtraFieldsNoCopy()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setCentralDirectoryExtra([B)V",
                                    "method_body": "public void setCentralDirectoryExtra(final byte[] b) {\nfinal ZipExtraField[] central =\nmergeExtraFields(central, false);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "protected void setName(String name) {\nif (name != null && getPlatform() == PLATFORM_FAT\nname = name.replace('\\\\', '/');\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(final long size) {\nif (size < 0) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;[B)V",
                                    "method_body": "protected void setName(final String name, final byte[] rawName) {\nsetName(name);\nthis.rawName = rawName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setGeneralPurposeBit(Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;)V",
                                    "method_body": "public void setGeneralPurposeBit(final GeneralPurposeBit b) {\ngpb = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:mergeExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;Z)V",
                                    "method_body": "private void mergeExtraFields(final ZipExtraField[] f, final boolean local)\nif (extraFields == null) {\nsetExtraFields(f);\nfor (final ZipExtraField element : f) {\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setVersionMadeBy(I)V",
                                    "method_body": "public void setVersionMadeBy(final int versionMadeBy) {\nthis.versionMadeBy = versionMadeBy;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setVersionRequired(I)V",
                                    "method_body": "public void setVersionRequired(final int versionRequired) {\nthis.versionRequired = versionRequired;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setRawFlag(I)V",
                                    "method_body": "public void setRawFlag(final int rawFlag) {\nthis.rawFlag = rawFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:<init>()V",
                                    "method_body": "public static final int UFT8_NAMES_FLAG = 1 << 11;\nprivate boolean languageEncodingFlag = false;\nprivate boolean dataDescriptorFlag = false;\nprivate boolean encryptionFlag = false;\nprivate boolean strongEncryptionFlag = false;\npublic GeneralPurposeBit() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesUTF8ForNames()Z",
                                    "method_body": "public boolean usesUTF8ForNames() {\nreturn languageEncodingFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useUTF8ForNames(Z)V",
                                    "method_body": "public void useUTF8ForNames(final boolean b) {\nlanguageEncodingFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useDataDescriptor(Z)V",
                                    "method_body": "public void useDataDescriptor(final boolean b) {\ndataDescriptorFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useEncryption(Z)V",
                                    "method_body": "public void useEncryption(final boolean b) {\nencryptionFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useStrongEncryption(Z)V",
                                    "method_body": "public void useStrongEncryption(final boolean b) {\nstrongEncryptionFlag = b;\nif (b) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:parse([BI)Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "public static GeneralPurposeBit parse(final byte[] data, final int offset) {\nfinal int generalPurposeFlag = ZipShort.getValue(data, offset);\nfinal GeneralPurposeBit b = new GeneralPurposeBit();\nb.useDataDescriptor((generalPurposeFlag & DATA_DESCRIPTOR_FLAG) != 0);\nb.useUTF8ForNames((generalPurposeFlag & UFT8_NAMES_FLAG) != 0);\nb.useStrongEncryption((generalPurposeFlag & STRONG_ENCRYPTION_FLAG) != 0);\nb.useEncryption((generalPurposeFlag & ENCRYPTION_FLAG) != 0);\nb.slidingDictionarySize = (generalPurposeFlag & SLIDING_DICTIONARY_SIZE_FLAG) != 0 ? 8192 : 4096;\nb.numberOfShannonFanoTrees = (generalPurposeFlag & NUMBER_OF_SHANNON_FANO_TREES_FLAG) != 0 ? 3 : 2;\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (final int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([BI)I",
                                    "method_body": "public static int getValue(final byte[] bytes, final int offset) {\nint value = (bytes[offset + 1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([B)I",
                                    "method_body": "public static int getValue(final byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:dosToJavaTime(J)J",
                                    "method_body": "public static long dosToJavaTime(final long dosTime) {\nfinal Calendar cal = Calendar.getInstance();\ncal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\ncal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\ncal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);\ncal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);\ncal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);\ncal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);\ncal.set(Calendar.MILLISECOND, 0);\nreturn cal.getTime().getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<init>(I)V",
                                    "method_body": "private UnparseableExtraField(final int k) {\nkey = k;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<clinit>()V",
                                    "method_body": "public static final UnparseableExtraField READ\nprivate UnparseableExtraField(final int k) {\nkey = k;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\nimplementations = new ConcurrentHashMap<>();\nregister(AsiExtraField.class);\nregister(X5455_ExtendedTimestamp.class);\nregister(X7875_NewUnix.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\nregister(Zip64ExtendedInformationExtraField.class);\nregister(X000A_NTFS.class);\nregister(X0014_X509Certificates.class);\nregister(X0015_CertificateIdForFile.class);\nregister(X0016_CertificateIdForCentralDirectory.class);\nregister(X0017_StrongEncryptionHeader.class);\nregister(X0019_EncryptionRecipientCertificateList.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(final Class<?> c) {\nfinal ZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:parse([BZLorg/apache/commons/compress/archivers/zip/ExtraFieldUtils$UnparseableExtraField;)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField[] parse(final byte[] data, final boolean local,\nfinal List<ZipExtraField> v = new ArrayList<>();\nint start = 0;\nwhile (start <= data.length - WORD) {\nfinal ZipExtraField[] result = new ZipExtraField[v.size()];\nreturn v.toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data) {\nfinal boolean lastIsUnparseableHolder = data.length > 0\nfinal int regularExtraFieldCount =\nint sum = WORD * regularExtraFieldCount;\nfor (final ZipExtraField element : data) {\nfinal byte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\nif (lastIsUnparseableHolder) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<init>()V",
                                    "method_body": "public X5455_ExtendedTimestamp() {}\npublic X5455_ExtendedTimestamp() {}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x5455);\npublic X5455_ExtendedTimestamp() {}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<init>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x7875);\nprivate static final ZipShort ZERO = new ZipShort(0);\nprivate static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);\nprivate int version = 1; // always '1' according to current info-zip spec.\npublic X7875_NewUnix() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x7875);\nprivate static final ZipShort ZERO = new ZipShort(0);\nprivate static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);\nprivate int version = 1; // always '1' according to current info-zip spec.\npublic X7875_NewUnix() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:reset()V",
                                    "method_body": "private void reset() {\nuid = ONE_THOUSAND;\ngid = ONE_THOUSAND;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\npublic JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<init>()V",
                                    "method_body": "public Zip64ExtendedInformationExtraField() { }\npublic Zip64ExtendedInformationExtraField() { }"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<clinit>()V",
                                    "method_body": "static final ZipShort HEADER_ID = new ZipShort(0x0001);\nprivate static final byte[] EMPTY = new byte[0];\n* parseFromCentralDirectoryData} so it can be reused when ZipFile"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X000A_NTFS:<init>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x000a);\nprivate static final ZipShort TIME_ATTR_TAG = new ZipShort(0x0001);\nprivate static final ZipShort TIME_ATTR_SIZE = new ZipShort(3 * 8);\nprivate ZipEightByteInteger modifyTime = ZipEightByteInteger.ZERO;\nprivate ZipEightByteInteger accessTime = ZipEightByteInteger.ZERO;\nprivate ZipEightByteInteger createTime = ZipEightByteInteger.ZERO;\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X000A_NTFS:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x000a);\nprivate static final ZipShort TIME_ATTR_TAG = new ZipShort(0x0001);\nprivate static final ZipShort TIME_ATTR_SIZE = new ZipShort(3 * 8);\nprivate ZipEightByteInteger modifyTime = ZipEightByteInteger.ZERO;\nprivate ZipEightByteInteger accessTime = ZipEightByteInteger.ZERO;\nprivate ZipEightByteInteger createTime = ZipEightByteInteger.ZERO;\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X000A_NTFS:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<init>(J)V",
                                    "method_body": "public ZipEightByteInteger(final long value) {\nthis(BigInteger.valueOf(value));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<init>(Ljava/math/BigInteger;)V",
                                    "method_body": "public ZipEightByteInteger(final BigInteger value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\npublic static final ZipEightByteInteger ZERO = new ZipEightByteInteger(0);\nthis(BigInteger.valueOf(value));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.PKWareExtraHeader:<init>(Lorg/apache/commons/compress/archivers/zip/ZipShort;)V",
                                    "method_body": "protected PKWareExtraHeader(final ZipShort headerId) {\nthis.headerId = headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.PKWareExtraHeader:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0014_X509Certificates:<init>()V",
                                    "method_body": "public X0014_X509Certificates() {\nsuper(new ZipShort(0x0014));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0015_CertificateIdForFile:<init>()V",
                                    "method_body": "public X0015_CertificateIdForFile() {\nsuper(new ZipShort(0x0015));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0016_CertificateIdForCentralDirectory:<init>()V",
                                    "method_body": "public X0016_CertificateIdForCentralDirectory() {\nsuper(new ZipShort(0x0016));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0017_StrongEncryptionHeader:<init>()V",
                                    "method_body": "public X0017_StrongEncryptionHeader() {\nsuper(new ZipShort(0x0017));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0019_EncryptionRecipientCertificateList:<init>()V",
                                    "method_body": "public X0019_EncryptionRecipientCertificateList() {\nsuper(new ZipShort(0x0019));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipFile(final File f) throws IOException {\nthis(f, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;)V",
                                    "method_body": "public ZipFile(final File f, final String encoding) throws IOException {\nthis(f, encoding, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(final File f, final String encoding, final boolean useUnicodeExtraFields)\nthis(Files.newByteChannel(f.toPath(), EnumSet.of(StandardOpenOption.READ)),\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/nio/channels/SeekableByteChannel;Ljava/lang/String;Ljava/lang/String;ZZ)V",
                                    "method_body": "private ZipFile(final SeekableByteChannel channel, final String archiveName,\nthrows IOException {\nthis.archiveName = archiveName;\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = channel;\nboolean success = false;\nfinal Map<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag =\nresolveLocalFileHeaderData(entriesWithoutUTF8Flag);\nsuccess = true;\nclosed = !success;\nif (!success && closeOnError) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<clinit>()V",
                                    "method_body": "private static final int CFH_LEN =\nprivate static final long CFH_SIG =\nfinal HashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\npositionAtCentralDirectory();\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nlong sig = ZipLong.getValue(wordBuf);\nif (sig != CFH_SIG && startsWithLocalFileHeader()) {\nwhile (sig == CFH_SIG) {\nreadCentralDirectoryEntry(noUTF8Flag);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nsig = ZipLong.getValue(wordBuf);\nreturn noUTF8Flag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:close()V",
                                    "method_body": "public void close() throws IOException {\nclosed = true;\narchive.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:getEntry(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;",
                                    "method_body": "public ZipArchiveEntry getEntry(final String name) {\nfinal LinkedList<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\nreturn entriesOfThatName != null ? entriesOfThatName.getFirst() : null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory()\nfinal HashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\npositionAtCentralDirectory();\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nlong sig = ZipLong.getValue(wordBuf);\nif (sig != CFH_SIG && startsWithLocalFileHeader()) {\nwhile (sig == CFH_SIG) {\nreadCentralDirectoryEntry(noUTF8Flag);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nsig = ZipLong.getValue(wordBuf);\nreturn noUTF8Flag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:readCentralDirectoryEntry(Ljava/util/Map;)V",
                                    "method_body": "private void\ncfhBbuf.rewind();\nIOUtils.readFully(archive, cfhBbuf);\nint off = 0;\nfinal OffsetEntry offset = new OffsetEntry();\nfinal Entry ze = new Entry(offset);\nfinal int versionMadeBy = ZipShort.getValue(cfhBuf, off);\noff += SHORT;\nze.setVersionMadeBy(versionMadeBy);\nze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\nze.setVersionRequired(ZipShort.getValue(cfhBuf, off));\noff += SHORT; // version required\nfinal GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(cfhBuf, off);\nfinal boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\nfinal ZipEncoding entryEncoding =\nze.setGeneralPurposeBit(gpFlag);\nze.setRawFlag(ZipShort.getValue(cfhBuf, off));\noff += SHORT;\nze.setMethod(ZipShort.getValue(cfhBuf, off));\noff += SHORT;\nfinal long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfhBuf, off));\nze.setTime(time);\noff += WORD;\nze.setCrc(ZipLong.getValue(cfhBuf, off));\noff += WORD;\nze.setCompressedSize(ZipLong.getValue(cfhBuf, off));\noff += WORD;\nze.setSize(ZipLong.getValue(cfhBuf, off));\noff += WORD;\nfinal int fileNameLen = ZipShort.getValue(cfhBuf, off);\noff += SHORT;\nfinal int extraLen = ZipShort.getValue(cfhBuf, off);\noff += SHORT;\nfinal int commentLen = ZipShort.getValue(cfhBuf, off);\noff += SHORT;\nfinal int diskStart = ZipShort.getValue(cfhBuf, off);\noff += SHORT;\nze.setInternalAttributes(ZipShort.getValue(cfhBuf, off));\noff += SHORT;\nze.setExternalAttributes(ZipLong.getValue(cfhBuf, off));\noff += WORD;\nfinal byte[] fileName = new byte[fileNameLen];\nIOUtils.readFully(archive, ByteBuffer.wrap(fileName));\nze.setName(entryEncoding.decode(fileName), fileName);\noffset.headerOffset = ZipLong.getValue(cfhBuf, off);\nentries.add(ze);\nfinal byte[] cdExtraData = new byte[extraLen];\nIOUtils.readFully(archive, ByteBuffer.wrap(cdExtraData));\nze.setCentralDirectoryExtra(cdExtraData);\nsetSizesAndOffsetFromZip64Extra(ze, offset, diskStart);\nfinal byte[] comment = new byte[commentLen];\nIOUtils.readFully(archive, ByteBuffer.wrap(comment));\nze.setComment(entryEncoding.decode(comment));\nif (!hasUTF8Flag && useUnicodeExtraFields) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:setSizesAndOffsetFromZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Lorg/apache/commons/compress/archivers/zip/ZipFile$OffsetEntry;I)V",
                                    "method_body": "private void setSizesAndOffsetFromZip64Extra(final ZipArchiveEntry ze,\nfinal Zip64ExtendedInformationExtraField z64 =\nif (z64 != null) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\npositionAtEndOfCentralDirectoryRecord();\nboolean found = false;\nfinal boolean searchedForZip64EOCD =\nif (searchedForZip64EOCD) {\narchive.position(archive.position() - ZIP64_EOCDL_LENGTH);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nfound = Arrays.equals(ZipArchiveOutputStream.ZIP64_EOCD_LOC_SIG,\nif (!found) {\nif (searchedForZip64EOCD) {\nskipBytes(ZIP64_EOCDL_LENGTH - WORD);\npositionAtCentralDirectory32();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory32()V",
                                    "method_body": "private void positionAtCentralDirectory32()\nskipBytes(CFD_LOCATOR_OFFSET);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\narchive.position(ZipLong.getValue(wordBuf));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtEndOfCentralDirectoryRecord()V",
                                    "method_body": "private void positionAtEndOfCentralDirectoryRecord()\nfinal boolean found = tryToLocateSignature(MIN_EOCD_SIZE, MAX_EOCD_SIZE,\nif (!found) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:tryToLocateSignature(JJ[B)Z",
                                    "method_body": "private boolean tryToLocateSignature(final long minDistanceFromEnd,\nboolean found = false;\nlong off = archive.size() - minDistanceFromEnd;\nfinal long stopSearching =\nif (off >= 0) {\nfor (; off >= stopSearching; off--) {\narchive.position(off);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nwordBbuf.flip();\n}\nint curr = wordBbuf.get();\nif (curr == sig[POS_0]) {\ncurr = wordBbuf.get();\nif (curr == sig[POS_1]) {\ncurr = wordBbuf.get();\nif (curr == sig[POS_2]) {\ncurr = wordBbuf.get();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\nif (found) {\narchive.position(off);\nreturn found;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:skipBytes(I)V",
                                    "method_body": "private void skipBytes(final int count) throws IOException {\nlong currentPosition = archive.position();\nlong newPosition = currentPosition + count;\nif (newPosition > archive.size()) {\narchive.position(newPosition);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:resolveLocalFileHeaderData(Ljava/util/Map;)V",
                                    "method_body": "private void resolveLocalFileHeaderData(final Map<ZipArchiveEntry, NameAndComment>\nfor (final ZipArchiveEntry zipArchiveEntry : entries) {\nfinal Entry ze = (Entry) zipArchiveEntry;\nfinal OffsetEntry offsetEntry = ze.getOffsetEntry();\nfinal long offset = offsetEntry.headerOffset;\narchive.position(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nwordBbuf.flip();\nwordBbuf.get(shortBuf);\nfinal int fileNameLen = ZipShort.getValue(shortBuf);\nwordBbuf.get(shortBuf);\nfinal int extraFieldLen = ZipShort.getValue(shortBuf);\nskipBytes(fileNameLen);\nfinal byte[] localExtraData = new byte[extraFieldLen];\nIOUtils.readFully(archive, ByteBuffer.wrap(localExtraData));\nze.setExtra(localExtraData);\noffsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\nif (entriesWithoutUTF8Flag.containsKey(ze)) {\nfinal String name = ze.getName();\nLinkedList<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\nif (entriesOfThatName == null) {\nentriesOfThatName = new LinkedList<>();\nnameMap.put(name, entriesOfThatName);\nentriesOfThatName.addLast(ze);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$OffsetEntry:access$002(Lorg/apache/commons/compress/archivers/zip/ZipFile$OffsetEntry;J)J",
                                    "method_body": "private static final int HASH_SIZE = 509;\nprivate final List<ZipArchiveEntry> entries =\nprivate final Map<String, LinkedList<ZipArchiveEntry>> nameMap =\nprivate static final class OffsetEntry {\nprivate long headerOffset = -1;\nprivate long dataOffset = -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$OffsetEntry:<init>()V",
                                    "method_body": "private static final int HASH_SIZE = 509;\nprivate final List<ZipArchiveEntry> entries =\nprivate final Map<String, LinkedList<ZipArchiveEntry>> nameMap =\nprivate static final class OffsetEntry {\nprivate long headerOffset = -1;\nprivate long dataOffset = -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$Entry:<init>(Lorg/apache/commons/compress/archivers/zip/ZipFile$OffsetEntry;)V",
                                    "method_body": "Entry(final OffsetEntry offset) {\nthis.offsetEntry = offset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$Entry:getOffsetEntry()Lorg/apache/commons/compress/archivers/zip/ZipFile$OffsetEntry;",
                                    "method_body": "OffsetEntry getOffsetEntry() {\nreturn offsetEntry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$Entry:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn 3 * super.hashCode()\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 43,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.DataDescriptorTest.doesntWriteDataDescriptorWhenAddingRawEntries",
                            "test_body": "135: public void doesntWriteDataDescriptorWhenAddingRawEntries() throws IOException {\n136: ByteArrayOutputStream init = new ByteArrayOutputStream();\n137: try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(init)) {\n138: zos.putArchiveEntry(new ZipArchiveEntry(\"test1.txt\"));\n139: zos.write(\"foo\".getBytes(\"UTF-8\"));\n140: zos.closeArchiveEntry();\n141: }\n142: 143: File f = new File(dir, \"test.zip\");\n144: try (FileOutputStream fos = new FileOutputStream(f)) {\n145: fos.write(init.toByteArray());\n146: }\n147: 148: ByteArrayOutputStream o = new ByteArrayOutputStream();\n149: ZipArchiveEntry zae;\n150: try (ZipFile zf = new ZipFile(f);\n151: ZipArchiveOutputStream zos = new ZipArchiveOutputStream(o)) {\n152: zae = zf.getEntry(\"test1.txt\");\n153: zos.addRawArchiveEntry(zae, zf.getRawInputStream(zae));\n154: }\n155: 156: byte[] data = o.toByteArray();\n157: byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);\n158: // still 2.0 because of Deflate\n159: assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);\n160: byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);\n161: // no DD but EFS flag\n162: assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);\n163: 164: int cdhStart = findCentralDirectory(data);\n165: byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);\n166: assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);\n167: byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);\n168: assertArrayEquals(new byte[] { 0, 8 }, gpbInCDH);\n169: 170: int ddStart = cdhStart - 16;\n171: assertNotEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));\n172: long crcFromLFH = ZipLong.getValue(data, 14);\n173: long cSizeFromLFH = ZipLong.getValue(data, 18);\n174: long sizeFromLFH = ZipLong.getValue(data, 22);\n175: assertEquals(3, sizeFromLFH);\n176: 177: long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);\n178: assertEquals(crcFromLFH, crcFromCDH);\n179: long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);\n180: assertEquals(cSizeFromLFH, cSizeFromCDH);\n181: long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);\n182: assertEquals(sizeFromLFH, sizeFromCDH);\n183: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveOutputStream:count(I)V",
                                    "method_body": "protected void count(final int written) {\ncount((long) written);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveOutputStream:count(J)V",
                                    "method_body": "protected void count(final long written) {\nif (written != -1) {\nbytesWritten = bytesWritten + written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\nfinal Map<String, SimpleEncodingHolder> se =\nfinal char[] cp437_high_chars =\nfinal SimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\nfinal char[] cp850_high_chars =\nfinal SimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(final String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nfor (final String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(final char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(final String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:canEncode(Ljava/lang/String;)Z",
                                    "method_body": "public boolean canEncode(final String name) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(final String name) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn ByteBuffer.wrap(name.getBytes(this.charsetName));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(final byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data,this.charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/nio/channels/ReadableByteChannel;Ljava/nio/ByteBuffer;)V",
                                    "method_body": "public static void readFully(ReadableByteChannel channel, ByteBuffer b) throws IOException {\nfinal int expectedLength = b.remaining();\nint read = 0;\nwhile (read < expectedLength) {\nint readNow = channel.read(b);\nif (readNow <= 0) {\nread += readNow;\n}\nif (read < expectedLength) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ByteUtils:fromLittleEndian([BII)J",
                                    "method_body": "public static long fromLittleEndian(byte[] bytes, final int off, final int length) {\ncheckReadLength(length);\nlong l = 0;\nfor (int i = 0; i < length; i++) {\nl |= (bytes[off + i] & 0xffl) << (8 * i);\nreturn l;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ByteUtils:toLittleEndian([BJII)V",
                                    "method_body": "public static void toLittleEndian(final byte[] b, final long value, final int off, final int length) {\nlong num = value;\nfor (int i = 0; i < length; i++) {\nb[off + i] = (byte) (num & 0xff);\nnum >>= 8;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ByteUtils:checkReadLength(I)V",
                                    "method_body": "private static final void checkReadLength(int length) {\nif (length > 8) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(final long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\npublic ZipLong(final long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(final long value) {\nfinal byte[] result = new byte[WORD];\nputLong(value, result, 0);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:putLong(J[BI)V",
                                    "method_body": "public static void putLong(final long value, final byte[] buf, int offset) {\nByteUtils.toLittleEndian(buf, value, offset, 4);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(final byte[] bytes, final int offset) {\nreturn ByteUtils.fromLittleEndian(bytes, offset, 4);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(final byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public ZipArchiveOutputStream(final OutputStream out) {\nthis.out = out;\nthis.channel = null;\ndef = new Deflater(level, true);\nstreamCompressor = StreamCompressor.create(out, def);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/nio/channels/SeekableByteChannel;)V",
                                    "method_body": "private ZipEncoding zipEncoding =\nprivate boolean useUTF8Flag = true;\nprivate boolean fallbackToUTF8 = false;\nprivate UnicodeExtraFieldPolicy createUnicodeExtraFields = UnicodeExtraFieldPolicy.NEVER;\nprivate boolean hasUsedZip64 = false;\nprivate Zip64Mode zip64Mode = Zip64Mode.AsNeeded;\nprivate final byte[] copyBuffer = new byte[32768];\nprivate final Calendar calendarInstance = Calendar.getInstance();\npublic ZipArchiveOutputStream(final OutputStream out) {\nthis.out = out;\nthis.channel = null;\ndef = new Deflater(level, true);\nstreamCompressor = StreamCompressor.create(out, def);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes(); //NOSONAR\nstatic final byte[] DD_SIG = ZipLong.DD_SIG.getBytes(); //NOSONAR\nstatic final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes(); //NOSONAR\nstatic final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L); //NOSONAR\nstatic final byte[] ZIP64_EOCD_SIG = ZipLong.getBytes(0X06064B50L); //NOSONAR\nstatic final byte[] ZIP64_EOCD_LOC_SIG = ZipLong.getBytes(0X07064B50L); //NOSONAR\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif (finished) {\nif (entry != null) {\ncdOffset = streamCompressor.getTotalBytesWritten();\nwriteCentralDirectoryInChunks();\ncdLength = streamCompressor.getTotalBytesWritten() - cdOffset;\nwriteZip64CentralDirectory();\nwriteCentralDirectoryEnd();\nmetaData.clear();\nentries.clear();\nstreamCompressor.close();\nfinished = true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryInChunks()V",
                                    "method_body": "private void writeCentralDirectoryInChunks() throws IOException {\nfinal int NUM_PER_WRITE = 1000;\nfinal ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(70 * NUM_PER_WRITE);\nint count = 0;\nfor (final ZipArchiveEntry ze : entries) {\nbyteArrayOutputStream.write(createCentralFileHeader(ze));\nif (++count > NUM_PER_WRITE){\n}\nwriteCounted(byteArrayOutputStream.toByteArray());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\npreClose();\nflushDeflater();\nfinal long bytesWritten = streamCompressor.getTotalBytesWritten() - entry.dataStart;\nfinal long realCrc = streamCompressor.getCrc32();\nentry.bytesRead = streamCompressor.getBytesRead();\nfinal Zip64Mode effectiveMode = getEffectiveZip64Mode(entry.entry);\nfinal boolean actuallyNeedsZip64 = handleSizesAndCrc(bytesWritten, realCrc, effectiveMode);\ncloseEntry(actuallyNeedsZip64, false);\nstreamCompressor.reset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeCopiedEntry(Z)V",
                                    "method_body": "private void closeCopiedEntry(final boolean phased) throws IOException {\npreClose();\nentry.bytesRead = entry.entry.getSize();\nfinal Zip64Mode effectiveMode = getEffectiveZip64Mode(entry.entry);\nfinal boolean actuallyNeedsZip64 = checkIfNeedsZip64(effectiveMode);\ncloseEntry(actuallyNeedsZip64, phased);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeEntry(ZZ)V",
                                    "method_body": "private void closeEntry(final boolean actuallyNeedsZip64, final boolean phased) throws IOException {\nif (!phased && channel != null) {\nif (!phased) {\nwriteDataDescriptor(entry.entry);\nentry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:preClose()V",
                                    "method_body": "private void preClose() throws IOException {\nif (finished) {\nif (entry == null) {\nif (!entry.hasWritten) {\nwrite(EMPTY, 0, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:addRawArchiveEntry(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Ljava/io/InputStream;)V",
                                    "method_body": "public void addRawArchiveEntry(final ZipArchiveEntry entry, final InputStream rawStream)\nfinal ZipArchiveEntry ae = new ZipArchiveEntry(entry);\nif (hasZip64Extra(ae)) {\nfinal boolean is2PhaseSource = ae.getCrc() != ZipArchiveEntry.CRC_UNKNOWN\nputArchiveEntry(ae, is2PhaseSource);\ncopyFromZipInputStream(rawStream);\ncloseCopiedEntry(is2PhaseSource);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:flushDeflater()V",
                                    "method_body": "private void flushDeflater() throws IOException {\nif (entry.entry.getMethod() == DEFLATED) {\nstreamCompressor.flushDeflater();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:handleSizesAndCrc(JJLorg/apache/commons/compress/archivers/zip/Zip64Mode;)Z",
                                    "method_body": "private boolean handleSizesAndCrc(final long bytesWritten, final long crc,\nif (entry.entry.getMethod() == DEFLATED) {\nentry.entry.setSize(entry.bytesRead);\nentry.entry.setCompressedSize(bytesWritten);\nentry.entry.setCrc(crc);\nreturn checkIfNeedsZip64(effectiveMode);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:checkIfNeedsZip64(Lorg/apache/commons/compress/archivers/zip/Zip64Mode;)Z",
                                    "method_body": "private boolean checkIfNeedsZip64(final Zip64Mode effectiveMode)\nfinal boolean actuallyNeedsZip64 = isZip64Required(entry.entry, effectiveMode);\nif (actuallyNeedsZip64 && effectiveMode == Zip64Mode.Never) {\nreturn actuallyNeedsZip64;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:isZip64Required(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Lorg/apache/commons/compress/archivers/zip/Zip64Mode;)Z",
                                    "method_body": "private boolean isZip64Required(final ZipArchiveEntry entry1, final Zip64Mode requestedMode) {\nreturn requestedMode == Zip64Mode.Always || isTooLageForZip32(entry1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:isTooLageForZip32(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private boolean isTooLageForZip32(final ZipArchiveEntry zipArchiveEntry){\nreturn zipArchiveEntry.getSize() >= ZIP64_MAGIC || zipArchiveEntry.getCompressedSize() >= ZIP64_MAGIC;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\nputArchiveEntry(archiveEntry, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;Z)V",
                                    "method_body": "private void putArchiveEntry(final ArchiveEntry archiveEntry, final boolean phased) throws IOException {\nif (finished) {\nif (entry != null) {\nentry = new CurrentEntry((ZipArchiveEntry) archiveEntry);\nentries.add(entry.entry);\nsetDefaults(entry.entry);\nfinal Zip64Mode effectiveMode = getEffectiveZip64Mode(entry.entry);\nvalidateSizeInformation(effectiveMode);\nif (shouldAddZip64Extra(entry.entry, effectiveMode)) {\nif (entry.entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\nwriteLocalFileHeader((ZipArchiveEntry) archiveEntry, phased);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setDefaults(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "private void setDefaults(final ZipArchiveEntry entry) {\nif (entry.getMethod() == -1) { // not specified\nentry.setMethod(method);\nif (entry.getTime() == -1) { // not specified\nentry.setTime(System.currentTimeMillis());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:validateSizeInformation(Lorg/apache/commons/compress/archivers/zip/Zip64Mode;)V",
                                    "method_body": "private void validateSizeInformation(final Zip64Mode effectiveMode)\nif (entry.entry.getMethod() == STORED && channel == null) {\nif ((entry.entry.getSize() >= ZIP64_MAGIC\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:shouldAddZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Lorg/apache/commons/compress/archivers/zip/Zip64Mode;)Z",
                                    "method_body": "private boolean shouldAddZip64Extra(final ZipArchiveEntry entry, final Zip64Mode mode) {\nreturn mode == Zip64Mode.Always\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int offset, final int length) throws IOException {\nif (entry == null) {\nZipUtil.checkRequestedFeatures(entry.entry);\nfinal long writtenThisTime = streamCompressor.write(b, offset, length, entry.entry.getMethod());\ncount(writtenThisTime);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCounted([B)V",
                                    "method_body": "private void writeCounted(final byte[] data) throws IOException {\nstreamCompressor.writeCounted(data);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:copyFromZipInputStream(Ljava/io/InputStream;)V",
                                    "method_body": "private void copyFromZipInputStream(final InputStream src) throws IOException {\nif (entry == null) {\nZipUtil.checkRequestedFeatures(entry.entry);\nentry.hasWritten = true;\nwhile ((length = src.read(copyBuffer)) >= 0 )\nstreamCompressor.writeCounted(copyBuffer, 0, length);\ncount( length );\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!finished) {\nfinish();\ndestroy();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Z)V",
                                    "method_body": "private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nfinal ByteBuffer name = getName(ze);\nif (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\nfinal long localHeaderStart = streamCompressor.getTotalBytesWritten();\nfinal byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\nmetaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\nentry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\nwriteCounted(localHeader);\nentry.dataStart = streamCompressor.getTotalBytesWritten();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:createLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Ljava/nio/ByteBuffer;ZZJ)[B",
                                    "method_body": "private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\nResourceAlignmentExtraField oldAlignmentEx =\nif (oldAlignmentEx != null) {\nint alignment = ze.getAlignment();\nif (alignment <= 0 && oldAlignmentEx != null) {\nif (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\nfinal byte[] extra = ze.getLocalFileDataExtra();\nfinal int nameLen = name.limit() - name.position();\nfinal int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\nfinal byte[] buf = new byte[len];\nSystem.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\nfinal int zipMethod = ze.getMethod();\nfinal boolean dataDescriptor = usesDataDescriptor(zipMethod);\nputShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\nfinal GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\ngeneralPurposeBit.encode(buf, LFH_GPB_OFFSET);\nputShort(zipMethod, buf, LFH_METHOD_OFFSET);\nZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\nif (phased){\nputLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n} else if (zipMethod == DEFLATED || channel != null) {\nSystem.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\nif (hasZip64Extra(entry.entry)){\n} else if (phased) {\nputLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\nputLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n} else if (zipMethod == DEFLATED || channel != null) {\nSystem.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\nSystem.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\nputShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\nputShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\nSystem.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\nSystem.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\nreturn buf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeDataDescriptor(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\nif (ze.getMethod() != DEFLATED || channel != null) {\nwriteCounted(DD_SIG);\nwriteCounted(ZipLong.getBytes(ze.getCrc()));\nif (!hasZip64Extra(ze)) {\nwriteCounted(ZipLong.getBytes(ze.getCompressedSize()));\nwriteCounted(ZipLong.getBytes(ze.getSize()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:createCentralFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)[B",
                                    "method_body": "private byte[] createCentralFileHeader(final ZipArchiveEntry ze) throws IOException {\nfinal EntryMetaData entryMetaData = metaData.get(ze);\nfinal boolean needsZip64Extra = hasZip64Extra(ze)\nif (needsZip64Extra && zip64Mode == Zip64Mode.Never) {\nhandleZip64Extra(ze, entryMetaData.offset, needsZip64Extra);\nreturn createCentralFileHeader(ze, getName(ze), entryMetaData, needsZip64Extra);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:createCentralFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Ljava/nio/ByteBuffer;Lorg/apache/commons/compress/archivers/zip/ZipArchiveOutputStream$EntryMetaData;Z)[B",
                                    "method_body": "private byte[] createCentralFileHeader(final ZipArchiveEntry ze, final ByteBuffer name,\nfinal byte[] extra = ze.getCentralDirectoryExtra();\nString comm = ze.getComment();\nif (comm == null) {\ncomm = \"\";\nfinal ByteBuffer commentB = getEntryEncoding(ze).encode(comm);\nfinal int nameLen = name.limit() - name.position();\nfinal int commentLen = commentB.limit() - commentB.position();\nfinal int len= CFH_FILENAME_OFFSET + nameLen + extra.length + commentLen;\nfinal byte[] buf = new byte[len];\nSystem.arraycopy(CFH_SIG,  0, buf, CFH_SIG_OFFSET, WORD);\nputShort((ze.getPlatform() << 8) | (!hasUsedZip64 ? DATA_DESCRIPTOR_MIN_VERSION : ZIP64_MIN_VERSION),\nfinal int zipMethod = ze.getMethod();\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nputShort(versionNeededToExtract(zipMethod, needsZip64Extra, entryMetaData.usesDataDescriptor),\ngetGeneralPurposeBits(!encodable && fallbackToUTF8, entryMetaData.usesDataDescriptor).encode(buf, CFH_GPB_OFFSET);\nputShort(zipMethod, buf, CFH_METHOD_OFFSET);\nZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, CFH_TIME_OFFSET);\nputLong(ze.getCrc(), buf, CFH_CRC_OFFSET);\nif (ze.getCompressedSize() >= ZIP64_MAGIC\nputLong(ze.getCompressedSize(), buf, CFH_COMPRESSED_SIZE_OFFSET);\nputLong(ze.getSize(), buf, CFH_ORIGINAL_SIZE_OFFSET);\nputShort(nameLen, buf, CFH_FILENAME_LENGTH_OFFSET);\nputShort(extra.length, buf, CFH_EXTRA_LENGTH_OFFSET);\nputShort(commentLen, buf, CFH_COMMENT_LENGTH_OFFSET);\nSystem.arraycopy(ZERO, 0, buf, CFH_DISK_NUMBER_OFFSET, SHORT);\nputShort(ze.getInternalAttributes(), buf, CFH_INTERNAL_ATTRIBUTES_OFFSET);\nputLong(ze.getExternalAttributes(), buf, CFH_EXTERNAL_ATTRIBUTES_OFFSET);\nif (entryMetaData.offset >= ZIP64_MAGIC || zip64Mode == Zip64Mode.Always) {\nputLong(Math.min(entryMetaData.offset, ZIP64_MAGIC), buf, CFH_LFH_OFFSET);\nSystem.arraycopy(name.array(), name.arrayOffset(), buf, CFH_FILENAME_OFFSET, nameLen);\nfinal int extraStart = CFH_FILENAME_OFFSET + nameLen;\nSystem.arraycopy(extra, 0, buf, extraStart, extra.length);\nfinal int commentStart = extraStart + extra.length;\nSystem.arraycopy(commentB.array(), commentB.arrayOffset(), buf, commentStart, commentLen);\nreturn buf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:handleZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;JZ)V",
                                    "method_body": "private void handleZip64Extra(final ZipArchiveEntry ze, final long lfhOffset,\nif (needsZip64Extra) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryEnd()V",
                                    "method_body": "protected void writeCentralDirectoryEnd() throws IOException {\nwriteCounted(EOCD_SIG);\nwriteCounted(ZERO);\nwriteCounted(ZERO);\nfinal int numberOfEntries = entries.size();\nif (numberOfEntries > ZIP64_MAGIC_SHORT\nif (cdOffset > ZIP64_MAGIC && zip64Mode == Zip64Mode.Never) {\nfinal byte[] num = ZipShort.getBytes(Math.min(numberOfEntries,\nwriteCounted(num);\nwriteCounted(num);\nwriteCounted(ZipLong.getBytes(Math.min(cdLength, ZIP64_MAGIC)));\nwriteCounted(ZipLong.getBytes(Math.min(cdOffset, ZIP64_MAGIC)));\nfinal ByteBuffer data = this.zipEncoding.encode(comment);\nfinal int dataLen = data.limit() - data.position();\nwriteCounted(ZipShort.getBytes(dataLen));\nstreamCompressor.writeCounted(data.array(), data.arrayOffset(), dataLen);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeZip64CentralDirectory()V",
                                    "method_body": "protected void writeZip64CentralDirectory() throws IOException {\nif (zip64Mode == Zip64Mode.Never) {\nif (!hasUsedZip64\nif (!hasUsedZip64) {\nreturn;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:getGeneralPurposeBits(ZZ)Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "private GeneralPurposeBit getGeneralPurposeBits(final boolean utfFallback, boolean usesDataDescriptor) {\nfinal GeneralPurposeBit b = new GeneralPurposeBit();\nb.useUTF8ForNames(useUTF8Flag || utfFallback);\nif (usesDataDescriptor) {\nb.useDataDescriptor(true);\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:versionNeededToExtract(IZZ)I",
                                    "method_body": "private int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\nif (zip64) {\nif (usedDataDescriptor) {\nreturn DATA_DESCRIPTOR_MIN_VERSION;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:usesDataDescriptor(I)Z",
                                    "method_body": "private boolean usesDataDescriptor(final int zipMethod) {\nreturn zipMethod == DEFLATED && channel == null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:hasZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private boolean hasZip64Extra(final ZipArchiveEntry ze) {\nreturn ze.getExtraField(Zip64ExtendedInformationExtraField\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:getEffectiveZip64Mode(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Lorg/apache/commons/compress/archivers/zip/Zip64Mode;",
                                    "method_body": "private Zip64Mode getEffectiveZip64Mode(final ZipArchiveEntry ze) {\nif (zip64Mode != Zip64Mode.AsNeeded\nreturn zip64Mode;\nreturn Zip64Mode.Never;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:getEntryEncoding(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "private ZipEncoding getEntryEncoding(final ZipArchiveEntry ze) {\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nreturn !encodable && fallbackToUTF8\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:getName(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Ljava/nio/ByteBuffer;",
                                    "method_body": "private ByteBuffer getName(final ZipArchiveEntry ze) throws IOException {\nreturn getEntryEncoding(ze).encode(ze.getName());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:destroy()V",
                                    "method_body": "void destroy() throws IOException {\nif (channel != null) {\nif (out != null) {\nout.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(final String name) {\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/util/zip/ZipEntry;)V",
                                    "method_body": "private long size = SIZE_UNKNOWN;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate int alignment = 0;\nprivate UnparseableExtraFieldData unparseableExtra = null;\nprivate String name = null;\nprivate byte[] rawName = null;\nprivate GeneralPurposeBit gpb = new GeneralPurposeBit();\nprivate static final ZipExtraField[] noExtraFields = new ZipExtraField[0];\nprivate long localHeaderOffset = OFFSET_UNKNOWN;\nprivate long dataOffset = OFFSET_UNKNOWN;\nprivate boolean isStreamContiguous = false;\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "public ZipArchiveEntry(final ZipArchiveEntry entry) throws ZipException {\nthis((java.util.zip.ZipEntry) entry);\nsetInternalAttributes(entry.getInternalAttributes());\nsetExternalAttributes(entry.getExternalAttributes());\nsetExtraFields(getAllExtraFieldsNoCopy());\nsetPlatform(entry.getPlatform());\nfinal GeneralPurposeBit other = entry.getGeneralPurposeBit();\nsetGeneralPurposeBit(other == null ? null :\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "protected ZipArchiveEntry() {\nthis(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<clinit>()V",
                                    "method_body": "private long size = SIZE_UNKNOWN;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate int alignment = 0;\nprivate UnparseableExtraFieldData unparseableExtra = null;\nprivate String name = null;\nprivate byte[] rawName = null;\nprivate GeneralPurposeBit gpb = new GeneralPurposeBit();\nprivate static final ZipExtraField[] noExtraFields = new ZipExtraField[0];\nprivate long localHeaderOffset = OFFSET_UNKNOWN;\nprivate long dataOffset = OFFSET_UNKNOWN;\nprivate boolean isStreamContiguous = false;\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getMethod()I",
                                    "method_body": "public int getMethod() {\nreturn method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setMethod(I)V",
                                    "method_body": "public void setMethod(final int method) {\nif (method < 0) {\nthis.method = method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getInternalAttributes()I",
                                    "method_body": "public int getInternalAttributes() {\nreturn internalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setInternalAttributes(I)V",
                                    "method_body": "public void setInternalAttributes(final int value) {\ninternalAttributes = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExternalAttributes()J",
                                    "method_body": "public long getExternalAttributes() {\nreturn externalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExternalAttributes(J)V",
                                    "method_body": "public void setExternalAttributes(final long value) {\nexternalAttributes = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setPlatform(I)V",
                                    "method_body": "protected void setPlatform(final int platform) {\nthis.platform = platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getAlignment()I",
                                    "method_body": "protected int getAlignment() {\nreturn this.alignment;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void setExtraFields(final ZipExtraField[] fields) {\nfinal List<ZipExtraField> newFields = new ArrayList<>();\nfor (final ZipExtraField field : fields) {\nextraFields = newFields.toArray(new ZipExtraField[newFields.size()]);\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getAllExtraFieldsNoCopy()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "private ZipExtraField[] getAllExtraFieldsNoCopy() {\nif (extraFields == null) {\nreturn getUnparseableOnly();\nreturn unparseableExtra != null ? getMergedFields() : extraFields;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getUnparseableOnly()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "private ZipExtraField[] getUnparseableOnly() {\nreturn unparseableExtra == null ? noExtraFields : new ZipExtraField[] { unparseableExtra };\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField getExtraField(final ZipShort type) {\nif (extraFields != null) {\nfor (final ZipExtraField extraField : extraFields) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra([B)V",
                                    "method_body": "public void setExtra(final byte[] extra) throws RuntimeException {\nfinal ZipExtraField[] local =\nmergeExtraFields(local, true);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getAllExtraFieldsNoCopy()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setCentralDirectoryExtra([B)V",
                                    "method_body": "public void setCentralDirectoryExtra(final byte[] b) {\nfinal ZipExtraField[] central =\nmergeExtraFields(central, false);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
                                    "method_body": "public byte[] getLocalFileDataExtra() {\nfinal byte[] extra = getExtra();\nreturn extra != null ? extra : EMPTY;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getCentralDirectoryExtra()[B",
                                    "method_body": "public byte[] getCentralDirectoryExtra() {\nreturn ExtraFieldUtils.mergeCentralDirectoryData(getAllExtraFieldsNoCopy());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "protected void setName(String name) {\nif (name != null && getPlatform() == PLATFORM_FAT\nname = name.replace('\\\\', '/');\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(final long size) {\nif (size < 0) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;[B)V",
                                    "method_body": "protected void setName(final String name, final byte[] rawName) {\nsetName(name);\nthis.rawName = rawName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalHeaderOffset()J",
                                    "method_body": "protected long getLocalHeaderOffset() {\nreturn this.localHeaderOffset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setLocalHeaderOffset(J)V",
                                    "method_body": "protected void setLocalHeaderOffset(long localHeaderOffset) {\nthis.localHeaderOffset = localHeaderOffset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getDataOffset()J",
                                    "method_body": "public long getDataOffset() {\nreturn dataOffset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setDataOffset(J)V",
                                    "method_body": "protected void setDataOffset(long dataOffset) {\nthis.dataOffset = dataOffset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setStreamContiguous(Z)V",
                                    "method_body": "protected void setStreamContiguous(boolean isStreamContiguous) {\nthis.isStreamContiguous = isStreamContiguous;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getGeneralPurposeBit()Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "public GeneralPurposeBit getGeneralPurposeBit() {\nreturn gpb;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setGeneralPurposeBit(Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;)V",
                                    "method_body": "public void setGeneralPurposeBit(final GeneralPurposeBit b) {\ngpb = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:mergeExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;Z)V",
                                    "method_body": "private void mergeExtraFields(final ZipExtraField[] f, final boolean local)\nif (extraFields == null) {\nsetExtraFields(f);\nfor (final ZipExtraField element : f) {\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setVersionMadeBy(I)V",
                                    "method_body": "public void setVersionMadeBy(final int versionMadeBy) {\nthis.versionMadeBy = versionMadeBy;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setVersionRequired(I)V",
                                    "method_body": "public void setVersionRequired(final int versionRequired) {\nthis.versionRequired = versionRequired;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setRawFlag(I)V",
                                    "method_body": "public void setRawFlag(final int rawFlag) {\nthis.rawFlag = rawFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:<init>()V",
                                    "method_body": "public static final int UFT8_NAMES_FLAG = 1 << 11;\nprivate boolean languageEncodingFlag = false;\nprivate boolean dataDescriptorFlag = false;\nprivate boolean encryptionFlag = false;\nprivate boolean strongEncryptionFlag = false;\npublic GeneralPurposeBit() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesUTF8ForNames()Z",
                                    "method_body": "public boolean usesUTF8ForNames() {\nreturn languageEncodingFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useUTF8ForNames(Z)V",
                                    "method_body": "public void useUTF8ForNames(final boolean b) {\nlanguageEncodingFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useDataDescriptor(Z)V",
                                    "method_body": "public void useDataDescriptor(final boolean b) {\ndataDescriptorFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesEncryption()Z",
                                    "method_body": "public boolean usesEncryption() {\nreturn encryptionFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useEncryption(Z)V",
                                    "method_body": "public void useEncryption(final boolean b) {\nencryptionFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useStrongEncryption(Z)V",
                                    "method_body": "public void useStrongEncryption(final boolean b) {\nstrongEncryptionFlag = b;\nif (b) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:encode([BI)V",
                                    "method_body": "public void encode(final byte[] buf, final int offset) {\nZipShort.putShort((dataDescriptorFlag ? DATA_DESCRIPTOR_FLAG : 0)\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:parse([BI)Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "public static GeneralPurposeBit parse(final byte[] data, final int offset) {\nfinal int generalPurposeFlag = ZipShort.getValue(data, offset);\nfinal GeneralPurposeBit b = new GeneralPurposeBit();\nb.useDataDescriptor((generalPurposeFlag & DATA_DESCRIPTOR_FLAG) != 0);\nb.useUTF8ForNames((generalPurposeFlag & UFT8_NAMES_FLAG) != 0);\nb.useStrongEncryption((generalPurposeFlag & STRONG_ENCRYPTION_FLAG) != 0);\nb.useEncryption((generalPurposeFlag & ENCRYPTION_FLAG) != 0);\nb.slidingDictionarySize = (generalPurposeFlag & SLIDING_DICTIONARY_SIZE_FLAG) != 0 ? 8192 : 4096;\nb.numberOfShannonFanoTrees = (generalPurposeFlag & NUMBER_OF_SHANNON_FANO_TREES_FLAG) != 0 ? 3 : 2;\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:clone()Ljava/lang/Object;",
                                    "method_body": "public Object clone() {\nreturn super.clone();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (final int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<clinit>()V",
                                    "method_body": "public static final ZipShort ZERO = new ZipShort(0);\npublic ZipShort (final int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes(I)[B",
                                    "method_body": "public static byte[] getBytes(final int value) {\nfinal byte[] result = new byte[2];\nputShort(value, result, 0);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:putShort(I[BI)V",
                                    "method_body": "public static void putShort(final int value, final byte[] buf, final int offset) {\nByteUtils.toLittleEndian(buf, value, offset, 2);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([BI)I",
                                    "method_body": "public static int getValue(final byte[] bytes, final int offset) {\nreturn (int) ByteUtils.fromLittleEndian(bytes, offset, 2);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([B)I",
                                    "method_body": "public static int getValue(final byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(Ljava/util/Calendar;J[BI)V",
                                    "method_body": "static void toDosTime(final Calendar c, final long t, final byte[] buf, final int offset) {\nc.setTimeInMillis(t);\nfinal int year = c.get(Calendar.YEAR);\nif (year < 1980) {\nfinal int month = c.get(Calendar.MONTH) + 1;\nfinal long value =  ((year - 1980) << 25)\nZipLong.putLong(value, buf, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:dosToJavaTime(J)J",
                                    "method_body": "public static long dosToJavaTime(final long dosTime) {\nfinal Calendar cal = Calendar.getInstance();\ncal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\ncal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\ncal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);\ncal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);\ncal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);\ncal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);\ncal.set(Calendar.MILLISECOND, 0);\nreturn cal.getTime().getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:supportsEncryptionOf(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private static boolean supportsEncryptionOf(final ZipArchiveEntry entry) {\nreturn !entry.getGeneralPurposeBit().usesEncryption();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:supportsMethodOf(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private static boolean supportsMethodOf(final ZipArchiveEntry entry) {\nreturn entry.getMethod() == ZipEntry.STORED\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:checkRequestedFeatures(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "static void checkRequestedFeatures(final ZipArchiveEntry ze)\nif (!supportsEncryptionOf(ze)) {\nif (!supportsMethodOf(ze)) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<init>(I)V",
                                    "method_body": "private UnparseableExtraField(final int k) {\nkey = k;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<clinit>()V",
                                    "method_body": "public static final int THROW_KEY = 0;\npublic static final UnparseableExtraField THROW\npublic static final UnparseableExtraField SKIP\n* UnparseableExtraFieldData UnparseableExtraFieldData}."
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\nimplementations = new ConcurrentHashMap<>();\nregister(AsiExtraField.class);\nregister(X5455_ExtendedTimestamp.class);\nregister(X7875_NewUnix.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\nregister(Zip64ExtendedInformationExtraField.class);\nregister(X000A_NTFS.class);\nregister(X0014_X509Certificates.class);\nregister(X0015_CertificateIdForFile.class);\nregister(X0016_CertificateIdForCentralDirectory.class);\nregister(X0017_StrongEncryptionHeader.class);\nregister(X0019_EncryptionRecipientCertificateList.class);\nregister(ResourceAlignmentExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(final Class<?> c) {\nfinal ZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:parse([BZLorg/apache/commons/compress/archivers/zip/ExtraFieldUtils$UnparseableExtraField;)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField[] parse(final byte[] data, final boolean local,\nfinal List<ZipExtraField> v = new ArrayList<>();\nint start = 0;\nwhile (start <= data.length - WORD) {\nfinal ZipExtraField[] result = new ZipExtraField[v.size()];\nreturn v.toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data) {\nfinal boolean lastIsUnparseableHolder = data.length > 0\nfinal int regularExtraFieldCount =\nint sum = WORD * regularExtraFieldCount;\nfor (final ZipExtraField element : data) {\nfinal byte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\nif (lastIsUnparseableHolder) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeCentralDirectoryData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data) {\nfinal boolean lastIsUnparseableHolder = data.length > 0\nfinal int regularExtraFieldCount =\nint sum = WORD * regularExtraFieldCount;\nfor (final ZipExtraField element : data) {\nfinal byte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\nif (lastIsUnparseableHolder) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate int mode = 0;\nprivate int uid = 0;\nprivate int gid = 0;\nprivate String link = \"\";\nprivate boolean dirFlag = false;\nprivate CRC32 crc = new CRC32();\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<init>()V",
                                    "method_body": "public X5455_ExtendedTimestamp() {}\npublic X5455_ExtendedTimestamp() {}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x5455);\npublic X5455_ExtendedTimestamp() {}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<init>()V",
                                    "method_body": "public X7875_NewUnix() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x7875);\nprivate static final ZipShort ZERO = new ZipShort(0);\nprivate static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);\nprivate int version = 1; // always '1' according to current info-zip spec.\npublic X7875_NewUnix() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:reset()V",
                                    "method_body": "private void reset() {\nuid = ONE_THOUSAND;\ngid = ONE_THOUSAND;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\npublic JarMarker() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<init>()V",
                                    "method_body": "public Zip64ExtendedInformationExtraField() { }\npublic Zip64ExtendedInformationExtraField() { }"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<clinit>()V",
                                    "method_body": "static final ZipShort HEADER_ID = new ZipShort(0x0001);\nprivate static final byte[] EMPTY = new byte[0];\n* parseFromCentralDirectoryData} so it can be reused when ZipFile"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X000A_NTFS:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x000a);\nprivate static final ZipShort TIME_ATTR_TAG = new ZipShort(0x0001);\nprivate static final ZipShort TIME_ATTR_SIZE = new ZipShort(3 * 8);\nprivate ZipEightByteInteger modifyTime = ZipEightByteInteger.ZERO;\nprivate ZipEightByteInteger accessTime = ZipEightByteInteger.ZERO;\nprivate ZipEightByteInteger createTime = ZipEightByteInteger.ZERO;\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X000A_NTFS:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<init>(J)V",
                                    "method_body": "public ZipEightByteInteger(final long value) {\nthis(BigInteger.valueOf(value));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<init>(Ljava/math/BigInteger;)V",
                                    "method_body": "public ZipEightByteInteger(final BigInteger value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\npublic static final ZipEightByteInteger ZERO = new ZipEightByteInteger(0);\nthis(BigInteger.valueOf(value));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.PKWareExtraHeader:<init>(Lorg/apache/commons/compress/archivers/zip/ZipShort;)V",
                                    "method_body": "protected PKWareExtraHeader(final ZipShort headerId) {\nthis.headerId = headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.PKWareExtraHeader:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0014_X509Certificates:<init>()V",
                                    "method_body": "public X0014_X509Certificates() {\nsuper(new ZipShort(0x0014));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0015_CertificateIdForFile:<init>()V",
                                    "method_body": "public X0015_CertificateIdForFile() {\nsuper(new ZipShort(0x0015));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0016_CertificateIdForCentralDirectory:<init>()V",
                                    "method_body": "public X0016_CertificateIdForCentralDirectory() {\nsuper(new ZipShort(0x0016));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0017_StrongEncryptionHeader:<init>()V",
                                    "method_body": "public X0017_StrongEncryptionHeader() {\nsuper(new ZipShort(0x0017));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0019_EncryptionRecipientCertificateList:<init>()V",
                                    "method_body": "public X0019_EncryptionRecipientCertificateList() {\nsuper(new ZipShort(0x0019));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ResourceAlignmentExtraField:<init>()V",
                                    "method_body": "public ResourceAlignmentExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ResourceAlignmentExtraField:<init>(IZI)V",
                                    "method_body": "public static final ZipShort ID = new ZipShort(0xa11e);\nprivate int padding = 0;\npublic ResourceAlignmentExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ResourceAlignmentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort ID = new ZipShort(0xa11e);\nprivate int padding = 0;\npublic ResourceAlignmentExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ResourceAlignmentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:<init>(Ljava/lang/String;I)V",
                                    "method_body": "private ZipMethod() {\nthis(UNKNOWN_CODE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:<init>(Ljava/lang/String;II)V",
                                    "method_body": "ZipMethod(final int code) {\nthis.code = code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:getCode()I",
                                    "method_body": "public int getCode() {\nreturn code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<init>(Ljava/lang/String;)V",
                                    "method_body": "private UnicodeExtraFieldPolicy(final String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
                                    "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS = new UnicodeExtraFieldPolicy(\"always\");\npublic static final UnicodeExtraFieldPolicy NEVER = new UnicodeExtraFieldPolicy(\"never\");\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nprivate UnicodeExtraFieldPolicy(final String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:<init>(Ljava/util/zip/Deflater;)V",
                                    "method_body": "private static final int DEFLATER_BLOCK_SIZE = 8192;\nprivate final CRC32 crc = new CRC32();\nprivate long writtenToOutputStreamForLastEntry = 0;\nprivate long sourcePayloadLength = 0;\nprivate long totalWrittenToOutputStream = 0;\nprivate final byte[] outputBuffer = new byte[BUFFER_SIZE];\nprivate final byte[] readerBuf = new byte[BUFFER_SIZE];\nStreamCompressor(final Deflater deflater) {\nthis.def = deflater;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:create(Ljava/io/OutputStream;Ljava/util/zip/Deflater;)Lorg/apache/commons/compress/archivers/zip/StreamCompressor;",
                                    "method_body": "static StreamCompressor create(final OutputStream os, final Deflater deflater) {\nreturn new OutputStreamCompressor(deflater, os);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:getCrc32()J",
                                    "method_body": "public long getCrc32() {\nreturn crc.getValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:getBytesRead()J",
                                    "method_body": "public long getBytesRead() {\nreturn sourcePayloadLength;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:getTotalBytesWritten()J",
                                    "method_body": "public long getTotalBytesWritten() {\nreturn totalWrittenToOutputStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:write([BIII)J",
                                    "method_body": "long write(final byte[] b, final int offset, final int length, final int method) throws IOException {\nfinal long current = writtenToOutputStreamForLastEntry;\ncrc.update(b, offset, length);\nif (method == ZipEntry.DEFLATED) {\nwriteDeflated(b, offset, length);\nsourcePayloadLength += length;\nreturn writtenToOutputStreamForLastEntry - current;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:reset()V",
                                    "method_body": "void reset() {\ncrc.reset();\ndef.reset();\nsourcePayloadLength = 0;\nwrittenToOutputStreamForLastEntry = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:close()V",
                                    "method_body": "public void close() throws IOException {\ndef.end();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:flushDeflater()V",
                                    "method_body": "void flushDeflater() throws IOException {\ndef.finish();\nwhile (!def.finished()) {\ndeflate();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:writeDeflated([BII)V",
                                    "method_body": "private void writeDeflated(final byte[] b, final int offset, final int length)\nif (length > 0 && !def.finished()) {\nif (length <= DEFLATER_BLOCK_SIZE) {\ndef.setInput(b, offset, length);\ndeflateUntilInputIsNeeded();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:deflateUntilInputIsNeeded()V",
                                    "method_body": "private void deflateUntilInputIsNeeded() throws IOException {\nwhile (!def.needsInput()) {\ndeflate();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:deflate()V",
                                    "method_body": "void deflate() throws IOException {\nfinal int len = def.deflate(outputBuffer, 0, outputBuffer.length);\nif (len > 0) {\nwriteCounted(outputBuffer, 0, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:writeCounted([B)V",
                                    "method_body": "public void writeCounted(final byte[] data) throws IOException {\nwriteCounted(data, 0, data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:writeCounted([BII)V",
                                    "method_body": "public void writeCounted(final byte[] data, final int offset, final int length) throws IOException {\nwriteOut(data, offset, length);\nwrittenToOutputStreamForLastEntry += length;\ntotalWrittenToOutputStream += length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor$OutputStreamCompressor:<init>(Ljava/util/zip/Deflater;Ljava/io/OutputStream;)V",
                                    "method_body": "public OutputStreamCompressor(final Deflater deflater, final OutputStream os) {\nsuper(deflater);\nthis.os = os;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor$OutputStreamCompressor:writeOut([BII)V",
                                    "method_body": "protected final void writeOut(final byte[] data, final int offset, final int length)\nos.write(data, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$CurrentEntry:<init>(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "private final ZipArchiveEntry entry;\nprivate long localDataStart = 0;\nprivate long dataStart = 0;\nprivate long bytesRead = 0;\nprivate boolean causedUseOfZip64 = false;\n* #closeArchiveEntry closeArchiveEntry} will write an empty"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$EntryMetaData:<init>(JZ)V",
                                    "method_body": "private EntryMetaData(long offset, boolean usesDataDescriptor) {\nthis.offset = offset;\nthis.usesDataDescriptor = usesDataDescriptor;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipFile(final File f) throws IOException {\nthis(f, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;)V",
                                    "method_body": "public ZipFile(final File f, final String encoding) throws IOException {\nthis(f, encoding, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(final File f, final String encoding, final boolean useUnicodeExtraFields)\nthis(Files.newByteChannel(f.toPath(), EnumSet.of(StandardOpenOption.READ)),\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/nio/channels/SeekableByteChannel;Ljava/lang/String;Ljava/lang/String;ZZ)V",
                                    "method_body": "private static final int HASH_SIZE = 509;\nprivate final List<ZipArchiveEntry> entries =\nprivate final Map<String, LinkedList<ZipArchiveEntry>> nameMap =\nprivate volatile boolean closed = true;\nprivate final byte[] dwordBuf = new byte[DWORD];\nprivate final byte[] wordBuf = new byte[WORD];\nprivate final byte[] cfhBuf = new byte[CFH_LEN];\nprivate final byte[] shortBuf = new byte[SHORT];\nprivate final ByteBuffer dwordBbuf = ByteBuffer.wrap(dwordBuf);\nprivate final ByteBuffer wordBbuf = ByteBuffer.wrap(wordBuf);\nprivate final ByteBuffer cfhBbuf = ByteBuffer.wrap(cfhBuf);\nthis(f, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<clinit>()V",
                                    "method_body": "private static final int CFH_LEN =\nprivate static final long CFH_SIG =\nfinal HashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\npositionAtCentralDirectory();\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nlong sig = ZipLong.getValue(wordBuf);\nif (sig != CFH_SIG && startsWithLocalFileHeader()) {\nwhile (sig == CFH_SIG) {\nreadCentralDirectoryEntry(noUTF8Flag);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nsig = ZipLong.getValue(wordBuf);\nreturn noUTF8Flag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:close()V",
                                    "method_body": "public void close() throws IOException {\nclosed = true;\narchive.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:getEntry(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;",
                                    "method_body": "public ZipArchiveEntry getEntry(final String name) {\nfinal LinkedList<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\nreturn entriesOfThatName != null ? entriesOfThatName.getFirst() : null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:getRawInputStream(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Ljava/io/InputStream;",
                                    "method_body": "public InputStream getRawInputStream(final ZipArchiveEntry ze) {\nif (!(ze instanceof Entry)) {\nfinal long start = ze.getDataOffset();\nreturn createBoundedInputStream(start, ze.getCompressedSize());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory()\nfinal HashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\npositionAtCentralDirectory();\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nlong sig = ZipLong.getValue(wordBuf);\nif (sig != CFH_SIG && startsWithLocalFileHeader()) {\nwhile (sig == CFH_SIG) {\nreadCentralDirectoryEntry(noUTF8Flag);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nsig = ZipLong.getValue(wordBuf);\nreturn noUTF8Flag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:readCentralDirectoryEntry(Ljava/util/Map;)V",
                                    "method_body": "private void\ncfhBbuf.rewind();\nIOUtils.readFully(archive, cfhBbuf);\nint off = 0;\nfinal Entry ze = new Entry();\nfinal int versionMadeBy = ZipShort.getValue(cfhBuf, off);\noff += SHORT;\nze.setVersionMadeBy(versionMadeBy);\nze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\nze.setVersionRequired(ZipShort.getValue(cfhBuf, off));\noff += SHORT; // version required\nfinal GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(cfhBuf, off);\nfinal boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\nfinal ZipEncoding entryEncoding =\nze.setGeneralPurposeBit(gpFlag);\nze.setRawFlag(ZipShort.getValue(cfhBuf, off));\noff += SHORT;\nze.setMethod(ZipShort.getValue(cfhBuf, off));\noff += SHORT;\nfinal long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfhBuf, off));\nze.setTime(time);\noff += WORD;\nze.setCrc(ZipLong.getValue(cfhBuf, off));\noff += WORD;\nze.setCompressedSize(ZipLong.getValue(cfhBuf, off));\noff += WORD;\nze.setSize(ZipLong.getValue(cfhBuf, off));\noff += WORD;\nfinal int fileNameLen = ZipShort.getValue(cfhBuf, off);\noff += SHORT;\nfinal int extraLen = ZipShort.getValue(cfhBuf, off);\noff += SHORT;\nfinal int commentLen = ZipShort.getValue(cfhBuf, off);\noff += SHORT;\nfinal int diskStart = ZipShort.getValue(cfhBuf, off);\noff += SHORT;\nze.setInternalAttributes(ZipShort.getValue(cfhBuf, off));\noff += SHORT;\nze.setExternalAttributes(ZipLong.getValue(cfhBuf, off));\noff += WORD;\nfinal byte[] fileName = new byte[fileNameLen];\nIOUtils.readFully(archive, ByteBuffer.wrap(fileName));\nze.setName(entryEncoding.decode(fileName), fileName);\nze.setLocalHeaderOffset(ZipLong.getValue(cfhBuf, off));\nentries.add(ze);\nfinal byte[] cdExtraData = new byte[extraLen];\nIOUtils.readFully(archive, ByteBuffer.wrap(cdExtraData));\nze.setCentralDirectoryExtra(cdExtraData);\nsetSizesAndOffsetFromZip64Extra(ze, diskStart);\nfinal byte[] comment = new byte[commentLen];\nIOUtils.readFully(archive, ByteBuffer.wrap(comment));\nze.setComment(entryEncoding.decode(comment));\nif (!hasUTF8Flag && useUnicodeExtraFields) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:setSizesAndOffsetFromZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;I)V",
                                    "method_body": "private void setSizesAndOffsetFromZip64Extra(final ZipArchiveEntry ze,\nfinal Zip64ExtendedInformationExtraField z64 =\nif (z64 != null) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\npositionAtEndOfCentralDirectoryRecord();\nboolean found = false;\nfinal boolean searchedForZip64EOCD =\nif (searchedForZip64EOCD) {\narchive.position(archive.position() - ZIP64_EOCDL_LENGTH);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nfound = Arrays.equals(ZipArchiveOutputStream.ZIP64_EOCD_LOC_SIG,\nif (!found) {\nif (searchedForZip64EOCD) {\nskipBytes(ZIP64_EOCDL_LENGTH - WORD);\npositionAtCentralDirectory32();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory32()V",
                                    "method_body": "private void positionAtCentralDirectory32()\nskipBytes(CFD_LOCATOR_OFFSET);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\narchive.position(ZipLong.getValue(wordBuf));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtEndOfCentralDirectoryRecord()V",
                                    "method_body": "private void positionAtEndOfCentralDirectoryRecord()\nfinal boolean found = tryToLocateSignature(MIN_EOCD_SIZE, MAX_EOCD_SIZE,\nif (!found) {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:tryToLocateSignature(JJ[B)Z",
                                    "method_body": "private boolean tryToLocateSignature(final long minDistanceFromEnd,\nboolean found = false;\nlong off = archive.size() - minDistanceFromEnd;\nfinal long stopSearching =\nif (off >= 0) {\nfor (; off >= stopSearching; off--) {\narchive.position(off);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nwordBbuf.flip();\n}\nint curr = wordBbuf.get();\nif (curr == sig[POS_0]) {\ncurr = wordBbuf.get();\nif (curr == sig[POS_1]) {\ncurr = wordBbuf.get();\nif (curr == sig[POS_2]) {\ncurr = wordBbuf.get();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\nif (found) {\narchive.position(off);\nreturn found;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:skipBytes(I)V",
                                    "method_body": "private void skipBytes(final int count) throws IOException {\nlong currentPosition = archive.position();\nlong newPosition = currentPosition + count;\nif (newPosition > archive.size()) {\narchive.position(newPosition);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:resolveLocalFileHeaderData(Ljava/util/Map;)V",
                                    "method_body": "private void resolveLocalFileHeaderData(final Map<ZipArchiveEntry, NameAndComment>\nfor (final ZipArchiveEntry zipArchiveEntry : entries) {\nfinal Entry ze = (Entry) zipArchiveEntry;\nfinal long offset = ze.getLocalHeaderOffset();\narchive.position(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nwordBbuf.flip();\nwordBbuf.get(shortBuf);\nfinal int fileNameLen = ZipShort.getValue(shortBuf);\nwordBbuf.get(shortBuf);\nfinal int extraFieldLen = ZipShort.getValue(shortBuf);\nskipBytes(fileNameLen);\nfinal byte[] localExtraData = new byte[extraFieldLen];\nIOUtils.readFully(archive, ByteBuffer.wrap(localExtraData));\nze.setExtra(localExtraData);\nze.setDataOffset(offset + LFH_OFFSET_FOR_FILENAME_LENGTH\nze.setStreamContiguous(true);\nif (entriesWithoutUTF8Flag.containsKey(ze)) {\nfinal String name = ze.getName();\nLinkedList<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\nif (entriesOfThatName == null) {\nentriesOfThatName = new LinkedList<>();\nnameMap.put(name, entriesOfThatName);\nentriesOfThatName.addLast(ze);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:createBoundedInputStream(JJ)Lorg/apache/commons/compress/archivers/zip/ZipFile$BoundedInputStream;",
                                    "method_body": "private BoundedInputStream createBoundedInputStream(long start, long remaining) {\nreturn archive instanceof FileChannel ?\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$Entry:<init>()V",
                                    "method_body": "Entry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$Entry:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn 3 * super.hashCode()\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$BoundedInputStream:<init>(Lorg/apache/commons/compress/archivers/zip/ZipFile;JJ)V",
                                    "method_body": "BoundedInputStream(final long start, final long remaining) {\nthis.end = start+remaining;\nif (this.end < start) {\nloc = start;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$BoundedInputStream:read([BII)I",
                                    "method_body": "public synchronized int read(final byte[] b, final int off, int len) throws IOException {\nif (len <= 0) {\nif (len > end-loc) {\nif (loc >= end) {\nif (loc == end && addDummy) {\nreturn -1;\nlen = (int)(end-loc);\nbuf = ByteBuffer.wrap(b, off, len);\nint ret = read(loc, buf);\nif (ret > 0) {\nloc += ret;\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$BoundedFileChannelInputStream:<init>(Lorg/apache/commons/compress/archivers/zip/ZipFile;JJ)V",
                                    "method_body": "BoundedFileChannelInputStream(final long start, final long remaining) {\nsuper(start, remaining);\narchive = (FileChannel)ZipFile.this.archive;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$BoundedFileChannelInputStream:read(JLjava/nio/ByteBuffer;)I",
                                    "method_body": "protected int read(long pos, ByteBuffer buf) throws IOException {\nint read = archive.read(buf, pos);\nbuf.flip();\nreturn read;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 44,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest.testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree",
                            "test_body": "129: public void testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree() {\n130: 131: ChecksumCalculatingInputStream checksumCalculatingInputStream = new ChecksumCalculatingInputStream(new CRC32(),null);\n132: 133: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumCalculatingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;)V",
                                    "method_body": "public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\nthis.checksum = checksum;\nthis.in = in;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest.testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
                            "test_body": "120: public void testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo() {\n121: 122: ChecksumCalculatingInputStream checksumCalculatingInputStream = new ChecksumCalculatingInputStream(null,new ByteArrayInputStream(new byte[1]));\n123: 124: 125: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumCalculatingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;)V",
                                    "method_body": "public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\nthis.checksum = checksum;\nthis.in = in;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest.testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
                            "test_body": "111: public void testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne() {\n112: 113: ChecksumCalculatingInputStream checksumCalculatingInputStream = new ChecksumCalculatingInputStream(null,null);\n114: 115: 116: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumCalculatingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;)V",
                                    "method_body": "public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\nthis.checksum = checksum;\nthis.in = in;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 45,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarUtilsTest.testRoundTripOctalOrBinary8",
                            "test_body": "147: public void testRoundTripOctalOrBinary8() {\n148: testRoundTripOctalOrBinary(8);\n149: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\nfinal Map<String, SimpleEncodingHolder> se =\nfinal char[] cp437_high_chars =\nfinal SimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\nfinal char[] cp850_high_chars =\nfinal SimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(final String name) {\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\ncharsetName = Charset.defaultCharset().name();\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(final char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(final String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:<clinit>()V",
                                    "method_body": "private static final int BYTE_MASK = 255;\nstatic final ZipEncoding DEFAULT_ENCODING =\nstatic final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\nif (length < 2){\nif (buffer[start] == 0) {\nwhile (start < end){\nif (buffer[start] == ' '){\nbyte trailer = buffer[end - 1];\nwhile (start < end && (trailer == 0 || trailer == ' ')) {\nend--;\ntrailer = buffer[end - 1];\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\nif (currentByte < '0' || currentByte > '7'){\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctalOrBinary([BII)J",
                                    "method_body": "public static long parseOctalOrBinary(final byte[] buffer, final int offset,\nif ((buffer[offset] & 0x80) == 0) {\nreturn parseOctal(buffer, offset, length);\nfinal boolean negative = buffer[offset] == (byte) 0xff;\nif (length < 9) {\nreturn parseBinaryLong(buffer, offset, length, negative);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseBinaryLong([BIIZ)J",
                                    "method_body": "private static long parseBinaryLong(final byte[] buffer, final int offset,\nif (length >= 9) {\nlong val = 0;\nfor (int i = 1; i < length; i++) {\nval = (val << 8) + (buffer[offset + i] & 0xff);\nif (negative) {\nval--;\nval ^= (long) Math.pow(2.0, (length - 1) * 8.0) - 1;\nreturn negative ? -val : val;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatUnsignedOctalString(J[BII)V",
                                    "method_body": "public static void formatUnsignedOctalString(final long value, final byte[] buffer,\nint remaining = length;\nremaining--;\nif (value == 0) {\nbuffer[offset + remaining--] = (byte) '0';\nlong val = value;\nfor (; remaining >= 0 && val != 0; --remaining) {\nbuffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));\nval = val >>> 3;\nif (val != 0){\nfor (; remaining >= 0; --remaining) { // leading zeros\nbuffer[offset + remaining] = (byte) '0';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatLongOctalBytes(J[BII)I",
                                    "method_body": "public static int formatLongOctalBytes(final long value, final byte[] buf, final int offset, final int length) {\nfinal int idx=length-1; // For space\nformatUnsignedOctalString(value, buf, offset, idx);\nbuf[offset + idx] = (byte) ' '; // Trailing space\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatLongOctalOrBinaryBytes(J[BII)I",
                                    "method_body": "public static int formatLongOctalOrBinaryBytes(\nfinal long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\nfinal boolean negative = value < 0;\nif (!negative && value <= maxAsOctalChar) { // OK to store as octal chars\nreturn formatLongOctalBytes(value, buf, offset, length);\nif (length < 9) {\nformatLongBinary(value, buf, offset, length, negative);\nformatBigIntegerBinary(value, buf, offset, length, negative);\nbuf[offset] = (byte) (negative ? 0xff : 0x80);\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatLongBinary(J[BIIZ)V",
                                    "method_body": "private static void formatLongBinary(final long value, final byte[] buf,\nfinal int bits = (length - 1) * 8;\nfinal long max = 1l << bits;\nlong val = Math.abs(value); // Long.MIN_VALUE stays Long.MIN_VALUE\nif (val < 0 || val >= max) {\nif (negative) {\nval ^= max - 1;\nval++;\nval |= 0xffl << bits;\nfor (int i = offset + length - 1; i >= offset; i--) {\nbuf[i] = (byte) val;\nval >>= 8;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatBigIntegerBinary(J[BIIZ)V",
                                    "method_body": "private static void formatBigIntegerBinary(final long value, final byte[] buf,\nfinal BigInteger val = BigInteger.valueOf(value);\nfinal byte[] b = val.toByteArray();\nfinal int len = b.length;\nif (len > length - 1) {\nthrow new IllegalArgumentException(\"Value \" + value +\nfinal int off = offset + length - len;\nSystem.arraycopy(b, 0, buf, off, len);\nfinal byte fill = (byte) (negative ? 0xff : 0);\nfor (int i = offset + 1; i < off; i++) {\nbuf[i] = fill;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 46,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestampTest.testGettersSetters",
                            "test_body": "200: public void testGettersSetters() {\n201: // X5455 is concerned with time, so let's\n202: // get a timestamp to play with (Jan 1st, 2000).\n203: final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n204: cal.set(Calendar.YEAR, 2000);\n205: cal.set(Calendar.MONTH, Calendar.JANUARY);\n206: cal.set(Calendar.DATE, 1);\n207: cal.set(Calendar.HOUR_OF_DAY, 0);\n208: cal.set(Calendar.MINUTE, 0);\n209: cal.set(Calendar.SECOND, 0);\n210: cal.set(Calendar.MILLISECOND, 0);\n211: final long timeMillis = cal.getTimeInMillis();\n212: final ZipLong time = new ZipLong(timeMillis / 1000);\n213: 214: // set too big\n215: try {\n216: // Java time is 1000 x larger (milliseconds).\n217: xf.setModifyJavaTime(new Date(1000L * (MAX_TIME_SECONDS.getValue() + 1L)));\n218: fail(\"Time too big for 32 bits!\");\n219: } catch (final IllegalArgumentException iae) {\n220: // All is good.\n221: }\n222: 223: // get/set modify time\n224: xf.setModifyTime(time);\n225: assertEquals(time, xf.getModifyTime());\n226: Date xfModifyJavaTime = xf.getModifyJavaTime();\n227: assertEquals(timeMillis, xfModifyJavaTime.getTime());\n228: xf.setModifyJavaTime(new Date(timeMillis));\n229: assertEquals(time, xf.getModifyTime());\n230: assertEquals(timeMillis, xf.getModifyJavaTime().getTime());\n231: // Make sure milliseconds get zeroed out:\n232: xf.setModifyJavaTime(new Date(timeMillis + 123));\n233: assertEquals(time, xf.getModifyTime());\n234: assertEquals(timeMillis, xf.getModifyJavaTime().getTime());\n235: // Null\n236: xf.setModifyTime(null);\n237: assertNull(xf.getModifyJavaTime());\n238: xf.setModifyJavaTime(null);\n239: assertNull(xf.getModifyTime());\n240: 241: // get/set access time\n242: xf.setAccessTime(time);\n243: assertEquals(time, xf.getAccessTime());\n244: assertEquals(timeMillis, xf.getAccessJavaTime().getTime());\n245: xf.setAccessJavaTime(new Date(timeMillis));\n246: assertEquals(time, xf.getAccessTime());\n247: assertEquals(timeMillis, xf.getAccessJavaTime().getTime());\n248: // Make sure milliseconds get zeroed out:\n249: xf.setAccessJavaTime(new Date(timeMillis + 123));\n250: assertEquals(time, xf.getAccessTime());\n251: assertEquals(timeMillis, xf.getAccessJavaTime().getTime());\n252: // Null\n253: xf.setAccessTime(null);\n254: assertNull(xf.getAccessJavaTime());\n255: xf.setAccessJavaTime(null);\n256: assertNull(xf.getAccessTime());\n257: 258: // get/set create time\n259: xf.setCreateTime(time);\n260: assertEquals(time, xf.getCreateTime());\n261: assertEquals(timeMillis, xf.getCreateJavaTime().getTime());\n262: xf.setCreateJavaTime(new Date(timeMillis));\n263: assertEquals(time, xf.getCreateTime());\n264: assertEquals(timeMillis, xf.getCreateJavaTime().getTime());\n265: // Make sure milliseconds get zeroed out:\n266: xf.setCreateJavaTime(new Date(timeMillis + 123));\n267: assertEquals(time, xf.getCreateTime());\n268: assertEquals(timeMillis, xf.getCreateJavaTime().getTime());\n269: // Null\n270: xf.setCreateTime(null);\n271: assertNull(xf.getCreateJavaTime());\n272: xf.setCreateJavaTime(null);\n273: assertNull(xf.getCreateTime());\n274: 275: 276: // initialize for flags\n277: xf.setModifyTime(time);\n278: xf.setAccessTime(time);\n279: xf.setCreateTime(time);\n280: 281: // get/set flags: 000\n282: xf.setFlags((byte) 0);\n283: assertEquals(0, xf.getFlags());\n284: assertFalse(xf.isBit0_modifyTimePresent());\n285: assertFalse(xf.isBit1_accessTimePresent());\n286: assertFalse(xf.isBit2_createTimePresent());\n287: // Local length=1, Central length=1 (flags only!)\n288: assertEquals(1, xf.getLocalFileDataLength().getValue());\n289: assertEquals(1, xf.getCentralDirectoryLength().getValue());\n290: 291: // get/set flags: 001\n292: xf.setFlags((byte) 1);\n293: assertEquals(1, xf.getFlags());\n294: assertTrue(xf.isBit0_modifyTimePresent());\n295: assertFalse(xf.isBit1_accessTimePresent());\n296: assertFalse(xf.isBit2_createTimePresent());\n297: // Local length=5, Central length=5 (flags + mod)\n298: assertEquals(5, xf.getLocalFileDataLength().getValue());\n299: assertEquals(5, xf.getCentralDirectoryLength().getValue());\n300: 301: // get/set flags: 010\n302: xf.setFlags((byte) 2);\n303: assertEquals(2, xf.getFlags());\n304: assertFalse(xf.isBit0_modifyTimePresent());\n305: assertTrue(xf.isBit1_accessTimePresent());\n306: assertFalse(xf.isBit2_createTimePresent());\n307: // Local length=5, Central length=1\n308: assertEquals(5, xf.getLocalFileDataLength().getValue());\n309: assertEquals(1, xf.getCentralDirectoryLength().getValue());\n310: 311: // get/set flags: 100\n312: xf.setFlags((byte) 4);\n313: assertEquals(4, xf.getFlags());\n314: assertFalse(xf.isBit0_modifyTimePresent());\n315: assertFalse(xf.isBit1_accessTimePresent());\n316: assertTrue(xf.isBit2_createTimePresent());\n317: // Local length=5, Central length=1\n318: assertEquals(5, xf.getLocalFileDataLength().getValue());\n319: assertEquals(1, xf.getCentralDirectoryLength().getValue());\n320: 321: // get/set flags: 111\n322: xf.setFlags((byte) 7);\n323: assertEquals(7, xf.getFlags());\n324: assertTrue(xf.isBit0_modifyTimePresent());\n325: assertTrue(xf.isBit1_accessTimePresent());\n326: assertTrue(xf.isBit2_createTimePresent());\n327: // Local length=13, Central length=5\n328: assertEquals(13, xf.getLocalFileDataLength().getValue());\n329: assertEquals(5, xf.getCentralDirectoryLength().getValue());\n330: 331: // get/set flags: 11111111\n332: xf.setFlags((byte) -1);\n333: assertEquals(-1, xf.getFlags());\n334: assertTrue(xf.isBit0_modifyTimePresent());\n335: assertTrue(xf.isBit1_accessTimePresent());\n336: assertTrue(xf.isBit2_createTimePresent());\n337: // Local length=13, Central length=5\n338: assertEquals(13, xf.getLocalFileDataLength().getValue());\n339: assertEquals(5, xf.getCentralDirectoryLength().getValue());\n340: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(final long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(I)V",
                                    "method_body": "public ZipLong(int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\npublic ZipLong(final long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue()J",
                                    "method_body": "public long getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (final int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<clinit>()V",
                                    "method_body": "public static final ZipShort ZERO = new ZipShort(0);\npublic ZipShort (final int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<init>()V",
                                    "method_body": "public X5455_ExtendedTimestamp() {}\npublic X5455_ExtendedTimestamp() {}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x5455);\npublic X5455_ExtendedTimestamp() {}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:setModifyTime(Lorg/apache/commons/compress/archivers/zip/ZipLong;)V",
                                    "method_body": "public void setModifyTime(final ZipLong l) {\nbit0_modifyTimePresent = l != null;\nflags = (byte) (l != null ? (flags | MODIFY_TIME_BIT)\nthis.modifyTime = l;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:setModifyJavaTime(Ljava/util/Date;)V",
                                    "method_body": "public void setModifyJavaTime(final Date d) { setModifyTime(dateToZipLong(d)); }\npublic void setModifyJavaTime(final Date d) { setModifyTime(dateToZipLong(d)); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:dateToZipLong(Ljava/util/Date;)Lorg/apache/commons/compress/archivers/zip/ZipLong;",
                                    "method_body": "private static ZipLong dateToZipLong(final Date d) {\nif (d == null) { return null; }\nreturn unixTimeToZipLong(d.getTime() / 1000);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:unixTimeToZipLong(J)Lorg/apache/commons/compress/archivers/zip/ZipLong;",
                                    "method_body": "private static ZipLong unixTimeToZipLong(long l) {\nfinal long TWO_TO_32 = 0x100000000L;\nif (l >= TWO_TO_32) {\nreturn new ZipLong(l);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 47,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest.properlyMarksEntriesAsUnreadableIfUncompressedSizeIsUnknown",
                            "test_body": "330: public void properlyMarksEntriesAsUnreadableIfUncompressedSizeIsUnknown() throws Exception {\n331: // we never read any data\n332: try (ZipArchiveInputStream zis = new ZipArchiveInputStream(new ByteArrayInputStream(new byte[0]))) {\n333: ZipArchiveEntry e = new ZipArchiveEntry(\"test\");\n334: e.setMethod(ZipMethod.DEFLATED.getCode());\n335: assertTrue(zis.canReadEntryData(e));\n336: e.setMethod(ZipMethod.ENHANCED_DEFLATED.getCode());\n337: assertTrue(zis.canReadEntryData(e));\n338: e.setMethod(ZipMethod.BZIP2.getCode());\n339: assertFalse(zis.canReadEntryData(e));\n340: }\n341: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "static final String UTF8 = \"UTF8\";\nstatic final ZipEncoding UTF8_ZIP_ENCODING = getZipEncoding(UTF8);\n* @param name The name of the zip encoding. Specify {@code null} for"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(final String name) {\nCharset cs = Charset.defaultCharset();\nif (name != null) {\ncs = Charset.forName(name);\n}\nboolean useReplacement = isUTF8(cs.name());\nreturn new NioZipEncoding(cs, useReplacement);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:<init>(Ljava/nio/charset/Charset;Z)V",
                                    "method_body": "NioZipEncoding(final Charset charset, boolean useReplacement) {\nthis.charset = charset;\nthis.useReplacement = useReplacement;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:<clinit>()V",
                                    "method_body": "private static final String REPLACEMENT_STRING = String.valueOf(REPLACEMENT);\nprivate static final char[] HEX_CHARS = new char[] {\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ByteUtils:toLittleEndian([BJII)V",
                                    "method_body": "public static void toLittleEndian(final byte[] b, final long value, final int off, final int length) {\nlong num = value;\nfor (int i = 0; i < length; i++) {\nb[off + i] = (byte) (num & 0xff);\nnum >>= 8;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public ZipArchiveInputStream(final InputStream inputStream) {\nthis(inputStream, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveInputStream(final InputStream inputStream, final String encoding) {\nthis(inputStream, encoding, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipArchiveInputStream(final InputStream inputStream, final String encoding, final boolean useUnicodeExtraFields) {\nthis(inputStream, encoding, useUnicodeExtraFields, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;ZZ)V",
                                    "method_body": "public ZipArchiveInputStream(final InputStream inputStream,\nfinal boolean allowStoredEntriesWithDataDescriptor) {\nthis.encoding = encoding;\nzipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\nin = new PushbackInputStream(inputStream, buf.capacity());\nthis.allowStoredEntriesWithDataDescriptor =\nbuf.limit(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<clinit>()V",
                                    "method_body": "private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\nprivate static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\nprivate static final byte[] DD = ZipLong.DD_SIG.getBytes();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:canReadEntryData(Lorg/apache/commons/compress/archivers/ArchiveEntry;)Z",
                                    "method_body": "public boolean canReadEntryData(final ArchiveEntry ae) {\nif (ae instanceof ZipArchiveEntry) {\nfinal ZipArchiveEntry ze = (ZipArchiveEntry) ae;\nreturn ZipUtil.canHandleEntryData(ze)\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!closed) {\nclosed = true;\nin.close();\ninf.end();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:supportsDataDescriptorFor(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private boolean supportsDataDescriptorFor(final ZipArchiveEntry entry) {\nreturn !entry.getGeneralPurposeBit().usesDataDescriptor()\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(final long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\npublic ZipLong(final long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(final long value) {\nfinal byte[] result = new byte[WORD];\nputLong(value, result, 0);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:putLong(J[BI)V",
                                    "method_body": "public static void putLong(final long value, final byte[] buf, int offset) {\nByteUtils.toLittleEndian(buf, value, offset, 4);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(final String name) {\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/util/zip/ZipEntry;)V",
                                    "method_body": "private long size = SIZE_UNKNOWN;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate int alignment = 0;\nprivate UnparseableExtraFieldData unparseableExtra = null;\nprivate String name = null;\nprivate byte[] rawName = null;\nprivate GeneralPurposeBit gpb = new GeneralPurposeBit();\nprivate static final ZipExtraField[] noExtraFields = new ZipExtraField[0];\nprivate long localHeaderOffset = OFFSET_UNKNOWN;\nprivate long dataOffset = OFFSET_UNKNOWN;\nprivate boolean isStreamContiguous = false;\nprivate NameSource nameSource = NameSource.NAME;\nprivate CommentSource commentSource = CommentSource.COMMENT;\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<clinit>()V",
                                    "method_body": "public static final int PLATFORM_UNIX = 3;\nprivate static final byte[] EMPTY = new byte[0];\npublic enum NameSource {\nNAME,\nNAME_WITH_EFS_FLAG,\nUNICODE_EXTRA_FIELD\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getMethod()I",
                                    "method_body": "public int getMethod() {\nreturn method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setMethod(I)V",
                                    "method_body": "public void setMethod(final int method) {\nif (method < 0) {\nthis.method = method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "protected void setName(String name) {\nif (name != null && getPlatform() == PLATFORM_FAT\nname = name.replace('\\\\', '/');\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getGeneralPurposeBit()Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "public GeneralPurposeBit getGeneralPurposeBit() {\nreturn gpb;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:<init>()V",
                                    "method_body": "public GeneralPurposeBit() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesDataDescriptor()Z",
                                    "method_body": "public boolean usesDataDescriptor() {\nreturn dataDescriptorFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesEncryption()Z",
                                    "method_body": "public boolean usesEncryption() {\nreturn encryptionFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry$NameSource:<clinit>()V",
                                    "method_body": "public static final int PLATFORM_UNIX = 3;\nprivate static final byte[] EMPTY = new byte[0];\npublic enum NameSource {\nNAME,\nNAME_WITH_EFS_FLAG,\nUNICODE_EXTRA_FIELD\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:canHandleEntryData(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "static boolean canHandleEntryData(final ZipArchiveEntry entry) {\nreturn supportsEncryptionOf(entry) && supportsMethodOf(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:supportsEncryptionOf(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private static boolean supportsEncryptionOf(final ZipArchiveEntry entry) {\nreturn !entry.getGeneralPurposeBit().usesEncryption();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:supportsMethodOf(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private static boolean supportsMethodOf(final ZipArchiveEntry entry) {\nreturn entry.getMethod() == ZipEntry.STORED\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:<init>(Ljava/lang/String;I)V",
                                    "method_body": "private ZipMethod() {\nthis(UNKNOWN_CODE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:<init>(Ljava/lang/String;II)V",
                                    "method_body": "ZipMethod(final int code) {\nthis.code = code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:getCode()I",
                                    "method_body": "public int getCode() {\nreturn code;\n}"
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}