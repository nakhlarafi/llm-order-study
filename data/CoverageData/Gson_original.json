{
    "projects": [
        {
            "name": "Gson",
            "bugs": [
                {
                    "bug_id": 1,
                    "tests": [
                        {
                            "test_name": "com.google.gson.functional.TypeVariableTest.testSingle",
                            "test_body": "33: public void testSingle() throws Exception {\n34: Gson gson = new Gson();\n35: Bar bar1 = new Bar(\"someString\", 1);\n36: ArrayList<Integer> arrayList = new ArrayList<Integer>();\n37: arrayList.add(1);\n38: arrayList.add(2);\n39: bar1.map.put(\"key1\", arrayList);\n40: bar1.map.put(\"key2\", new ArrayList<Integer>());\n41: String json = gson.toJson(bar1);\n42: System.out.println(json);\n43: 44: Bar bar2 = gson.fromJson(json, Bar.class);\n45: assertEquals(bar1, bar2);\n46: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.JsonElement:<clinit>()V",
                                    "method_body": "private static final Escaper BASIC_ESCAPER = new Escaper(false);\n* @return true if this element is of type {@link JsonArray}, false otherwise."
                                },
                                {
                                    "method_signature": "com.google.gson.Escaper:<init>(Z)V",
                                    "method_body": "Escaper(boolean escapeHtmlCharacters) {\nthis.escapeHtmlCharacters = escapeHtmlCharacters;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Escaper:<clinit>()V",
                                    "method_body": "private static final Set<Character> JS_ESCAPE_CHARS;\nSet<Character> mandatoryEscapeSet = new HashSet<Character>();\nmandatoryEscapeSet.add('\"');\nmandatoryEscapeSet.add('\\\\');\nJS_ESCAPE_CHARS = Collections.unmodifiableSet(mandatoryEscapeSet);\nSet<Character> htmlEscapeSet = new HashSet<Character>();\nhtmlEscapeSet.add('<');\nhtmlEscapeSet.add('>');\nhtmlEscapeSet.add('&');\nhtmlEscapeSet.add('=');\nhtmlEscapeSet.add('\\'');\nHTML_ESCAPE_CHARS = Collections.unmodifiableSet(htmlEscapeSet);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonObject:<init>()V",
                                    "method_body": "public JsonObject() {\nmembers = new LinkedHashMap<String, JsonElement>();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Preconditions:checkNotNull(Ljava/lang/Object;)V",
                                    "method_body": "public static void checkNotNull(Object obj) {\ncheckArgument(obj != null);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(DEFAULT_EXCLUSION_STRATEGY, DEFAULT_EXCLUSION_STRATEGY, DEFAULT_NAMING_POLICY,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/ExclusionStrategy;Lcom/google/gson/ExclusionStrategy;Lcom/google/gson/FieldNamingStrategy2;Lcom/google/gson/MappedObjectConstructor;ZLcom/google/gson/ParameterizedTypeHandlerMap;Lcom/google/gson/ParameterizedTypeHandlerMap;ZZZ)V",
                                    "method_body": "Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy,\nboolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting) {\nthis.serializationStrategy = serializationStrategy;\nthis.deserializationStrategy = deserializationStrategy;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.objectConstructor = objectConstructor;\nthis.serializeNulls = serializeNulls;\nthis.serializers = serializers;\nthis.deserializers = deserializers;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<clinit>()V",
                                    "method_body": "private static final String NULL_STRING = \"null\";\nstatic final AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY =\nstatic final SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY =\nstatic final ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY =\nnew ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC });"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:createDefaultObjectNavigatorFactory(Lcom/google/gson/ExclusionStrategy;)Lcom/google/gson/ObjectNavigatorFactory;",
                                    "method_body": "private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy) {\nreturn new ObjectNavigatorFactory(strategy, fieldNamingPolicy);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:createExclusionStrategy(D)Lcom/google/gson/ExclusionStrategy;",
                                    "method_body": "private static ExclusionStrategy createExclusionStrategy(double version) {\nList<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>();\nstrategies.add(DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY);\nstrategies.add(DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY);\nstrategies.add(DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY);\nif (version != VersionConstants.IGNORE_VERSIONS) {\nreturn new DisjunctionExclusionStrategy(strategies);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:toJsonTree(Ljava/lang/Object;Ljava/lang/reflect/Type;)Lcom/google/gson/JsonElement;",
                                    "method_body": "public JsonElement toJsonTree(Object src, Type typeOfSrc) {\nif (src == null) {\nJsonSerializationContextDefault context = new JsonSerializationContextDefault(\nreturn context.serialize(src, typeOfSrc, true);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:toJson(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public String toJson(Object src) {\nif (src == null) {\nreturn toJson(src, src.getClass());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:toJson(Ljava/lang/Object;Ljava/lang/reflect/Type;)Ljava/lang/String;",
                                    "method_body": "public String toJson(Object src, Type typeOfSrc) {\nStringWriter writer = new StringWriter();\ntoJson(toJsonTree(src, typeOfSrc), writer);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.AnonymousAndLocalClassExclusionStrategy:shouldSkipField(Lcom/google/gson/FieldAttributes;)Z",
                                    "method_body": "public boolean shouldSkipField(FieldAttributes f) {\nreturn isAnonymousOrLocal(f.getDeclaredClass());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.AnonymousAndLocalClassExclusionStrategy:shouldSkipClass(Ljava/lang/Class;)Z",
                                    "method_body": "public boolean shouldSkipClass(Class<?> clazz) {\nreturn isAnonymousOrLocal(clazz);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.AnonymousAndLocalClassExclusionStrategy:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.SyntheticFieldExclusionStrategy:<init>(Z)V",
                                    "method_body": "SyntheticFieldExclusionStrategy(boolean skipSyntheticFields) {\nthis.skipSyntheticFields = skipSyntheticFields;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.SyntheticFieldExclusionStrategy:shouldSkipClass(Ljava/lang/Class;)Z",
                                    "method_body": "public boolean shouldSkipClass(Class<?> clazz) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.SyntheticFieldExclusionStrategy:shouldSkipField(Lcom/google/gson/FieldAttributes;)Z",
                                    "method_body": "public boolean shouldSkipField(FieldAttributes f) {\nreturn skipSyntheticFields && f.isSynthetic();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ModifierBasedExclusionStrategy:<init>([I)V",
                                    "method_body": "public ModifierBasedExclusionStrategy(int... modifiers) {\nthis.modifiers = new HashSet<Integer>();\nif (modifiers != null) {\nfor (int modifier : modifiers) {\nthis.modifiers.add(modifier);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ModifierBasedExclusionStrategy:shouldSkipField(Lcom/google/gson/FieldAttributes;)Z",
                                    "method_body": "public boolean shouldSkipField(FieldAttributes f) {\nfor (int modifier : modifiers) {\nif (f.hasModifier(modifier)) {\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ModifierBasedExclusionStrategy:shouldSkipClass(Ljava/lang/Class;)Z",
                                    "method_body": "public boolean shouldSkipClass(Class<?> clazz) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.SerializedNameAnnotationInterceptingNamingPolicy:<init>(Lcom/google/gson/FieldNamingStrategy2;)V",
                                    "method_body": "public SerializedNameAnnotationInterceptingNamingPolicy(FieldNamingStrategy2 delegate) {\nthis.delegate = delegate;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.SerializedNameAnnotationInterceptingNamingPolicy:<clinit>()V",
                                    "method_body": "private static final JsonFieldNameValidator fieldNameValidator = new JsonFieldNameValidator();\npublic SerializedNameAnnotationInterceptingNamingPolicy(FieldNamingStrategy2 delegate) {\nthis.delegate = delegate;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonFieldNameValidator:<clinit>()V",
                                    "method_body": "private static final String COMMON_PATTERN = \"[a-zA-Z][a-zA-Z0-9\\\\ \\\\$_\\\\-]*$\";\nprivate static final Pattern JSON_FIELD_NAME_PATTERN =\n* @return {@code fieldName} if it is a valid JSON field name"
                                },
                                {
                                    "method_signature": "com.google.gson.DisjunctionExclusionStrategy:<init>(Ljava/util/Collection;)V",
                                    "method_body": "public DisjunctionExclusionStrategy(Collection<ExclusionStrategy> strategies) {\nPreconditions.checkNotNull(strategies);\nthis.strategies = strategies;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DisjunctionExclusionStrategy:shouldSkipField(Lcom/google/gson/FieldAttributes;)Z",
                                    "method_body": "public boolean shouldSkipField(FieldAttributes f) {\nfor (ExclusionStrategy strategy : strategies) {\nif (strategy.shouldSkipField(f)) {\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DisjunctionExclusionStrategy:shouldSkipClass(Ljava/lang/Class;)Z",
                                    "method_body": "public boolean shouldSkipClass(Class<?> clazz) {\nfor (ExclusionStrategy strategy : strategies) {\nif (strategy.shouldSkipClass(clazz)) {\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.MappedObjectConstructor:<init>(Lcom/google/gson/ParameterizedTypeHandlerMap;)V",
                                    "method_body": "public MappedObjectConstructor(\nParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators) {\ninstanceCreatorMap = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.MappedObjectConstructor:<clinit>()V",
                                    "method_body": "private static final Logger log = Logger.getLogger(MappedObjectConstructor.class.getName());\nParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators) {\ninstanceCreatorMap = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters:<clinit>()V",
                                    "method_body": "private static final EnumTypeAdapter ENUM_TYPE_ADAPTER = new EnumTypeAdapter();\nprivate static final UrlTypeAdapter URL_TYPE_ADAPTER = new UrlTypeAdapter();\nprivate static final UriTypeAdapter URI_TYPE_ADAPTER = new UriTypeAdapter();\nprivate static final UuidTypeAdapter UUUID_TYPE_ADAPTER = new UuidTypeAdapter();\nprivate static final LocaleTypeAdapter LOCALE_TYPE_ADAPTER = new LocaleTypeAdapter();\nprivate static final CollectionTypeAdapter COLLECTION_TYPE_ADAPTER = new CollectionTypeAdapter();\nprivate static final MapTypeAdapter MAP_TYPE_ADAPTER = new MapTypeAdapter();\nprivate static final BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER = new BigDecimalTypeAdapter();\nprivate static final BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER = new BigIntegerTypeAdapter();\nprivate static final BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER = new BooleanTypeAdapter();\nprivate static final ByteTypeAdapter BYTE_TYPE_ADAPTER = new ByteTypeAdapter();\nprivate static final CharacterTypeAdapter CHARACTER_TYPE_ADAPTER = new CharacterTypeAdapter();\nprivate static final DoubleDeserializer DOUBLE_TYPE_ADAPTER = new DoubleDeserializer();\nprivate static final FloatDeserializer FLOAT_TYPE_ADAPTER = new FloatDeserializer();\nprivate static final IntegerTypeAdapter INTEGER_TYPE_ADAPTER = new IntegerTypeAdapter();\nprivate static final LongDeserializer LONG_DESERIALIZER = new LongDeserializer();\nprivate static final NumberTypeAdapter NUMBER_TYPE_ADAPTER = new NumberTypeAdapter();\nprivate static final ShortTypeAdapter SHORT_TYPE_ADAPTER = new ShortTypeAdapter();\nprivate static final StringTypeAdapter STRING_TYPE_ADAPTER = new StringTypeAdapter();\nprivate static final PropertiesCreator PROPERTIES_CREATOR = new PropertiesCreator();\nprivate static final TreeSetCreator TREE_SET_CREATOR = new TreeSetCreator();\nprivate static final HashSetCreator HASH_SET_CREATOR = new HashSetCreator();\nprivate static final GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER =\nprivate static final ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS =\nprivate static final ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS =\nprivate static final ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS =\nParameterizedTypeHandlerMap<JsonSerializer<?>> map =\nmap.registerForTypeHierarchy(Enum.class, ENUM_TYPE_ADAPTER);\nmap.register(URL.class, URL_TYPE_ADAPTER);\nmap.register(URI.class, URI_TYPE_ADAPTER);\nmap.register(UUID.class, UUUID_TYPE_ADAPTER);\nmap.register(Locale.class, LOCALE_TYPE_ADAPTER);\nmap.registerForTypeHierarchy(Collection.class, COLLECTION_TYPE_ADAPTER);\nmap.registerForTypeHierarchy(Map.class, MAP_TYPE_ADAPTER);\nmap.register(Date.class, DATE_TYPE_ADAPTER);\nmap.register(java.sql.Date.class, JAVA_SQL_DATE_TYPE_ADAPTER);\nmap.register(Timestamp.class, DATE_TYPE_ADAPTER);\nmap.register(Time.class, TIME_TYPE_ADAPTER);\nmap.register(Calendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER);\nmap.register(GregorianCalendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER);\nmap.register(BigDecimal.class, BIG_DECIMAL_TYPE_ADAPTER);\nmap.register(BigInteger.class, BIG_INTEGER_TYPE_ADAPTER);\nmap.register(Boolean.class, BOOLEAN_TYPE_ADAPTER);\nmap.register(boolean.class, BOOLEAN_TYPE_ADAPTER);\nmap.register(Byte.class, BYTE_TYPE_ADAPTER);\nmap.register(byte.class, BYTE_TYPE_ADAPTER);\nmap.register(Character.class, CHARACTER_TYPE_ADAPTER);\nmap.register(char.class, CHARACTER_TYPE_ADAPTER);\nmap.register(Integer.class, INTEGER_TYPE_ADAPTER);\nmap.register(int.class, INTEGER_TYPE_ADAPTER);\nmap.register(Number.class, NUMBER_TYPE_ADAPTER);\nmap.register(Short.class, SHORT_TYPE_ADAPTER);\nmap.register(short.class, SHORT_TYPE_ADAPTER);\nmap.register(String.class, STRING_TYPE_ADAPTER);\nmap.makeUnmodifiable();\nreturn map;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters:createDefaultSerializers()Lcom/google/gson/ParameterizedTypeHandlerMap;",
                                    "method_body": "private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers() {\nParameterizedTypeHandlerMap<JsonSerializer<?>> map =\nmap.registerForTypeHierarchy(Enum.class, ENUM_TYPE_ADAPTER);\nmap.register(URL.class, URL_TYPE_ADAPTER);\nmap.register(URI.class, URI_TYPE_ADAPTER);\nmap.register(UUID.class, UUUID_TYPE_ADAPTER);\nmap.register(Locale.class, LOCALE_TYPE_ADAPTER);\nmap.registerForTypeHierarchy(Collection.class, COLLECTION_TYPE_ADAPTER);\nmap.registerForTypeHierarchy(Map.class, MAP_TYPE_ADAPTER);\nmap.register(Date.class, DATE_TYPE_ADAPTER);\nmap.register(java.sql.Date.class, JAVA_SQL_DATE_TYPE_ADAPTER);\nmap.register(Timestamp.class, DATE_TYPE_ADAPTER);\nmap.register(Time.class, TIME_TYPE_ADAPTER);\nmap.register(Calendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER);\nmap.register(GregorianCalendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER);\nmap.register(BigDecimal.class, BIG_DECIMAL_TYPE_ADAPTER);\nmap.register(BigInteger.class, BIG_INTEGER_TYPE_ADAPTER);\nmap.register(Boolean.class, BOOLEAN_TYPE_ADAPTER);\nmap.register(boolean.class, BOOLEAN_TYPE_ADAPTER);\nmap.register(Byte.class, BYTE_TYPE_ADAPTER);\nmap.register(byte.class, BYTE_TYPE_ADAPTER);\nmap.register(Character.class, CHARACTER_TYPE_ADAPTER);\nmap.register(char.class, CHARACTER_TYPE_ADAPTER);\nmap.register(Integer.class, INTEGER_TYPE_ADAPTER);\nmap.register(int.class, INTEGER_TYPE_ADAPTER);\nmap.register(Number.class, NUMBER_TYPE_ADAPTER);\nmap.register(Short.class, SHORT_TYPE_ADAPTER);\nmap.register(short.class, SHORT_TYPE_ADAPTER);\nmap.register(String.class, STRING_TYPE_ADAPTER);\nmap.makeUnmodifiable();\nreturn map;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters:createDefaultDeserializers()Lcom/google/gson/ParameterizedTypeHandlerMap;",
                                    "method_body": "private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers() {\nParameterizedTypeHandlerMap<JsonDeserializer<?>> map =\nmap.registerForTypeHierarchy(Enum.class, wrapDeserializer(ENUM_TYPE_ADAPTER));\nmap.register(URL.class, wrapDeserializer(URL_TYPE_ADAPTER));\nmap.register(URI.class, wrapDeserializer(URI_TYPE_ADAPTER));\nmap.register(UUID.class, wrapDeserializer(UUUID_TYPE_ADAPTER));\nmap.register(Locale.class, wrapDeserializer(LOCALE_TYPE_ADAPTER));\nmap.registerForTypeHierarchy(Collection.class, wrapDeserializer(COLLECTION_TYPE_ADAPTER));\nmap.registerForTypeHierarchy(Map.class, wrapDeserializer(MAP_TYPE_ADAPTER));\nmap.register(Date.class, wrapDeserializer(DATE_TYPE_ADAPTER));\nmap.register(java.sql.Date.class, wrapDeserializer(JAVA_SQL_DATE_TYPE_ADAPTER));\nmap.register(Timestamp.class, wrapDeserializer(TIMESTAMP_DESERIALIZER));\nmap.register(Time.class, wrapDeserializer(TIME_TYPE_ADAPTER));\nmap.register(Calendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER);\nmap.register(GregorianCalendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER);\nmap.register(BigDecimal.class, wrapDeserializer(BIG_DECIMAL_TYPE_ADAPTER));\nmap.register(BigInteger.class, wrapDeserializer(BIG_INTEGER_TYPE_ADAPTER));\nmap.register(Boolean.class, wrapDeserializer(BOOLEAN_TYPE_ADAPTER));\nmap.register(boolean.class, wrapDeserializer(BOOLEAN_TYPE_ADAPTER));\nmap.register(Byte.class, wrapDeserializer(BYTE_TYPE_ADAPTER));\nmap.register(byte.class, wrapDeserializer(BYTE_TYPE_ADAPTER));\nmap.register(Character.class, wrapDeserializer(CHARACTER_TYPE_ADAPTER));\nmap.register(char.class, wrapDeserializer(CHARACTER_TYPE_ADAPTER));\nmap.register(Double.class, wrapDeserializer(DOUBLE_TYPE_ADAPTER));\nmap.register(double.class, wrapDeserializer(DOUBLE_TYPE_ADAPTER));\nmap.register(Float.class, wrapDeserializer(FLOAT_TYPE_ADAPTER));\nmap.register(float.class, wrapDeserializer(FLOAT_TYPE_ADAPTER));\nmap.register(Integer.class, wrapDeserializer(INTEGER_TYPE_ADAPTER));\nmap.register(int.class, wrapDeserializer(INTEGER_TYPE_ADAPTER));\nmap.register(Long.class, wrapDeserializer(LONG_DESERIALIZER));\nmap.register(long.class, wrapDeserializer(LONG_DESERIALIZER));\nmap.register(Number.class, wrapDeserializer(NUMBER_TYPE_ADAPTER));\nmap.register(Short.class, wrapDeserializer(SHORT_TYPE_ADAPTER));\nmap.register(short.class, wrapDeserializer(SHORT_TYPE_ADAPTER));\nmap.register(String.class, wrapDeserializer(STRING_TYPE_ADAPTER));\nmap.makeUnmodifiable();\nreturn map;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters:createDefaultInstanceCreators()Lcom/google/gson/ParameterizedTypeHandlerMap;",
                                    "method_body": "private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators() {\nParameterizedTypeHandlerMap<InstanceCreator<?>> map =\nmap.registerForTypeHierarchy(Map.class, MAP_TYPE_ADAPTER);\nmap.registerForTypeHierarchy(Collection.class, COLLECTION_TYPE_ADAPTER);\nmap.registerForTypeHierarchy(Set.class, HASH_SET_CREATOR);\nmap.registerForTypeHierarchy(SortedSet.class, TREE_SET_CREATOR);\nmap.register(Properties.class, PROPERTIES_CREATOR);\nmap.makeUnmodifiable();\nreturn map;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters:wrapDeserializer(Lcom/google/gson/JsonDeserializer;)Lcom/google/gson/JsonDeserializer;",
                                    "method_body": "private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer) {\nreturn new JsonDeserializerExceptionWrapper(deserializer);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters:getDefaultSerializers()Lcom/google/gson/ParameterizedTypeHandlerMap;",
                                    "method_body": "static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers() {\nreturn getDefaultSerializers(false, LongSerializationPolicy.DEFAULT);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters:getDefaultSerializers(ZLcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/ParameterizedTypeHandlerMap;",
                                    "method_body": "static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(\nParameterizedTypeHandlerMap<JsonSerializer<?>> serializers =\nDefaultTypeAdapters.DoubleSerializer doubleSerializer =\nserializers.registerIfAbsent(Double.class, doubleSerializer);\nserializers.registerIfAbsent(double.class, doubleSerializer);\nDefaultTypeAdapters.FloatSerializer floatSerializer =\nserializers.registerIfAbsent(Float.class, floatSerializer);\nserializers.registerIfAbsent(float.class, floatSerializer);\nDefaultTypeAdapters.LongSerializer longSerializer =\nserializers.registerIfAbsent(Long.class, longSerializer);\nserializers.registerIfAbsent(long.class, longSerializer);\nserializers.registerIfAbsent(DEFAULT_SERIALIZERS);\nreturn serializers;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters:getDefaultDeserializers()Lcom/google/gson/ParameterizedTypeHandlerMap;",
                                    "method_body": "static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers() {\nreturn DEFAULT_DESERIALIZERS;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters:getDefaultInstanceCreators()Lcom/google/gson/ParameterizedTypeHandlerMap;",
                                    "method_body": "static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators() {\nreturn DEFAULT_INSTANCE_CREATORS;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters$DefaultDateTypeAdapter:<init>()V",
                                    "method_body": "DefaultDateTypeAdapter() {\nthis.format = DateFormat.getDateTimeInstance();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters$DefaultJavaSqlDateTypeAdapter:<init>()V",
                                    "method_body": "DefaultJavaSqlDateTypeAdapter() {\nthis.format = new SimpleDateFormat(\"MMM d, yyyy\");\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters$DefaultTimeTypeAdapter:<init>()V",
                                    "method_body": "DefaultTimeTypeAdapter() {\nthis.format = new SimpleDateFormat(\"hh:mm:ss a\");\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:<init>()V",
                                    "method_body": "private static final Logger logger =\nprivate final Map<Type, T> map = new HashMap<Type, T>();\nprivate final List<Pair<Class<?>, T>> typeHierarchyList = new ArrayList<Pair<Class<?>, T>>();\nprivate boolean modifiable = true;\nPair<Class<?>, T> pair = new Pair<Class<?>, T>(typeOfT, value);\nregisterForTypeHierarchy(pair);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:<clinit>()V",
                                    "method_body": "private static final Logger logger =\nprivate final Map<Type, T> map = new HashMap<Type, T>();\nprivate final List<Pair<Class<?>, T>> typeHierarchyList = new ArrayList<Pair<Class<?>, T>>();\nprivate boolean modifiable = true;\nPair<Class<?>, T> pair = new Pair<Class<?>, T>(typeOfT, value);\nregisterForTypeHierarchy(pair);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:registerForTypeHierarchy(Ljava/lang/Class;Ljava/lang/Object;)V",
                                    "method_body": "public synchronized void registerForTypeHierarchy(Class<?> typeOfT, T value) {\nPair<Class<?>, T> pair = new Pair<Class<?>, T>(typeOfT, value);\nregisterForTypeHierarchy(pair);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:registerForTypeHierarchy(Lcom/google/gson/Pair;)V",
                                    "method_body": "public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\nif (!modifiable) {\nint index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\nif (index >= 0) {\nindex = getIndexOfAnOverriddenHandler(pair.first);\nif (index >= 0) {\ntypeHierarchyList.add(0, pair);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:getIndexOfAnOverriddenHandler(Ljava/lang/Class;)I",
                                    "method_body": "private int getIndexOfAnOverriddenHandler(Class<?> type) {\nfor (int i = typeHierarchyList.size()-1; i >= 0; --i) {\nPair<Class<?>, T> entry = typeHierarchyList.get(i);\nif (type.isAssignableFrom(entry.first)) {\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:register(Ljava/lang/reflect/Type;Ljava/lang/Object;)V",
                                    "method_body": "public synchronized void register(Type typeOfT, T value) {\nif (!modifiable) {\nif (hasSpecificHandlerFor(typeOfT)) {\nmap.put(typeOfT, value);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:registerIfAbsent(Lcom/google/gson/ParameterizedTypeHandlerMap;)V",
                                    "method_body": "public synchronized void registerIfAbsent(ParameterizedTypeHandlerMap<T> other) {\nif (!modifiable) {\nfor (Map.Entry<Type, T> entry : other.map.entrySet()) {\nif (!map.containsKey(entry.getKey())) {\nregister(entry.getKey(), entry.getValue());\n}\nfor (int i = other.typeHierarchyList.size()-1; i >= 0; --i) {\nPair<Class<?>, T> entry = other.typeHierarchyList.get(i);\nint index = getIndexOfSpecificHandlerForTypeHierarchy(entry.first);\nif (index < 0) {\nregisterForTypeHierarchy(entry);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:registerIfAbsent(Ljava/lang/reflect/Type;Ljava/lang/Object;)V",
                                    "method_body": "public synchronized void registerIfAbsent(Type typeOfT, T value) {\nif (!modifiable) {\nif (!map.containsKey(typeOfT)) {\nregister(typeOfT, value);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:makeUnmodifiable()V",
                                    "method_body": "public synchronized void makeUnmodifiable() {\nmodifiable = false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:getHandlerFor(Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public synchronized T getHandlerFor(Type type) {\nT handler = map.get(type);\nif (handler == null) {\nClass<?> rawClass = TypeUtils.toRawClass(type);\nif (rawClass != type) {\nif (handler == null) {\nhandler = getHandlerForTypeHierarchy(rawClass);\nreturn handler;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:getHandlerForTypeHierarchy(Ljava/lang/Class;)Ljava/lang/Object;",
                                    "method_body": "private T getHandlerForTypeHierarchy(Class<?> type) {\nfor (Pair<Class<?>, T> entry : typeHierarchyList) {\nif (entry.first.isAssignableFrom(type)) {\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:hasSpecificHandlerFor(Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public synchronized boolean hasSpecificHandlerFor(Type type) {\nreturn map.containsKey(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:getIndexOfSpecificHandlerForTypeHierarchy(Ljava/lang/Class;)I",
                                    "method_body": "private synchronized int getIndexOfSpecificHandlerForTypeHierarchy(Class<?> type) {\nfor (int i = typeHierarchyList.size()-1; i >= 0; --i) {\nif (type.equals(typeHierarchyList.get(i).first)) {\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Pair:<init>(Ljava/lang/Object;Ljava/lang/Object;)V",
                                    "method_body": "Pair(FIRST first, SECOND second) {\nthis.first = first;\nthis.second = second;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonDeserializerExceptionWrapper:<init>(Lcom/google/gson/JsonDeserializer;)V",
                                    "method_body": "JsonDeserializerExceptionWrapper(JsonDeserializer<T> delegate) {\nPreconditions.checkNotNull(delegate);\nthis.delegate = delegate;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.LongSerializationPolicy:<init>(Ljava/lang/String;ILcom/google/gson/LongSerializationPolicy$Strategy;)V",
                                    "method_body": "private LongSerializationPolicy(Strategy strategy) {\nthis.strategy = strategy;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.LongSerializationPolicy$DefaultStrategy:<init>(Lcom/google/gson/LongSerializationPolicy$1;)V",
                                    "method_body": "JsonElement serialize(Long value);\nprivate static class DefaultStrategy implements Strategy {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters$DoubleSerializer:<init>(Z)V",
                                    "method_body": "DoubleSerializer(boolean serializeSpecialDoubleValues) {\nthis.serializeSpecialFloatingPointValues = serializeSpecialDoubleValues;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters$FloatSerializer:<init>(Z)V",
                                    "method_body": "FloatSerializer(boolean serializeSpecialDoubleValues) {\nthis.serializeSpecialFloatingPointValues = serializeSpecialDoubleValues;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters$LongSerializer:<init>(Lcom/google/gson/LongSerializationPolicy;)V",
                                    "method_body": "private LongSerializer(LongSerializationPolicy longSerializationPolicy) {\nthis.longSerializationPolicy = longSerializationPolicy;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeInfo:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeInfo(Type actualType) {\nthis.actualType = actualType;\nrawClass = TypeUtils.toRawClass(actualType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeInfo:getActualType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getActualType() {\nreturn actualType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeInfo:getRawClass()Ljava/lang/Class;",
                                    "method_body": "public final Class<?> getRawClass() {\nreturn rawClass;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeInfo:isArray()Z",
                                    "method_body": "public final boolean isArray() {\nreturn TypeUtils.isArray(rawClass);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeUtils:isArray(Ljava/lang/reflect/Type;)Z",
                                    "method_body": "static boolean isArray(Type type) {\nif (type instanceof Class<?>) {\nreturn ((Class<?>)type).isArray();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeUtils:toRawClass(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "static Class<?> toRawClass(Type type) {\nif (type instanceof Class<?>) {\nreturn (Class<?>) type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.FieldAttributes:<init>(Ljava/lang/Class;Ljava/lang/reflect/Field;)V",
                                    "method_body": "FieldAttributes(final Class<?> declaringClazz, final Field f) {\nPreconditions.checkNotNull(declaringClazz);\nthis.declaringClazz = declaringClazz;\nname = f.getName();\ndeclaredType = f.getType();\nisSynthetic = f.isSynthetic();\nmodifiers = f.getModifiers();\nfield = f;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.FieldAttributes:<clinit>()V",
                                    "method_body": "private static final String MAX_CACHE_PROPERTY_NAME =\nprivate static final Cache<Pair<Class<?>, String>, Collection<Annotation>> ANNOTATION_CACHE =\n* Constructs a Field Attributes object from the {@code f}."
                                },
                                {
                                    "method_signature": "com.google.gson.FieldAttributes:getMaxCacheSize()I",
                                    "method_body": "private static int getMaxCacheSize() {\nfinal int defaultMaxCacheSize = 2000;\nString propertyValue = System.getProperty(\nreturn Integer.parseInt(propertyValue);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.FieldAttributes:getDeclaredClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getDeclaredClass() {\nreturn declaredType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.FieldAttributes:hasModifier(I)Z",
                                    "method_body": "public boolean hasModifier(int modifier) {\nreturn (modifiers & modifier) != 0;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.FieldAttributes:isSynthetic()Z",
                                    "method_body": "boolean isSynthetic() {\nreturn isSynthetic;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.LruCache:<init>(I)V",
                                    "method_body": "LruCache(int maxCapacity) {\nsuper(maxCapacity, 0.7F, true);\nthis.maxCapacity = maxCapacity;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonSerializationContextDefault:<init>(Lcom/google/gson/ObjectNavigatorFactory;ZLcom/google/gson/ParameterizedTypeHandlerMap;)V",
                                    "method_body": "JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls,\nParameterizedTypeHandlerMap<JsonSerializer<?>> serializers) {\nthis.factory = factory;\nthis.serializeNulls = serializeNulls;\nthis.serializers = serializers;\nthis.ancestors = new MemoryRefStack();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonSerializationContextDefault:serialize(Ljava/lang/Object;Ljava/lang/reflect/Type;Z)Lcom/google/gson/JsonElement;",
                                    "method_body": "public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType) {\nObjectNavigator on = factory.create(new ObjectTypePair(src, typeOfSrc, preserveType));\nJsonSerializationVisitor visitor =\non.accept(visitor);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ObjectNavigatorFactory:<init>(Lcom/google/gson/ExclusionStrategy;Lcom/google/gson/FieldNamingStrategy2;)V",
                                    "method_body": "public ObjectNavigatorFactory(ExclusionStrategy strategy, FieldNamingStrategy2 fieldNamingPolicy) {\nPreconditions.checkNotNull(fieldNamingPolicy);\nthis.strategy = (strategy == null ? new NullExclusionStrategy() : strategy);\nthis.fieldNamingPolicy = fieldNamingPolicy;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ObjectNavigatorFactory:create(Lcom/google/gson/ObjectTypePair;)Lcom/google/gson/ObjectNavigator;",
                                    "method_body": "public ObjectNavigator create(ObjectTypePair objTypePair) {\nreturn new ObjectNavigator(objTypePair, strategy);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.MemoryRefStack:<init>()V",
                                    "method_body": "private final Stack<ObjectTypePair> stack = new Stack<ObjectTypePair>();\nPreconditions.checkNotNull(obj);\nreturn stack.push(obj);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.MemoryRefStack:push(Lcom/google/gson/ObjectTypePair;)Lcom/google/gson/ObjectTypePair;",
                                    "method_body": "public ObjectTypePair push(ObjectTypePair obj) {\nPreconditions.checkNotNull(obj);\nreturn stack.push(obj);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.MemoryRefStack:pop()Lcom/google/gson/ObjectTypePair;",
                                    "method_body": "public ObjectTypePair pop() {\nreturn stack.pop();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.MemoryRefStack:contains(Lcom/google/gson/ObjectTypePair;)Z",
                                    "method_body": "public boolean contains(ObjectTypePair obj) {\nif (obj == null) {\nfor (ObjectTypePair stackObject : stack) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ObjectTypePair:<init>(Ljava/lang/Object;Ljava/lang/reflect/Type;Z)V",
                                    "method_body": "ObjectTypePair(Object obj, Type type, boolean preserveType) {\nthis.obj = obj;\nthis.type = type;\nthis.preserveType = preserveType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ObjectTypePair:getObject()Ljava/lang/Object;",
                                    "method_body": "Object getObject() {\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ObjectTypePair:setObject(Ljava/lang/Object;)V",
                                    "method_body": "void setObject(Object obj) {\nthis.obj = obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ObjectTypePair:getMatchingHandler(Lcom/google/gson/ParameterizedTypeHandlerMap;)Lcom/google/gson/Pair;",
                                    "method_body": "<HANDLER> Pair<HANDLER, ObjectTypePair> getMatchingHandler(\nHANDLER handler = null;\nif (!preserveType && obj != null) {\nhandler = handlers.getHandlerFor(type);\nreturn handler == null ? null : new Pair<HANDLER, ObjectTypePair>(handler, this);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ObjectTypePair:toMoreSpecificType()Lcom/google/gson/ObjectTypePair;",
                                    "method_body": "ObjectTypePair toMoreSpecificType() {\nif (preserveType || obj == null) {\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ObjectNavigator:<init>(Lcom/google/gson/ObjectTypePair;Lcom/google/gson/ExclusionStrategy;)V",
                                    "method_body": "public void start(ObjectTypePair node);\nObjectNavigator(ObjectTypePair objTypePair, ExclusionStrategy exclusionStrategy) {\nPreconditions.checkNotNull(exclusionStrategy);\nthis.objTypePair = objTypePair;\nthis.exclusionStrategy = exclusionStrategy;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ObjectNavigator:accept(Lcom/google/gson/ObjectNavigator$Visitor;)V",
                                    "method_body": "public void accept(Visitor visitor) {\nTypeInfo objTypeInfo = new TypeInfo(objTypePair.type);\nif (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) {\nboolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair);\nif (!visitedWithCustomHandler) {\nObject obj = objTypePair.getObject();\nObject objectToVisit = (obj == null) ? visitor.getTarget() : obj;\nif (objectToVisit == null) {\nobjTypePair.setObject(objectToVisit);\nvisitor.start(objTypePair);\nif (objTypeInfo.isArray()) {\n} else if (objTypeInfo.getActualType() == Object.class\nvisitor.startVisitingObject(objectToVisit);\nObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType();\nClass<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass();\nfor (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr =\nif (!curr.isSynthetic()) {\nnavigateClassFields(objectToVisit, curr, visitor);\nvisitor.end(objTypePair);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ObjectNavigator:navigateClassFields(Ljava/lang/Object;Ljava/lang/Class;Lcom/google/gson/ObjectNavigator$Visitor;)V",
                                    "method_body": "private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor) {\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field f : fields) {\nFieldAttributes fieldAttributes = new FieldAttributes(clazz, f);\nif (exclusionStrategy.shouldSkipField(fieldAttributes)\nTypeInfo fieldTypeInfo = TypeInfoFactory.getTypeInfoForField(f, objTypePair.type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonSerializationVisitor:<init>(Lcom/google/gson/ObjectNavigatorFactory;ZLcom/google/gson/ParameterizedTypeHandlerMap;Lcom/google/gson/JsonSerializationContext;Lcom/google/gson/MemoryRefStack;)V",
                                    "method_body": "JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls,\nMemoryRefStack ancestors) {\nthis.factory = factory;\nthis.serializeNulls = serializeNulls;\nthis.serializers = serializers;\nthis.context = context;\nthis.ancestors = ancestors;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonSerializationVisitor:start(Lcom/google/gson/ObjectTypePair;)V",
                                    "method_body": "public void start(ObjectTypePair node) {\nif (node == null) {\nif (ancestors.contains(node)) {\nancestors.push(node);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonSerializationVisitor:end(Lcom/google/gson/ObjectTypePair;)V",
                                    "method_body": "public void end(ObjectTypePair node) {\nif (node != null) {\nancestors.pop();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonSerializationVisitor:startVisitingObject(Ljava/lang/Object;)V",
                                    "method_body": "public void startVisitingObject(Object node) {\nassignToRoot(new JsonObject());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonSerializationVisitor:visitUsingCustomHandler(Lcom/google/gson/ObjectTypePair;)Z",
                                    "method_body": "public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) {\nObject obj = objTypePair.getObject();\nif (obj == null) {\nJsonElement element = findAndInvokeCustomSerializer(objTypePair);\nif (element != null) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonSerializationVisitor:findAndInvokeCustomSerializer(Lcom/google/gson/ObjectTypePair;)Lcom/google/gson/JsonElement;",
                                    "method_body": "private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) {\nPair<JsonSerializer<?>,ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers);\nif (pair == null) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonSerializationVisitor:assignToRoot(Lcom/google/gson/JsonElement;)V",
                                    "method_body": "private void assignToRoot(JsonElement newRoot) {\nPreconditions.checkNotNull(newRoot);\nroot = newRoot;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeInfoFactory:getTypeInfoForField(Ljava/lang/reflect/Field;Ljava/lang/reflect/Type;)Lcom/google/gson/TypeInfo;",
                                    "method_body": "public static TypeInfo getTypeInfoForField(Field f, Type typeDefiningF) {\nClass<?> classDefiningF = TypeUtils.toRawClass(typeDefiningF);\nType type = f.getGenericType();\nType actualType = getActualType(type, typeDefiningF, classDefiningF);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeInfoFactory:getActualType(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "private static Type getActualType(\nif (typeToEvaluate instanceof Class<?>) {\n} else if (typeToEvaluate instanceof ParameterizedType) {\n} else if (typeToEvaluate instanceof GenericArrayType) {\n} else if (typeToEvaluate instanceof TypeVariable<?>) {\nif (parentType instanceof ParameterizedType) {\nthrow new UnsupportedOperationException(\"Expecting parameterized type, got \" + parentType\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 2,
                    "tests": [
                        {
                            "test_name": "com.google.gson.functional.DefaultTypeAdaptersTest.testJsonElementTypeMismatch",
                            "test_body": "621: public void testJsonElementTypeMismatch() {\n622: try {\n623: gson.fromJson(\"\\\"abc\\\"\", JsonObject.class);\n624: fail();\n625: } catch (JsonSyntaxException expected) {\n626: assertEquals(\"Expected a com.google.gson.JsonObject but was com.google.gson.JsonPrimitive\",\n627: expected.getMessage());\n628: }\n629: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\nreturn (Class<?>) type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:<init>(Ljava/lang/String;)V",
                                    "method_body": "public JsonPrimitive(String string) {\nsetValue(string);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:<clinit>()V",
                                    "method_body": "private static final Class<?>[] PRIMITIVE_TYPES = { int.class, long.class, short.class,\nShort.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class };"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:setValue(Ljava/lang/Object;)V",
                                    "method_body": "void setValue(Object primitive) {\nif (primitive instanceof Character) {\n$Gson$Preconditions.checkArgument(primitive instanceof Number\nthis.value = primitive;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:isPrimitiveOrString(Ljava/lang/Object;)Z",
                                    "method_body": "private static boolean isPrimitiveOrString(Object target) {\nif (target instanceof String) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingPolicy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\nfactories.add(excluder);\nfactories.addAll(typeAdapterFactories);\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class,\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nfactories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type);\nif (cached != null) {\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\nthreadCalls.remove(type);\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException {\nObject object = fromJson(json, (Type) classOfT);\nreturn Primitives.wrap(classOfT).cast(object);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {\nif (json == null) {\nStringReader reader = new StringReader(json);\nT target = (T) fromJson(reader, typeOfT);\nreturn target;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/io/Reader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nJsonReader jsonReader = new JsonReader(json);\nT object = (T) fromJson(jsonReader, typeOfT);\nassertFullConsumption(object, jsonReader);\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:assertFullConsumption(Ljava/lang/Object;Lcom/google/gson/stream/JsonReader;)V",
                                    "method_body": "private static void assertFullConsumption(Object obj, JsonReader reader) {\nif (obj != null && reader.peek() != JsonToken.END_DOCUMENT) {\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Lcom/google/gson/stream/JsonReader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nboolean isEmpty = true;\nboolean oldLenient = reader.isLenient();\nreader.setLenient(true);\nreader.peek();\nisEmpty = false;\nTypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\nTypeAdapter<T> typeAdapter = getAdapter(typeToken);\nT object = typeAdapter.read(reader);\nreturn object;\nreader.setLenient(oldLenient);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<init>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory CALENDAR_FACTORY =\npublic static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn (TypeAdapter<T2>) typeAdapter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$31:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn (TypeAdapter<T2>) typeAdapter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$25:read(Lcom/google/gson/stream/JsonReader;)Lcom/google/gson/JsonElement;",
                                    "method_body": "@Override public JsonElement read(JsonReader in) throws IOException {\nswitch (in.peek()) {\nreturn new JsonPrimitive(in.nextString());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nFieldNamingStrategy fieldNamingPolicy, Excluder excluder) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "private String[] pathNames = new String[32];\nprivate int[] pathIndices = new int[32];\n* Creates a new instance that reads a JSON-encoded stream from {@code in}."
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:setLenient(Z)V",
                                    "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:isLenient()Z",
                                    "method_body": "public final boolean isLenient() {\nreturn lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\nswitch (p) {\nreturn JsonToken.STRING;\nreturn JsonToken.END_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextString()Ljava/lang/String;",
                                    "method_body": "public String nextString() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\nif (p == PEEKED_UNQUOTED) {\n} else if (p == PEEKED_SINGLE_QUOTED) {\n} else if (p == PEEKED_DOUBLE_QUOTED) {\nresult = nextQuotedValue('\"');\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextQuotedValue(C)Ljava/lang/String;",
                                    "method_body": "private String nextQuotedValue(char quote) throws IOException {\nchar[] buffer = this.buffer;\nStringBuilder builder = new StringBuilder();\nint p = pos;\nint l = limit;\nint start = p;\nwhile (p < l) {\nint c = buffer[p++];\nif (c == quote) {\npos = p;\nbuilder.append(buffer, start, p - start - 1);\nreturn builder.toString();\n} else if (c == '\\\\') {\n} else if (c == '\\n') {\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit = 0;\npos = 0;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\nif (limit >= minimum) {\nreturn true;\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\nbreak;\np = pos;\nl = limit;\nint c = buffer[p++];\nif (c == '\\n') {\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\nif (c == '/') {\n} else if (c == '#') {\npos = p;\nreturn c;\nif (throwOnEof) {\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:checkLenient()V",
                                    "method_body": "private void checkLenient() throws IOException {\nif (!lenient) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:consumeNonExecutePrefix()V",
                                    "method_body": "private void consumeNonExecutePrefix() throws IOException {\nnextNonWhitespace(true);\npos--;\nif (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\nfor (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\nif (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\nreturn; // not a security token!\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:<clinit>()V",
                                    "method_body": "public BitSet read(JsonReader in) throws IOException {\nswitch (tokenType) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson$FutureTypeAdapter:setDelegate(Lcom/google/gson/TypeAdapter;)V",
                                    "method_body": "public void setDelegate(TypeAdapter<T> typeAdapter) {\nif (delegate != null) {\ndelegate = typeAdapter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:<clinit>()V",
                                    "method_body": "private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;\nMap<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);\nMap<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);\nadd(primToWrap, wrapToPrim, boolean.class, Boolean.class);\nadd(primToWrap, wrapToPrim, byte.class, Byte.class);\nadd(primToWrap, wrapToPrim, char.class, Character.class);\nadd(primToWrap, wrapToPrim, double.class, Double.class);\nadd(primToWrap, wrapToPrim, float.class, Float.class);\nadd(primToWrap, wrapToPrim, int.class, Integer.class);\nadd(primToWrap, wrapToPrim, long.class, Long.class);\nadd(primToWrap, wrapToPrim, short.class, Short.class);\nadd(primToWrap, wrapToPrim, void.class, Void.class);\nPRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);\nWRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:add(Ljava/util/Map;Ljava/util/Map;Ljava/lang/Class;Ljava/lang/Class;)V",
                                    "method_body": "private static void add(Map<Class<?>, Class<?>> forward,\nforward.put(key, value);\nbackward.put(value, key);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:wrap(Ljava/lang/Class;)Ljava/lang/Class;",
                                    "method_body": "public static <T> Class<T> wrap(Class<T> type) {\nClass<T> wrapped = (Class<T>) PRIMITIVE_TO_WRAPPER_TYPE.get(\nreturn (wrapped == null) ? type : wrapped;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 3,
                    "tests": [
                        {
                            "test_name": "com.google.gson.functional.MapTest.testConcurrentMap",
                            "test_body": "186: public void testConcurrentMap() throws Exception {\n187: Type typeOfMap = new TypeToken<ConcurrentMap<Integer, String>>() {}.getType();\n188: ConcurrentMap<Integer, String> map = gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\n189: assertEquals(1, map.size());\n190: assertTrue(map.containsKey(123));\n191: assertEquals(\"456\", map.get(123));\n192: String json = gson.toJson(map);\n193: assertEquals(\"{\\\"123\\\":\\\"456\\\"}\", json);\n194: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>()V",
                                    "method_body": "protected TypeToken() {\nthis.type = getSuperclassTypeParameter(getClass());\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(type);\nthis.hashCode = type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getSuperclassTypeParameter(Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getSuperclassTypeParameter(Class<?> subclass) {\nType superclass = subclass.getGenericSuperclass();\nif (superclass instanceof Class) {\nParameterizedType parameterized = (ParameterizedType) superclass;\nreturn $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:newParameterizedTypeWithOwner(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)Ljava/lang/reflect/ParameterizedType;",
                                    "method_body": "public static ParameterizedType newParameterizedTypeWithOwner(\nreturn new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\nreturn (Class<?>) type;\n} else if (type instanceof ParameterizedType) {\nParameterizedType parameterizedType = (ParameterizedType) type;\nType rawType = parameterizedType.getRawType();\ncheckArgument(rawType instanceof Class);\nreturn (Class<?>) rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:hashCodeOrZero(Ljava/lang/Object;)I",
                                    "method_body": "private static int hashCodeOrZero(Object o) {\nreturn o != null ? o.hashCode() : 0;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getGenericSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\nif (toResolve == rawType) {\nreturn context;\nif (toResolve.isInterface()) {\nClass<?>[] interfaces = rawType.getInterfaces();\nfor (int i = 0, length = interfaces.length; i < length; i++) {\nif (interfaces[i] == toResolve) {\nreturn rawType.getGenericInterfaces()[i];\n} else if (toResolve.isAssignableFrom(interfaces[i])) {\nreturn getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\ncheckArgument(supertype.isAssignableFrom(contextRawType));\nreturn resolve(context, contextRawType,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getMapKeyAndValueTypes(Ljava/lang/reflect/Type;Ljava/lang/Class;)[Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {\nif (context == Properties.class) {\nType mapType = getSupertype(context, contextRawType, Map.class);\nif (mapType instanceof ParameterizedType) {\nParameterizedType mapParameterizedType = (ParameterizedType) mapType;\nreturn mapParameterizedType.getActualTypeArguments();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\nif (toResolve instanceof TypeVariable) {\nTypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\ntoResolve = resolveTypeVariable(context, contextRawType, typeVariable);\nif (toResolve == typeVariable) {\n} else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n} else if (toResolve instanceof GenericArrayType) {\n} else if (toResolve instanceof ParameterizedType) {\nParameterizedType original = (ParameterizedType) toResolve;\nType ownerType = original.getOwnerType();\nType newOwnerType = resolve(context, contextRawType, ownerType);\nboolean changed = newOwnerType != ownerType;\nType[] args = original.getActualTypeArguments();\nfor (int t = 0, length = args.length; t < length; t++) {\nType resolvedTypeArgument = resolve(context, contextRawType, args[t]);\nif (resolvedTypeArgument != args[t]) {\nif (!changed) {\nargs = args.clone();\nchanged = true;\nargs[t] = resolvedTypeArgument;\nreturn changed\n} else if (toResolve instanceof WildcardType) {\nreturn toResolve;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolveTypeVariable(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/TypeVariable;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\nClass<?> declaredByRaw = declaringClassOf(unknown);\nif (declaredByRaw == null) {\nType declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\nif (declaredBy instanceof ParameterizedType) {\nint index = indexOf(declaredByRaw.getTypeParameters(), unknown);\nreturn ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:indexOf([Ljava/lang/Object;Ljava/lang/Object;)I",
                                    "method_body": "private static int indexOf(Object[] array, Object toFind) {\nfor (int i = 0; i < array.length; i++) {\nif (toFind.equals(array[i])) {\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:declaringClassOf(Ljava/lang/reflect/TypeVariable;)Ljava/lang/Class;",
                                    "method_body": "private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\nGenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\nreturn genericDeclaration instanceof Class\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "private static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$ParameterizedTypeImpl:<init>(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingPolicy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\nfactories.add(excluder);\nfactories.addAll(typeAdapterFactories);\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class,\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nfactories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type);\nif (cached != null) {\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\n}\nthreadCalls.remove(type);\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {\nif (json == null) {\nStringReader reader = new StringReader(json);\nT target = (T) fromJson(reader, typeOfT);\nreturn target;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/io/Reader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nJsonReader jsonReader = new JsonReader(json);\nT object = (T) fromJson(jsonReader, typeOfT);\nassertFullConsumption(object, jsonReader);\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:assertFullConsumption(Ljava/lang/Object;Lcom/google/gson/stream/JsonReader;)V",
                                    "method_body": "private static void assertFullConsumption(Object obj, JsonReader reader) {\nif (obj != null && reader.peek() != JsonToken.END_DOCUMENT) {\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Lcom/google/gson/stream/JsonReader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nboolean isEmpty = true;\nboolean oldLenient = reader.isLenient();\nreader.setLenient(true);\nreader.peek();\nisEmpty = false;\nTypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\nTypeAdapter<T> typeAdapter = getAdapter(typeToken);\nT object = typeAdapter.read(reader);\nreturn object;\nreader.setLenient(oldLenient);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<init>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nif (isAnonymousOrLocal(clazz)) {\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nfinal InstanceCreator<T> rawTypeCreator =\nif (rawTypeCreator != null) {\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\nif (defaultImplementation != null) {\nreturn defaultImplementation;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultConstructor(Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\n} catch (NoSuchMethodException e) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultImplementationConstructor(Ljava/lang/reflect/Type;Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nif (Collection.class.isAssignableFrom(rawType)) {\nif (Map.class.isAssignableFrom(rawType)) {\nif (SortedMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\nreturn (T) new TreeMap<Object, Object>();\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nreturn new ObjectConstructor<T>() {\nreturn (T) new LinkedHashMap<Object, Object>();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory BOOLEAN_FACTORY\npublic static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() {\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$28:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$29:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$7:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Number;",
                                    "method_body": "public Number read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nreturn in.nextInt();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$13:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/String;",
                                    "method_body": "public String read(JsonReader in) throws IOException {\nJsonToken peek = in.peek();\nif (peek == JsonToken.NULL) {\nif (peek == JsonToken.BOOLEAN) {\nreturn in.nextString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$31:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$22:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$30:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nif (type.getRawType() == Object.class) {\nreturn null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == java.sql.Date.class\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nClass<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\nType[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\nTypeAdapter<?> keyAdapter = getKeyAdapter(gson, keyAndValueTypes[0]);\nTypeAdapter<?> valueAdapter = gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\nTypeAdapter<T> result = new Adapter(gson, keyAndValueTypes[0], keyAdapter,\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:getKeyAdapter(Lcom/google/gson/Gson;Ljava/lang/reflect/Type;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<?> getKeyAdapter(Gson context, Type keyType) {\nreturn (keyType == boolean.class || keyType == Boolean.class)\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nFieldNamingStrategy fieldNamingPolicy, Excluder excluder) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "public JsonReader(Reader in) {\nif (in == null) {\nthis.in = in;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<clinit>()V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate boolean lenient = false;\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\nprivate int peeked = PEEKED_NONE;\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:setLenient(Z)V",
                                    "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:isLenient()Z",
                                    "method_body": "public final boolean isLenient() {\nreturn lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:beginObject()V",
                                    "method_body": "public void beginObject() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\nif (p == PEEKED_BEGIN_OBJECT) {\npush(JsonScope.EMPTY_OBJECT);\npeeked = PEEKED_NONE;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:endObject()V",
                                    "method_body": "public void endObject() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\nif (p == PEEKED_END_OBJECT) {\nstackSize--;\npathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!\npathIndices[stackSize - 1]++;\npeeked = PEEKED_NONE;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:hasNext()Z",
                                    "method_body": "public boolean hasNext() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\nreturn p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\nswitch (p) {\nreturn JsonToken.BEGIN_OBJECT;\nreturn JsonToken.STRING;\nreturn JsonToken.END_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:doPeek()I",
                                    "method_body": "private int doPeek() throws IOException {\nint peekStack = stack[stackSize - 1];\nif (peekStack == JsonScope.EMPTY_ARRAY) {\n} else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\nstack[stackSize - 1] = JsonScope.DANGLING_NAME;\nif (peekStack == JsonScope.NONEMPTY_OBJECT) {\nint c = nextNonWhitespace(true);\nswitch (c) {\nreturn peeked = PEEKED_END_OBJECT;\nint c = nextNonWhitespace(true);\nswitch (c) {\nreturn peeked = PEEKED_DOUBLE_QUOTED_NAME;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextString()Ljava/lang/String;",
                                    "method_body": "public String nextString() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\nif (p == PEEKED_UNQUOTED) {\n} else if (p == PEEKED_SINGLE_QUOTED) {\n} else if (p == PEEKED_DOUBLE_QUOTED) {\nresult = nextQuotedValue('\"');\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextQuotedValue(C)Ljava/lang/String;",
                                    "method_body": "private String nextQuotedValue(char quote) throws IOException {\nchar[] buffer = this.buffer;\nStringBuilder builder = new StringBuilder();\nint p = pos;\nint l = limit;\nint start = p;\nwhile (p < l) {\nint c = buffer[p++];\nif (c == quote) {\npos = p;\nbuilder.append(buffer, start, p - start - 1);\nreturn builder.toString();\n} else if (c == '\\\\') {\n} else if (c == '\\n') {\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextInt()I",
                                    "method_body": "public int nextInt() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\nif (p == PEEKED_LONG) {\nif (p == PEEKED_NUMBER) {\n} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\npeekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\nresult = Integer.parseInt(peekedString);\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:push(I)V",
                                    "method_body": "private void push(int newTop) {\nif (stackSize == stack.length) {\nstack[stackSize++] = newTop;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit = 0;\npos = 0;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\nif (limit >= minimum) {\nreturn true;\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\nbreak;\np = pos;\nl = limit;\nint c = buffer[p++];\nif (c == '\\n') {\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\nif (c == '/') {\n} else if (c == '#') {\npos = p;\nreturn c;\nif (throwOnEof) {\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:consumeNonExecutePrefix()V",
                                    "method_body": "private void consumeNonExecutePrefix() throws IOException {\nnextNonWhitespace(true);\npos--;\nif (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\nfor (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\nif (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\nreturn; // not a security token!\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader$1:promoteNameToValue(Lcom/google/gson/stream/JsonReader;)V",
                                    "method_body": "@Override public void promoteNameToValue(JsonReader reader) throws IOException {\nif (reader instanceof JsonTreeReader) {\nint p = reader.peeked;\nif (p == PEEKED_NONE) {\nif (p == PEEKED_DOUBLE_QUOTED_NAME) {\nreader.peeked = PEEKED_DOUBLE_QUOTED;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson$FutureTypeAdapter:setDelegate(Lcom/google/gson/TypeAdapter;)V",
                                    "method_body": "public void setDelegate(TypeAdapter<T> typeAdapter) {\nif (delegate != null) {\ndelegate = typeAdapter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter:<init>(Lcom/google/gson/internal/bind/MapTypeAdapterFactory;Lcom/google/gson/Gson;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Lcom/google/gson/internal/ObjectConstructor;)V",
                                    "method_body": "public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,\nObjectConstructor<? extends Map<K, V>> constructor) {\nthis.keyTypeAdapter =\nthis.valueTypeAdapter =\nthis.constructor = constructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter:read(Lcom/google/gson/stream/JsonReader;)Ljava/util/Map;",
                                    "method_body": "@Override public Map<K, V> read(JsonReader in) throws IOException {\nJsonToken peek = in.peek();\nif (peek == JsonToken.NULL) {\nMap<K, V> map = constructor.construct();\nif (peek == JsonToken.BEGIN_ARRAY) {\nin.beginObject();\nwhile (in.hasNext()) {\nJsonReaderInternalAccess.INSTANCE.promoteNameToValue(in);\nK key = keyTypeAdapter.read(in);\nV value = valueTypeAdapter.read(in);\nV replaced = map.put(key, value);\nif (replaced != null) {\n}\nin.endObject();\nreturn map;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:<init>(Lcom/google/gson/Gson;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeAdapterRuntimeTypeWrapper(Gson context, TypeAdapter<T> delegate, Type type) {\nthis.context = context;\nthis.delegate = delegate;\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Object;",
                                    "method_body": "public T read(JsonReader in) throws IOException {\nreturn delegate.read(in);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor$10:construct()Ljava/lang/Object;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nif (Collection.class.isAssignableFrom(rawType)) {\nif (Map.class.isAssignableFrom(rawType)) {\nif (SortedMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\nreturn (T) new TreeMap<Object, Object>();\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nreturn new ObjectConstructor<T>() {\nreturn (T) new LinkedHashMap<Object, Object>();\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.functional.MapTest.testConcurrentNavigableMap",
                            "test_body": "206: public void testConcurrentNavigableMap() throws Exception {\n207: Type typeOfMap = new TypeToken<ConcurrentNavigableMap<Integer, String>>() {}.getType();\n208: ConcurrentNavigableMap<Integer, String> map = gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\n209: assertEquals(1, map.size());\n210: assertTrue(map.containsKey(123));\n211: assertEquals(\"456\", map.get(123));\n212: String json = gson.toJson(map);\n213: assertEquals(\"{\\\"123\\\":\\\"456\\\"}\", json);\n214: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>()V",
                                    "method_body": "protected TypeToken() {\nthis.type = getSuperclassTypeParameter(getClass());\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(type);\nthis.hashCode = type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getSuperclassTypeParameter(Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getSuperclassTypeParameter(Class<?> subclass) {\nType superclass = subclass.getGenericSuperclass();\nif (superclass instanceof Class) {\nParameterizedType parameterized = (ParameterizedType) superclass;\nreturn $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:newParameterizedTypeWithOwner(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)Ljava/lang/reflect/ParameterizedType;",
                                    "method_body": "public static ParameterizedType newParameterizedTypeWithOwner(\nreturn new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\nreturn (Class<?>) type;\n} else if (type instanceof ParameterizedType) {\nParameterizedType parameterizedType = (ParameterizedType) type;\nType rawType = parameterizedType.getRawType();\ncheckArgument(rawType instanceof Class);\nreturn (Class<?>) rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:hashCodeOrZero(Ljava/lang/Object;)I",
                                    "method_body": "private static int hashCodeOrZero(Object o) {\nreturn o != null ? o.hashCode() : 0;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getGenericSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\nif (toResolve == rawType) {\nreturn context;\nif (toResolve.isInterface()) {\nClass<?>[] interfaces = rawType.getInterfaces();\nfor (int i = 0, length = interfaces.length; i < length; i++) {\nif (interfaces[i] == toResolve) {\nreturn rawType.getGenericInterfaces()[i];\n} else if (toResolve.isAssignableFrom(interfaces[i])) {\nreturn getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\ncheckArgument(supertype.isAssignableFrom(contextRawType));\nreturn resolve(context, contextRawType,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getMapKeyAndValueTypes(Ljava/lang/reflect/Type;Ljava/lang/Class;)[Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {\nif (context == Properties.class) {\nType mapType = getSupertype(context, contextRawType, Map.class);\nif (mapType instanceof ParameterizedType) {\nParameterizedType mapParameterizedType = (ParameterizedType) mapType;\nreturn mapParameterizedType.getActualTypeArguments();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\nif (toResolve instanceof TypeVariable) {\nTypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\ntoResolve = resolveTypeVariable(context, contextRawType, typeVariable);\nif (toResolve == typeVariable) {\n} else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n} else if (toResolve instanceof GenericArrayType) {\n} else if (toResolve instanceof ParameterizedType) {\nParameterizedType original = (ParameterizedType) toResolve;\nType ownerType = original.getOwnerType();\nType newOwnerType = resolve(context, contextRawType, ownerType);\nboolean changed = newOwnerType != ownerType;\nType[] args = original.getActualTypeArguments();\nfor (int t = 0, length = args.length; t < length; t++) {\nType resolvedTypeArgument = resolve(context, contextRawType, args[t]);\nif (resolvedTypeArgument != args[t]) {\nif (!changed) {\nargs = args.clone();\nchanged = true;\nargs[t] = resolvedTypeArgument;\nreturn changed\n} else if (toResolve instanceof WildcardType) {\nreturn toResolve;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolveTypeVariable(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/TypeVariable;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\nClass<?> declaredByRaw = declaringClassOf(unknown);\nif (declaredByRaw == null) {\nType declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\nif (declaredBy instanceof ParameterizedType) {\nint index = indexOf(declaredByRaw.getTypeParameters(), unknown);\nreturn ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:indexOf([Ljava/lang/Object;Ljava/lang/Object;)I",
                                    "method_body": "private static int indexOf(Object[] array, Object toFind) {\nfor (int i = 0; i < array.length; i++) {\nif (toFind.equals(array[i])) {\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:declaringClassOf(Ljava/lang/reflect/TypeVariable;)Ljava/lang/Class;",
                                    "method_body": "private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\nGenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\nreturn genericDeclaration instanceof Class\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "private static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$ParameterizedTypeImpl:<init>(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingPolicy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\nfactories.add(excluder);\nfactories.addAll(typeAdapterFactories);\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class,\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nfactories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type);\nif (cached != null) {\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\n}\nthreadCalls.remove(type);\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {\nif (json == null) {\nStringReader reader = new StringReader(json);\nT target = (T) fromJson(reader, typeOfT);\nreturn target;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/io/Reader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nJsonReader jsonReader = new JsonReader(json);\nT object = (T) fromJson(jsonReader, typeOfT);\nassertFullConsumption(object, jsonReader);\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:assertFullConsumption(Ljava/lang/Object;Lcom/google/gson/stream/JsonReader;)V",
                                    "method_body": "private static void assertFullConsumption(Object obj, JsonReader reader) {\nif (obj != null && reader.peek() != JsonToken.END_DOCUMENT) {\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Lcom/google/gson/stream/JsonReader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nboolean isEmpty = true;\nboolean oldLenient = reader.isLenient();\nreader.setLenient(true);\nreader.peek();\nisEmpty = false;\nTypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\nTypeAdapter<T> typeAdapter = getAdapter(typeToken);\nT object = typeAdapter.read(reader);\nreturn object;\nreader.setLenient(oldLenient);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<init>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nif (isAnonymousOrLocal(clazz)) {\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nfinal InstanceCreator<T> rawTypeCreator =\nif (rawTypeCreator != null) {\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\nif (defaultImplementation != null) {\nreturn defaultImplementation;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultConstructor(Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\n} catch (NoSuchMethodException e) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultImplementationConstructor(Ljava/lang/reflect/Type;Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nif (Collection.class.isAssignableFrom(rawType)) {\nif (Map.class.isAssignableFrom(rawType)) {\nif (SortedMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\nreturn (T) new TreeMap<Object, Object>();\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nreturn new ObjectConstructor<T>() {\nreturn (T) new LinkedHashMap<Object, Object>();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory BOOLEAN_FACTORY\npublic static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() {\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$28:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$29:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$7:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Number;",
                                    "method_body": "public Number read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nreturn in.nextInt();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$13:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/String;",
                                    "method_body": "public String read(JsonReader in) throws IOException {\nJsonToken peek = in.peek();\nif (peek == JsonToken.NULL) {\nif (peek == JsonToken.BOOLEAN) {\nreturn in.nextString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$31:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$22:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$30:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nif (type.getRawType() == Object.class) {\nreturn null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == java.sql.Date.class\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nClass<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\nType[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\nTypeAdapter<?> keyAdapter = getKeyAdapter(gson, keyAndValueTypes[0]);\nTypeAdapter<?> valueAdapter = gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\nTypeAdapter<T> result = new Adapter(gson, keyAndValueTypes[0], keyAdapter,\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:getKeyAdapter(Lcom/google/gson/Gson;Ljava/lang/reflect/Type;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<?> getKeyAdapter(Gson context, Type keyType) {\nreturn (keyType == boolean.class || keyType == Boolean.class)\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nFieldNamingStrategy fieldNamingPolicy, Excluder excluder) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "public JsonReader(Reader in) {\nif (in == null) {\nthis.in = in;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<clinit>()V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate boolean lenient = false;\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\nprivate int peeked = PEEKED_NONE;\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:setLenient(Z)V",
                                    "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:isLenient()Z",
                                    "method_body": "public final boolean isLenient() {\nreturn lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:beginObject()V",
                                    "method_body": "public void beginObject() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\nif (p == PEEKED_BEGIN_OBJECT) {\npush(JsonScope.EMPTY_OBJECT);\npeeked = PEEKED_NONE;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:endObject()V",
                                    "method_body": "public void endObject() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\nif (p == PEEKED_END_OBJECT) {\nstackSize--;\npathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!\npathIndices[stackSize - 1]++;\npeeked = PEEKED_NONE;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:hasNext()Z",
                                    "method_body": "public boolean hasNext() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\nreturn p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\nswitch (p) {\nreturn JsonToken.BEGIN_OBJECT;\nreturn JsonToken.STRING;\nreturn JsonToken.END_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:doPeek()I",
                                    "method_body": "private int doPeek() throws IOException {\nint peekStack = stack[stackSize - 1];\nif (peekStack == JsonScope.EMPTY_ARRAY) {\n} else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\nstack[stackSize - 1] = JsonScope.DANGLING_NAME;\nif (peekStack == JsonScope.NONEMPTY_OBJECT) {\nint c = nextNonWhitespace(true);\nswitch (c) {\nreturn peeked = PEEKED_END_OBJECT;\nint c = nextNonWhitespace(true);\nswitch (c) {\nreturn peeked = PEEKED_DOUBLE_QUOTED_NAME;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextString()Ljava/lang/String;",
                                    "method_body": "public String nextString() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\nif (p == PEEKED_UNQUOTED) {\n} else if (p == PEEKED_SINGLE_QUOTED) {\n} else if (p == PEEKED_DOUBLE_QUOTED) {\nresult = nextQuotedValue('\"');\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextQuotedValue(C)Ljava/lang/String;",
                                    "method_body": "private String nextQuotedValue(char quote) throws IOException {\nchar[] buffer = this.buffer;\nStringBuilder builder = new StringBuilder();\nint p = pos;\nint l = limit;\nint start = p;\nwhile (p < l) {\nint c = buffer[p++];\nif (c == quote) {\npos = p;\nbuilder.append(buffer, start, p - start - 1);\nreturn builder.toString();\n} else if (c == '\\\\') {\n} else if (c == '\\n') {\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextInt()I",
                                    "method_body": "public int nextInt() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\nif (p == PEEKED_LONG) {\nif (p == PEEKED_NUMBER) {\n} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\npeekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\nresult = Integer.parseInt(peekedString);\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:push(I)V",
                                    "method_body": "private void push(int newTop) {\nif (stackSize == stack.length) {\nstack[stackSize++] = newTop;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit = 0;\npos = 0;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\nif (limit >= minimum) {\nreturn true;\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\nbreak;\np = pos;\nl = limit;\nint c = buffer[p++];\nif (c == '\\n') {\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\nif (c == '/') {\n} else if (c == '#') {\npos = p;\nreturn c;\nif (throwOnEof) {\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:consumeNonExecutePrefix()V",
                                    "method_body": "private void consumeNonExecutePrefix() throws IOException {\nnextNonWhitespace(true);\npos--;\nif (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\nfor (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\nif (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\nreturn; // not a security token!\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader$1:promoteNameToValue(Lcom/google/gson/stream/JsonReader;)V",
                                    "method_body": "@Override public void promoteNameToValue(JsonReader reader) throws IOException {\nif (reader instanceof JsonTreeReader) {\nint p = reader.peeked;\nif (p == PEEKED_NONE) {\nif (p == PEEKED_DOUBLE_QUOTED_NAME) {\nreader.peeked = PEEKED_DOUBLE_QUOTED;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson$FutureTypeAdapter:setDelegate(Lcom/google/gson/TypeAdapter;)V",
                                    "method_body": "public void setDelegate(TypeAdapter<T> typeAdapter) {\nif (delegate != null) {\ndelegate = typeAdapter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter:<init>(Lcom/google/gson/internal/bind/MapTypeAdapterFactory;Lcom/google/gson/Gson;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Lcom/google/gson/internal/ObjectConstructor;)V",
                                    "method_body": "public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,\nObjectConstructor<? extends Map<K, V>> constructor) {\nthis.keyTypeAdapter =\nthis.valueTypeAdapter =\nthis.constructor = constructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter:read(Lcom/google/gson/stream/JsonReader;)Ljava/util/Map;",
                                    "method_body": "@Override public Map<K, V> read(JsonReader in) throws IOException {\nJsonToken peek = in.peek();\nif (peek == JsonToken.NULL) {\nMap<K, V> map = constructor.construct();\nif (peek == JsonToken.BEGIN_ARRAY) {\nin.beginObject();\nwhile (in.hasNext()) {\nJsonReaderInternalAccess.INSTANCE.promoteNameToValue(in);\nK key = keyTypeAdapter.read(in);\nV value = valueTypeAdapter.read(in);\nV replaced = map.put(key, value);\nif (replaced != null) {\n}\nin.endObject();\nreturn map;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:<init>(Lcom/google/gson/Gson;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeAdapterRuntimeTypeWrapper(Gson context, TypeAdapter<T> delegate, Type type) {\nthis.context = context;\nthis.delegate = delegate;\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Object;",
                                    "method_body": "public T read(JsonReader in) throws IOException {\nreturn delegate.read(in);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor$9:construct()Ljava/lang/Object;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nif (Collection.class.isAssignableFrom(rawType)) {\nif (Map.class.isAssignableFrom(rawType)) {\nif (SortedMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\nreturn (T) new TreeMap<Object, Object>();\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nreturn new ObjectConstructor<T>() {\nreturn (T) new LinkedHashMap<Object, Object>();\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 4,
                    "tests": [
                        {
                            "test_name": "com.google.gson.stream.JsonReaderTest.testTopLevelValueTypes",
                            "test_body": "1222: public void testTopLevelValueTypes() throws IOException {\n1223: JsonReader reader1 = new JsonReader(reader(\"true\"));\n1224: assertTrue(reader1.nextBoolean());\n1225: assertEquals(JsonToken.END_DOCUMENT, reader1.peek());\n1226: 1227: JsonReader reader2 = new JsonReader(reader(\"false\"));\n1228: assertFalse(reader2.nextBoolean());\n1229: assertEquals(JsonToken.END_DOCUMENT, reader2.peek());\n1230: 1231: JsonReader reader3 = new JsonReader(reader(\"null\"));\n1232: assertEquals(JsonToken.NULL, reader3.peek());\n1233: reader3.nextNull();\n1234: assertEquals(JsonToken.END_DOCUMENT, reader3.peek());\n1235: 1236: JsonReader reader4 = new JsonReader(reader(\"123\"));\n1237: assertEquals(123, reader4.nextInt());\n1238: assertEquals(JsonToken.END_DOCUMENT, reader4.peek());\n1239: 1240: JsonReader reader5 = new JsonReader(reader(\"123.4\"));\n1241: assertEquals(123.4, reader5.nextDouble());\n1242: assertEquals(JsonToken.END_DOCUMENT, reader5.peek());\n1243: 1244: JsonReader reader6 = new JsonReader(reader(\"\\\"a\\\"\"));\n1245: assertEquals(\"a\", reader6.nextString());\n1246: assertEquals(JsonToken.END_DOCUMENT, reader6.peek());\n1247: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate boolean lenient = false;\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\nint peeked = PEEKED_NONE;\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextBoolean()Z",
                                    "method_body": "public boolean nextBoolean() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit = 0;\npos = 0;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\nif (limit >= minimum) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getLineNumber()I",
                                    "method_body": "int getLineNumber() {\nreturn lineNumber + 1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getColumnNumber()I",
                                    "method_body": "int getColumnNumber() {\nreturn pos - lineStart + 1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\np = pos;\nl = limit;\nint c = buffer[p++];\nif (c == '\\n') {\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\nif (c == '/') {\n} else if (c == '#') {\npos = p;\nreturn c;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:checkLenient()V",
                                    "method_body": "private void checkLenient() throws IOException {\nif (!lenient) {\nthrow syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\");\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getPath()Ljava/lang/String;",
                                    "method_body": "public String getPath() {\nStringBuilder result = new StringBuilder().append('$');\nfor (int i = 0, size = stackSize; i < size; i++) {\nswitch (stack[i]) {\nreturn result.toString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:syntaxError(Ljava/lang/String;)Ljava/io/IOException;",
                                    "method_body": "private IOException syntaxError(String message) throws IOException {\nthrow new MalformedJsonException(message\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.MalformedJsonException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public MalformedJsonException(String msg) {\nsuper(msg);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.stream.JsonReaderTest.testTopLevelValueTypeWithSkipValue",
                            "test_body": "1249: public void testTopLevelValueTypeWithSkipValue() throws IOException {\n1250: JsonReader reader = new JsonReader(reader(\"true\"));\n1251: reader.skipValue();\n1252: assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n1253: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate boolean lenient = false;\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\nint peeked = PEEKED_NONE;\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit = 0;\npos = 0;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\nif (limit >= minimum) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getLineNumber()I",
                                    "method_body": "int getLineNumber() {\nreturn lineNumber + 1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getColumnNumber()I",
                                    "method_body": "int getColumnNumber() {\nreturn pos - lineStart + 1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\np = pos;\nl = limit;\nint c = buffer[p++];\nif (c == '\\n') {\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\nif (c == '/') {\n} else if (c == '#') {\npos = p;\nreturn c;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:checkLenient()V",
                                    "method_body": "private void checkLenient() throws IOException {\nif (!lenient) {\nthrow syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\");\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getPath()Ljava/lang/String;",
                                    "method_body": "public String getPath() {\nStringBuilder result = new StringBuilder().append('$');\nfor (int i = 0, size = stackSize; i < size; i++) {\nswitch (stack[i]) {\nreturn result.toString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:syntaxError(Ljava/lang/String;)Ljava/io/IOException;",
                                    "method_body": "private IOException syntaxError(String message) throws IOException {\nthrow new MalformedJsonException(message\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.MalformedJsonException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public MalformedJsonException(String msg) {\nsuper(msg);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:skipValue()V",
                                    "method_body": "public void skipValue() throws IOException {\nint count = 0;\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.stream.JsonWriterTest.testTopLevelValueTypes",
                            "test_body": "28: public void testTopLevelValueTypes() throws IOException {\n29: StringWriter string1 = new StringWriter();\n30: JsonWriter writer1 = new JsonWriter(string1);\n31: writer1.value(true);\n32: writer1.close();\n33: assertEquals(\"true\", string1.toString());\n34: 35: StringWriter string2 = new StringWriter();\n36: JsonWriter writer2 = new JsonWriter(string2);\n37: writer2.nullValue();\n38: writer2.close();\n39: assertEquals(\"null\", string2.toString());\n40: 41: StringWriter string3 = new StringWriter();\n42: JsonWriter writer3 = new JsonWriter(string3);\n43: writer3.value(123);\n44: writer3.close();\n45: assertEquals(\"123\", string3.toString());\n46: 47: StringWriter string4 = new StringWriter();\n48: JsonWriter writer4 = new JsonWriter(string4);\n49: writer4.value(123.4);\n50: writer4.close();\n51: assertEquals(\"123.4\", string4.toString());\n52: 53: StringWriter string5 = new StringWriter();\n54: JsonWriter writert = new JsonWriter(string5);\n55: writert.value(\"a\");\n56: writert.close();\n57: assertEquals(\"\\\"a\\\"\", string5.toString());\n58: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:<init>(Ljava/io/Writer;)V",
                                    "method_body": "private String indent;\nprivate String separator = \":\";\nprivate boolean serializeNulls = true;\n* Creates a new instance that writes a JSON-encoded stream to {@code out}."
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:<clinit>()V",
                                    "method_body": "private static final String[] REPLACEMENT_CHARS;\nREPLACEMENT_CHARS = new String[128];\nfor (int i = 0; i <= 0x1f; i++) {\nREPLACEMENT_CHARS[i] = String.format(\"\\\\u%04x\", (int) i);\nREPLACEMENT_CHARS['\"'] = \"\\\\\\\"\";\nREPLACEMENT_CHARS['\\\\'] = \"\\\\\\\\\";\nREPLACEMENT_CHARS['\\t'] = \"\\\\t\";\nREPLACEMENT_CHARS['\\b'] = \"\\\\b\";\nREPLACEMENT_CHARS['\\n'] = \"\\\\n\";\nREPLACEMENT_CHARS['\\r'] = \"\\\\r\";\nREPLACEMENT_CHARS['\\f'] = \"\\\\f\";\nHTML_SAFE_REPLACEMENT_CHARS = REPLACEMENT_CHARS.clone();\nHTML_SAFE_REPLACEMENT_CHARS['<'] = \"\\\\u003c\";\nHTML_SAFE_REPLACEMENT_CHARS['>'] = \"\\\\u003e\";\nHTML_SAFE_REPLACEMENT_CHARS['&'] = \"\\\\u0026\";\nHTML_SAFE_REPLACEMENT_CHARS['='] = \"\\\\u003d\";\nHTML_SAFE_REPLACEMENT_CHARS['\\''] = \"\\\\u0027\";\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:push(I)V",
                                    "method_body": "private void push(int newTop) {\nif (stackSize == stack.length) {\nstack[stackSize++] = newTop;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:peek()I",
                                    "method_body": "private int peek() {\nif (stackSize == 0) {\nreturn stack[stackSize - 1];\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:writeDeferredName()V",
                                    "method_body": "private void writeDeferredName() throws IOException {\nif (deferredName != null) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:value(Z)Lcom/google/gson/stream/JsonWriter;",
                                    "method_body": "public JsonWriter value(boolean value) throws IOException {\nwriteDeferredName();\nbeforeValue(false);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:beforeValue(Z)V",
                                    "method_body": "private void beforeValue(boolean root) throws IOException {\nswitch (peek()) {\nif (!lenient && !root) {\nthrow new IllegalStateException(\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 5,
                    "tests": [
                        {
                            "test_name": "com.google.gson.DefaultDateTypeAdapterTest.testDateDeserializationISO8601",
                            "test_body": "127: public void testDateDeserializationISO8601() throws Exception {\n128: DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter();\n129: assertParsed(\"1970-01-01T00:00:00.000Z\", adapter);\n130: assertParsed(\"1970-01-01T00:00Z\", adapter);\n131: assertParsed(\"1970-01-01T00:00:00+00:00\", adapter);\n132: assertParsed(\"1970-01-01T01:00:00+01:00\", adapter);\n133: assertParsed(\"1970-01-01T01:00:00+01\", adapter);\n134: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:<init>(Ljava/lang/String;)V",
                                    "method_body": "public JsonPrimitive(String string) {\nsetValue(string);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:<clinit>()V",
                                    "method_body": "private static final Class<?>[] PRIMITIVE_TYPES = { int.class, long.class, short.class,\nShort.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class };"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:setValue(Ljava/lang/Object;)V",
                                    "method_body": "void setValue(Object primitive) {\nif (primitive instanceof Character) {\n$Gson$Preconditions.checkArgument(primitive instanceof Number\nthis.value = primitive;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:isBoolean()Z",
                                    "method_body": "public boolean isBoolean() {\nreturn value instanceof Boolean;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:isNumber()Z",
                                    "method_body": "public boolean isNumber() {\nreturn value instanceof Number;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:getAsString()Ljava/lang/String;",
                                    "method_body": "public String getAsString() {\nif (isNumber()) {\n} else if (isBoolean()) {\nreturn (String) value;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:isPrimitiveOrString(Ljava/lang/Object;)Z",
                                    "method_body": "private static boolean isPrimitiveOrString(Object target) {\nif (target instanceof String) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonParseException:<init>(Ljava/lang/String;Ljava/lang/Throwable;)V",
                                    "method_body": "public JsonParseException(String msg, Throwable cause) {\nsuper(msg, cause);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonSyntaxException:<init>(Ljava/lang/String;Ljava/lang/Throwable;)V",
                                    "method_body": "public JsonSyntaxException(String msg, Throwable cause) {\nsuper(msg, cause);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultDateTypeAdapter:<init>()V",
                                    "method_body": "DefaultDateTypeAdapter() {\nthis(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultDateTypeAdapter:<init>(Ljava/text/DateFormat;Ljava/text/DateFormat;)V",
                                    "method_body": "DefaultDateTypeAdapter(DateFormat enUsFormat, DateFormat localFormat) {\nthis.enUsFormat = enUsFormat;\nthis.localFormat = localFormat;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultDateTypeAdapter:deserialize(Lcom/google/gson/JsonElement;Ljava/lang/reflect/Type;Lcom/google/gson/JsonDeserializationContext;)Ljava/util/Date;",
                                    "method_body": "public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\nif (!(json instanceof JsonPrimitive)) {\nDate date = deserializeToDate(json);\nif (typeOfT == Date.class) {\nreturn date;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultDateTypeAdapter:deserializeToDate(Lcom/google/gson/JsonElement;)Ljava/util/Date;",
                                    "method_body": "private Date deserializeToDate(JsonElement json) {\nsynchronized (localFormat) {\nreturn localFormat.parse(json.getAsString());\n} catch (ParseException ignored) {}\nreturn enUsFormat.parse(json.getAsString());\n} catch (ParseException ignored) {}\nreturn ISO8601Utils.parse(json.getAsString(), new ParsePosition(0));\n} catch (ParseException e) {\nthrow new JsonSyntaxException(json.getAsString(), e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.util.ISO8601Utils:<clinit>()V",
                                    "method_body": "private static final String UTC_ID = \"UTC\";\nprivate static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(UTC_ID);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.util.ISO8601Utils:parse(Ljava/lang/String;Ljava/text/ParsePosition;)Ljava/util/Date;",
                                    "method_body": "public static Date parse(String date, ParsePosition pos) throws ParseException {\nException fail = null;\nint offset = pos.getIndex();\nint year = parseInt(date, offset, offset += 4);\nif (checkOffset(date, offset, '-')) {\noffset += 1;\nint month = parseInt(date, offset, offset += 2);\nif (checkOffset(date, offset, '-')) {\noffset += 1;\nint day = parseInt(date, offset, offset += 2);\nint hour = 0;\nint minutes = 0;\nint seconds = 0;\nint milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\nboolean hasT = checkOffset(date, offset, 'T');\nif (!hasT && (date.length() <= offset)) {\nif (hasT) {\nhour = parseInt(date, offset += 1, offset += 2);\nif (checkOffset(date, offset, ':')) {\noffset += 1;\nminutes = parseInt(date, offset, offset += 2);\nif (checkOffset(date, offset, ':')) {\noffset += 1;\nif (date.length() > offset) {\nchar c = date.charAt(offset);\nif (c != 'Z' && c != '+' && c != '-') {\nseconds = parseInt(date, offset, offset += 2);\nif (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds\nif (checkOffset(date, offset, '.')) {\noffset += 1;\nint endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit\nint parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits\nint fraction = parseInt(date, offset, parseEndOffset);\nswitch (parseEndOffset - offset) { // number of digits parsed\nmilliseconds = fraction;\noffset = endOffset;\nif (date.length() <= offset) {\nTimeZone timezone = null;\nchar timezoneIndicator = date.charAt(offset);\nif (timezoneIndicator == 'Z') {\ntimezone = TIMEZONE_UTC;\noffset += 1;\n} else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\nString timezoneOffset = date.substring(offset);\noffset += timezoneOffset.length();\nif (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\ntimezone = TIMEZONE_UTC;\nString timezoneId = \"GMT\" + timezoneOffset;\ntimezone = TimeZone.getTimeZone(timezoneId);\nString act = timezone.getID();\nif (!act.equals(timezoneId)) {\nString cleaned = act.replace(\":\", \"\");\nif (!cleaned.equals(timezoneId)) {\nthrow new IndexOutOfBoundsException(\"Mismatching time zone indicator: \"+timezoneId+\" given, resolves to \"\n} else {\nCalendar calendar = new GregorianCalendar(timezone);\ncalendar.setLenient(false);\ncalendar.set(Calendar.YEAR, year);\ncalendar.set(Calendar.MONTH, month - 1);\ncalendar.set(Calendar.DAY_OF_MONTH, day);\ncalendar.set(Calendar.HOUR_OF_DAY, hour);\ncalendar.set(Calendar.MINUTE, minutes);\ncalendar.set(Calendar.SECOND, seconds);\ncalendar.set(Calendar.MILLISECOND, milliseconds);\npos.setIndex(offset);\nreturn calendar.getTime();\n} catch (IndexOutOfBoundsException e) {\nfail = e;\n}\nString input = (date == null) ? null : ('\"' + date + \"'\");\nString msg = fail.getMessage();\nif (msg == null || msg.isEmpty()) {\nParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\nex.initCause(fail);\nthrow ex;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.util.ISO8601Utils:checkOffset(Ljava/lang/String;IC)Z",
                                    "method_body": "private static boolean checkOffset(String value, int offset, char expected) {\nreturn (offset < value.length()) && (value.charAt(offset) == expected);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.util.ISO8601Utils:parseInt(Ljava/lang/String;II)I",
                                    "method_body": "private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException {\nif (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) {\nint i = beginIndex;\nint result = 0;\nif (i < endIndex) {\ndigit = Character.digit(value.charAt(i++), 10);\nif (digit < 0) {\nresult = -digit;\nwhile (i < endIndex) {\ndigit = Character.digit(value.charAt(i++), 10);\nif (digit < 0) {\nresult *= 10;\nresult -= digit;\nreturn -result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.util.ISO8601Utils:indexOfNonDigit(Ljava/lang/String;I)I",
                                    "method_body": "private static int indexOfNonDigit(String string, int offset) {\nfor (int i = offset; i < string.length(); i++) {\nchar c = string.charAt(i);\nif (c < '0' || c > '9') return i;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 6,
                    "tests": [
                        {
                            "test_name": "com.google.gson.regression.JsonAdapterNullSafeTest.testNullSafeBugDeserialize",
                            "test_body": "34: public void testNullSafeBugDeserialize() throws Exception {\n35: Device device = gson.fromJson(\"{'id':'ec57803e2'}\", Device.class);\n36: assertEquals(\"ec57803e2\", device.id);\n37: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/Class;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static <T> TypeToken<T> get(Class<T> type) {\nreturn new TypeToken<T>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\nreturn (Class<?>) type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\nprivate final ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>> calls\nprivate final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache\nfinal JsonDeserializationContext deserializationContext = new JsonDeserializationContext() {\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLong>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongArrayAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLongArray>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type);\nif (cached != null) {\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\n}\nthreadCalls.remove(type);\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getDelegateAdapter(Lcom/google/gson/TypeAdapterFactory;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getDelegateAdapter(TypeAdapterFactory skipPast, TypeToken<T> type) {\nboolean skipPastFound = false;\nif (!factories.contains(skipPast)) skipPastFound = true;\nfor (TypeAdapterFactory factory : factories) {\nif (!skipPastFound) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:newJsonReader(Ljava/io/Reader;)Lcom/google/gson/stream/JsonReader;",
                                    "method_body": "public JsonReader newJsonReader(Reader reader) {\nJsonReader jsonReader = new JsonReader(reader);\njsonReader.setLenient(lenient);\nreturn jsonReader;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException {\nObject object = fromJson(json, (Type) classOfT);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {\nif (json == null) {\nStringReader reader = new StringReader(json);\nT target = (T) fromJson(reader, typeOfT);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/io/Reader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nJsonReader jsonReader = newJsonReader(json);\nT object = (T) fromJson(jsonReader, typeOfT);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Lcom/google/gson/stream/JsonReader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nboolean isEmpty = true;\nboolean oldLenient = reader.isLenient();\nreader.setLenient(true);\nreader.peek();\nisEmpty = false;\nTypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\nTypeAdapter<T> typeAdapter = getAdapter(typeToken);\nreader.setLenient(oldLenient);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<init>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nif (isAnonymousOrLocal(clazz)) {\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nfinal InstanceCreator<T> rawTypeCreator =\nif (rawTypeCreator != null) {\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nreturn defaultConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultConstructor(Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\nreturn new ObjectConstructor<T>() {\nObject[] args = null;\nreturn (T) constructor.newInstance(args);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() {\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:nullSafe()Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public final TypeAdapter<T> nullSafe() {\nreturn new TypeAdapter<T>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$35:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$26:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$34:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nif (type.getRawType() == Object.class) {\nreturn null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == java.sql.Date.class\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\nJsonAdapter annotation = targetType.getRawType().getAnnotation(JsonAdapter.class);\nif (annotation == null) {\nreturn (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:getTypeAdapter(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;Lcom/google/gson/annotations/JsonAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\nClass<?> value = annotation.value();\nif (TypeAdapter.class.isAssignableFrom(value)) {\n} else if (TypeAdapterFactory.class.isAssignableFrom(value)) {\nClass<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;\ntypeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterFactory))\n} else {\ntypeAdapter = typeAdapter.nullSafe();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nFieldNamingStrategy fieldNamingPolicy, Excluder excluder) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "public JsonReader(Reader in) {\nif (in == null) {\nthis.in = in;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:setLenient(Z)V",
                                    "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:isLenient()Z",
                                    "method_body": "public final boolean isLenient() {\nreturn lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\nswitch (p) {\nreturn JsonToken.BEGIN_OBJECT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit = 0;\npos = 0;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\nif (limit >= minimum) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\np = pos;\nl = limit;\nint c = buffer[p++];\nif (c == '\\n') {\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\nif (c == '/') {\n} else if (c == '#') {\npos = p;\nreturn c;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:consumeNonExecutePrefix()V",
                                    "method_body": "private void consumeNonExecutePrefix() throws IOException {\nnextNonWhitespace(true);\npos--;\nif (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\nfor (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\nif (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\nreturn; // not a security token!\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor$3:construct()Ljava/lang/Object;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\nreturn new ObjectConstructor<T>() {\nObject[] args = null;\nreturn (T) constructor.newInstance(args);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.regression.JsonAdapterNullSafeTest.testNullSafeBugSerialize",
                            "test_body": "29: public void testNullSafeBugSerialize() throws Exception {\n30: Device device = new Device(\"ec57803e\");\n31: gson.toJson(device);\n32: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/Class;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static <T> TypeToken<T> get(Class<T> type) {\nreturn new TypeToken<T>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\nreturn (Class<?>) type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\nprivate final ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>> calls\nprivate final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache\nfinal JsonDeserializationContext deserializationContext = new JsonDeserializationContext() {\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLong>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongArrayAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLongArray>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type);\nif (cached != null) {\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\n}\nthreadCalls.remove(type);\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getDelegateAdapter(Lcom/google/gson/TypeAdapterFactory;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getDelegateAdapter(TypeAdapterFactory skipPast, TypeToken<T> type) {\nboolean skipPastFound = false;\nif (!factories.contains(skipPast)) skipPastFound = true;\nfor (TypeAdapterFactory factory : factories) {\nif (!skipPastFound) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<init>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nif (isAnonymousOrLocal(clazz)) {\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nfinal InstanceCreator<T> rawTypeCreator =\nif (rawTypeCreator != null) {\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nreturn defaultConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultConstructor(Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\nreturn new ObjectConstructor<T>() {\nObject[] args = null;\nreturn (T) constructor.newInstance(args);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() {\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:nullSafe()Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public final TypeAdapter<T> nullSafe() {\nreturn new TypeAdapter<T>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$35:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$26:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$34:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nif (type.getRawType() == Object.class) {\nreturn null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == java.sql.Date.class\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\nJsonAdapter annotation = targetType.getRawType().getAnnotation(JsonAdapter.class);\nif (annotation == null) {\nreturn (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:getTypeAdapter(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;Lcom/google/gson/annotations/JsonAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\nClass<?> value = annotation.value();\nif (TypeAdapter.class.isAssignableFrom(value)) {\n} else if (TypeAdapterFactory.class.isAssignableFrom(value)) {\nClass<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;\ntypeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterFactory))\n} else {\ntypeAdapter = typeAdapter.nullSafe();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nFieldNamingStrategy fieldNamingPolicy, Excluder excluder) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor$3:construct()Ljava/lang/Object;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\nreturn new ObjectConstructor<T>() {\nObject[] args = null;\nreturn (T) constructor.newInstance(args);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:toJson(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public String toJson(Object src) {\nif (src == null) {\nreturn toJson(src, src.getClass());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:toJson(Ljava/lang/Object;Ljava/lang/reflect/Type;)Ljava/lang/String;",
                                    "method_body": "public String toJson(Object src, Type typeOfSrc) {\nStringWriter writer = new StringWriter();\ntoJson(src, typeOfSrc, writer);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:toJson(Ljava/lang/Object;Ljava/lang/reflect/Type;Ljava/lang/Appendable;)V",
                                    "method_body": "public void toJson(Object src, Type typeOfSrc, Appendable writer) throws JsonIOException {\nJsonWriter jsonWriter = newJsonWriter(Streams.writerForAppendable(writer));\ntoJson(src, typeOfSrc, jsonWriter);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:toJson(Ljava/lang/Object;Ljava/lang/reflect/Type;Lcom/google/gson/stream/JsonWriter;)V",
                                    "method_body": "public void toJson(Object src, Type typeOfSrc, JsonWriter writer) throws JsonIOException {\nTypeAdapter<?> adapter = getAdapter(TypeToken.get(typeOfSrc));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:newJsonWriter(Ljava/io/Writer;)Lcom/google/gson/stream/JsonWriter;",
                                    "method_body": "public JsonWriter newJsonWriter(Writer writer) throws IOException {\nif (generateNonExecutableJson) {\nJsonWriter jsonWriter = new JsonWriter(writer);\nif (prettyPrinting) {\njsonWriter.setSerializeNulls(serializeNulls);\nreturn jsonWriter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Streams:writerForAppendable(Ljava/lang/Appendable;)Ljava/io/Writer;",
                                    "method_body": "public static Writer writerForAppendable(Appendable appendable) {\nreturn appendable instanceof Writer ? (Writer) appendable : new AppendableWriter(appendable);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:<init>(Ljava/io/Writer;)V",
                                    "method_body": "private String indent;\nprivate String separator = \":\";\nprivate boolean serializeNulls = true;\n* Creates a new instance that writes a JSON-encoded stream to {@code out}."
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:<clinit>()V",
                                    "method_body": "private static final String[] REPLACEMENT_CHARS;\nREPLACEMENT_CHARS = new String[128];\nfor (int i = 0; i <= 0x1f; i++) {\nREPLACEMENT_CHARS[i] = String.format(\"\\\\u%04x\", (int) i);\nREPLACEMENT_CHARS['\"'] = \"\\\\\\\"\";\nREPLACEMENT_CHARS['\\\\'] = \"\\\\\\\\\";\nREPLACEMENT_CHARS['\\t'] = \"\\\\t\";\nREPLACEMENT_CHARS['\\b'] = \"\\\\b\";\nREPLACEMENT_CHARS['\\n'] = \"\\\\n\";\nREPLACEMENT_CHARS['\\r'] = \"\\\\r\";\nREPLACEMENT_CHARS['\\f'] = \"\\\\f\";\nHTML_SAFE_REPLACEMENT_CHARS = REPLACEMENT_CHARS.clone();\nHTML_SAFE_REPLACEMENT_CHARS['<'] = \"\\\\u003c\";\nHTML_SAFE_REPLACEMENT_CHARS['>'] = \"\\\\u003e\";\nHTML_SAFE_REPLACEMENT_CHARS['&'] = \"\\\\u0026\";\nHTML_SAFE_REPLACEMENT_CHARS['='] = \"\\\\u003d\";\nHTML_SAFE_REPLACEMENT_CHARS['\\''] = \"\\\\u0027\";\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:setSerializeNulls(Z)V",
                                    "method_body": "public final void setSerializeNulls(boolean serializeNulls) {\nthis.serializeNulls = serializeNulls;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:push(I)V",
                                    "method_body": "private void push(int newTop) {\nif (stackSize == stack.length) {\nstack[stackSize++] = newTop;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 7,
                    "tests": [
                        {
                            "test_name": "com.google.gson.functional.MapTest.testMapDeserializationWithUnquotedLongKeys",
                            "test_body": "188: public void testMapDeserializationWithUnquotedLongKeys() {\n189: long longKey = 9876543210L;\n190: String json = String.format(\"{%d:\\\"456\\\"}\", longKey);\n191: Type typeOfMap = new TypeToken<Map<Long, String>>() {}.getType();\n192: Map<Long, String> map = gson.fromJson(json, typeOfMap);\n193: assertEquals(1, map.size());\n194: assertTrue(map.containsKey(longKey));\n195: assertEquals(\"456\", map.get(longKey));\n196: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>()V",
                                    "method_body": "protected TypeToken() {\nthis.type = getSuperclassTypeParameter(getClass());\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(type);\nthis.hashCode = type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getSuperclassTypeParameter(Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getSuperclassTypeParameter(Class<?> subclass) {\nType superclass = subclass.getGenericSuperclass();\nif (superclass instanceof Class) {\nParameterizedType parameterized = (ParameterizedType) superclass;\nreturn $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\nreturn (Class<?>) type;\n} else if (type instanceof ParameterizedType) {\nParameterizedType parameterizedType = (ParameterizedType) type;\nType rawType = parameterizedType.getRawType();\ncheckArgument(rawType instanceof Class);\nreturn (Class<?>) rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:hashCodeOrZero(Ljava/lang/Object;)I",
                                    "method_body": "static int hashCodeOrZero(Object o) {\nreturn o != null ? o.hashCode() : 0;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getGenericSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\nif (toResolve == rawType) {\nreturn context;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\ncheckArgument(supertype.isAssignableFrom(contextRawType));\nreturn resolve(context, contextRawType,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getMapKeyAndValueTypes(Ljava/lang/reflect/Type;Ljava/lang/Class;)[Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {\nif (context == Properties.class) {\nType mapType = getSupertype(context, contextRawType, Map.class);\nif (mapType instanceof ParameterizedType) {\nParameterizedType mapParameterizedType = (ParameterizedType) mapType;\nreturn mapParameterizedType.getActualTypeArguments();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\nif (toResolve instanceof TypeVariable) {\n} else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n} else if (toResolve instanceof GenericArrayType) {\n} else if (toResolve instanceof ParameterizedType) {\nParameterizedType original = (ParameterizedType) toResolve;\nType ownerType = original.getOwnerType();\nType newOwnerType = resolve(context, contextRawType, ownerType);\nboolean changed = newOwnerType != ownerType;\nType[] args = original.getActualTypeArguments();\nfor (int t = 0, length = args.length; t < length; t++) {\nType resolvedTypeArgument = resolve(context, contextRawType, args[t]);\nif (resolvedTypeArgument != args[t]) {\nreturn changed\n} else if (toResolve instanceof WildcardType) {\nreturn toResolve;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$ParameterizedTypeImpl:<init>(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingPolicy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nthis.lenient = lenient;\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\nfactories.add(excluder);\nfactories.addAll(typeAdapterFactories);\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nTypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\nfactories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\nfactories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.CURRENCY_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nfactories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<clinit>()V",
                                    "method_body": "static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\nprivate static final TypeToken<?> NULL_KEY_SURROGATE = new TypeToken<Object>() {};"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLong>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongArrayAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLongArray>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);\nif (cached != null) {\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\n}\nthreadCalls.remove(type);\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:newJsonReader(Ljava/io/Reader;)Lcom/google/gson/stream/JsonReader;",
                                    "method_body": "public JsonReader newJsonReader(Reader reader) {\nJsonReader jsonReader = new JsonReader(reader);\njsonReader.setLenient(lenient);\nreturn jsonReader;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {\nif (json == null) {\nStringReader reader = new StringReader(json);\nT target = (T) fromJson(reader, typeOfT);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/io/Reader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nJsonReader jsonReader = newJsonReader(json);\nT object = (T) fromJson(jsonReader, typeOfT);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Lcom/google/gson/stream/JsonReader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nboolean isEmpty = true;\nboolean oldLenient = reader.isLenient();\nreader.setLenient(true);\nreader.peek();\nisEmpty = false;\nTypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\nTypeAdapter<T> typeAdapter = getAdapter(typeToken);\nT object = typeAdapter.read(reader);\n} catch (IllegalStateException e) {\nthrow new JsonSyntaxException(e);\nreader.setLenient(oldLenient);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<init>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nif (isAnonymousOrLocal(clazz)) {\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nfinal InstanceCreator<T> rawTypeCreator =\nif (rawTypeCreator != null) {\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\nif (defaultImplementation != null) {\nreturn defaultImplementation;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultConstructor(Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\n} catch (NoSuchMethodException e) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultImplementationConstructor(Ljava/lang/reflect/Type;Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nif (Collection.class.isAssignableFrom(rawType)) {\nif (Map.class.isAssignableFrom(rawType)) {\nif (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\n} else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\n} else if (SortedMap.class.isAssignableFrom(rawType)) {\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nreturn new ObjectConstructor<T>() {\nreturn (T) new LinkedHashMap<Object, Object>();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() {\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:nullSafe()Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public final TypeAdapter<T> nullSafe() {\nreturn new TypeAdapter<T>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$35:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$26:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$34:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nif (type.getRawType() == Object.class) {\nreturn null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == java.sql.Date.class\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nClass<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\nType[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\nTypeAdapter<?> keyAdapter = getKeyAdapter(gson, keyAndValueTypes[0]);\nTypeAdapter<?> valueAdapter = gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\nTypeAdapter<T> result = new Adapter(gson, keyAndValueTypes[0], keyAdapter,\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:getKeyAdapter(Lcom/google/gson/Gson;Ljava/lang/reflect/Type;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<?> getKeyAdapter(Gson context, Type keyType) {\nreturn (keyType == boolean.class || keyType == Boolean.class)\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nFieldNamingStrategy fieldNamingPolicy, Excluder excluder) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate boolean lenient = false;\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\nint peeked = PEEKED_NONE;\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:setLenient(Z)V",
                                    "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:isLenient()Z",
                                    "method_body": "public final boolean isLenient() {\nreturn lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:beginObject()V",
                                    "method_body": "public void beginObject() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\nif (p == PEEKED_BEGIN_OBJECT) {\npush(JsonScope.EMPTY_OBJECT);\npeeked = PEEKED_NONE;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:hasNext()Z",
                                    "method_body": "public boolean hasNext() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\nreturn p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\nswitch (p) {\nreturn JsonToken.BEGIN_OBJECT;\nreturn JsonToken.STRING;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:isLiteral(C)Z",
                                    "method_body": "private boolean isLiteral(char c) throws IOException {\nswitch (c) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:push(I)V",
                                    "method_body": "private void push(int newTop) {\nif (stackSize == stack.length) {\nstack[stackSize++] = newTop;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit = 0;\npos = 0;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\nif (limit >= minimum) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getLineNumber()I",
                                    "method_body": "int getLineNumber() {\nreturn lineNumber + 1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getColumnNumber()I",
                                    "method_body": "int getColumnNumber() {\nreturn pos - lineStart + 1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\np = pos;\nl = limit;\nint c = buffer[p++];\nif (c == '\\n') {\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\nif (c == '/') {\n} else if (c == '#') {\npos = p;\nreturn c;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:checkLenient()V",
                                    "method_body": "private void checkLenient() throws IOException {\nif (!lenient) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getPath()Ljava/lang/String;",
                                    "method_body": "public String getPath() {\nStringBuilder result = new StringBuilder().append('$');\nfor (int i = 0, size = stackSize; i < size; i++) {\nswitch (stack[i]) {\nresult.append('[').append(pathIndices[i]).append(']');\nbreak;\nresult.append('.');\nif (pathNames[i] != null) {\nreturn result.toString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:consumeNonExecutePrefix()V",
                                    "method_body": "private void consumeNonExecutePrefix() throws IOException {\nnextNonWhitespace(true);\npos--;\nif (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\nfor (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\nif (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\nreturn; // not a security token!\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader$1:promoteNameToValue(Lcom/google/gson/stream/JsonReader;)V",
                                    "method_body": "@Override public void promoteNameToValue(JsonReader reader) throws IOException {\nif (reader instanceof JsonTreeReader) {\nint p = reader.peeked;\nif (p == PEEKED_NONE) {\nif (p == PEEKED_DOUBLE_QUOTED_NAME) {\n} else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n} else if (p == PEEKED_UNQUOTED_NAME) {\nreader.peeked = PEEKED_UNQUOTED;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson$FutureTypeAdapter:setDelegate(Lcom/google/gson/TypeAdapter;)V",
                                    "method_body": "public void setDelegate(TypeAdapter<T> typeAdapter) {\nif (delegate != null) {\ndelegate = typeAdapter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter:<init>(Lcom/google/gson/internal/bind/MapTypeAdapterFactory;Lcom/google/gson/Gson;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Lcom/google/gson/internal/ObjectConstructor;)V",
                                    "method_body": "public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,\nObjectConstructor<? extends Map<K, V>> constructor) {\nthis.keyTypeAdapter =\nthis.valueTypeAdapter =\nthis.constructor = constructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter:read(Lcom/google/gson/stream/JsonReader;)Ljava/util/Map;",
                                    "method_body": "@Override public Map<K, V> read(JsonReader in) throws IOException {\nJsonToken peek = in.peek();\nif (peek == JsonToken.NULL) {\nMap<K, V> map = constructor.construct();\nif (peek == JsonToken.BEGIN_ARRAY) {\nin.beginObject();\nwhile (in.hasNext()) {\nJsonReaderInternalAccess.INSTANCE.promoteNameToValue(in);\nK key = keyTypeAdapter.read(in);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:<init>(Lcom/google/gson/Gson;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeAdapterRuntimeTypeWrapper(Gson context, TypeAdapter<T> delegate, Type type) {\nthis.context = context;\nthis.delegate = delegate;\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Object;",
                                    "method_body": "public T read(JsonReader in) throws IOException {\nreturn delegate.read(in);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonParseException:<init>(Ljava/lang/Throwable;)V",
                                    "method_body": "public JsonParseException(Throwable cause) {\nsuper(cause);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonSyntaxException:<init>(Ljava/lang/Throwable;)V",
                                    "method_body": "public JsonSyntaxException(Throwable cause) {\nsuper(cause);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor$12:construct()Ljava/lang/Object;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nif (Collection.class.isAssignableFrom(rawType)) {\nif (Map.class.isAssignableFrom(rawType)) {\nif (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\n} else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\n} else if (SortedMap.class.isAssignableFrom(rawType)) {\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nreturn new ObjectConstructor<T>() {\nreturn (T) new LinkedHashMap<Object, Object>();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$12:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Number;",
                                    "method_body": "public Number read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nreturn in.nextLong();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextLong()J",
                                    "method_body": "public long nextLong() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\nif (p == PEEKED_LONG) {\nif (p == PEEKED_NUMBER) {\n} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\nthrow new IllegalStateException(\"Expected a long but was \" + peek()\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.functional.MapTest.testMapDeserializationWithUnquotedIntegerKeys",
                            "test_body": "170: public void testMapDeserializationWithUnquotedIntegerKeys() {\n171: Type typeOfMap = new TypeToken<Map<Integer, String>>() {}.getType();\n172: Map<Integer, String> map = gson.fromJson(\"{123:\\\"456\\\"}\", typeOfMap);\n173: assertEquals(1, map.size());\n174: assertTrue(map.containsKey(123));\n175: assertEquals(\"456\", map.get(123));\n176: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>()V",
                                    "method_body": "protected TypeToken() {\nthis.type = getSuperclassTypeParameter(getClass());\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(type);\nthis.hashCode = type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getSuperclassTypeParameter(Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getSuperclassTypeParameter(Class<?> subclass) {\nType superclass = subclass.getGenericSuperclass();\nif (superclass instanceof Class) {\nParameterizedType parameterized = (ParameterizedType) superclass;\nreturn $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\nreturn (Class<?>) type;\n} else if (type instanceof ParameterizedType) {\nParameterizedType parameterizedType = (ParameterizedType) type;\nType rawType = parameterizedType.getRawType();\ncheckArgument(rawType instanceof Class);\nreturn (Class<?>) rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:hashCodeOrZero(Ljava/lang/Object;)I",
                                    "method_body": "static int hashCodeOrZero(Object o) {\nreturn o != null ? o.hashCode() : 0;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getGenericSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\nif (toResolve == rawType) {\nreturn context;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\ncheckArgument(supertype.isAssignableFrom(contextRawType));\nreturn resolve(context, contextRawType,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getMapKeyAndValueTypes(Ljava/lang/reflect/Type;Ljava/lang/Class;)[Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {\nif (context == Properties.class) {\nType mapType = getSupertype(context, contextRawType, Map.class);\nif (mapType instanceof ParameterizedType) {\nParameterizedType mapParameterizedType = (ParameterizedType) mapType;\nreturn mapParameterizedType.getActualTypeArguments();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\nif (toResolve instanceof TypeVariable) {\n} else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n} else if (toResolve instanceof GenericArrayType) {\n} else if (toResolve instanceof ParameterizedType) {\nParameterizedType original = (ParameterizedType) toResolve;\nType ownerType = original.getOwnerType();\nType newOwnerType = resolve(context, contextRawType, ownerType);\nboolean changed = newOwnerType != ownerType;\nType[] args = original.getActualTypeArguments();\nfor (int t = 0, length = args.length; t < length; t++) {\nType resolvedTypeArgument = resolve(context, contextRawType, args[t]);\nif (resolvedTypeArgument != args[t]) {\nreturn changed\n} else if (toResolve instanceof WildcardType) {\nreturn toResolve;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$ParameterizedTypeImpl:<init>(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingPolicy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nthis.lenient = lenient;\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\nfactories.add(excluder);\nfactories.addAll(typeAdapterFactories);\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nTypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\nfactories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\nfactories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.CURRENCY_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nfactories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<clinit>()V",
                                    "method_body": "static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\nprivate static final TypeToken<?> NULL_KEY_SURROGATE = new TypeToken<Object>() {};"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLong>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongArrayAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLongArray>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);\nif (cached != null) {\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\n}\nthreadCalls.remove(type);\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:newJsonReader(Ljava/io/Reader;)Lcom/google/gson/stream/JsonReader;",
                                    "method_body": "public JsonReader newJsonReader(Reader reader) {\nJsonReader jsonReader = new JsonReader(reader);\njsonReader.setLenient(lenient);\nreturn jsonReader;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {\nif (json == null) {\nStringReader reader = new StringReader(json);\nT target = (T) fromJson(reader, typeOfT);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/io/Reader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nJsonReader jsonReader = newJsonReader(json);\nT object = (T) fromJson(jsonReader, typeOfT);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Lcom/google/gson/stream/JsonReader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nboolean isEmpty = true;\nboolean oldLenient = reader.isLenient();\nreader.setLenient(true);\nreader.peek();\nisEmpty = false;\nTypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\nTypeAdapter<T> typeAdapter = getAdapter(typeToken);\nT object = typeAdapter.read(reader);\n} catch (IllegalStateException e) {\nthrow new JsonSyntaxException(e);\nreader.setLenient(oldLenient);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<init>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nif (isAnonymousOrLocal(clazz)) {\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nfinal InstanceCreator<T> rawTypeCreator =\nif (rawTypeCreator != null) {\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\nif (defaultImplementation != null) {\nreturn defaultImplementation;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultConstructor(Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\n} catch (NoSuchMethodException e) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultImplementationConstructor(Ljava/lang/reflect/Type;Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nif (Collection.class.isAssignableFrom(rawType)) {\nif (Map.class.isAssignableFrom(rawType)) {\nif (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\n} else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\n} else if (SortedMap.class.isAssignableFrom(rawType)) {\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nreturn new ObjectConstructor<T>() {\nreturn (T) new LinkedHashMap<Object, Object>();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() {\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:nullSafe()Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public final TypeAdapter<T> nullSafe() {\nreturn new TypeAdapter<T>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$11:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Number;",
                                    "method_body": "public Number read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nreturn in.nextInt();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$35:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$26:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$34:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nif (type.getRawType() == Object.class) {\nreturn null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == java.sql.Date.class\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nClass<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\nType[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\nTypeAdapter<?> keyAdapter = getKeyAdapter(gson, keyAndValueTypes[0]);\nTypeAdapter<?> valueAdapter = gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\nTypeAdapter<T> result = new Adapter(gson, keyAndValueTypes[0], keyAdapter,\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:getKeyAdapter(Lcom/google/gson/Gson;Ljava/lang/reflect/Type;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<?> getKeyAdapter(Gson context, Type keyType) {\nreturn (keyType == boolean.class || keyType == Boolean.class)\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nFieldNamingStrategy fieldNamingPolicy, Excluder excluder) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate boolean lenient = false;\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\nint peeked = PEEKED_NONE;\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:setLenient(Z)V",
                                    "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:isLenient()Z",
                                    "method_body": "public final boolean isLenient() {\nreturn lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:beginObject()V",
                                    "method_body": "public void beginObject() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\nif (p == PEEKED_BEGIN_OBJECT) {\npush(JsonScope.EMPTY_OBJECT);\npeeked = PEEKED_NONE;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:hasNext()Z",
                                    "method_body": "public boolean hasNext() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\nreturn p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\nswitch (p) {\nreturn JsonToken.BEGIN_OBJECT;\nreturn JsonToken.STRING;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:isLiteral(C)Z",
                                    "method_body": "private boolean isLiteral(char c) throws IOException {\nswitch (c) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextInt()I",
                                    "method_body": "public int nextInt() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\nif (p == PEEKED_LONG) {\nif (p == PEEKED_NUMBER) {\n} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\nthrow new IllegalStateException(\"Expected an int but was \" + peek()\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:push(I)V",
                                    "method_body": "private void push(int newTop) {\nif (stackSize == stack.length) {\nstack[stackSize++] = newTop;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit = 0;\npos = 0;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\nif (limit >= minimum) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getLineNumber()I",
                                    "method_body": "int getLineNumber() {\nreturn lineNumber + 1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getColumnNumber()I",
                                    "method_body": "int getColumnNumber() {\nreturn pos - lineStart + 1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\np = pos;\nl = limit;\nint c = buffer[p++];\nif (c == '\\n') {\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\nif (c == '/') {\n} else if (c == '#') {\npos = p;\nreturn c;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:checkLenient()V",
                                    "method_body": "private void checkLenient() throws IOException {\nif (!lenient) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getPath()Ljava/lang/String;",
                                    "method_body": "public String getPath() {\nStringBuilder result = new StringBuilder().append('$');\nfor (int i = 0, size = stackSize; i < size; i++) {\nswitch (stack[i]) {\nresult.append('[').append(pathIndices[i]).append(']');\nbreak;\nresult.append('.');\nif (pathNames[i] != null) {\nreturn result.toString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:consumeNonExecutePrefix()V",
                                    "method_body": "private void consumeNonExecutePrefix() throws IOException {\nnextNonWhitespace(true);\npos--;\nif (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\nfor (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\nif (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\nreturn; // not a security token!\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader$1:promoteNameToValue(Lcom/google/gson/stream/JsonReader;)V",
                                    "method_body": "@Override public void promoteNameToValue(JsonReader reader) throws IOException {\nif (reader instanceof JsonTreeReader) {\nint p = reader.peeked;\nif (p == PEEKED_NONE) {\nif (p == PEEKED_DOUBLE_QUOTED_NAME) {\n} else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n} else if (p == PEEKED_UNQUOTED_NAME) {\nreader.peeked = PEEKED_UNQUOTED;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson$FutureTypeAdapter:setDelegate(Lcom/google/gson/TypeAdapter;)V",
                                    "method_body": "public void setDelegate(TypeAdapter<T> typeAdapter) {\nif (delegate != null) {\ndelegate = typeAdapter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter:<init>(Lcom/google/gson/internal/bind/MapTypeAdapterFactory;Lcom/google/gson/Gson;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Lcom/google/gson/internal/ObjectConstructor;)V",
                                    "method_body": "public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,\nObjectConstructor<? extends Map<K, V>> constructor) {\nthis.keyTypeAdapter =\nthis.valueTypeAdapter =\nthis.constructor = constructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter:read(Lcom/google/gson/stream/JsonReader;)Ljava/util/Map;",
                                    "method_body": "@Override public Map<K, V> read(JsonReader in) throws IOException {\nJsonToken peek = in.peek();\nif (peek == JsonToken.NULL) {\nMap<K, V> map = constructor.construct();\nif (peek == JsonToken.BEGIN_ARRAY) {\nin.beginObject();\nwhile (in.hasNext()) {\nJsonReaderInternalAccess.INSTANCE.promoteNameToValue(in);\nK key = keyTypeAdapter.read(in);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:<init>(Lcom/google/gson/Gson;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeAdapterRuntimeTypeWrapper(Gson context, TypeAdapter<T> delegate, Type type) {\nthis.context = context;\nthis.delegate = delegate;\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Object;",
                                    "method_body": "public T read(JsonReader in) throws IOException {\nreturn delegate.read(in);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonParseException:<init>(Ljava/lang/Throwable;)V",
                                    "method_body": "public JsonParseException(Throwable cause) {\nsuper(cause);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonSyntaxException:<init>(Ljava/lang/Throwable;)V",
                                    "method_body": "public JsonSyntaxException(Throwable cause) {\nsuper(cause);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor$12:construct()Ljava/lang/Object;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nif (Collection.class.isAssignableFrom(rawType)) {\nif (Map.class.isAssignableFrom(rawType)) {\nif (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\n} else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\n} else if (SortedMap.class.isAssignableFrom(rawType)) {\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nreturn new ObjectConstructor<T>() {\nreturn (T) new LinkedHashMap<Object, Object>();\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.stream.JsonReaderTest.testPeekingUnquotedStringsPrefixedWithIntegers",
                            "test_body": "496: public void testPeekingUnquotedStringsPrefixedWithIntegers() throws IOException {\n497: JsonReader reader = new JsonReader(reader(\"[12.34e5x]\"));\n498: reader.setLenient(true);\n499: reader.beginArray();\n500: assertEquals(STRING, reader.peek());\n501: try {\n502: reader.nextInt();\n503: fail();\n504: } catch (NumberFormatException expected) {\n505: }\n506: assertEquals(\"12.34e5x\", reader.nextString());\n507: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate boolean lenient = false;\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\nint peeked = PEEKED_NONE;\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:setLenient(Z)V",
                                    "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\nswitch (p) {\nreturn JsonToken.BEGIN_OBJECT;\nreturn JsonToken.STRING;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:isLiteral(C)Z",
                                    "method_body": "private boolean isLiteral(char c) throws IOException {\nswitch (c) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextInt()I",
                                    "method_body": "public int nextInt() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\nif (p == PEEKED_LONG) {\nif (p == PEEKED_NUMBER) {\n} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\nthrow new IllegalStateException(\"Expected an int but was \" + peek()\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:push(I)V",
                                    "method_body": "private void push(int newTop) {\nif (stackSize == stack.length) {\nstack[stackSize++] = newTop;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit = 0;\npos = 0;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\nif (limit >= minimum) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getLineNumber()I",
                                    "method_body": "int getLineNumber() {\nreturn lineNumber + 1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getColumnNumber()I",
                                    "method_body": "int getColumnNumber() {\nreturn pos - lineStart + 1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\np = pos;\nl = limit;\nint c = buffer[p++];\nif (c == '\\n') {\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\nif (c == '/') {\n} else if (c == '#') {\npos = p;\nreturn c;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:checkLenient()V",
                                    "method_body": "private void checkLenient() throws IOException {\nif (!lenient) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:consumeNonExecutePrefix()V",
                                    "method_body": "private void consumeNonExecutePrefix() throws IOException {\nnextNonWhitespace(true);\npos--;\nif (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\nfor (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\nif (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\nreturn; // not a security token!\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:beginArray()V",
                                    "method_body": "public void beginArray() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\nif (p == PEEKED_BEGIN_ARRAY) {\npush(JsonScope.EMPTY_ARRAY);\npathIndices[stackSize - 1] = 0;\npeeked = PEEKED_NONE;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peekKeyword()I",
                                    "method_body": "private int peekKeyword() throws IOException {\nchar c = buffer[pos];\nif (c == 't' || c == 'T') {\n} else if (c == 'f' || c == 'F') {\n} else if (c == 'n' || c == 'N') {\nreturn PEEKED_NONE;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peekNumber()I",
                                    "method_body": "private int peekNumber() throws IOException {\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nlong value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\nboolean negative = false;\nboolean fitsInLong = true;\nint last = NUMBER_CHAR_NONE;\nint i = 0;\nfor (; true; i++) {\nif (p + i == l) {\nchar c = buffer[p + i];\nswitch (c) {\nif (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\nlast = NUMBER_CHAR_EXP_E;\ncontinue;\nif (last == NUMBER_CHAR_DIGIT) {\nlast = NUMBER_CHAR_DECIMAL;\ncontinue;\nif (c < '0' || c > '9') {\nif (!isLiteral(c)) {\nreturn PEEKED_NONE;\nif (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\nvalue = -(c - '0');\nlast = NUMBER_CHAR_DIGIT;\n} else if (last == NUMBER_CHAR_DIGIT) {\nif (value == 0) {\nlong newValue = value * 10 - (c - '0');\nfitsInLong &= value > MIN_INCOMPLETE_INTEGER\nvalue = newValue;\n} else if (last == NUMBER_CHAR_DECIMAL) {\nlast = NUMBER_CHAR_FRACTION_DIGIT;\n} else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\nlast = NUMBER_CHAR_EXP_DIGIT;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 8,
                    "tests": [
                        {
                            "test_name": "com.google.gson.internal.UnsafeAllocatorInstantiationTest.testAbstractClassInstantiation",
                            "test_body": "53: public void testAbstractClassInstantiation() {\n54: UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();\n55: try {\n56: unsafeAllocator.newInstance(AbstractClass.class);\n57: fail();\n58: } catch (Exception e) {\n59: assertEquals(e.getClass(), UnsupportedOperationException.class);\n60: }\n61: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.internal.UnsafeAllocator:create()Lcom/google/gson/internal/UnsafeAllocator;",
                                    "method_body": "public abstract <T> T newInstance(Class<T> c) throws Exception;\nClass<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\nField f = unsafeClass.getDeclaredField(\"theUnsafe\");\nf.setAccessible(true);\nfinal Object unsafe = f.get(null);\nfinal Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\nreturn new UnsafeAllocator() {\nreturn (T) allocateInstance.invoke(unsafe, c);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.UnsafeAllocator$1:newInstance(Ljava/lang/Class;)Ljava/lang/Object;",
                                    "method_body": "public abstract <T> T newInstance(Class<T> c) throws Exception;\nClass<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\nField f = unsafeClass.getDeclaredField(\"theUnsafe\");\nf.setAccessible(true);\nfinal Object unsafe = f.get(null);\nfinal Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\nreturn new UnsafeAllocator() {\nreturn (T) allocateInstance.invoke(unsafe, c);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.internal.UnsafeAllocatorInstantiationTest.testInterfaceInstantiation",
                            "test_body": "39: public void testInterfaceInstantiation() {\n40: UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();\n41: try {\n42: unsafeAllocator.newInstance(Interface.class);\n43: fail();\n44: } catch (Exception e) {\n45: assertEquals(e.getClass(), UnsupportedOperationException.class);\n46: }\n47: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.internal.UnsafeAllocator:create()Lcom/google/gson/internal/UnsafeAllocator;",
                                    "method_body": "public abstract <T> T newInstance(Class<T> c) throws Exception;\nClass<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\nField f = unsafeClass.getDeclaredField(\"theUnsafe\");\nf.setAccessible(true);\nfinal Object unsafe = f.get(null);\nfinal Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\nreturn new UnsafeAllocator() {\nreturn (T) allocateInstance.invoke(unsafe, c);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.UnsafeAllocator$1:newInstance(Ljava/lang/Class;)Ljava/lang/Object;",
                                    "method_body": "public abstract <T> T newInstance(Class<T> c) throws Exception;\nClass<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\nField f = unsafeClass.getDeclaredField(\"theUnsafe\");\nf.setAccessible(true);\nfinal Object unsafe = f.get(null);\nfinal Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\nreturn new UnsafeAllocator() {\nreturn (T) allocateInstance.invoke(unsafe, c);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 10,
                    "tests": [
                        {
                            "test_name": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.testPrimitiveFieldAnnotationTakesPrecedenceOverDefault",
                            "test_body": "233: public void testPrimitiveFieldAnnotationTakesPrecedenceOverDefault() {\n234: Gson gson = new Gson();\n235: String json = gson.toJson(new GadgetWithPrimitivePart(42));\n236: assertEquals(\"{\\\"part\\\":\\\"42\\\"}\", json);\n237: GadgetWithPrimitivePart gadget = gson.fromJson(json, GadgetWithPrimitivePart.class);\n238: assertEquals(42, gadget.part);\n239: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>()V",
                                    "method_body": "protected TypeToken() {\nthis.type = getSuperclassTypeParameter(getClass());\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(type);\nthis.hashCode = type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getSuperclassTypeParameter(Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getSuperclassTypeParameter(Class<?> subclass) {\nType superclass = subclass.getGenericSuperclass();\nif (superclass instanceof Class) {\nParameterizedType parameterized = (ParameterizedType) superclass;\nreturn $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/Class;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static <T> TypeToken<T> get(Class<T> type) {\nreturn new TypeToken<T>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\nreturn (Class<?>) type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\nif (toResolve instanceof TypeVariable) {\n} else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n} else if (toResolve instanceof GenericArrayType) {\n} else if (toResolve instanceof ParameterizedType) {\n} else if (toResolve instanceof WildcardType) {\nreturn toResolve;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.excluder = excluder;\nthis.fieldNamingStrategy = fieldNamingStrategy;\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nthis.lenient = lenient;\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\nfactories.add(excluder);\nfactories.addAll(typeAdapterFactories);\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nTypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\nfactories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\nfactories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.CURRENCY_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nfactories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<clinit>()V",
                                    "method_body": "static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\nprivate static final TypeToken<?> NULL_KEY_SURROGATE = new TypeToken<Object>() {};"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLong>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongArrayAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLongArray>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);\nif (cached != null) {\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\n}\nthreadCalls.remove(type);\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:toJson(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public String toJson(Object src) {\nif (src == null) {\nreturn toJson(src, src.getClass());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:toJson(Ljava/lang/Object;Ljava/lang/reflect/Type;)Ljava/lang/String;",
                                    "method_body": "public String toJson(Object src, Type typeOfSrc) {\nStringWriter writer = new StringWriter();\ntoJson(src, typeOfSrc, writer);\nreturn writer.toString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:toJson(Ljava/lang/Object;Ljava/lang/reflect/Type;Ljava/lang/Appendable;)V",
                                    "method_body": "public void toJson(Object src, Type typeOfSrc, Appendable writer) throws JsonIOException {\nJsonWriter jsonWriter = newJsonWriter(Streams.writerForAppendable(writer));\ntoJson(src, typeOfSrc, jsonWriter);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:toJson(Ljava/lang/Object;Ljava/lang/reflect/Type;Lcom/google/gson/stream/JsonWriter;)V",
                                    "method_body": "public void toJson(Object src, Type typeOfSrc, JsonWriter writer) throws JsonIOException {\nTypeAdapter<?> adapter = getAdapter(TypeToken.get(typeOfSrc));\nboolean oldLenient = writer.isLenient();\nwriter.setLenient(true);\nboolean oldHtmlSafe = writer.isHtmlSafe();\nwriter.setHtmlSafe(htmlSafe);\nboolean oldSerializeNulls = writer.getSerializeNulls();\nwriter.setSerializeNulls(serializeNulls);\n((TypeAdapter<Object>) adapter).write(writer, src);\nwriter.setLenient(oldLenient);\nwriter.setHtmlSafe(oldHtmlSafe);\nwriter.setSerializeNulls(oldSerializeNulls);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:newJsonWriter(Ljava/io/Writer;)Lcom/google/gson/stream/JsonWriter;",
                                    "method_body": "public JsonWriter newJsonWriter(Writer writer) throws IOException {\nif (generateNonExecutableJson) {\nJsonWriter jsonWriter = new JsonWriter(writer);\nif (prettyPrinting) {\njsonWriter.setSerializeNulls(serializeNulls);\nreturn jsonWriter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<init>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field field, boolean serialize) {\nif ((modifiers & field.getModifiers()) != 0) {\nif (version != Excluder.IGNORE_VERSIONS\nif (field.isSynthetic()) {\nif (requireExpose) {\nif (!serializeInnerClasses && isInnerClass(field.getType())) {\nif (isAnonymousOrLocal(field.getType())) {\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nif (!list.isEmpty()) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nif (isAnonymousOrLocal(clazz)) {\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.FieldNamingPolicy$1:translateName(Ljava/lang/reflect/Field;)Ljava/lang/String;",
                                    "method_body": "@Override public String translateName(Field f) {\nreturn f.getName();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nfinal InstanceCreator<T> rawTypeCreator =\nif (rawTypeCreator != null) {\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nreturn defaultConstructor;\nObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\nif (defaultImplementation != null) {\nreturn newUnsafeAllocator(type, rawType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultConstructor(Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\nreturn new ObjectConstructor<T>() {\nObject[] args = null;\nreturn (T) constructor.newInstance(args);\n} catch (NoSuchMethodException e) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultImplementationConstructor(Ljava/lang/reflect/Type;Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nif (Collection.class.isAssignableFrom(rawType)) {\nif (Map.class.isAssignableFrom(rawType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newUnsafeAllocator(Ljava/lang/reflect/Type;Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newUnsafeAllocator(\nreturn new ObjectConstructor<T>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY =\npublic static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() {\nout.value(value);\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:nullSafe()Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public final TypeAdapter<T> nullSafe() {\nreturn new TypeAdapter<T>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$12:write(Lcom/google/gson/stream/JsonWriter;Ljava/lang/Number;)V",
                                    "method_body": "public void write(JsonWriter out, Number value) throws IOException {\nout.value(value);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$35:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$26:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$34:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$30:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nif (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nif (type.getRawType() == Object.class) {\nreturn null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == java.sql.Date.class\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\nJsonAdapter annotation = targetType.getRawType().getAnnotation(JsonAdapter.class);\nif (annotation == null) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:getTypeAdapter(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;Lcom/google/gson/annotations/JsonAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\nClass<?> value = annotation.value();\nif (TypeAdapter.class.isAssignableFrom(value)) {\n} else if (TypeAdapterFactory.class.isAssignableFrom(value)) {\nClass<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;\ntypeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterFactory))\n} else {\nif (typeAdapter != null) {\ntypeAdapter = typeAdapter.nullSafe();\nreturn typeAdapter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nFieldNamingStrategy fieldNamingPolicy, Excluder excluder) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field f, boolean serialize) {\nreturn excludeField(f, serialize, excluder);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;ZLcom/google/gson/internal/Excluder;)Z",
                                    "method_body": "static boolean excludeField(Field f, boolean serialize, Excluder excluder) {\nreturn !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getFieldNames(Ljava/lang/reflect/Field;)Ljava/util/List;",
                                    "method_body": "private List<String> getFieldNames(Field f) {\nSerializedName annotation = f.getAnnotation(SerializedName.class);\nif (annotation == null) {\nString name = fieldNamingPolicy.translateName(f);\nreturn Collections.singletonList(name);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\nClass<? super T> raw = type.getRawType();\nif (!Object.class.isAssignableFrom(raw)) {\nObjectConstructor<T> constructor = constructorConstructor.get(type);\nreturn new Adapter<T>(constructor, getBoundFields(gson, type, raw));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:createBoundField(Lcom/google/gson/Gson;Ljava/lang/reflect/Field;Ljava/lang/String;Lcom/google/gson/reflect/TypeToken;ZZ)Lcom/google/gson/internal/bind/ReflectiveTypeAdapterFactory$BoundField;",
                                    "method_body": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(\nfinal boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\nJsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\nTypeAdapter<?> mapped = null;\nif (annotation != null) {\nmapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\nfinal boolean jsonAdapterPresent = mapped != null;\nif (mapped == null) mapped = context.getAdapter(fieldType);\nfinal TypeAdapter<?> typeAdapter = mapped;\nreturn new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\nObject fieldValue = field.get(value);\nTypeAdapter t =\nt.write(writer, fieldValue);\n}\nif (!serialized) return false;\nObject fieldValue = field.get(value);\nreturn fieldValue != value; // avoid recursion for example for Throwable.cause\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getBoundFields(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;Ljava/lang/Class;)Ljava/util/Map;",
                                    "method_body": "private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {\nMap<String, BoundField> result = new LinkedHashMap<String, BoundField>();\nif (raw.isInterface()) {\nType declaredType = type.getType();\nwhile (raw != Object.class) {\nField[] fields = raw.getDeclaredFields();\nfor (Field field : fields) {\nboolean serialize = excludeField(field, true);\nboolean deserialize = excludeField(field, false);\nif (!serialize && !deserialize) {\nfield.setAccessible(true);\nType fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\nList<String> fieldNames = getFieldNames(field);\nBoundField previous = null;\nfor (int i = 0; i < fieldNames.size(); ++i) {\nString name = fieldNames.get(i);\nif (i != 0) serialize = false; // only serialize the default name\nBoundField boundField = createBoundField(context, field, name,\nBoundField replaced = result.put(name, boundField);\nif (previous == null) previous = replaced;\nif (previous != null) {\ntype = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\nraw = type.getRawType();\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Streams:writerForAppendable(Ljava/lang/Appendable;)Ljava/io/Writer;",
                                    "method_body": "public static Writer writerForAppendable(Appendable appendable) {\nreturn appendable instanceof Writer ? (Writer) appendable : new AppendableWriter(appendable);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:<init>(Ljava/io/Writer;)V",
                                    "method_body": "public JsonWriter(Writer out) {\nif (out == null) {\nthis.out = out;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:<clinit>()V",
                                    "method_body": "private static final String[] REPLACEMENT_CHARS;\nREPLACEMENT_CHARS = new String[128];\nfor (int i = 0; i <= 0x1f; i++) {\nREPLACEMENT_CHARS[i] = String.format(\"\\\\u%04x\", (int) i);\nREPLACEMENT_CHARS['\"'] = \"\\\\\\\"\";\nREPLACEMENT_CHARS['\\\\'] = \"\\\\\\\\\";\nREPLACEMENT_CHARS['\\t'] = \"\\\\t\";\nREPLACEMENT_CHARS['\\b'] = \"\\\\b\";\nREPLACEMENT_CHARS['\\n'] = \"\\\\n\";\nREPLACEMENT_CHARS['\\r'] = \"\\\\r\";\nREPLACEMENT_CHARS['\\f'] = \"\\\\f\";\nHTML_SAFE_REPLACEMENT_CHARS = REPLACEMENT_CHARS.clone();\nHTML_SAFE_REPLACEMENT_CHARS['<'] = \"\\\\u003c\";\nHTML_SAFE_REPLACEMENT_CHARS['>'] = \"\\\\u003e\";\nHTML_SAFE_REPLACEMENT_CHARS['&'] = \"\\\\u0026\";\nHTML_SAFE_REPLACEMENT_CHARS['='] = \"\\\\u003d\";\nHTML_SAFE_REPLACEMENT_CHARS['\\''] = \"\\\\u0027\";\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:setLenient(Z)V",
                                    "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:isLenient()Z",
                                    "method_body": "public boolean isLenient() {\nreturn lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:setHtmlSafe(Z)V",
                                    "method_body": "public final void setHtmlSafe(boolean htmlSafe) {\nthis.htmlSafe = htmlSafe;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:isHtmlSafe()Z",
                                    "method_body": "public final boolean isHtmlSafe() {\nreturn htmlSafe;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:setSerializeNulls(Z)V",
                                    "method_body": "public final void setSerializeNulls(boolean serializeNulls) {\nthis.serializeNulls = serializeNulls;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:getSerializeNulls()Z",
                                    "method_body": "public final boolean getSerializeNulls() {\nreturn serializeNulls;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:beginObject()Lcom/google/gson/stream/JsonWriter;",
                                    "method_body": "public JsonWriter beginObject() throws IOException {\nwriteDeferredName();\nreturn open(EMPTY_OBJECT, \"{\");\nreturn close(EMPTY_OBJECT, NONEMPTY_OBJECT, \"}\");\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:endObject()Lcom/google/gson/stream/JsonWriter;",
                                    "method_body": "public JsonWriter beginObject() throws IOException {\nwriteDeferredName();\nreturn open(EMPTY_OBJECT, \"{\");\nreturn close(EMPTY_OBJECT, NONEMPTY_OBJECT, \"}\");\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:open(ILjava/lang/String;)Lcom/google/gson/stream/JsonWriter;",
                                    "method_body": "private JsonWriter open(int empty, String openBracket) throws IOException {\nbeforeValue();\npush(empty);\nout.write(openBracket);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:close(IILjava/lang/String;)Lcom/google/gson/stream/JsonWriter;",
                                    "method_body": "private JsonWriter close(int empty, int nonempty, String closeBracket)\nint context = peek();\nif (context != nonempty && context != empty) {\nif (deferredName != null) {\nstackSize--;\nif (context == nonempty) {\nnewline();\nout.write(closeBracket);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:push(I)V",
                                    "method_body": "private void push(int newTop) {\nif (stackSize == stack.length) {\nstack[stackSize++] = newTop;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:peek()I",
                                    "method_body": "private int peek() {\nif (stackSize == 0) {\nreturn stack[stackSize - 1];\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:replaceTop(I)V",
                                    "method_body": "private void replaceTop(int topOfStack) {\nstack[stackSize - 1] = topOfStack;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:name(Ljava/lang/String;)Lcom/google/gson/stream/JsonWriter;",
                                    "method_body": "public JsonWriter name(String name) throws IOException {\nif (name == null) {\nif (deferredName != null) {\nif (stackSize == 0) {\ndeferredName = name;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:writeDeferredName()V",
                                    "method_body": "private void writeDeferredName() throws IOException {\nif (deferredName != null) {\nbeforeName();\nstring(deferredName);\ndeferredName = null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:value(Ljava/lang/Number;)Lcom/google/gson/stream/JsonWriter;",
                                    "method_body": "public JsonWriter value(Number value) throws IOException {\nif (value == null) {\nwriteDeferredName();\nString string = value.toString();\nif (!lenient\nbeforeValue();\nout.append(string);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:string(Ljava/lang/String;)V",
                                    "method_body": "private void string(String value) throws IOException {\nString[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;\nout.write(\"\\\"\");\nint last = 0;\nint length = value.length();\nfor (int i = 0; i < length; i++) {\nchar c = value.charAt(i);\nif (c < 128) {\nreplacement = replacements[c];\nif (replacement == null) {\ncontinue;\nif (last < length) {\nout.write(value, last, length - last);\nout.write(\"\\\"\");\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:newline()V",
                                    "method_body": "private void newline() throws IOException {\nif (indent == null) {\nreturn;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:beforeName()V",
                                    "method_body": "private void beforeName() throws IOException {\nint context = peek();\nif (context == NONEMPTY_OBJECT) { // first in object\n} else if (context != EMPTY_OBJECT) { // not in an object!\nnewline();\nreplaceTop(DANGLING_NAME);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:beforeValue()V",
                                    "method_body": "private void beforeValue() throws IOException {\nswitch (peek()) {\nreplaceTop(NONEMPTY_DOCUMENT);\nbreak;\nout.append(separator);\nreplaceTop(NONEMPTY_OBJECT);\nbreak;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.UnsafeAllocator:create()Lcom/google/gson/internal/UnsafeAllocator;",
                                    "method_body": "public abstract <T> T newInstance(Class<T> c) throws Exception;\nClass<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\nField f = unsafeClass.getDeclaredField(\"theUnsafe\");\nf.setAccessible(true);\nfinal Object unsafe = f.get(null);\nfinal Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\nreturn new UnsafeAllocator() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson$FutureTypeAdapter:setDelegate(Lcom/google/gson/TypeAdapter;)V",
                                    "method_body": "public void setDelegate(TypeAdapter<T> typeAdapter) {\nif (delegate != null) {\ndelegate = typeAdapter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor$3:construct()Ljava/lang/Object;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\nreturn new ObjectConstructor<T>() {\nObject[] args = null;\nreturn (T) constructor.newInstance(args);\n} catch (NoSuchMethodException e) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:<init>(Lcom/google/gson/Gson;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeAdapterRuntimeTypeWrapper(Gson context, TypeAdapter<T> delegate, Type type) {\nthis.context = context;\nthis.delegate = delegate;\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:write(Lcom/google/gson/stream/JsonWriter;Ljava/lang/Object;)V",
                                    "method_body": "public void write(JsonWriter out, T value) throws IOException {\nTypeAdapter chosen = delegate;\nType runtimeType = getRuntimeTypeIfMoreSpecific(type, value);\nif (runtimeType != type) {\nTypeAdapter runtimeTypeAdapter = context.getAdapter(TypeToken.get(runtimeType));\nif (!(runtimeTypeAdapter instanceof ReflectiveTypeAdapterFactory.Adapter)) {\nchosen = runtimeTypeAdapter;\nchosen.write(out, value);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:getRuntimeTypeIfMoreSpecific(Ljava/lang/reflect/Type;Ljava/lang/Object;)Ljava/lang/reflect/Type;",
                                    "method_body": "private Type getRuntimeTypeIfMoreSpecific(Type type, Object value) {\nif (value != null\ntype = value.getClass();\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter:<init>(Lcom/google/gson/internal/ObjectConstructor;Ljava/util/Map;)V",
                                    "method_body": "abstract boolean writeField(Object value) throws IOException, IllegalAccessException;\nAdapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {\nthis.constructor = constructor;\nthis.boundFields = boundFields;\n}\nif (value == null) {\nout.beginObject();\nfor (BoundField boundField : boundFields.values()) {\nif (boundField.writeField(value)) {\nout.name(boundField.name);\nboundField.write(out, value);\n}\n}\nout.endObject();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter:write(Lcom/google/gson/stream/JsonWriter;Ljava/lang/Object;)V",
                                    "method_body": "abstract boolean writeField(Object value) throws IOException, IllegalAccessException;\nAdapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {\nthis.constructor = constructor;\nthis.boundFields = boundFields;\n}\nif (value == null) {\nout.beginObject();\nfor (BoundField boundField : boundFields.values()) {\nif (boundField.writeField(value)) {\nout.name(boundField.name);\nboundField.write(out, value);\n}\n}\nout.endObject();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:<clinit>()V",
                                    "method_body": "private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;\nMap<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);\nMap<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);\nadd(primToWrap, wrapToPrim, boolean.class, Boolean.class);\nadd(primToWrap, wrapToPrim, byte.class, Byte.class);\nadd(primToWrap, wrapToPrim, char.class, Character.class);\nadd(primToWrap, wrapToPrim, double.class, Double.class);\nadd(primToWrap, wrapToPrim, float.class, Float.class);\nadd(primToWrap, wrapToPrim, int.class, Integer.class);\nadd(primToWrap, wrapToPrim, long.class, Long.class);\nadd(primToWrap, wrapToPrim, short.class, Short.class);\nadd(primToWrap, wrapToPrim, void.class, Void.class);\nPRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);\nWRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:add(Ljava/util/Map;Ljava/util/Map;Ljava/lang/Class;Ljava/lang/Class;)V",
                                    "method_body": "private static void add(Map<Class<?>, Class<?>> forward,\nforward.put(key, value);\nbackward.put(value, key);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:isPrimitive(Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public static boolean isPrimitive(Type type) {\nreturn PRIMITIVE_TO_WRAPPER_TYPE.containsKey(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$BoundField:<init>(Ljava/lang/String;ZZ)V",
                                    "method_body": "protected BoundField(String name, boolean serialized, boolean deserialized) {\nthis.name = name;\nthis.serialized = serialized;\nthis.deserialized = deserialized;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$1:write(Lcom/google/gson/stream/JsonWriter;Ljava/lang/Object;)V",
                                    "method_body": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(\nfinal boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\nJsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\nTypeAdapter<?> mapped = null;\nif (annotation != null) {\nmapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\nfinal boolean jsonAdapterPresent = mapped != null;\nif (mapped == null) mapped = context.getAdapter(fieldType);\nfinal TypeAdapter<?> typeAdapter = mapped;\nreturn new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\nObject fieldValue = field.get(value);\nTypeAdapter t =\nt.write(writer, fieldValue);\n}\nif (!serialized) return false;\nObject fieldValue = field.get(value);\nreturn fieldValue != value; // avoid recursion for example for Throwable.cause\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$1:writeField(Ljava/lang/Object;)Z",
                                    "method_body": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(\nfinal boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\nJsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\nTypeAdapter<?> mapped = null;\nif (annotation != null) {\nmapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\nfinal boolean jsonAdapterPresent = mapped != null;\nif (mapped == null) mapped = context.getAdapter(fieldType);\nfinal TypeAdapter<?> typeAdapter = mapped;\nreturn new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\nObject fieldValue = field.get(value);\nTypeAdapter t =\nt.write(writer, fieldValue);\n}\nif (!serialized) return false;\nObject fieldValue = field.get(value);\nreturn fieldValue != value; // avoid recursion for example for Throwable.cause\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 11,
                    "tests": [
                        {
                            "test_name": "com.google.gson.functional.PrimitiveTest.testNumberAsStringDeserialization",
                            "test_body": "161: public void testNumberAsStringDeserialization() {\n162: Number value = gson.fromJson(\"\\\"18\\\"\", Number.class);\n163: assertEquals(18, value.intValue());\n164: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>()V",
                                    "method_body": "protected TypeToken() {\nthis.type = getSuperclassTypeParameter(getClass());\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(type);\nthis.hashCode = type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getSuperclassTypeParameter(Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getSuperclassTypeParameter(Class<?> subclass) {\nType superclass = subclass.getGenericSuperclass();\nif (superclass instanceof Class) {\nParameterizedType parameterized = (ParameterizedType) superclass;\nreturn $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\nreturn (Class<?>) type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate boolean lenient = false;\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\nint peeked = PEEKED_NONE;\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<clinit>()V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate boolean lenient = false;\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\nint peeked = PEEKED_NONE;\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:setLenient(Z)V",
                                    "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:isLenient()Z",
                                    "method_body": "public final boolean isLenient() {\nreturn lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\nswitch (p) {\nreturn JsonToken.STRING;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:doPeek()I",
                                    "method_body": "int doPeek() throws IOException {\nint peekStack = stack[stackSize - 1];\nif (peekStack == JsonScope.EMPTY_ARRAY) {\n} else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit -= pos;\nSystem.arraycopy(buffer, pos, buffer, 0, limit);\nlimit = 0;\npos = 0;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\nif (limit >= minimum) {\nreturn true;\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\np = pos;\nl = limit;\nint c = buffer[p++];\nif (c == '\\n') {\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\nif (c == '/') {\n} else if (c == '#') {\npos = p;\nreturn c;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:consumeNonExecutePrefix()V",
                                    "method_body": "private void consumeNonExecutePrefix() throws IOException {\nnextNonWhitespace(true);\npos--;\nif (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\nreturn;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory CALENDAR_FACTORY =\npublic static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:nullSafe()Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public final TypeAdapter<T> nullSafe() {\nreturn new TypeAdapter<T>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$15:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Number;",
                                    "method_body": "public Number read(JsonReader in) throws IOException {\nJsonToken jsonToken = in.peek();\nswitch (jsonToken) {\nthrow new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$35:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$36:<clinit>()V",
                                    "method_body": "@Override public BitSet read(JsonReader in) throws IOException {\nswitch (tokenType) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.excluder = excluder;\nthis.fieldNamingStrategy = fieldNamingStrategy;\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nthis.lenient = lenient;\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\nfactories.add(excluder);\nfactories.addAll(typeAdapterFactories);\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nTypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\nfactories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\nfactories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.CURRENCY_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nthis.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);\nfactories.add(jsonAdapterFactory);\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<clinit>()V",
                                    "method_body": "static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\nprivate static final TypeToken<?> NULL_KEY_SURROGATE = new TypeToken<Object>() {};"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLong>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongArrayAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLongArray>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);\nif (cached != null) {\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\n}\nthreadCalls.remove(type);\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:newJsonReader(Ljava/io/Reader;)Lcom/google/gson/stream/JsonReader;",
                                    "method_body": "public JsonReader newJsonReader(Reader reader) {\nJsonReader jsonReader = new JsonReader(reader);\njsonReader.setLenient(lenient);\nreturn jsonReader;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException {\nObject object = fromJson(json, (Type) classOfT);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {\nif (json == null) {\nStringReader reader = new StringReader(json);\nT target = (T) fromJson(reader, typeOfT);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/io/Reader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nJsonReader jsonReader = newJsonReader(json);\nT object = (T) fromJson(jsonReader, typeOfT);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Lcom/google/gson/stream/JsonReader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nboolean isEmpty = true;\nboolean oldLenient = reader.isLenient();\nreader.setLenient(true);\nreader.peek();\nisEmpty = false;\nTypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\nTypeAdapter<T> typeAdapter = getAdapter(typeToken);\nT object = typeAdapter.read(reader);\nreader.setLenient(oldLenient);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<init>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nif (isAnonymousOrLocal(clazz)) {\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nif (type.getRawType() == Object.class) {\nreturn null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;Lcom/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nJsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\nthis.jsonAdapterFactory = jsonAdapterFactory;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson$FutureTypeAdapter:setDelegate(Lcom/google/gson/TypeAdapter;)V",
                                    "method_body": "public void setDelegate(TypeAdapter<T> typeAdapter) {\nif (delegate != null) {\ndelegate = typeAdapter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonParseException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public JsonParseException(String msg) {\nsuper(msg);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonSyntaxException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public JsonSyntaxException(String msg) {\nsuper(msg);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 12,
                    "tests": [
                        {
                            "test_name": "com.google.gson.internal.bind.JsonTreeReaderTest.testSkipValue_filledJsonObject",
                            "test_body": "33: public void testSkipValue_filledJsonObject() throws IOException {\n34: JsonObject jsonObject = new JsonObject();\n35: JsonArray jsonArray = new JsonArray();\n36: jsonArray.add('c');\n37: jsonArray.add(\"text\");\n38: jsonObject.add(\"a\", jsonArray);\n39: jsonObject.addProperty(\"b\", true);\n40: jsonObject.addProperty(\"i\", 1);\n41: jsonObject.add(\"n\", JsonNull.INSTANCE);\n42: JsonObject jsonObject2 = new JsonObject();\n43: jsonObject2.addProperty(\"n\", 2L);\n44: jsonObject.add(\"o\", jsonObject2);\n45: jsonObject.addProperty(\"s\", \"text\");\n46: JsonTreeReader in = new JsonTreeReader(jsonObject);\n47: in.skipValue();\n48: assertEquals(JsonToken.END_DOCUMENT, in.peek());\n49: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "public JsonReader(Reader in) {\nif (in == null) {\nthis.in = in;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonObject:<init>()V",
                                    "method_body": "private final LinkedTreeMap<String, JsonElement> members =\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonObject:add(Ljava/lang/String;Lcom/google/gson/JsonElement;)V",
                                    "method_body": "public void add(String property, JsonElement value) {\nif (value == null) {\nmembers.put(property, value);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonObject:addProperty(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public void addProperty(String property, String value) {\nadd(property, createJsonElement(value));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonObject:addProperty(Ljava/lang/String;Ljava/lang/Number;)V",
                                    "method_body": "public void addProperty(String property, Number value) {\nadd(property, createJsonElement(value));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonObject:addProperty(Ljava/lang/String;Ljava/lang/Boolean;)V",
                                    "method_body": "public void addProperty(String property, Boolean value) {\nadd(property, createJsonElement(value));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonObject:createJsonElement(Ljava/lang/Object;)Lcom/google/gson/JsonElement;",
                                    "method_body": "private JsonElement createJsonElement(Object value) {\nreturn value == null ? JsonNull.INSTANCE : new JsonPrimitive(value);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:<init>()V",
                                    "method_body": "public LinkedTreeMap() {\nthis((Comparator<? super K>) NATURAL_ORDER);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:<init>(Ljava/util/Comparator;)V",
                                    "method_body": "Comparator<? super K> comparator;\nint size = 0;\nint modCount = 0;\nfinal Node<K, V> header = new Node<K, V>();\nthis((Comparator<? super K>) NATURAL_ORDER);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:<clinit>()V",
                                    "method_body": "private static final Comparator<Comparable> NATURAL_ORDER = new Comparator<Comparable>() {\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:put(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "@Override public V put(K key, V value) {\nif (key == null) {\nNode<K, V> created = find(key, true);\nV result = created.value;\ncreated.value = value;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:find(Ljava/lang/Object;Z)Lcom/google/gson/internal/LinkedTreeMap$Node;",
                                    "method_body": "Node<K, V> find(K key, boolean create) {\nComparator<? super K> comparator = this.comparator;\nNode<K, V> nearest = root;\nint comparison = 0;\nif (nearest != null) {\nComparable<Object> comparableKey = (comparator == NATURAL_ORDER)\ncomparison = (comparableKey != null)\nif (comparison == 0) {\nNode<K, V> child = (comparison < 0) ? nearest.left : nearest.right;\nif (child == null) {\nbreak;\nnearest = child;\n}\nif (!create) {\nNode<K, V> header = this.header;\nif (nearest == null) {\nif (comparator == NATURAL_ORDER && !(key instanceof Comparable)) {\ncreated = new Node<K, V>(nearest, key, header, header.prev);\nroot = created;\ncreated = new Node<K, V>(nearest, key, header, header.prev);\nif (comparison < 0) { // nearest.key is higher\nnearest.right = created;\nrebalance(nearest, true);\nsize++;\nmodCount++;\nreturn created;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:replaceInParent(Lcom/google/gson/internal/LinkedTreeMap$Node;Lcom/google/gson/internal/LinkedTreeMap$Node;)V",
                                    "method_body": "private void replaceInParent(Node<K, V> node, Node<K, V> replacement) {\nNode<K, V> parent = node.parent;\nnode.parent = null;\nif (replacement != null) {\nreplacement.parent = parent;\nif (parent != null) {\nif (parent.left == node) {\nassert (parent.right == node);\nparent.right = replacement;\nroot = replacement;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:rebalance(Lcom/google/gson/internal/LinkedTreeMap$Node;Z)V",
                                    "method_body": "private void rebalance(Node<K, V> unbalanced, boolean insert) {\nfor (Node<K, V> node = unbalanced; node != null; node = node.parent) {\nNode<K, V> left = node.left;\nNode<K, V> right = node.right;\nint leftHeight = left != null ? left.height : 0;\nint rightHeight = right != null ? right.height : 0;\nint delta = leftHeight - rightHeight;\nif (delta == -2) {\nNode<K, V> rightLeft = right.left;\nNode<K, V> rightRight = right.right;\nint rightRightHeight = rightRight != null ? rightRight.height : 0;\nint rightLeftHeight = rightLeft != null ? rightLeft.height : 0;\nint rightDelta = rightLeftHeight - rightRightHeight;\nif (rightDelta == -1 || (rightDelta == 0 && !insert)) {\nrotateLeft(node); // AVL right right\nif (insert) {\nbreak; // no further rotations will be necessary\n} else if (delta == 2) {\n} else if (delta == 0) {\nassert (delta == -1 || delta == 1);\nnode.height = Math.max(leftHeight, rightHeight) + 1;\nif (!insert) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:rotateLeft(Lcom/google/gson/internal/LinkedTreeMap$Node;)V",
                                    "method_body": "private void rotateLeft(Node<K, V> root) {\nNode<K, V> left = root.left;\nNode<K, V> pivot = root.right;\nNode<K, V> pivotLeft = pivot.left;\nNode<K, V> pivotRight = pivot.right;\nroot.right = pivotLeft;\nif (pivotLeft != null) {\npivotLeft.parent = root;\nreplaceInParent(root, pivot);\npivot.left = root;\nroot.parent = pivot;\nroot.height = Math.max(left != null ? left.height : 0,\npivot.height = Math.max(root.height,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap$Node:<init>()V",
                                    "method_body": "Node() {\nkey = null;\nnext = prev = this;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap$Node:<init>(Lcom/google/gson/internal/LinkedTreeMap$Node;Ljava/lang/Object;Lcom/google/gson/internal/LinkedTreeMap$Node;Lcom/google/gson/internal/LinkedTreeMap$Node;)V",
                                    "method_body": "Node(Node<K, V> parent, K key, Node<K, V> next, Node<K, V> prev) {\nthis.parent = parent;\nthis.key = key;\nthis.height = 1;\nthis.next = next;\nthis.prev = prev;\nprev.next = this;\nnext.prev = this;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:<init>(Ljava/lang/String;)V",
                                    "method_body": "public JsonPrimitive(String string) {\nsetValue(string);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:<init>(Ljava/lang/Character;)V",
                                    "method_body": "public JsonPrimitive(Character c) {\nsetValue(c);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:<init>(Ljava/lang/Object;)V",
                                    "method_body": "JsonPrimitive(Object primitive) {\nsetValue(primitive);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:<clinit>()V",
                                    "method_body": "private static final Class<?>[] PRIMITIVE_TYPES = { int.class, long.class, short.class,\nShort.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class };"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:setValue(Ljava/lang/Object;)V",
                                    "method_body": "void setValue(Object primitive) {\nif (primitive instanceof Character) {\nchar c = ((Character) primitive).charValue();\nthis.value = String.valueOf(c);\n} else {\n$Gson$Preconditions.checkArgument(primitive instanceof Number\nthis.value = primitive;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:isPrimitiveOrString(Ljava/lang/Object;)Z",
                                    "method_body": "private static boolean isPrimitiveOrString(Object target) {\nif (target instanceof String) {\nreturn true;\nClass<?> classOfPrimitive = target.getClass();\nfor (Class<?> standardPrimitive : PRIMITIVE_TYPES) {\nif (standardPrimitive.isAssignableFrom(classOfPrimitive)) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonNull:<init>()V",
                                    "method_body": "public JsonNull() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonNull:<clinit>()V",
                                    "method_body": "public static final JsonNull INSTANCE = new JsonNull();\n* Deprecated since Gson version 1.8. Use {@link #INSTANCE} instead"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonArray:<init>()V",
                                    "method_body": "public JsonArray() {\nelements = new ArrayList<JsonElement>();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonArray:add(Ljava/lang/Character;)V",
                                    "method_body": "public void add(Character character) {\nelements.add(character == null ? JsonNull.INSTANCE : new JsonPrimitive(character));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonArray:add(Ljava/lang/String;)V",
                                    "method_body": "public void add(String string) {\nelements.add(string == null ? JsonNull.INSTANCE : new JsonPrimitive(string));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:<init>(Lcom/google/gson/JsonElement;)V",
                                    "method_body": "private static final Object SENTINEL_CLOSED = new Object();\nprivate Object[] stack = new Object[32];\nprivate int stackSize = 0;\nprivate String[] pathNames = new String[32];\nprivate int[] pathIndices = new int[32];\nsuper(UNREADABLE_READER);\npush(element);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:<clinit>()V",
                                    "method_body": "private static final Object SENTINEL_CLOSED = new Object();\nprivate Object[] stack = new Object[32];\nprivate int stackSize = 0;\nprivate String[] pathNames = new String[32];\nprivate int[] pathIndices = new int[32];\nsuper(UNREADABLE_READER);\npush(element);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "@Override public JsonToken peek() throws IOException {\nif (stackSize == 0) {\nObject o = peekStack();\nif (o instanceof Iterator) {\n} else if (o instanceof JsonObject) {\nreturn JsonToken.BEGIN_OBJECT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:peekStack()Ljava/lang/Object;",
                                    "method_body": "private Object peekStack() {\nreturn stack[stackSize - 1];\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:popStack()Ljava/lang/Object;",
                                    "method_body": "private Object popStack() {\nObject result = stack[--stackSize];\nstack[stackSize] = null;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:skipValue()V",
                                    "method_body": "@Override public void skipValue() throws IOException {\nif (peek() == JsonToken.NAME) {\npopStack();\npathNames[stackSize - 1] = \"null\";\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:push(Ljava/lang/Object;)V",
                                    "method_body": "private void push(Object newTop) {\nif (stackSize == stack.length) {\nstack[stackSize++] = newTop;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.internal.bind.JsonTreeReaderTest.testSkipValue_emptyJsonObject",
                            "test_body": "27: public void testSkipValue_emptyJsonObject() throws IOException {\n28: JsonTreeReader in = new JsonTreeReader(new JsonObject());\n29: in.skipValue();\n30: assertEquals(JsonToken.END_DOCUMENT, in.peek());\n31: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "public JsonReader(Reader in) {\nif (in == null) {\nthis.in = in;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonObject:<init>()V",
                                    "method_body": "private final LinkedTreeMap<String, JsonElement> members =\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:<init>()V",
                                    "method_body": "public LinkedTreeMap() {\nthis((Comparator<? super K>) NATURAL_ORDER);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:<init>(Ljava/util/Comparator;)V",
                                    "method_body": "Comparator<? super K> comparator;\nint size = 0;\nint modCount = 0;\nfinal Node<K, V> header = new Node<K, V>();\nthis((Comparator<? super K>) NATURAL_ORDER);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:<clinit>()V",
                                    "method_body": "private static final Comparator<Comparable> NATURAL_ORDER = new Comparator<Comparable>() {\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap$Node:<init>()V",
                                    "method_body": "Node() {\nkey = null;\nnext = prev = this;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:<init>(Lcom/google/gson/JsonElement;)V",
                                    "method_body": "private static final Object SENTINEL_CLOSED = new Object();\nprivate Object[] stack = new Object[32];\nprivate int stackSize = 0;\nprivate String[] pathNames = new String[32];\nprivate int[] pathIndices = new int[32];\nsuper(UNREADABLE_READER);\npush(element);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:<clinit>()V",
                                    "method_body": "private static final Object SENTINEL_CLOSED = new Object();\nprivate Object[] stack = new Object[32];\nprivate int stackSize = 0;\nprivate String[] pathNames = new String[32];\nprivate int[] pathIndices = new int[32];\nsuper(UNREADABLE_READER);\npush(element);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "@Override public JsonToken peek() throws IOException {\nif (stackSize == 0) {\nObject o = peekStack();\nif (o instanceof Iterator) {\n} else if (o instanceof JsonObject) {\nreturn JsonToken.BEGIN_OBJECT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:peekStack()Ljava/lang/Object;",
                                    "method_body": "private Object peekStack() {\nreturn stack[stackSize - 1];\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:popStack()Ljava/lang/Object;",
                                    "method_body": "private Object popStack() {\nObject result = stack[--stackSize];\nstack[stackSize] = null;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:skipValue()V",
                                    "method_body": "@Override public void skipValue() throws IOException {\nif (peek() == JsonToken.NAME) {\npopStack();\npathNames[stackSize - 1] = \"null\";\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:push(Ljava/lang/Object;)V",
                                    "method_body": "private void push(Object newTop) {\nif (stackSize == stack.length) {\nstack[stackSize++] = newTop;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 13,
                    "tests": [
                        {
                            "test_name": "com.google.gson.stream.JsonReaderTest.testNegativeZero",
                            "test_body": "568: public void testNegativeZero() throws Exception {\n569: JsonReader reader = new JsonReader(reader(\"[-0]\"));\n570: reader.setLenient(false);\n571: reader.beginArray();\n572: assertEquals(NUMBER, reader.peek());\n573: assertEquals(\"-0\", reader.nextString());\n574: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate boolean lenient = false;\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\nint peeked = PEEKED_NONE;\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:setLenient(Z)V",
                                    "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:beginArray()V",
                                    "method_body": "public void beginArray() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\nif (p == PEEKED_BEGIN_ARRAY) {\npush(JsonScope.EMPTY_ARRAY);\npathIndices[stackSize - 1] = 0;\npeeked = PEEKED_NONE;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\nswitch (p) {\nreturn JsonToken.NUMBER;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:doPeek()I",
                                    "method_body": "int doPeek() throws IOException {\nint peekStack = stack[stackSize - 1];\nif (peekStack == JsonScope.EMPTY_ARRAY) {\nstack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n} else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peekKeyword()I",
                                    "method_body": "private int peekKeyword() throws IOException {\nchar c = buffer[pos];\nif (c == 't' || c == 'T') {\n} else if (c == 'f' || c == 'F') {\n} else if (c == 'n' || c == 'N') {\nreturn PEEKED_NONE;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peekNumber()I",
                                    "method_body": "private int peekNumber() throws IOException {\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nlong value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\nboolean negative = false;\nboolean fitsInLong = true;\nint last = NUMBER_CHAR_NONE;\nint i = 0;\nfor (; true; i++) {\nif (p + i == l) {\nchar c = buffer[p + i];\nswitch (c) {\nif (last == NUMBER_CHAR_NONE) {\nnegative = true;\nlast = NUMBER_CHAR_SIGN;\ncontinue;\nif (c < '0' || c > '9') {\nif (!isLiteral(c)) {\nbreak charactersOfNumber;\nif (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\nvalue = -(c - '0');\nlast = NUMBER_CHAR_DIGIT;\nif (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\npeekedLong = negative ? value : -value;\npos += i;\nreturn peeked = PEEKED_LONG;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:isLiteral(C)Z",
                                    "method_body": "private boolean isLiteral(char c) throws IOException {\nswitch (c) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextString()Ljava/lang/String;",
                                    "method_body": "public String nextString() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\nif (p == PEEKED_UNQUOTED) {\n} else if (p == PEEKED_SINGLE_QUOTED) {\n} else if (p == PEEKED_DOUBLE_QUOTED) {\n} else if (p == PEEKED_BUFFERED) {\n} else if (p == PEEKED_LONG) {\nresult = Long.toString(peekedLong);\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:push(I)V",
                                    "method_body": "private void push(int newTop) {\nif (stackSize == stack.length) {\nstack[stackSize++] = newTop;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit = 0;\npos = 0;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\nif (limit >= minimum) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\np = pos;\nl = limit;\nint c = buffer[p++];\nif (c == '\\n') {\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\nif (c == '/') {\n} else if (c == '#') {\npos = p;\nreturn c;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 14,
                    "tests": [
                        {
                            "test_name": "com.google.gson.internal.bind.RecursiveTypesResolveTest.testSuperSubtype",
                            "test_body": "80: public void testSuperSubtype() {\n81: assertEquals($Gson$Types.subtypeOf(Object.class),\n82: $Gson$Types.supertypeOf($Gson$Types.subtypeOf(Number.class)));\n83: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:supertypeOf(Ljava/lang/reflect/Type;)Ljava/lang/reflect/WildcardType;",
                                    "method_body": "public static WildcardType supertypeOf(Type bound) {\nlowerBounds = new Type[] { bound };\nreturn new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:equals(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public static boolean equals(Type a, Type b) {\nif (a == b) {\nreturn true;\n} else if (a instanceof Class) {\nreturn a.equals(b);\n} else if (a instanceof ParameterizedType) {\nif (!(b instanceof ParameterizedType)) {\nParameterizedType pa = (ParameterizedType) a;\nParameterizedType pb = (ParameterizedType) b;\nreturn equal(pa.getOwnerType(), pb.getOwnerType())\n} else if (a instanceof GenericArrayType) {\nif (!(b instanceof GenericArrayType)) {\nreturn false;\nGenericArrayType ga = (GenericArrayType) a;\nGenericArrayType gb = (GenericArrayType) b;\nreturn equals(ga.getGenericComponentType(), gb.getGenericComponentType());\n} else if (a instanceof WildcardType) {\nif (!(b instanceof WildcardType)) {\nWildcardType wa = (WildcardType) a;\nWildcardType wb = (WildcardType) b;\nreturn Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:typeToString(Ljava/lang/reflect/Type;)Ljava/lang/String;",
                                    "method_body": "public static String typeToString(Type type) {\nreturn type instanceof Class ? ((Class<?>) type).getName() : type.toString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$WildcardTypeImpl:<init>([Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:subtypeOf(Ljava/lang/reflect/Type;)Ljava/lang/reflect/WildcardType;",
                                    "method_body": "public static WildcardType subtypeOf(Type bound) {\nupperBounds = new Type[] { bound };\nreturn new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.internal.bind.RecursiveTypesResolveTest.testIssue603PrintStream",
                            "test_body": "56: public void testIssue603PrintStream() {\n57: TypeAdapter<PrintStream> adapter = new Gson().getAdapter(PrintStream.class);\n58: assertNotNull(adapter);\n59: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:supertypeOf(Ljava/lang/reflect/Type;)Ljava/lang/reflect/WildcardType;",
                                    "method_body": "public static WildcardType supertypeOf(Type bound) {\nlowerBounds = new Type[] { bound };\nreturn new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$WildcardTypeImpl:<init>([Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:equals(Ljava/lang/Object;)Z",
                                    "method_body": "@Override public final boolean equals(Object o) {\nreturn o instanceof TypeToken<?>\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/Class;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static <T> TypeToken<T> get(Class<T> type) {\nreturn new TypeToken<T>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:newParameterizedTypeWithOwner(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)Ljava/lang/reflect/ParameterizedType;",
                                    "method_body": "public static ParameterizedType newParameterizedTypeWithOwner(\nreturn new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:subtypeOf(Ljava/lang/reflect/Type;)Ljava/lang/reflect/WildcardType;",
                                    "method_body": "public static WildcardType subtypeOf(Type bound) {\nupperBounds = new Type[] { bound };\nreturn new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\nreturn (Class<?>) type;\n} else if (type instanceof ParameterizedType) {\nParameterizedType parameterizedType = (ParameterizedType) type;\nType rawType = parameterizedType.getRawType();\ncheckArgument(rawType instanceof Class);\nreturn (Class<?>) rawType;\n} else if (type instanceof GenericArrayType) {\nType componentType = ((GenericArrayType)type).getGenericComponentType();\nreturn Array.newInstance(getRawType(componentType), 0).getClass();\n} else if (type instanceof TypeVariable) {\nreturn Object.class;\n} else if (type instanceof WildcardType) {\nreturn getRawType(((WildcardType) type).getUpperBounds()[0]);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:hashCodeOrZero(Ljava/lang/Object;)I",
                                    "method_body": "static int hashCodeOrZero(Object o) {\nreturn o != null ? o.hashCode() : 0;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getGenericSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\nif (toResolve == rawType) {\nreturn context;\nif (toResolve.isInterface()) {\nClass<?>[] interfaces = rawType.getInterfaces();\nfor (int i = 0, length = interfaces.length; i < length; i++) {\nif (interfaces[i] == toResolve) {\nreturn rawType.getGenericInterfaces()[i];\nif (!rawType.isInterface()) {\nwhile (rawType != Object.class) {\nClass<?> rawSupertype = rawType.getSuperclass();\nif (rawSupertype == toResolve) {\n} else if (toResolve.isAssignableFrom(rawSupertype)) {\nrawType = rawSupertype;\n}\nreturn toResolve;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\nif (toResolve instanceof TypeVariable) {\nTypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\ntoResolve = resolveTypeVariable(context, contextRawType, typeVariable);\nif (toResolve == typeVariable) {\nreturn toResolve;\n} else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\nClass<?> original = (Class<?>) toResolve;\nType componentType = original.getComponentType();\nType newComponentType = resolve(context, contextRawType, componentType);\nreturn componentType == newComponentType\n} else if (toResolve instanceof GenericArrayType) {\n} else if (toResolve instanceof ParameterizedType) {\nParameterizedType original = (ParameterizedType) toResolve;\nType ownerType = original.getOwnerType();\nType newOwnerType = resolve(context, contextRawType, ownerType);\nboolean changed = newOwnerType != ownerType;\nType[] args = original.getActualTypeArguments();\nfor (int t = 0, length = args.length; t < length; t++) {\nType resolvedTypeArgument = resolve(context, contextRawType, args[t]);\nif (resolvedTypeArgument != args[t]) {\nif (!changed) {\nargs = args.clone();\nchanged = true;\nargs[t] = resolvedTypeArgument;\nreturn changed\n} else if (toResolve instanceof WildcardType) {\nWildcardType original = (WildcardType) toResolve;\nType[] originalLowerBound = original.getLowerBounds();\nType[] originalUpperBound = original.getUpperBounds();\nif (originalLowerBound.length == 1) {\nType lowerBound = resolve(context, contextRawType, originalLowerBound[0]);\nif (lowerBound != originalLowerBound[0]) {\nreturn supertypeOf(lowerBound);\n} else if (originalUpperBound.length == 1) {\nType upperBound = resolve(context, contextRawType, originalUpperBound[0]);\nif (upperBound != originalUpperBound[0]) {\nreturn subtypeOf(upperBound);\nreturn original;\nreturn toResolve;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolveTypeVariable(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/TypeVariable;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\nClass<?> declaredByRaw = declaringClassOf(unknown);\nif (declaredByRaw == null) {\nType declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\nif (declaredBy instanceof ParameterizedType) {\nint index = indexOf(declaredByRaw.getTypeParameters(), unknown);\nreturn ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\nreturn unknown;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:indexOf([Ljava/lang/Object;Ljava/lang/Object;)I",
                                    "method_body": "private static int indexOf(Object[] array, Object toFind) {\nfor (int i = 0, length = array.length; i < length; i++) {\nif (toFind.equals(array[i])) {\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:declaringClassOf(Ljava/lang/reflect/TypeVariable;)Ljava/lang/Class;",
                                    "method_body": "private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\nGenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\nreturn genericDeclaration instanceof Class\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$ParameterizedTypeImpl:<init>(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory CALENDAR_FACTORY =\npublic static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:nullSafe()Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public final TypeAdapter<T> nullSafe() {\nreturn new TypeAdapter<T>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$35:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$26:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$34:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$30:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nif (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.excluder = excluder;\nthis.fieldNamingStrategy = fieldNamingStrategy;\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nthis.lenient = lenient;\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\nfactories.add(excluder);\nfactories.addAll(typeAdapterFactories);\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nTypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\nfactories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\nfactories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.CURRENCY_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nthis.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);\nfactories.add(jsonAdapterFactory);\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<clinit>()V",
                                    "method_body": "static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\nprivate static final TypeToken<?> NULL_KEY_SURROGATE = TypeToken.get(Object.class);\nprivate final ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>> calls\nprivate final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache = new ConcurrentHashMap<TypeToken<?>, TypeAdapter<?>>();\n*   {@link GsonBuilder#setPrettyPrinting()}. </li>"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLong>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongArrayAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLongArray>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);\nif (cached != null) {\nreturn (TypeAdapter<T>) cached;\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nreturn ongoingCall;\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\n}\nthreadCalls.remove(type);\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Ljava/lang/Class;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(Class<T> type) {\nreturn getAdapter(TypeToken.get(type));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<init>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field field, boolean serialize) {\nif ((modifiers & field.getModifiers()) != 0) {\nreturn true;\nif (version != Excluder.IGNORE_VERSIONS\nif (field.isSynthetic()) {\nif (requireExpose) {\nif (!serializeInnerClasses && isInnerClass(field.getType())) {\nif (isAnonymousOrLocal(field.getType())) {\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nif (!list.isEmpty()) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nif (isAnonymousOrLocal(clazz)) {\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.FieldNamingPolicy$1:translateName(Ljava/lang/reflect/Field;)Ljava/lang/String;",
                                    "method_body": "@Override public String translateName(Field f) {\nreturn f.getName();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nfinal InstanceCreator<T> rawTypeCreator =\nif (rawTypeCreator != null) {\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nreturn defaultConstructor;\nObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\nif (defaultImplementation != null) {\nreturn defaultImplementation;\nreturn newUnsafeAllocator(type, rawType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultConstructor(Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\nreturn new ObjectConstructor<T>() {\n} catch (NoSuchMethodException e) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultImplementationConstructor(Ljava/lang/reflect/Type;Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nif (Collection.class.isAssignableFrom(rawType)) {\nif (SortedSet.class.isAssignableFrom(rawType)) {\n} else if (EnumSet.class.isAssignableFrom(rawType)) {\n} else if (Set.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n} else if (Queue.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\nif (Map.class.isAssignableFrom(rawType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newUnsafeAllocator(Ljava/lang/reflect/Type;Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newUnsafeAllocator(\nreturn new ObjectConstructor<T>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<init>(Lcom/google/gson/Gson;)V",
                                    "method_body": "ObjectTypeAdapter(Gson gson) {\nthis.gson = gson;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\nreturn null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == java.sql.Date.class\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\nType elementType = $Gson$Types.getCollectionElementType(type, rawType);\nTypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\nTypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\nClass<? super T> rawType = targetType.getRawType();\nJsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);\nif (annotation == null) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;Lcom/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nJsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\nthis.jsonAdapterFactory = jsonAdapterFactory;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field f, boolean serialize) {\nreturn excludeField(f, serialize, excluder);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;ZLcom/google/gson/internal/Excluder;)Z",
                                    "method_body": "static boolean excludeField(Field f, boolean serialize, Excluder excluder) {\nreturn !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getFieldNames(Ljava/lang/reflect/Field;)Ljava/util/List;",
                                    "method_body": "private List<String> getFieldNames(Field f) {\nSerializedName annotation = f.getAnnotation(SerializedName.class);\nif (annotation == null) {\nString name = fieldNamingPolicy.translateName(f);\nreturn Collections.singletonList(name);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\nClass<? super T> raw = type.getRawType();\nif (!Object.class.isAssignableFrom(raw)) {\nObjectConstructor<T> constructor = constructorConstructor.get(type);\nreturn new Adapter<T>(constructor, getBoundFields(gson, type, raw));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:createBoundField(Lcom/google/gson/Gson;Ljava/lang/reflect/Field;Ljava/lang/String;Lcom/google/gson/reflect/TypeToken;ZZ)Lcom/google/gson/internal/bind/ReflectiveTypeAdapterFactory$BoundField;",
                                    "method_body": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(\nfinal boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\nJsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\nTypeAdapter<?> mapped = null;\nif (annotation != null) {\nfinal boolean jsonAdapterPresent = mapped != null;\nif (mapped == null) mapped = context.getAdapter(fieldType);\nfinal TypeAdapter<?> typeAdapter = mapped;\nreturn new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getBoundFields(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;Ljava/lang/Class;)Ljava/util/Map;",
                                    "method_body": "private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {\nMap<String, BoundField> result = new LinkedHashMap<String, BoundField>();\nif (raw.isInterface()) {\nreturn result;\nType declaredType = type.getType();\nwhile (raw != Object.class) {\nField[] fields = raw.getDeclaredFields();\nfor (Field field : fields) {\nboolean serialize = excludeField(field, true);\nboolean deserialize = excludeField(field, false);\nif (!serialize && !deserialize) {\ncontinue;\nfield.setAccessible(true);\nType fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\nList<String> fieldNames = getFieldNames(field);\nBoundField previous = null;\nfor (int i = 0, size = fieldNames.size(); i < size; ++i) {\nString name = fieldNames.get(i);\nif (i != 0) serialize = false; // only serialize the default name\nBoundField boundField = createBoundField(context, field, name,\nBoundField replaced = result.put(name, boundField);\nif (previous == null) previous = replaced;\nif (previous != null) {\ntype = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\nraw = type.getRawType();\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.UnsafeAllocator:create()Lcom/google/gson/internal/UnsafeAllocator;",
                                    "method_body": "public abstract <T> T newInstance(Class<T> c) throws Exception;\nClass<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\nField f = unsafeClass.getDeclaredField(\"theUnsafe\");\nf.setAccessible(true);\nfinal Object unsafe = f.get(null);\nfinal Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\nreturn new UnsafeAllocator() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson$FutureTypeAdapter:setDelegate(Lcom/google/gson/TypeAdapter;)V",
                                    "method_body": "public void setDelegate(TypeAdapter<T> typeAdapter) {\nif (delegate != null) {\ndelegate = typeAdapter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter:<init>(Lcom/google/gson/internal/ObjectConstructor;Ljava/util/Map;)V",
                                    "method_body": "abstract boolean writeField(Object value) throws IOException, IllegalAccessException;\nAdapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {\nthis.constructor = constructor;\nthis.boundFields = boundFields;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:<clinit>()V",
                                    "method_body": "private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;\nMap<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);\nMap<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);\nadd(primToWrap, wrapToPrim, boolean.class, Boolean.class);\nadd(primToWrap, wrapToPrim, byte.class, Byte.class);\nadd(primToWrap, wrapToPrim, char.class, Character.class);\nadd(primToWrap, wrapToPrim, double.class, Double.class);\nadd(primToWrap, wrapToPrim, float.class, Float.class);\nadd(primToWrap, wrapToPrim, int.class, Integer.class);\nadd(primToWrap, wrapToPrim, long.class, Long.class);\nadd(primToWrap, wrapToPrim, short.class, Short.class);\nadd(primToWrap, wrapToPrim, void.class, Void.class);\nPRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);\nWRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:add(Ljava/util/Map;Ljava/util/Map;Ljava/lang/Class;Ljava/lang/Class;)V",
                                    "method_body": "private static void add(Map<Class<?>, Class<?>> forward,\nforward.put(key, value);\nbackward.put(value, key);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:isPrimitive(Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public static boolean isPrimitive(Type type) {\nreturn PRIMITIVE_TO_WRAPPER_TYPE.containsKey(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$BoundField:<init>(Ljava/lang/String;ZZ)V",
                                    "method_body": "protected BoundField(String name, boolean serialized, boolean deserialized) {\nthis.name = name;\nthis.serialized = serialized;\nthis.deserialized = deserialized;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:equal(Ljava/lang/Object;Ljava/lang/Object;)Z",
                                    "method_body": "static boolean equal(Object a, Object b) {\nreturn a == b || (a != null && a.equals(b));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\ncheckArgument(supertype.isAssignableFrom(contextRawType));\nreturn resolve(context, contextRawType,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getArrayComponentType(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type getArrayComponentType(Type array) {\nreturn array instanceof GenericArrayType\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getCollectionElementType(Ljava/lang/reflect/Type;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type getCollectionElementType(Type context, Class<?> contextRawType) {\nType collectionType = getSupertype(context, contextRawType, Collection.class);\nif (collectionType instanceof WildcardType) {\nif (collectionType instanceof ParameterizedType) {\nreturn ((ParameterizedType) collectionType).getActualTypeArguments()[0];\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$GenericArrayTypeImpl:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "public GenericArrayTypeImpl(Type componentType) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<init>(Lcom/google/gson/Gson;Lcom/google/gson/TypeAdapter;Ljava/lang/Class;)V",
                                    "method_body": "public ArrayTypeAdapter(Gson context, TypeAdapter<E> componentTypeAdapter, Class<E> componentType) {\nthis.componentTypeAdapter =\nthis.componentType = componentType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:<init>(Lcom/google/gson/Gson;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeAdapterRuntimeTypeWrapper(Gson context, TypeAdapter<T> delegate, Type type) {\nthis.context = context;\nthis.delegate = delegate;\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory$Adapter:<init>(Lcom/google/gson/Gson;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Lcom/google/gson/internal/ObjectConstructor;)V",
                                    "method_body": "public Adapter(Gson context, Type elementType,\nObjectConstructor<? extends Collection<E>> constructor) {\nthis.elementTypeAdapter =\nthis.constructor = constructor;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.internal.bind.RecursiveTypesResolveTest.testRecursiveResolveSimple",
                            "test_body": "48: public void testRecursiveResolveSimple() {\n49: TypeAdapter<Foo1> adapter = new Gson().getAdapter(Foo1.class);\n50: assertNotNull(adapter);\n51: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:supertypeOf(Ljava/lang/reflect/Type;)Ljava/lang/reflect/WildcardType;",
                                    "method_body": "public static WildcardType supertypeOf(Type bound) {\nlowerBounds = new Type[] { bound };\nreturn new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\n} else if (type instanceof GenericArrayType) {\n} else if (type instanceof WildcardType) {\nWildcardType w = (WildcardType) type;\nreturn new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$WildcardTypeImpl:<init>([Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/Class;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static <T> TypeToken<T> get(Class<T> type) {\nreturn new TypeToken<T>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:newParameterizedTypeWithOwner(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)Ljava/lang/reflect/ParameterizedType;",
                                    "method_body": "public static ParameterizedType newParameterizedTypeWithOwner(\nreturn new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:hashCodeOrZero(Ljava/lang/Object;)I",
                                    "method_body": "static int hashCodeOrZero(Object o) {\nreturn o != null ? o.hashCode() : 0;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getGenericSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\nif (toResolve == rawType) {\nreturn context;\nif (toResolve.isInterface()) {\nClass<?>[] interfaces = rawType.getInterfaces();\nfor (int i = 0, length = interfaces.length; i < length; i++) {\nif (interfaces[i] == toResolve) {\nreturn rawType.getGenericInterfaces()[i];\nif (!rawType.isInterface()) {\nwhile (rawType != Object.class) {\nClass<?> rawSupertype = rawType.getSuperclass();\nif (rawSupertype == toResolve) {\n} else if (toResolve.isAssignableFrom(rawSupertype)) {\nrawType = rawSupertype;\n}\nreturn toResolve;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolveTypeVariable(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/TypeVariable;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\nClass<?> declaredByRaw = declaringClassOf(unknown);\nif (declaredByRaw == null) {\nType declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\nif (declaredBy instanceof ParameterizedType) {\nint index = indexOf(declaredByRaw.getTypeParameters(), unknown);\nreturn ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\nreturn unknown;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:indexOf([Ljava/lang/Object;Ljava/lang/Object;)I",
                                    "method_body": "private static int indexOf(Object[] array, Object toFind) {\nfor (int i = 0, length = array.length; i < length; i++) {\nif (toFind.equals(array[i])) {\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:declaringClassOf(Ljava/lang/reflect/TypeVariable;)Ljava/lang/Class;",
                                    "method_body": "private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\nGenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\nreturn genericDeclaration instanceof Class\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$ParameterizedTypeImpl:<init>(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory CALENDAR_FACTORY =\npublic static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:nullSafe()Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public final TypeAdapter<T> nullSafe() {\nreturn new TypeAdapter<T>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$35:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$26:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$34:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$30:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nif (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.excluder = excluder;\nthis.fieldNamingStrategy = fieldNamingStrategy;\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nthis.lenient = lenient;\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\nfactories.add(excluder);\nfactories.addAll(typeAdapterFactories);\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nTypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\nfactories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\nfactories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.CURRENCY_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nthis.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);\nfactories.add(jsonAdapterFactory);\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<clinit>()V",
                                    "method_body": "static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\nprivate static final TypeToken<?> NULL_KEY_SURROGATE = TypeToken.get(Object.class);\nprivate final ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>> calls\nprivate final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache = new ConcurrentHashMap<TypeToken<?>, TypeAdapter<?>>();\n*   {@link GsonBuilder#setPrettyPrinting()}. </li>"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLong>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongArrayAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLongArray>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Ljava/lang/Class;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(Class<T> type) {\nreturn getAdapter(TypeToken.get(type));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<init>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nif (isAnonymousOrLocal(clazz)) {\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.FieldNamingPolicy$1:translateName(Ljava/lang/reflect/Field;)Ljava/lang/String;",
                                    "method_body": "@Override public String translateName(Field f) {\nreturn f.getName();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nfinal InstanceCreator<T> rawTypeCreator =\nif (rawTypeCreator != null) {\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nreturn defaultConstructor;\nObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\nif (defaultImplementation != null) {\nreturn defaultImplementation;\nreturn newUnsafeAllocator(type, rawType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\nreturn null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == java.sql.Date.class\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\nClass<? super T> rawType = targetType.getRawType();\nJsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);\nif (annotation == null) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;Lcom/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nJsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\nthis.jsonAdapterFactory = jsonAdapterFactory;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field f, boolean serialize) {\nreturn excludeField(f, serialize, excluder);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;ZLcom/google/gson/internal/Excluder;)Z",
                                    "method_body": "static boolean excludeField(Field f, boolean serialize, Excluder excluder) {\nreturn !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getFieldNames(Ljava/lang/reflect/Field;)Ljava/util/List;",
                                    "method_body": "private List<String> getFieldNames(Field f) {\nSerializedName annotation = f.getAnnotation(SerializedName.class);\nif (annotation == null) {\nString name = fieldNamingPolicy.translateName(f);\nreturn Collections.singletonList(name);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\nClass<? super T> raw = type.getRawType();\nif (!Object.class.isAssignableFrom(raw)) {\nObjectConstructor<T> constructor = constructorConstructor.get(type);\nreturn new Adapter<T>(constructor, getBoundFields(gson, type, raw));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:createBoundField(Lcom/google/gson/Gson;Ljava/lang/reflect/Field;Ljava/lang/String;Lcom/google/gson/reflect/TypeToken;ZZ)Lcom/google/gson/internal/bind/ReflectiveTypeAdapterFactory$BoundField;",
                                    "method_body": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(\nfinal boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\nJsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\nTypeAdapter<?> mapped = null;\nif (annotation != null) {\nfinal boolean jsonAdapterPresent = mapped != null;\nif (mapped == null) mapped = context.getAdapter(fieldType);\nfinal TypeAdapter<?> typeAdapter = mapped;\nreturn new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:<clinit>()V",
                                    "method_body": "private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;\nMap<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);\nMap<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);\nadd(primToWrap, wrapToPrim, boolean.class, Boolean.class);\nadd(primToWrap, wrapToPrim, byte.class, Byte.class);\nadd(primToWrap, wrapToPrim, char.class, Character.class);\nadd(primToWrap, wrapToPrim, double.class, Double.class);\nadd(primToWrap, wrapToPrim, float.class, Float.class);\nadd(primToWrap, wrapToPrim, int.class, Integer.class);\nadd(primToWrap, wrapToPrim, long.class, Long.class);\nadd(primToWrap, wrapToPrim, short.class, Short.class);\nadd(primToWrap, wrapToPrim, void.class, Void.class);\nPRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);\nWRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:add(Ljava/util/Map;Ljava/util/Map;Ljava/lang/Class;Ljava/lang/Class;)V",
                                    "method_body": "private static void add(Map<Class<?>, Class<?>> forward,\nforward.put(key, value);\nbackward.put(value, key);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:isPrimitive(Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public static boolean isPrimitive(Type type) {\nreturn PRIMITIVE_TO_WRAPPER_TYPE.containsKey(type);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.internal.bind.RecursiveTypesResolveTest.testDoubleSupertype",
                            "test_body": "70: public void testDoubleSupertype() {\n71: assertEquals($Gson$Types.supertypeOf(Number.class),\n72: $Gson$Types.supertypeOf($Gson$Types.supertypeOf(Number.class)));\n73: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:supertypeOf(Ljava/lang/reflect/Type;)Ljava/lang/reflect/WildcardType;",
                                    "method_body": "public static WildcardType supertypeOf(Type bound) {\nlowerBounds = new Type[] { bound };\nreturn new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:equals(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public static boolean equals(Type a, Type b) {\nif (a == b) {\nreturn true;\n} else if (a instanceof Class) {\nreturn a.equals(b);\n} else if (a instanceof ParameterizedType) {\nif (!(b instanceof ParameterizedType)) {\nParameterizedType pa = (ParameterizedType) a;\nParameterizedType pb = (ParameterizedType) b;\nreturn equal(pa.getOwnerType(), pb.getOwnerType())\n} else if (a instanceof GenericArrayType) {\nif (!(b instanceof GenericArrayType)) {\nreturn false;\nGenericArrayType ga = (GenericArrayType) a;\nGenericArrayType gb = (GenericArrayType) b;\nreturn equals(ga.getGenericComponentType(), gb.getGenericComponentType());\n} else if (a instanceof WildcardType) {\nif (!(b instanceof WildcardType)) {\nWildcardType wa = (WildcardType) a;\nWildcardType wb = (WildcardType) b;\nreturn Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:typeToString(Ljava/lang/reflect/Type;)Ljava/lang/String;",
                                    "method_body": "public static String typeToString(Type type) {\nreturn type instanceof Class ? ((Class<?>) type).getName() : type.toString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$WildcardTypeImpl:<init>([Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.internal.bind.RecursiveTypesResolveTest.testSubSupertype",
                            "test_body": "85: public void testSubSupertype() {\n86: assertEquals($Gson$Types.subtypeOf(Object.class),\n87: $Gson$Types.subtypeOf($Gson$Types.supertypeOf(Number.class)));\n88: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:supertypeOf(Ljava/lang/reflect/Type;)Ljava/lang/reflect/WildcardType;",
                                    "method_body": "public static WildcardType supertypeOf(Type bound) {\nlowerBounds = new Type[] { bound };\nreturn new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:equals(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public static boolean equals(Type a, Type b) {\nif (a == b) {\nreturn true;\n} else if (a instanceof Class) {\nreturn a.equals(b);\n} else if (a instanceof ParameterizedType) {\nif (!(b instanceof ParameterizedType)) {\nParameterizedType pa = (ParameterizedType) a;\nParameterizedType pb = (ParameterizedType) b;\nreturn equal(pa.getOwnerType(), pb.getOwnerType())\n} else if (a instanceof GenericArrayType) {\nif (!(b instanceof GenericArrayType)) {\nreturn false;\nGenericArrayType ga = (GenericArrayType) a;\nGenericArrayType gb = (GenericArrayType) b;\nreturn equals(ga.getGenericComponentType(), gb.getGenericComponentType());\n} else if (a instanceof WildcardType) {\nif (!(b instanceof WildcardType)) {\nWildcardType wa = (WildcardType) a;\nWildcardType wb = (WildcardType) b;\nreturn Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:typeToString(Ljava/lang/reflect/Type;)Ljava/lang/String;",
                                    "method_body": "public static String typeToString(Type type) {\nreturn type instanceof Class ? ((Class<?>) type).getName() : type.toString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$WildcardTypeImpl:<init>([Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:subtypeOf(Ljava/lang/reflect/Type;)Ljava/lang/reflect/WildcardType;",
                                    "method_body": "public static WildcardType subtypeOf(Type bound) {\nupperBounds = new Type[] { bound };\nreturn new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.internal.bind.RecursiveTypesResolveTest.testIssue440WeakReference",
                            "test_body": "61: public void testIssue440WeakReference() throws Exception {\n62: TypeAdapter<WeakReference> adapter = new Gson().getAdapter(WeakReference.class);\n63: assertNotNull(adapter);\n64: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:supertypeOf(Ljava/lang/reflect/Type;)Ljava/lang/reflect/WildcardType;",
                                    "method_body": "public static WildcardType supertypeOf(Type bound) {\nlowerBounds = new Type[] { bound };\nreturn new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\n} else if (type instanceof GenericArrayType) {\n} else if (type instanceof WildcardType) {\nWildcardType w = (WildcardType) type;\nreturn new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$WildcardTypeImpl:<init>([Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:equals(Ljava/lang/Object;)Z",
                                    "method_body": "@Override public final boolean equals(Object o) {\nreturn o instanceof TypeToken<?>\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/Class;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static <T> TypeToken<T> get(Class<T> type) {\nreturn new TypeToken<T>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:newParameterizedTypeWithOwner(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)Ljava/lang/reflect/ParameterizedType;",
                                    "method_body": "public static ParameterizedType newParameterizedTypeWithOwner(\nreturn new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:subtypeOf(Ljava/lang/reflect/Type;)Ljava/lang/reflect/WildcardType;",
                                    "method_body": "public static WildcardType subtypeOf(Type bound) {\nupperBounds = new Type[] { bound };\nreturn new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:hashCodeOrZero(Ljava/lang/Object;)I",
                                    "method_body": "static int hashCodeOrZero(Object o) {\nreturn o != null ? o.hashCode() : 0;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getGenericSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\nif (toResolve == rawType) {\nreturn context;\nif (toResolve.isInterface()) {\nClass<?>[] interfaces = rawType.getInterfaces();\nfor (int i = 0, length = interfaces.length; i < length; i++) {\nif (interfaces[i] == toResolve) {\nreturn rawType.getGenericInterfaces()[i];\nif (!rawType.isInterface()) {\nwhile (rawType != Object.class) {\nClass<?> rawSupertype = rawType.getSuperclass();\nif (rawSupertype == toResolve) {\n} else if (toResolve.isAssignableFrom(rawSupertype)) {\nrawType = rawSupertype;\n}\nreturn toResolve;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolveTypeVariable(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/TypeVariable;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\nClass<?> declaredByRaw = declaringClassOf(unknown);\nif (declaredByRaw == null) {\nType declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\nif (declaredBy instanceof ParameterizedType) {\nint index = indexOf(declaredByRaw.getTypeParameters(), unknown);\nreturn ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\nreturn unknown;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:indexOf([Ljava/lang/Object;Ljava/lang/Object;)I",
                                    "method_body": "private static int indexOf(Object[] array, Object toFind) {\nfor (int i = 0, length = array.length; i < length; i++) {\nif (toFind.equals(array[i])) {\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:declaringClassOf(Ljava/lang/reflect/TypeVariable;)Ljava/lang/Class;",
                                    "method_body": "private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\nGenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\nreturn genericDeclaration instanceof Class\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$ParameterizedTypeImpl:<init>(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory CALENDAR_FACTORY =\npublic static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:nullSafe()Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public final TypeAdapter<T> nullSafe() {\nreturn new TypeAdapter<T>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$35:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$26:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$34:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$30:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nif (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.excluder = excluder;\nthis.fieldNamingStrategy = fieldNamingStrategy;\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nthis.lenient = lenient;\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\nfactories.add(excluder);\nfactories.addAll(typeAdapterFactories);\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nTypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\nfactories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\nfactories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.CURRENCY_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nthis.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);\nfactories.add(jsonAdapterFactory);\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<clinit>()V",
                                    "method_body": "static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\nprivate static final TypeToken<?> NULL_KEY_SURROGATE = TypeToken.get(Object.class);\nprivate final ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>> calls\nprivate final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache = new ConcurrentHashMap<TypeToken<?>, TypeAdapter<?>>();\n*   {@link GsonBuilder#setPrettyPrinting()}. </li>"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLong>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongArrayAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLongArray>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);\nif (cached != null) {\nreturn (TypeAdapter<T>) cached;\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nreturn ongoingCall;\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\n}\nthreadCalls.remove(type);\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Ljava/lang/Class;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(Class<T> type) {\nreturn getAdapter(TypeToken.get(type));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<init>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field field, boolean serialize) {\nif ((modifiers & field.getModifiers()) != 0) {\nreturn true;\nif (version != Excluder.IGNORE_VERSIONS\nif (field.isSynthetic()) {\nif (requireExpose) {\nif (!serializeInnerClasses && isInnerClass(field.getType())) {\nif (isAnonymousOrLocal(field.getType())) {\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nif (!list.isEmpty()) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nif (isAnonymousOrLocal(clazz)) {\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.FieldNamingPolicy$1:translateName(Ljava/lang/reflect/Field;)Ljava/lang/String;",
                                    "method_body": "@Override public String translateName(Field f) {\nreturn f.getName();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nfinal InstanceCreator<T> rawTypeCreator =\nif (rawTypeCreator != null) {\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nreturn defaultConstructor;\nObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\nif (defaultImplementation != null) {\nreturn defaultImplementation;\nreturn newUnsafeAllocator(type, rawType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultConstructor(Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\nreturn new ObjectConstructor<T>() {\n} catch (NoSuchMethodException e) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newUnsafeAllocator(Ljava/lang/reflect/Type;Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newUnsafeAllocator(\nreturn new ObjectConstructor<T>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<init>(Lcom/google/gson/Gson;)V",
                                    "method_body": "ObjectTypeAdapter(Gson gson) {\nthis.gson = gson;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\nreturn null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == java.sql.Date.class\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\nClass<? super T> rawType = targetType.getRawType();\nJsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);\nif (annotation == null) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;Lcom/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nJsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\nthis.jsonAdapterFactory = jsonAdapterFactory;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field f, boolean serialize) {\nreturn excludeField(f, serialize, excluder);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;ZLcom/google/gson/internal/Excluder;)Z",
                                    "method_body": "static boolean excludeField(Field f, boolean serialize, Excluder excluder) {\nreturn !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getFieldNames(Ljava/lang/reflect/Field;)Ljava/util/List;",
                                    "method_body": "private List<String> getFieldNames(Field f) {\nSerializedName annotation = f.getAnnotation(SerializedName.class);\nif (annotation == null) {\nString name = fieldNamingPolicy.translateName(f);\nreturn Collections.singletonList(name);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\nClass<? super T> raw = type.getRawType();\nif (!Object.class.isAssignableFrom(raw)) {\nObjectConstructor<T> constructor = constructorConstructor.get(type);\nreturn new Adapter<T>(constructor, getBoundFields(gson, type, raw));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:createBoundField(Lcom/google/gson/Gson;Ljava/lang/reflect/Field;Ljava/lang/String;Lcom/google/gson/reflect/TypeToken;ZZ)Lcom/google/gson/internal/bind/ReflectiveTypeAdapterFactory$BoundField;",
                                    "method_body": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(\nfinal boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\nJsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\nTypeAdapter<?> mapped = null;\nif (annotation != null) {\nfinal boolean jsonAdapterPresent = mapped != null;\nif (mapped == null) mapped = context.getAdapter(fieldType);\nfinal TypeAdapter<?> typeAdapter = mapped;\nreturn new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getBoundFields(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;Ljava/lang/Class;)Ljava/util/Map;",
                                    "method_body": "private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {\nMap<String, BoundField> result = new LinkedHashMap<String, BoundField>();\nif (raw.isInterface()) {\nreturn result;\nType declaredType = type.getType();\nwhile (raw != Object.class) {\nField[] fields = raw.getDeclaredFields();\nfor (Field field : fields) {\nboolean serialize = excludeField(field, true);\nboolean deserialize = excludeField(field, false);\nif (!serialize && !deserialize) {\ncontinue;\nfield.setAccessible(true);\nType fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\nList<String> fieldNames = getFieldNames(field);\nBoundField previous = null;\nfor (int i = 0, size = fieldNames.size(); i < size; ++i) {\nString name = fieldNames.get(i);\nif (i != 0) serialize = false; // only serialize the default name\nBoundField boundField = createBoundField(context, field, name,\nBoundField replaced = result.put(name, boundField);\nif (previous == null) previous = replaced;\nif (previous != null) {\ntype = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\nraw = type.getRawType();\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.UnsafeAllocator:create()Lcom/google/gson/internal/UnsafeAllocator;",
                                    "method_body": "public abstract <T> T newInstance(Class<T> c) throws Exception;\nClass<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\nField f = unsafeClass.getDeclaredField(\"theUnsafe\");\nf.setAccessible(true);\nfinal Object unsafe = f.get(null);\nfinal Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\nreturn new UnsafeAllocator() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson$FutureTypeAdapter:setDelegate(Lcom/google/gson/TypeAdapter;)V",
                                    "method_body": "public void setDelegate(TypeAdapter<T> typeAdapter) {\nif (delegate != null) {\ndelegate = typeAdapter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter:<init>(Lcom/google/gson/internal/ObjectConstructor;Ljava/util/Map;)V",
                                    "method_body": "abstract boolean writeField(Object value) throws IOException, IllegalAccessException;\nAdapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {\nthis.constructor = constructor;\nthis.boundFields = boundFields;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:<clinit>()V",
                                    "method_body": "private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;\nMap<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);\nMap<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);\nadd(primToWrap, wrapToPrim, boolean.class, Boolean.class);\nadd(primToWrap, wrapToPrim, byte.class, Byte.class);\nadd(primToWrap, wrapToPrim, char.class, Character.class);\nadd(primToWrap, wrapToPrim, double.class, Double.class);\nadd(primToWrap, wrapToPrim, float.class, Float.class);\nadd(primToWrap, wrapToPrim, int.class, Integer.class);\nadd(primToWrap, wrapToPrim, long.class, Long.class);\nadd(primToWrap, wrapToPrim, short.class, Short.class);\nadd(primToWrap, wrapToPrim, void.class, Void.class);\nPRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);\nWRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:add(Ljava/util/Map;Ljava/util/Map;Ljava/lang/Class;Ljava/lang/Class;)V",
                                    "method_body": "private static void add(Map<Class<?>, Class<?>> forward,\nforward.put(key, value);\nbackward.put(value, key);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:isPrimitive(Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public static boolean isPrimitive(Type type) {\nreturn PRIMITIVE_TO_WRAPPER_TYPE.containsKey(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$BoundField:<init>(Ljava/lang/String;ZZ)V",
                                    "method_body": "protected BoundField(String name, boolean serialized, boolean deserialized) {\nthis.name = name;\nthis.serialized = serialized;\nthis.deserialized = deserialized;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.internal.bind.RecursiveTypesResolveTest.testDoubleSubtype",
                            "test_body": "75: public void testDoubleSubtype() {\n76: assertEquals($Gson$Types.subtypeOf(Number.class),\n77: $Gson$Types.subtypeOf($Gson$Types.subtypeOf(Number.class)));\n78: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:equals(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public static boolean equals(Type a, Type b) {\nif (a == b) {\nreturn true;\n} else if (a instanceof Class) {\nreturn a.equals(b);\n} else if (a instanceof ParameterizedType) {\nif (!(b instanceof ParameterizedType)) {\nParameterizedType pa = (ParameterizedType) a;\nParameterizedType pb = (ParameterizedType) b;\nreturn equal(pa.getOwnerType(), pb.getOwnerType())\n} else if (a instanceof GenericArrayType) {\nif (!(b instanceof GenericArrayType)) {\nreturn false;\nGenericArrayType ga = (GenericArrayType) a;\nGenericArrayType gb = (GenericArrayType) b;\nreturn equals(ga.getGenericComponentType(), gb.getGenericComponentType());\n} else if (a instanceof WildcardType) {\nif (!(b instanceof WildcardType)) {\nWildcardType wa = (WildcardType) a;\nWildcardType wb = (WildcardType) b;\nreturn Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:typeToString(Ljava/lang/reflect/Type;)Ljava/lang/String;",
                                    "method_body": "public static String typeToString(Type type) {\nreturn type instanceof Class ? ((Class<?>) type).getName() : type.toString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:subtypeOf(Ljava/lang/reflect/Type;)Ljava/lang/reflect/WildcardType;",
                                    "method_body": "public static WildcardType subtypeOf(Type bound) {\nupperBounds = new Type[] { bound };\nreturn new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 15,
                    "tests": [
                        {
                            "test_name": "com.google.gson.stream.JsonWriterTest.testNonFiniteDoublesWhenLenient",
                            "test_body": "217: public void testNonFiniteDoublesWhenLenient() throws IOException {\n218: StringWriter stringWriter = new StringWriter();\n219: JsonWriter jsonWriter = new JsonWriter(stringWriter);\n220: jsonWriter.setLenient(true);\n221: jsonWriter.beginArray();\n222: jsonWriter.value(Double.NaN);\n223: jsonWriter.value(Double.NEGATIVE_INFINITY);\n224: jsonWriter.value(Double.POSITIVE_INFINITY);\n225: jsonWriter.endArray();\n226: assertEquals(\"[NaN,-Infinity,Infinity]\", stringWriter.toString());\n227: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:<init>(Ljava/io/Writer;)V",
                                    "method_body": "private final Writer out;\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\npush(EMPTY_DOCUMENT);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:<clinit>()V",
                                    "method_body": "private static final String[] REPLACEMENT_CHARS;\nREPLACEMENT_CHARS = new String[128];\nfor (int i = 0; i <= 0x1f; i++) {\nREPLACEMENT_CHARS[i] = String.format(\"\\\\u%04x\", (int) i);\nREPLACEMENT_CHARS['\"'] = \"\\\\\\\"\";\nREPLACEMENT_CHARS['\\\\'] = \"\\\\\\\\\";\nREPLACEMENT_CHARS['\\t'] = \"\\\\t\";\nREPLACEMENT_CHARS['\\b'] = \"\\\\b\";\nREPLACEMENT_CHARS['\\n'] = \"\\\\n\";\nREPLACEMENT_CHARS['\\r'] = \"\\\\r\";\nREPLACEMENT_CHARS['\\f'] = \"\\\\f\";\nHTML_SAFE_REPLACEMENT_CHARS = REPLACEMENT_CHARS.clone();\nHTML_SAFE_REPLACEMENT_CHARS['<'] = \"\\\\u003c\";\nHTML_SAFE_REPLACEMENT_CHARS['>'] = \"\\\\u003e\";\nHTML_SAFE_REPLACEMENT_CHARS['&'] = \"\\\\u0026\";\nHTML_SAFE_REPLACEMENT_CHARS['='] = \"\\\\u003d\";\nHTML_SAFE_REPLACEMENT_CHARS['\\''] = \"\\\\u0027\";\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:setLenient(Z)V",
                                    "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:beginArray()Lcom/google/gson/stream/JsonWriter;",
                                    "method_body": "public JsonWriter beginArray() throws IOException {\nwriteDeferredName();\nreturn open(EMPTY_ARRAY, \"[\");\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:open(ILjava/lang/String;)Lcom/google/gson/stream/JsonWriter;",
                                    "method_body": "private JsonWriter open(int empty, String openBracket) throws IOException {\nbeforeValue();\npush(empty);\nout.write(openBracket);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:push(I)V",
                                    "method_body": "private void push(int newTop) {\nif (stackSize == stack.length) {\nstack[stackSize++] = newTop;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:peek()I",
                                    "method_body": "private int peek() {\nif (stackSize == 0) {\nreturn stack[stackSize - 1];\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:replaceTop(I)V",
                                    "method_body": "private void replaceTop(int topOfStack) {\nstack[stackSize - 1] = topOfStack;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:writeDeferredName()V",
                                    "method_body": "private void writeDeferredName() throws IOException {\nif (deferredName != null) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:value(D)Lcom/google/gson/stream/JsonWriter;",
                                    "method_body": "public JsonWriter value(double value) throws IOException {\nwriteDeferredName();\nif (Double.isNaN(value) || Double.isInfinite(value)) {\nthrow new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:beforeValue()V",
                                    "method_body": "private void beforeValue() throws IOException {\nswitch (peek()) {\nreplaceTop(NONEMPTY_DOCUMENT);\nbreak;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 16,
                    "tests": [
                        {
                            "test_name": "com.google.gson.internal.bind.RecursiveTypesResolveTest.testRecursiveTypeVariablesResolve12",
                            "test_body": "107: public void testRecursiveTypeVariablesResolve12() throws Exception {\n108: TypeAdapter<TestType2> adapter = new Gson().getAdapter(TestType2.class);\n109: assertNotNull(adapter);\n110: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/Class;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static <T> TypeToken<T> get(Class<T> type) {\nreturn new TypeToken<T>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\n} else if (type instanceof GenericArrayType) {\n} else if (type instanceof WildcardType) {\nWildcardType w = (WildcardType) type;\nreturn new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\nreturn (Class<?>) type;\n} else if (type instanceof ParameterizedType) {\nParameterizedType parameterizedType = (ParameterizedType) type;\nType rawType = parameterizedType.getRawType();\ncheckArgument(rawType instanceof Class);\nreturn (Class<?>) rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:hashCodeOrZero(Ljava/lang/Object;)I",
                                    "method_body": "static int hashCodeOrZero(Object o) {\nreturn o != null ? o.hashCode() : 0;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getGenericSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\nif (toResolve == rawType) {\nreturn context;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\nreturn resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;Ljava/util/Collection;)Ljava/lang/reflect/Type;",
                                    "method_body": "private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,\nif (toResolve instanceof TypeVariable) {\nTypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\ntoResolve = resolveTypeVariable(context, contextRawType, typeVariable);\nif (toResolve == typeVariable) {\nreturn toResolve;\n} else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n} else if (toResolve instanceof GenericArrayType) {\n} else if (toResolve instanceof ParameterizedType) {\nParameterizedType original = (ParameterizedType) toResolve;\nType ownerType = original.getOwnerType();\nType newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\nboolean changed = newOwnerType != ownerType;\nType[] args = original.getActualTypeArguments();\nfor (int t = 0, length = args.length; t < length; t++) {\nType resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\nif (resolvedTypeArgument != args[t]) {\nreturn changed\n} else if (toResolve instanceof WildcardType) {\nWildcardType original = (WildcardType) toResolve;\nType[] originalLowerBound = original.getLowerBounds();\nType[] originalUpperBound = original.getUpperBounds();\nif (originalLowerBound.length == 1) {\nType lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\nif (lowerBound != originalLowerBound[0]) {\n} else if (originalUpperBound.length == 1) {\nreturn original;\nreturn toResolve;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolveTypeVariable(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/TypeVariable;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\nClass<?> declaredByRaw = declaringClassOf(unknown);\nif (declaredByRaw == null) {\nType declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\nif (declaredBy instanceof ParameterizedType) {\nint index = indexOf(declaredByRaw.getTypeParameters(), unknown);\nreturn ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\nreturn unknown;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:indexOf([Ljava/lang/Object;Ljava/lang/Object;)I",
                                    "method_body": "private static int indexOf(Object[] array, Object toFind) {\nfor (int i = 0, length = array.length; i < length; i++) {\nif (toFind.equals(array[i])) {\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:declaringClassOf(Ljava/lang/reflect/TypeVariable;)Ljava/lang/Class;",
                                    "method_body": "private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\nGenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\nreturn genericDeclaration instanceof Class\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$ParameterizedTypeImpl:<init>(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$WildcardTypeImpl:<init>([Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n}.nullSafe();"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:nullSafe()Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public final TypeAdapter<T> nullSafe() {\nreturn new TypeAdapter<T>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$35:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$26:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$34:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$30:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nif (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.excluder = excluder;\nthis.fieldNamingStrategy = fieldNamingStrategy;\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nthis.lenient = lenient;\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\nfactories.add(excluder);\nfactories.addAll(typeAdapterFactories);\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nTypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\nfactories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\nfactories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.CURRENCY_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nthis.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);\nfactories.add(jsonAdapterFactory);\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<clinit>()V",
                                    "method_body": "static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\nprivate static final TypeToken<?> NULL_KEY_SURROGATE = TypeToken.get(Object.class);\nprivate final ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>> calls\nprivate final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache = new ConcurrentHashMap<TypeToken<?>, TypeAdapter<?>>();\n*   {@link GsonBuilder#setPrettyPrinting()}. </li>"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLong>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongArrayAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLongArray>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);\nif (cached != null) {\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\n}\nthreadCalls.remove(type);\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Ljava/lang/Class;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(Class<T> type) {\nreturn getAdapter(TypeToken.get(type));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<init>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field field, boolean serialize) {\nif ((modifiers & field.getModifiers()) != 0) {\nif (version != Excluder.IGNORE_VERSIONS\nif (field.isSynthetic()) {\nif (requireExpose) {\nif (!serializeInnerClasses && isInnerClass(field.getType())) {\nif (isAnonymousOrLocal(field.getType())) {\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nif (!list.isEmpty()) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nif (isAnonymousOrLocal(clazz)) {\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.FieldNamingPolicy$1:translateName(Ljava/lang/reflect/Field;)Ljava/lang/String;",
                                    "method_body": "@Override public String translateName(Field f) {\nreturn f.getName();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nfinal InstanceCreator<T> rawTypeCreator =\nif (rawTypeCreator != null) {\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nreturn defaultConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultConstructor(Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\nreturn new ObjectConstructor<T>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nif (type.getRawType() == Object.class) {\nreturn null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == java.sql.Date.class\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\nClass<? super T> rawType = targetType.getRawType();\nJsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);\nif (annotation == null) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;Lcom/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nJsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\nthis.jsonAdapterFactory = jsonAdapterFactory;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field f, boolean serialize) {\nreturn excludeField(f, serialize, excluder);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;ZLcom/google/gson/internal/Excluder;)Z",
                                    "method_body": "static boolean excludeField(Field f, boolean serialize, Excluder excluder) {\nreturn !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getFieldNames(Ljava/lang/reflect/Field;)Ljava/util/List;",
                                    "method_body": "private List<String> getFieldNames(Field f) {\nSerializedName annotation = f.getAnnotation(SerializedName.class);\nif (annotation == null) {\nString name = fieldNamingPolicy.translateName(f);\nreturn Collections.singletonList(name);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\nClass<? super T> raw = type.getRawType();\nif (!Object.class.isAssignableFrom(raw)) {\nObjectConstructor<T> constructor = constructorConstructor.get(type);\nreturn new Adapter<T>(constructor, getBoundFields(gson, type, raw));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:createBoundField(Lcom/google/gson/Gson;Ljava/lang/reflect/Field;Ljava/lang/String;Lcom/google/gson/reflect/TypeToken;ZZ)Lcom/google/gson/internal/bind/ReflectiveTypeAdapterFactory$BoundField;",
                                    "method_body": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(\nfinal boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\nJsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\nTypeAdapter<?> mapped = null;\nif (annotation != null) {\nfinal boolean jsonAdapterPresent = mapped != null;\nif (mapped == null) mapped = context.getAdapter(fieldType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getBoundFields(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;Ljava/lang/Class;)Ljava/util/Map;",
                                    "method_body": "private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {\nMap<String, BoundField> result = new LinkedHashMap<String, BoundField>();\nif (raw.isInterface()) {\nType declaredType = type.getType();\nwhile (raw != Object.class) {\nField[] fields = raw.getDeclaredFields();\nfor (Field field : fields) {\nboolean serialize = excludeField(field, true);\nboolean deserialize = excludeField(field, false);\nif (!serialize && !deserialize) {\nfield.setAccessible(true);\nType fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\nList<String> fieldNames = getFieldNames(field);\nBoundField previous = null;\nfor (int i = 0, size = fieldNames.size(); i < size; ++i) {\nString name = fieldNames.get(i);\nif (i != 0) serialize = false; // only serialize the default name\nBoundField boundField = createBoundField(context, field, name,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:<clinit>()V",
                                    "method_body": "private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;\nMap<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);\nMap<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);\nadd(primToWrap, wrapToPrim, boolean.class, Boolean.class);\nadd(primToWrap, wrapToPrim, byte.class, Byte.class);\nadd(primToWrap, wrapToPrim, char.class, Character.class);\nadd(primToWrap, wrapToPrim, double.class, Double.class);\nadd(primToWrap, wrapToPrim, float.class, Float.class);\nadd(primToWrap, wrapToPrim, int.class, Integer.class);\nadd(primToWrap, wrapToPrim, long.class, Long.class);\nadd(primToWrap, wrapToPrim, short.class, Short.class);\nadd(primToWrap, wrapToPrim, void.class, Void.class);\nPRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);\nWRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:add(Ljava/util/Map;Ljava/util/Map;Ljava/lang/Class;Ljava/lang/Class;)V",
                                    "method_body": "private static void add(Map<Class<?>, Class<?>> forward,\nforward.put(key, value);\nbackward.put(value, key);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:isPrimitive(Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public static boolean isPrimitive(Type type) {\nreturn PRIMITIVE_TO_WRAPPER_TYPE.containsKey(type);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.internal.bind.RecursiveTypesResolveTest.testRecursiveTypeVariablesResolve1",
                            "test_body": "102: public void testRecursiveTypeVariablesResolve1() throws Exception {\n103: TypeAdapter<TestType> adapter = new Gson().getAdapter(TestType.class);\n104: assertNotNull(adapter);\n105: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/Class;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static <T> TypeToken<T> get(Class<T> type) {\nreturn new TypeToken<T>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\n} else if (type instanceof GenericArrayType) {\n} else if (type instanceof WildcardType) {\nWildcardType w = (WildcardType) type;\nreturn new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\nreturn (Class<?>) type;\n} else if (type instanceof ParameterizedType) {\nParameterizedType parameterizedType = (ParameterizedType) type;\nType rawType = parameterizedType.getRawType();\ncheckArgument(rawType instanceof Class);\nreturn (Class<?>) rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:hashCodeOrZero(Ljava/lang/Object;)I",
                                    "method_body": "static int hashCodeOrZero(Object o) {\nreturn o != null ? o.hashCode() : 0;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getGenericSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\nif (toResolve == rawType) {\nreturn context;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\nreturn resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;Ljava/util/Collection;)Ljava/lang/reflect/Type;",
                                    "method_body": "private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,\nif (toResolve instanceof TypeVariable) {\nTypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\ntoResolve = resolveTypeVariable(context, contextRawType, typeVariable);\nif (toResolve == typeVariable) {\nreturn toResolve;\n} else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n} else if (toResolve instanceof GenericArrayType) {\n} else if (toResolve instanceof ParameterizedType) {\nParameterizedType original = (ParameterizedType) toResolve;\nType ownerType = original.getOwnerType();\nType newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\nboolean changed = newOwnerType != ownerType;\nType[] args = original.getActualTypeArguments();\nfor (int t = 0, length = args.length; t < length; t++) {\nType resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\nif (resolvedTypeArgument != args[t]) {\nreturn changed\n} else if (toResolve instanceof WildcardType) {\nWildcardType original = (WildcardType) toResolve;\nType[] originalLowerBound = original.getLowerBounds();\nType[] originalUpperBound = original.getUpperBounds();\nif (originalLowerBound.length == 1) {\nType lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\nif (lowerBound != originalLowerBound[0]) {\n} else if (originalUpperBound.length == 1) {\nreturn original;\nreturn toResolve;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolveTypeVariable(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/TypeVariable;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\nClass<?> declaredByRaw = declaringClassOf(unknown);\nif (declaredByRaw == null) {\nType declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\nif (declaredBy instanceof ParameterizedType) {\nint index = indexOf(declaredByRaw.getTypeParameters(), unknown);\nreturn ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\nreturn unknown;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:indexOf([Ljava/lang/Object;Ljava/lang/Object;)I",
                                    "method_body": "private static int indexOf(Object[] array, Object toFind) {\nfor (int i = 0, length = array.length; i < length; i++) {\nif (toFind.equals(array[i])) {\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:declaringClassOf(Ljava/lang/reflect/TypeVariable;)Ljava/lang/Class;",
                                    "method_body": "private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\nGenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\nreturn genericDeclaration instanceof Class\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$ParameterizedTypeImpl:<init>(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$WildcardTypeImpl:<init>([Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n}.nullSafe();"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:nullSafe()Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public final TypeAdapter<T> nullSafe() {\nreturn new TypeAdapter<T>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$35:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$26:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$34:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$30:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nif (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.excluder = excluder;\nthis.fieldNamingStrategy = fieldNamingStrategy;\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nthis.lenient = lenient;\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\nfactories.add(excluder);\nfactories.addAll(typeAdapterFactories);\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nTypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\nfactories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\nfactories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.CURRENCY_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nthis.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);\nfactories.add(jsonAdapterFactory);\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<clinit>()V",
                                    "method_body": "static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\nprivate static final TypeToken<?> NULL_KEY_SURROGATE = TypeToken.get(Object.class);\nprivate final ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>> calls\nprivate final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache = new ConcurrentHashMap<TypeToken<?>, TypeAdapter<?>>();\n*   {@link GsonBuilder#setPrettyPrinting()}. </li>"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLong>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongArrayAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLongArray>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);\nif (cached != null) {\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\n}\nthreadCalls.remove(type);\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Ljava/lang/Class;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(Class<T> type) {\nreturn getAdapter(TypeToken.get(type));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<init>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field field, boolean serialize) {\nif ((modifiers & field.getModifiers()) != 0) {\nif (version != Excluder.IGNORE_VERSIONS\nif (field.isSynthetic()) {\nif (requireExpose) {\nif (!serializeInnerClasses && isInnerClass(field.getType())) {\nif (isAnonymousOrLocal(field.getType())) {\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nif (!list.isEmpty()) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nif (isAnonymousOrLocal(clazz)) {\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.FieldNamingPolicy$1:translateName(Ljava/lang/reflect/Field;)Ljava/lang/String;",
                                    "method_body": "@Override public String translateName(Field f) {\nreturn f.getName();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nfinal InstanceCreator<T> rawTypeCreator =\nif (rawTypeCreator != null) {\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nreturn defaultConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultConstructor(Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\nreturn new ObjectConstructor<T>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nif (type.getRawType() == Object.class) {\nreturn null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == java.sql.Date.class\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\nClass<? super T> rawType = targetType.getRawType();\nJsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);\nif (annotation == null) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;Lcom/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nJsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\nthis.jsonAdapterFactory = jsonAdapterFactory;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field f, boolean serialize) {\nreturn excludeField(f, serialize, excluder);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;ZLcom/google/gson/internal/Excluder;)Z",
                                    "method_body": "static boolean excludeField(Field f, boolean serialize, Excluder excluder) {\nreturn !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getFieldNames(Ljava/lang/reflect/Field;)Ljava/util/List;",
                                    "method_body": "private List<String> getFieldNames(Field f) {\nSerializedName annotation = f.getAnnotation(SerializedName.class);\nif (annotation == null) {\nString name = fieldNamingPolicy.translateName(f);\nreturn Collections.singletonList(name);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\nClass<? super T> raw = type.getRawType();\nif (!Object.class.isAssignableFrom(raw)) {\nObjectConstructor<T> constructor = constructorConstructor.get(type);\nreturn new Adapter<T>(constructor, getBoundFields(gson, type, raw));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:createBoundField(Lcom/google/gson/Gson;Ljava/lang/reflect/Field;Ljava/lang/String;Lcom/google/gson/reflect/TypeToken;ZZ)Lcom/google/gson/internal/bind/ReflectiveTypeAdapterFactory$BoundField;",
                                    "method_body": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(\nfinal boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\nJsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\nTypeAdapter<?> mapped = null;\nif (annotation != null) {\nfinal boolean jsonAdapterPresent = mapped != null;\nif (mapped == null) mapped = context.getAdapter(fieldType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getBoundFields(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;Ljava/lang/Class;)Ljava/util/Map;",
                                    "method_body": "private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {\nMap<String, BoundField> result = new LinkedHashMap<String, BoundField>();\nif (raw.isInterface()) {\nType declaredType = type.getType();\nwhile (raw != Object.class) {\nField[] fields = raw.getDeclaredFields();\nfor (Field field : fields) {\nboolean serialize = excludeField(field, true);\nboolean deserialize = excludeField(field, false);\nif (!serialize && !deserialize) {\nfield.setAccessible(true);\nType fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\nList<String> fieldNames = getFieldNames(field);\nBoundField previous = null;\nfor (int i = 0, size = fieldNames.size(); i < size; ++i) {\nString name = fieldNames.get(i);\nif (i != 0) serialize = false; // only serialize the default name\nBoundField boundField = createBoundField(context, field, name,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:<clinit>()V",
                                    "method_body": "private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;\nMap<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);\nMap<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);\nadd(primToWrap, wrapToPrim, boolean.class, Boolean.class);\nadd(primToWrap, wrapToPrim, byte.class, Byte.class);\nadd(primToWrap, wrapToPrim, char.class, Character.class);\nadd(primToWrap, wrapToPrim, double.class, Double.class);\nadd(primToWrap, wrapToPrim, float.class, Float.class);\nadd(primToWrap, wrapToPrim, int.class, Integer.class);\nadd(primToWrap, wrapToPrim, long.class, Long.class);\nadd(primToWrap, wrapToPrim, short.class, Short.class);\nadd(primToWrap, wrapToPrim, void.class, Void.class);\nPRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);\nWRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:add(Ljava/util/Map;Ljava/util/Map;Ljava/lang/Class;Ljava/lang/Class;)V",
                                    "method_body": "private static void add(Map<Class<?>, Class<?>> forward,\nforward.put(key, value);\nbackward.put(value, key);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:isPrimitive(Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public static boolean isPrimitive(Type type) {\nreturn PRIMITIVE_TO_WRAPPER_TYPE.containsKey(type);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 17,
                    "tests": [
                        {
                            "test_name": "com.google.gson.DefaultDateTypeAdapterTest.testNullValue",
                            "test_body": "164: public void testNullValue() throws Exception {\n165: DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter(Date.class);\n166: assertNull(adapter.fromJson(\"null\"));\n167: assertEquals(\"null\", adapter.toJson(null));\n168: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate boolean lenient = false;\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\nint peeked = PEEKED_NONE;\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\nswitch (p) {\nreturn JsonToken.BEGIN_OBJECT;\nreturn JsonToken.NULL;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit -= pos;\nSystem.arraycopy(buffer, pos, buffer, 0, limit);\nlimit = 0;\npos = 0;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\nif (limit >= minimum) {\nreturn true;\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\np = pos;\nl = limit;\nint c = buffer[p++];\nif (c == '\\n') {\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\nif (c == '/') {\n} else if (c == '#') {\npos = p;\nreturn c;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:fromJson(Ljava/io/Reader;)Ljava/lang/Object;",
                                    "method_body": "public final T fromJson(Reader in) throws IOException {\nJsonReader reader = new JsonReader(in);\nreturn read(reader);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:fromJson(Ljava/lang/String;)Ljava/lang/Object;",
                                    "method_body": "public final T fromJson(String json) throws IOException {\nreturn fromJson(new StringReader(json));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonParseException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public JsonParseException(String msg) {\nsuper(msg);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultDateTypeAdapter:<init>(Ljava/lang/Class;)V",
                                    "method_body": "DefaultDateTypeAdapter(Class<? extends Date> dateType) {\nthis(dateType,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultDateTypeAdapter:<init>(Ljava/lang/Class;Ljava/text/DateFormat;Ljava/text/DateFormat;)V",
                                    "method_body": "DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat) {\nif ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) {\nthis.dateType = dateType;\nthis.enUsFormat = enUsFormat;\nthis.localFormat = localFormat;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultDateTypeAdapter:read(Lcom/google/gson/stream/JsonReader;)Ljava/util/Date;",
                                    "method_body": "public Date read(JsonReader in) throws IOException {\nif (in.peek() != JsonToken.STRING) {\nthrow new JsonParseException(\"The date should be a string value\");\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peekKeyword()I",
                                    "method_body": "private int peekKeyword() throws IOException {\nchar c = buffer[pos];\nif (c == 't' || c == 'T') {\n} else if (c == 'f' || c == 'F') {\n} else if (c == 'n' || c == 'N') {\nkeyword = \"null\";\nkeywordUpper = \"NULL\";\npeeking = PEEKED_NULL;\nint length = keyword.length();\nfor (int i = 1; i < length; i++) {\nif (pos + i >= limit && !fillBuffer(i + 1)) {\nc = buffer[pos + i];\nif (c != keyword.charAt(i) && c != keywordUpper.charAt(i)) {\nif ((pos + length < limit || fillBuffer(length + 1))\npos += length;\nreturn peeked = peeking;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.DefaultDateTypeAdapterTest.testUnexpectedToken",
                            "test_body": "170: public void testUnexpectedToken() throws Exception {\n171: try {\n172: DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter(Date.class);\n173: adapter.fromJson(\"{}\");\n174: fail(\"Unexpected token should fail.\");\n175: } catch (IllegalStateException expected) { }\n176: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate boolean lenient = false;\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\nint peeked = PEEKED_NONE;\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\nswitch (p) {\nreturn JsonToken.BEGIN_OBJECT;\nreturn JsonToken.NULL;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit -= pos;\nSystem.arraycopy(buffer, pos, buffer, 0, limit);\nlimit = 0;\npos = 0;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\nif (limit >= minimum) {\nreturn true;\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\np = pos;\nl = limit;\nint c = buffer[p++];\nif (c == '\\n') {\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\nif (c == '/') {\n} else if (c == '#') {\npos = p;\nreturn c;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:fromJson(Ljava/io/Reader;)Ljava/lang/Object;",
                                    "method_body": "public final T fromJson(Reader in) throws IOException {\nJsonReader reader = new JsonReader(in);\nreturn read(reader);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:fromJson(Ljava/lang/String;)Ljava/lang/Object;",
                                    "method_body": "public final T fromJson(String json) throws IOException {\nreturn fromJson(new StringReader(json));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonParseException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public JsonParseException(String msg) {\nsuper(msg);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultDateTypeAdapter:<init>(Ljava/lang/Class;)V",
                                    "method_body": "DefaultDateTypeAdapter(Class<? extends Date> dateType) {\nthis(dateType,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultDateTypeAdapter:<init>(Ljava/lang/Class;Ljava/text/DateFormat;Ljava/text/DateFormat;)V",
                                    "method_body": "DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat) {\nif ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) {\nthis.dateType = dateType;\nthis.enUsFormat = enUsFormat;\nthis.localFormat = localFormat;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultDateTypeAdapter:read(Lcom/google/gson/stream/JsonReader;)Ljava/util/Date;",
                                    "method_body": "public Date read(JsonReader in) throws IOException {\nif (in.peek() != JsonToken.STRING) {\nthrow new JsonParseException(\"The date should be a string value\");\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 18,
                    "tests": [
                        {
                            "test_name": "com.google.gson.functional.CollectionTest.testIssue1107",
                            "test_body": "401: public void testIssue1107() {\n402: String json = \"{\\n\" +\n403: \"  \\\"inBig\\\": {\\n\" +\n404: \"    \\\"key\\\": [\\n\" +\n405: \"      { \\\"inSmall\\\": \\\"hello\\\" }\\n\" +\n406: \"    ]\\n\" +\n407: \"  }\\n\" +\n408: \"}\";\n409: BigClass bigClass = new Gson().fromJson(json, BigClass.class);\n410: SmallClass small = bigClass.inBig.get(\"key\").get(0);\n411: assertNotNull(small);\n412: assertEquals(\"hello\", small.inSmall);\n413: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/Class;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static <T> TypeToken<T> get(Class<T> type) {\nreturn new TypeToken<T>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\n} else if (type instanceof GenericArrayType) {\n} else if (type instanceof WildcardType) {\nWildcardType w = (WildcardType) type;\nreturn new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\nreturn (Class<?>) type;\n} else if (type instanceof ParameterizedType) {\nParameterizedType parameterizedType = (ParameterizedType) type;\nType rawType = parameterizedType.getRawType();\ncheckArgument(rawType instanceof Class);\nreturn (Class<?>) rawType;\n} else if (type instanceof GenericArrayType) {\n} else if (type instanceof TypeVariable) {\nreturn Object.class;\n} else if (type instanceof WildcardType) {\nreturn getRawType(((WildcardType) type).getUpperBounds()[0]);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:hashCodeOrZero(Ljava/lang/Object;)I",
                                    "method_body": "static int hashCodeOrZero(Object o) {\nreturn o != null ? o.hashCode() : 0;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getGenericSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\nif (toResolve == rawType) {\nreturn context;\nif (toResolve.isInterface()) {\nClass<?>[] interfaces = rawType.getInterfaces();\nfor (int i = 0, length = interfaces.length; i < length; i++) {\nif (interfaces[i] == toResolve) {\nreturn rawType.getGenericInterfaces()[i];\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\ncheckArgument(supertype.isAssignableFrom(contextRawType));\nreturn resolve(context, contextRawType,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getCollectionElementType(Ljava/lang/reflect/Type;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type getCollectionElementType(Type context, Class<?> contextRawType) {\nType collectionType = getSupertype(context, contextRawType, Collection.class);\nif (collectionType instanceof WildcardType) {\nif (collectionType instanceof ParameterizedType) {\nreturn ((ParameterizedType) collectionType).getActualTypeArguments()[0];\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getMapKeyAndValueTypes(Ljava/lang/reflect/Type;Ljava/lang/Class;)[Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {\nif (context == Properties.class) {\nType mapType = getSupertype(context, contextRawType, Map.class);\nif (mapType instanceof ParameterizedType) {\nParameterizedType mapParameterizedType = (ParameterizedType) mapType;\nreturn mapParameterizedType.getActualTypeArguments();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\nreturn resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;Ljava/util/Collection;)Ljava/lang/reflect/Type;",
                                    "method_body": "private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,\nif (toResolve instanceof TypeVariable) {\nTypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\nif (visitedTypeVariables.contains(typeVariable)) {\nvisitedTypeVariables.add(typeVariable);\ntoResolve = resolveTypeVariable(context, contextRawType, typeVariable);\nif (toResolve == typeVariable) {\nreturn toResolve;\n} else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n} else if (toResolve instanceof GenericArrayType) {\n} else if (toResolve instanceof ParameterizedType) {\nParameterizedType original = (ParameterizedType) toResolve;\nType ownerType = original.getOwnerType();\nType newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\nboolean changed = newOwnerType != ownerType;\nType[] args = original.getActualTypeArguments();\nfor (int t = 0, length = args.length; t < length; t++) {\nType resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\nif (resolvedTypeArgument != args[t]) {\nreturn changed\n} else if (toResolve instanceof WildcardType) {\nWildcardType original = (WildcardType) toResolve;\nType[] originalLowerBound = original.getLowerBounds();\nType[] originalUpperBound = original.getUpperBounds();\nif (originalLowerBound.length == 1) {\n} else if (originalUpperBound.length == 1) {\nType upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\nif (upperBound != originalUpperBound[0]) {\nreturn original;\nreturn toResolve;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolveTypeVariable(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/TypeVariable;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\nClass<?> declaredByRaw = declaringClassOf(unknown);\nif (declaredByRaw == null) {\nType declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\nif (declaredBy instanceof ParameterizedType) {\nreturn unknown;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:declaringClassOf(Ljava/lang/reflect/TypeVariable;)Ljava/lang/Class;",
                                    "method_body": "private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\nGenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\nreturn genericDeclaration instanceof Class\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$ParameterizedTypeImpl:<init>(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$WildcardTypeImpl:<init>([Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate boolean lenient = false;\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\nint peeked = PEEKED_NONE;\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:setLenient(Z)V",
                                    "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:isLenient()Z",
                                    "method_body": "public final boolean isLenient() {\nreturn lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:beginArray()V",
                                    "method_body": "public void beginArray() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\nif (p == PEEKED_BEGIN_ARRAY) {\npush(JsonScope.EMPTY_ARRAY);\npathIndices[stackSize - 1] = 0;\npeeked = PEEKED_NONE;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:endArray()V",
                                    "method_body": "public void endArray() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\nif (p == PEEKED_END_ARRAY) {\nstackSize--;\npathIndices[stackSize - 1]++;\npeeked = PEEKED_NONE;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:beginObject()V",
                                    "method_body": "public void beginObject() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\nif (p == PEEKED_BEGIN_OBJECT) {\npush(JsonScope.EMPTY_OBJECT);\npeeked = PEEKED_NONE;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:endObject()V",
                                    "method_body": "public void endObject() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\nif (p == PEEKED_END_OBJECT) {\nstackSize--;\npathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!\npathIndices[stackSize - 1]++;\npeeked = PEEKED_NONE;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:hasNext()Z",
                                    "method_body": "public boolean hasNext() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\nreturn p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\nswitch (p) {\nreturn JsonToken.BEGIN_OBJECT;\nreturn JsonToken.BEGIN_ARRAY;\nreturn JsonToken.STRING;\nreturn JsonToken.END_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:doPeek()I",
                                    "method_body": "int doPeek() throws IOException {\nint peekStack = stack[stackSize - 1];\nif (peekStack == JsonScope.EMPTY_ARRAY) {\nstack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n} else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\nint c = nextNonWhitespace(true);\nswitch (c) {\nreturn peeked = PEEKED_END_ARRAY;\nstack[stackSize - 1] = JsonScope.DANGLING_NAME;\nif (peekStack == JsonScope.NONEMPTY_OBJECT) {\nint c = nextNonWhitespace(true);\nswitch (c) {\nreturn peeked = PEEKED_END_OBJECT;\nint c = nextNonWhitespace(true);\nswitch (c) {\nreturn peeked = PEEKED_DOUBLE_QUOTED_NAME;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextName()Ljava/lang/String;",
                                    "method_body": "public String nextName() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\nif (p == PEEKED_UNQUOTED_NAME) {\n} else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n} else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\nresult = nextQuotedValue('\"');\npeeked = PEEKED_NONE;\npathNames[stackSize - 1] = result;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextString()Ljava/lang/String;",
                                    "method_body": "public String nextString() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\nif (p == PEEKED_UNQUOTED) {\n} else if (p == PEEKED_SINGLE_QUOTED) {\n} else if (p == PEEKED_DOUBLE_QUOTED) {\nresult = nextQuotedValue('\"');\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextQuotedValue(C)Ljava/lang/String;",
                                    "method_body": "private String nextQuotedValue(char quote) throws IOException {\nchar[] buffer = this.buffer;\nStringBuilder builder = null;\nint p = pos;\nint l = limit;\nint start = p;\nwhile (p < l) {\nint c = buffer[p++];\nif (c == quote) {\npos = p;\nint len = p - start - 1;\nif (builder == null) {\nreturn new String(buffer, start, len);\n} else if (c == '\\\\') {\n} else if (c == '\\n') {\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:push(I)V",
                                    "method_body": "private void push(int newTop) {\nif (stackSize == stack.length) {\nstack[stackSize++] = newTop;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit = 0;\npos = 0;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\nif (limit >= minimum) {\nreturn true;\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\nbreak;\np = pos;\nl = limit;\nint c = buffer[p++];\nif (c == '\\n') {\nlineNumber++;\nlineStart = p;\ncontinue;\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\nif (c == '/') {\n} else if (c == '#') {\npos = p;\nreturn c;\nif (throwOnEof) {\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:consumeNonExecutePrefix()V",
                                    "method_body": "private void consumeNonExecutePrefix() throws IOException {\nnextNonWhitespace(true);\npos--;\nif (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\nfor (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\nif (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\nreturn; // not a security token!\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader$1:promoteNameToValue(Lcom/google/gson/stream/JsonReader;)V",
                                    "method_body": "@Override public void promoteNameToValue(JsonReader reader) throws IOException {\nif (reader instanceof JsonTreeReader) {\nint p = reader.peeked;\nif (p == PEEKED_NONE) {\nif (p == PEEKED_DOUBLE_QUOTED_NAME) {\nreader.peeked = PEEKED_DOUBLE_QUOTED;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory STRING_BUILDER_FACTORY =\npublic static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() {\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:nullSafe()Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public final TypeAdapter<T> nullSafe() {\nreturn new TypeAdapter<T>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$17:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/String;",
                                    "method_body": "public String read(JsonReader in) throws IOException {\nJsonToken peek = in.peek();\nif (peek == JsonToken.NULL) {\nif (peek == JsonToken.BOOLEAN) {\nreturn in.nextString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$35:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nreturn new TypeAdapterFactory() {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$26:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$34:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nreturn new TypeAdapterFactory() {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$30:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nif (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:<init>()V",
                                    "method_body": "public LinkedTreeMap() {\nthis((Comparator<? super K>) NATURAL_ORDER);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:<init>(Ljava/util/Comparator;)V",
                                    "method_body": "Comparator<? super K> comparator;\nint size = 0;\nint modCount = 0;\nfinal Node<K, V> header = new Node<K, V>();\nthis((Comparator<? super K>) NATURAL_ORDER);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:<clinit>()V",
                                    "method_body": "private static final Comparator<Comparable> NATURAL_ORDER = new Comparator<Comparable>() {\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:get(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "@Override public V get(Object key) {\nNode<K, V> node = findByObject(key);\nreturn node != null ? node.value : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:put(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "@Override public V put(K key, V value) {\nif (key == null) {\nNode<K, V> created = find(key, true);\nV result = created.value;\ncreated.value = value;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:find(Ljava/lang/Object;Z)Lcom/google/gson/internal/LinkedTreeMap$Node;",
                                    "method_body": "Node<K, V> find(K key, boolean create) {\nComparator<? super K> comparator = this.comparator;\nNode<K, V> nearest = root;\nint comparison = 0;\nif (nearest != null) {\nComparable<Object> comparableKey = (comparator == NATURAL_ORDER)\ncomparison = (comparableKey != null)\nif (comparison == 0) {\nreturn nearest;\nif (!create) {\nNode<K, V> header = this.header;\nif (nearest == null) {\nif (comparator == NATURAL_ORDER && !(key instanceof Comparable)) {\ncreated = new Node<K, V>(nearest, key, header, header.prev);\nroot = created;\nsize++;\nmodCount++;\nreturn created;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:findByObject(Ljava/lang/Object;)Lcom/google/gson/internal/LinkedTreeMap$Node;",
                                    "method_body": "Node<K, V> findByObject(Object key) {\nreturn key != null ? find((K) key, false) : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap$Node:<init>()V",
                                    "method_body": "Node() {\nkey = null;\nnext = prev = this;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap$Node:<init>(Lcom/google/gson/internal/LinkedTreeMap$Node;Ljava/lang/Object;Lcom/google/gson/internal/LinkedTreeMap$Node;Lcom/google/gson/internal/LinkedTreeMap$Node;)V",
                                    "method_body": "Node(Node<K, V> parent, K key, Node<K, V> next, Node<K, V> prev) {\nthis.parent = parent;\nthis.key = key;\nthis.height = 1;\nthis.next = next;\nthis.prev = prev;\nprev.next = this;\nnext.prev = this;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/lang/String;IILjava/util/List;Ljava/util/List;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,\nList<TypeAdapterFactory> factoriesToBeAdded) {\nthis.excluder = excluder;\nthis.fieldNamingStrategy = fieldNamingStrategy;\nthis.instanceCreators = instanceCreators;\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.serializeNulls = serializeNulls;\nthis.complexMapKeySerialization = complexMapKeySerialization;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nthis.lenient = lenient;\nthis.serializeSpecialFloatingPointValues = serializeSpecialFloatingPointValues;\nthis.longSerializationPolicy = longSerializationPolicy;\nthis.datePattern = datePattern;\nthis.dateStyle = dateStyle;\nthis.timeStyle = timeStyle;\nthis.builderFactories = builderFactories;\nthis.builderHierarchyFactories = builderHierarchyFactories;\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\nfactories.add(excluder);\nfactories.addAll(factoriesToBeAdded);\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nTypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\nfactories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\nfactories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.CURRENCY_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nthis.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);\nfactories.add(jsonAdapterFactory);\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<clinit>()V",
                                    "method_body": "static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\nprivate static final TypeToken<?> NULL_KEY_SURROGATE = TypeToken.get(Object.class);\nprivate final ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>> calls\nprivate final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache = new ConcurrentHashMap<TypeToken<?>, TypeAdapter<?>>();\n*   {@link GsonBuilder#setPrettyPrinting()}. </li>"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn new TypeAdapter<Number>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLong>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongArrayAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLongArray>() {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);\nif (cached != null) {\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\n}\nthreadCalls.remove(type);\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:newJsonReader(Ljava/io/Reader;)Lcom/google/gson/stream/JsonReader;",
                                    "method_body": "public JsonReader newJsonReader(Reader reader) {\nJsonReader jsonReader = new JsonReader(reader);\njsonReader.setLenient(lenient);\nreturn jsonReader;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException {\nObject object = fromJson(json, (Type) classOfT);\nreturn Primitives.wrap(classOfT).cast(object);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {\nif (json == null) {\nStringReader reader = new StringReader(json);\nT target = (T) fromJson(reader, typeOfT);\nreturn target;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/io/Reader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nJsonReader jsonReader = newJsonReader(json);\nT object = (T) fromJson(jsonReader, typeOfT);\nassertFullConsumption(object, jsonReader);\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:assertFullConsumption(Ljava/lang/Object;Lcom/google/gson/stream/JsonReader;)V",
                                    "method_body": "private static void assertFullConsumption(Object obj, JsonReader reader) {\nif (obj != null && reader.peek() != JsonToken.END_DOCUMENT) {\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Lcom/google/gson/stream/JsonReader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nboolean isEmpty = true;\nboolean oldLenient = reader.isLenient();\nreader.setLenient(true);\nreader.peek();\nisEmpty = false;\nTypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\nTypeAdapter<T> typeAdapter = getAdapter(typeToken);\nT object = typeAdapter.read(reader);\nreturn object;\nreader.setLenient(oldLenient);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<init>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field field, boolean serialize) {\nif ((modifiers & field.getModifiers()) != 0) {\nif (version != Excluder.IGNORE_VERSIONS\nif (field.isSynthetic()) {\nreturn true;\nif (requireExpose) {\nif (!serializeInnerClasses && isInnerClass(field.getType())) {\nif (isAnonymousOrLocal(field.getType())) {\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nif (!list.isEmpty()) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nif (isAnonymousOrLocal(clazz)) {\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.FieldNamingPolicy$1:translateName(Ljava/lang/reflect/Field;)Ljava/lang/String;",
                                    "method_body": "@Override public String translateName(Field f) {\nreturn f.getName();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nfinal InstanceCreator<T> rawTypeCreator =\nif (rawTypeCreator != null) {\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\nif (defaultImplementation != null) {\nreturn defaultImplementation;\nreturn newUnsafeAllocator(type, rawType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultConstructor(Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\n} catch (NoSuchMethodException e) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultImplementationConstructor(Ljava/lang/reflect/Type;Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nif (Collection.class.isAssignableFrom(rawType)) {\nif (SortedSet.class.isAssignableFrom(rawType)) {\n} else if (EnumSet.class.isAssignableFrom(rawType)) {\n} else if (Set.class.isAssignableFrom(rawType)) {\n} else if (Queue.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\nreturn (T) new ArrayList<Object>();\nif (Map.class.isAssignableFrom(rawType)) {\nif (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\n} else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\n} else if (SortedMap.class.isAssignableFrom(rawType)) {\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nreturn new ObjectConstructor<T>() {\nreturn (T) new LinkedTreeMap<String, Object>();\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newUnsafeAllocator(Ljava/lang/reflect/Type;Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newUnsafeAllocator(\nreturn new ObjectConstructor<T>() {\nObject newInstance = unsafeAllocator.newInstance(rawType);\nreturn (T) newInstance;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<init>(Lcom/google/gson/Gson;)V",
                                    "method_body": "ObjectTypeAdapter(Gson gson) {\nthis.gson = gson;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\nreturn null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Object;",
                                    "method_body": "@Override public Object read(JsonReader in) throws IOException {\nJsonToken token = in.peek();\nswitch (token) {\nMap<String, Object> map = new LinkedTreeMap<String, Object>();\nin.beginObject();\nwhile (in.hasNext()) {\nmap.put(in.nextName(), read(in));\nin.endObject();\nreturn map;\nreturn in.nextString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nreturn typeToken.getRawType() == java.sql.Date.class\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\nType elementType = $Gson$Types.getCollectionElementType(type, rawType);\nTypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\nTypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nreturn null;\nClass<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\nType[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\nTypeAdapter<?> keyAdapter = getKeyAdapter(gson, keyAndValueTypes[0]);\nTypeAdapter<?> valueAdapter = gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\nTypeAdapter<T> result = new Adapter(gson, keyAndValueTypes[0], keyAdapter,\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:getKeyAdapter(Lcom/google/gson/Gson;Ljava/lang/reflect/Type;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<?> getKeyAdapter(Gson context, Type keyType) {\nreturn (keyType == boolean.class || keyType == Boolean.class)\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\nClass<? super T> rawType = targetType.getRawType();\nJsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);\nif (annotation == null) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;Lcom/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nJsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\nthis.jsonAdapterFactory = jsonAdapterFactory;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field f, boolean serialize) {\nreturn excludeField(f, serialize, excluder);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;ZLcom/google/gson/internal/Excluder;)Z",
                                    "method_body": "static boolean excludeField(Field f, boolean serialize, Excluder excluder) {\nreturn !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getFieldNames(Ljava/lang/reflect/Field;)Ljava/util/List;",
                                    "method_body": "private List<String> getFieldNames(Field f) {\nSerializedName annotation = f.getAnnotation(SerializedName.class);\nif (annotation == null) {\nString name = fieldNamingPolicy.translateName(f);\nreturn Collections.singletonList(name);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\nClass<? super T> raw = type.getRawType();\nif (!Object.class.isAssignableFrom(raw)) {\nObjectConstructor<T> constructor = constructorConstructor.get(type);\nreturn new Adapter<T>(constructor, getBoundFields(gson, type, raw));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:createBoundField(Lcom/google/gson/Gson;Ljava/lang/reflect/Field;Ljava/lang/String;Lcom/google/gson/reflect/TypeToken;ZZ)Lcom/google/gson/internal/bind/ReflectiveTypeAdapterFactory$BoundField;",
                                    "method_body": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(\nfinal boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\nJsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\nTypeAdapter<?> mapped = null;\nif (annotation != null) {\nfinal boolean jsonAdapterPresent = mapped != null;\nif (mapped == null) mapped = context.getAdapter(fieldType);\nfinal TypeAdapter<?> typeAdapter = mapped;\nreturn new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\nObject fieldValue = typeAdapter.read(reader);\nif (fieldValue != null || !isPrimitive) {\nfield.set(value, fieldValue);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getBoundFields(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;Ljava/lang/Class;)Ljava/util/Map;",
                                    "method_body": "private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {\nMap<String, BoundField> result = new LinkedHashMap<String, BoundField>();\nif (raw.isInterface()) {\nType declaredType = type.getType();\nwhile (raw != Object.class) {\nField[] fields = raw.getDeclaredFields();\nfor (Field field : fields) {\nboolean serialize = excludeField(field, true);\nboolean deserialize = excludeField(field, false);\nif (!serialize && !deserialize) {\ncontinue;\nfield.setAccessible(true);\nType fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\nList<String> fieldNames = getFieldNames(field);\nBoundField previous = null;\nfor (int i = 0, size = fieldNames.size(); i < size; ++i) {\nString name = fieldNames.get(i);\nif (i != 0) serialize = false; // only serialize the default name\nBoundField boundField = createBoundField(context, field, name,\nBoundField replaced = result.put(name, boundField);\nif (previous == null) previous = replaced;\nif (previous != null) {\ntype = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\nraw = type.getRawType();\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.UnsafeAllocator:create()Lcom/google/gson/internal/UnsafeAllocator;",
                                    "method_body": "public abstract <T> T newInstance(Class<T> c) throws Exception;\nClass<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\nField f = unsafeClass.getDeclaredField(\"theUnsafe\");\nf.setAccessible(true);\nfinal Object unsafe = f.get(null);\nfinal Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\nreturn new UnsafeAllocator() {\nassertInstantiable(c);\nreturn (T) allocateInstance.invoke(unsafe, c);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.UnsafeAllocator:assertInstantiable(Ljava/lang/Class;)V",
                                    "method_body": "static void assertInstantiable(Class<?> c) {\nint modifiers = c.getModifiers();\nif (Modifier.isInterface(modifiers)) {\nif (Modifier.isAbstract(modifiers)) {\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.UnsafeAllocator$1:newInstance(Ljava/lang/Class;)Ljava/lang/Object;",
                                    "method_body": "public abstract <T> T newInstance(Class<T> c) throws Exception;\nClass<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\nField f = unsafeClass.getDeclaredField(\"theUnsafe\");\nf.setAccessible(true);\nfinal Object unsafe = f.get(null);\nfinal Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\nreturn new UnsafeAllocator() {\nassertInstantiable(c);\nreturn (T) allocateInstance.invoke(unsafe, c);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson$FutureTypeAdapter:setDelegate(Lcom/google/gson/TypeAdapter;)V",
                                    "method_body": "public void setDelegate(TypeAdapter<T> typeAdapter) {\nif (delegate != null) {\ndelegate = typeAdapter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor$14:construct()Ljava/lang/Object;",
                                    "method_body": "private <T> ObjectConstructor<T> newUnsafeAllocator(\nreturn new ObjectConstructor<T>() {\nObject newInstance = unsafeAllocator.newInstance(rawType);\nreturn (T) newInstance;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter:<init>(Lcom/google/gson/internal/ObjectConstructor;Ljava/util/Map;)V",
                                    "method_body": "abstract boolean writeField(Object value) throws IOException, IllegalAccessException;\nAdapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {\nthis.constructor = constructor;\nthis.boundFields = boundFields;\n}\nif (in.peek() == JsonToken.NULL) {\nT instance = constructor.construct();\nin.beginObject();\nwhile (in.hasNext()) {\nString name = in.nextName();\nBoundField field = boundFields.get(name);\nif (field == null || !field.deserialized) {\nfield.read(in, instance);\n}\n}\nin.endObject();\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Object;",
                                    "method_body": "abstract boolean writeField(Object value) throws IOException, IllegalAccessException;\nAdapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {\nthis.constructor = constructor;\nthis.boundFields = boundFields;\n}\nif (in.peek() == JsonToken.NULL) {\nT instance = constructor.construct();\nin.beginObject();\nwhile (in.hasNext()) {\nString name = in.nextName();\nBoundField field = boundFields.get(name);\nif (field == null || !field.deserialized) {\nfield.read(in, instance);\n}\n}\nin.endObject();\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:<clinit>()V",
                                    "method_body": "private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;\nMap<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);\nMap<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);\nadd(primToWrap, wrapToPrim, boolean.class, Boolean.class);\nadd(primToWrap, wrapToPrim, byte.class, Byte.class);\nadd(primToWrap, wrapToPrim, char.class, Character.class);\nadd(primToWrap, wrapToPrim, double.class, Double.class);\nadd(primToWrap, wrapToPrim, float.class, Float.class);\nadd(primToWrap, wrapToPrim, int.class, Integer.class);\nadd(primToWrap, wrapToPrim, long.class, Long.class);\nadd(primToWrap, wrapToPrim, short.class, Short.class);\nadd(primToWrap, wrapToPrim, void.class, Void.class);\nPRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);\nWRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:add(Ljava/util/Map;Ljava/util/Map;Ljava/lang/Class;Ljava/lang/Class;)V",
                                    "method_body": "private static void add(Map<Class<?>, Class<?>> forward,\nforward.put(key, value);\nbackward.put(value, key);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:isPrimitive(Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public static boolean isPrimitive(Type type) {\nreturn PRIMITIVE_TO_WRAPPER_TYPE.containsKey(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:wrap(Ljava/lang/Class;)Ljava/lang/Class;",
                                    "method_body": "public static <T> Class<T> wrap(Class<T> type) {\nClass<T> wrapped = (Class<T>) PRIMITIVE_TO_WRAPPER_TYPE.get(\nreturn (wrapped == null) ? type : wrapped;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$BoundField:<init>(Ljava/lang/String;ZZ)V",
                                    "method_body": "protected BoundField(String name, boolean serialized, boolean deserialized) {\nthis.name = name;\nthis.serialized = serialized;\nthis.deserialized = deserialized;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$1:read(Lcom/google/gson/stream/JsonReader;Ljava/lang/Object;)V",
                                    "method_body": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(\nfinal boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\nJsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\nTypeAdapter<?> mapped = null;\nif (annotation != null) {\nfinal boolean jsonAdapterPresent = mapped != null;\nif (mapped == null) mapped = context.getAdapter(fieldType);\nfinal TypeAdapter<?> typeAdapter = mapped;\nreturn new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\nObject fieldValue = typeAdapter.read(reader);\nif (fieldValue != null || !isPrimitive) {\nfield.set(value, fieldValue);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:<init>(Lcom/google/gson/Gson;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeAdapterRuntimeTypeWrapper(Gson context, TypeAdapter<T> delegate, Type type) {\nthis.context = context;\nthis.delegate = delegate;\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Object;",
                                    "method_body": "public T read(JsonReader in) throws IOException {\nreturn delegate.read(in);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor$8:construct()Ljava/lang/Object;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nif (Collection.class.isAssignableFrom(rawType)) {\nif (SortedSet.class.isAssignableFrom(rawType)) {\n} else if (EnumSet.class.isAssignableFrom(rawType)) {\n} else if (Set.class.isAssignableFrom(rawType)) {\n} else if (Queue.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\nreturn (T) new ArrayList<Object>();\nif (Map.class.isAssignableFrom(rawType)) {\nif (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\n} else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\n} else if (SortedMap.class.isAssignableFrom(rawType)) {\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nreturn new ObjectConstructor<T>() {\nreturn (T) new LinkedTreeMap<String, Object>();\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory$Adapter:<init>(Lcom/google/gson/Gson;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Lcom/google/gson/internal/ObjectConstructor;)V",
                                    "method_body": "public Adapter(Gson context, Type elementType,\nObjectConstructor<? extends Collection<E>> constructor) {\nthis.elementTypeAdapter =\nthis.constructor = constructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory$Adapter:read(Lcom/google/gson/stream/JsonReader;)Ljava/util/Collection;",
                                    "method_body": "@Override public Collection<E> read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nCollection<E> collection = constructor.construct();\nin.beginArray();\nwhile (in.hasNext()) {\nE instance = elementTypeAdapter.read(in);\ncollection.add(instance);\n}\nin.endArray();\nreturn collection;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor$13:construct()Ljava/lang/Object;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nif (Collection.class.isAssignableFrom(rawType)) {\nif (SortedSet.class.isAssignableFrom(rawType)) {\n} else if (EnumSet.class.isAssignableFrom(rawType)) {\n} else if (Set.class.isAssignableFrom(rawType)) {\n} else if (Queue.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\nreturn (T) new ArrayList<Object>();\nif (Map.class.isAssignableFrom(rawType)) {\nif (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\n} else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\n} else if (SortedMap.class.isAssignableFrom(rawType)) {\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nreturn new ObjectConstructor<T>() {\nreturn (T) new LinkedTreeMap<String, Object>();\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter:<init>(Lcom/google/gson/internal/bind/MapTypeAdapterFactory;Lcom/google/gson/Gson;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Lcom/google/gson/internal/ObjectConstructor;)V",
                                    "method_body": "public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,\nObjectConstructor<? extends Map<K, V>> constructor) {\nthis.keyTypeAdapter =\nthis.valueTypeAdapter =\nthis.constructor = constructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter:read(Lcom/google/gson/stream/JsonReader;)Ljava/util/Map;",
                                    "method_body": "@Override public Map<K, V> read(JsonReader in) throws IOException {\nJsonToken peek = in.peek();\nif (peek == JsonToken.NULL) {\nMap<K, V> map = constructor.construct();\nif (peek == JsonToken.BEGIN_ARRAY) {\nin.beginObject();\nwhile (in.hasNext()) {\nJsonReaderInternalAccess.INSTANCE.promoteNameToValue(in);\nK key = keyTypeAdapter.read(in);\nV value = valueTypeAdapter.read(in);\nV replaced = map.put(key, value);\nif (replaced != null) {\n}\nin.endObject();\nreturn map;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$2:<clinit>()V",
                                    "method_body": "@Override public Object read(JsonReader in) throws IOException {\nJsonToken token = in.peek();\nswitch (token) {\nMap<String, Object> map = new LinkedTreeMap<String, Object>();\nin.beginObject();\nwhile (in.hasNext()) {\nmap.put(in.nextName(), read(in));\nin.endObject();\nreturn map;\nreturn in.nextString();\n}"
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}