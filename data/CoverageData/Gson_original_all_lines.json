{
    "projects": [
        {
            "name": "Gson",
            "bugs": [
                {
                    "bug_id": 1,
                    "tests": [
                        {
                            "test_name": "com.google.gson.functional.TypeVariableTest.testSingle",
                            "test_body": "33: public void testSingle() throws Exception {\n34: Gson gson = new Gson();\n35: Bar bar1 = new Bar(\"someString\", 1);\n36: ArrayList<Integer> arrayList = new ArrayList<Integer>();\n37: arrayList.add(1);\n38: arrayList.add(2);\n39: bar1.map.put(\"key1\", arrayList);\n40: bar1.map.put(\"key2\", new ArrayList<Integer>());\n41: String json = gson.toJson(bar1);\n42: System.out.println(json);\n43: 44: Bar bar2 = gson.fromJson(json, Bar.class);\n45: assertEquals(bar1, bar2);\n46: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.JsonElement:<clinit>()V",
                                    "method_body": "private static final Escaper BASIC_ESCAPER = new Escaper(false);\n\n/**\n* provides check for verifying if this element is an array or not.\n*\n* @return true if this element is of type {@link JsonArray}, false otherwise."
                                },
                                {
                                    "method_signature": "com.google.gson.Escaper:<init>(Z)V",
                                    "method_body": "Escaper(boolean escapeHtmlCharacters) {\nthis.escapeHtmlCharacters = escapeHtmlCharacters;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Escaper:<clinit>()V",
                                    "method_body": "private static final char[] HEX_CHARS = {\n'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.Preconditions:checkNotNull(Ljava/lang/Object;)V",
                                    "method_body": "public static void checkNotNull(Object obj) {\ncheckArgument(obj != null);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\nthrow new IllegalArgumentException(\"condition failed: \" + condition);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonDeserializerExceptionWrapper:<init>(Lcom/google/gson/JsonDeserializer;)V",
                                    "method_body": "JsonDeserializerExceptionWrapper(JsonDeserializer<T> delegate) {\nPreconditions.checkNotNull(delegate);\nthis.delegate = delegate;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters$DefaultDateTypeAdapter:<init>()V",
                                    "method_body": "DefaultDateTypeAdapter() {\nthis.format = DateFormat.getDateTimeInstance();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(DEFAULT_EXCLUSION_STRATEGY, DEFAULT_EXCLUSION_STRATEGY, DEFAULT_NAMING_POLICY,\nnew MappedObjectConstructor(DefaultTypeAdapters.getDefaultInstanceCreators()),\nfalse, DefaultTypeAdapters.getDefaultSerializers(),\nDefaultTypeAdapters.getDefaultDeserializers(), DEFAULT_JSON_NON_EXECUTABLE, true, false);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/ExclusionStrategy;Lcom/google/gson/ExclusionStrategy;Lcom/google/gson/FieldNamingStrategy2;Lcom/google/gson/MappedObjectConstructor;ZLcom/google/gson/ParameterizedTypeHandlerMap;Lcom/google/gson/ParameterizedTypeHandlerMap;ZZZ)V",
                                    "method_body": "Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy,\nFieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor,\nboolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers,\nParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,\nboolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting) {\nthis.serializationStrategy = serializationStrategy;\nthis.deserializationStrategy = deserializationStrategy;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.objectConstructor = objectConstructor;\nthis.serializeNulls = serializeNulls;\nthis.serializers = serializers;\nthis.deserializers = deserializers;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<clinit>()V",
                                    "method_body": "private static final String NULL_STRING = \"null\";\n\nstatic final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\n\n// Default instances of plug-ins\nstatic final AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY =\nnew AnonymousAndLocalClassExclusionStrategy();\nstatic final SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY =\nnew SyntheticFieldExclusionStrategy(true);\nstatic final ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY =\nnew ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC });"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:createDefaultObjectNavigatorFactory(Lcom/google/gson/ExclusionStrategy;)Lcom/google/gson/ObjectNavigatorFactory;",
                                    "method_body": "private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy) {\nreturn new ObjectNavigatorFactory(strategy, fieldNamingPolicy);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:createExclusionStrategy(D)Lcom/google/gson/ExclusionStrategy;",
                                    "method_body": "private static ExclusionStrategy createExclusionStrategy(double version) {\nList<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>();\nstrategies.add(DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY);\nstrategies.add(DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY);\nstrategies.add(DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY);\nif (version != VersionConstants.IGNORE_VERSIONS) {\nstrategies.add(new VersionExclusionStrategy(version));\n}\nreturn new DisjunctionExclusionStrategy(strategies);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:toJsonTree(Ljava/lang/Object;Ljava/lang/reflect/Type;)Lcom/google/gson/JsonElement;",
                                    "method_body": "public JsonElement toJsonTree(Object src, Type typeOfSrc) {\nif (src == null) {\nreturn JsonNull.createJsonNull();\n}\nJsonSerializationContextDefault context = new JsonSerializationContextDefault(\ncreateDefaultObjectNavigatorFactory(serializationStrategy), serializeNulls, serializers);\nreturn context.serialize(src, typeOfSrc, true);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:toJson(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public String toJson(Object src) {\nif (src == null) {\nreturn serializeNulls ? NULL_STRING : \"\";\n}\nreturn toJson(src, src.getClass());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:toJson(Ljava/lang/Object;Ljava/lang/reflect/Type;)Ljava/lang/String;",
                                    "method_body": "public String toJson(Object src, Type typeOfSrc) {\nStringWriter writer = new StringWriter();\ntoJson(toJsonTree(src, typeOfSrc), writer);\nreturn writer.toString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.AnonymousAndLocalClassExclusionStrategy:shouldSkipField(Lcom/google/gson/FieldAttributes;)Z",
                                    "method_body": "public boolean shouldSkipField(FieldAttributes f) {\nreturn isAnonymousOrLocal(f.getDeclaredClass());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.AnonymousAndLocalClassExclusionStrategy:shouldSkipClass(Ljava/lang/Class;)Z",
                                    "method_body": "public boolean shouldSkipClass(Class<?> clazz) {\nreturn isAnonymousOrLocal(clazz);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.AnonymousAndLocalClassExclusionStrategy:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n&& (clazz.isAnonymousClass() || clazz.isLocalClass());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.SyntheticFieldExclusionStrategy:<init>(Z)V",
                                    "method_body": "SyntheticFieldExclusionStrategy(boolean skipSyntheticFields) {\nthis.skipSyntheticFields = skipSyntheticFields;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.SyntheticFieldExclusionStrategy:shouldSkipClass(Ljava/lang/Class;)Z",
                                    "method_body": "public boolean shouldSkipClass(Class<?> clazz) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.SyntheticFieldExclusionStrategy:shouldSkipField(Lcom/google/gson/FieldAttributes;)Z",
                                    "method_body": "public boolean shouldSkipField(FieldAttributes f) {\nreturn skipSyntheticFields && f.isSynthetic();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ModifierBasedExclusionStrategy:<init>([I)V",
                                    "method_body": "public ModifierBasedExclusionStrategy(int... modifiers) {\nthis.modifiers = new HashSet<Integer>();\nif (modifiers != null) {\nfor (int modifier : modifiers) {\nthis.modifiers.add(modifier);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ModifierBasedExclusionStrategy:shouldSkipField(Lcom/google/gson/FieldAttributes;)Z",
                                    "method_body": "public boolean shouldSkipField(FieldAttributes f) {\nfor (int modifier : modifiers) {\nif (f.hasModifier(modifier)) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ModifierBasedExclusionStrategy:shouldSkipClass(Ljava/lang/Class;)Z",
                                    "method_body": "public boolean shouldSkipClass(Class<?> clazz) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.SerializedNameAnnotationInterceptingNamingPolicy:<init>(Lcom/google/gson/FieldNamingStrategy2;)V",
                                    "method_body": "public SerializedNameAnnotationInterceptingNamingPolicy(FieldNamingStrategy2 delegate) {\nthis.delegate = delegate;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.SerializedNameAnnotationInterceptingNamingPolicy:<clinit>()V",
                                    "method_body": "private static final JsonFieldNameValidator fieldNameValidator = new JsonFieldNameValidator();\nprivate final FieldNamingStrategy2 delegate;\n\npublic SerializedNameAnnotationInterceptingNamingPolicy(FieldNamingStrategy2 delegate) {\nthis.delegate = delegate;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonFieldNameValidator:<clinit>()V",
                                    "method_body": "private static final String COMMON_PATTERN = \"[a-zA-Z][a-zA-Z0-9\\\\ \\\\$_\\\\-]*$\";\n\nprivate static final Pattern JSON_FIELD_NAME_PATTERN =\nPattern.compile(\"(^\" + COMMON_PATTERN + \")|(^[\\\\$_]\" + COMMON_PATTERN + \")\");\n\n\n/**\n* Performs validation on the JSON field name to ensure it is a valid field name.\n*\n* @param fieldName the name of the field to validate\n* @return {@code fieldName} if it is a valid JSON field name"
                                },
                                {
                                    "method_signature": "com.google.gson.DisjunctionExclusionStrategy:<init>(Ljava/util/Collection;)V",
                                    "method_body": "public DisjunctionExclusionStrategy(Collection<ExclusionStrategy> strategies) {\nPreconditions.checkNotNull(strategies);\nthis.strategies = strategies;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DisjunctionExclusionStrategy:shouldSkipField(Lcom/google/gson/FieldAttributes;)Z",
                                    "method_body": "public boolean shouldSkipField(FieldAttributes f) {\nfor (ExclusionStrategy strategy : strategies) {\nif (strategy.shouldSkipField(f)) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DisjunctionExclusionStrategy:shouldSkipClass(Ljava/lang/Class;)Z",
                                    "method_body": "public boolean shouldSkipClass(Class<?> clazz) {\nfor (ExclusionStrategy strategy : strategies) {\nif (strategy.shouldSkipClass(clazz)) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.MappedObjectConstructor:<init>(Lcom/google/gson/ParameterizedTypeHandlerMap;)V",
                                    "method_body": "public MappedObjectConstructor(\nParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators) {\ninstanceCreatorMap = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.MappedObjectConstructor:<clinit>()V",
                                    "method_body": "private static final Logger log = Logger.getLogger(MappedObjectConstructor.class.getName());\n\nprivate final ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreatorMap;\n\npublic MappedObjectConstructor(\nParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators) {\ninstanceCreatorMap = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters:<clinit>()V",
                                    "method_body": "private static final DefaultDateTypeAdapter DATE_TYPE_ADAPTER = new DefaultDateTypeAdapter();\nprivate static final DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER =\nnew DefaultJavaSqlDateTypeAdapter();\nprivate static final DefaultTimeTypeAdapter TIME_TYPE_ADAPTER =\nnew DefaultTimeTypeAdapter();\nprivate static final DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER =\nnew DefaultTimestampDeserializer();\n\n@SuppressWarnings({ \"rawtypes\" })"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters:createDefaultSerializers()Lcom/google/gson/ParameterizedTypeHandlerMap;",
                                    "method_body": "private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers() {\nParameterizedTypeHandlerMap<JsonSerializer<?>> map =\nnew ParameterizedTypeHandlerMap<JsonSerializer<?>>();\n\nmap.registerForTypeHierarchy(Enum.class, ENUM_TYPE_ADAPTER);\nmap.register(URL.class, URL_TYPE_ADAPTER);\nmap.register(URI.class, URI_TYPE_ADAPTER);\nmap.register(UUID.class, UUUID_TYPE_ADAPTER);\nmap.register(Locale.class, LOCALE_TYPE_ADAPTER);\nmap.registerForTypeHierarchy(Collection.class, COLLECTION_TYPE_ADAPTER);\nmap.registerForTypeHierarchy(Map.class, MAP_TYPE_ADAPTER);\nmap.register(Date.class, DATE_TYPE_ADAPTER);\nmap.register(java.sql.Date.class, JAVA_SQL_DATE_TYPE_ADAPTER);\nmap.register(Timestamp.class, DATE_TYPE_ADAPTER);\nmap.register(Time.class, TIME_TYPE_ADAPTER);\nmap.register(Calendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER);\nmap.register(GregorianCalendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER);\nmap.register(BigDecimal.class, BIG_DECIMAL_TYPE_ADAPTER);\nmap.register(BigInteger.class, BIG_INTEGER_TYPE_ADAPTER);\n\n// Add primitive serializers\nmap.register(Boolean.class, BOOLEAN_TYPE_ADAPTER);\nmap.register(boolean.class, BOOLEAN_TYPE_ADAPTER);\nmap.register(Byte.class, BYTE_TYPE_ADAPTER);\nmap.register(byte.class, BYTE_TYPE_ADAPTER);\nmap.register(Character.class, CHARACTER_TYPE_ADAPTER);\nmap.register(char.class, CHARACTER_TYPE_ADAPTER);\nmap.register(Integer.class, INTEGER_TYPE_ADAPTER);\nmap.register(int.class, INTEGER_TYPE_ADAPTER);\nmap.register(Number.class, NUMBER_TYPE_ADAPTER);\nmap.register(Short.class, SHORT_TYPE_ADAPTER);\nmap.register(short.class, SHORT_TYPE_ADAPTER);\nmap.register(String.class, STRING_TYPE_ADAPTER);\n\nmap.makeUnmodifiable();\nreturn map;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters:createDefaultDeserializers()Lcom/google/gson/ParameterizedTypeHandlerMap;",
                                    "method_body": "private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers() {\nParameterizedTypeHandlerMap<JsonDeserializer<?>> map =\nnew ParameterizedTypeHandlerMap<JsonDeserializer<?>>();\nmap.registerForTypeHierarchy(Enum.class, wrapDeserializer(ENUM_TYPE_ADAPTER));\nmap.register(URL.class, wrapDeserializer(URL_TYPE_ADAPTER));\nmap.register(URI.class, wrapDeserializer(URI_TYPE_ADAPTER));\nmap.register(UUID.class, wrapDeserializer(UUUID_TYPE_ADAPTER));\nmap.register(Locale.class, wrapDeserializer(LOCALE_TYPE_ADAPTER));\nmap.registerForTypeHierarchy(Collection.class, wrapDeserializer(COLLECTION_TYPE_ADAPTER));\nmap.registerForTypeHierarchy(Map.class, wrapDeserializer(MAP_TYPE_ADAPTER));\nmap.register(Date.class, wrapDeserializer(DATE_TYPE_ADAPTER));\nmap.register(java.sql.Date.class, wrapDeserializer(JAVA_SQL_DATE_TYPE_ADAPTER));\nmap.register(Timestamp.class, wrapDeserializer(TIMESTAMP_DESERIALIZER));\nmap.register(Time.class, wrapDeserializer(TIME_TYPE_ADAPTER));\nmap.register(Calendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER);\nmap.register(GregorianCalendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER);\nmap.register(BigDecimal.class, wrapDeserializer(BIG_DECIMAL_TYPE_ADAPTER));\nmap.register(BigInteger.class, wrapDeserializer(BIG_INTEGER_TYPE_ADAPTER));\n\n// Add primitive deserializers\nmap.register(Boolean.class, wrapDeserializer(BOOLEAN_TYPE_ADAPTER));\nmap.register(boolean.class, wrapDeserializer(BOOLEAN_TYPE_ADAPTER));\nmap.register(Byte.class, wrapDeserializer(BYTE_TYPE_ADAPTER));\nmap.register(byte.class, wrapDeserializer(BYTE_TYPE_ADAPTER));\nmap.register(Character.class, wrapDeserializer(CHARACTER_TYPE_ADAPTER));\nmap.register(char.class, wrapDeserializer(CHARACTER_TYPE_ADAPTER));\nmap.register(Double.class, wrapDeserializer(DOUBLE_TYPE_ADAPTER));\nmap.register(double.class, wrapDeserializer(DOUBLE_TYPE_ADAPTER));\nmap.register(Float.class, wrapDeserializer(FLOAT_TYPE_ADAPTER));\nmap.register(float.class, wrapDeserializer(FLOAT_TYPE_ADAPTER));\nmap.register(Integer.class, wrapDeserializer(INTEGER_TYPE_ADAPTER));\nmap.register(int.class, wrapDeserializer(INTEGER_TYPE_ADAPTER));\nmap.register(Long.class, wrapDeserializer(LONG_DESERIALIZER));\nmap.register(long.class, wrapDeserializer(LONG_DESERIALIZER));\nmap.register(Number.class, wrapDeserializer(NUMBER_TYPE_ADAPTER));\nmap.register(Short.class, wrapDeserializer(SHORT_TYPE_ADAPTER));\nmap.register(short.class, wrapDeserializer(SHORT_TYPE_ADAPTER));\nmap.register(String.class, wrapDeserializer(STRING_TYPE_ADAPTER));\n\nmap.makeUnmodifiable();\nreturn map;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters:createDefaultInstanceCreators()Lcom/google/gson/ParameterizedTypeHandlerMap;",
                                    "method_body": "private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators() {\nParameterizedTypeHandlerMap<InstanceCreator<?>> map =\nnew ParameterizedTypeHandlerMap<InstanceCreator<?>>();\nmap.registerForTypeHierarchy(Map.class, MAP_TYPE_ADAPTER);\n\n// Add Collection type instance creators\nmap.registerForTypeHierarchy(Collection.class, COLLECTION_TYPE_ADAPTER);\n\nmap.registerForTypeHierarchy(Set.class, HASH_SET_CREATOR);\nmap.registerForTypeHierarchy(SortedSet.class, TREE_SET_CREATOR);\nmap.register(Properties.class, PROPERTIES_CREATOR);\nmap.makeUnmodifiable();\nreturn map;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters:wrapDeserializer(Lcom/google/gson/JsonDeserializer;)Lcom/google/gson/JsonDeserializer;",
                                    "method_body": "private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer) {\nreturn new JsonDeserializerExceptionWrapper(deserializer);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters:getDefaultSerializers()Lcom/google/gson/ParameterizedTypeHandlerMap;",
                                    "method_body": "static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers() {\nreturn getDefaultSerializers(false, LongSerializationPolicy.DEFAULT);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters:getDefaultSerializers(ZLcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/ParameterizedTypeHandlerMap;",
                                    "method_body": "static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(\nboolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy) {\nParameterizedTypeHandlerMap<JsonSerializer<?>> serializers =\nnew ParameterizedTypeHandlerMap<JsonSerializer<?>>();\n\n// Double primitive\nDefaultTypeAdapters.DoubleSerializer doubleSerializer =\nnew DefaultTypeAdapters.DoubleSerializer(serializeSpecialFloatingPointValues);\nserializers.registerIfAbsent(Double.class, doubleSerializer);\nserializers.registerIfAbsent(double.class, doubleSerializer);\n\n// Float primitive\nDefaultTypeAdapters.FloatSerializer floatSerializer =\nnew DefaultTypeAdapters.FloatSerializer(serializeSpecialFloatingPointValues);\nserializers.registerIfAbsent(Float.class, floatSerializer);\nserializers.registerIfAbsent(float.class, floatSerializer);\n\n// Long primitive\nDefaultTypeAdapters.LongSerializer longSerializer =\nnew DefaultTypeAdapters.LongSerializer(longSerializationPolicy);\nserializers.registerIfAbsent(Long.class, longSerializer);\nserializers.registerIfAbsent(long.class, longSerializer);\n\nserializers.registerIfAbsent(DEFAULT_SERIALIZERS);\nreturn serializers;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters:getDefaultDeserializers()Lcom/google/gson/ParameterizedTypeHandlerMap;",
                                    "method_body": "static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers() {\nreturn DEFAULT_DESERIALIZERS;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters:getDefaultInstanceCreators()Lcom/google/gson/ParameterizedTypeHandlerMap;",
                                    "method_body": "static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators() {\nreturn DEFAULT_INSTANCE_CREATORS;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters$DefaultJavaSqlDateTypeAdapter:<init>()V",
                                    "method_body": "DefaultJavaSqlDateTypeAdapter() {\nthis.format = new SimpleDateFormat(\"MMM d, yyyy\");\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters$DefaultTimeTypeAdapter:<init>()V",
                                    "method_body": "DefaultTimeTypeAdapter() {\nthis.format = new SimpleDateFormat(\"hh:mm:ss a\");\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:<clinit>()V",
                                    "method_body": "private static final Logger logger =\nLogger.getLogger(ParameterizedTypeHandlerMap.class.getName());\nprivate final Map<Type, T> map = new HashMap<Type, T>();\nprivate final List<Pair<Class<?>, T>> typeHierarchyList = new ArrayList<Pair<Class<?>, T>>();\nprivate boolean modifiable = true;\n\npublic synchronized void registerForTypeHierarchy(Class<?> typeOfT, T value) {\nPair<Class<?>, T> pair = new Pair<Class<?>, T>(typeOfT, value);\nregisterForTypeHierarchy(pair);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:registerForTypeHierarchy(Ljava/lang/Class;Ljava/lang/Object;)V",
                                    "method_body": "public synchronized void registerForTypeHierarchy(Class<?> typeOfT, T value) {\nPair<Class<?>, T> pair = new Pair<Class<?>, T>(typeOfT, value);\nregisterForTypeHierarchy(pair);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:registerForTypeHierarchy(Lcom/google/gson/Pair;)V",
                                    "method_body": "public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\nif (!modifiable) {\nthrow new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n}\nint index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\nif (index >= 0) {\nlogger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\ntypeHierarchyList.remove(index);\n}\nindex = getIndexOfAnOverriddenHandler(pair.first);\nif (index >= 0) {\nthrow new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n+ \" hides the previously registered type hierarchy handler for \"\n+ typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n}\n// We want stack behavior for adding to this list. A type adapter added subsequently should\n// override a previously registered one.\ntypeHierarchyList.add(0, pair);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:getIndexOfAnOverriddenHandler(Ljava/lang/Class;)I",
                                    "method_body": "private int getIndexOfAnOverriddenHandler(Class<?> type) {\nfor (int i = typeHierarchyList.size()-1; i >= 0; --i) {\nPair<Class<?>, T> entry = typeHierarchyList.get(i);\nif (type.isAssignableFrom(entry.first)) {\nreturn i;\n}\n}\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:register(Ljava/lang/reflect/Type;Ljava/lang/Object;)V",
                                    "method_body": "public synchronized void register(Type typeOfT, T value) {\nif (!modifiable) {\nthrow new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n}\nif (hasSpecificHandlerFor(typeOfT)) {\nlogger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", typeOfT);\n}\nmap.put(typeOfT, value);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:registerIfAbsent(Lcom/google/gson/ParameterizedTypeHandlerMap;)V",
                                    "method_body": "public synchronized void registerIfAbsent(ParameterizedTypeHandlerMap<T> other) {\nif (!modifiable) {\nthrow new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n}\nfor (Map.Entry<Type, T> entry : other.map.entrySet()) {\nif (!map.containsKey(entry.getKey())) {\nregister(entry.getKey(), entry.getValue());\n}\n}\n// Quite important to traverse the typeHierarchyList from stack bottom first since\n// we want to register the handlers in the same order to preserve priority order\nfor (int i = other.typeHierarchyList.size()-1; i >= 0; --i) {\nPair<Class<?>, T> entry = other.typeHierarchyList.get(i);\nint index = getIndexOfSpecificHandlerForTypeHierarchy(entry.first);\nif (index < 0) {\nregisterForTypeHierarchy(entry);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:registerIfAbsent(Ljava/lang/reflect/Type;Ljava/lang/Object;)V",
                                    "method_body": "public synchronized void registerIfAbsent(Type typeOfT, T value) {\nif (!modifiable) {\nthrow new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n}\nif (!map.containsKey(typeOfT)) {\nregister(typeOfT, value);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:makeUnmodifiable()V",
                                    "method_body": "public synchronized void makeUnmodifiable() {\nmodifiable = false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:getHandlerFor(Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public synchronized T getHandlerFor(Type type) {\nT handler = map.get(type);\nif (handler == null) {\nClass<?> rawClass = TypeUtils.toRawClass(type);\nif (rawClass != type) {\nhandler = getHandlerFor(rawClass);\n}\nif (handler == null) {\n// check if something registered for type hierarchy\nhandler = getHandlerForTypeHierarchy(rawClass);\n}\n}\nreturn handler;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:getHandlerForTypeHierarchy(Ljava/lang/Class;)Ljava/lang/Object;",
                                    "method_body": "private T getHandlerForTypeHierarchy(Class<?> type) {\nfor (Pair<Class<?>, T> entry : typeHierarchyList) {\nif (entry.first.isAssignableFrom(type)) {\nreturn entry.second;\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:hasSpecificHandlerFor(Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public synchronized boolean hasSpecificHandlerFor(Type type) {\nreturn map.containsKey(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:getIndexOfSpecificHandlerForTypeHierarchy(Ljava/lang/Class;)I",
                                    "method_body": "private synchronized int getIndexOfSpecificHandlerForTypeHierarchy(Class<?> type) {\nfor (int i = typeHierarchyList.size()-1; i >= 0; --i) {\nif (type.equals(typeHierarchyList.get(i).first)) {\nreturn i;\n}\n}\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Pair:<init>(Ljava/lang/Object;Ljava/lang/Object;)V",
                                    "method_body": "Pair(FIRST first, SECOND second) {\nthis.first = first;\nthis.second = second;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.LongSerializationPolicy:<init>(Ljava/lang/String;ILcom/google/gson/LongSerializationPolicy$Strategy;)V",
                                    "method_body": "private LongSerializationPolicy(Strategy strategy) {\nthis.strategy = strategy;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.LongSerializationPolicy$DefaultStrategy:<init>(Lcom/google/gson/LongSerializationPolicy$1;)V",
                                    "method_body": "JsonElement serialize(Long value);\n}\n\nprivate static class DefaultStrategy implements Strategy {\npublic JsonElement serialize(Long value) {\nreturn new JsonPrimitive(value);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters$DoubleSerializer:<init>(Z)V",
                                    "method_body": "DoubleSerializer(boolean serializeSpecialDoubleValues) {\nthis.serializeSpecialFloatingPointValues = serializeSpecialDoubleValues;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters$FloatSerializer:<init>(Z)V",
                                    "method_body": "FloatSerializer(boolean serializeSpecialDoubleValues) {\nthis.serializeSpecialFloatingPointValues = serializeSpecialDoubleValues;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultTypeAdapters$LongSerializer:<init>(Lcom/google/gson/LongSerializationPolicy;)V",
                                    "method_body": "private LongSerializer(LongSerializationPolicy longSerializationPolicy) {\nthis.longSerializationPolicy = longSerializationPolicy;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.FieldAttributes:<init>(Ljava/lang/Class;Ljava/lang/reflect/Field;)V",
                                    "method_body": "FieldAttributes(final Class<?> declaringClazz, final Field f) {\nPreconditions.checkNotNull(declaringClazz);\nthis.declaringClazz = declaringClazz;\nname = f.getName();\ndeclaredType = f.getType();\nisSynthetic = f.isSynthetic();\nmodifiers = f.getModifiers();\nfield = f;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.FieldAttributes:<clinit>()V",
                                    "method_body": "private static final String MAX_CACHE_PROPERTY_NAME =\n\"com.google.gson.annotation_cache_size_hint\";\n\nprivate static final Cache<Pair<Class<?>, String>, Collection<Annotation>> ANNOTATION_CACHE =\nnew LruCache<Pair<Class<?>,String>, Collection<Annotation>>(getMaxCacheSize());\n\nprivate final Class<?> declaringClazz;\nprivate final Field field;\nprivate final Class<?> declaredType;\nprivate final boolean isSynthetic;\nprivate final int modifiers;\nprivate final String name;\n\n// Fields used for lazy initialization\nprivate Type genericType;\nprivate Collection<Annotation> annotations;\n\n/**\n* Constructs a Field Attributes object from the {@code f}."
                                },
                                {
                                    "method_signature": "com.google.gson.FieldAttributes:getMaxCacheSize()I",
                                    "method_body": "private static int getMaxCacheSize() {\nfinal int defaultMaxCacheSize = 2000;\ntry {\nString propertyValue = System.getProperty(\nMAX_CACHE_PROPERTY_NAME, String.valueOf(defaultMaxCacheSize));\nreturn Integer.parseInt(propertyValue);\n} catch (NumberFormatException e) {\nreturn defaultMaxCacheSize;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.FieldAttributes:getDeclaredClass()Ljava/lang/Class;",
                                    "method_body": "public Class<?> getDeclaredClass() {\nreturn declaredType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.FieldAttributes:hasModifier(I)Z",
                                    "method_body": "public boolean hasModifier(int modifier) {\nreturn (modifiers & modifier) != 0;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.FieldAttributes:isSynthetic()Z",
                                    "method_body": "boolean isSynthetic() {\nreturn isSynthetic;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.LruCache:<init>(I)V",
                                    "method_body": "LruCache(int maxCapacity) {\nsuper(maxCapacity, 0.7F, true);\nthis.maxCapacity = maxCapacity;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonObject:<init>()V",
                                    "method_body": "public JsonObject() {\nmembers = new LinkedHashMap<String, JsonElement>();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonSerializationContextDefault:<init>(Lcom/google/gson/ObjectNavigatorFactory;ZLcom/google/gson/ParameterizedTypeHandlerMap;)V",
                                    "method_body": "JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls,\nParameterizedTypeHandlerMap<JsonSerializer<?>> serializers) {\nthis.factory = factory;\nthis.serializeNulls = serializeNulls;\nthis.serializers = serializers;\nthis.ancestors = new MemoryRefStack();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonSerializationContextDefault:serialize(Ljava/lang/Object;Ljava/lang/reflect/Type;Z)Lcom/google/gson/JsonElement;",
                                    "method_body": "public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType) {\nObjectNavigator on = factory.create(new ObjectTypePair(src, typeOfSrc, preserveType));\nJsonSerializationVisitor visitor =\nnew JsonSerializationVisitor(factory, serializeNulls, serializers, this, ancestors);\non.accept(visitor);\nreturn visitor.getJsonElement();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ObjectNavigatorFactory:<init>(Lcom/google/gson/ExclusionStrategy;Lcom/google/gson/FieldNamingStrategy2;)V",
                                    "method_body": "public ObjectNavigatorFactory(ExclusionStrategy strategy, FieldNamingStrategy2 fieldNamingPolicy) {\nPreconditions.checkNotNull(fieldNamingPolicy);\nthis.strategy = (strategy == null ? new NullExclusionStrategy() : strategy);\nthis.fieldNamingPolicy = fieldNamingPolicy;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ObjectNavigatorFactory:create(Lcom/google/gson/ObjectTypePair;)Lcom/google/gson/ObjectNavigator;",
                                    "method_body": "public ObjectNavigator create(ObjectTypePair objTypePair) {\nreturn new ObjectNavigator(objTypePair, strategy);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.MemoryRefStack:push(Lcom/google/gson/ObjectTypePair;)Lcom/google/gson/ObjectTypePair;",
                                    "method_body": "public ObjectTypePair push(ObjectTypePair obj) {\nPreconditions.checkNotNull(obj);\n\nreturn stack.push(obj);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.MemoryRefStack:pop()Lcom/google/gson/ObjectTypePair;",
                                    "method_body": "public ObjectTypePair pop() {\nreturn stack.pop();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.MemoryRefStack:contains(Lcom/google/gson/ObjectTypePair;)Z",
                                    "method_body": "public boolean contains(ObjectTypePair obj) {\nif (obj == null) {\nreturn false;\n}\n\nfor (ObjectTypePair stackObject : stack) {\nif (stackObject.getObject() == obj.getObject()\n&& stackObject.type.equals(obj.type) ) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ObjectTypePair:<init>(Ljava/lang/Object;Ljava/lang/reflect/Type;Z)V",
                                    "method_body": "ObjectTypePair(Object obj, Type type, boolean preserveType) {\nthis.obj = obj;\nthis.type = type;\nthis.preserveType = preserveType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ObjectTypePair:getObject()Ljava/lang/Object;",
                                    "method_body": "Object getObject() {\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ObjectTypePair:setObject(Ljava/lang/Object;)V",
                                    "method_body": "void setObject(Object obj) {\nthis.obj = obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ObjectTypePair:getMatchingHandler(Lcom/google/gson/ParameterizedTypeHandlerMap;)Lcom/google/gson/Pair;",
                                    "method_body": "<HANDLER> Pair<HANDLER, ObjectTypePair> getMatchingHandler(\nParameterizedTypeHandlerMap<HANDLER> handlers) {\nHANDLER handler = null;\nif (!preserveType && obj != null) {\n// First try looking up the handler for the actual type\nObjectTypePair moreSpecificType = toMoreSpecificType();\nhandler = handlers.getHandlerFor(moreSpecificType.type);\nif (handler != null) {\nreturn new Pair<HANDLER, ObjectTypePair>(handler, moreSpecificType);\n}\n}\n// Try the specified type\nhandler = handlers.getHandlerFor(type);\nreturn handler == null ? null : new Pair<HANDLER, ObjectTypePair>(handler, this);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ObjectTypePair:toMoreSpecificType()Lcom/google/gson/ObjectTypePair;",
                                    "method_body": "ObjectTypePair toMoreSpecificType() {\nif (preserveType || obj == null) {\nreturn this;\n}\nType actualType = getActualTypeIfMoreSpecific(type, obj.getClass());\nif (actualType == type) {\nreturn this;\n}\nreturn new ObjectTypePair(obj, actualType, preserveType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ObjectNavigator:<init>(Lcom/google/gson/ObjectTypePair;Lcom/google/gson/ExclusionStrategy;)V",
                                    "method_body": "public void start(ObjectTypePair node);\n\npublic void end(ObjectTypePair node);\n\n/**\n* This is called before the object navigator starts visiting the current\n* object\n*/\nvoid startVisitingObject(Object node);\n\n/**\n* This is called to visit the current object if it is an array\n*/\nvoid visitArray(Object array, Type componentType);\n\n/**\n* This is called to visit an object field of the current object\n*/\nvoid visitObjectField(FieldAttributes f, Type typeOfF, Object obj);\n\n/**\n* This is called to visit an array field of the current object\n*/\nvoid visitArrayField(FieldAttributes f, Type typeOfF, Object obj);\n\n/**\n* This is called to visit an object using a custom handler\n*\n* @return true if a custom handler exists, false otherwise\n*/\npublic boolean visitUsingCustomHandler(ObjectTypePair objTypePair);\n\n/**\n* This is called to visit a field of the current object using a custom\n* handler\n*/\npublic boolean visitFieldUsingCustomHandler(FieldAttributes f, Type actualTypeOfField,\nObject parent);\n\n/**\n* Retrieve the current target\n*/\nObject getTarget();\n\nvoid visitPrimitive(Object primitive);\n}\n\nprivate final ExclusionStrategy exclusionStrategy;\nprivate final ObjectTypePair objTypePair;\n\n/**\n* @param objTypePair\n*          The object,type (fully genericized) being navigated\n* @param exclusionStrategy\n*          the concrete strategy object to be used to filter out fields of an\n*          object.\n*/\nObjectNavigator(ObjectTypePair objTypePair, ExclusionStrategy exclusionStrategy) {\nPreconditions.checkNotNull(exclusionStrategy);\n\nthis.objTypePair = objTypePair;\nthis.exclusionStrategy = exclusionStrategy;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ObjectNavigator:accept(Lcom/google/gson/ObjectNavigator$Visitor;)V",
                                    "method_body": "public void accept(Visitor visitor) {\nTypeInfo objTypeInfo = new TypeInfo(objTypePair.type);\nif (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) {\nreturn;\n}\nboolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair);\nif (!visitedWithCustomHandler) {\nObject obj = objTypePair.getObject();\nObject objectToVisit = (obj == null) ? visitor.getTarget() : obj;\nif (objectToVisit == null) {\nreturn;\n}\nobjTypePair.setObject(objectToVisit);\nvisitor.start(objTypePair);\ntry {\nif (objTypeInfo.isArray()) {\nvisitor.visitArray(objectToVisit, objTypePair.type);\n} else if (objTypeInfo.getActualType() == Object.class\n&& isPrimitiveOrString(objectToVisit)) {\n// TODO(Joel): this is only used for deserialization of \"primitives\"\n// we should rethink this!!!\nvisitor.visitPrimitive(objectToVisit);\nobjectToVisit = visitor.getTarget();\n} else {\nvisitor.startVisitingObject(objectToVisit);\nObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType();\nClass<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass();\nfor (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr =\ncurr.getSuperclass()) {\nif (!curr.isSynthetic()) {\nnavigateClassFields(objectToVisit, curr, visitor);\n}\n}\n}\n} finally {\nvisitor.end(objTypePair);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.ObjectNavigator:navigateClassFields(Ljava/lang/Object;Ljava/lang/Class;Lcom/google/gson/ObjectNavigator$Visitor;)V",
                                    "method_body": "private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor) {\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field f : fields) {\nFieldAttributes fieldAttributes = new FieldAttributes(clazz, f);\nif (exclusionStrategy.shouldSkipField(fieldAttributes)\n|| exclusionStrategy.shouldSkipClass(fieldAttributes.getDeclaredClass())) {\ncontinue; // skip\n}\nTypeInfo fieldTypeInfo = TypeInfoFactory.getTypeInfoForField(f, objTypePair.type);\nType declaredTypeOfField = fieldTypeInfo.getActualType();\nboolean visitedWithCustomHandler =\nvisitor.visitFieldUsingCustomHandler(fieldAttributes, declaredTypeOfField, obj);\nif (!visitedWithCustomHandler) {\nif (fieldTypeInfo.isArray()) {\nvisitor.visitArrayField(fieldAttributes, declaredTypeOfField, obj);\n} else {\nvisitor.visitObjectField(fieldAttributes, declaredTypeOfField, obj);\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonSerializationVisitor:<init>(Lcom/google/gson/ObjectNavigatorFactory;ZLcom/google/gson/ParameterizedTypeHandlerMap;Lcom/google/gson/JsonSerializationContext;Lcom/google/gson/MemoryRefStack;)V",
                                    "method_body": "JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls,\nParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context,\nMemoryRefStack ancestors) {\nthis.factory = factory;\nthis.serializeNulls = serializeNulls;\nthis.serializers = serializers;\nthis.context = context;\nthis.ancestors = ancestors;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonSerializationVisitor:start(Lcom/google/gson/ObjectTypePair;)V",
                                    "method_body": "public void start(ObjectTypePair node) {\nif (node == null) {\nreturn;\n}\nif (ancestors.contains(node)) {\nthrow new CircularReferenceException(node);\n}\nancestors.push(node);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonSerializationVisitor:end(Lcom/google/gson/ObjectTypePair;)V",
                                    "method_body": "public void end(ObjectTypePair node) {\nif (node != null) {\nancestors.pop();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonSerializationVisitor:startVisitingObject(Ljava/lang/Object;)V",
                                    "method_body": "public void startVisitingObject(Object node) {\nassignToRoot(new JsonObject());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonSerializationVisitor:visitUsingCustomHandler(Lcom/google/gson/ObjectTypePair;)Z",
                                    "method_body": "public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) {\ntry {\nObject obj = objTypePair.getObject();\nif (obj == null) {\nif (serializeNulls) {\nassignToRoot(JsonNull.createJsonNull());\n}\nreturn true;\n}\nJsonElement element = findAndInvokeCustomSerializer(objTypePair);\nif (element != null) {\nassignToRoot(element);\nreturn true;\n}\nreturn false;\n} catch (CircularReferenceException e) {\nthrow e.createDetailedException(null);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonSerializationVisitor:findAndInvokeCustomSerializer(Lcom/google/gson/ObjectTypePair;)Lcom/google/gson/JsonElement;",
                                    "method_body": "private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) {\nPair<JsonSerializer<?>,ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers);\nif (pair == null) {\nreturn null;\n}\nJsonSerializer serializer = pair.first;\nobjTypePair = pair.second;\nstart(objTypePair);\ntry {\nJsonElement element =\nserializer.serialize(objTypePair.getObject(), objTypePair.getType(), context);\nreturn element == null ? JsonNull.createJsonNull() : element;\n} finally {\nend(objTypePair);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonSerializationVisitor:assignToRoot(Lcom/google/gson/JsonElement;)V",
                                    "method_body": "private void assignToRoot(JsonElement newRoot) {\nPreconditions.checkNotNull(newRoot);\nroot = newRoot;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeInfo:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeInfo(Type actualType) {\nthis.actualType = actualType;\nrawClass = TypeUtils.toRawClass(actualType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeInfo:getActualType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getActualType() {\nreturn actualType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeInfo:getRawClass()Ljava/lang/Class;",
                                    "method_body": "public final Class<?> getRawClass() {\nreturn rawClass;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeInfo:isArray()Z",
                                    "method_body": "public final boolean isArray() {\nreturn TypeUtils.isArray(rawClass);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeUtils:isArray(Ljava/lang/reflect/Type;)Z",
                                    "method_body": "static boolean isArray(Type type) {\nif (type instanceof Class<?>) {\nreturn ((Class<?>)type).isArray();\n} else if (type instanceof GenericArrayType) {\nreturn true;\n} else {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeUtils:toRawClass(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "static Class<?> toRawClass(Type type) {\nif (type instanceof Class<?>) {\nreturn (Class<?>) type;\n} else if (type instanceof ParameterizedType) {\nParameterizedType actualType = (ParameterizedType)type;\nreturn toRawClass(actualType.getRawType());\n} else if (type instanceof GenericArrayType) {\nGenericArrayType actualType = (GenericArrayType) type;\nClass<?> rawClass = toRawClass(actualType.getGenericComponentType());\nreturn wrapWithArray(rawClass);\n} else if (type instanceof WildcardType) {\nWildcardType castedType = (WildcardType) type;\nreturn toRawClass(castedType.getUpperBounds()[0]);\n} else {\nthrow new IllegalArgumentException(\"Type \\'\" + type + \"\\' is not a Class, \"\n+ \"ParameterizedType, or GenericArrayType. Can't extract class.\");\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeInfoFactory:getTypeInfoForField(Ljava/lang/reflect/Field;Ljava/lang/reflect/Type;)Lcom/google/gson/TypeInfo;",
                                    "method_body": "public static TypeInfo getTypeInfoForField(Field f, Type typeDefiningF) {\nClass<?> classDefiningF = TypeUtils.toRawClass(typeDefiningF);\nType type = f.getGenericType();\nType actualType = getActualType(type, typeDefiningF, classDefiningF);\nreturn new TypeInfo(actualType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeInfoFactory:getActualType(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "private static Type getActualType(\nType typeToEvaluate, Type parentType, Class<?> rawParentClass) {\nif (typeToEvaluate instanceof Class<?>) {\nreturn typeToEvaluate;\n} else if (typeToEvaluate instanceof ParameterizedType) {\nParameterizedType castedType = (ParameterizedType) typeToEvaluate;\nType owner = castedType.getOwnerType();\nType[] actualTypeParameters =\nextractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass);\nType rawType = castedType.getRawType();\nreturn new ParameterizedTypeImpl(rawType, actualTypeParameters, owner);\n} else if (typeToEvaluate instanceof GenericArrayType) {\nGenericArrayType castedType = (GenericArrayType) typeToEvaluate;\nType componentType = castedType.getGenericComponentType();\nType actualType = getActualType(componentType, parentType, rawParentClass);\nif (componentType.equals(actualType)) {\nreturn castedType;\n}\nreturn actualType instanceof Class<?> ?\nTypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType))\n: new GenericArrayTypeImpl(actualType);\n} else if (typeToEvaluate instanceof TypeVariable<?>) {\nif (parentType instanceof ParameterizedType) {\n// The class definition has the actual types used for the type variables.\n// Find the matching actual type for the Type Variable used for the field.\n// For example, class Foo<A> { A a; }\n// new Foo<Integer>(); defines the actual type of A to be Integer.\n// So, to find the type of the field a, we will have to look at the class'\n// actual type arguments.\nTypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate;\nTypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters();\nParameterizedType objParameterizedType = (ParameterizedType) parentType;\nint indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable);\nType[] actualTypeArguments = objParameterizedType.getActualTypeArguments();\nreturn actualTypeArguments[indexOfActualTypeArgument];\n\n\n}\n\nthrow new UnsupportedOperationException(\"Expecting parameterized type, got \" + parentType\n+ \".\\n Are you missing the use of TypeToken idiom?\\n See \"\n+ \"http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener\");\n} else if (typeToEvaluate instanceof WildcardType) {\nWildcardType castedType = (WildcardType) typeToEvaluate;\nreturn getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass);\n} else {\nthrow new IllegalArgumentException(\"Type \\'\" + typeToEvaluate + \"\\' is not a Class, \"\n+ \"ParameterizedType, GenericArrayType or TypeVariable. Can't extract type.\");\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 2,
                    "tests": [
                        {
                            "test_name": "com.google.gson.functional.DefaultTypeAdaptersTest.testJsonElementTypeMismatch",
                            "test_body": "621: public void testJsonElementTypeMismatch() {\n622: try {\n623: gson.fromJson(\"\\\"abc\\\"\", JsonObject.class);\n624: fail();\n625: } catch (JsonSyntaxException expected) {\n626: assertEquals(\"Expected a com.google.gson.JsonObject but was com.google.gson.JsonPrimitive\",\n627: expected.getMessage());\n628: }\n629: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\nCollections.<Type, InstanceCreator<?>>emptyMap(), false, false, DEFAULT_JSON_NON_EXECUTABLE,\ntrue, false, false, LongSerializationPolicy.DEFAULT,\nCollections.<TypeAdapterFactory>emptyList());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingPolicy,\nfinal Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,\nboolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\nboolean prettyPrinting, boolean serializeSpecialFloatingPointValues,\nLongSerializationPolicy longSerializationPolicy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\n\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n\n// built-in type adapters that cannot be overridden\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\n\n// the excluder must precede all adapters that handle user-defined types\nfactories.add(excluder);\n\n// user's type adapters\nfactories.addAll(typeAdapterFactories);\n\n// type adapters for basic platform types\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class,\nlongAdapter(longSerializationPolicy)));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\ndoubleAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfloatAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\n\n// type adapters for composite and user-defined types\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nfactories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nconstructorConstructor, fieldNamingPolicy, excluder));\n\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.DOUBLE;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Double read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\ndouble doubleValue = value.doubleValue();\ncheckValidFloatingPoint(doubleValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.FLOAT;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Float read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn (float) in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nfloat floatValue = value.floatValue();\ncheckValidFloatingPoint(floatValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Number read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextLong();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nout.value(value.toString());\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type);\nif (cached != null) {\nreturn (TypeAdapter<T>) cached;\n}\n\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\n}\n\n// the key and value type parameters always agree\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nreturn ongoingCall;\n}\n\ntry {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\n\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\n}\n}\nthrow new IllegalArgumentException(\"GSON cannot handle \" + type);\n} finally {\nthreadCalls.remove(type);\n\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException {\nObject object = fromJson(json, (Type) classOfT);\nreturn Primitives.wrap(classOfT).cast(object);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {\nif (json == null) {\nreturn null;\n}\nStringReader reader = new StringReader(json);\nT target = (T) fromJson(reader, typeOfT);\nreturn target;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/io/Reader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nJsonReader jsonReader = new JsonReader(json);\nT object = (T) fromJson(jsonReader, typeOfT);\nassertFullConsumption(object, jsonReader);\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:assertFullConsumption(Ljava/lang/Object;Lcom/google/gson/stream/JsonReader;)V",
                                    "method_body": "private static void assertFullConsumption(Object obj, JsonReader reader) {\ntry {\nif (obj != null && reader.peek() != JsonToken.END_DOCUMENT) {\nthrow new JsonIOException(\"JSON document was not fully consumed.\");\n}\n} catch (MalformedJsonException e) {\nthrow new JsonSyntaxException(e);\n} catch (IOException e) {\nthrow new JsonIOException(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Lcom/google/gson/stream/JsonReader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nboolean isEmpty = true;\nboolean oldLenient = reader.isLenient();\nreader.setLenient(true);\ntry {\nreader.peek();\nisEmpty = false;\nTypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\nTypeAdapter<T> typeAdapter = getAdapter(typeToken);\nT object = typeAdapter.read(reader);\nreturn object;\n} catch (EOFException e) {\n/*\n* For compatibility with JSON 1.5 and earlier, we return null for empty\n* documents instead of throwing.\n*/\nif (isEmpty) {\nreturn null;\n}\nthrow new JsonSyntaxException(e);\n} catch (IllegalStateException e) {\nthrow new JsonSyntaxException(e);\n} catch (IOException e) {\n// TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException\nthrow new JsonSyntaxException(e);\n} finally {\nreader.setLenient(oldLenient);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\n\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate boolean requireExpose;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n\n@Override protected Excluder clone() {\ntry {\nreturn (Excluder) super.clone();\n} catch (CloneNotSupportedException e) {\nthrow new AssertionError();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n@Override\npublic void write(JsonWriter out, Class value) throws IOException {\nif (value == null) {\nout.nullValue();\n} else {\nthrow new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n+ value.getName() + \". Forgot to register a type adapter?\");\n}\n}\n@Override\npublic Class read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n} else {\nthrow new UnsupportedOperationException(\n\"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n}\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\npublic <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\npublic <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\npublic <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\npublic <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) typeAdapter;\n\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$31:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\npublic <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) typeAdapter;\n\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$25:read(Lcom/google/gson/stream/JsonReader;)Lcom/google/gson/JsonElement;",
                                    "method_body": "@Override public JsonElement read(JsonReader in) throws IOException {\nswitch (in.peek()) {\ncase STRING:\nreturn new JsonPrimitive(in.nextString());\ncase NUMBER:\nString number = in.nextString();\nreturn new JsonPrimitive(new LazilyParsedNumber(number));\ncase BOOLEAN:\nreturn new JsonPrimitive(in.nextBoolean());\ncase NULL:\nin.nextNull();\nreturn JsonNull.INSTANCE;\ncase BEGIN_ARRAY:\nJsonArray array = new JsonArray();\nin.beginArray();\nwhile (in.hasNext()) {\narray.add(read(in));\n}\nin.endArray();\nreturn array;\ncase BEGIN_OBJECT:\nJsonObject object = new JsonObject();\nin.beginObject();\nwhile (in.hasNext()) {\nobject.add(in.nextName(), read(in));\n}\nin.endObject();\nreturn object;\ncase END_DOCUMENT:\ncase NAME:\ncase END_OBJECT:\ncase END_ARRAY:\ndefault:\nthrow new IllegalArgumentException();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\npublic <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\npublic <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\npublic <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\npublic <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nFieldNamingStrategy fieldNamingPolicy, Excluder excluder) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "public JsonReader(Reader in) {\nif (in == null) {\nthrow new NullPointerException(\"in == null\");\n}\nthis.in = in;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<clinit>()V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;\n\nprivate static final int PEEKED_NONE = 0;\nprivate static final int PEEKED_BEGIN_OBJECT = 1;\nprivate static final int PEEKED_END_OBJECT = 2;\nprivate static final int PEEKED_BEGIN_ARRAY = 3;\nprivate static final int PEEKED_END_ARRAY = 4;\nprivate static final int PEEKED_TRUE = 5;\nprivate static final int PEEKED_FALSE = 6;\nprivate static final int PEEKED_NULL = 7;\nprivate static final int PEEKED_SINGLE_QUOTED = 8;\nprivate static final int PEEKED_DOUBLE_QUOTED = 9;\nprivate static final int PEEKED_UNQUOTED = 10;\n/** When this is returned, the string value is stored in peekedString. */\nprivate static final int PEEKED_BUFFERED = 11;\nprivate static final int PEEKED_SINGLE_QUOTED_NAME = 12;\nprivate static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\nprivate static final int PEEKED_UNQUOTED_NAME = 14;\n/** When this is returned, the integer value is stored in peekedLong. */\nprivate static final int PEEKED_LONG = 15;\nprivate static final int PEEKED_NUMBER = 16;\nprivate static final int PEEKED_EOF = 17;\n\n/* State machine when parsing numbers */\nprivate static final int NUMBER_CHAR_NONE = 0;\nprivate static final int NUMBER_CHAR_SIGN = 1;\nprivate static final int NUMBER_CHAR_DIGIT = 2;\nprivate static final int NUMBER_CHAR_DECIMAL = 3;\nprivate static final int NUMBER_CHAR_FRACTION_DIGIT = 4;\nprivate static final int NUMBER_CHAR_EXP_E = 5;\nprivate static final int NUMBER_CHAR_EXP_SIGN = 6;\nprivate static final int NUMBER_CHAR_EXP_DIGIT = 7;\n\n/** The input JSON. */\nprivate final Reader in;\n\n/** True to accept non-spec compliant JSON */\nprivate boolean lenient = false;\n\n/**\n* Use a manual buffer to easily read and unread upcoming characters, and\n* also so we can create strings without an intermediate StringBuilder.\n* We decode literals directly out of this buffer, so it must be at least as\n* long as the longest token that can be reported as a number.\n*/\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\n\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\n\nprivate int peeked = PEEKED_NONE;\n\n/**\n* A peeked value that was composed entirely of digits with an optional\n* leading dash. Positive values may not have a leading 0.\n*/\nprivate long peekedLong;\n\n/**\n* The number of characters in a peeked number literal. Increment 'pos' by\n* this after reading a number.\n*/\nprivate int peekedNumberLength;\n\n/**\n* A peeked string that should be parsed on the next double, long or string.\n* This is populated before a numeric value is parsed and used if that parsing\n* fails.\n*/\nprivate String peekedString;\n\n/*\n* The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n*/\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\n{\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:setLenient(Z)V",
                                    "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:isLenient()Z",
                                    "method_body": "public final boolean isLenient() {\nreturn lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\n\nswitch (p) {\ncase PEEKED_BEGIN_OBJECT:\nreturn JsonToken.BEGIN_OBJECT;\ncase PEEKED_END_OBJECT:\nreturn JsonToken.END_OBJECT;\ncase PEEKED_BEGIN_ARRAY:\nreturn JsonToken.BEGIN_ARRAY;\ncase PEEKED_END_ARRAY:\nreturn JsonToken.END_ARRAY;\ncase PEEKED_SINGLE_QUOTED_NAME:\ncase PEEKED_DOUBLE_QUOTED_NAME:\ncase PEEKED_UNQUOTED_NAME:\nreturn JsonToken.NAME;\ncase PEEKED_TRUE:\ncase PEEKED_FALSE:\nreturn JsonToken.BOOLEAN;\ncase PEEKED_NULL:\nreturn JsonToken.NULL;\ncase PEEKED_SINGLE_QUOTED:\ncase PEEKED_DOUBLE_QUOTED:\ncase PEEKED_UNQUOTED:\ncase PEEKED_BUFFERED:\nreturn JsonToken.STRING;\ncase PEEKED_LONG:\ncase PEEKED_NUMBER:\nreturn JsonToken.NUMBER;\ncase PEEKED_EOF:\nreturn JsonToken.END_DOCUMENT;\ndefault:\nthrow new AssertionError();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:doPeek()I",
                                    "method_body": "private int doPeek() throws IOException {\nint peekStack = stack[stackSize - 1];\nif (peekStack == JsonScope.EMPTY_ARRAY) {\nstack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n} else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n// Look for a comma before the next element.\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase ']':\nreturn peeked = PEEKED_END_ARRAY;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated array\");\n}\n} else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\nstack[stackSize - 1] = JsonScope.DANGLING_NAME;\n// Look for a comma before the next element.\nif (peekStack == JsonScope.NONEMPTY_OBJECT) {\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '}':\nreturn peeked = PEEKED_END_OBJECT;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated object\");\n}\n}\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '\"':\nreturn peeked = PEEKED_DOUBLE_QUOTED_NAME;\ncase '\\'':\ncheckLenient();\nreturn peeked = PEEKED_SINGLE_QUOTED_NAME;\ncase '}':\nif (peekStack != JsonScope.NONEMPTY_OBJECT) {\nreturn peeked = PEEKED_END_OBJECT;\n} else {\nthrow syntaxError(\"Expected name\");\n}\ndefault:\ncheckLenient();\npos--; // Don't consume the first character in an unquoted string.\nif (isLiteral((char) c)) {\nreturn peeked = PEEKED_UNQUOTED_NAME;\n} else {\nthrow syntaxError(\"Expected name\");\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextString()Ljava/lang/String;",
                                    "method_body": "public String nextString() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nString result;\nif (p == PEEKED_UNQUOTED) {\nresult = nextUnquotedValue();\n} else if (p == PEEKED_SINGLE_QUOTED) {\nresult = nextQuotedValue('\\'');\n} else if (p == PEEKED_DOUBLE_QUOTED) {\nresult = nextQuotedValue('\"');\n} else if (p == PEEKED_BUFFERED) {\nresult = peekedString;\npeekedString = null;\n} else if (p == PEEKED_LONG) {\nresult = Long.toString(peekedLong);\n} else if (p == PEEKED_NUMBER) {\nresult = new String(buffer, pos, peekedNumberLength);\npos += peekedNumberLength;\n} else {\nthrow new IllegalStateException(\"Expected a string but was \" + peek()\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextQuotedValue(C)Ljava/lang/String;",
                                    "method_body": "private String nextQuotedValue(char quote) throws IOException {\n// Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\nchar[] buffer = this.buffer;\nStringBuilder builder = new StringBuilder();\nwhile (true) {\nint p = pos;\nint l = limit;\n/* the index of the first character not yet appended to the builder. */\nint start = p;\nwhile (p < l) {\nint c = buffer[p++];\n\nif (c == quote) {\npos = p;\nbuilder.append(buffer, start, p - start - 1);\nreturn builder.toString();\n} else if (c == '\\\\') {\npos = p;\nbuilder.append(buffer, start, p - start - 1);\nbuilder.append(readEscapeCharacter());\np = pos;\nl = limit;\nstart = p;\n} else if (c == '\\n') {\nlineNumber++;\nlineStart = p;\n}\n}\n\nbuilder.append(buffer, start, p - start);\npos = p;\nif (!fillBuffer(1)) {\nthrow syntaxError(\"Unterminated string\");\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit -= pos;\nSystem.arraycopy(buffer, pos, buffer, 0, limit);\n} else {\nlimit = 0;\n}\n\npos = 0;\nint total;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\n\n// if this is the first read, consume an optional byte order mark (BOM) if it exists\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\npos++;\nlineStart++;\nminimum++;\n}\n\nif (limit >= minimum) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n/*\n* This code uses ugly local variables 'p' and 'l' representing the 'pos'\n* and 'limit' fields respectively. Using locals rather than fields saves\n* a few field reads for each whitespace character in a pretty-printed\n* document, resulting in a 5% speedup. We need to flush 'p' to its field\n* before any (potentially indirect) call to fillBuffer() and reread both\n* 'p' and 'l' after any (potentially indirect) call to the same method.\n*/\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nwhile (true) {\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\nbreak;\n}\np = pos;\nl = limit;\n}\n\nint c = buffer[p++];\nif (c == '\\n') {\nlineNumber++;\nlineStart = p;\ncontinue;\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\ncontinue;\n}\n\nif (c == '/') {\npos = p;\nif (p == l) {\npos--; // push back '/' so it's still in the buffer when this method returns\nboolean charsLoaded = fillBuffer(2);\npos++; // consume the '/' again\nif (!charsLoaded) {\nreturn c;\n}\n}\n\ncheckLenient();\nchar peek = buffer[pos];\nswitch (peek) {\ncase '*':\n// skip a /* c-style comment */\npos++;\nif (!skipTo(\"*/\")) {\nthrow syntaxError(\"Unterminated comment\");\n}\np = pos + 2;\nl = limit;\ncontinue;\n\ncase '/':\n// skip a // end-of-line comment\npos++;\nskipToEndOfLine();\np = pos;\nl = limit;\ncontinue;\n\ndefault:\nreturn c;\n}\n} else if (c == '#') {\npos = p;\n/*\n* Skip a # hash end-of-line comment. The JSON RFC doesn't\n* specify this behaviour, but it's required to parse\n* existing documents. See http://b/2571423.\n*/\ncheckLenient();\nskipToEndOfLine();\np = pos;\nl = limit;\n} else {\npos = p;\nreturn c;\n}\n}\nif (throwOnEof) {\nthrow new EOFException(\"End of input\"\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n} else {\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:checkLenient()V",
                                    "method_body": "private void checkLenient() throws IOException {\nif (!lenient) {\nthrow syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\");\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:consumeNonExecutePrefix()V",
                                    "method_body": "private void consumeNonExecutePrefix() throws IOException {\n// fast forward through the leading whitespace\nnextNonWhitespace(true);\npos--;\n\nif (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\nreturn;\n}\n\nfor (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\nif (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\nreturn; // not a security token!\n}\n}\n\n// we consumed a security token!\npos += NON_EXECUTE_PREFIX.length;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:<clinit>()V",
                                    "method_body": "public BitSet read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\n\nBitSet bitset = new BitSet();\nin.beginArray();\nint i = 0;\nJsonToken tokenType = in.peek();\nwhile (tokenType != JsonToken.END_ARRAY) {\nboolean set;\nswitch (tokenType) {\ncase NUMBER:\nset = in.nextInt() != 0;\nbreak;\ncase BOOLEAN:\nset = in.nextBoolean();\nbreak;\ncase STRING:\nString stringValue = in.nextString();\ntry {\nset = Integer.parseInt(stringValue) != 0;\n} catch (NumberFormatException e) {\nthrow new JsonSyntaxException(\n\"Error: Expecting: bitset number value (1, 0), Found: \" + stringValue);\n}\nbreak;\ndefault:\nthrow new JsonSyntaxException(\"Invalid bitset value type: \" + tokenType);\n}\nif (set) {\nbitset.set(i);\n}\n++i;\ntokenType = in.peek();\n}\nin.endArray();\nreturn bitset;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:<init>(Ljava/lang/String;)V",
                                    "method_body": "public JsonPrimitive(String string) {\nsetValue(string);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:<clinit>()V",
                                    "method_body": "private static final Class<?>[] PRIMITIVE_TYPES = { int.class, long.class, short.class,\nfloat.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class,\nShort.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class };"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:setValue(Ljava/lang/Object;)V",
                                    "method_body": "void setValue(Object primitive) {\nif (primitive instanceof Character) {\n// convert characters to strings since in JSON, characters are represented as a single\n// character string\nchar c = ((Character) primitive).charValue();\nthis.value = String.valueOf(c);\n} else {\n$Gson$Preconditions.checkArgument(primitive instanceof Number\n|| isPrimitiveOrString(primitive));\nthis.value = primitive;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:isPrimitiveOrString(Ljava/lang/Object;)Z",
                                    "method_body": "private static boolean isPrimitiveOrString(Object target) {\nif (target instanceof String) {\nreturn true;\n}\n\nClass<?> classOfPrimitive = target.getClass();\nfor (Class<?> standardPrimitive : PRIMITIVE_TYPES) {\nif (standardPrimitive.isAssignableFrom(classOfPrimitive)) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nthrow new NullPointerException();\n}\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\nthrow new IllegalArgumentException();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\np.getRawType(), p.getActualTypeArguments());\n\n} else if (type instanceof GenericArrayType) {\nGenericArrayType g = (GenericArrayType) type;\nreturn new GenericArrayTypeImpl(g.getGenericComponentType());\n\n} else if (type instanceof WildcardType) {\nWildcardType w = (WildcardType) type;\nreturn new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n} else {\n// type is either serializable as-is or unsupported\nreturn type;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\n// type is a normal class.\nreturn (Class<?>) type;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType parameterizedType = (ParameterizedType) type;\n\n// I'm not exactly sure why getRawType() returns Type instead of Class.\n// Neal isn't either but suspects some pathological case related\n// to nested classes exists.\nType rawType = parameterizedType.getRawType();\ncheckArgument(rawType instanceof Class);\nreturn (Class<?>) rawType;\n\n} else if (type instanceof GenericArrayType) {\nType componentType = ((GenericArrayType)type).getGenericComponentType();\nreturn Array.newInstance(getRawType(componentType), 0).getClass();\n\n} else if (type instanceof TypeVariable) {\n// we could use the variable's bounds, but that won't work if there are multiple.\n// having a raw type that's more general than necessary is okay\nreturn Object.class;\n\n} else if (type instanceof WildcardType) {\nreturn getRawType(((WildcardType) type).getUpperBounds()[0]);\n\n} else {\nString className = type == null ? \"null\" : type.getClass().getName();\nthrow new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n+ \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson$FutureTypeAdapter:setDelegate(Lcom/google/gson/TypeAdapter;)V",
                                    "method_body": "public void setDelegate(TypeAdapter<T> typeAdapter) {\nif (delegate != null) {\nthrow new AssertionError();\n}\ndelegate = typeAdapter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:<clinit>()V",
                                    "method_body": "private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;\n\n/** A map from wrapper types to their corresponding primitive types. */\nprivate static final Map<Class<?>, Class<?>> WRAPPER_TO_PRIMITIVE_TYPE;\n\n// Sad that we can't use a BiMap. :(\n\nstatic {\nMap<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);\nMap<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);\n\nadd(primToWrap, wrapToPrim, boolean.class, Boolean.class);\nadd(primToWrap, wrapToPrim, byte.class, Byte.class);\nadd(primToWrap, wrapToPrim, char.class, Character.class);\nadd(primToWrap, wrapToPrim, double.class, Double.class);\nadd(primToWrap, wrapToPrim, float.class, Float.class);\nadd(primToWrap, wrapToPrim, int.class, Integer.class);\nadd(primToWrap, wrapToPrim, long.class, Long.class);\nadd(primToWrap, wrapToPrim, short.class, Short.class);\nadd(primToWrap, wrapToPrim, void.class, Void.class);\n\nPRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);\nWRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:add(Ljava/util/Map;Ljava/util/Map;Ljava/lang/Class;Ljava/lang/Class;)V",
                                    "method_body": "private static void add(Map<Class<?>, Class<?>> forward,\nMap<Class<?>, Class<?>> backward, Class<?> key, Class<?> value) {\nforward.put(key, value);\nbackward.put(value, key);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:wrap(Ljava/lang/Class;)Ljava/lang/Class;",
                                    "method_body": "public static <T> Class<T> wrap(Class<T> type) {\n// cast is safe: long.class and Long.class are both of type Class<Long>\n@SuppressWarnings(\"unchecked\")\nClass<T> wrapped = (Class<T>) PRIMITIVE_TO_WRAPPER_TYPE.get(\n$Gson$Preconditions.checkNotNull(type));\nreturn (wrapped == null) ? type : wrapped;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 3,
                    "tests": [
                        {
                            "test_name": "com.google.gson.functional.MapTest.testConcurrentMap",
                            "test_body": "186: public void testConcurrentMap() throws Exception {\n187: Type typeOfMap = new TypeToken<ConcurrentMap<Integer, String>>() {}.getType();\n188: ConcurrentMap<Integer, String> map = gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\n189: assertEquals(1, map.size());\n190: assertTrue(map.containsKey(123));\n191: assertEquals(\"456\", map.get(123));\n192: String json = gson.toJson(map);\n193: assertEquals(\"{\\\"123\\\":\\\"456\\\"}\", json);\n194: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\nCollections.<Type, InstanceCreator<?>>emptyMap(), false, false, DEFAULT_JSON_NON_EXECUTABLE,\ntrue, false, false, LongSerializationPolicy.DEFAULT,\nCollections.<TypeAdapterFactory>emptyList());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingPolicy,\nfinal Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,\nboolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\nboolean prettyPrinting, boolean serializeSpecialFloatingPointValues,\nLongSerializationPolicy longSerializationPolicy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\n\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n\n// built-in type adapters that cannot be overridden\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\n\n// the excluder must precede all adapters that handle user-defined types\nfactories.add(excluder);\n\n// user's type adapters\nfactories.addAll(typeAdapterFactories);\n\n// type adapters for basic platform types\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class,\nlongAdapter(longSerializationPolicy)));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\ndoubleAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfloatAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\n\n// type adapters for composite and user-defined types\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nfactories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nconstructorConstructor, fieldNamingPolicy, excluder));\n\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.DOUBLE;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Double read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\ndouble doubleValue = value.doubleValue();\ncheckValidFloatingPoint(doubleValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.FLOAT;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Float read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn (float) in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nfloat floatValue = value.floatValue();\ncheckValidFloatingPoint(floatValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Number read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextLong();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nout.value(value.toString());\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type);\nif (cached != null) {\nreturn (TypeAdapter<T>) cached;\n}\n\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\n}\n\n// the key and value type parameters always agree\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nreturn ongoingCall;\n}\n\ntry {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\n\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\n}\n}\nthrow new IllegalArgumentException(\"GSON cannot handle \" + type);\n} finally {\nthreadCalls.remove(type);\n\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {\nif (json == null) {\nreturn null;\n}\nStringReader reader = new StringReader(json);\nT target = (T) fromJson(reader, typeOfT);\nreturn target;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/io/Reader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nJsonReader jsonReader = new JsonReader(json);\nT object = (T) fromJson(jsonReader, typeOfT);\nassertFullConsumption(object, jsonReader);\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:assertFullConsumption(Ljava/lang/Object;Lcom/google/gson/stream/JsonReader;)V",
                                    "method_body": "private static void assertFullConsumption(Object obj, JsonReader reader) {\ntry {\nif (obj != null && reader.peek() != JsonToken.END_DOCUMENT) {\nthrow new JsonIOException(\"JSON document was not fully consumed.\");\n}\n} catch (MalformedJsonException e) {\nthrow new JsonSyntaxException(e);\n} catch (IOException e) {\nthrow new JsonIOException(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Lcom/google/gson/stream/JsonReader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nboolean isEmpty = true;\nboolean oldLenient = reader.isLenient();\nreader.setLenient(true);\ntry {\nreader.peek();\nisEmpty = false;\nTypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\nTypeAdapter<T> typeAdapter = getAdapter(typeToken);\nT object = typeAdapter.read(reader);\nreturn object;\n} catch (EOFException e) {\n/*\n* For compatibility with JSON 1.5 and earlier, we return null for empty\n* documents instead of throwing.\n*/\nif (isEmpty) {\nreturn null;\n}\nthrow new JsonSyntaxException(e);\n} catch (IllegalStateException e) {\nthrow new JsonSyntaxException(e);\n} catch (IOException e) {\n// TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException\nthrow new JsonSyntaxException(e);\n} finally {\nreader.setLenient(oldLenient);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\n\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate boolean requireExpose;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n\n@Override protected Excluder clone() {\ntry {\nreturn (Excluder) super.clone();\n} catch (CloneNotSupportedException e) {\nthrow new AssertionError();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\n\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}\n\nreturn new TypeAdapter<T>() {\n/** The delegate is lazily created because it may not be needed, and creating it may fail. */\nprivate TypeAdapter<T> delegate;\n\n@Override public T read(JsonReader in) throws IOException {\nif (skipDeserialize) {\nin.skipValue();\nreturn null;\n}\nreturn delegate().read(in);\n}\n\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (skipSerialize) {\nout.nullValue();\nreturn;\n}\ndelegate().write(out, value);\n}\n\nprivate TypeAdapter<T> delegate() {\nTypeAdapter<T> d = delegate;\nreturn d != null\n? d\n: (delegate = gson.getDelegateAdapter(Excluder.this, type));\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\n&& !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\nreturn true;\n}\n\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nreturn true;\n}\n\nif (isAnonymousOrLocal(clazz)) {\nreturn true;\n}\n\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nif (exclusionStrategy.shouldSkipClass(clazz)) {\nreturn true;\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n&& (clazz.isAnonymousClass() || clazz.isLocalClass());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\n\n// first try an instance creator\n\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn typeCreator.createInstance(type);\n}\n};\n}\n\n// Next try raw type match for instance creators\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> rawTypeCreator =\n(InstanceCreator<T>) instanceCreators.get(rawType);\nif (rawTypeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn rawTypeCreator.createInstance(type);\n}\n};\n}\n\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nreturn defaultConstructor;\n}\n\nObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\nif (defaultImplementation != null) {\nreturn defaultImplementation;\n}\n\n// finally try unsafe\nreturn newUnsafeAllocator(type, rawType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultConstructor(Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\ntry {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\n}\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"unchecked\") // T is the same raw type as is requested\n@Override public T construct() {\ntry {\nObject[] args = null;\nreturn (T) constructor.newInstance(args);\n} catch (InstantiationException e) {\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\", e);\n} catch (InvocationTargetException e) {\n// TODO: don't wrap if cause is unchecked!\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",\ne.getTargetException());\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\n}\n};\n} catch (NoSuchMethodException e) {\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultImplementationConstructor(Ljava/lang/reflect/Type;Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nfinal Type type, Class<? super T> rawType) {\nif (Collection.class.isAssignableFrom(rawType)) {\nif (SortedSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeSet<Object>();\n}\n};\n} else if (EnumSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"rawtypes\")\n@Override public T construct() {\nif (type instanceof ParameterizedType) {\nType elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\nif (elementType instanceof Class) {\nreturn (T) EnumSet.noneOf((Class)elementType);\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n}\n};\n} else if (Set.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashSet<Object>();\n}\n};\n} else if (Queue.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedList<Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ArrayList<Object>();\n}\n};\n}\n}\n\nif (Map.class.isAssignableFrom(rawType)) {\nif (SortedMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeMap<Object, Object>();\n}\n};\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nTypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashMap<Object, Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedTreeMap<String, Object>();\n}\n};\n}\n}\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n@Override\npublic void write(JsonWriter out, Class value) throws IOException {\nif (value == null) {\nout.nullValue();\n} else {\nthrow new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n+ value.getName() + \". Forgot to register a type adapter?\");\n}\n}\n@Override\npublic Class read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n} else {\nthrow new UnsupportedOperationException(\n\"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n}\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$28:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$29:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$7:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Number;",
                                    "method_body": "public Number read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\ntry {\nreturn in.nextInt();\n} catch (NumberFormatException e) {\nthrow new JsonSyntaxException(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$13:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/String;",
                                    "method_body": "public String read(JsonReader in) throws IOException {\nJsonToken peek = in.peek();\nif (peek == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\n/* coerce booleans to strings for backwards compatibility */\nif (peek == JsonToken.BOOLEAN) {\nreturn Boolean.toString(in.nextBoolean());\n}\nreturn in.nextString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$31:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$22:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}\n\nfinal TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\nreturn (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n@Override public Timestamp read(JsonReader in) throws IOException {\nDate date = dateTypeAdapter.read(in);\nreturn date != null ? new Timestamp(date.getTime()) : null;\n}\n\n@Override public void write(JsonWriter out, Timestamp value) throws IOException {\ndateTypeAdapter.write(out, value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$30:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nType elementType = $Gson$Types.getCollectionElementType(type, rawType);\nTypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // create() doesn't define a type parameter\nTypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nClass<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\nType[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\nTypeAdapter<?> keyAdapter = getKeyAdapter(gson, keyAndValueTypes[0]);\nTypeAdapter<?> valueAdapter = gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n// we don't define a type parameter for the key or value types\nTypeAdapter<T> result = new Adapter(gson, keyAndValueTypes[0], keyAdapter,\nkeyAndValueTypes[1], valueAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:getKeyAdapter(Lcom/google/gson/Gson;Ljava/lang/reflect/Type;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<?> getKeyAdapter(Gson context, Type keyType) {\nreturn (keyType == boolean.class || keyType == Boolean.class)\n? TypeAdapters.BOOLEAN_AS_STRING\n: context.getAdapter(TypeToken.get(keyType));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nFieldNamingStrategy fieldNamingPolicy, Excluder excluder) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "public JsonReader(Reader in) {\nif (in == null) {\nthrow new NullPointerException(\"in == null\");\n}\nthis.in = in;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<clinit>()V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;\n\nprivate static final int PEEKED_NONE = 0;\nprivate static final int PEEKED_BEGIN_OBJECT = 1;\nprivate static final int PEEKED_END_OBJECT = 2;\nprivate static final int PEEKED_BEGIN_ARRAY = 3;\nprivate static final int PEEKED_END_ARRAY = 4;\nprivate static final int PEEKED_TRUE = 5;\nprivate static final int PEEKED_FALSE = 6;\nprivate static final int PEEKED_NULL = 7;\nprivate static final int PEEKED_SINGLE_QUOTED = 8;\nprivate static final int PEEKED_DOUBLE_QUOTED = 9;\nprivate static final int PEEKED_UNQUOTED = 10;\n/** When this is returned, the string value is stored in peekedString. */\nprivate static final int PEEKED_BUFFERED = 11;\nprivate static final int PEEKED_SINGLE_QUOTED_NAME = 12;\nprivate static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\nprivate static final int PEEKED_UNQUOTED_NAME = 14;\n/** When this is returned, the integer value is stored in peekedLong. */\nprivate static final int PEEKED_LONG = 15;\nprivate static final int PEEKED_NUMBER = 16;\nprivate static final int PEEKED_EOF = 17;\n\n/* State machine when parsing numbers */\nprivate static final int NUMBER_CHAR_NONE = 0;\nprivate static final int NUMBER_CHAR_SIGN = 1;\nprivate static final int NUMBER_CHAR_DIGIT = 2;\nprivate static final int NUMBER_CHAR_DECIMAL = 3;\nprivate static final int NUMBER_CHAR_FRACTION_DIGIT = 4;\nprivate static final int NUMBER_CHAR_EXP_E = 5;\nprivate static final int NUMBER_CHAR_EXP_SIGN = 6;\nprivate static final int NUMBER_CHAR_EXP_DIGIT = 7;\n\n/** The input JSON. */\nprivate final Reader in;\n\n/** True to accept non-spec compliant JSON */\nprivate boolean lenient = false;\n\n/**\n* Use a manual buffer to easily read and unread upcoming characters, and\n* also so we can create strings without an intermediate StringBuilder.\n* We decode literals directly out of this buffer, so it must be at least as\n* long as the longest token that can be reported as a number.\n*/\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\n\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\n\nprivate int peeked = PEEKED_NONE;\n\n/**\n* A peeked value that was composed entirely of digits with an optional\n* leading dash. Positive values may not have a leading 0.\n*/\nprivate long peekedLong;\n\n/**\n* The number of characters in a peeked number literal. Increment 'pos' by\n* this after reading a number.\n*/\nprivate int peekedNumberLength;\n\n/**\n* A peeked string that should be parsed on the next double, long or string.\n* This is populated before a numeric value is parsed and used if that parsing\n* fails.\n*/\nprivate String peekedString;\n\n/*\n* The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n*/\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\n{\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:setLenient(Z)V",
                                    "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:isLenient()Z",
                                    "method_body": "public final boolean isLenient() {\nreturn lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:beginObject()V",
                                    "method_body": "public void beginObject() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nif (p == PEEKED_BEGIN_OBJECT) {\npush(JsonScope.EMPTY_OBJECT);\npeeked = PEEKED_NONE;\n} else {\nthrow new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek()\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:endObject()V",
                                    "method_body": "public void endObject() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nif (p == PEEKED_END_OBJECT) {\nstackSize--;\npathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!\npathIndices[stackSize - 1]++;\npeeked = PEEKED_NONE;\n} else {\nthrow new IllegalStateException(\"Expected END_OBJECT but was \" + peek()\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:hasNext()Z",
                                    "method_body": "public boolean hasNext() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nreturn p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\n\nswitch (p) {\ncase PEEKED_BEGIN_OBJECT:\nreturn JsonToken.BEGIN_OBJECT;\ncase PEEKED_END_OBJECT:\nreturn JsonToken.END_OBJECT;\ncase PEEKED_BEGIN_ARRAY:\nreturn JsonToken.BEGIN_ARRAY;\ncase PEEKED_END_ARRAY:\nreturn JsonToken.END_ARRAY;\ncase PEEKED_SINGLE_QUOTED_NAME:\ncase PEEKED_DOUBLE_QUOTED_NAME:\ncase PEEKED_UNQUOTED_NAME:\nreturn JsonToken.NAME;\ncase PEEKED_TRUE:\ncase PEEKED_FALSE:\nreturn JsonToken.BOOLEAN;\ncase PEEKED_NULL:\nreturn JsonToken.NULL;\ncase PEEKED_SINGLE_QUOTED:\ncase PEEKED_DOUBLE_QUOTED:\ncase PEEKED_UNQUOTED:\ncase PEEKED_BUFFERED:\nreturn JsonToken.STRING;\ncase PEEKED_LONG:\ncase PEEKED_NUMBER:\nreturn JsonToken.NUMBER;\ncase PEEKED_EOF:\nreturn JsonToken.END_DOCUMENT;\ndefault:\nthrow new AssertionError();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:doPeek()I",
                                    "method_body": "private int doPeek() throws IOException {\nint peekStack = stack[stackSize - 1];\nif (peekStack == JsonScope.EMPTY_ARRAY) {\nstack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n} else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n// Look for a comma before the next element.\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase ']':\nreturn peeked = PEEKED_END_ARRAY;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated array\");\n}\n} else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\nstack[stackSize - 1] = JsonScope.DANGLING_NAME;\n// Look for a comma before the next element.\nif (peekStack == JsonScope.NONEMPTY_OBJECT) {\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '}':\nreturn peeked = PEEKED_END_OBJECT;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated object\");\n}\n}\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '\"':\nreturn peeked = PEEKED_DOUBLE_QUOTED_NAME;\ncase '\\'':\ncheckLenient();\nreturn peeked = PEEKED_SINGLE_QUOTED_NAME;\ncase '}':\nif (peekStack != JsonScope.NONEMPTY_OBJECT) {\nreturn peeked = PEEKED_END_OBJECT;\n} else {\nthrow syntaxError(\"Expected name\");\n}\ndefault:\ncheckLenient();\npos--; // Don't consume the first character in an unquoted string.\nif (isLiteral((char) c)) {\nreturn peeked = PEEKED_UNQUOTED_NAME;\n} else {\nthrow syntaxError(\"Expected name\");\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextString()Ljava/lang/String;",
                                    "method_body": "public String nextString() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nString result;\nif (p == PEEKED_UNQUOTED) {\nresult = nextUnquotedValue();\n} else if (p == PEEKED_SINGLE_QUOTED) {\nresult = nextQuotedValue('\\'');\n} else if (p == PEEKED_DOUBLE_QUOTED) {\nresult = nextQuotedValue('\"');\n} else if (p == PEEKED_BUFFERED) {\nresult = peekedString;\npeekedString = null;\n} else if (p == PEEKED_LONG) {\nresult = Long.toString(peekedLong);\n} else if (p == PEEKED_NUMBER) {\nresult = new String(buffer, pos, peekedNumberLength);\npos += peekedNumberLength;\n} else {\nthrow new IllegalStateException(\"Expected a string but was \" + peek()\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextQuotedValue(C)Ljava/lang/String;",
                                    "method_body": "private String nextQuotedValue(char quote) throws IOException {\n// Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\nchar[] buffer = this.buffer;\nStringBuilder builder = new StringBuilder();\nwhile (true) {\nint p = pos;\nint l = limit;\n/* the index of the first character not yet appended to the builder. */\nint start = p;\nwhile (p < l) {\nint c = buffer[p++];\n\nif (c == quote) {\npos = p;\nbuilder.append(buffer, start, p - start - 1);\nreturn builder.toString();\n} else if (c == '\\\\') {\npos = p;\nbuilder.append(buffer, start, p - start - 1);\nbuilder.append(readEscapeCharacter());\np = pos;\nl = limit;\nstart = p;\n} else if (c == '\\n') {\nlineNumber++;\nlineStart = p;\n}\n}\n\nbuilder.append(buffer, start, p - start);\npos = p;\nif (!fillBuffer(1)) {\nthrow syntaxError(\"Unterminated string\");\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextInt()I",
                                    "method_body": "public int nextInt() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\n\nint result;\nif (p == PEEKED_LONG) {\nresult = (int) peekedLong;\nif (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\nthrow new NumberFormatException(\"Expected an int but was \" + peekedLong\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n}\n\nif (p == PEEKED_NUMBER) {\npeekedString = new String(buffer, pos, peekedNumberLength);\npos += peekedNumberLength;\n} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\npeekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\ntry {\nresult = Integer.parseInt(peekedString);\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n} catch (NumberFormatException ignored) {\n// Fall back to parse as a double below.\n}\n} else {\nthrow new IllegalStateException(\"Expected an int but was \" + peek()\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}\n\npeeked = PEEKED_BUFFERED;\ndouble asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\nresult = (int) asDouble;\nif (result != asDouble) { // Make sure no precision was lost casting to 'int'.\nthrow new NumberFormatException(\"Expected an int but was \" + peekedString\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}\npeekedString = null;\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:push(I)V",
                                    "method_body": "private void push(int newTop) {\nif (stackSize == stack.length) {\nint[] newStack = new int[stackSize * 2];\nint[] newPathIndices = new int[stackSize * 2];\nString[] newPathNames = new String[stackSize * 2];\nSystem.arraycopy(stack, 0, newStack, 0, stackSize);\nSystem.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\nSystem.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\nstack = newStack;\npathIndices = newPathIndices;\npathNames = newPathNames;\n}\nstack[stackSize++] = newTop;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit -= pos;\nSystem.arraycopy(buffer, pos, buffer, 0, limit);\n} else {\nlimit = 0;\n}\n\npos = 0;\nint total;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\n\n// if this is the first read, consume an optional byte order mark (BOM) if it exists\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\npos++;\nlineStart++;\nminimum++;\n}\n\nif (limit >= minimum) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n/*\n* This code uses ugly local variables 'p' and 'l' representing the 'pos'\n* and 'limit' fields respectively. Using locals rather than fields saves\n* a few field reads for each whitespace character in a pretty-printed\n* document, resulting in a 5% speedup. We need to flush 'p' to its field\n* before any (potentially indirect) call to fillBuffer() and reread both\n* 'p' and 'l' after any (potentially indirect) call to the same method.\n*/\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nwhile (true) {\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\nbreak;\n}\np = pos;\nl = limit;\n}\n\nint c = buffer[p++];\nif (c == '\\n') {\nlineNumber++;\nlineStart = p;\ncontinue;\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\ncontinue;\n}\n\nif (c == '/') {\npos = p;\nif (p == l) {\npos--; // push back '/' so it's still in the buffer when this method returns\nboolean charsLoaded = fillBuffer(2);\npos++; // consume the '/' again\nif (!charsLoaded) {\nreturn c;\n}\n}\n\ncheckLenient();\nchar peek = buffer[pos];\nswitch (peek) {\ncase '*':\n// skip a /* c-style comment */\npos++;\nif (!skipTo(\"*/\")) {\nthrow syntaxError(\"Unterminated comment\");\n}\np = pos + 2;\nl = limit;\ncontinue;\n\ncase '/':\n// skip a // end-of-line comment\npos++;\nskipToEndOfLine();\np = pos;\nl = limit;\ncontinue;\n\ndefault:\nreturn c;\n}\n} else if (c == '#') {\npos = p;\n/*\n* Skip a # hash end-of-line comment. The JSON RFC doesn't\n* specify this behaviour, but it's required to parse\n* existing documents. See http://b/2571423.\n*/\ncheckLenient();\nskipToEndOfLine();\np = pos;\nl = limit;\n} else {\npos = p;\nreturn c;\n}\n}\nif (throwOnEof) {\nthrow new EOFException(\"End of input\"\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n} else {\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:consumeNonExecutePrefix()V",
                                    "method_body": "private void consumeNonExecutePrefix() throws IOException {\n// fast forward through the leading whitespace\nnextNonWhitespace(true);\npos--;\n\nif (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\nreturn;\n}\n\nfor (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\nif (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\nreturn; // not a security token!\n}\n}\n\n// we consumed a security token!\npos += NON_EXECUTE_PREFIX.length;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader$1:promoteNameToValue(Lcom/google/gson/stream/JsonReader;)V",
                                    "method_body": "@Override public void promoteNameToValue(JsonReader reader) throws IOException {\nif (reader instanceof JsonTreeReader) {\n((JsonTreeReader)reader).promoteNameToValue();\nreturn;\n}\nint p = reader.peeked;\nif (p == PEEKED_NONE) {\np = reader.doPeek();\n}\nif (p == PEEKED_DOUBLE_QUOTED_NAME) {\nreader.peeked = PEEKED_DOUBLE_QUOTED;\n} else if (p == PEEKED_SINGLE_QUOTED_NAME) {\nreader.peeked = PEEKED_SINGLE_QUOTED;\n} else if (p == PEEKED_UNQUOTED_NAME) {\nreader.peeked = PEEKED_UNQUOTED;\n} else {\nthrow new IllegalStateException(\"Expected a name but was \" + reader.peek() + \" \"\n+ \" at line \" + reader.getLineNumber() + \" column \" + reader.getColumnNumber()\n+ \" path \" + reader.getPath());\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nthrow new NullPointerException();\n}\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\nthrow new IllegalArgumentException();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>()V",
                                    "method_body": "protected TypeToken() {\nthis.type = getSuperclassTypeParameter(getClass());\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(type);\nthis.hashCode = type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getSuperclassTypeParameter(Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getSuperclassTypeParameter(Class<?> subclass) {\nType superclass = subclass.getGenericSuperclass();\nif (superclass instanceof Class) {\nthrow new RuntimeException(\"Missing type parameter.\");\n}\nParameterizedType parameterized = (ParameterizedType) superclass;\nreturn $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:newParameterizedTypeWithOwner(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)Ljava/lang/reflect/ParameterizedType;",
                                    "method_body": "public static ParameterizedType newParameterizedTypeWithOwner(\nType ownerType, Type rawType, Type... typeArguments) {\nreturn new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\np.getRawType(), p.getActualTypeArguments());\n\n} else if (type instanceof GenericArrayType) {\nGenericArrayType g = (GenericArrayType) type;\nreturn new GenericArrayTypeImpl(g.getGenericComponentType());\n\n} else if (type instanceof WildcardType) {\nWildcardType w = (WildcardType) type;\nreturn new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n} else {\n// type is either serializable as-is or unsupported\nreturn type;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\n// type is a normal class.\nreturn (Class<?>) type;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType parameterizedType = (ParameterizedType) type;\n\n// I'm not exactly sure why getRawType() returns Type instead of Class.\n// Neal isn't either but suspects some pathological case related\n// to nested classes exists.\nType rawType = parameterizedType.getRawType();\ncheckArgument(rawType instanceof Class);\nreturn (Class<?>) rawType;\n\n} else if (type instanceof GenericArrayType) {\nType componentType = ((GenericArrayType)type).getGenericComponentType();\nreturn Array.newInstance(getRawType(componentType), 0).getClass();\n\n} else if (type instanceof TypeVariable) {\n// we could use the variable's bounds, but that won't work if there are multiple.\n// having a raw type that's more general than necessary is okay\nreturn Object.class;\n\n} else if (type instanceof WildcardType) {\nreturn getRawType(((WildcardType) type).getUpperBounds()[0]);\n\n} else {\nString className = type == null ? \"null\" : type.getClass().getName();\nthrow new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n+ \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:hashCodeOrZero(Ljava/lang/Object;)I",
                                    "method_body": "private static int hashCodeOrZero(Object o) {\nreturn o != null ? o.hashCode() : 0;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getGenericSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\nif (toResolve == rawType) {\nreturn context;\n}\n\n// we skip searching through interfaces if unknown is an interface\nif (toResolve.isInterface()) {\nClass<?>[] interfaces = rawType.getInterfaces();\nfor (int i = 0, length = interfaces.length; i < length; i++) {\nif (interfaces[i] == toResolve) {\nreturn rawType.getGenericInterfaces()[i];\n} else if (toResolve.isAssignableFrom(interfaces[i])) {\nreturn getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n}\n}\n}\n\n// check our supertypes\nif (!rawType.isInterface()) {\nwhile (rawType != Object.class) {\nClass<?> rawSupertype = rawType.getSuperclass();\nif (rawSupertype == toResolve) {\nreturn rawType.getGenericSuperclass();\n} else if (toResolve.isAssignableFrom(rawSupertype)) {\nreturn getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);\n}\nrawType = rawSupertype;\n}\n}\n\n// we can't resolve this further\nreturn toResolve;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\ncheckArgument(supertype.isAssignableFrom(contextRawType));\nreturn resolve(context, contextRawType,\n$Gson$Types.getGenericSupertype(context, contextRawType, supertype));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getMapKeyAndValueTypes(Ljava/lang/reflect/Type;Ljava/lang/Class;)[Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {\n/*\n* Work around a problem with the declaration of java.util.Properties. That\n* class should extend Hashtable<String, String>, but it's declared to\n* extend Hashtable<Object, Object>.\n*/\nif (context == Properties.class) {\nreturn new Type[] { String.class, String.class }; // TODO: test subclasses of Properties!\n}\n\nType mapType = getSupertype(context, contextRawType, Map.class);\n// TODO: strip wildcards?\nif (mapType instanceof ParameterizedType) {\nParameterizedType mapParameterizedType = (ParameterizedType) mapType;\nreturn mapParameterizedType.getActualTypeArguments();\n}\nreturn new Type[] { Object.class, Object.class };\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\n// this implementation is made a little more complicated in an attempt to avoid object-creation\nwhile (true) {\nif (toResolve instanceof TypeVariable) {\nTypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\ntoResolve = resolveTypeVariable(context, contextRawType, typeVariable);\nif (toResolve == typeVariable) {\nreturn toResolve;\n}\n\n} else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\nClass<?> original = (Class<?>) toResolve;\nType componentType = original.getComponentType();\nType newComponentType = resolve(context, contextRawType, componentType);\nreturn componentType == newComponentType\n? original\n: arrayOf(newComponentType);\n\n} else if (toResolve instanceof GenericArrayType) {\nGenericArrayType original = (GenericArrayType) toResolve;\nType componentType = original.getGenericComponentType();\nType newComponentType = resolve(context, contextRawType, componentType);\nreturn componentType == newComponentType\n? original\n: arrayOf(newComponentType);\n\n} else if (toResolve instanceof ParameterizedType) {\nParameterizedType original = (ParameterizedType) toResolve;\nType ownerType = original.getOwnerType();\nType newOwnerType = resolve(context, contextRawType, ownerType);\nboolean changed = newOwnerType != ownerType;\n\nType[] args = original.getActualTypeArguments();\nfor (int t = 0, length = args.length; t < length; t++) {\nType resolvedTypeArgument = resolve(context, contextRawType, args[t]);\nif (resolvedTypeArgument != args[t]) {\nif (!changed) {\nargs = args.clone();\nchanged = true;\n}\nargs[t] = resolvedTypeArgument;\n}\n}\n\nreturn changed\n? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n: original;\n\n} else if (toResolve instanceof WildcardType) {\nWildcardType original = (WildcardType) toResolve;\nType[] originalLowerBound = original.getLowerBounds();\nType[] originalUpperBound = original.getUpperBounds();\n\nif (originalLowerBound.length == 1) {\nType lowerBound = resolve(context, contextRawType, originalLowerBound[0]);\nif (lowerBound != originalLowerBound[0]) {\nreturn supertypeOf(lowerBound);\n}\n} else if (originalUpperBound.length == 1) {\nType upperBound = resolve(context, contextRawType, originalUpperBound[0]);\nif (upperBound != originalUpperBound[0]) {\nreturn subtypeOf(upperBound);\n}\n}\nreturn original;\n\n} else {\nreturn toResolve;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolveTypeVariable(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/TypeVariable;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\nClass<?> declaredByRaw = declaringClassOf(unknown);\n\n// we can't reduce this further\nif (declaredByRaw == null) {\nreturn unknown;\n}\n\nType declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\nif (declaredBy instanceof ParameterizedType) {\nint index = indexOf(declaredByRaw.getTypeParameters(), unknown);\nreturn ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\n}\n\nreturn unknown;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:indexOf([Ljava/lang/Object;Ljava/lang/Object;)I",
                                    "method_body": "private static int indexOf(Object[] array, Object toFind) {\nfor (int i = 0; i < array.length; i++) {\nif (toFind.equals(array[i])) {\nreturn i;\n}\n}\nthrow new NoSuchElementException();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:declaringClassOf(Ljava/lang/reflect/TypeVariable;)Ljava/lang/Class;",
                                    "method_body": "private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\nGenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\nreturn genericDeclaration instanceof Class\n? (Class<?>) genericDeclaration\n: null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "private static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$ParameterizedTypeImpl:<init>(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n// require an owner type if the raw type needs it\nif (rawType instanceof Class<?>) {\nClass<?> rawTypeAsClass = (Class<?>) rawType;\nboolean isStaticOrTopLevelClass = Modifier.isStatic(rawTypeAsClass.getModifiers())\n|| rawTypeAsClass.getEnclosingClass() == null;\ncheckArgument(ownerType != null || isStaticOrTopLevelClass);\n}\n\nthis.ownerType = ownerType == null ? null : canonicalize(ownerType);\nthis.rawType = canonicalize(rawType);\nthis.typeArguments = typeArguments.clone();\nfor (int t = 0; t < this.typeArguments.length; t++) {\ncheckNotNull(this.typeArguments[t]);\ncheckNotPrimitive(this.typeArguments[t]);\nthis.typeArguments[t] = canonicalize(this.typeArguments[t]);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson$FutureTypeAdapter:setDelegate(Lcom/google/gson/TypeAdapter;)V",
                                    "method_body": "public void setDelegate(TypeAdapter<T> typeAdapter) {\nif (delegate != null) {\nthrow new AssertionError();\n}\ndelegate = typeAdapter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:<init>(Lcom/google/gson/Gson;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeAdapterRuntimeTypeWrapper(Gson context, TypeAdapter<T> delegate, Type type) {\nthis.context = context;\nthis.delegate = delegate;\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Object;",
                                    "method_body": "public T read(JsonReader in) throws IOException {\nreturn delegate.read(in);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter:<init>(Lcom/google/gson/internal/bind/MapTypeAdapterFactory;Lcom/google/gson/Gson;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Lcom/google/gson/internal/ObjectConstructor;)V",
                                    "method_body": "public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,\nType valueType, TypeAdapter<V> valueTypeAdapter,\nObjectConstructor<? extends Map<K, V>> constructor) {\nthis.keyTypeAdapter =\nnew TypeAdapterRuntimeTypeWrapper<K>(context, keyTypeAdapter, keyType);\nthis.valueTypeAdapter =\nnew TypeAdapterRuntimeTypeWrapper<V>(context, valueTypeAdapter, valueType);\nthis.constructor = constructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter:read(Lcom/google/gson/stream/JsonReader;)Ljava/util/Map;",
                                    "method_body": "@Override public Map<K, V> read(JsonReader in) throws IOException {\nJsonToken peek = in.peek();\nif (peek == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\n\nMap<K, V> map = constructor.construct();\n\nif (peek == JsonToken.BEGIN_ARRAY) {\nin.beginArray();\nwhile (in.hasNext()) {\nin.beginArray(); // entry array\nK key = keyTypeAdapter.read(in);\nV value = valueTypeAdapter.read(in);\nV replaced = map.put(key, value);\nif (replaced != null) {\nthrow new JsonSyntaxException(\"duplicate key: \" + key);\n}\nin.endArray();\n}\nin.endArray();\n} else {\nin.beginObject();\nwhile (in.hasNext()) {\nJsonReaderInternalAccess.INSTANCE.promoteNameToValue(in);\nK key = keyTypeAdapter.read(in);\nV value = valueTypeAdapter.read(in);\nV replaced = map.put(key, value);\nif (replaced != null) {\nthrow new JsonSyntaxException(\"duplicate key: \" + key);\n}\n}\nin.endObject();\n}\nreturn map;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor$10:construct()Ljava/lang/Object;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nfinal Type type, Class<? super T> rawType) {\nif (Collection.class.isAssignableFrom(rawType)) {\nif (SortedSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeSet<Object>();\n}\n};\n} else if (EnumSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"rawtypes\")\n@Override public T construct() {\nif (type instanceof ParameterizedType) {\nType elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\nif (elementType instanceof Class) {\nreturn (T) EnumSet.noneOf((Class)elementType);\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n}\n};\n} else if (Set.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashSet<Object>();\n}\n};\n} else if (Queue.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedList<Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ArrayList<Object>();\n}\n};\n}\n}\n\nif (Map.class.isAssignableFrom(rawType)) {\nif (SortedMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeMap<Object, Object>();\n}\n};\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nTypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashMap<Object, Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedTreeMap<String, Object>();\n}\n};\n}\n}\n\nreturn null;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.functional.MapTest.testConcurrentNavigableMap",
                            "test_body": "206: public void testConcurrentNavigableMap() throws Exception {\n207: Type typeOfMap = new TypeToken<ConcurrentNavigableMap<Integer, String>>() {}.getType();\n208: ConcurrentNavigableMap<Integer, String> map = gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\n209: assertEquals(1, map.size());\n210: assertTrue(map.containsKey(123));\n211: assertEquals(\"456\", map.get(123));\n212: String json = gson.toJson(map);\n213: assertEquals(\"{\\\"123\\\":\\\"456\\\"}\", json);\n214: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\nCollections.<Type, InstanceCreator<?>>emptyMap(), false, false, DEFAULT_JSON_NON_EXECUTABLE,\ntrue, false, false, LongSerializationPolicy.DEFAULT,\nCollections.<TypeAdapterFactory>emptyList());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingPolicy,\nfinal Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,\nboolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\nboolean prettyPrinting, boolean serializeSpecialFloatingPointValues,\nLongSerializationPolicy longSerializationPolicy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\n\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n\n// built-in type adapters that cannot be overridden\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\n\n// the excluder must precede all adapters that handle user-defined types\nfactories.add(excluder);\n\n// user's type adapters\nfactories.addAll(typeAdapterFactories);\n\n// type adapters for basic platform types\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class,\nlongAdapter(longSerializationPolicy)));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\ndoubleAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfloatAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\n\n// type adapters for composite and user-defined types\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nfactories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nconstructorConstructor, fieldNamingPolicy, excluder));\n\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.DOUBLE;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Double read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\ndouble doubleValue = value.doubleValue();\ncheckValidFloatingPoint(doubleValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.FLOAT;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Float read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn (float) in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nfloat floatValue = value.floatValue();\ncheckValidFloatingPoint(floatValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Number read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextLong();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nout.value(value.toString());\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type);\nif (cached != null) {\nreturn (TypeAdapter<T>) cached;\n}\n\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\n}\n\n// the key and value type parameters always agree\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nreturn ongoingCall;\n}\n\ntry {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\n\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\n}\n}\nthrow new IllegalArgumentException(\"GSON cannot handle \" + type);\n} finally {\nthreadCalls.remove(type);\n\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {\nif (json == null) {\nreturn null;\n}\nStringReader reader = new StringReader(json);\nT target = (T) fromJson(reader, typeOfT);\nreturn target;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/io/Reader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nJsonReader jsonReader = new JsonReader(json);\nT object = (T) fromJson(jsonReader, typeOfT);\nassertFullConsumption(object, jsonReader);\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:assertFullConsumption(Ljava/lang/Object;Lcom/google/gson/stream/JsonReader;)V",
                                    "method_body": "private static void assertFullConsumption(Object obj, JsonReader reader) {\ntry {\nif (obj != null && reader.peek() != JsonToken.END_DOCUMENT) {\nthrow new JsonIOException(\"JSON document was not fully consumed.\");\n}\n} catch (MalformedJsonException e) {\nthrow new JsonSyntaxException(e);\n} catch (IOException e) {\nthrow new JsonIOException(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Lcom/google/gson/stream/JsonReader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nboolean isEmpty = true;\nboolean oldLenient = reader.isLenient();\nreader.setLenient(true);\ntry {\nreader.peek();\nisEmpty = false;\nTypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\nTypeAdapter<T> typeAdapter = getAdapter(typeToken);\nT object = typeAdapter.read(reader);\nreturn object;\n} catch (EOFException e) {\n/*\n* For compatibility with JSON 1.5 and earlier, we return null for empty\n* documents instead of throwing.\n*/\nif (isEmpty) {\nreturn null;\n}\nthrow new JsonSyntaxException(e);\n} catch (IllegalStateException e) {\nthrow new JsonSyntaxException(e);\n} catch (IOException e) {\n// TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException\nthrow new JsonSyntaxException(e);\n} finally {\nreader.setLenient(oldLenient);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\n\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate boolean requireExpose;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n\n@Override protected Excluder clone() {\ntry {\nreturn (Excluder) super.clone();\n} catch (CloneNotSupportedException e) {\nthrow new AssertionError();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\n\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}\n\nreturn new TypeAdapter<T>() {\n/** The delegate is lazily created because it may not be needed, and creating it may fail. */\nprivate TypeAdapter<T> delegate;\n\n@Override public T read(JsonReader in) throws IOException {\nif (skipDeserialize) {\nin.skipValue();\nreturn null;\n}\nreturn delegate().read(in);\n}\n\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (skipSerialize) {\nout.nullValue();\nreturn;\n}\ndelegate().write(out, value);\n}\n\nprivate TypeAdapter<T> delegate() {\nTypeAdapter<T> d = delegate;\nreturn d != null\n? d\n: (delegate = gson.getDelegateAdapter(Excluder.this, type));\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\n&& !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\nreturn true;\n}\n\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nreturn true;\n}\n\nif (isAnonymousOrLocal(clazz)) {\nreturn true;\n}\n\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nif (exclusionStrategy.shouldSkipClass(clazz)) {\nreturn true;\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n&& (clazz.isAnonymousClass() || clazz.isLocalClass());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\n\n// first try an instance creator\n\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn typeCreator.createInstance(type);\n}\n};\n}\n\n// Next try raw type match for instance creators\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> rawTypeCreator =\n(InstanceCreator<T>) instanceCreators.get(rawType);\nif (rawTypeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn rawTypeCreator.createInstance(type);\n}\n};\n}\n\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nreturn defaultConstructor;\n}\n\nObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\nif (defaultImplementation != null) {\nreturn defaultImplementation;\n}\n\n// finally try unsafe\nreturn newUnsafeAllocator(type, rawType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultConstructor(Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\ntry {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\n}\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"unchecked\") // T is the same raw type as is requested\n@Override public T construct() {\ntry {\nObject[] args = null;\nreturn (T) constructor.newInstance(args);\n} catch (InstantiationException e) {\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\", e);\n} catch (InvocationTargetException e) {\n// TODO: don't wrap if cause is unchecked!\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",\ne.getTargetException());\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\n}\n};\n} catch (NoSuchMethodException e) {\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultImplementationConstructor(Ljava/lang/reflect/Type;Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nfinal Type type, Class<? super T> rawType) {\nif (Collection.class.isAssignableFrom(rawType)) {\nif (SortedSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeSet<Object>();\n}\n};\n} else if (EnumSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"rawtypes\")\n@Override public T construct() {\nif (type instanceof ParameterizedType) {\nType elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\nif (elementType instanceof Class) {\nreturn (T) EnumSet.noneOf((Class)elementType);\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n}\n};\n} else if (Set.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashSet<Object>();\n}\n};\n} else if (Queue.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedList<Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ArrayList<Object>();\n}\n};\n}\n}\n\nif (Map.class.isAssignableFrom(rawType)) {\nif (SortedMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeMap<Object, Object>();\n}\n};\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nTypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashMap<Object, Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedTreeMap<String, Object>();\n}\n};\n}\n}\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n@Override\npublic void write(JsonWriter out, Class value) throws IOException {\nif (value == null) {\nout.nullValue();\n} else {\nthrow new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n+ value.getName() + \". Forgot to register a type adapter?\");\n}\n}\n@Override\npublic Class read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n} else {\nthrow new UnsupportedOperationException(\n\"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n}\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$28:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$29:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$7:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Number;",
                                    "method_body": "public Number read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\ntry {\nreturn in.nextInt();\n} catch (NumberFormatException e) {\nthrow new JsonSyntaxException(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$13:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/String;",
                                    "method_body": "public String read(JsonReader in) throws IOException {\nJsonToken peek = in.peek();\nif (peek == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\n/* coerce booleans to strings for backwards compatibility */\nif (peek == JsonToken.BOOLEAN) {\nreturn Boolean.toString(in.nextBoolean());\n}\nreturn in.nextString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$31:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$22:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}\n\nfinal TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\nreturn (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n@Override public Timestamp read(JsonReader in) throws IOException {\nDate date = dateTypeAdapter.read(in);\nreturn date != null ? new Timestamp(date.getTime()) : null;\n}\n\n@Override public void write(JsonWriter out, Timestamp value) throws IOException {\ndateTypeAdapter.write(out, value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$30:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nType elementType = $Gson$Types.getCollectionElementType(type, rawType);\nTypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // create() doesn't define a type parameter\nTypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nClass<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\nType[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\nTypeAdapter<?> keyAdapter = getKeyAdapter(gson, keyAndValueTypes[0]);\nTypeAdapter<?> valueAdapter = gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n// we don't define a type parameter for the key or value types\nTypeAdapter<T> result = new Adapter(gson, keyAndValueTypes[0], keyAdapter,\nkeyAndValueTypes[1], valueAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:getKeyAdapter(Lcom/google/gson/Gson;Ljava/lang/reflect/Type;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<?> getKeyAdapter(Gson context, Type keyType) {\nreturn (keyType == boolean.class || keyType == Boolean.class)\n? TypeAdapters.BOOLEAN_AS_STRING\n: context.getAdapter(TypeToken.get(keyType));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nFieldNamingStrategy fieldNamingPolicy, Excluder excluder) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "public JsonReader(Reader in) {\nif (in == null) {\nthrow new NullPointerException(\"in == null\");\n}\nthis.in = in;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<clinit>()V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;\n\nprivate static final int PEEKED_NONE = 0;\nprivate static final int PEEKED_BEGIN_OBJECT = 1;\nprivate static final int PEEKED_END_OBJECT = 2;\nprivate static final int PEEKED_BEGIN_ARRAY = 3;\nprivate static final int PEEKED_END_ARRAY = 4;\nprivate static final int PEEKED_TRUE = 5;\nprivate static final int PEEKED_FALSE = 6;\nprivate static final int PEEKED_NULL = 7;\nprivate static final int PEEKED_SINGLE_QUOTED = 8;\nprivate static final int PEEKED_DOUBLE_QUOTED = 9;\nprivate static final int PEEKED_UNQUOTED = 10;\n/** When this is returned, the string value is stored in peekedString. */\nprivate static final int PEEKED_BUFFERED = 11;\nprivate static final int PEEKED_SINGLE_QUOTED_NAME = 12;\nprivate static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\nprivate static final int PEEKED_UNQUOTED_NAME = 14;\n/** When this is returned, the integer value is stored in peekedLong. */\nprivate static final int PEEKED_LONG = 15;\nprivate static final int PEEKED_NUMBER = 16;\nprivate static final int PEEKED_EOF = 17;\n\n/* State machine when parsing numbers */\nprivate static final int NUMBER_CHAR_NONE = 0;\nprivate static final int NUMBER_CHAR_SIGN = 1;\nprivate static final int NUMBER_CHAR_DIGIT = 2;\nprivate static final int NUMBER_CHAR_DECIMAL = 3;\nprivate static final int NUMBER_CHAR_FRACTION_DIGIT = 4;\nprivate static final int NUMBER_CHAR_EXP_E = 5;\nprivate static final int NUMBER_CHAR_EXP_SIGN = 6;\nprivate static final int NUMBER_CHAR_EXP_DIGIT = 7;\n\n/** The input JSON. */\nprivate final Reader in;\n\n/** True to accept non-spec compliant JSON */\nprivate boolean lenient = false;\n\n/**\n* Use a manual buffer to easily read and unread upcoming characters, and\n* also so we can create strings without an intermediate StringBuilder.\n* We decode literals directly out of this buffer, so it must be at least as\n* long as the longest token that can be reported as a number.\n*/\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\n\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\n\nprivate int peeked = PEEKED_NONE;\n\n/**\n* A peeked value that was composed entirely of digits with an optional\n* leading dash. Positive values may not have a leading 0.\n*/\nprivate long peekedLong;\n\n/**\n* The number of characters in a peeked number literal. Increment 'pos' by\n* this after reading a number.\n*/\nprivate int peekedNumberLength;\n\n/**\n* A peeked string that should be parsed on the next double, long or string.\n* This is populated before a numeric value is parsed and used if that parsing\n* fails.\n*/\nprivate String peekedString;\n\n/*\n* The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n*/\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\n{\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:setLenient(Z)V",
                                    "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:isLenient()Z",
                                    "method_body": "public final boolean isLenient() {\nreturn lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:beginObject()V",
                                    "method_body": "public void beginObject() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nif (p == PEEKED_BEGIN_OBJECT) {\npush(JsonScope.EMPTY_OBJECT);\npeeked = PEEKED_NONE;\n} else {\nthrow new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek()\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:endObject()V",
                                    "method_body": "public void endObject() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nif (p == PEEKED_END_OBJECT) {\nstackSize--;\npathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!\npathIndices[stackSize - 1]++;\npeeked = PEEKED_NONE;\n} else {\nthrow new IllegalStateException(\"Expected END_OBJECT but was \" + peek()\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:hasNext()Z",
                                    "method_body": "public boolean hasNext() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nreturn p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\n\nswitch (p) {\ncase PEEKED_BEGIN_OBJECT:\nreturn JsonToken.BEGIN_OBJECT;\ncase PEEKED_END_OBJECT:\nreturn JsonToken.END_OBJECT;\ncase PEEKED_BEGIN_ARRAY:\nreturn JsonToken.BEGIN_ARRAY;\ncase PEEKED_END_ARRAY:\nreturn JsonToken.END_ARRAY;\ncase PEEKED_SINGLE_QUOTED_NAME:\ncase PEEKED_DOUBLE_QUOTED_NAME:\ncase PEEKED_UNQUOTED_NAME:\nreturn JsonToken.NAME;\ncase PEEKED_TRUE:\ncase PEEKED_FALSE:\nreturn JsonToken.BOOLEAN;\ncase PEEKED_NULL:\nreturn JsonToken.NULL;\ncase PEEKED_SINGLE_QUOTED:\ncase PEEKED_DOUBLE_QUOTED:\ncase PEEKED_UNQUOTED:\ncase PEEKED_BUFFERED:\nreturn JsonToken.STRING;\ncase PEEKED_LONG:\ncase PEEKED_NUMBER:\nreturn JsonToken.NUMBER;\ncase PEEKED_EOF:\nreturn JsonToken.END_DOCUMENT;\ndefault:\nthrow new AssertionError();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:doPeek()I",
                                    "method_body": "private int doPeek() throws IOException {\nint peekStack = stack[stackSize - 1];\nif (peekStack == JsonScope.EMPTY_ARRAY) {\nstack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n} else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n// Look for a comma before the next element.\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase ']':\nreturn peeked = PEEKED_END_ARRAY;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated array\");\n}\n} else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\nstack[stackSize - 1] = JsonScope.DANGLING_NAME;\n// Look for a comma before the next element.\nif (peekStack == JsonScope.NONEMPTY_OBJECT) {\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '}':\nreturn peeked = PEEKED_END_OBJECT;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated object\");\n}\n}\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '\"':\nreturn peeked = PEEKED_DOUBLE_QUOTED_NAME;\ncase '\\'':\ncheckLenient();\nreturn peeked = PEEKED_SINGLE_QUOTED_NAME;\ncase '}':\nif (peekStack != JsonScope.NONEMPTY_OBJECT) {\nreturn peeked = PEEKED_END_OBJECT;\n} else {\nthrow syntaxError(\"Expected name\");\n}\ndefault:\ncheckLenient();\npos--; // Don't consume the first character in an unquoted string.\nif (isLiteral((char) c)) {\nreturn peeked = PEEKED_UNQUOTED_NAME;\n} else {\nthrow syntaxError(\"Expected name\");\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextString()Ljava/lang/String;",
                                    "method_body": "public String nextString() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nString result;\nif (p == PEEKED_UNQUOTED) {\nresult = nextUnquotedValue();\n} else if (p == PEEKED_SINGLE_QUOTED) {\nresult = nextQuotedValue('\\'');\n} else if (p == PEEKED_DOUBLE_QUOTED) {\nresult = nextQuotedValue('\"');\n} else if (p == PEEKED_BUFFERED) {\nresult = peekedString;\npeekedString = null;\n} else if (p == PEEKED_LONG) {\nresult = Long.toString(peekedLong);\n} else if (p == PEEKED_NUMBER) {\nresult = new String(buffer, pos, peekedNumberLength);\npos += peekedNumberLength;\n} else {\nthrow new IllegalStateException(\"Expected a string but was \" + peek()\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextQuotedValue(C)Ljava/lang/String;",
                                    "method_body": "private String nextQuotedValue(char quote) throws IOException {\n// Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\nchar[] buffer = this.buffer;\nStringBuilder builder = new StringBuilder();\nwhile (true) {\nint p = pos;\nint l = limit;\n/* the index of the first character not yet appended to the builder. */\nint start = p;\nwhile (p < l) {\nint c = buffer[p++];\n\nif (c == quote) {\npos = p;\nbuilder.append(buffer, start, p - start - 1);\nreturn builder.toString();\n} else if (c == '\\\\') {\npos = p;\nbuilder.append(buffer, start, p - start - 1);\nbuilder.append(readEscapeCharacter());\np = pos;\nl = limit;\nstart = p;\n} else if (c == '\\n') {\nlineNumber++;\nlineStart = p;\n}\n}\n\nbuilder.append(buffer, start, p - start);\npos = p;\nif (!fillBuffer(1)) {\nthrow syntaxError(\"Unterminated string\");\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextInt()I",
                                    "method_body": "public int nextInt() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\n\nint result;\nif (p == PEEKED_LONG) {\nresult = (int) peekedLong;\nif (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\nthrow new NumberFormatException(\"Expected an int but was \" + peekedLong\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n}\n\nif (p == PEEKED_NUMBER) {\npeekedString = new String(buffer, pos, peekedNumberLength);\npos += peekedNumberLength;\n} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\npeekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\ntry {\nresult = Integer.parseInt(peekedString);\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n} catch (NumberFormatException ignored) {\n// Fall back to parse as a double below.\n}\n} else {\nthrow new IllegalStateException(\"Expected an int but was \" + peek()\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}\n\npeeked = PEEKED_BUFFERED;\ndouble asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\nresult = (int) asDouble;\nif (result != asDouble) { // Make sure no precision was lost casting to 'int'.\nthrow new NumberFormatException(\"Expected an int but was \" + peekedString\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}\npeekedString = null;\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:push(I)V",
                                    "method_body": "private void push(int newTop) {\nif (stackSize == stack.length) {\nint[] newStack = new int[stackSize * 2];\nint[] newPathIndices = new int[stackSize * 2];\nString[] newPathNames = new String[stackSize * 2];\nSystem.arraycopy(stack, 0, newStack, 0, stackSize);\nSystem.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\nSystem.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\nstack = newStack;\npathIndices = newPathIndices;\npathNames = newPathNames;\n}\nstack[stackSize++] = newTop;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit -= pos;\nSystem.arraycopy(buffer, pos, buffer, 0, limit);\n} else {\nlimit = 0;\n}\n\npos = 0;\nint total;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\n\n// if this is the first read, consume an optional byte order mark (BOM) if it exists\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\npos++;\nlineStart++;\nminimum++;\n}\n\nif (limit >= minimum) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n/*\n* This code uses ugly local variables 'p' and 'l' representing the 'pos'\n* and 'limit' fields respectively. Using locals rather than fields saves\n* a few field reads for each whitespace character in a pretty-printed\n* document, resulting in a 5% speedup. We need to flush 'p' to its field\n* before any (potentially indirect) call to fillBuffer() and reread both\n* 'p' and 'l' after any (potentially indirect) call to the same method.\n*/\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nwhile (true) {\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\nbreak;\n}\np = pos;\nl = limit;\n}\n\nint c = buffer[p++];\nif (c == '\\n') {\nlineNumber++;\nlineStart = p;\ncontinue;\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\ncontinue;\n}\n\nif (c == '/') {\npos = p;\nif (p == l) {\npos--; // push back '/' so it's still in the buffer when this method returns\nboolean charsLoaded = fillBuffer(2);\npos++; // consume the '/' again\nif (!charsLoaded) {\nreturn c;\n}\n}\n\ncheckLenient();\nchar peek = buffer[pos];\nswitch (peek) {\ncase '*':\n// skip a /* c-style comment */\npos++;\nif (!skipTo(\"*/\")) {\nthrow syntaxError(\"Unterminated comment\");\n}\np = pos + 2;\nl = limit;\ncontinue;\n\ncase '/':\n// skip a // end-of-line comment\npos++;\nskipToEndOfLine();\np = pos;\nl = limit;\ncontinue;\n\ndefault:\nreturn c;\n}\n} else if (c == '#') {\npos = p;\n/*\n* Skip a # hash end-of-line comment. The JSON RFC doesn't\n* specify this behaviour, but it's required to parse\n* existing documents. See http://b/2571423.\n*/\ncheckLenient();\nskipToEndOfLine();\np = pos;\nl = limit;\n} else {\npos = p;\nreturn c;\n}\n}\nif (throwOnEof) {\nthrow new EOFException(\"End of input\"\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n} else {\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:consumeNonExecutePrefix()V",
                                    "method_body": "private void consumeNonExecutePrefix() throws IOException {\n// fast forward through the leading whitespace\nnextNonWhitespace(true);\npos--;\n\nif (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\nreturn;\n}\n\nfor (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\nif (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\nreturn; // not a security token!\n}\n}\n\n// we consumed a security token!\npos += NON_EXECUTE_PREFIX.length;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader$1:promoteNameToValue(Lcom/google/gson/stream/JsonReader;)V",
                                    "method_body": "@Override public void promoteNameToValue(JsonReader reader) throws IOException {\nif (reader instanceof JsonTreeReader) {\n((JsonTreeReader)reader).promoteNameToValue();\nreturn;\n}\nint p = reader.peeked;\nif (p == PEEKED_NONE) {\np = reader.doPeek();\n}\nif (p == PEEKED_DOUBLE_QUOTED_NAME) {\nreader.peeked = PEEKED_DOUBLE_QUOTED;\n} else if (p == PEEKED_SINGLE_QUOTED_NAME) {\nreader.peeked = PEEKED_SINGLE_QUOTED;\n} else if (p == PEEKED_UNQUOTED_NAME) {\nreader.peeked = PEEKED_UNQUOTED;\n} else {\nthrow new IllegalStateException(\"Expected a name but was \" + reader.peek() + \" \"\n+ \" at line \" + reader.getLineNumber() + \" column \" + reader.getColumnNumber()\n+ \" path \" + reader.getPath());\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nthrow new NullPointerException();\n}\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\nthrow new IllegalArgumentException();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>()V",
                                    "method_body": "protected TypeToken() {\nthis.type = getSuperclassTypeParameter(getClass());\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(type);\nthis.hashCode = type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getSuperclassTypeParameter(Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getSuperclassTypeParameter(Class<?> subclass) {\nType superclass = subclass.getGenericSuperclass();\nif (superclass instanceof Class) {\nthrow new RuntimeException(\"Missing type parameter.\");\n}\nParameterizedType parameterized = (ParameterizedType) superclass;\nreturn $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:newParameterizedTypeWithOwner(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)Ljava/lang/reflect/ParameterizedType;",
                                    "method_body": "public static ParameterizedType newParameterizedTypeWithOwner(\nType ownerType, Type rawType, Type... typeArguments) {\nreturn new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\np.getRawType(), p.getActualTypeArguments());\n\n} else if (type instanceof GenericArrayType) {\nGenericArrayType g = (GenericArrayType) type;\nreturn new GenericArrayTypeImpl(g.getGenericComponentType());\n\n} else if (type instanceof WildcardType) {\nWildcardType w = (WildcardType) type;\nreturn new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n} else {\n// type is either serializable as-is or unsupported\nreturn type;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\n// type is a normal class.\nreturn (Class<?>) type;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType parameterizedType = (ParameterizedType) type;\n\n// I'm not exactly sure why getRawType() returns Type instead of Class.\n// Neal isn't either but suspects some pathological case related\n// to nested classes exists.\nType rawType = parameterizedType.getRawType();\ncheckArgument(rawType instanceof Class);\nreturn (Class<?>) rawType;\n\n} else if (type instanceof GenericArrayType) {\nType componentType = ((GenericArrayType)type).getGenericComponentType();\nreturn Array.newInstance(getRawType(componentType), 0).getClass();\n\n} else if (type instanceof TypeVariable) {\n// we could use the variable's bounds, but that won't work if there are multiple.\n// having a raw type that's more general than necessary is okay\nreturn Object.class;\n\n} else if (type instanceof WildcardType) {\nreturn getRawType(((WildcardType) type).getUpperBounds()[0]);\n\n} else {\nString className = type == null ? \"null\" : type.getClass().getName();\nthrow new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n+ \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:hashCodeOrZero(Ljava/lang/Object;)I",
                                    "method_body": "private static int hashCodeOrZero(Object o) {\nreturn o != null ? o.hashCode() : 0;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getGenericSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\nif (toResolve == rawType) {\nreturn context;\n}\n\n// we skip searching through interfaces if unknown is an interface\nif (toResolve.isInterface()) {\nClass<?>[] interfaces = rawType.getInterfaces();\nfor (int i = 0, length = interfaces.length; i < length; i++) {\nif (interfaces[i] == toResolve) {\nreturn rawType.getGenericInterfaces()[i];\n} else if (toResolve.isAssignableFrom(interfaces[i])) {\nreturn getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n}\n}\n}\n\n// check our supertypes\nif (!rawType.isInterface()) {\nwhile (rawType != Object.class) {\nClass<?> rawSupertype = rawType.getSuperclass();\nif (rawSupertype == toResolve) {\nreturn rawType.getGenericSuperclass();\n} else if (toResolve.isAssignableFrom(rawSupertype)) {\nreturn getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);\n}\nrawType = rawSupertype;\n}\n}\n\n// we can't resolve this further\nreturn toResolve;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\ncheckArgument(supertype.isAssignableFrom(contextRawType));\nreturn resolve(context, contextRawType,\n$Gson$Types.getGenericSupertype(context, contextRawType, supertype));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getMapKeyAndValueTypes(Ljava/lang/reflect/Type;Ljava/lang/Class;)[Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {\n/*\n* Work around a problem with the declaration of java.util.Properties. That\n* class should extend Hashtable<String, String>, but it's declared to\n* extend Hashtable<Object, Object>.\n*/\nif (context == Properties.class) {\nreturn new Type[] { String.class, String.class }; // TODO: test subclasses of Properties!\n}\n\nType mapType = getSupertype(context, contextRawType, Map.class);\n// TODO: strip wildcards?\nif (mapType instanceof ParameterizedType) {\nParameterizedType mapParameterizedType = (ParameterizedType) mapType;\nreturn mapParameterizedType.getActualTypeArguments();\n}\nreturn new Type[] { Object.class, Object.class };\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\n// this implementation is made a little more complicated in an attempt to avoid object-creation\nwhile (true) {\nif (toResolve instanceof TypeVariable) {\nTypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\ntoResolve = resolveTypeVariable(context, contextRawType, typeVariable);\nif (toResolve == typeVariable) {\nreturn toResolve;\n}\n\n} else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\nClass<?> original = (Class<?>) toResolve;\nType componentType = original.getComponentType();\nType newComponentType = resolve(context, contextRawType, componentType);\nreturn componentType == newComponentType\n? original\n: arrayOf(newComponentType);\n\n} else if (toResolve instanceof GenericArrayType) {\nGenericArrayType original = (GenericArrayType) toResolve;\nType componentType = original.getGenericComponentType();\nType newComponentType = resolve(context, contextRawType, componentType);\nreturn componentType == newComponentType\n? original\n: arrayOf(newComponentType);\n\n} else if (toResolve instanceof ParameterizedType) {\nParameterizedType original = (ParameterizedType) toResolve;\nType ownerType = original.getOwnerType();\nType newOwnerType = resolve(context, contextRawType, ownerType);\nboolean changed = newOwnerType != ownerType;\n\nType[] args = original.getActualTypeArguments();\nfor (int t = 0, length = args.length; t < length; t++) {\nType resolvedTypeArgument = resolve(context, contextRawType, args[t]);\nif (resolvedTypeArgument != args[t]) {\nif (!changed) {\nargs = args.clone();\nchanged = true;\n}\nargs[t] = resolvedTypeArgument;\n}\n}\n\nreturn changed\n? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n: original;\n\n} else if (toResolve instanceof WildcardType) {\nWildcardType original = (WildcardType) toResolve;\nType[] originalLowerBound = original.getLowerBounds();\nType[] originalUpperBound = original.getUpperBounds();\n\nif (originalLowerBound.length == 1) {\nType lowerBound = resolve(context, contextRawType, originalLowerBound[0]);\nif (lowerBound != originalLowerBound[0]) {\nreturn supertypeOf(lowerBound);\n}\n} else if (originalUpperBound.length == 1) {\nType upperBound = resolve(context, contextRawType, originalUpperBound[0]);\nif (upperBound != originalUpperBound[0]) {\nreturn subtypeOf(upperBound);\n}\n}\nreturn original;\n\n} else {\nreturn toResolve;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolveTypeVariable(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/TypeVariable;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\nClass<?> declaredByRaw = declaringClassOf(unknown);\n\n// we can't reduce this further\nif (declaredByRaw == null) {\nreturn unknown;\n}\n\nType declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\nif (declaredBy instanceof ParameterizedType) {\nint index = indexOf(declaredByRaw.getTypeParameters(), unknown);\nreturn ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\n}\n\nreturn unknown;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:indexOf([Ljava/lang/Object;Ljava/lang/Object;)I",
                                    "method_body": "private static int indexOf(Object[] array, Object toFind) {\nfor (int i = 0; i < array.length; i++) {\nif (toFind.equals(array[i])) {\nreturn i;\n}\n}\nthrow new NoSuchElementException();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:declaringClassOf(Ljava/lang/reflect/TypeVariable;)Ljava/lang/Class;",
                                    "method_body": "private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\nGenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\nreturn genericDeclaration instanceof Class\n? (Class<?>) genericDeclaration\n: null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "private static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$ParameterizedTypeImpl:<init>(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n// require an owner type if the raw type needs it\nif (rawType instanceof Class<?>) {\nClass<?> rawTypeAsClass = (Class<?>) rawType;\nboolean isStaticOrTopLevelClass = Modifier.isStatic(rawTypeAsClass.getModifiers())\n|| rawTypeAsClass.getEnclosingClass() == null;\ncheckArgument(ownerType != null || isStaticOrTopLevelClass);\n}\n\nthis.ownerType = ownerType == null ? null : canonicalize(ownerType);\nthis.rawType = canonicalize(rawType);\nthis.typeArguments = typeArguments.clone();\nfor (int t = 0; t < this.typeArguments.length; t++) {\ncheckNotNull(this.typeArguments[t]);\ncheckNotPrimitive(this.typeArguments[t]);\nthis.typeArguments[t] = canonicalize(this.typeArguments[t]);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson$FutureTypeAdapter:setDelegate(Lcom/google/gson/TypeAdapter;)V",
                                    "method_body": "public void setDelegate(TypeAdapter<T> typeAdapter) {\nif (delegate != null) {\nthrow new AssertionError();\n}\ndelegate = typeAdapter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:<init>(Lcom/google/gson/Gson;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeAdapterRuntimeTypeWrapper(Gson context, TypeAdapter<T> delegate, Type type) {\nthis.context = context;\nthis.delegate = delegate;\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Object;",
                                    "method_body": "public T read(JsonReader in) throws IOException {\nreturn delegate.read(in);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter:<init>(Lcom/google/gson/internal/bind/MapTypeAdapterFactory;Lcom/google/gson/Gson;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Lcom/google/gson/internal/ObjectConstructor;)V",
                                    "method_body": "public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,\nType valueType, TypeAdapter<V> valueTypeAdapter,\nObjectConstructor<? extends Map<K, V>> constructor) {\nthis.keyTypeAdapter =\nnew TypeAdapterRuntimeTypeWrapper<K>(context, keyTypeAdapter, keyType);\nthis.valueTypeAdapter =\nnew TypeAdapterRuntimeTypeWrapper<V>(context, valueTypeAdapter, valueType);\nthis.constructor = constructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter:read(Lcom/google/gson/stream/JsonReader;)Ljava/util/Map;",
                                    "method_body": "@Override public Map<K, V> read(JsonReader in) throws IOException {\nJsonToken peek = in.peek();\nif (peek == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\n\nMap<K, V> map = constructor.construct();\n\nif (peek == JsonToken.BEGIN_ARRAY) {\nin.beginArray();\nwhile (in.hasNext()) {\nin.beginArray(); // entry array\nK key = keyTypeAdapter.read(in);\nV value = valueTypeAdapter.read(in);\nV replaced = map.put(key, value);\nif (replaced != null) {\nthrow new JsonSyntaxException(\"duplicate key: \" + key);\n}\nin.endArray();\n}\nin.endArray();\n} else {\nin.beginObject();\nwhile (in.hasNext()) {\nJsonReaderInternalAccess.INSTANCE.promoteNameToValue(in);\nK key = keyTypeAdapter.read(in);\nV value = valueTypeAdapter.read(in);\nV replaced = map.put(key, value);\nif (replaced != null) {\nthrow new JsonSyntaxException(\"duplicate key: \" + key);\n}\n}\nin.endObject();\n}\nreturn map;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor$9:construct()Ljava/lang/Object;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nfinal Type type, Class<? super T> rawType) {\nif (Collection.class.isAssignableFrom(rawType)) {\nif (SortedSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeSet<Object>();\n}\n};\n} else if (EnumSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"rawtypes\")\n@Override public T construct() {\nif (type instanceof ParameterizedType) {\nType elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\nif (elementType instanceof Class) {\nreturn (T) EnumSet.noneOf((Class)elementType);\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n}\n};\n} else if (Set.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashSet<Object>();\n}\n};\n} else if (Queue.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedList<Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ArrayList<Object>();\n}\n};\n}\n}\n\nif (Map.class.isAssignableFrom(rawType)) {\nif (SortedMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeMap<Object, Object>();\n}\n};\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nTypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashMap<Object, Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedTreeMap<String, Object>();\n}\n};\n}\n}\n\nreturn null;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 4,
                    "tests": [
                        {
                            "test_name": "com.google.gson.stream.JsonReaderTest.testTopLevelValueTypes",
                            "test_body": "1222: public void testTopLevelValueTypes() throws IOException {\n1223: JsonReader reader1 = new JsonReader(reader(\"true\"));\n1224: assertTrue(reader1.nextBoolean());\n1225: assertEquals(JsonToken.END_DOCUMENT, reader1.peek());\n1226: 1227: JsonReader reader2 = new JsonReader(reader(\"false\"));\n1228: assertFalse(reader2.nextBoolean());\n1229: assertEquals(JsonToken.END_DOCUMENT, reader2.peek());\n1230: 1231: JsonReader reader3 = new JsonReader(reader(\"null\"));\n1232: assertEquals(JsonToken.NULL, reader3.peek());\n1233: reader3.nextNull();\n1234: assertEquals(JsonToken.END_DOCUMENT, reader3.peek());\n1235: 1236: JsonReader reader4 = new JsonReader(reader(\"123\"));\n1237: assertEquals(123, reader4.nextInt());\n1238: assertEquals(JsonToken.END_DOCUMENT, reader4.peek());\n1239: 1240: JsonReader reader5 = new JsonReader(reader(\"123.4\"));\n1241: assertEquals(123.4, reader5.nextDouble());\n1242: assertEquals(JsonToken.END_DOCUMENT, reader5.peek());\n1243: 1244: JsonReader reader6 = new JsonReader(reader(\"\\\"a\\\"\"));\n1245: assertEquals(\"a\", reader6.nextString());\n1246: assertEquals(JsonToken.END_DOCUMENT, reader6.peek());\n1247: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "public JsonReader(Reader in) {\nif (in == null) {\nthrow new NullPointerException(\"in == null\");\n}\nthis.in = in;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<clinit>()V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;\n\nprivate static final int PEEKED_NONE = 0;\nprivate static final int PEEKED_BEGIN_OBJECT = 1;\nprivate static final int PEEKED_END_OBJECT = 2;\nprivate static final int PEEKED_BEGIN_ARRAY = 3;\nprivate static final int PEEKED_END_ARRAY = 4;\nprivate static final int PEEKED_TRUE = 5;\nprivate static final int PEEKED_FALSE = 6;\nprivate static final int PEEKED_NULL = 7;\nprivate static final int PEEKED_SINGLE_QUOTED = 8;\nprivate static final int PEEKED_DOUBLE_QUOTED = 9;\nprivate static final int PEEKED_UNQUOTED = 10;\n/** When this is returned, the string value is stored in peekedString. */\nprivate static final int PEEKED_BUFFERED = 11;\nprivate static final int PEEKED_SINGLE_QUOTED_NAME = 12;\nprivate static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\nprivate static final int PEEKED_UNQUOTED_NAME = 14;\n/** When this is returned, the integer value is stored in peekedLong. */\nprivate static final int PEEKED_LONG = 15;\nprivate static final int PEEKED_NUMBER = 16;\nprivate static final int PEEKED_EOF = 17;\n\n/* State machine when parsing numbers */\nprivate static final int NUMBER_CHAR_NONE = 0;\nprivate static final int NUMBER_CHAR_SIGN = 1;\nprivate static final int NUMBER_CHAR_DIGIT = 2;\nprivate static final int NUMBER_CHAR_DECIMAL = 3;\nprivate static final int NUMBER_CHAR_FRACTION_DIGIT = 4;\nprivate static final int NUMBER_CHAR_EXP_E = 5;\nprivate static final int NUMBER_CHAR_EXP_SIGN = 6;\nprivate static final int NUMBER_CHAR_EXP_DIGIT = 7;\n\n/** The input JSON. */\nprivate final Reader in;\n\n/** True to accept non-spec compliant JSON */\nprivate boolean lenient = false;\n\n/**\n* Use a manual buffer to easily read and unread upcoming characters, and\n* also so we can create strings without an intermediate StringBuilder.\n* We decode literals directly out of this buffer, so it must be at least as\n* long as the longest token that can be reported as a number.\n*/\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\n\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\n\nint peeked = PEEKED_NONE;\n\n/**\n* A peeked value that was composed entirely of digits with an optional\n* leading dash. Positive values may not have a leading 0.\n*/\nprivate long peekedLong;\n\n/**\n* The number of characters in a peeked number literal. Increment 'pos' by\n* this after reading a number.\n*/\nprivate int peekedNumberLength;\n\n/**\n* A peeked string that should be parsed on the next double, long or string.\n* This is populated before a numeric value is parsed and used if that parsing\n* fails.\n*/\nprivate String peekedString;\n\n/*\n* The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n*/\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\n{\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:doPeek()I",
                                    "method_body": "int doPeek() throws IOException {\nint peekStack = stack[stackSize - 1];\nif (peekStack == JsonScope.EMPTY_ARRAY) {\nstack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n} else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n// Look for a comma before the next element.\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase ']':\nreturn peeked = PEEKED_END_ARRAY;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated array\");\n}\n} else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\nstack[stackSize - 1] = JsonScope.DANGLING_NAME;\n// Look for a comma before the next element.\nif (peekStack == JsonScope.NONEMPTY_OBJECT) {\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '}':\nreturn peeked = PEEKED_END_OBJECT;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated object\");\n}\n}\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '\"':\nreturn peeked = PEEKED_DOUBLE_QUOTED_NAME;\ncase '\\'':\ncheckLenient();\nreturn peeked = PEEKED_SINGLE_QUOTED_NAME;\ncase '}':\nif (peekStack != JsonScope.NONEMPTY_OBJECT) {\nreturn peeked = PEEKED_END_OBJECT;\n} else {\nthrow syntaxError(\"Expected name\");\n}\ndefault:\ncheckLenient();\npos--; // Don't consume the first character in an unquoted string.\nif (isLiteral((char) c)) {\nreturn peeked = PEEKED_UNQUOTED_NAME;\n} else {\nthrow syntaxError(\"Expected name\");\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextBoolean()Z",
                                    "method_body": "public boolean nextBoolean() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nif (p == PEEKED_TRUE) {\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn true;\n} else if (p == PEEKED_FALSE) {\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn false;\n}\nthrow new IllegalStateException(\"Expected a boolean but was \" + peek()\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit -= pos;\nSystem.arraycopy(buffer, pos, buffer, 0, limit);\n} else {\nlimit = 0;\n}\n\npos = 0;\nint total;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\n\n// if this is the first read, consume an optional byte order mark (BOM) if it exists\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\npos++;\nlineStart++;\nminimum++;\n}\n\nif (limit >= minimum) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getLineNumber()I",
                                    "method_body": "int getLineNumber() {\nreturn lineNumber + 1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getColumnNumber()I",
                                    "method_body": "int getColumnNumber() {\nreturn pos - lineStart + 1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n/*\n* This code uses ugly local variables 'p' and 'l' representing the 'pos'\n* and 'limit' fields respectively. Using locals rather than fields saves\n* a few field reads for each whitespace character in a pretty-printed\n* document, resulting in a 5% speedup. We need to flush 'p' to its field\n* before any (potentially indirect) call to fillBuffer() and reread both\n* 'p' and 'l' after any (potentially indirect) call to the same method.\n*/\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nwhile (true) {\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\nbreak;\n}\np = pos;\nl = limit;\n}\n\nint c = buffer[p++];\nif (c == '\\n') {\nlineNumber++;\nlineStart = p;\ncontinue;\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\ncontinue;\n}\n\nif (c == '/') {\npos = p;\nif (p == l) {\npos--; // push back '/' so it's still in the buffer when this method returns\nboolean charsLoaded = fillBuffer(2);\npos++; // consume the '/' again\nif (!charsLoaded) {\nreturn c;\n}\n}\n\ncheckLenient();\nchar peek = buffer[pos];\nswitch (peek) {\ncase '*':\n// skip a /* c-style comment */\npos++;\nif (!skipTo(\"*/\")) {\nthrow syntaxError(\"Unterminated comment\");\n}\np = pos + 2;\nl = limit;\ncontinue;\n\ncase '/':\n// skip a // end-of-line comment\npos++;\nskipToEndOfLine();\np = pos;\nl = limit;\ncontinue;\n\ndefault:\nreturn c;\n}\n} else if (c == '#') {\npos = p;\n/*\n* Skip a # hash end-of-line comment. The JSON RFC doesn't\n* specify this behaviour, but it's required to parse\n* existing documents. See http://b/2571423.\n*/\ncheckLenient();\nskipToEndOfLine();\np = pos;\nl = limit;\n} else {\npos = p;\nreturn c;\n}\n}\nif (throwOnEof) {\nthrow new EOFException(\"End of input\"\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n} else {\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:checkLenient()V",
                                    "method_body": "private void checkLenient() throws IOException {\nif (!lenient) {\nthrow syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\");\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getPath()Ljava/lang/String;",
                                    "method_body": "public String getPath() {\nStringBuilder result = new StringBuilder().append('$');\nfor (int i = 0, size = stackSize; i < size; i++) {\nswitch (stack[i]) {\ncase JsonScope.EMPTY_ARRAY:\ncase JsonScope.NONEMPTY_ARRAY:\nresult.append('[').append(pathIndices[i]).append(']');\nbreak;\n\ncase JsonScope.EMPTY_OBJECT:\ncase JsonScope.DANGLING_NAME:\ncase JsonScope.NONEMPTY_OBJECT:\nresult.append('.');\nif (pathNames[i] != null) {\nresult.append(pathNames[i]);\n}\nbreak;\n\ncase JsonScope.NONEMPTY_DOCUMENT:\ncase JsonScope.EMPTY_DOCUMENT:\ncase JsonScope.CLOSED:\nbreak;\n}\n}\nreturn result.toString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:syntaxError(Ljava/lang/String;)Ljava/io/IOException;",
                                    "method_body": "private IOException syntaxError(String message) throws IOException {\nthrow new MalformedJsonException(message\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.MalformedJsonException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public MalformedJsonException(String msg) {\nsuper(msg);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.stream.JsonReaderTest.testTopLevelValueTypeWithSkipValue",
                            "test_body": "1249: public void testTopLevelValueTypeWithSkipValue() throws IOException {\n1250: JsonReader reader = new JsonReader(reader(\"true\"));\n1251: reader.skipValue();\n1252: assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n1253: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "public JsonReader(Reader in) {\nif (in == null) {\nthrow new NullPointerException(\"in == null\");\n}\nthis.in = in;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<clinit>()V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;\n\nprivate static final int PEEKED_NONE = 0;\nprivate static final int PEEKED_BEGIN_OBJECT = 1;\nprivate static final int PEEKED_END_OBJECT = 2;\nprivate static final int PEEKED_BEGIN_ARRAY = 3;\nprivate static final int PEEKED_END_ARRAY = 4;\nprivate static final int PEEKED_TRUE = 5;\nprivate static final int PEEKED_FALSE = 6;\nprivate static final int PEEKED_NULL = 7;\nprivate static final int PEEKED_SINGLE_QUOTED = 8;\nprivate static final int PEEKED_DOUBLE_QUOTED = 9;\nprivate static final int PEEKED_UNQUOTED = 10;\n/** When this is returned, the string value is stored in peekedString. */\nprivate static final int PEEKED_BUFFERED = 11;\nprivate static final int PEEKED_SINGLE_QUOTED_NAME = 12;\nprivate static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\nprivate static final int PEEKED_UNQUOTED_NAME = 14;\n/** When this is returned, the integer value is stored in peekedLong. */\nprivate static final int PEEKED_LONG = 15;\nprivate static final int PEEKED_NUMBER = 16;\nprivate static final int PEEKED_EOF = 17;\n\n/* State machine when parsing numbers */\nprivate static final int NUMBER_CHAR_NONE = 0;\nprivate static final int NUMBER_CHAR_SIGN = 1;\nprivate static final int NUMBER_CHAR_DIGIT = 2;\nprivate static final int NUMBER_CHAR_DECIMAL = 3;\nprivate static final int NUMBER_CHAR_FRACTION_DIGIT = 4;\nprivate static final int NUMBER_CHAR_EXP_E = 5;\nprivate static final int NUMBER_CHAR_EXP_SIGN = 6;\nprivate static final int NUMBER_CHAR_EXP_DIGIT = 7;\n\n/** The input JSON. */\nprivate final Reader in;\n\n/** True to accept non-spec compliant JSON */\nprivate boolean lenient = false;\n\n/**\n* Use a manual buffer to easily read and unread upcoming characters, and\n* also so we can create strings without an intermediate StringBuilder.\n* We decode literals directly out of this buffer, so it must be at least as\n* long as the longest token that can be reported as a number.\n*/\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\n\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\n\nint peeked = PEEKED_NONE;\n\n/**\n* A peeked value that was composed entirely of digits with an optional\n* leading dash. Positive values may not have a leading 0.\n*/\nprivate long peekedLong;\n\n/**\n* The number of characters in a peeked number literal. Increment 'pos' by\n* this after reading a number.\n*/\nprivate int peekedNumberLength;\n\n/**\n* A peeked string that should be parsed on the next double, long or string.\n* This is populated before a numeric value is parsed and used if that parsing\n* fails.\n*/\nprivate String peekedString;\n\n/*\n* The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n*/\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\n{\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:doPeek()I",
                                    "method_body": "int doPeek() throws IOException {\nint peekStack = stack[stackSize - 1];\nif (peekStack == JsonScope.EMPTY_ARRAY) {\nstack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n} else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n// Look for a comma before the next element.\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase ']':\nreturn peeked = PEEKED_END_ARRAY;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated array\");\n}\n} else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\nstack[stackSize - 1] = JsonScope.DANGLING_NAME;\n// Look for a comma before the next element.\nif (peekStack == JsonScope.NONEMPTY_OBJECT) {\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '}':\nreturn peeked = PEEKED_END_OBJECT;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated object\");\n}\n}\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '\"':\nreturn peeked = PEEKED_DOUBLE_QUOTED_NAME;\ncase '\\'':\ncheckLenient();\nreturn peeked = PEEKED_SINGLE_QUOTED_NAME;\ncase '}':\nif (peekStack != JsonScope.NONEMPTY_OBJECT) {\nreturn peeked = PEEKED_END_OBJECT;\n} else {\nthrow syntaxError(\"Expected name\");\n}\ndefault:\ncheckLenient();\npos--; // Don't consume the first character in an unquoted string.\nif (isLiteral((char) c)) {\nreturn peeked = PEEKED_UNQUOTED_NAME;\n} else {\nthrow syntaxError(\"Expected name\");\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit -= pos;\nSystem.arraycopy(buffer, pos, buffer, 0, limit);\n} else {\nlimit = 0;\n}\n\npos = 0;\nint total;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\n\n// if this is the first read, consume an optional byte order mark (BOM) if it exists\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\npos++;\nlineStart++;\nminimum++;\n}\n\nif (limit >= minimum) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getLineNumber()I",
                                    "method_body": "int getLineNumber() {\nreturn lineNumber + 1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getColumnNumber()I",
                                    "method_body": "int getColumnNumber() {\nreturn pos - lineStart + 1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n/*\n* This code uses ugly local variables 'p' and 'l' representing the 'pos'\n* and 'limit' fields respectively. Using locals rather than fields saves\n* a few field reads for each whitespace character in a pretty-printed\n* document, resulting in a 5% speedup. We need to flush 'p' to its field\n* before any (potentially indirect) call to fillBuffer() and reread both\n* 'p' and 'l' after any (potentially indirect) call to the same method.\n*/\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nwhile (true) {\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\nbreak;\n}\np = pos;\nl = limit;\n}\n\nint c = buffer[p++];\nif (c == '\\n') {\nlineNumber++;\nlineStart = p;\ncontinue;\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\ncontinue;\n}\n\nif (c == '/') {\npos = p;\nif (p == l) {\npos--; // push back '/' so it's still in the buffer when this method returns\nboolean charsLoaded = fillBuffer(2);\npos++; // consume the '/' again\nif (!charsLoaded) {\nreturn c;\n}\n}\n\ncheckLenient();\nchar peek = buffer[pos];\nswitch (peek) {\ncase '*':\n// skip a /* c-style comment */\npos++;\nif (!skipTo(\"*/\")) {\nthrow syntaxError(\"Unterminated comment\");\n}\np = pos + 2;\nl = limit;\ncontinue;\n\ncase '/':\n// skip a // end-of-line comment\npos++;\nskipToEndOfLine();\np = pos;\nl = limit;\ncontinue;\n\ndefault:\nreturn c;\n}\n} else if (c == '#') {\npos = p;\n/*\n* Skip a # hash end-of-line comment. The JSON RFC doesn't\n* specify this behaviour, but it's required to parse\n* existing documents. See http://b/2571423.\n*/\ncheckLenient();\nskipToEndOfLine();\np = pos;\nl = limit;\n} else {\npos = p;\nreturn c;\n}\n}\nif (throwOnEof) {\nthrow new EOFException(\"End of input\"\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n} else {\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:checkLenient()V",
                                    "method_body": "private void checkLenient() throws IOException {\nif (!lenient) {\nthrow syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\");\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getPath()Ljava/lang/String;",
                                    "method_body": "public String getPath() {\nStringBuilder result = new StringBuilder().append('$');\nfor (int i = 0, size = stackSize; i < size; i++) {\nswitch (stack[i]) {\ncase JsonScope.EMPTY_ARRAY:\ncase JsonScope.NONEMPTY_ARRAY:\nresult.append('[').append(pathIndices[i]).append(']');\nbreak;\n\ncase JsonScope.EMPTY_OBJECT:\ncase JsonScope.DANGLING_NAME:\ncase JsonScope.NONEMPTY_OBJECT:\nresult.append('.');\nif (pathNames[i] != null) {\nresult.append(pathNames[i]);\n}\nbreak;\n\ncase JsonScope.NONEMPTY_DOCUMENT:\ncase JsonScope.EMPTY_DOCUMENT:\ncase JsonScope.CLOSED:\nbreak;\n}\n}\nreturn result.toString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:syntaxError(Ljava/lang/String;)Ljava/io/IOException;",
                                    "method_body": "private IOException syntaxError(String message) throws IOException {\nthrow new MalformedJsonException(message\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.MalformedJsonException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public MalformedJsonException(String msg) {\nsuper(msg);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:skipValue()V",
                                    "method_body": "public void skipValue() throws IOException {\nint count = 0;\ndo {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\n\nif (p == PEEKED_BEGIN_ARRAY) {\npush(JsonScope.EMPTY_ARRAY);\ncount++;\n} else if (p == PEEKED_BEGIN_OBJECT) {\npush(JsonScope.EMPTY_OBJECT);\ncount++;\n} else if (p == PEEKED_END_ARRAY) {\nstackSize--;\ncount--;\n} else if (p == PEEKED_END_OBJECT) {\nstackSize--;\ncount--;\n} else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {\nskipUnquotedValue();\n} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {\nskipQuotedValue('\\'');\n} else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {\nskipQuotedValue('\"');\n} else if (p == PEEKED_NUMBER) {\npos += peekedNumberLength;\n}\npeeked = PEEKED_NONE;\n} while (count != 0);\n\npathIndices[stackSize - 1]++;\npathNames[stackSize - 1] = \"null\";\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.stream.JsonWriterTest.testTopLevelValueTypes",
                            "test_body": "28: public void testTopLevelValueTypes() throws IOException {\n29: StringWriter string1 = new StringWriter();\n30: JsonWriter writer1 = new JsonWriter(string1);\n31: writer1.value(true);\n32: writer1.close();\n33: assertEquals(\"true\", string1.toString());\n34: 35: StringWriter string2 = new StringWriter();\n36: JsonWriter writer2 = new JsonWriter(string2);\n37: writer2.nullValue();\n38: writer2.close();\n39: assertEquals(\"null\", string2.toString());\n40: 41: StringWriter string3 = new StringWriter();\n42: JsonWriter writer3 = new JsonWriter(string3);\n43: writer3.value(123);\n44: writer3.close();\n45: assertEquals(\"123\", string3.toString());\n46: 47: StringWriter string4 = new StringWriter();\n48: JsonWriter writer4 = new JsonWriter(string4);\n49: writer4.value(123.4);\n50: writer4.close();\n51: assertEquals(\"123.4\", string4.toString());\n52: 53: StringWriter string5 = new StringWriter();\n54: JsonWriter writert = new JsonWriter(string5);\n55: writert.value(\"a\");\n56: writert.close();\n57: assertEquals(\"\\\"a\\\"\", string5.toString());\n58: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:<init>(Ljava/io/Writer;)V",
                                    "method_body": "public JsonWriter(Writer out) {\nif (out == null) {\nthrow new NullPointerException(\"out == null\");\n}\nthis.out = out;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:<clinit>()V",
                                    "method_body": "private static final String[] REPLACEMENT_CHARS;\nprivate static final String[] HTML_SAFE_REPLACEMENT_CHARS;\nstatic {\nREPLACEMENT_CHARS = new String[128];\nfor (int i = 0; i <= 0x1f; i++) {\nREPLACEMENT_CHARS[i] = String.format(\"\\\\u%04x\", (int) i);\n}\nREPLACEMENT_CHARS['\"'] = \"\\\\\\\"\";\nREPLACEMENT_CHARS['\\\\'] = \"\\\\\\\\\";\nREPLACEMENT_CHARS['\\t'] = \"\\\\t\";\nREPLACEMENT_CHARS['\\b'] = \"\\\\b\";\nREPLACEMENT_CHARS['\\n'] = \"\\\\n\";\nREPLACEMENT_CHARS['\\r'] = \"\\\\r\";\nREPLACEMENT_CHARS['\\f'] = \"\\\\f\";\nHTML_SAFE_REPLACEMENT_CHARS = REPLACEMENT_CHARS.clone();\nHTML_SAFE_REPLACEMENT_CHARS['<'] = \"\\\\u003c\";\nHTML_SAFE_REPLACEMENT_CHARS['>'] = \"\\\\u003e\";\nHTML_SAFE_REPLACEMENT_CHARS['&'] = \"\\\\u0026\";\nHTML_SAFE_REPLACEMENT_CHARS['='] = \"\\\\u003d\";\nHTML_SAFE_REPLACEMENT_CHARS['\\''] = \"\\\\u0027\";\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:push(I)V",
                                    "method_body": "private void push(int newTop) {\nif (stackSize == stack.length) {\nint[] newStack = new int[stackSize * 2];\nSystem.arraycopy(stack, 0, newStack, 0, stackSize);\nstack = newStack;\n}\nstack[stackSize++] = newTop;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:peek()I",
                                    "method_body": "private int peek() {\nif (stackSize == 0) {\nthrow new IllegalStateException(\"JsonWriter is closed.\");\n}\nreturn stack[stackSize - 1];\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:writeDeferredName()V",
                                    "method_body": "private void writeDeferredName() throws IOException {\nif (deferredName != null) {\nbeforeName();\nstring(deferredName);\ndeferredName = null;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:value(Z)Lcom/google/gson/stream/JsonWriter;",
                                    "method_body": "public JsonWriter value(boolean value) throws IOException {\nwriteDeferredName();\nbeforeValue(false);\nout.write(value ? \"true\" : \"false\");\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:beforeValue(Z)V",
                                    "method_body": "private void beforeValue(boolean root) throws IOException {\nswitch (peek()) {\ncase NONEMPTY_DOCUMENT:\nif (!lenient) {\nthrow new IllegalStateException(\n\"JSON must have only one top-level value.\");\n}\n// fall-through\ncase EMPTY_DOCUMENT: // first in document\nif (!lenient && !root) {\nthrow new IllegalStateException(\n\"JSON must start with an array or an object.\");\n}\nreplaceTop(NONEMPTY_DOCUMENT);\nbreak;\n\ncase EMPTY_ARRAY: // first in array\nreplaceTop(NONEMPTY_ARRAY);\nnewline();\nbreak;\n\ncase NONEMPTY_ARRAY: // another in array\nout.append(',');\nnewline();\nbreak;\n\ncase DANGLING_NAME: // value for name\nout.append(separator);\nreplaceTop(NONEMPTY_OBJECT);\nbreak;\n\ndefault:\nthrow new IllegalStateException(\"Nesting problem.\");\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 5,
                    "tests": [
                        {
                            "test_name": "com.google.gson.DefaultDateTypeAdapterTest.testDateDeserializationISO8601",
                            "test_body": "127: public void testDateDeserializationISO8601() throws Exception {\n128: DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter();\n129: assertParsed(\"1970-01-01T00:00:00.000Z\", adapter);\n130: assertParsed(\"1970-01-01T00:00Z\", adapter);\n131: assertParsed(\"1970-01-01T00:00:00+00:00\", adapter);\n132: assertParsed(\"1970-01-01T01:00:00+01:00\", adapter);\n133: assertParsed(\"1970-01-01T01:00:00+01\", adapter);\n134: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:<init>(Ljava/lang/String;)V",
                                    "method_body": "public JsonPrimitive(String string) {\nsetValue(string);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:<clinit>()V",
                                    "method_body": "private static final Class<?>[] PRIMITIVE_TYPES = { int.class, long.class, short.class,\nfloat.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class,\nShort.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class };"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:setValue(Ljava/lang/Object;)V",
                                    "method_body": "void setValue(Object primitive) {\nif (primitive instanceof Character) {\n// convert characters to strings since in JSON, characters are represented as a single\n// character string\nchar c = ((Character) primitive).charValue();\nthis.value = String.valueOf(c);\n} else {\n$Gson$Preconditions.checkArgument(primitive instanceof Number\n|| isPrimitiveOrString(primitive));\nthis.value = primitive;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:isBoolean()Z",
                                    "method_body": "public boolean isBoolean() {\nreturn value instanceof Boolean;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:isNumber()Z",
                                    "method_body": "public boolean isNumber() {\nreturn value instanceof Number;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:getAsString()Ljava/lang/String;",
                                    "method_body": "public String getAsString() {\nif (isNumber()) {\nreturn getAsNumber().toString();\n} else if (isBoolean()) {\nreturn getAsBooleanWrapper().toString();\n} else {\nreturn (String) value;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:isPrimitiveOrString(Ljava/lang/Object;)Z",
                                    "method_body": "private static boolean isPrimitiveOrString(Object target) {\nif (target instanceof String) {\nreturn true;\n}\n\nClass<?> classOfPrimitive = target.getClass();\nfor (Class<?> standardPrimitive : PRIMITIVE_TYPES) {\nif (standardPrimitive.isAssignableFrom(classOfPrimitive)) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\nthrow new IllegalArgumentException();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonParseException:<init>(Ljava/lang/String;Ljava/lang/Throwable;)V",
                                    "method_body": "public JsonParseException(String msg, Throwable cause) {\nsuper(msg, cause);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonSyntaxException:<init>(Ljava/lang/String;Ljava/lang/Throwable;)V",
                                    "method_body": "public JsonSyntaxException(String msg, Throwable cause) {\nsuper(msg, cause);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultDateTypeAdapter:<init>()V",
                                    "method_body": "DefaultDateTypeAdapter() {\nthis(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),\nDateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultDateTypeAdapter:<init>(Ljava/text/DateFormat;Ljava/text/DateFormat;)V",
                                    "method_body": "DefaultDateTypeAdapter(DateFormat enUsFormat, DateFormat localFormat) {\nthis.enUsFormat = enUsFormat;\nthis.localFormat = localFormat;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultDateTypeAdapter:deserialize(Lcom/google/gson/JsonElement;Ljava/lang/reflect/Type;Lcom/google/gson/JsonDeserializationContext;)Ljava/util/Date;",
                                    "method_body": "public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\nthrows JsonParseException {\nif (!(json instanceof JsonPrimitive)) {\nthrow new JsonParseException(\"The date should be a string value\");\n}\nDate date = deserializeToDate(json);\nif (typeOfT == Date.class) {\nreturn date;\n} else if (typeOfT == Timestamp.class) {\nreturn new Timestamp(date.getTime());\n} else if (typeOfT == java.sql.Date.class) {\nreturn new java.sql.Date(date.getTime());\n} else {\nthrow new IllegalArgumentException(getClass() + \" cannot deserialize to \" + typeOfT);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultDateTypeAdapter:deserializeToDate(Lcom/google/gson/JsonElement;)Ljava/util/Date;",
                                    "method_body": "private Date deserializeToDate(JsonElement json) {\nsynchronized (localFormat) {\ntry {\nreturn localFormat.parse(json.getAsString());\n} catch (ParseException ignored) {}\ntry {\nreturn enUsFormat.parse(json.getAsString());\n} catch (ParseException ignored) {}\ntry {\nreturn ISO8601Utils.parse(json.getAsString(), new ParsePosition(0));\n} catch (ParseException e) {\nthrow new JsonSyntaxException(json.getAsString(), e);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.util.ISO8601Utils:<clinit>()V",
                                    "method_body": "private static final String UTC_ID = \"UTC\";\n/**\n* The UTC timezone, prefetched to avoid more lookups.\n*\n* @since 2.7\n*/\nprivate static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(UTC_ID);\n\n/*\n/**********************************************************\n/* Formatting\n/**********************************************************\n*/\n\n/**\n* Format a date into 'yyyy-MM-ddThh:mm:ssZ' (default timezone, no milliseconds precision)\n*\n* @param date the date to format\n* @return the date formatted as 'yyyy-MM-ddThh:mm:ssZ'\n*/\npublic static String format(Date date) {\nreturn format(date, false, TIMEZONE_UTC);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.util.ISO8601Utils:parse(Ljava/lang/String;Ljava/text/ParsePosition;)Ljava/util/Date;",
                                    "method_body": "public static Date parse(String date, ParsePosition pos) throws ParseException {\nException fail = null;\ntry {\nint offset = pos.getIndex();\n\n// extract year\nint year = parseInt(date, offset, offset += 4);\nif (checkOffset(date, offset, '-')) {\noffset += 1;\n}\n\n// extract month\nint month = parseInt(date, offset, offset += 2);\nif (checkOffset(date, offset, '-')) {\noffset += 1;\n}\n\n// extract day\nint day = parseInt(date, offset, offset += 2);\n// default time value\nint hour = 0;\nint minutes = 0;\nint seconds = 0;\nint milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n\n// if the value has no time component (and no time zone), we are done\nboolean hasT = checkOffset(date, offset, 'T');\n\nif (!hasT && (date.length() <= offset)) {\nCalendar calendar = new GregorianCalendar(year, month - 1, day);\n\npos.setIndex(offset);\nreturn calendar.getTime();\n}\n\nif (hasT) {\n\n// extract hours, minutes, seconds and milliseconds\nhour = parseInt(date, offset += 1, offset += 2);\nif (checkOffset(date, offset, ':')) {\noffset += 1;\n}\n\nminutes = parseInt(date, offset, offset += 2);\nif (checkOffset(date, offset, ':')) {\noffset += 1;\n}\n// second and milliseconds can be optional\nif (date.length() > offset) {\nchar c = date.charAt(offset);\nif (c != 'Z' && c != '+' && c != '-') {\nseconds = parseInt(date, offset, offset += 2);\nif (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds\n// milliseconds can be optional in the format\nif (checkOffset(date, offset, '.')) {\noffset += 1;\nint endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit\nint parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits\nint fraction = parseInt(date, offset, parseEndOffset);\n// compensate for \"missing\" digits\nswitch (parseEndOffset - offset) { // number of digits parsed\ncase 2:\nmilliseconds = fraction * 10;\nbreak;\ncase 1:\nmilliseconds = fraction * 100;\nbreak;\ndefault:\nmilliseconds = fraction;\n}\noffset = endOffset;\n}\n}\n}\n}\n\n// extract timezone\nif (date.length() <= offset) {\nthrow new IllegalArgumentException(\"No time zone indicator\");\n}\n\nTimeZone timezone = null;\nchar timezoneIndicator = date.charAt(offset);\n\nif (timezoneIndicator == 'Z') {\ntimezone = TIMEZONE_UTC;\noffset += 1;\n} else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\nString timezoneOffset = date.substring(offset);\n\n// When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n\noffset += timezoneOffset.length();\n// 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\nif (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\ntimezone = TIMEZONE_UTC;\n} else {\n// 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n//    not sure why, but that's the way it looks. Further, Javadocs for\n//    `java.util.TimeZone` specifically instruct use of GMT as base for\n//    custom timezones... odd.\nString timezoneId = \"GMT\" + timezoneOffset;\n//                    String timezoneId = \"UTC\" + timezoneOffset;\n\ntimezone = TimeZone.getTimeZone(timezoneId);\n\nString act = timezone.getID();\nif (!act.equals(timezoneId)) {\n/* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\n*    one without. If so, don't sweat.\n*   Yes, very inefficient. Hopefully not hit often.\n*   If it becomes a perf problem, add 'loose' comparison instead.\n*/\nString cleaned = act.replace(\":\", \"\");\nif (!cleaned.equals(timezoneId)) {\nthrow new IndexOutOfBoundsException(\"Mismatching time zone indicator: \"+timezoneId+\" given, resolves to \"\n+timezone.getID());\n}\n}\n}\n} else {\nthrow new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator+\"'\");\n}\n\nCalendar calendar = new GregorianCalendar(timezone);\ncalendar.setLenient(false);\ncalendar.set(Calendar.YEAR, year);\ncalendar.set(Calendar.MONTH, month - 1);\ncalendar.set(Calendar.DAY_OF_MONTH, day);\ncalendar.set(Calendar.HOUR_OF_DAY, hour);\ncalendar.set(Calendar.MINUTE, minutes);\ncalendar.set(Calendar.SECOND, seconds);\ncalendar.set(Calendar.MILLISECOND, milliseconds);\n\npos.setIndex(offset);\nreturn calendar.getTime();\n// If we get a ParseException it'll already have the right message/offset.\n// Other exception types can convert here.\n} catch (IndexOutOfBoundsException e) {\nfail = e;\n} catch (NumberFormatException e) {\nfail = e;\n} catch (IllegalArgumentException e) {\nfail = e;\n}\nString input = (date == null) ? null : ('\"' + date + \"'\");\nString msg = fail.getMessage();\nif (msg == null || msg.isEmpty()) {\nmsg = \"(\"+fail.getClass().getName()+\")\";\n}\nParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\nex.initCause(fail);\nthrow ex;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.util.ISO8601Utils:checkOffset(Ljava/lang/String;IC)Z",
                                    "method_body": "private static boolean checkOffset(String value, int offset, char expected) {\nreturn (offset < value.length()) && (value.charAt(offset) == expected);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.util.ISO8601Utils:parseInt(Ljava/lang/String;II)I",
                                    "method_body": "private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException {\nif (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) {\nthrow new NumberFormatException(value);\n}\n// use same logic as in Integer.parseInt() but less generic we're not supporting negative values\nint i = beginIndex;\nint result = 0;\nint digit;\nif (i < endIndex) {\ndigit = Character.digit(value.charAt(i++), 10);\nif (digit < 0) {\nthrow new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\n}\nresult = -digit;\n}\nwhile (i < endIndex) {\ndigit = Character.digit(value.charAt(i++), 10);\nif (digit < 0) {\nthrow new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\n}\nresult *= 10;\nresult -= digit;\n}\nreturn -result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.util.ISO8601Utils:indexOfNonDigit(Ljava/lang/String;I)I",
                                    "method_body": "private static int indexOfNonDigit(String string, int offset) {\nfor (int i = offset; i < string.length(); i++) {\nchar c = string.charAt(i);\nif (c < '0' || c > '9') return i;\n}\nreturn string.length();\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 6,
                    "tests": [
                        {
                            "test_name": "com.google.gson.regression.JsonAdapterNullSafeTest.testNullSafeBugDeserialize",
                            "test_body": "34: public void testNullSafeBugDeserialize() throws Exception {\n35: Device device = gson.fromJson(\"{'id':'ec57803e2'}\", Device.class);\n36: assertEquals(\"ec57803e2\", device.id);\n37: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\nCollections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\nDEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\nDEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\nLongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingPolicy,\nfinal Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,\nboolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\nboolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,\nLongSerializationPolicy longSerializationPolicy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nthis.lenient = lenient;\n\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n\n// built-in type adapters that cannot be overridden\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\n\n// the excluder must precede all adapters that handle user-defined types\nfactories.add(excluder);\n\n// user's type adapters\nfactories.addAll(typeAdapterFactories);\n\n// type adapters for basic platform types\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nTypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\ndoubleAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfloatAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\nfactories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\nfactories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.CURRENCY_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\n\n// type adapters for composite and user-defined types\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nfactories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nconstructorConstructor, fieldNamingPolicy, excluder));\n\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.DOUBLE;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Double read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\ndouble doubleValue = value.doubleValue();\ncheckValidFloatingPoint(doubleValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.FLOAT;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Float read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn (float) in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nfloat floatValue = value.floatValue();\ncheckValidFloatingPoint(floatValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Number read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextLong();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nout.value(value.toString());\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLong>() {\n@Override public void write(JsonWriter out, AtomicLong value) throws IOException {\nlongAdapter.write(out, value.get());\n}\n@Override public AtomicLong read(JsonReader in) throws IOException {\nNumber value = longAdapter.read(in);\nreturn new AtomicLong(value.longValue());\n}\n}.nullSafe();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongArrayAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLongArray>() {\n@Override public void write(JsonWriter out, AtomicLongArray value) throws IOException {\nout.beginArray();\nfor (int i = 0, length = value.length(); i < length; i++) {\nlongAdapter.write(out, value.get(i));\n}\nout.endArray();\n}\n@Override public AtomicLongArray read(JsonReader in) throws IOException {\nList<Long> list = new ArrayList<Long>();\nin.beginArray();\nwhile (in.hasNext()) {\nlong value = longAdapter.read(in).longValue();\nlist.add(value);\n}\nin.endArray();\nint length = list.size();\nAtomicLongArray array = new AtomicLongArray(length);\nfor (int i = 0; i < length; ++i) {\narray.set(i, list.get(i));\n}\nreturn array;\n}\n}.nullSafe();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type);\nif (cached != null) {\nreturn (TypeAdapter<T>) cached;\n}\n\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\n}\n\n// the key and value type parameters always agree\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nreturn ongoingCall;\n}\n\ntry {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\n\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\n}\n}\nthrow new IllegalArgumentException(\"GSON cannot handle \" + type);\n} finally {\nthreadCalls.remove(type);\n\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getDelegateAdapter(Lcom/google/gson/TypeAdapterFactory;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getDelegateAdapter(TypeAdapterFactory skipPast, TypeToken<T> type) {\nboolean skipPastFound = false;\n// Skip past if and only if the specified factory is present in the factories.\n// This is useful because the factories created through JsonAdapter annotations are not\n// registered in this list.\nif (!factories.contains(skipPast)) skipPastFound = true;\n\nfor (TypeAdapterFactory factory : factories) {\nif (!skipPastFound) {\nif (factory == skipPast) {\nskipPastFound = true;\n}\ncontinue;\n}\n\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\nreturn candidate;\n}\n}\nthrow new IllegalArgumentException(\"GSON cannot serialize \" + type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:newJsonReader(Ljava/io/Reader;)Lcom/google/gson/stream/JsonReader;",
                                    "method_body": "public JsonReader newJsonReader(Reader reader) {\nJsonReader jsonReader = new JsonReader(reader);\njsonReader.setLenient(lenient);\nreturn jsonReader;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException {\nObject object = fromJson(json, (Type) classOfT);\nreturn Primitives.wrap(classOfT).cast(object);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {\nif (json == null) {\nreturn null;\n}\nStringReader reader = new StringReader(json);\nT target = (T) fromJson(reader, typeOfT);\nreturn target;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/io/Reader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nJsonReader jsonReader = newJsonReader(json);\nT object = (T) fromJson(jsonReader, typeOfT);\nassertFullConsumption(object, jsonReader);\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Lcom/google/gson/stream/JsonReader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nboolean isEmpty = true;\nboolean oldLenient = reader.isLenient();\nreader.setLenient(true);\ntry {\nreader.peek();\nisEmpty = false;\nTypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\nTypeAdapter<T> typeAdapter = getAdapter(typeToken);\nT object = typeAdapter.read(reader);\nreturn object;\n} catch (EOFException e) {\n/*\n* For compatibility with JSON 1.5 and earlier, we return null for empty\n* documents instead of throwing.\n*/\nif (isEmpty) {\nreturn null;\n}\nthrow new JsonSyntaxException(e);\n} catch (IllegalStateException e) {\nthrow new JsonSyntaxException(e);\n} catch (IOException e) {\n// TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException\nthrow new JsonSyntaxException(e);\n} finally {\nreader.setLenient(oldLenient);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\n\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate boolean requireExpose;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n\n@Override protected Excluder clone() {\ntry {\nreturn (Excluder) super.clone();\n} catch (CloneNotSupportedException e) {\nthrow new AssertionError(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\n\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}\n\nreturn new TypeAdapter<T>() {\n/** The delegate is lazily created because it may not be needed, and creating it may fail. */\nprivate TypeAdapter<T> delegate;\n\n@Override public T read(JsonReader in) throws IOException {\nif (skipDeserialize) {\nin.skipValue();\nreturn null;\n}\nreturn delegate().read(in);\n}\n\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (skipSerialize) {\nout.nullValue();\nreturn;\n}\ndelegate().write(out, value);\n}\n\nprivate TypeAdapter<T> delegate() {\nTypeAdapter<T> d = delegate;\nreturn d != null\n? d\n: (delegate = gson.getDelegateAdapter(Excluder.this, type));\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\n&& !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\nreturn true;\n}\n\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nreturn true;\n}\n\nif (isAnonymousOrLocal(clazz)) {\nreturn true;\n}\n\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nif (exclusionStrategy.shouldSkipClass(clazz)) {\nreturn true;\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n&& (clazz.isAnonymousClass() || clazz.isLocalClass());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\n\n// first try an instance creator\n\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn typeCreator.createInstance(type);\n}\n};\n}\n\n// Next try raw type match for instance creators\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> rawTypeCreator =\n(InstanceCreator<T>) instanceCreators.get(rawType);\nif (rawTypeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn rawTypeCreator.createInstance(type);\n}\n};\n}\n\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nreturn defaultConstructor;\n}\n\nObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\nif (defaultImplementation != null) {\nreturn defaultImplementation;\n}\n\n// finally try unsafe\nreturn newUnsafeAllocator(type, rawType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultConstructor(Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\ntry {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\n}\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"unchecked\") // T is the same raw type as is requested\n@Override public T construct() {\ntry {\nObject[] args = null;\nreturn (T) constructor.newInstance(args);\n} catch (InstantiationException e) {\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\", e);\n} catch (InvocationTargetException e) {\n// TODO: don't wrap if cause is unchecked!\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",\ne.getTargetException());\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\n}\n};\n} catch (NoSuchMethodException e) {\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n@Override\npublic void write(JsonWriter out, Class value) throws IOException {\nif (value == null) {\nout.nullValue();\n} else {\nthrow new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n+ value.getName() + \". Forgot to register a type adapter?\");\n}\n}\n@Override\npublic Class read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n} else {\nthrow new UnsupportedOperationException(\n\"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n}\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:nullSafe()Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public final TypeAdapter<T> nullSafe() {\nreturn new TypeAdapter<T>() {\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (value == null) {\nout.nullValue();\n} else {\nTypeAdapter.this.write(out, value);\n}\n}\n@Override public T read(JsonReader reader) throws IOException {\nif (reader.peek() == JsonToken.NULL) {\nreader.nextNull();\nreturn null;\n}\nreturn TypeAdapter.this.read(reader);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$35:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$26:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}\n\nfinal TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\nreturn (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n@Override public Timestamp read(JsonReader in) throws IOException {\nDate date = dateTypeAdapter.read(in);\nreturn date != null ? new Timestamp(date.getTime()) : null;\n}\n\n@Override public void write(JsonWriter out, Timestamp value) throws IOException {\ndateTypeAdapter.write(out, value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$34:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nType elementType = $Gson$Types.getCollectionElementType(type, rawType);\nTypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // create() doesn't define a type parameter\nTypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nClass<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\nType[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\nTypeAdapter<?> keyAdapter = getKeyAdapter(gson, keyAndValueTypes[0]);\nTypeAdapter<?> valueAdapter = gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n// we don't define a type parameter for the key or value types\nTypeAdapter<T> result = new Adapter(gson, keyAndValueTypes[0], keyAdapter,\nkeyAndValueTypes[1], valueAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\nJsonAdapter annotation = targetType.getRawType().getAnnotation(JsonAdapter.class);\nif (annotation == null) {\nreturn null;\n}\nreturn (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:getTypeAdapter(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;Lcom/google/gson/annotations/JsonAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\nTypeToken<?> fieldType, JsonAdapter annotation) {\nClass<?> value = annotation.value();\nTypeAdapter<?> typeAdapter;\nif (TypeAdapter.class.isAssignableFrom(value)) {\nClass<TypeAdapter<?>> typeAdapterClass = (Class<TypeAdapter<?>>) value;\ntypeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();\n} else if (TypeAdapterFactory.class.isAssignableFrom(value)) {\nClass<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;\ntypeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterFactory))\n.construct()\n.create(gson, fieldType);\n} else {\nthrow new IllegalArgumentException(\n\"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\");\n}\ntypeAdapter = typeAdapter.nullSafe();\nreturn typeAdapter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nFieldNamingStrategy fieldNamingPolicy, Excluder excluder) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "public JsonReader(Reader in) {\nif (in == null) {\nthrow new NullPointerException(\"in == null\");\n}\nthis.in = in;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<clinit>()V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;\n\nprivate static final int PEEKED_NONE = 0;\nprivate static final int PEEKED_BEGIN_OBJECT = 1;\nprivate static final int PEEKED_END_OBJECT = 2;\nprivate static final int PEEKED_BEGIN_ARRAY = 3;\nprivate static final int PEEKED_END_ARRAY = 4;\nprivate static final int PEEKED_TRUE = 5;\nprivate static final int PEEKED_FALSE = 6;\nprivate static final int PEEKED_NULL = 7;\nprivate static final int PEEKED_SINGLE_QUOTED = 8;\nprivate static final int PEEKED_DOUBLE_QUOTED = 9;\nprivate static final int PEEKED_UNQUOTED = 10;\n/** When this is returned, the string value is stored in peekedString. */\nprivate static final int PEEKED_BUFFERED = 11;\nprivate static final int PEEKED_SINGLE_QUOTED_NAME = 12;\nprivate static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\nprivate static final int PEEKED_UNQUOTED_NAME = 14;\n/** When this is returned, the integer value is stored in peekedLong. */\nprivate static final int PEEKED_LONG = 15;\nprivate static final int PEEKED_NUMBER = 16;\nprivate static final int PEEKED_EOF = 17;\n\n/* State machine when parsing numbers */\nprivate static final int NUMBER_CHAR_NONE = 0;\nprivate static final int NUMBER_CHAR_SIGN = 1;\nprivate static final int NUMBER_CHAR_DIGIT = 2;\nprivate static final int NUMBER_CHAR_DECIMAL = 3;\nprivate static final int NUMBER_CHAR_FRACTION_DIGIT = 4;\nprivate static final int NUMBER_CHAR_EXP_E = 5;\nprivate static final int NUMBER_CHAR_EXP_SIGN = 6;\nprivate static final int NUMBER_CHAR_EXP_DIGIT = 7;\n\n/** The input JSON. */\nprivate final Reader in;\n\n/** True to accept non-spec compliant JSON */\nprivate boolean lenient = false;\n\n/**\n* Use a manual buffer to easily read and unread upcoming characters, and\n* also so we can create strings without an intermediate StringBuilder.\n* We decode literals directly out of this buffer, so it must be at least as\n* long as the longest token that can be reported as a number.\n*/\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\n\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\n\nint peeked = PEEKED_NONE;\n\n/**\n* A peeked value that was composed entirely of digits with an optional\n* leading dash. Positive values may not have a leading 0.\n*/\nprivate long peekedLong;\n\n/**\n* The number of characters in a peeked number literal. Increment 'pos' by\n* this after reading a number.\n*/\nprivate int peekedNumberLength;\n\n/**\n* A peeked string that should be parsed on the next double, long or string.\n* This is populated before a numeric value is parsed and used if that parsing\n* fails.\n*/\nprivate String peekedString;\n\n/*\n* The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n*/\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\n{\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:setLenient(Z)V",
                                    "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:isLenient()Z",
                                    "method_body": "public final boolean isLenient() {\nreturn lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\n\nswitch (p) {\ncase PEEKED_BEGIN_OBJECT:\nreturn JsonToken.BEGIN_OBJECT;\ncase PEEKED_END_OBJECT:\nreturn JsonToken.END_OBJECT;\ncase PEEKED_BEGIN_ARRAY:\nreturn JsonToken.BEGIN_ARRAY;\ncase PEEKED_END_ARRAY:\nreturn JsonToken.END_ARRAY;\ncase PEEKED_SINGLE_QUOTED_NAME:\ncase PEEKED_DOUBLE_QUOTED_NAME:\ncase PEEKED_UNQUOTED_NAME:\nreturn JsonToken.NAME;\ncase PEEKED_TRUE:\ncase PEEKED_FALSE:\nreturn JsonToken.BOOLEAN;\ncase PEEKED_NULL:\nreturn JsonToken.NULL;\ncase PEEKED_SINGLE_QUOTED:\ncase PEEKED_DOUBLE_QUOTED:\ncase PEEKED_UNQUOTED:\ncase PEEKED_BUFFERED:\nreturn JsonToken.STRING;\ncase PEEKED_LONG:\ncase PEEKED_NUMBER:\nreturn JsonToken.NUMBER;\ncase PEEKED_EOF:\nreturn JsonToken.END_DOCUMENT;\ndefault:\nthrow new AssertionError();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:doPeek()I",
                                    "method_body": "int doPeek() throws IOException {\nint peekStack = stack[stackSize - 1];\nif (peekStack == JsonScope.EMPTY_ARRAY) {\nstack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n} else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n// Look for a comma before the next element.\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase ']':\nreturn peeked = PEEKED_END_ARRAY;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated array\");\n}\n} else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\nstack[stackSize - 1] = JsonScope.DANGLING_NAME;\n// Look for a comma before the next element.\nif (peekStack == JsonScope.NONEMPTY_OBJECT) {\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '}':\nreturn peeked = PEEKED_END_OBJECT;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated object\");\n}\n}\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '\"':\nreturn peeked = PEEKED_DOUBLE_QUOTED_NAME;\ncase '\\'':\ncheckLenient();\nreturn peeked = PEEKED_SINGLE_QUOTED_NAME;\ncase '}':\nif (peekStack != JsonScope.NONEMPTY_OBJECT) {\nreturn peeked = PEEKED_END_OBJECT;\n} else {\nthrow syntaxError(\"Expected name\");\n}\ndefault:\ncheckLenient();\npos--; // Don't consume the first character in an unquoted string.\nif (isLiteral((char) c)) {\nreturn peeked = PEEKED_UNQUOTED_NAME;\n} else {\nthrow syntaxError(\"Expected name\");\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit -= pos;\nSystem.arraycopy(buffer, pos, buffer, 0, limit);\n} else {\nlimit = 0;\n}\n\npos = 0;\nint total;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\n\n// if this is the first read, consume an optional byte order mark (BOM) if it exists\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\npos++;\nlineStart++;\nminimum++;\n}\n\nif (limit >= minimum) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n/*\n* This code uses ugly local variables 'p' and 'l' representing the 'pos'\n* and 'limit' fields respectively. Using locals rather than fields saves\n* a few field reads for each whitespace character in a pretty-printed\n* document, resulting in a 5% speedup. We need to flush 'p' to its field\n* before any (potentially indirect) call to fillBuffer() and reread both\n* 'p' and 'l' after any (potentially indirect) call to the same method.\n*/\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nwhile (true) {\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\nbreak;\n}\np = pos;\nl = limit;\n}\n\nint c = buffer[p++];\nif (c == '\\n') {\nlineNumber++;\nlineStart = p;\ncontinue;\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\ncontinue;\n}\n\nif (c == '/') {\npos = p;\nif (p == l) {\npos--; // push back '/' so it's still in the buffer when this method returns\nboolean charsLoaded = fillBuffer(2);\npos++; // consume the '/' again\nif (!charsLoaded) {\nreturn c;\n}\n}\n\ncheckLenient();\nchar peek = buffer[pos];\nswitch (peek) {\ncase '*':\n// skip a /* c-style comment */\npos++;\nif (!skipTo(\"*/\")) {\nthrow syntaxError(\"Unterminated comment\");\n}\np = pos + 2;\nl = limit;\ncontinue;\n\ncase '/':\n// skip a // end-of-line comment\npos++;\nskipToEndOfLine();\np = pos;\nl = limit;\ncontinue;\n\ndefault:\nreturn c;\n}\n} else if (c == '#') {\npos = p;\n/*\n* Skip a # hash end-of-line comment. The JSON RFC doesn't\n* specify this behaviour, but it's required to parse\n* existing documents. See http://b/2571423.\n*/\ncheckLenient();\nskipToEndOfLine();\np = pos;\nl = limit;\n} else {\npos = p;\nreturn c;\n}\n}\nif (throwOnEof) {\nthrow new EOFException(\"End of input\"\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n} else {\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:consumeNonExecutePrefix()V",
                                    "method_body": "private void consumeNonExecutePrefix() throws IOException {\n// fast forward through the leading whitespace\nnextNonWhitespace(true);\npos--;\n\nif (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\nreturn;\n}\n\nfor (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\nif (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\nreturn; // not a security token!\n}\n}\n\n// we consumed a security token!\npos += NON_EXECUTE_PREFIX.length;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nthrow new NullPointerException();\n}\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/Class;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static <T> TypeToken<T> get(Class<T> type) {\nreturn new TypeToken<T>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\np.getRawType(), p.getActualTypeArguments());\n\n} else if (type instanceof GenericArrayType) {\nGenericArrayType g = (GenericArrayType) type;\nreturn new GenericArrayTypeImpl(g.getGenericComponentType());\n\n} else if (type instanceof WildcardType) {\nWildcardType w = (WildcardType) type;\nreturn new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n} else {\n// type is either serializable as-is or unsupported\nreturn type;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\n// type is a normal class.\nreturn (Class<?>) type;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType parameterizedType = (ParameterizedType) type;\n\n// I'm not exactly sure why getRawType() returns Type instead of Class.\n// Neal isn't either but suspects some pathological case related\n// to nested classes exists.\nType rawType = parameterizedType.getRawType();\ncheckArgument(rawType instanceof Class);\nreturn (Class<?>) rawType;\n\n} else if (type instanceof GenericArrayType) {\nType componentType = ((GenericArrayType)type).getGenericComponentType();\nreturn Array.newInstance(getRawType(componentType), 0).getClass();\n\n} else if (type instanceof TypeVariable) {\n// we could use the variable's bounds, but that won't work if there are multiple.\n// having a raw type that's more general than necessary is okay\nreturn Object.class;\n\n} else if (type instanceof WildcardType) {\nreturn getRawType(((WildcardType) type).getUpperBounds()[0]);\n\n} else {\nString className = type == null ? \"null\" : type.getClass().getName();\nthrow new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n+ \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor$3:construct()Ljava/lang/Object;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\ntry {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\n}\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"unchecked\") // T is the same raw type as is requested\n@Override public T construct() {\ntry {\nObject[] args = null;\nreturn (T) constructor.newInstance(args);\n} catch (InstantiationException e) {\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\", e);\n} catch (InvocationTargetException e) {\n// TODO: don't wrap if cause is unchecked!\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",\ne.getTargetException());\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\n}\n};\n} catch (NoSuchMethodException e) {\nreturn null;\n}\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.regression.JsonAdapterNullSafeTest.testNullSafeBugSerialize",
                            "test_body": "29: public void testNullSafeBugSerialize() throws Exception {\n30: Device device = new Device(\"ec57803e\");\n31: gson.toJson(device);\n32: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\nCollections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\nDEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\nDEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\nLongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingPolicy,\nfinal Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,\nboolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\nboolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,\nLongSerializationPolicy longSerializationPolicy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nthis.lenient = lenient;\n\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n\n// built-in type adapters that cannot be overridden\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\n\n// the excluder must precede all adapters that handle user-defined types\nfactories.add(excluder);\n\n// user's type adapters\nfactories.addAll(typeAdapterFactories);\n\n// type adapters for basic platform types\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nTypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\ndoubleAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfloatAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\nfactories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\nfactories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.CURRENCY_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\n\n// type adapters for composite and user-defined types\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nfactories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nconstructorConstructor, fieldNamingPolicy, excluder));\n\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.DOUBLE;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Double read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\ndouble doubleValue = value.doubleValue();\ncheckValidFloatingPoint(doubleValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.FLOAT;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Float read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn (float) in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nfloat floatValue = value.floatValue();\ncheckValidFloatingPoint(floatValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Number read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextLong();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nout.value(value.toString());\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLong>() {\n@Override public void write(JsonWriter out, AtomicLong value) throws IOException {\nlongAdapter.write(out, value.get());\n}\n@Override public AtomicLong read(JsonReader in) throws IOException {\nNumber value = longAdapter.read(in);\nreturn new AtomicLong(value.longValue());\n}\n}.nullSafe();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongArrayAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLongArray>() {\n@Override public void write(JsonWriter out, AtomicLongArray value) throws IOException {\nout.beginArray();\nfor (int i = 0, length = value.length(); i < length; i++) {\nlongAdapter.write(out, value.get(i));\n}\nout.endArray();\n}\n@Override public AtomicLongArray read(JsonReader in) throws IOException {\nList<Long> list = new ArrayList<Long>();\nin.beginArray();\nwhile (in.hasNext()) {\nlong value = longAdapter.read(in).longValue();\nlist.add(value);\n}\nin.endArray();\nint length = list.size();\nAtomicLongArray array = new AtomicLongArray(length);\nfor (int i = 0; i < length; ++i) {\narray.set(i, list.get(i));\n}\nreturn array;\n}\n}.nullSafe();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type);\nif (cached != null) {\nreturn (TypeAdapter<T>) cached;\n}\n\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\n}\n\n// the key and value type parameters always agree\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nreturn ongoingCall;\n}\n\ntry {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\n\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\n}\n}\nthrow new IllegalArgumentException(\"GSON cannot handle \" + type);\n} finally {\nthreadCalls.remove(type);\n\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getDelegateAdapter(Lcom/google/gson/TypeAdapterFactory;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getDelegateAdapter(TypeAdapterFactory skipPast, TypeToken<T> type) {\nboolean skipPastFound = false;\n// Skip past if and only if the specified factory is present in the factories.\n// This is useful because the factories created through JsonAdapter annotations are not\n// registered in this list.\nif (!factories.contains(skipPast)) skipPastFound = true;\n\nfor (TypeAdapterFactory factory : factories) {\nif (!skipPastFound) {\nif (factory == skipPast) {\nskipPastFound = true;\n}\ncontinue;\n}\n\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\nreturn candidate;\n}\n}\nthrow new IllegalArgumentException(\"GSON cannot serialize \" + type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\n\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate boolean requireExpose;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n\n@Override protected Excluder clone() {\ntry {\nreturn (Excluder) super.clone();\n} catch (CloneNotSupportedException e) {\nthrow new AssertionError(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\n\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}\n\nreturn new TypeAdapter<T>() {\n/** The delegate is lazily created because it may not be needed, and creating it may fail. */\nprivate TypeAdapter<T> delegate;\n\n@Override public T read(JsonReader in) throws IOException {\nif (skipDeserialize) {\nin.skipValue();\nreturn null;\n}\nreturn delegate().read(in);\n}\n\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (skipSerialize) {\nout.nullValue();\nreturn;\n}\ndelegate().write(out, value);\n}\n\nprivate TypeAdapter<T> delegate() {\nTypeAdapter<T> d = delegate;\nreturn d != null\n? d\n: (delegate = gson.getDelegateAdapter(Excluder.this, type));\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\n&& !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\nreturn true;\n}\n\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nreturn true;\n}\n\nif (isAnonymousOrLocal(clazz)) {\nreturn true;\n}\n\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nif (exclusionStrategy.shouldSkipClass(clazz)) {\nreturn true;\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n&& (clazz.isAnonymousClass() || clazz.isLocalClass());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\n\n// first try an instance creator\n\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn typeCreator.createInstance(type);\n}\n};\n}\n\n// Next try raw type match for instance creators\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> rawTypeCreator =\n(InstanceCreator<T>) instanceCreators.get(rawType);\nif (rawTypeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn rawTypeCreator.createInstance(type);\n}\n};\n}\n\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nreturn defaultConstructor;\n}\n\nObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\nif (defaultImplementation != null) {\nreturn defaultImplementation;\n}\n\n// finally try unsafe\nreturn newUnsafeAllocator(type, rawType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultConstructor(Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\ntry {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\n}\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"unchecked\") // T is the same raw type as is requested\n@Override public T construct() {\ntry {\nObject[] args = null;\nreturn (T) constructor.newInstance(args);\n} catch (InstantiationException e) {\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\", e);\n} catch (InvocationTargetException e) {\n// TODO: don't wrap if cause is unchecked!\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",\ne.getTargetException());\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\n}\n};\n} catch (NoSuchMethodException e) {\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n@Override\npublic void write(JsonWriter out, Class value) throws IOException {\nif (value == null) {\nout.nullValue();\n} else {\nthrow new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n+ value.getName() + \". Forgot to register a type adapter?\");\n}\n}\n@Override\npublic Class read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n} else {\nthrow new UnsupportedOperationException(\n\"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n}\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:nullSafe()Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public final TypeAdapter<T> nullSafe() {\nreturn new TypeAdapter<T>() {\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (value == null) {\nout.nullValue();\n} else {\nTypeAdapter.this.write(out, value);\n}\n}\n@Override public T read(JsonReader reader) throws IOException {\nif (reader.peek() == JsonToken.NULL) {\nreader.nextNull();\nreturn null;\n}\nreturn TypeAdapter.this.read(reader);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$35:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$26:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}\n\nfinal TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\nreturn (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n@Override public Timestamp read(JsonReader in) throws IOException {\nDate date = dateTypeAdapter.read(in);\nreturn date != null ? new Timestamp(date.getTime()) : null;\n}\n\n@Override public void write(JsonWriter out, Timestamp value) throws IOException {\ndateTypeAdapter.write(out, value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$34:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nType elementType = $Gson$Types.getCollectionElementType(type, rawType);\nTypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // create() doesn't define a type parameter\nTypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nClass<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\nType[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\nTypeAdapter<?> keyAdapter = getKeyAdapter(gson, keyAndValueTypes[0]);\nTypeAdapter<?> valueAdapter = gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n// we don't define a type parameter for the key or value types\nTypeAdapter<T> result = new Adapter(gson, keyAndValueTypes[0], keyAdapter,\nkeyAndValueTypes[1], valueAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\nJsonAdapter annotation = targetType.getRawType().getAnnotation(JsonAdapter.class);\nif (annotation == null) {\nreturn null;\n}\nreturn (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:getTypeAdapter(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;Lcom/google/gson/annotations/JsonAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\nTypeToken<?> fieldType, JsonAdapter annotation) {\nClass<?> value = annotation.value();\nTypeAdapter<?> typeAdapter;\nif (TypeAdapter.class.isAssignableFrom(value)) {\nClass<TypeAdapter<?>> typeAdapterClass = (Class<TypeAdapter<?>>) value;\ntypeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();\n} else if (TypeAdapterFactory.class.isAssignableFrom(value)) {\nClass<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;\ntypeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterFactory))\n.construct()\n.create(gson, fieldType);\n} else {\nthrow new IllegalArgumentException(\n\"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\");\n}\ntypeAdapter = typeAdapter.nullSafe();\nreturn typeAdapter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nFieldNamingStrategy fieldNamingPolicy, Excluder excluder) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nthrow new NullPointerException();\n}\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/Class;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static <T> TypeToken<T> get(Class<T> type) {\nreturn new TypeToken<T>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\np.getRawType(), p.getActualTypeArguments());\n\n} else if (type instanceof GenericArrayType) {\nGenericArrayType g = (GenericArrayType) type;\nreturn new GenericArrayTypeImpl(g.getGenericComponentType());\n\n} else if (type instanceof WildcardType) {\nWildcardType w = (WildcardType) type;\nreturn new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n} else {\n// type is either serializable as-is or unsupported\nreturn type;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\n// type is a normal class.\nreturn (Class<?>) type;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType parameterizedType = (ParameterizedType) type;\n\n// I'm not exactly sure why getRawType() returns Type instead of Class.\n// Neal isn't either but suspects some pathological case related\n// to nested classes exists.\nType rawType = parameterizedType.getRawType();\ncheckArgument(rawType instanceof Class);\nreturn (Class<?>) rawType;\n\n} else if (type instanceof GenericArrayType) {\nType componentType = ((GenericArrayType)type).getGenericComponentType();\nreturn Array.newInstance(getRawType(componentType), 0).getClass();\n\n} else if (type instanceof TypeVariable) {\n// we could use the variable's bounds, but that won't work if there are multiple.\n// having a raw type that's more general than necessary is okay\nreturn Object.class;\n\n} else if (type instanceof WildcardType) {\nreturn getRawType(((WildcardType) type).getUpperBounds()[0]);\n\n} else {\nString className = type == null ? \"null\" : type.getClass().getName();\nthrow new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n+ \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor$3:construct()Ljava/lang/Object;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\ntry {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\n}\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"unchecked\") // T is the same raw type as is requested\n@Override public T construct() {\ntry {\nObject[] args = null;\nreturn (T) constructor.newInstance(args);\n} catch (InstantiationException e) {\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\", e);\n} catch (InvocationTargetException e) {\n// TODO: don't wrap if cause is unchecked!\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",\ne.getTargetException());\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\n}\n};\n} catch (NoSuchMethodException e) {\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:toJson(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public String toJson(Object src) {\nif (src == null) {\nreturn toJson(JsonNull.INSTANCE);\n}\nreturn toJson(src, src.getClass());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:toJson(Ljava/lang/Object;Ljava/lang/reflect/Type;)Ljava/lang/String;",
                                    "method_body": "public String toJson(Object src, Type typeOfSrc) {\nStringWriter writer = new StringWriter();\ntoJson(src, typeOfSrc, writer);\nreturn writer.toString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:toJson(Ljava/lang/Object;Ljava/lang/reflect/Type;Ljava/lang/Appendable;)V",
                                    "method_body": "public void toJson(Object src, Type typeOfSrc, Appendable writer) throws JsonIOException {\ntry {\nJsonWriter jsonWriter = newJsonWriter(Streams.writerForAppendable(writer));\ntoJson(src, typeOfSrc, jsonWriter);\n} catch (IOException e) {\nthrow new JsonIOException(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:toJson(Ljava/lang/Object;Ljava/lang/reflect/Type;Lcom/google/gson/stream/JsonWriter;)V",
                                    "method_body": "public void toJson(Object src, Type typeOfSrc, JsonWriter writer) throws JsonIOException {\nTypeAdapter<?> adapter = getAdapter(TypeToken.get(typeOfSrc));\nboolean oldLenient = writer.isLenient();\nwriter.setLenient(true);\nboolean oldHtmlSafe = writer.isHtmlSafe();\nwriter.setHtmlSafe(htmlSafe);\nboolean oldSerializeNulls = writer.getSerializeNulls();\nwriter.setSerializeNulls(serializeNulls);\ntry {\n((TypeAdapter<Object>) adapter).write(writer, src);\n} catch (IOException e) {\nthrow new JsonIOException(e);\n} finally {\nwriter.setLenient(oldLenient);\nwriter.setHtmlSafe(oldHtmlSafe);\nwriter.setSerializeNulls(oldSerializeNulls);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:newJsonWriter(Ljava/io/Writer;)Lcom/google/gson/stream/JsonWriter;",
                                    "method_body": "public JsonWriter newJsonWriter(Writer writer) throws IOException {\nif (generateNonExecutableJson) {\nwriter.write(JSON_NON_EXECUTABLE_PREFIX);\n}\nJsonWriter jsonWriter = new JsonWriter(writer);\nif (prettyPrinting) {\njsonWriter.setIndent(\"  \");\n}\njsonWriter.setSerializeNulls(serializeNulls);\nreturn jsonWriter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Streams:writerForAppendable(Ljava/lang/Appendable;)Ljava/io/Writer;",
                                    "method_body": "public static Writer writerForAppendable(Appendable appendable) {\nreturn appendable instanceof Writer ? (Writer) appendable : new AppendableWriter(appendable);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:<init>(Ljava/io/Writer;)V",
                                    "method_body": "public JsonWriter(Writer out) {\nif (out == null) {\nthrow new NullPointerException(\"out == null\");\n}\nthis.out = out;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:<clinit>()V",
                                    "method_body": "private static final String[] REPLACEMENT_CHARS;\nprivate static final String[] HTML_SAFE_REPLACEMENT_CHARS;\nstatic {\nREPLACEMENT_CHARS = new String[128];\nfor (int i = 0; i <= 0x1f; i++) {\nREPLACEMENT_CHARS[i] = String.format(\"\\\\u%04x\", (int) i);\n}\nREPLACEMENT_CHARS['\"'] = \"\\\\\\\"\";\nREPLACEMENT_CHARS['\\\\'] = \"\\\\\\\\\";\nREPLACEMENT_CHARS['\\t'] = \"\\\\t\";\nREPLACEMENT_CHARS['\\b'] = \"\\\\b\";\nREPLACEMENT_CHARS['\\n'] = \"\\\\n\";\nREPLACEMENT_CHARS['\\r'] = \"\\\\r\";\nREPLACEMENT_CHARS['\\f'] = \"\\\\f\";\nHTML_SAFE_REPLACEMENT_CHARS = REPLACEMENT_CHARS.clone();\nHTML_SAFE_REPLACEMENT_CHARS['<'] = \"\\\\u003c\";\nHTML_SAFE_REPLACEMENT_CHARS['>'] = \"\\\\u003e\";\nHTML_SAFE_REPLACEMENT_CHARS['&'] = \"\\\\u0026\";\nHTML_SAFE_REPLACEMENT_CHARS['='] = \"\\\\u003d\";\nHTML_SAFE_REPLACEMENT_CHARS['\\''] = \"\\\\u0027\";\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:setSerializeNulls(Z)V",
                                    "method_body": "public final void setSerializeNulls(boolean serializeNulls) {\nthis.serializeNulls = serializeNulls;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:push(I)V",
                                    "method_body": "private void push(int newTop) {\nif (stackSize == stack.length) {\nint[] newStack = new int[stackSize * 2];\nSystem.arraycopy(stack, 0, newStack, 0, stackSize);\nstack = newStack;\n}\nstack[stackSize++] = newTop;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 7,
                    "tests": [
                        {
                            "test_name": "com.google.gson.functional.MapTest.testMapDeserializationWithUnquotedLongKeys",
                            "test_body": "188: public void testMapDeserializationWithUnquotedLongKeys() {\n189: long longKey = 9876543210L;\n190: String json = String.format(\"{%d:\\\"456\\\"}\", longKey);\n191: Type typeOfMap = new TypeToken<Map<Long, String>>() {}.getType();\n192: Map<Long, String> map = gson.fromJson(json, typeOfMap);\n193: assertEquals(1, map.size());\n194: assertTrue(map.containsKey(longKey));\n195: assertEquals(\"456\", map.get(longKey));\n196: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "public JsonReader(Reader in) {\nif (in == null) {\nthrow new NullPointerException(\"in == null\");\n}\nthis.in = in;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<clinit>()V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;\n\nprivate static final int PEEKED_NONE = 0;\nprivate static final int PEEKED_BEGIN_OBJECT = 1;\nprivate static final int PEEKED_END_OBJECT = 2;\nprivate static final int PEEKED_BEGIN_ARRAY = 3;\nprivate static final int PEEKED_END_ARRAY = 4;\nprivate static final int PEEKED_TRUE = 5;\nprivate static final int PEEKED_FALSE = 6;\nprivate static final int PEEKED_NULL = 7;\nprivate static final int PEEKED_SINGLE_QUOTED = 8;\nprivate static final int PEEKED_DOUBLE_QUOTED = 9;\nprivate static final int PEEKED_UNQUOTED = 10;\n/** When this is returned, the string value is stored in peekedString. */\nprivate static final int PEEKED_BUFFERED = 11;\nprivate static final int PEEKED_SINGLE_QUOTED_NAME = 12;\nprivate static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\nprivate static final int PEEKED_UNQUOTED_NAME = 14;\n/** When this is returned, the integer value is stored in peekedLong. */\nprivate static final int PEEKED_LONG = 15;\nprivate static final int PEEKED_NUMBER = 16;\nprivate static final int PEEKED_EOF = 17;\n\n/* State machine when parsing numbers */\nprivate static final int NUMBER_CHAR_NONE = 0;\nprivate static final int NUMBER_CHAR_SIGN = 1;\nprivate static final int NUMBER_CHAR_DIGIT = 2;\nprivate static final int NUMBER_CHAR_DECIMAL = 3;\nprivate static final int NUMBER_CHAR_FRACTION_DIGIT = 4;\nprivate static final int NUMBER_CHAR_EXP_E = 5;\nprivate static final int NUMBER_CHAR_EXP_SIGN = 6;\nprivate static final int NUMBER_CHAR_EXP_DIGIT = 7;\n\n/** The input JSON. */\nprivate final Reader in;\n\n/** True to accept non-spec compliant JSON */\nprivate boolean lenient = false;\n\n/**\n* Use a manual buffer to easily read and unread upcoming characters, and\n* also so we can create strings without an intermediate StringBuilder.\n* We decode literals directly out of this buffer, so it must be at least as\n* long as the longest token that can be reported as a number.\n*/\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\n\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\n\nint peeked = PEEKED_NONE;\n\n/**\n* A peeked value that was composed entirely of digits with an optional\n* leading dash. Positive values may not have a leading 0.\n*/\nprivate long peekedLong;\n\n/**\n* The number of characters in a peeked number literal. Increment 'pos' by\n* this after reading a number.\n*/\nprivate int peekedNumberLength;\n\n/**\n* A peeked string that should be parsed on the next double, long or string.\n* This is populated before a numeric value is parsed and used if that parsing\n* fails.\n*/\nprivate String peekedString;\n\n/*\n* The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n*/\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\n{\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:setLenient(Z)V",
                                    "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\n\nswitch (p) {\ncase PEEKED_BEGIN_OBJECT:\nreturn JsonToken.BEGIN_OBJECT;\ncase PEEKED_END_OBJECT:\nreturn JsonToken.END_OBJECT;\ncase PEEKED_BEGIN_ARRAY:\nreturn JsonToken.BEGIN_ARRAY;\ncase PEEKED_END_ARRAY:\nreturn JsonToken.END_ARRAY;\ncase PEEKED_SINGLE_QUOTED_NAME:\ncase PEEKED_DOUBLE_QUOTED_NAME:\ncase PEEKED_UNQUOTED_NAME:\nreturn JsonToken.NAME;\ncase PEEKED_TRUE:\ncase PEEKED_FALSE:\nreturn JsonToken.BOOLEAN;\ncase PEEKED_NULL:\nreturn JsonToken.NULL;\ncase PEEKED_SINGLE_QUOTED:\ncase PEEKED_DOUBLE_QUOTED:\ncase PEEKED_UNQUOTED:\ncase PEEKED_BUFFERED:\nreturn JsonToken.STRING;\ncase PEEKED_LONG:\ncase PEEKED_NUMBER:\nreturn JsonToken.NUMBER;\ncase PEEKED_EOF:\nreturn JsonToken.END_DOCUMENT;\ndefault:\nthrow new AssertionError();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:doPeek()I",
                                    "method_body": "int doPeek() throws IOException {\nint peekStack = stack[stackSize - 1];\nif (peekStack == JsonScope.EMPTY_ARRAY) {\nstack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n} else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n// Look for a comma before the next element.\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase ']':\nreturn peeked = PEEKED_END_ARRAY;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated array\");\n}\n} else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\nstack[stackSize - 1] = JsonScope.DANGLING_NAME;\n// Look for a comma before the next element.\nif (peekStack == JsonScope.NONEMPTY_OBJECT) {\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '}':\nreturn peeked = PEEKED_END_OBJECT;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated object\");\n}\n}\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '\"':\nreturn peeked = PEEKED_DOUBLE_QUOTED_NAME;\ncase '\\'':\ncheckLenient();\nreturn peeked = PEEKED_SINGLE_QUOTED_NAME;\ncase '}':\nif (peekStack != JsonScope.NONEMPTY_OBJECT) {\nreturn peeked = PEEKED_END_OBJECT;\n} else {\nthrow syntaxError(\"Expected name\");\n}\ndefault:\ncheckLenient();\npos--; // Don't consume the first character in an unquoted string.\nif (isLiteral((char) c)) {\nreturn peeked = PEEKED_UNQUOTED_NAME;\n} else {\nthrow syntaxError(\"Expected name\");\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:isLiteral(C)Z",
                                    "method_body": "private boolean isLiteral(char c) throws IOException {\nswitch (c) {\ncase '/':\ncase '\\\\':\ncase ';':\ncase '#':\ncase '=':\ncheckLenient(); // fall-through\ncase '{':\ncase '}':\ncase '[':\ncase ']':\ncase ':':\ncase ',':\ncase ' ':\ncase '\\t':\ncase '\\f':\ncase '\\r':\ncase '\\n':\nreturn false;\ndefault:\nreturn true;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:push(I)V",
                                    "method_body": "private void push(int newTop) {\nif (stackSize == stack.length) {\nint[] newStack = new int[stackSize * 2];\nint[] newPathIndices = new int[stackSize * 2];\nString[] newPathNames = new String[stackSize * 2];\nSystem.arraycopy(stack, 0, newStack, 0, stackSize);\nSystem.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\nSystem.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\nstack = newStack;\npathIndices = newPathIndices;\npathNames = newPathNames;\n}\nstack[stackSize++] = newTop;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit -= pos;\nSystem.arraycopy(buffer, pos, buffer, 0, limit);\n} else {\nlimit = 0;\n}\n\npos = 0;\nint total;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\n\n// if this is the first read, consume an optional byte order mark (BOM) if it exists\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\npos++;\nlineStart++;\nminimum++;\n}\n\nif (limit >= minimum) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getLineNumber()I",
                                    "method_body": "int getLineNumber() {\nreturn lineNumber + 1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getColumnNumber()I",
                                    "method_body": "int getColumnNumber() {\nreturn pos - lineStart + 1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n/*\n* This code uses ugly local variables 'p' and 'l' representing the 'pos'\n* and 'limit' fields respectively. Using locals rather than fields saves\n* a few field reads for each whitespace character in a pretty-printed\n* document, resulting in a 5% speedup. We need to flush 'p' to its field\n* before any (potentially indirect) call to fillBuffer() and reread both\n* 'p' and 'l' after any (potentially indirect) call to the same method.\n*/\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nwhile (true) {\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\nbreak;\n}\np = pos;\nl = limit;\n}\n\nint c = buffer[p++];\nif (c == '\\n') {\nlineNumber++;\nlineStart = p;\ncontinue;\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\ncontinue;\n}\n\nif (c == '/') {\npos = p;\nif (p == l) {\npos--; // push back '/' so it's still in the buffer when this method returns\nboolean charsLoaded = fillBuffer(2);\npos++; // consume the '/' again\nif (!charsLoaded) {\nreturn c;\n}\n}\n\ncheckLenient();\nchar peek = buffer[pos];\nswitch (peek) {\ncase '*':\n// skip a /* c-style comment */\npos++;\nif (!skipTo(\"*/\")) {\nthrow syntaxError(\"Unterminated comment\");\n}\np = pos + 2;\nl = limit;\ncontinue;\n\ncase '/':\n// skip a // end-of-line comment\npos++;\nskipToEndOfLine();\np = pos;\nl = limit;\ncontinue;\n\ndefault:\nreturn c;\n}\n} else if (c == '#') {\npos = p;\n/*\n* Skip a # hash end-of-line comment. The JSON RFC doesn't\n* specify this behaviour, but it's required to parse\n* existing documents. See http://b/2571423.\n*/\ncheckLenient();\nskipToEndOfLine();\np = pos;\nl = limit;\n} else {\npos = p;\nreturn c;\n}\n}\nif (throwOnEof) {\nthrow new EOFException(\"End of input\"\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n} else {\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:checkLenient()V",
                                    "method_body": "private void checkLenient() throws IOException {\nif (!lenient) {\nthrow syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\");\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getPath()Ljava/lang/String;",
                                    "method_body": "public String getPath() {\nStringBuilder result = new StringBuilder().append('$');\nfor (int i = 0, size = stackSize; i < size; i++) {\nswitch (stack[i]) {\ncase JsonScope.EMPTY_ARRAY:\ncase JsonScope.NONEMPTY_ARRAY:\nresult.append('[').append(pathIndices[i]).append(']');\nbreak;\n\ncase JsonScope.EMPTY_OBJECT:\ncase JsonScope.DANGLING_NAME:\ncase JsonScope.NONEMPTY_OBJECT:\nresult.append('.');\nif (pathNames[i] != null) {\nresult.append(pathNames[i]);\n}\nbreak;\n\ncase JsonScope.NONEMPTY_DOCUMENT:\ncase JsonScope.EMPTY_DOCUMENT:\ncase JsonScope.CLOSED:\nbreak;\n}\n}\nreturn result.toString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:consumeNonExecutePrefix()V",
                                    "method_body": "private void consumeNonExecutePrefix() throws IOException {\n// fast forward through the leading whitespace\nnextNonWhitespace(true);\npos--;\n\nif (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\nreturn;\n}\n\nfor (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\nif (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\nreturn; // not a security token!\n}\n}\n\n// we consumed a security token!\npos += NON_EXECUTE_PREFIX.length;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\nCollections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\nDEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\nDEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\nLongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingPolicy,\nfinal Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,\nboolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\nboolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,\nLongSerializationPolicy longSerializationPolicy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nthis.lenient = lenient;\n\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n\n// built-in type adapters that cannot be overridden\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\n\n// the excluder must precede all adapters that handle user-defined types\nfactories.add(excluder);\n\n// user's type adapters\nfactories.addAll(typeAdapterFactories);\n\n// type adapters for basic platform types\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nTypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\ndoubleAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfloatAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\nfactories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\nfactories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.CURRENCY_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\n\n// type adapters for composite and user-defined types\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nfactories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nconstructorConstructor, fieldNamingPolicy, excluder));\n\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<clinit>()V",
                                    "method_body": "static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\nstatic final boolean DEFAULT_LENIENT = false;\nstatic final boolean DEFAULT_PRETTY_PRINT = false;\nstatic final boolean DEFAULT_ESCAPE_HTML = true;\nstatic final boolean DEFAULT_SERIALIZE_NULLS = false;\nstatic final boolean DEFAULT_COMPLEX_MAP_KEYS = false;\nstatic final boolean DEFAULT_SPECIALIZE_FLOAT_VALUES = false;\n\nprivate static final TypeToken<?> NULL_KEY_SURROGATE = new TypeToken<Object>() {};"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.DOUBLE;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Double read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\ndouble doubleValue = value.doubleValue();\ncheckValidFloatingPoint(doubleValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.FLOAT;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Float read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn (float) in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nfloat floatValue = value.floatValue();\ncheckValidFloatingPoint(floatValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Number read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextLong();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nout.value(value.toString());\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLong>() {\n@Override public void write(JsonWriter out, AtomicLong value) throws IOException {\nlongAdapter.write(out, value.get());\n}\n@Override public AtomicLong read(JsonReader in) throws IOException {\nNumber value = longAdapter.read(in);\nreturn new AtomicLong(value.longValue());\n}\n}.nullSafe();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongArrayAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLongArray>() {\n@Override public void write(JsonWriter out, AtomicLongArray value) throws IOException {\nout.beginArray();\nfor (int i = 0, length = value.length(); i < length; i++) {\nlongAdapter.write(out, value.get(i));\n}\nout.endArray();\n}\n@Override public AtomicLongArray read(JsonReader in) throws IOException {\nList<Long> list = new ArrayList<Long>();\nin.beginArray();\nwhile (in.hasNext()) {\nlong value = longAdapter.read(in).longValue();\nlist.add(value);\n}\nin.endArray();\nint length = list.size();\nAtomicLongArray array = new AtomicLongArray(length);\nfor (int i = 0; i < length; ++i) {\narray.set(i, list.get(i));\n}\nreturn array;\n}\n}.nullSafe();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);\nif (cached != null) {\nreturn (TypeAdapter<T>) cached;\n}\n\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\n}\n\n// the key and value type parameters always agree\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nreturn ongoingCall;\n}\n\ntry {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\n\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\n}\n}\nthrow new IllegalArgumentException(\"GSON cannot handle \" + type);\n} finally {\nthreadCalls.remove(type);\n\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:newJsonReader(Ljava/io/Reader;)Lcom/google/gson/stream/JsonReader;",
                                    "method_body": "public JsonReader newJsonReader(Reader reader) {\nJsonReader jsonReader = new JsonReader(reader);\njsonReader.setLenient(lenient);\nreturn jsonReader;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {\nif (json == null) {\nreturn null;\n}\nStringReader reader = new StringReader(json);\nT target = (T) fromJson(reader, typeOfT);\nreturn target;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/io/Reader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nJsonReader jsonReader = newJsonReader(json);\nT object = (T) fromJson(jsonReader, typeOfT);\nassertFullConsumption(object, jsonReader);\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Lcom/google/gson/stream/JsonReader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nboolean isEmpty = true;\nboolean oldLenient = reader.isLenient();\nreader.setLenient(true);\ntry {\nreader.peek();\nisEmpty = false;\nTypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\nTypeAdapter<T> typeAdapter = getAdapter(typeToken);\nT object = typeAdapter.read(reader);\nreturn object;\n} catch (EOFException e) {\n/*\n* For compatibility with JSON 1.5 and earlier, we return null for empty\n* documents instead of throwing.\n*/\nif (isEmpty) {\nreturn null;\n}\nthrow new JsonSyntaxException(e);\n} catch (IllegalStateException e) {\nthrow new JsonSyntaxException(e);\n} catch (IOException e) {\n// TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException\nthrow new JsonSyntaxException(e);\n} finally {\nreader.setLenient(oldLenient);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>()V",
                                    "method_body": "protected TypeToken() {\nthis.type = getSuperclassTypeParameter(getClass());\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(type);\nthis.hashCode = type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getSuperclassTypeParameter(Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getSuperclassTypeParameter(Class<?> subclass) {\nType superclass = subclass.getGenericSuperclass();\nif (superclass instanceof Class) {\nthrow new RuntimeException(\"Missing type parameter.\");\n}\nParameterizedType parameterized = (ParameterizedType) superclass;\nreturn $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\np.getRawType(), p.getActualTypeArguments());\n\n} else if (type instanceof GenericArrayType) {\nGenericArrayType g = (GenericArrayType) type;\nreturn new GenericArrayTypeImpl(g.getGenericComponentType());\n\n} else if (type instanceof WildcardType) {\nWildcardType w = (WildcardType) type;\nreturn new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n} else {\n// type is either serializable as-is or unsupported\nreturn type;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\n// type is a normal class.\nreturn (Class<?>) type;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType parameterizedType = (ParameterizedType) type;\n\n// I'm not exactly sure why getRawType() returns Type instead of Class.\n// Neal isn't either but suspects some pathological case related\n// to nested classes exists.\nType rawType = parameterizedType.getRawType();\ncheckArgument(rawType instanceof Class);\nreturn (Class<?>) rawType;\n\n} else if (type instanceof GenericArrayType) {\nType componentType = ((GenericArrayType)type).getGenericComponentType();\nreturn Array.newInstance(getRawType(componentType), 0).getClass();\n\n} else if (type instanceof TypeVariable) {\n// we could use the variable's bounds, but that won't work if there are multiple.\n// having a raw type that's more general than necessary is okay\nreturn Object.class;\n\n} else if (type instanceof WildcardType) {\nreturn getRawType(((WildcardType) type).getUpperBounds()[0]);\n\n} else {\nString className = type == null ? \"null\" : type.getClass().getName();\nthrow new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n+ \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:hashCodeOrZero(Ljava/lang/Object;)I",
                                    "method_body": "static int hashCodeOrZero(Object o) {\nreturn o != null ? o.hashCode() : 0;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getGenericSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\nif (toResolve == rawType) {\nreturn context;\n}\n\n// we skip searching through interfaces if unknown is an interface\nif (toResolve.isInterface()) {\nClass<?>[] interfaces = rawType.getInterfaces();\nfor (int i = 0, length = interfaces.length; i < length; i++) {\nif (interfaces[i] == toResolve) {\nreturn rawType.getGenericInterfaces()[i];\n} else if (toResolve.isAssignableFrom(interfaces[i])) {\nreturn getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n}\n}\n}\n\n// check our supertypes\nif (!rawType.isInterface()) {\nwhile (rawType != Object.class) {\nClass<?> rawSupertype = rawType.getSuperclass();\nif (rawSupertype == toResolve) {\nreturn rawType.getGenericSuperclass();\n} else if (toResolve.isAssignableFrom(rawSupertype)) {\nreturn getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);\n}\nrawType = rawSupertype;\n}\n}\n\n// we can't resolve this further\nreturn toResolve;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\ncheckArgument(supertype.isAssignableFrom(contextRawType));\nreturn resolve(context, contextRawType,\n$Gson$Types.getGenericSupertype(context, contextRawType, supertype));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getMapKeyAndValueTypes(Ljava/lang/reflect/Type;Ljava/lang/Class;)[Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {\n/*\n* Work around a problem with the declaration of java.util.Properties. That\n* class should extend Hashtable<String, String>, but it's declared to\n* extend Hashtable<Object, Object>.\n*/\nif (context == Properties.class) {\nreturn new Type[] { String.class, String.class }; // TODO: test subclasses of Properties!\n}\n\nType mapType = getSupertype(context, contextRawType, Map.class);\n// TODO: strip wildcards?\nif (mapType instanceof ParameterizedType) {\nParameterizedType mapParameterizedType = (ParameterizedType) mapType;\nreturn mapParameterizedType.getActualTypeArguments();\n}\nreturn new Type[] { Object.class, Object.class };\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\n// this implementation is made a little more complicated in an attempt to avoid object-creation\nwhile (true) {\nif (toResolve instanceof TypeVariable) {\nTypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\ntoResolve = resolveTypeVariable(context, contextRawType, typeVariable);\nif (toResolve == typeVariable) {\nreturn toResolve;\n}\n\n} else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\nClass<?> original = (Class<?>) toResolve;\nType componentType = original.getComponentType();\nType newComponentType = resolve(context, contextRawType, componentType);\nreturn componentType == newComponentType\n? original\n: arrayOf(newComponentType);\n\n} else if (toResolve instanceof GenericArrayType) {\nGenericArrayType original = (GenericArrayType) toResolve;\nType componentType = original.getGenericComponentType();\nType newComponentType = resolve(context, contextRawType, componentType);\nreturn componentType == newComponentType\n? original\n: arrayOf(newComponentType);\n\n} else if (toResolve instanceof ParameterizedType) {\nParameterizedType original = (ParameterizedType) toResolve;\nType ownerType = original.getOwnerType();\nType newOwnerType = resolve(context, contextRawType, ownerType);\nboolean changed = newOwnerType != ownerType;\n\nType[] args = original.getActualTypeArguments();\nfor (int t = 0, length = args.length; t < length; t++) {\nType resolvedTypeArgument = resolve(context, contextRawType, args[t]);\nif (resolvedTypeArgument != args[t]) {\nif (!changed) {\nargs = args.clone();\nchanged = true;\n}\nargs[t] = resolvedTypeArgument;\n}\n}\n\nreturn changed\n? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n: original;\n\n} else if (toResolve instanceof WildcardType) {\nWildcardType original = (WildcardType) toResolve;\nType[] originalLowerBound = original.getLowerBounds();\nType[] originalUpperBound = original.getUpperBounds();\n\nif (originalLowerBound.length == 1) {\nType lowerBound = resolve(context, contextRawType, originalLowerBound[0]);\nif (lowerBound != originalLowerBound[0]) {\nreturn supertypeOf(lowerBound);\n}\n} else if (originalUpperBound.length == 1) {\nType upperBound = resolve(context, contextRawType, originalUpperBound[0]);\nif (upperBound != originalUpperBound[0]) {\nreturn subtypeOf(upperBound);\n}\n}\nreturn original;\n\n} else {\nreturn toResolve;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\n\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate boolean requireExpose;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n\n@Override protected Excluder clone() {\ntry {\nreturn (Excluder) super.clone();\n} catch (CloneNotSupportedException e) {\nthrow new AssertionError(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\n\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}\n\nreturn new TypeAdapter<T>() {\n/** The delegate is lazily created because it may not be needed, and creating it may fail. */\nprivate TypeAdapter<T> delegate;\n\n@Override public T read(JsonReader in) throws IOException {\nif (skipDeserialize) {\nin.skipValue();\nreturn null;\n}\nreturn delegate().read(in);\n}\n\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (skipSerialize) {\nout.nullValue();\nreturn;\n}\ndelegate().write(out, value);\n}\n\nprivate TypeAdapter<T> delegate() {\nTypeAdapter<T> d = delegate;\nreturn d != null\n? d\n: (delegate = gson.getDelegateAdapter(Excluder.this, type));\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\n&& !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\nreturn true;\n}\n\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nreturn true;\n}\n\nif (isAnonymousOrLocal(clazz)) {\nreturn true;\n}\n\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nif (exclusionStrategy.shouldSkipClass(clazz)) {\nreturn true;\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n&& (clazz.isAnonymousClass() || clazz.isLocalClass());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\n\n// first try an instance creator\n\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn typeCreator.createInstance(type);\n}\n};\n}\n\n// Next try raw type match for instance creators\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> rawTypeCreator =\n(InstanceCreator<T>) instanceCreators.get(rawType);\nif (rawTypeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn rawTypeCreator.createInstance(type);\n}\n};\n}\n\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nreturn defaultConstructor;\n}\n\nObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\nif (defaultImplementation != null) {\nreturn defaultImplementation;\n}\n\n// finally try unsafe\nreturn newUnsafeAllocator(type, rawType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultConstructor(Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\ntry {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\n}\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"unchecked\") // T is the same raw type as is requested\n@Override public T construct() {\ntry {\nObject[] args = null;\nreturn (T) constructor.newInstance(args);\n} catch (InstantiationException e) {\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\", e);\n} catch (InvocationTargetException e) {\n// TODO: don't wrap if cause is unchecked!\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",\ne.getTargetException());\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\n}\n};\n} catch (NoSuchMethodException e) {\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultImplementationConstructor(Ljava/lang/reflect/Type;Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nfinal Type type, Class<? super T> rawType) {\nif (Collection.class.isAssignableFrom(rawType)) {\nif (SortedSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeSet<Object>();\n}\n};\n} else if (EnumSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"rawtypes\")\n@Override public T construct() {\nif (type instanceof ParameterizedType) {\nType elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\nif (elementType instanceof Class) {\nreturn (T) EnumSet.noneOf((Class)elementType);\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n}\n};\n} else if (Set.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashSet<Object>();\n}\n};\n} else if (Queue.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedList<Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ArrayList<Object>();\n}\n};\n}\n}\n\nif (Map.class.isAssignableFrom(rawType)) {\nif (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ConcurrentSkipListMap<Object, Object>();\n}\n};\n} else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ConcurrentHashMap<Object, Object>();\n}\n};\n} else if (SortedMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeMap<Object, Object>();\n}\n};\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nTypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashMap<Object, Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedTreeMap<String, Object>();\n}\n};\n}\n}\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n@Override\npublic void write(JsonWriter out, Class value) throws IOException {\nif (value == null) {\nout.nullValue();\n} else {\nthrow new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n+ value.getName() + \". Forgot to register a type adapter?\");\n}\n}\n@Override\npublic Class read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n} else {\nthrow new UnsupportedOperationException(\n\"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n}\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:nullSafe()Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public final TypeAdapter<T> nullSafe() {\nreturn new TypeAdapter<T>() {\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (value == null) {\nout.nullValue();\n} else {\nTypeAdapter.this.write(out, value);\n}\n}\n@Override public T read(JsonReader reader) throws IOException {\nif (reader.peek() == JsonToken.NULL) {\nreader.nextNull();\nreturn null;\n}\nreturn TypeAdapter.this.read(reader);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$35:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$26:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}\n\nfinal TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\nreturn (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n@Override public Timestamp read(JsonReader in) throws IOException {\nDate date = dateTypeAdapter.read(in);\nreturn date != null ? new Timestamp(date.getTime()) : null;\n}\n\n@Override public void write(JsonWriter out, Timestamp value) throws IOException {\ndateTypeAdapter.write(out, value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$34:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nType elementType = $Gson$Types.getCollectionElementType(type, rawType);\nTypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // create() doesn't define a type parameter\nTypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nClass<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\nType[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\nTypeAdapter<?> keyAdapter = getKeyAdapter(gson, keyAndValueTypes[0]);\nTypeAdapter<?> valueAdapter = gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n// we don't define a type parameter for the key or value types\nTypeAdapter<T> result = new Adapter(gson, keyAndValueTypes[0], keyAdapter,\nkeyAndValueTypes[1], valueAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:getKeyAdapter(Lcom/google/gson/Gson;Ljava/lang/reflect/Type;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<?> getKeyAdapter(Gson context, Type keyType) {\nreturn (keyType == boolean.class || keyType == Boolean.class)\n? TypeAdapters.BOOLEAN_AS_STRING\n: context.getAdapter(TypeToken.get(keyType));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nFieldNamingStrategy fieldNamingPolicy, Excluder excluder) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:isLenient()Z",
                                    "method_body": "public final boolean isLenient() {\nreturn lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:beginObject()V",
                                    "method_body": "public void beginObject() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nif (p == PEEKED_BEGIN_OBJECT) {\npush(JsonScope.EMPTY_OBJECT);\npeeked = PEEKED_NONE;\n} else {\nthrow new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek()\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:hasNext()Z",
                                    "method_body": "public boolean hasNext() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nreturn p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader$1:promoteNameToValue(Lcom/google/gson/stream/JsonReader;)V",
                                    "method_body": "@Override public void promoteNameToValue(JsonReader reader) throws IOException {\nif (reader instanceof JsonTreeReader) {\n((JsonTreeReader)reader).promoteNameToValue();\nreturn;\n}\nint p = reader.peeked;\nif (p == PEEKED_NONE) {\np = reader.doPeek();\n}\nif (p == PEEKED_DOUBLE_QUOTED_NAME) {\nreader.peeked = PEEKED_DOUBLE_QUOTED;\n} else if (p == PEEKED_SINGLE_QUOTED_NAME) {\nreader.peeked = PEEKED_SINGLE_QUOTED;\n} else if (p == PEEKED_UNQUOTED_NAME) {\nreader.peeked = PEEKED_UNQUOTED;\n} else {\nthrow new IllegalStateException(\"Expected a name but was \" + reader.peek() + \" \"\n+ \" at line \" + reader.getLineNumber() + \" column \" + reader.getColumnNumber()\n+ \" path \" + reader.getPath());\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nthrow new NullPointerException();\n}\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\nthrow new IllegalArgumentException();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$ParameterizedTypeImpl:<init>(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n// require an owner type if the raw type needs it\nif (rawType instanceof Class<?>) {\nClass<?> rawTypeAsClass = (Class<?>) rawType;\nboolean isStaticOrTopLevelClass = Modifier.isStatic(rawTypeAsClass.getModifiers())\n|| rawTypeAsClass.getEnclosingClass() == null;\ncheckArgument(ownerType != null || isStaticOrTopLevelClass);\n}\n\nthis.ownerType = ownerType == null ? null : canonicalize(ownerType);\nthis.rawType = canonicalize(rawType);\nthis.typeArguments = typeArguments.clone();\nfor (int t = 0; t < this.typeArguments.length; t++) {\ncheckNotNull(this.typeArguments[t]);\ncheckNotPrimitive(this.typeArguments[t]);\nthis.typeArguments[t] = canonicalize(this.typeArguments[t]);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonParseException:<init>(Ljava/lang/Throwable;)V",
                                    "method_body": "public JsonParseException(Throwable cause) {\nsuper(cause);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonSyntaxException:<init>(Ljava/lang/Throwable;)V",
                                    "method_body": "public JsonSyntaxException(Throwable cause) {\nsuper(cause);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson$FutureTypeAdapter:setDelegate(Lcom/google/gson/TypeAdapter;)V",
                                    "method_body": "public void setDelegate(TypeAdapter<T> typeAdapter) {\nif (delegate != null) {\nthrow new AssertionError();\n}\ndelegate = typeAdapter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:<init>(Lcom/google/gson/Gson;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeAdapterRuntimeTypeWrapper(Gson context, TypeAdapter<T> delegate, Type type) {\nthis.context = context;\nthis.delegate = delegate;\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Object;",
                                    "method_body": "public T read(JsonReader in) throws IOException {\nreturn delegate.read(in);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter:<init>(Lcom/google/gson/internal/bind/MapTypeAdapterFactory;Lcom/google/gson/Gson;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Lcom/google/gson/internal/ObjectConstructor;)V",
                                    "method_body": "public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,\nType valueType, TypeAdapter<V> valueTypeAdapter,\nObjectConstructor<? extends Map<K, V>> constructor) {\nthis.keyTypeAdapter =\nnew TypeAdapterRuntimeTypeWrapper<K>(context, keyTypeAdapter, keyType);\nthis.valueTypeAdapter =\nnew TypeAdapterRuntimeTypeWrapper<V>(context, valueTypeAdapter, valueType);\nthis.constructor = constructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter:read(Lcom/google/gson/stream/JsonReader;)Ljava/util/Map;",
                                    "method_body": "@Override public Map<K, V> read(JsonReader in) throws IOException {\nJsonToken peek = in.peek();\nif (peek == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\n\nMap<K, V> map = constructor.construct();\n\nif (peek == JsonToken.BEGIN_ARRAY) {\nin.beginArray();\nwhile (in.hasNext()) {\nin.beginArray(); // entry array\nK key = keyTypeAdapter.read(in);\nV value = valueTypeAdapter.read(in);\nV replaced = map.put(key, value);\nif (replaced != null) {\nthrow new JsonSyntaxException(\"duplicate key: \" + key);\n}\nin.endArray();\n}\nin.endArray();\n} else {\nin.beginObject();\nwhile (in.hasNext()) {\nJsonReaderInternalAccess.INSTANCE.promoteNameToValue(in);\nK key = keyTypeAdapter.read(in);\nV value = valueTypeAdapter.read(in);\nV replaced = map.put(key, value);\nif (replaced != null) {\nthrow new JsonSyntaxException(\"duplicate key: \" + key);\n}\n}\nin.endObject();\n}\nreturn map;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor$12:construct()Ljava/lang/Object;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nfinal Type type, Class<? super T> rawType) {\nif (Collection.class.isAssignableFrom(rawType)) {\nif (SortedSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeSet<Object>();\n}\n};\n} else if (EnumSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"rawtypes\")\n@Override public T construct() {\nif (type instanceof ParameterizedType) {\nType elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\nif (elementType instanceof Class) {\nreturn (T) EnumSet.noneOf((Class)elementType);\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n}\n};\n} else if (Set.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashSet<Object>();\n}\n};\n} else if (Queue.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedList<Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ArrayList<Object>();\n}\n};\n}\n}\n\nif (Map.class.isAssignableFrom(rawType)) {\nif (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ConcurrentSkipListMap<Object, Object>();\n}\n};\n} else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ConcurrentHashMap<Object, Object>();\n}\n};\n} else if (SortedMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeMap<Object, Object>();\n}\n};\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nTypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashMap<Object, Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedTreeMap<String, Object>();\n}\n};\n}\n}\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$12:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Number;",
                                    "method_body": "public Number read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\ntry {\nreturn in.nextLong();\n} catch (NumberFormatException e) {\nthrow new JsonSyntaxException(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextLong()J",
                                    "method_body": "public long nextLong() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\n\nif (p == PEEKED_LONG) {\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn peekedLong;\n}\n\nif (p == PEEKED_NUMBER) {\npeekedString = new String(buffer, pos, peekedNumberLength);\npos += peekedNumberLength;\n} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\npeekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\ntry {\nlong result = Long.parseLong(peekedString);\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n} catch (NumberFormatException ignored) {\n// Fall back to parse as a double below.\n}\n} else {\nthrow new IllegalStateException(\"Expected a long but was \" + peek()\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}\n\npeeked = PEEKED_BUFFERED;\ndouble asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\nlong result = (long) asDouble;\nif (result != asDouble) { // Make sure no precision was lost casting to 'long'.\nthrow new NumberFormatException(\"Expected a long but was \" + peekedString\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}\npeekedString = null;\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.stream.JsonReaderTest.testPeekingUnquotedStringsPrefixedWithIntegers",
                            "test_body": "496: public void testPeekingUnquotedStringsPrefixedWithIntegers() throws IOException {\n497: JsonReader reader = new JsonReader(reader(\"[12.34e5x]\"));\n498: reader.setLenient(true);\n499: reader.beginArray();\n500: assertEquals(STRING, reader.peek());\n501: try {\n502: reader.nextInt();\n503: fail();\n504: } catch (NumberFormatException expected) {\n505: }\n506: assertEquals(\"12.34e5x\", reader.nextString());\n507: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "public JsonReader(Reader in) {\nif (in == null) {\nthrow new NullPointerException(\"in == null\");\n}\nthis.in = in;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<clinit>()V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;\n\nprivate static final int PEEKED_NONE = 0;\nprivate static final int PEEKED_BEGIN_OBJECT = 1;\nprivate static final int PEEKED_END_OBJECT = 2;\nprivate static final int PEEKED_BEGIN_ARRAY = 3;\nprivate static final int PEEKED_END_ARRAY = 4;\nprivate static final int PEEKED_TRUE = 5;\nprivate static final int PEEKED_FALSE = 6;\nprivate static final int PEEKED_NULL = 7;\nprivate static final int PEEKED_SINGLE_QUOTED = 8;\nprivate static final int PEEKED_DOUBLE_QUOTED = 9;\nprivate static final int PEEKED_UNQUOTED = 10;\n/** When this is returned, the string value is stored in peekedString. */\nprivate static final int PEEKED_BUFFERED = 11;\nprivate static final int PEEKED_SINGLE_QUOTED_NAME = 12;\nprivate static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\nprivate static final int PEEKED_UNQUOTED_NAME = 14;\n/** When this is returned, the integer value is stored in peekedLong. */\nprivate static final int PEEKED_LONG = 15;\nprivate static final int PEEKED_NUMBER = 16;\nprivate static final int PEEKED_EOF = 17;\n\n/* State machine when parsing numbers */\nprivate static final int NUMBER_CHAR_NONE = 0;\nprivate static final int NUMBER_CHAR_SIGN = 1;\nprivate static final int NUMBER_CHAR_DIGIT = 2;\nprivate static final int NUMBER_CHAR_DECIMAL = 3;\nprivate static final int NUMBER_CHAR_FRACTION_DIGIT = 4;\nprivate static final int NUMBER_CHAR_EXP_E = 5;\nprivate static final int NUMBER_CHAR_EXP_SIGN = 6;\nprivate static final int NUMBER_CHAR_EXP_DIGIT = 7;\n\n/** The input JSON. */\nprivate final Reader in;\n\n/** True to accept non-spec compliant JSON */\nprivate boolean lenient = false;\n\n/**\n* Use a manual buffer to easily read and unread upcoming characters, and\n* also so we can create strings without an intermediate StringBuilder.\n* We decode literals directly out of this buffer, so it must be at least as\n* long as the longest token that can be reported as a number.\n*/\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\n\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\n\nint peeked = PEEKED_NONE;\n\n/**\n* A peeked value that was composed entirely of digits with an optional\n* leading dash. Positive values may not have a leading 0.\n*/\nprivate long peekedLong;\n\n/**\n* The number of characters in a peeked number literal. Increment 'pos' by\n* this after reading a number.\n*/\nprivate int peekedNumberLength;\n\n/**\n* A peeked string that should be parsed on the next double, long or string.\n* This is populated before a numeric value is parsed and used if that parsing\n* fails.\n*/\nprivate String peekedString;\n\n/*\n* The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n*/\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\n{\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:setLenient(Z)V",
                                    "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:beginArray()V",
                                    "method_body": "public void beginArray() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nif (p == PEEKED_BEGIN_ARRAY) {\npush(JsonScope.EMPTY_ARRAY);\npathIndices[stackSize - 1] = 0;\npeeked = PEEKED_NONE;\n} else {\nthrow new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek()\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\n\nswitch (p) {\ncase PEEKED_BEGIN_OBJECT:\nreturn JsonToken.BEGIN_OBJECT;\ncase PEEKED_END_OBJECT:\nreturn JsonToken.END_OBJECT;\ncase PEEKED_BEGIN_ARRAY:\nreturn JsonToken.BEGIN_ARRAY;\ncase PEEKED_END_ARRAY:\nreturn JsonToken.END_ARRAY;\ncase PEEKED_SINGLE_QUOTED_NAME:\ncase PEEKED_DOUBLE_QUOTED_NAME:\ncase PEEKED_UNQUOTED_NAME:\nreturn JsonToken.NAME;\ncase PEEKED_TRUE:\ncase PEEKED_FALSE:\nreturn JsonToken.BOOLEAN;\ncase PEEKED_NULL:\nreturn JsonToken.NULL;\ncase PEEKED_SINGLE_QUOTED:\ncase PEEKED_DOUBLE_QUOTED:\ncase PEEKED_UNQUOTED:\ncase PEEKED_BUFFERED:\nreturn JsonToken.STRING;\ncase PEEKED_LONG:\ncase PEEKED_NUMBER:\nreturn JsonToken.NUMBER;\ncase PEEKED_EOF:\nreturn JsonToken.END_DOCUMENT;\ndefault:\nthrow new AssertionError();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:doPeek()I",
                                    "method_body": "int doPeek() throws IOException {\nint peekStack = stack[stackSize - 1];\nif (peekStack == JsonScope.EMPTY_ARRAY) {\nstack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n} else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n// Look for a comma before the next element.\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase ']':\nreturn peeked = PEEKED_END_ARRAY;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated array\");\n}\n} else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\nstack[stackSize - 1] = JsonScope.DANGLING_NAME;\n// Look for a comma before the next element.\nif (peekStack == JsonScope.NONEMPTY_OBJECT) {\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '}':\nreturn peeked = PEEKED_END_OBJECT;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated object\");\n}\n}\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '\"':\nreturn peeked = PEEKED_DOUBLE_QUOTED_NAME;\ncase '\\'':\ncheckLenient();\nreturn peeked = PEEKED_SINGLE_QUOTED_NAME;\ncase '}':\nif (peekStack != JsonScope.NONEMPTY_OBJECT) {\nreturn peeked = PEEKED_END_OBJECT;\n} else {\nthrow syntaxError(\"Expected name\");\n}\ndefault:\ncheckLenient();\npos--; // Don't consume the first character in an unquoted string.\nif (isLiteral((char) c)) {\nreturn peeked = PEEKED_UNQUOTED_NAME;\n} else {\nthrow syntaxError(\"Expected name\");\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peekKeyword()I",
                                    "method_body": "private int peekKeyword() throws IOException {\n// Figure out which keyword we're matching against by its first character.\nchar c = buffer[pos];\nString keyword;\nString keywordUpper;\nint peeking;\nif (c == 't' || c == 'T') {\nkeyword = \"true\";\nkeywordUpper = \"TRUE\";\npeeking = PEEKED_TRUE;\n} else if (c == 'f' || c == 'F') {\nkeyword = \"false\";\nkeywordUpper = \"FALSE\";\npeeking = PEEKED_FALSE;\n} else if (c == 'n' || c == 'N') {\nkeyword = \"null\";\nkeywordUpper = \"NULL\";\npeeking = PEEKED_NULL;\n} else {\nreturn PEEKED_NONE;\n}\n\n// Confirm that chars [1..length) match the keyword.\nint length = keyword.length();\nfor (int i = 1; i < length; i++) {\nif (pos + i >= limit && !fillBuffer(i + 1)) {\nreturn PEEKED_NONE;\n}\nc = buffer[pos + i];\nif (c != keyword.charAt(i) && c != keywordUpper.charAt(i)) {\nreturn PEEKED_NONE;\n}\n}\n\nif ((pos + length < limit || fillBuffer(length + 1))\n&& isLiteral(buffer[pos + length])) {\nreturn PEEKED_NONE; // Don't match trues, falsey or nullsoft!\n}\n\n// We've found the keyword followed either by EOF or by a non-literal character.\npos += length;\nreturn peeked = peeking;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peekNumber()I",
                                    "method_body": "private int peekNumber() throws IOException {\n// Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\n\nlong value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\nboolean negative = false;\nboolean fitsInLong = true;\nint last = NUMBER_CHAR_NONE;\n\nint i = 0;\n\ncharactersOfNumber:\nfor (; true; i++) {\nif (p + i == l) {\nif (i == buffer.length) {\n// Though this looks like a well-formed number, it's too long to continue reading. Give up\n// and let the application handle this as an unquoted literal.\nreturn PEEKED_NONE;\n}\nif (!fillBuffer(i + 1)) {\nbreak;\n}\np = pos;\nl = limit;\n}\n\nchar c = buffer[p + i];\nswitch (c) {\ncase '-':\nif (last == NUMBER_CHAR_NONE) {\nnegative = true;\nlast = NUMBER_CHAR_SIGN;\ncontinue;\n} else if (last == NUMBER_CHAR_EXP_E) {\nlast = NUMBER_CHAR_EXP_SIGN;\ncontinue;\n}\nreturn PEEKED_NONE;\n\ncase '+':\nif (last == NUMBER_CHAR_EXP_E) {\nlast = NUMBER_CHAR_EXP_SIGN;\ncontinue;\n}\nreturn PEEKED_NONE;\n\ncase 'e':\ncase 'E':\nif (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\nlast = NUMBER_CHAR_EXP_E;\ncontinue;\n}\nreturn PEEKED_NONE;\n\ncase '.':\nif (last == NUMBER_CHAR_DIGIT) {\nlast = NUMBER_CHAR_DECIMAL;\ncontinue;\n}\nreturn PEEKED_NONE;\n\ndefault:\nif (c < '0' || c > '9') {\nif (!isLiteral(c)) {\nbreak charactersOfNumber;\n}\nreturn PEEKED_NONE;\n}\nif (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\nvalue = -(c - '0');\nlast = NUMBER_CHAR_DIGIT;\n} else if (last == NUMBER_CHAR_DIGIT) {\nif (value == 0) {\nreturn PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n}\nlong newValue = value * 10 - (c - '0');\nfitsInLong &= value > MIN_INCOMPLETE_INTEGER\n|| (value == MIN_INCOMPLETE_INTEGER && newValue < value);\nvalue = newValue;\n} else if (last == NUMBER_CHAR_DECIMAL) {\nlast = NUMBER_CHAR_FRACTION_DIGIT;\n} else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\nlast = NUMBER_CHAR_EXP_DIGIT;\n}\n}\n}\n\n// We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\npeekedLong = negative ? value : -value;\npos += i;\nreturn peeked = PEEKED_LONG;\n} else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n|| last == NUMBER_CHAR_EXP_DIGIT) {\npeekedNumberLength = i;\nreturn peeked = PEEKED_NUMBER;\n} else {\nreturn PEEKED_NONE;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:isLiteral(C)Z",
                                    "method_body": "private boolean isLiteral(char c) throws IOException {\nswitch (c) {\ncase '/':\ncase '\\\\':\ncase ';':\ncase '#':\ncase '=':\ncheckLenient(); // fall-through\ncase '{':\ncase '}':\ncase '[':\ncase ']':\ncase ':':\ncase ',':\ncase ' ':\ncase '\\t':\ncase '\\f':\ncase '\\r':\ncase '\\n':\nreturn false;\ndefault:\nreturn true;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextInt()I",
                                    "method_body": "public int nextInt() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\n\nint result;\nif (p == PEEKED_LONG) {\nresult = (int) peekedLong;\nif (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\nthrow new NumberFormatException(\"Expected an int but was \" + peekedLong\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n}\n\nif (p == PEEKED_NUMBER) {\npeekedString = new String(buffer, pos, peekedNumberLength);\npos += peekedNumberLength;\n} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\npeekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\ntry {\nresult = Integer.parseInt(peekedString);\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n} catch (NumberFormatException ignored) {\n// Fall back to parse as a double below.\n}\n} else {\nthrow new IllegalStateException(\"Expected an int but was \" + peek()\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}\n\npeeked = PEEKED_BUFFERED;\ndouble asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\nresult = (int) asDouble;\nif (result != asDouble) { // Make sure no precision was lost casting to 'int'.\nthrow new NumberFormatException(\"Expected an int but was \" + peekedString\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}\npeekedString = null;\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:push(I)V",
                                    "method_body": "private void push(int newTop) {\nif (stackSize == stack.length) {\nint[] newStack = new int[stackSize * 2];\nint[] newPathIndices = new int[stackSize * 2];\nString[] newPathNames = new String[stackSize * 2];\nSystem.arraycopy(stack, 0, newStack, 0, stackSize);\nSystem.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\nSystem.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\nstack = newStack;\npathIndices = newPathIndices;\npathNames = newPathNames;\n}\nstack[stackSize++] = newTop;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit -= pos;\nSystem.arraycopy(buffer, pos, buffer, 0, limit);\n} else {\nlimit = 0;\n}\n\npos = 0;\nint total;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\n\n// if this is the first read, consume an optional byte order mark (BOM) if it exists\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\npos++;\nlineStart++;\nminimum++;\n}\n\nif (limit >= minimum) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getLineNumber()I",
                                    "method_body": "int getLineNumber() {\nreturn lineNumber + 1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getColumnNumber()I",
                                    "method_body": "int getColumnNumber() {\nreturn pos - lineStart + 1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n/*\n* This code uses ugly local variables 'p' and 'l' representing the 'pos'\n* and 'limit' fields respectively. Using locals rather than fields saves\n* a few field reads for each whitespace character in a pretty-printed\n* document, resulting in a 5% speedup. We need to flush 'p' to its field\n* before any (potentially indirect) call to fillBuffer() and reread both\n* 'p' and 'l' after any (potentially indirect) call to the same method.\n*/\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nwhile (true) {\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\nbreak;\n}\np = pos;\nl = limit;\n}\n\nint c = buffer[p++];\nif (c == '\\n') {\nlineNumber++;\nlineStart = p;\ncontinue;\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\ncontinue;\n}\n\nif (c == '/') {\npos = p;\nif (p == l) {\npos--; // push back '/' so it's still in the buffer when this method returns\nboolean charsLoaded = fillBuffer(2);\npos++; // consume the '/' again\nif (!charsLoaded) {\nreturn c;\n}\n}\n\ncheckLenient();\nchar peek = buffer[pos];\nswitch (peek) {\ncase '*':\n// skip a /* c-style comment */\npos++;\nif (!skipTo(\"*/\")) {\nthrow syntaxError(\"Unterminated comment\");\n}\np = pos + 2;\nl = limit;\ncontinue;\n\ncase '/':\n// skip a // end-of-line comment\npos++;\nskipToEndOfLine();\np = pos;\nl = limit;\ncontinue;\n\ndefault:\nreturn c;\n}\n} else if (c == '#') {\npos = p;\n/*\n* Skip a # hash end-of-line comment. The JSON RFC doesn't\n* specify this behaviour, but it's required to parse\n* existing documents. See http://b/2571423.\n*/\ncheckLenient();\nskipToEndOfLine();\np = pos;\nl = limit;\n} else {\npos = p;\nreturn c;\n}\n}\nif (throwOnEof) {\nthrow new EOFException(\"End of input\"\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n} else {\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:checkLenient()V",
                                    "method_body": "private void checkLenient() throws IOException {\nif (!lenient) {\nthrow syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\");\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getPath()Ljava/lang/String;",
                                    "method_body": "public String getPath() {\nStringBuilder result = new StringBuilder().append('$');\nfor (int i = 0, size = stackSize; i < size; i++) {\nswitch (stack[i]) {\ncase JsonScope.EMPTY_ARRAY:\ncase JsonScope.NONEMPTY_ARRAY:\nresult.append('[').append(pathIndices[i]).append(']');\nbreak;\n\ncase JsonScope.EMPTY_OBJECT:\ncase JsonScope.DANGLING_NAME:\ncase JsonScope.NONEMPTY_OBJECT:\nresult.append('.');\nif (pathNames[i] != null) {\nresult.append(pathNames[i]);\n}\nbreak;\n\ncase JsonScope.NONEMPTY_DOCUMENT:\ncase JsonScope.EMPTY_DOCUMENT:\ncase JsonScope.CLOSED:\nbreak;\n}\n}\nreturn result.toString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:consumeNonExecutePrefix()V",
                                    "method_body": "private void consumeNonExecutePrefix() throws IOException {\n// fast forward through the leading whitespace\nnextNonWhitespace(true);\npos--;\n\nif (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\nreturn;\n}\n\nfor (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\nif (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\nreturn; // not a security token!\n}\n}\n\n// we consumed a security token!\npos += NON_EXECUTE_PREFIX.length;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.functional.MapTest.testMapDeserializationWithUnquotedIntegerKeys",
                            "test_body": "170: public void testMapDeserializationWithUnquotedIntegerKeys() {\n171: Type typeOfMap = new TypeToken<Map<Integer, String>>() {}.getType();\n172: Map<Integer, String> map = gson.fromJson(\"{123:\\\"456\\\"}\", typeOfMap);\n173: assertEquals(1, map.size());\n174: assertTrue(map.containsKey(123));\n175: assertEquals(\"456\", map.get(123));\n176: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "public JsonReader(Reader in) {\nif (in == null) {\nthrow new NullPointerException(\"in == null\");\n}\nthis.in = in;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<clinit>()V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;\n\nprivate static final int PEEKED_NONE = 0;\nprivate static final int PEEKED_BEGIN_OBJECT = 1;\nprivate static final int PEEKED_END_OBJECT = 2;\nprivate static final int PEEKED_BEGIN_ARRAY = 3;\nprivate static final int PEEKED_END_ARRAY = 4;\nprivate static final int PEEKED_TRUE = 5;\nprivate static final int PEEKED_FALSE = 6;\nprivate static final int PEEKED_NULL = 7;\nprivate static final int PEEKED_SINGLE_QUOTED = 8;\nprivate static final int PEEKED_DOUBLE_QUOTED = 9;\nprivate static final int PEEKED_UNQUOTED = 10;\n/** When this is returned, the string value is stored in peekedString. */\nprivate static final int PEEKED_BUFFERED = 11;\nprivate static final int PEEKED_SINGLE_QUOTED_NAME = 12;\nprivate static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\nprivate static final int PEEKED_UNQUOTED_NAME = 14;\n/** When this is returned, the integer value is stored in peekedLong. */\nprivate static final int PEEKED_LONG = 15;\nprivate static final int PEEKED_NUMBER = 16;\nprivate static final int PEEKED_EOF = 17;\n\n/* State machine when parsing numbers */\nprivate static final int NUMBER_CHAR_NONE = 0;\nprivate static final int NUMBER_CHAR_SIGN = 1;\nprivate static final int NUMBER_CHAR_DIGIT = 2;\nprivate static final int NUMBER_CHAR_DECIMAL = 3;\nprivate static final int NUMBER_CHAR_FRACTION_DIGIT = 4;\nprivate static final int NUMBER_CHAR_EXP_E = 5;\nprivate static final int NUMBER_CHAR_EXP_SIGN = 6;\nprivate static final int NUMBER_CHAR_EXP_DIGIT = 7;\n\n/** The input JSON. */\nprivate final Reader in;\n\n/** True to accept non-spec compliant JSON */\nprivate boolean lenient = false;\n\n/**\n* Use a manual buffer to easily read and unread upcoming characters, and\n* also so we can create strings without an intermediate StringBuilder.\n* We decode literals directly out of this buffer, so it must be at least as\n* long as the longest token that can be reported as a number.\n*/\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\n\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\n\nint peeked = PEEKED_NONE;\n\n/**\n* A peeked value that was composed entirely of digits with an optional\n* leading dash. Positive values may not have a leading 0.\n*/\nprivate long peekedLong;\n\n/**\n* The number of characters in a peeked number literal. Increment 'pos' by\n* this after reading a number.\n*/\nprivate int peekedNumberLength;\n\n/**\n* A peeked string that should be parsed on the next double, long or string.\n* This is populated before a numeric value is parsed and used if that parsing\n* fails.\n*/\nprivate String peekedString;\n\n/*\n* The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n*/\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\n{\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:setLenient(Z)V",
                                    "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\n\nswitch (p) {\ncase PEEKED_BEGIN_OBJECT:\nreturn JsonToken.BEGIN_OBJECT;\ncase PEEKED_END_OBJECT:\nreturn JsonToken.END_OBJECT;\ncase PEEKED_BEGIN_ARRAY:\nreturn JsonToken.BEGIN_ARRAY;\ncase PEEKED_END_ARRAY:\nreturn JsonToken.END_ARRAY;\ncase PEEKED_SINGLE_QUOTED_NAME:\ncase PEEKED_DOUBLE_QUOTED_NAME:\ncase PEEKED_UNQUOTED_NAME:\nreturn JsonToken.NAME;\ncase PEEKED_TRUE:\ncase PEEKED_FALSE:\nreturn JsonToken.BOOLEAN;\ncase PEEKED_NULL:\nreturn JsonToken.NULL;\ncase PEEKED_SINGLE_QUOTED:\ncase PEEKED_DOUBLE_QUOTED:\ncase PEEKED_UNQUOTED:\ncase PEEKED_BUFFERED:\nreturn JsonToken.STRING;\ncase PEEKED_LONG:\ncase PEEKED_NUMBER:\nreturn JsonToken.NUMBER;\ncase PEEKED_EOF:\nreturn JsonToken.END_DOCUMENT;\ndefault:\nthrow new AssertionError();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:doPeek()I",
                                    "method_body": "int doPeek() throws IOException {\nint peekStack = stack[stackSize - 1];\nif (peekStack == JsonScope.EMPTY_ARRAY) {\nstack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n} else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n// Look for a comma before the next element.\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase ']':\nreturn peeked = PEEKED_END_ARRAY;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated array\");\n}\n} else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\nstack[stackSize - 1] = JsonScope.DANGLING_NAME;\n// Look for a comma before the next element.\nif (peekStack == JsonScope.NONEMPTY_OBJECT) {\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '}':\nreturn peeked = PEEKED_END_OBJECT;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated object\");\n}\n}\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '\"':\nreturn peeked = PEEKED_DOUBLE_QUOTED_NAME;\ncase '\\'':\ncheckLenient();\nreturn peeked = PEEKED_SINGLE_QUOTED_NAME;\ncase '}':\nif (peekStack != JsonScope.NONEMPTY_OBJECT) {\nreturn peeked = PEEKED_END_OBJECT;\n} else {\nthrow syntaxError(\"Expected name\");\n}\ndefault:\ncheckLenient();\npos--; // Don't consume the first character in an unquoted string.\nif (isLiteral((char) c)) {\nreturn peeked = PEEKED_UNQUOTED_NAME;\n} else {\nthrow syntaxError(\"Expected name\");\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:isLiteral(C)Z",
                                    "method_body": "private boolean isLiteral(char c) throws IOException {\nswitch (c) {\ncase '/':\ncase '\\\\':\ncase ';':\ncase '#':\ncase '=':\ncheckLenient(); // fall-through\ncase '{':\ncase '}':\ncase '[':\ncase ']':\ncase ':':\ncase ',':\ncase ' ':\ncase '\\t':\ncase '\\f':\ncase '\\r':\ncase '\\n':\nreturn false;\ndefault:\nreturn true;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextInt()I",
                                    "method_body": "public int nextInt() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\n\nint result;\nif (p == PEEKED_LONG) {\nresult = (int) peekedLong;\nif (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\nthrow new NumberFormatException(\"Expected an int but was \" + peekedLong\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n}\n\nif (p == PEEKED_NUMBER) {\npeekedString = new String(buffer, pos, peekedNumberLength);\npos += peekedNumberLength;\n} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\npeekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\ntry {\nresult = Integer.parseInt(peekedString);\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n} catch (NumberFormatException ignored) {\n// Fall back to parse as a double below.\n}\n} else {\nthrow new IllegalStateException(\"Expected an int but was \" + peek()\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}\n\npeeked = PEEKED_BUFFERED;\ndouble asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\nresult = (int) asDouble;\nif (result != asDouble) { // Make sure no precision was lost casting to 'int'.\nthrow new NumberFormatException(\"Expected an int but was \" + peekedString\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}\npeekedString = null;\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:push(I)V",
                                    "method_body": "private void push(int newTop) {\nif (stackSize == stack.length) {\nint[] newStack = new int[stackSize * 2];\nint[] newPathIndices = new int[stackSize * 2];\nString[] newPathNames = new String[stackSize * 2];\nSystem.arraycopy(stack, 0, newStack, 0, stackSize);\nSystem.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\nSystem.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\nstack = newStack;\npathIndices = newPathIndices;\npathNames = newPathNames;\n}\nstack[stackSize++] = newTop;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit -= pos;\nSystem.arraycopy(buffer, pos, buffer, 0, limit);\n} else {\nlimit = 0;\n}\n\npos = 0;\nint total;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\n\n// if this is the first read, consume an optional byte order mark (BOM) if it exists\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\npos++;\nlineStart++;\nminimum++;\n}\n\nif (limit >= minimum) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getLineNumber()I",
                                    "method_body": "int getLineNumber() {\nreturn lineNumber + 1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getColumnNumber()I",
                                    "method_body": "int getColumnNumber() {\nreturn pos - lineStart + 1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n/*\n* This code uses ugly local variables 'p' and 'l' representing the 'pos'\n* and 'limit' fields respectively. Using locals rather than fields saves\n* a few field reads for each whitespace character in a pretty-printed\n* document, resulting in a 5% speedup. We need to flush 'p' to its field\n* before any (potentially indirect) call to fillBuffer() and reread both\n* 'p' and 'l' after any (potentially indirect) call to the same method.\n*/\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nwhile (true) {\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\nbreak;\n}\np = pos;\nl = limit;\n}\n\nint c = buffer[p++];\nif (c == '\\n') {\nlineNumber++;\nlineStart = p;\ncontinue;\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\ncontinue;\n}\n\nif (c == '/') {\npos = p;\nif (p == l) {\npos--; // push back '/' so it's still in the buffer when this method returns\nboolean charsLoaded = fillBuffer(2);\npos++; // consume the '/' again\nif (!charsLoaded) {\nreturn c;\n}\n}\n\ncheckLenient();\nchar peek = buffer[pos];\nswitch (peek) {\ncase '*':\n// skip a /* c-style comment */\npos++;\nif (!skipTo(\"*/\")) {\nthrow syntaxError(\"Unterminated comment\");\n}\np = pos + 2;\nl = limit;\ncontinue;\n\ncase '/':\n// skip a // end-of-line comment\npos++;\nskipToEndOfLine();\np = pos;\nl = limit;\ncontinue;\n\ndefault:\nreturn c;\n}\n} else if (c == '#') {\npos = p;\n/*\n* Skip a # hash end-of-line comment. The JSON RFC doesn't\n* specify this behaviour, but it's required to parse\n* existing documents. See http://b/2571423.\n*/\ncheckLenient();\nskipToEndOfLine();\np = pos;\nl = limit;\n} else {\npos = p;\nreturn c;\n}\n}\nif (throwOnEof) {\nthrow new EOFException(\"End of input\"\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n} else {\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:checkLenient()V",
                                    "method_body": "private void checkLenient() throws IOException {\nif (!lenient) {\nthrow syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\");\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:getPath()Ljava/lang/String;",
                                    "method_body": "public String getPath() {\nStringBuilder result = new StringBuilder().append('$');\nfor (int i = 0, size = stackSize; i < size; i++) {\nswitch (stack[i]) {\ncase JsonScope.EMPTY_ARRAY:\ncase JsonScope.NONEMPTY_ARRAY:\nresult.append('[').append(pathIndices[i]).append(']');\nbreak;\n\ncase JsonScope.EMPTY_OBJECT:\ncase JsonScope.DANGLING_NAME:\ncase JsonScope.NONEMPTY_OBJECT:\nresult.append('.');\nif (pathNames[i] != null) {\nresult.append(pathNames[i]);\n}\nbreak;\n\ncase JsonScope.NONEMPTY_DOCUMENT:\ncase JsonScope.EMPTY_DOCUMENT:\ncase JsonScope.CLOSED:\nbreak;\n}\n}\nreturn result.toString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:consumeNonExecutePrefix()V",
                                    "method_body": "private void consumeNonExecutePrefix() throws IOException {\n// fast forward through the leading whitespace\nnextNonWhitespace(true);\npos--;\n\nif (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\nreturn;\n}\n\nfor (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\nif (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\nreturn; // not a security token!\n}\n}\n\n// we consumed a security token!\npos += NON_EXECUTE_PREFIX.length;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\nCollections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\nDEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\nDEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\nLongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingPolicy,\nfinal Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,\nboolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\nboolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,\nLongSerializationPolicy longSerializationPolicy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nthis.lenient = lenient;\n\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n\n// built-in type adapters that cannot be overridden\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\n\n// the excluder must precede all adapters that handle user-defined types\nfactories.add(excluder);\n\n// user's type adapters\nfactories.addAll(typeAdapterFactories);\n\n// type adapters for basic platform types\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nTypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\ndoubleAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfloatAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\nfactories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\nfactories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.CURRENCY_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\n\n// type adapters for composite and user-defined types\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nfactories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nconstructorConstructor, fieldNamingPolicy, excluder));\n\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<clinit>()V",
                                    "method_body": "static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\nstatic final boolean DEFAULT_LENIENT = false;\nstatic final boolean DEFAULT_PRETTY_PRINT = false;\nstatic final boolean DEFAULT_ESCAPE_HTML = true;\nstatic final boolean DEFAULT_SERIALIZE_NULLS = false;\nstatic final boolean DEFAULT_COMPLEX_MAP_KEYS = false;\nstatic final boolean DEFAULT_SPECIALIZE_FLOAT_VALUES = false;\n\nprivate static final TypeToken<?> NULL_KEY_SURROGATE = new TypeToken<Object>() {};"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.DOUBLE;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Double read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\ndouble doubleValue = value.doubleValue();\ncheckValidFloatingPoint(doubleValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.FLOAT;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Float read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn (float) in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nfloat floatValue = value.floatValue();\ncheckValidFloatingPoint(floatValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Number read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextLong();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nout.value(value.toString());\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLong>() {\n@Override public void write(JsonWriter out, AtomicLong value) throws IOException {\nlongAdapter.write(out, value.get());\n}\n@Override public AtomicLong read(JsonReader in) throws IOException {\nNumber value = longAdapter.read(in);\nreturn new AtomicLong(value.longValue());\n}\n}.nullSafe();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongArrayAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLongArray>() {\n@Override public void write(JsonWriter out, AtomicLongArray value) throws IOException {\nout.beginArray();\nfor (int i = 0, length = value.length(); i < length; i++) {\nlongAdapter.write(out, value.get(i));\n}\nout.endArray();\n}\n@Override public AtomicLongArray read(JsonReader in) throws IOException {\nList<Long> list = new ArrayList<Long>();\nin.beginArray();\nwhile (in.hasNext()) {\nlong value = longAdapter.read(in).longValue();\nlist.add(value);\n}\nin.endArray();\nint length = list.size();\nAtomicLongArray array = new AtomicLongArray(length);\nfor (int i = 0; i < length; ++i) {\narray.set(i, list.get(i));\n}\nreturn array;\n}\n}.nullSafe();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);\nif (cached != null) {\nreturn (TypeAdapter<T>) cached;\n}\n\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\n}\n\n// the key and value type parameters always agree\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nreturn ongoingCall;\n}\n\ntry {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\n\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\n}\n}\nthrow new IllegalArgumentException(\"GSON cannot handle \" + type);\n} finally {\nthreadCalls.remove(type);\n\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:newJsonReader(Ljava/io/Reader;)Lcom/google/gson/stream/JsonReader;",
                                    "method_body": "public JsonReader newJsonReader(Reader reader) {\nJsonReader jsonReader = new JsonReader(reader);\njsonReader.setLenient(lenient);\nreturn jsonReader;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {\nif (json == null) {\nreturn null;\n}\nStringReader reader = new StringReader(json);\nT target = (T) fromJson(reader, typeOfT);\nreturn target;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/io/Reader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nJsonReader jsonReader = newJsonReader(json);\nT object = (T) fromJson(jsonReader, typeOfT);\nassertFullConsumption(object, jsonReader);\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Lcom/google/gson/stream/JsonReader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nboolean isEmpty = true;\nboolean oldLenient = reader.isLenient();\nreader.setLenient(true);\ntry {\nreader.peek();\nisEmpty = false;\nTypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\nTypeAdapter<T> typeAdapter = getAdapter(typeToken);\nT object = typeAdapter.read(reader);\nreturn object;\n} catch (EOFException e) {\n/*\n* For compatibility with JSON 1.5 and earlier, we return null for empty\n* documents instead of throwing.\n*/\nif (isEmpty) {\nreturn null;\n}\nthrow new JsonSyntaxException(e);\n} catch (IllegalStateException e) {\nthrow new JsonSyntaxException(e);\n} catch (IOException e) {\n// TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException\nthrow new JsonSyntaxException(e);\n} finally {\nreader.setLenient(oldLenient);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>()V",
                                    "method_body": "protected TypeToken() {\nthis.type = getSuperclassTypeParameter(getClass());\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(type);\nthis.hashCode = type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getSuperclassTypeParameter(Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getSuperclassTypeParameter(Class<?> subclass) {\nType superclass = subclass.getGenericSuperclass();\nif (superclass instanceof Class) {\nthrow new RuntimeException(\"Missing type parameter.\");\n}\nParameterizedType parameterized = (ParameterizedType) superclass;\nreturn $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\np.getRawType(), p.getActualTypeArguments());\n\n} else if (type instanceof GenericArrayType) {\nGenericArrayType g = (GenericArrayType) type;\nreturn new GenericArrayTypeImpl(g.getGenericComponentType());\n\n} else if (type instanceof WildcardType) {\nWildcardType w = (WildcardType) type;\nreturn new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n} else {\n// type is either serializable as-is or unsupported\nreturn type;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\n// type is a normal class.\nreturn (Class<?>) type;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType parameterizedType = (ParameterizedType) type;\n\n// I'm not exactly sure why getRawType() returns Type instead of Class.\n// Neal isn't either but suspects some pathological case related\n// to nested classes exists.\nType rawType = parameterizedType.getRawType();\ncheckArgument(rawType instanceof Class);\nreturn (Class<?>) rawType;\n\n} else if (type instanceof GenericArrayType) {\nType componentType = ((GenericArrayType)type).getGenericComponentType();\nreturn Array.newInstance(getRawType(componentType), 0).getClass();\n\n} else if (type instanceof TypeVariable) {\n// we could use the variable's bounds, but that won't work if there are multiple.\n// having a raw type that's more general than necessary is okay\nreturn Object.class;\n\n} else if (type instanceof WildcardType) {\nreturn getRawType(((WildcardType) type).getUpperBounds()[0]);\n\n} else {\nString className = type == null ? \"null\" : type.getClass().getName();\nthrow new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n+ \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:hashCodeOrZero(Ljava/lang/Object;)I",
                                    "method_body": "static int hashCodeOrZero(Object o) {\nreturn o != null ? o.hashCode() : 0;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getGenericSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\nif (toResolve == rawType) {\nreturn context;\n}\n\n// we skip searching through interfaces if unknown is an interface\nif (toResolve.isInterface()) {\nClass<?>[] interfaces = rawType.getInterfaces();\nfor (int i = 0, length = interfaces.length; i < length; i++) {\nif (interfaces[i] == toResolve) {\nreturn rawType.getGenericInterfaces()[i];\n} else if (toResolve.isAssignableFrom(interfaces[i])) {\nreturn getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n}\n}\n}\n\n// check our supertypes\nif (!rawType.isInterface()) {\nwhile (rawType != Object.class) {\nClass<?> rawSupertype = rawType.getSuperclass();\nif (rawSupertype == toResolve) {\nreturn rawType.getGenericSuperclass();\n} else if (toResolve.isAssignableFrom(rawSupertype)) {\nreturn getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);\n}\nrawType = rawSupertype;\n}\n}\n\n// we can't resolve this further\nreturn toResolve;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\ncheckArgument(supertype.isAssignableFrom(contextRawType));\nreturn resolve(context, contextRawType,\n$Gson$Types.getGenericSupertype(context, contextRawType, supertype));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getMapKeyAndValueTypes(Ljava/lang/reflect/Type;Ljava/lang/Class;)[Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {\n/*\n* Work around a problem with the declaration of java.util.Properties. That\n* class should extend Hashtable<String, String>, but it's declared to\n* extend Hashtable<Object, Object>.\n*/\nif (context == Properties.class) {\nreturn new Type[] { String.class, String.class }; // TODO: test subclasses of Properties!\n}\n\nType mapType = getSupertype(context, contextRawType, Map.class);\n// TODO: strip wildcards?\nif (mapType instanceof ParameterizedType) {\nParameterizedType mapParameterizedType = (ParameterizedType) mapType;\nreturn mapParameterizedType.getActualTypeArguments();\n}\nreturn new Type[] { Object.class, Object.class };\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\n// this implementation is made a little more complicated in an attempt to avoid object-creation\nwhile (true) {\nif (toResolve instanceof TypeVariable) {\nTypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\ntoResolve = resolveTypeVariable(context, contextRawType, typeVariable);\nif (toResolve == typeVariable) {\nreturn toResolve;\n}\n\n} else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\nClass<?> original = (Class<?>) toResolve;\nType componentType = original.getComponentType();\nType newComponentType = resolve(context, contextRawType, componentType);\nreturn componentType == newComponentType\n? original\n: arrayOf(newComponentType);\n\n} else if (toResolve instanceof GenericArrayType) {\nGenericArrayType original = (GenericArrayType) toResolve;\nType componentType = original.getGenericComponentType();\nType newComponentType = resolve(context, contextRawType, componentType);\nreturn componentType == newComponentType\n? original\n: arrayOf(newComponentType);\n\n} else if (toResolve instanceof ParameterizedType) {\nParameterizedType original = (ParameterizedType) toResolve;\nType ownerType = original.getOwnerType();\nType newOwnerType = resolve(context, contextRawType, ownerType);\nboolean changed = newOwnerType != ownerType;\n\nType[] args = original.getActualTypeArguments();\nfor (int t = 0, length = args.length; t < length; t++) {\nType resolvedTypeArgument = resolve(context, contextRawType, args[t]);\nif (resolvedTypeArgument != args[t]) {\nif (!changed) {\nargs = args.clone();\nchanged = true;\n}\nargs[t] = resolvedTypeArgument;\n}\n}\n\nreturn changed\n? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n: original;\n\n} else if (toResolve instanceof WildcardType) {\nWildcardType original = (WildcardType) toResolve;\nType[] originalLowerBound = original.getLowerBounds();\nType[] originalUpperBound = original.getUpperBounds();\n\nif (originalLowerBound.length == 1) {\nType lowerBound = resolve(context, contextRawType, originalLowerBound[0]);\nif (lowerBound != originalLowerBound[0]) {\nreturn supertypeOf(lowerBound);\n}\n} else if (originalUpperBound.length == 1) {\nType upperBound = resolve(context, contextRawType, originalUpperBound[0]);\nif (upperBound != originalUpperBound[0]) {\nreturn subtypeOf(upperBound);\n}\n}\nreturn original;\n\n} else {\nreturn toResolve;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\n\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate boolean requireExpose;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n\n@Override protected Excluder clone() {\ntry {\nreturn (Excluder) super.clone();\n} catch (CloneNotSupportedException e) {\nthrow new AssertionError(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\n\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}\n\nreturn new TypeAdapter<T>() {\n/** The delegate is lazily created because it may not be needed, and creating it may fail. */\nprivate TypeAdapter<T> delegate;\n\n@Override public T read(JsonReader in) throws IOException {\nif (skipDeserialize) {\nin.skipValue();\nreturn null;\n}\nreturn delegate().read(in);\n}\n\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (skipSerialize) {\nout.nullValue();\nreturn;\n}\ndelegate().write(out, value);\n}\n\nprivate TypeAdapter<T> delegate() {\nTypeAdapter<T> d = delegate;\nreturn d != null\n? d\n: (delegate = gson.getDelegateAdapter(Excluder.this, type));\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\n&& !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\nreturn true;\n}\n\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nreturn true;\n}\n\nif (isAnonymousOrLocal(clazz)) {\nreturn true;\n}\n\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nif (exclusionStrategy.shouldSkipClass(clazz)) {\nreturn true;\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n&& (clazz.isAnonymousClass() || clazz.isLocalClass());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\n\n// first try an instance creator\n\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn typeCreator.createInstance(type);\n}\n};\n}\n\n// Next try raw type match for instance creators\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> rawTypeCreator =\n(InstanceCreator<T>) instanceCreators.get(rawType);\nif (rawTypeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn rawTypeCreator.createInstance(type);\n}\n};\n}\n\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nreturn defaultConstructor;\n}\n\nObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\nif (defaultImplementation != null) {\nreturn defaultImplementation;\n}\n\n// finally try unsafe\nreturn newUnsafeAllocator(type, rawType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultConstructor(Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\ntry {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\n}\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"unchecked\") // T is the same raw type as is requested\n@Override public T construct() {\ntry {\nObject[] args = null;\nreturn (T) constructor.newInstance(args);\n} catch (InstantiationException e) {\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\", e);\n} catch (InvocationTargetException e) {\n// TODO: don't wrap if cause is unchecked!\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",\ne.getTargetException());\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\n}\n};\n} catch (NoSuchMethodException e) {\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultImplementationConstructor(Ljava/lang/reflect/Type;Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nfinal Type type, Class<? super T> rawType) {\nif (Collection.class.isAssignableFrom(rawType)) {\nif (SortedSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeSet<Object>();\n}\n};\n} else if (EnumSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"rawtypes\")\n@Override public T construct() {\nif (type instanceof ParameterizedType) {\nType elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\nif (elementType instanceof Class) {\nreturn (T) EnumSet.noneOf((Class)elementType);\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n}\n};\n} else if (Set.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashSet<Object>();\n}\n};\n} else if (Queue.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedList<Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ArrayList<Object>();\n}\n};\n}\n}\n\nif (Map.class.isAssignableFrom(rawType)) {\nif (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ConcurrentSkipListMap<Object, Object>();\n}\n};\n} else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ConcurrentHashMap<Object, Object>();\n}\n};\n} else if (SortedMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeMap<Object, Object>();\n}\n};\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nTypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashMap<Object, Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedTreeMap<String, Object>();\n}\n};\n}\n}\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n@Override\npublic void write(JsonWriter out, Class value) throws IOException {\nif (value == null) {\nout.nullValue();\n} else {\nthrow new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n+ value.getName() + \". Forgot to register a type adapter?\");\n}\n}\n@Override\npublic Class read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n} else {\nthrow new UnsupportedOperationException(\n\"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n}\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:nullSafe()Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public final TypeAdapter<T> nullSafe() {\nreturn new TypeAdapter<T>() {\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (value == null) {\nout.nullValue();\n} else {\nTypeAdapter.this.write(out, value);\n}\n}\n@Override public T read(JsonReader reader) throws IOException {\nif (reader.peek() == JsonToken.NULL) {\nreader.nextNull();\nreturn null;\n}\nreturn TypeAdapter.this.read(reader);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$11:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Number;",
                                    "method_body": "public Number read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\ntry {\nreturn in.nextInt();\n} catch (NumberFormatException e) {\nthrow new JsonSyntaxException(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$35:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$26:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}\n\nfinal TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\nreturn (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n@Override public Timestamp read(JsonReader in) throws IOException {\nDate date = dateTypeAdapter.read(in);\nreturn date != null ? new Timestamp(date.getTime()) : null;\n}\n\n@Override public void write(JsonWriter out, Timestamp value) throws IOException {\ndateTypeAdapter.write(out, value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$34:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nType elementType = $Gson$Types.getCollectionElementType(type, rawType);\nTypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // create() doesn't define a type parameter\nTypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nClass<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\nType[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\nTypeAdapter<?> keyAdapter = getKeyAdapter(gson, keyAndValueTypes[0]);\nTypeAdapter<?> valueAdapter = gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n// we don't define a type parameter for the key or value types\nTypeAdapter<T> result = new Adapter(gson, keyAndValueTypes[0], keyAdapter,\nkeyAndValueTypes[1], valueAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:getKeyAdapter(Lcom/google/gson/Gson;Ljava/lang/reflect/Type;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<?> getKeyAdapter(Gson context, Type keyType) {\nreturn (keyType == boolean.class || keyType == Boolean.class)\n? TypeAdapters.BOOLEAN_AS_STRING\n: context.getAdapter(TypeToken.get(keyType));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nFieldNamingStrategy fieldNamingPolicy, Excluder excluder) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:isLenient()Z",
                                    "method_body": "public final boolean isLenient() {\nreturn lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:beginObject()V",
                                    "method_body": "public void beginObject() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nif (p == PEEKED_BEGIN_OBJECT) {\npush(JsonScope.EMPTY_OBJECT);\npeeked = PEEKED_NONE;\n} else {\nthrow new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek()\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:hasNext()Z",
                                    "method_body": "public boolean hasNext() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nreturn p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader$1:promoteNameToValue(Lcom/google/gson/stream/JsonReader;)V",
                                    "method_body": "@Override public void promoteNameToValue(JsonReader reader) throws IOException {\nif (reader instanceof JsonTreeReader) {\n((JsonTreeReader)reader).promoteNameToValue();\nreturn;\n}\nint p = reader.peeked;\nif (p == PEEKED_NONE) {\np = reader.doPeek();\n}\nif (p == PEEKED_DOUBLE_QUOTED_NAME) {\nreader.peeked = PEEKED_DOUBLE_QUOTED;\n} else if (p == PEEKED_SINGLE_QUOTED_NAME) {\nreader.peeked = PEEKED_SINGLE_QUOTED;\n} else if (p == PEEKED_UNQUOTED_NAME) {\nreader.peeked = PEEKED_UNQUOTED;\n} else {\nthrow new IllegalStateException(\"Expected a name but was \" + reader.peek() + \" \"\n+ \" at line \" + reader.getLineNumber() + \" column \" + reader.getColumnNumber()\n+ \" path \" + reader.getPath());\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nthrow new NullPointerException();\n}\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\nthrow new IllegalArgumentException();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$ParameterizedTypeImpl:<init>(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n// require an owner type if the raw type needs it\nif (rawType instanceof Class<?>) {\nClass<?> rawTypeAsClass = (Class<?>) rawType;\nboolean isStaticOrTopLevelClass = Modifier.isStatic(rawTypeAsClass.getModifiers())\n|| rawTypeAsClass.getEnclosingClass() == null;\ncheckArgument(ownerType != null || isStaticOrTopLevelClass);\n}\n\nthis.ownerType = ownerType == null ? null : canonicalize(ownerType);\nthis.rawType = canonicalize(rawType);\nthis.typeArguments = typeArguments.clone();\nfor (int t = 0; t < this.typeArguments.length; t++) {\ncheckNotNull(this.typeArguments[t]);\ncheckNotPrimitive(this.typeArguments[t]);\nthis.typeArguments[t] = canonicalize(this.typeArguments[t]);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonParseException:<init>(Ljava/lang/Throwable;)V",
                                    "method_body": "public JsonParseException(Throwable cause) {\nsuper(cause);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonSyntaxException:<init>(Ljava/lang/Throwable;)V",
                                    "method_body": "public JsonSyntaxException(Throwable cause) {\nsuper(cause);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson$FutureTypeAdapter:setDelegate(Lcom/google/gson/TypeAdapter;)V",
                                    "method_body": "public void setDelegate(TypeAdapter<T> typeAdapter) {\nif (delegate != null) {\nthrow new AssertionError();\n}\ndelegate = typeAdapter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:<init>(Lcom/google/gson/Gson;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeAdapterRuntimeTypeWrapper(Gson context, TypeAdapter<T> delegate, Type type) {\nthis.context = context;\nthis.delegate = delegate;\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Object;",
                                    "method_body": "public T read(JsonReader in) throws IOException {\nreturn delegate.read(in);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter:<init>(Lcom/google/gson/internal/bind/MapTypeAdapterFactory;Lcom/google/gson/Gson;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Lcom/google/gson/internal/ObjectConstructor;)V",
                                    "method_body": "public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,\nType valueType, TypeAdapter<V> valueTypeAdapter,\nObjectConstructor<? extends Map<K, V>> constructor) {\nthis.keyTypeAdapter =\nnew TypeAdapterRuntimeTypeWrapper<K>(context, keyTypeAdapter, keyType);\nthis.valueTypeAdapter =\nnew TypeAdapterRuntimeTypeWrapper<V>(context, valueTypeAdapter, valueType);\nthis.constructor = constructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter:read(Lcom/google/gson/stream/JsonReader;)Ljava/util/Map;",
                                    "method_body": "@Override public Map<K, V> read(JsonReader in) throws IOException {\nJsonToken peek = in.peek();\nif (peek == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\n\nMap<K, V> map = constructor.construct();\n\nif (peek == JsonToken.BEGIN_ARRAY) {\nin.beginArray();\nwhile (in.hasNext()) {\nin.beginArray(); // entry array\nK key = keyTypeAdapter.read(in);\nV value = valueTypeAdapter.read(in);\nV replaced = map.put(key, value);\nif (replaced != null) {\nthrow new JsonSyntaxException(\"duplicate key: \" + key);\n}\nin.endArray();\n}\nin.endArray();\n} else {\nin.beginObject();\nwhile (in.hasNext()) {\nJsonReaderInternalAccess.INSTANCE.promoteNameToValue(in);\nK key = keyTypeAdapter.read(in);\nV value = valueTypeAdapter.read(in);\nV replaced = map.put(key, value);\nif (replaced != null) {\nthrow new JsonSyntaxException(\"duplicate key: \" + key);\n}\n}\nin.endObject();\n}\nreturn map;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor$12:construct()Ljava/lang/Object;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nfinal Type type, Class<? super T> rawType) {\nif (Collection.class.isAssignableFrom(rawType)) {\nif (SortedSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeSet<Object>();\n}\n};\n} else if (EnumSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"rawtypes\")\n@Override public T construct() {\nif (type instanceof ParameterizedType) {\nType elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\nif (elementType instanceof Class) {\nreturn (T) EnumSet.noneOf((Class)elementType);\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n}\n};\n} else if (Set.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashSet<Object>();\n}\n};\n} else if (Queue.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedList<Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ArrayList<Object>();\n}\n};\n}\n}\n\nif (Map.class.isAssignableFrom(rawType)) {\nif (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ConcurrentSkipListMap<Object, Object>();\n}\n};\n} else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ConcurrentHashMap<Object, Object>();\n}\n};\n} else if (SortedMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeMap<Object, Object>();\n}\n};\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nTypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashMap<Object, Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedTreeMap<String, Object>();\n}\n};\n}\n}\n\nreturn null;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 8,
                    "tests": [
                        {
                            "test_name": "com.google.gson.internal.UnsafeAllocatorInstantiationTest.testAbstractClassInstantiation",
                            "test_body": "53: public void testAbstractClassInstantiation() {\n54: UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();\n55: try {\n56: unsafeAllocator.newInstance(AbstractClass.class);\n57: fail();\n58: } catch (Exception e) {\n59: assertEquals(e.getClass(), UnsupportedOperationException.class);\n60: }\n61: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.internal.UnsafeAllocator:create()Lcom/google/gson/internal/UnsafeAllocator;",
                                    "method_body": "public abstract <T> T newInstance(Class<T> c) throws Exception;\n\npublic static UnsafeAllocator create() {\n// try JVM\n// public class Unsafe {\n//   public Object allocateInstance(Class<?> type);\n// }\ntry {\nClass<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\nField f = unsafeClass.getDeclaredField(\"theUnsafe\");\nf.setAccessible(true);\nfinal Object unsafe = f.get(null);\nfinal Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nreturn (T) allocateInstance.invoke(unsafe, c);\n}\n};\n} catch (Exception ignored) {\n}\n\n// try dalvikvm, post-gingerbread\n// public class ObjectStreamClass {\n//   private static native int getConstructorId(Class<?> c);\n//   private static native Object newInstance(Class<?> instantiationClass, int methodId);\n// }\ntry {\nMethod getConstructorId = ObjectStreamClass.class\n.getDeclaredMethod(\"getConstructorId\", Class.class);\ngetConstructorId.setAccessible(true);\nfinal int constructorId = (Integer) getConstructorId.invoke(null, Object.class);\nfinal Method newInstance = ObjectStreamClass.class\n.getDeclaredMethod(\"newInstance\", Class.class, int.class);\nnewInstance.setAccessible(true);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nreturn (T) newInstance.invoke(null, c, constructorId);\n}\n};\n} catch (Exception ignored) {\n}\n\n// try dalvikvm, pre-gingerbread\n// public class ObjectInputStream {\n//   private static native Object newInstance(\n//     Class<?> instantiationClass, Class<?> constructorClass);\n// }\ntry {\nfinal Method newInstance = ObjectInputStream.class\n.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\nnewInstance.setAccessible(true);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nreturn (T) newInstance.invoke(null, c, Object.class);\n}\n};\n} catch (Exception ignored) {\n}\n\n// give up\nreturn new UnsafeAllocator() {\n@Override\npublic <T> T newInstance(Class<T> c) {\nthrow new UnsupportedOperationException(\"Cannot allocate \" + c);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.UnsafeAllocator$1:newInstance(Ljava/lang/Class;)Ljava/lang/Object;",
                                    "method_body": "public abstract <T> T newInstance(Class<T> c) throws Exception;\n\npublic static UnsafeAllocator create() {\n// try JVM\n// public class Unsafe {\n//   public Object allocateInstance(Class<?> type);\n// }\ntry {\nClass<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\nField f = unsafeClass.getDeclaredField(\"theUnsafe\");\nf.setAccessible(true);\nfinal Object unsafe = f.get(null);\nfinal Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nreturn (T) allocateInstance.invoke(unsafe, c);\n}\n};\n} catch (Exception ignored) {\n}\n\n// try dalvikvm, post-gingerbread\n// public class ObjectStreamClass {\n//   private static native int getConstructorId(Class<?> c);\n//   private static native Object newInstance(Class<?> instantiationClass, int methodId);\n// }\ntry {\nMethod getConstructorId = ObjectStreamClass.class\n.getDeclaredMethod(\"getConstructorId\", Class.class);\ngetConstructorId.setAccessible(true);\nfinal int constructorId = (Integer) getConstructorId.invoke(null, Object.class);\nfinal Method newInstance = ObjectStreamClass.class\n.getDeclaredMethod(\"newInstance\", Class.class, int.class);\nnewInstance.setAccessible(true);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nreturn (T) newInstance.invoke(null, c, constructorId);\n}\n};\n} catch (Exception ignored) {\n}\n\n// try dalvikvm, pre-gingerbread\n// public class ObjectInputStream {\n//   private static native Object newInstance(\n//     Class<?> instantiationClass, Class<?> constructorClass);\n// }\ntry {\nfinal Method newInstance = ObjectInputStream.class\n.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\nnewInstance.setAccessible(true);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nreturn (T) newInstance.invoke(null, c, Object.class);\n}\n};\n} catch (Exception ignored) {\n}\n\n// give up\nreturn new UnsafeAllocator() {\n@Override\npublic <T> T newInstance(Class<T> c) {\nthrow new UnsupportedOperationException(\"Cannot allocate \" + c);\n}\n};\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.internal.UnsafeAllocatorInstantiationTest.testInterfaceInstantiation",
                            "test_body": "39: public void testInterfaceInstantiation() {\n40: UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();\n41: try {\n42: unsafeAllocator.newInstance(Interface.class);\n43: fail();\n44: } catch (Exception e) {\n45: assertEquals(e.getClass(), UnsupportedOperationException.class);\n46: }\n47: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.internal.UnsafeAllocator:create()Lcom/google/gson/internal/UnsafeAllocator;",
                                    "method_body": "public abstract <T> T newInstance(Class<T> c) throws Exception;\n\npublic static UnsafeAllocator create() {\n// try JVM\n// public class Unsafe {\n//   public Object allocateInstance(Class<?> type);\n// }\ntry {\nClass<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\nField f = unsafeClass.getDeclaredField(\"theUnsafe\");\nf.setAccessible(true);\nfinal Object unsafe = f.get(null);\nfinal Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nreturn (T) allocateInstance.invoke(unsafe, c);\n}\n};\n} catch (Exception ignored) {\n}\n\n// try dalvikvm, post-gingerbread\n// public class ObjectStreamClass {\n//   private static native int getConstructorId(Class<?> c);\n//   private static native Object newInstance(Class<?> instantiationClass, int methodId);\n// }\ntry {\nMethod getConstructorId = ObjectStreamClass.class\n.getDeclaredMethod(\"getConstructorId\", Class.class);\ngetConstructorId.setAccessible(true);\nfinal int constructorId = (Integer) getConstructorId.invoke(null, Object.class);\nfinal Method newInstance = ObjectStreamClass.class\n.getDeclaredMethod(\"newInstance\", Class.class, int.class);\nnewInstance.setAccessible(true);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nreturn (T) newInstance.invoke(null, c, constructorId);\n}\n};\n} catch (Exception ignored) {\n}\n\n// try dalvikvm, pre-gingerbread\n// public class ObjectInputStream {\n//   private static native Object newInstance(\n//     Class<?> instantiationClass, Class<?> constructorClass);\n// }\ntry {\nfinal Method newInstance = ObjectInputStream.class\n.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\nnewInstance.setAccessible(true);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nreturn (T) newInstance.invoke(null, c, Object.class);\n}\n};\n} catch (Exception ignored) {\n}\n\n// give up\nreturn new UnsafeAllocator() {\n@Override\npublic <T> T newInstance(Class<T> c) {\nthrow new UnsupportedOperationException(\"Cannot allocate \" + c);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.UnsafeAllocator$1:newInstance(Ljava/lang/Class;)Ljava/lang/Object;",
                                    "method_body": "public abstract <T> T newInstance(Class<T> c) throws Exception;\n\npublic static UnsafeAllocator create() {\n// try JVM\n// public class Unsafe {\n//   public Object allocateInstance(Class<?> type);\n// }\ntry {\nClass<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\nField f = unsafeClass.getDeclaredField(\"theUnsafe\");\nf.setAccessible(true);\nfinal Object unsafe = f.get(null);\nfinal Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nreturn (T) allocateInstance.invoke(unsafe, c);\n}\n};\n} catch (Exception ignored) {\n}\n\n// try dalvikvm, post-gingerbread\n// public class ObjectStreamClass {\n//   private static native int getConstructorId(Class<?> c);\n//   private static native Object newInstance(Class<?> instantiationClass, int methodId);\n// }\ntry {\nMethod getConstructorId = ObjectStreamClass.class\n.getDeclaredMethod(\"getConstructorId\", Class.class);\ngetConstructorId.setAccessible(true);\nfinal int constructorId = (Integer) getConstructorId.invoke(null, Object.class);\nfinal Method newInstance = ObjectStreamClass.class\n.getDeclaredMethod(\"newInstance\", Class.class, int.class);\nnewInstance.setAccessible(true);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nreturn (T) newInstance.invoke(null, c, constructorId);\n}\n};\n} catch (Exception ignored) {\n}\n\n// try dalvikvm, pre-gingerbread\n// public class ObjectInputStream {\n//   private static native Object newInstance(\n//     Class<?> instantiationClass, Class<?> constructorClass);\n// }\ntry {\nfinal Method newInstance = ObjectInputStream.class\n.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\nnewInstance.setAccessible(true);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nreturn (T) newInstance.invoke(null, c, Object.class);\n}\n};\n} catch (Exception ignored) {\n}\n\n// give up\nreturn new UnsafeAllocator() {\n@Override\npublic <T> T newInstance(Class<T> c) {\nthrow new UnsupportedOperationException(\"Cannot allocate \" + c);\n}\n};\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 10,
                    "tests": [
                        {
                            "test_name": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.testPrimitiveFieldAnnotationTakesPrecedenceOverDefault",
                            "test_body": "233: public void testPrimitiveFieldAnnotationTakesPrecedenceOverDefault() {\n234: Gson gson = new Gson();\n235: String json = gson.toJson(new GadgetWithPrimitivePart(42));\n236: assertEquals(\"{\\\"part\\\":\\\"42\\\"}\", json);\n237: GadgetWithPrimitivePart gadget = gson.fromJson(json, GadgetWithPrimitivePart.class);\n238: assertEquals(42, gadget.part);\n239: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\nCollections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\nDEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\nDEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\nLongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,\nfinal Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,\nboolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\nboolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,\nLongSerializationPolicy longSerializationPolicy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.excluder = excluder;\nthis.fieldNamingStrategy = fieldNamingStrategy;\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nthis.lenient = lenient;\n\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n\n// built-in type adapters that cannot be overridden\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\n\n// the excluder must precede all adapters that handle user-defined types\nfactories.add(excluder);\n\n// user's type adapters\nfactories.addAll(typeAdapterFactories);\n\n// type adapters for basic platform types\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nTypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\ndoubleAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfloatAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\nfactories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\nfactories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.CURRENCY_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\n\n// type adapters for composite and user-defined types\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nfactories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nconstructorConstructor, fieldNamingStrategy, excluder));\n\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<clinit>()V",
                                    "method_body": "static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\nstatic final boolean DEFAULT_LENIENT = false;\nstatic final boolean DEFAULT_PRETTY_PRINT = false;\nstatic final boolean DEFAULT_ESCAPE_HTML = true;\nstatic final boolean DEFAULT_SERIALIZE_NULLS = false;\nstatic final boolean DEFAULT_COMPLEX_MAP_KEYS = false;\nstatic final boolean DEFAULT_SPECIALIZE_FLOAT_VALUES = false;\n\nprivate static final TypeToken<?> NULL_KEY_SURROGATE = new TypeToken<Object>() {};"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.DOUBLE;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Double read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\ndouble doubleValue = value.doubleValue();\ncheckValidFloatingPoint(doubleValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.FLOAT;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Float read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn (float) in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nfloat floatValue = value.floatValue();\ncheckValidFloatingPoint(floatValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Number read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextLong();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nout.value(value.toString());\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLong>() {\n@Override public void write(JsonWriter out, AtomicLong value) throws IOException {\nlongAdapter.write(out, value.get());\n}\n@Override public AtomicLong read(JsonReader in) throws IOException {\nNumber value = longAdapter.read(in);\nreturn new AtomicLong(value.longValue());\n}\n}.nullSafe();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongArrayAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLongArray>() {\n@Override public void write(JsonWriter out, AtomicLongArray value) throws IOException {\nout.beginArray();\nfor (int i = 0, length = value.length(); i < length; i++) {\nlongAdapter.write(out, value.get(i));\n}\nout.endArray();\n}\n@Override public AtomicLongArray read(JsonReader in) throws IOException {\nList<Long> list = new ArrayList<Long>();\nin.beginArray();\nwhile (in.hasNext()) {\nlong value = longAdapter.read(in).longValue();\nlist.add(value);\n}\nin.endArray();\nint length = list.size();\nAtomicLongArray array = new AtomicLongArray(length);\nfor (int i = 0; i < length; ++i) {\narray.set(i, list.get(i));\n}\nreturn array;\n}\n}.nullSafe();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);\nif (cached != null) {\nreturn (TypeAdapter<T>) cached;\n}\n\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\n}\n\n// the key and value type parameters always agree\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nreturn ongoingCall;\n}\n\ntry {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\n\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\n}\n}\nthrow new IllegalArgumentException(\"GSON cannot handle \" + type);\n} finally {\nthreadCalls.remove(type);\n\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:toJson(Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public String toJson(Object src) {\nif (src == null) {\nreturn toJson(JsonNull.INSTANCE);\n}\nreturn toJson(src, src.getClass());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:toJson(Ljava/lang/Object;Ljava/lang/reflect/Type;)Ljava/lang/String;",
                                    "method_body": "public String toJson(Object src, Type typeOfSrc) {\nStringWriter writer = new StringWriter();\ntoJson(src, typeOfSrc, writer);\nreturn writer.toString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:toJson(Ljava/lang/Object;Ljava/lang/reflect/Type;Ljava/lang/Appendable;)V",
                                    "method_body": "public void toJson(Object src, Type typeOfSrc, Appendable writer) throws JsonIOException {\ntry {\nJsonWriter jsonWriter = newJsonWriter(Streams.writerForAppendable(writer));\ntoJson(src, typeOfSrc, jsonWriter);\n} catch (IOException e) {\nthrow new JsonIOException(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:toJson(Ljava/lang/Object;Ljava/lang/reflect/Type;Lcom/google/gson/stream/JsonWriter;)V",
                                    "method_body": "public void toJson(Object src, Type typeOfSrc, JsonWriter writer) throws JsonIOException {\nTypeAdapter<?> adapter = getAdapter(TypeToken.get(typeOfSrc));\nboolean oldLenient = writer.isLenient();\nwriter.setLenient(true);\nboolean oldHtmlSafe = writer.isHtmlSafe();\nwriter.setHtmlSafe(htmlSafe);\nboolean oldSerializeNulls = writer.getSerializeNulls();\nwriter.setSerializeNulls(serializeNulls);\ntry {\n((TypeAdapter<Object>) adapter).write(writer, src);\n} catch (IOException e) {\nthrow new JsonIOException(e);\n} finally {\nwriter.setLenient(oldLenient);\nwriter.setHtmlSafe(oldHtmlSafe);\nwriter.setSerializeNulls(oldSerializeNulls);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:newJsonWriter(Ljava/io/Writer;)Lcom/google/gson/stream/JsonWriter;",
                                    "method_body": "public JsonWriter newJsonWriter(Writer writer) throws IOException {\nif (generateNonExecutableJson) {\nwriter.write(JSON_NON_EXECUTABLE_PREFIX);\n}\nJsonWriter jsonWriter = new JsonWriter(writer);\nif (prettyPrinting) {\njsonWriter.setIndent(\"  \");\n}\njsonWriter.setSerializeNulls(serializeNulls);\nreturn jsonWriter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>()V",
                                    "method_body": "protected TypeToken() {\nthis.type = getSuperclassTypeParameter(getClass());\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(type);\nthis.hashCode = type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getSuperclassTypeParameter(Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getSuperclassTypeParameter(Class<?> subclass) {\nType superclass = subclass.getGenericSuperclass();\nif (superclass instanceof Class) {\nthrow new RuntimeException(\"Missing type parameter.\");\n}\nParameterizedType parameterized = (ParameterizedType) superclass;\nreturn $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/Class;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static <T> TypeToken<T> get(Class<T> type) {\nreturn new TypeToken<T>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\np.getRawType(), p.getActualTypeArguments());\n\n} else if (type instanceof GenericArrayType) {\nGenericArrayType g = (GenericArrayType) type;\nreturn new GenericArrayTypeImpl(g.getGenericComponentType());\n\n} else if (type instanceof WildcardType) {\nWildcardType w = (WildcardType) type;\nreturn new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n} else {\n// type is either serializable as-is or unsupported\nreturn type;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\n// type is a normal class.\nreturn (Class<?>) type;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType parameterizedType = (ParameterizedType) type;\n\n// I'm not exactly sure why getRawType() returns Type instead of Class.\n// Neal isn't either but suspects some pathological case related\n// to nested classes exists.\nType rawType = parameterizedType.getRawType();\ncheckArgument(rawType instanceof Class);\nreturn (Class<?>) rawType;\n\n} else if (type instanceof GenericArrayType) {\nType componentType = ((GenericArrayType)type).getGenericComponentType();\nreturn Array.newInstance(getRawType(componentType), 0).getClass();\n\n} else if (type instanceof TypeVariable) {\n// we could use the variable's bounds, but that won't work if there are multiple.\n// having a raw type that's more general than necessary is okay\nreturn Object.class;\n\n} else if (type instanceof WildcardType) {\nreturn getRawType(((WildcardType) type).getUpperBounds()[0]);\n\n} else {\nString className = type == null ? \"null\" : type.getClass().getName();\nthrow new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n+ \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\n// this implementation is made a little more complicated in an attempt to avoid object-creation\nwhile (true) {\nif (toResolve instanceof TypeVariable) {\nTypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\ntoResolve = resolveTypeVariable(context, contextRawType, typeVariable);\nif (toResolve == typeVariable) {\nreturn toResolve;\n}\n\n} else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\nClass<?> original = (Class<?>) toResolve;\nType componentType = original.getComponentType();\nType newComponentType = resolve(context, contextRawType, componentType);\nreturn componentType == newComponentType\n? original\n: arrayOf(newComponentType);\n\n} else if (toResolve instanceof GenericArrayType) {\nGenericArrayType original = (GenericArrayType) toResolve;\nType componentType = original.getGenericComponentType();\nType newComponentType = resolve(context, contextRawType, componentType);\nreturn componentType == newComponentType\n? original\n: arrayOf(newComponentType);\n\n} else if (toResolve instanceof ParameterizedType) {\nParameterizedType original = (ParameterizedType) toResolve;\nType ownerType = original.getOwnerType();\nType newOwnerType = resolve(context, contextRawType, ownerType);\nboolean changed = newOwnerType != ownerType;\n\nType[] args = original.getActualTypeArguments();\nfor (int t = 0, length = args.length; t < length; t++) {\nType resolvedTypeArgument = resolve(context, contextRawType, args[t]);\nif (resolvedTypeArgument != args[t]) {\nif (!changed) {\nargs = args.clone();\nchanged = true;\n}\nargs[t] = resolvedTypeArgument;\n}\n}\n\nreturn changed\n? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n: original;\n\n} else if (toResolve instanceof WildcardType) {\nWildcardType original = (WildcardType) toResolve;\nType[] originalLowerBound = original.getLowerBounds();\nType[] originalUpperBound = original.getUpperBounds();\n\nif (originalLowerBound.length == 1) {\nType lowerBound = resolve(context, contextRawType, originalLowerBound[0]);\nif (lowerBound != originalLowerBound[0]) {\nreturn supertypeOf(lowerBound);\n}\n} else if (originalUpperBound.length == 1) {\nType upperBound = resolve(context, contextRawType, originalUpperBound[0]);\nif (upperBound != originalUpperBound[0]) {\nreturn subtypeOf(upperBound);\n}\n}\nreturn original;\n\n} else {\nreturn toResolve;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\n\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate boolean requireExpose;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n\n@Override protected Excluder clone() {\ntry {\nreturn (Excluder) super.clone();\n} catch (CloneNotSupportedException e) {\nthrow new AssertionError(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\n\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}\n\nreturn new TypeAdapter<T>() {\n/** The delegate is lazily created because it may not be needed, and creating it may fail. */\nprivate TypeAdapter<T> delegate;\n\n@Override public T read(JsonReader in) throws IOException {\nif (skipDeserialize) {\nin.skipValue();\nreturn null;\n}\nreturn delegate().read(in);\n}\n\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (skipSerialize) {\nout.nullValue();\nreturn;\n}\ndelegate().write(out, value);\n}\n\nprivate TypeAdapter<T> delegate() {\nTypeAdapter<T> d = delegate;\nreturn d != null\n? d\n: (delegate = gson.getDelegateAdapter(Excluder.this, type));\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field field, boolean serialize) {\nif ((modifiers & field.getModifiers()) != 0) {\nreturn true;\n}\n\nif (version != Excluder.IGNORE_VERSIONS\n&& !isValidVersion(field.getAnnotation(Since.class), field.getAnnotation(Until.class))) {\nreturn true;\n}\n\nif (field.isSynthetic()) {\nreturn true;\n}\n\nif (requireExpose) {\nExpose annotation = field.getAnnotation(Expose.class);\nif (annotation == null || (serialize ? !annotation.serialize() : !annotation.deserialize())) {\nreturn true;\n}\n}\n\nif (!serializeInnerClasses && isInnerClass(field.getType())) {\nreturn true;\n}\n\nif (isAnonymousOrLocal(field.getType())) {\nreturn true;\n}\n\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nif (!list.isEmpty()) {\nFieldAttributes fieldAttributes = new FieldAttributes(field);\nfor (ExclusionStrategy exclusionStrategy : list) {\nif (exclusionStrategy.shouldSkipField(fieldAttributes)) {\nreturn true;\n}\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\n&& !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\nreturn true;\n}\n\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nreturn true;\n}\n\nif (isAnonymousOrLocal(clazz)) {\nreturn true;\n}\n\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nif (exclusionStrategy.shouldSkipClass(clazz)) {\nreturn true;\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n&& (clazz.isAnonymousClass() || clazz.isLocalClass());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.FieldNamingPolicy$1:translateName(Ljava/lang/reflect/Field;)Ljava/lang/String;",
                                    "method_body": "@Override public String translateName(Field f) {\nreturn f.getName();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\n\n// first try an instance creator\n\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn typeCreator.createInstance(type);\n}\n};\n}\n\n// Next try raw type match for instance creators\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> rawTypeCreator =\n(InstanceCreator<T>) instanceCreators.get(rawType);\nif (rawTypeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn rawTypeCreator.createInstance(type);\n}\n};\n}\n\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nreturn defaultConstructor;\n}\n\nObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\nif (defaultImplementation != null) {\nreturn defaultImplementation;\n}\n\n// finally try unsafe\nreturn newUnsafeAllocator(type, rawType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultConstructor(Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\ntry {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\n}\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"unchecked\") // T is the same raw type as is requested\n@Override public T construct() {\ntry {\nObject[] args = null;\nreturn (T) constructor.newInstance(args);\n} catch (InstantiationException e) {\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\", e);\n} catch (InvocationTargetException e) {\n// TODO: don't wrap if cause is unchecked!\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",\ne.getTargetException());\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\n}\n};\n} catch (NoSuchMethodException e) {\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultImplementationConstructor(Ljava/lang/reflect/Type;Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nfinal Type type, Class<? super T> rawType) {\nif (Collection.class.isAssignableFrom(rawType)) {\nif (SortedSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeSet<Object>();\n}\n};\n} else if (EnumSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"rawtypes\")\n@Override public T construct() {\nif (type instanceof ParameterizedType) {\nType elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\nif (elementType instanceof Class) {\nreturn (T) EnumSet.noneOf((Class)elementType);\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n}\n};\n} else if (Set.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashSet<Object>();\n}\n};\n} else if (Queue.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ArrayDeque<Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ArrayList<Object>();\n}\n};\n}\n}\n\nif (Map.class.isAssignableFrom(rawType)) {\nif (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ConcurrentSkipListMap<Object, Object>();\n}\n};\n} else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ConcurrentHashMap<Object, Object>();\n}\n};\n} else if (SortedMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeMap<Object, Object>();\n}\n};\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nTypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashMap<Object, Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedTreeMap<String, Object>();\n}\n};\n}\n}\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newUnsafeAllocator(Ljava/lang/reflect/Type;Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newUnsafeAllocator(\nfinal Type type, final Class<? super T> rawType) {\nreturn new ObjectConstructor<T>() {\nprivate final UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();\n@SuppressWarnings(\"unchecked\")\n@Override public T construct() {\ntry {\nObject newInstance = unsafeAllocator.newInstance(rawType);\nreturn (T) newInstance;\n} catch (Exception e) {\nthrow new RuntimeException((\"Unable to invoke no-args constructor for \" + type + \". \"\n+ \"Register an InstanceCreator with Gson for this type may fix this problem.\"), e);\n}\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n@Override\npublic void write(JsonWriter out, Class value) throws IOException {\nif (value == null) {\nout.nullValue();\n} else {\nthrow new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n+ value.getName() + \". Forgot to register a type adapter?\");\n}\n}\n@Override\npublic Class read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n} else {\nthrow new UnsupportedOperationException(\n\"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n}\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:nullSafe()Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public final TypeAdapter<T> nullSafe() {\nreturn new TypeAdapter<T>() {\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (value == null) {\nout.nullValue();\n} else {\nTypeAdapter.this.write(out, value);\n}\n}\n@Override public T read(JsonReader reader) throws IOException {\nif (reader.peek() == JsonToken.NULL) {\nreader.nextNull();\nreturn null;\n}\nreturn TypeAdapter.this.read(reader);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$12:write(Lcom/google/gson/stream/JsonWriter;Ljava/lang/Number;)V",
                                    "method_body": "public void write(JsonWriter out, Number value) throws IOException {\nout.value(value);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$35:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$26:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}\n\nfinal TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\nreturn (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n@Override public Timestamp read(JsonReader in) throws IOException {\nDate date = dateTypeAdapter.read(in);\nreturn date != null ? new Timestamp(date.getTime()) : null;\n}\n\n@Override public void write(JsonWriter out, Timestamp value) throws IOException {\ndateTypeAdapter.write(out, value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$34:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$30:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nif (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {\nreturn null;\n}\nif (!rawType.isEnum()) {\nrawType = rawType.getSuperclass(); // handle anonymous subclasses\n}\nreturn (TypeAdapter<T>) new EnumTypeAdapter(rawType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nType elementType = $Gson$Types.getCollectionElementType(type, rawType);\nTypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // create() doesn't define a type parameter\nTypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nClass<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\nType[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\nTypeAdapter<?> keyAdapter = getKeyAdapter(gson, keyAndValueTypes[0]);\nTypeAdapter<?> valueAdapter = gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n// we don't define a type parameter for the key or value types\nTypeAdapter<T> result = new Adapter(gson, keyAndValueTypes[0], keyAdapter,\nkeyAndValueTypes[1], valueAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\nJsonAdapter annotation = targetType.getRawType().getAnnotation(JsonAdapter.class);\nif (annotation == null) {\nreturn null;\n}\nreturn (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:getTypeAdapter(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;Lcom/google/gson/annotations/JsonAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\nTypeToken<?> fieldType, JsonAdapter annotation) {\nClass<?> value = annotation.value();\nTypeAdapter<?> typeAdapter;\nif (TypeAdapter.class.isAssignableFrom(value)) {\nClass<TypeAdapter<?>> typeAdapterClass = (Class<TypeAdapter<?>>) value;\ntypeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();\n} else if (TypeAdapterFactory.class.isAssignableFrom(value)) {\nClass<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;\ntypeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterFactory))\n.construct()\n.create(gson, fieldType);\n} else {\nthrow new IllegalArgumentException(\n\"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\");\n}\nif (typeAdapter != null) {\ntypeAdapter = typeAdapter.nullSafe();\n}\nreturn typeAdapter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nFieldNamingStrategy fieldNamingPolicy, Excluder excluder) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field f, boolean serialize) {\nreturn excludeField(f, serialize, excluder);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;ZLcom/google/gson/internal/Excluder;)Z",
                                    "method_body": "static boolean excludeField(Field f, boolean serialize, Excluder excluder) {\nreturn !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getFieldNames(Ljava/lang/reflect/Field;)Ljava/util/List;",
                                    "method_body": "private List<String> getFieldNames(Field f) {\nSerializedName annotation = f.getAnnotation(SerializedName.class);\nif (annotation == null) {\nString name = fieldNamingPolicy.translateName(f);\nreturn Collections.singletonList(name);\n}\n\nString serializedName = annotation.value();\nString[] alternates = annotation.alternate();\nif (alternates.length == 0) {\nreturn Collections.singletonList(serializedName);\n}\n\nList<String> fieldNames = new ArrayList<String>(alternates.length + 1);\nfieldNames.add(serializedName);\nfor (String alternate : alternates) {\nfieldNames.add(alternate);\n}\nreturn fieldNames;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\nClass<? super T> raw = type.getRawType();\n\nif (!Object.class.isAssignableFrom(raw)) {\nreturn null; // it's a primitive!\n}\n\nObjectConstructor<T> constructor = constructorConstructor.get(type);\nreturn new Adapter<T>(constructor, getBoundFields(gson, type, raw));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:createBoundField(Lcom/google/gson/Gson;Ljava/lang/reflect/Field;Ljava/lang/String;Lcom/google/gson/reflect/TypeToken;ZZ)Lcom/google/gson/internal/bind/ReflectiveTypeAdapterFactory$BoundField;",
                                    "method_body": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(\nfinal Gson context, final Field field, final String name,\nfinal TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\nfinal boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n// special casing primitives here saves ~5% on Android...\nJsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\nTypeAdapter<?> mapped = null;\nif (annotation != null) {\nmapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n}\nfinal boolean jsonAdapterPresent = mapped != null;\nif (mapped == null) mapped = context.getAdapter(fieldType);\n\nfinal TypeAdapter<?> typeAdapter = mapped;\nreturn new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n@Override void write(JsonWriter writer, Object value)\nthrows IOException, IllegalAccessException {\nObject fieldValue = field.get(value);\nTypeAdapter t =\nnew TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\nt.write(writer, fieldValue);\n}\n@Override void read(JsonReader reader, Object value)\nthrows IOException, IllegalAccessException {\nObject fieldValue = typeAdapter.read(reader);\nif (fieldValue != null || !isPrimitive) {\nfield.set(value, fieldValue);\n}\n}\n@Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\nif (!serialized) return false;\nObject fieldValue = field.get(value);\nreturn fieldValue != value; // avoid recursion for example for Throwable.cause\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getBoundFields(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;Ljava/lang/Class;)Ljava/util/Map;",
                                    "method_body": "private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {\nMap<String, BoundField> result = new LinkedHashMap<String, BoundField>();\nif (raw.isInterface()) {\nreturn result;\n}\n\nType declaredType = type.getType();\nwhile (raw != Object.class) {\nField[] fields = raw.getDeclaredFields();\nfor (Field field : fields) {\nboolean serialize = excludeField(field, true);\nboolean deserialize = excludeField(field, false);\nif (!serialize && !deserialize) {\ncontinue;\n}\nfield.setAccessible(true);\nType fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\nList<String> fieldNames = getFieldNames(field);\nBoundField previous = null;\nfor (int i = 0; i < fieldNames.size(); ++i) {\nString name = fieldNames.get(i);\nif (i != 0) serialize = false; // only serialize the default name\nBoundField boundField = createBoundField(context, field, name,\nTypeToken.get(fieldType), serialize, deserialize);\nBoundField replaced = result.put(name, boundField);\nif (previous == null) previous = replaced;\n}\nif (previous != null) {\nthrow new IllegalArgumentException(declaredType\n+ \" declares multiple JSON fields named \" + previous.name);\n}\n}\ntype = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\nraw = type.getRawType();\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Streams:writerForAppendable(Ljava/lang/Appendable;)Ljava/io/Writer;",
                                    "method_body": "public static Writer writerForAppendable(Appendable appendable) {\nreturn appendable instanceof Writer ? (Writer) appendable : new AppendableWriter(appendable);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nthrow new NullPointerException();\n}\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:<init>(Ljava/io/Writer;)V",
                                    "method_body": "public JsonWriter(Writer out) {\nif (out == null) {\nthrow new NullPointerException(\"out == null\");\n}\nthis.out = out;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:<clinit>()V",
                                    "method_body": "private static final String[] REPLACEMENT_CHARS;\nprivate static final String[] HTML_SAFE_REPLACEMENT_CHARS;\nstatic {\nREPLACEMENT_CHARS = new String[128];\nfor (int i = 0; i <= 0x1f; i++) {\nREPLACEMENT_CHARS[i] = String.format(\"\\\\u%04x\", (int) i);\n}\nREPLACEMENT_CHARS['\"'] = \"\\\\\\\"\";\nREPLACEMENT_CHARS['\\\\'] = \"\\\\\\\\\";\nREPLACEMENT_CHARS['\\t'] = \"\\\\t\";\nREPLACEMENT_CHARS['\\b'] = \"\\\\b\";\nREPLACEMENT_CHARS['\\n'] = \"\\\\n\";\nREPLACEMENT_CHARS['\\r'] = \"\\\\r\";\nREPLACEMENT_CHARS['\\f'] = \"\\\\f\";\nHTML_SAFE_REPLACEMENT_CHARS = REPLACEMENT_CHARS.clone();\nHTML_SAFE_REPLACEMENT_CHARS['<'] = \"\\\\u003c\";\nHTML_SAFE_REPLACEMENT_CHARS['>'] = \"\\\\u003e\";\nHTML_SAFE_REPLACEMENT_CHARS['&'] = \"\\\\u0026\";\nHTML_SAFE_REPLACEMENT_CHARS['='] = \"\\\\u003d\";\nHTML_SAFE_REPLACEMENT_CHARS['\\''] = \"\\\\u0027\";\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:setLenient(Z)V",
                                    "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:isLenient()Z",
                                    "method_body": "public boolean isLenient() {\nreturn lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:setHtmlSafe(Z)V",
                                    "method_body": "public final void setHtmlSafe(boolean htmlSafe) {\nthis.htmlSafe = htmlSafe;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:isHtmlSafe()Z",
                                    "method_body": "public final boolean isHtmlSafe() {\nreturn htmlSafe;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:setSerializeNulls(Z)V",
                                    "method_body": "public final void setSerializeNulls(boolean serializeNulls) {\nthis.serializeNulls = serializeNulls;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:getSerializeNulls()Z",
                                    "method_body": "public final boolean getSerializeNulls() {\nreturn serializeNulls;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:beginObject()Lcom/google/gson/stream/JsonWriter;",
                                    "method_body": "public JsonWriter beginObject() throws IOException {\nwriteDeferredName();\nreturn open(EMPTY_OBJECT, \"{\");\n}\n\n/**\n* Ends encoding the current object.\n*\n* @return this writer.\n*/\npublic JsonWriter endObject() throws IOException {\nreturn close(EMPTY_OBJECT, NONEMPTY_OBJECT, \"}\");\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:endObject()Lcom/google/gson/stream/JsonWriter;",
                                    "method_body": "public JsonWriter beginObject() throws IOException {\nwriteDeferredName();\nreturn open(EMPTY_OBJECT, \"{\");\n}\n\n/**\n* Ends encoding the current object.\n*\n* @return this writer.\n*/\npublic JsonWriter endObject() throws IOException {\nreturn close(EMPTY_OBJECT, NONEMPTY_OBJECT, \"}\");\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:open(ILjava/lang/String;)Lcom/google/gson/stream/JsonWriter;",
                                    "method_body": "private JsonWriter open(int empty, String openBracket) throws IOException {\nbeforeValue();\npush(empty);\nout.write(openBracket);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:close(IILjava/lang/String;)Lcom/google/gson/stream/JsonWriter;",
                                    "method_body": "private JsonWriter close(int empty, int nonempty, String closeBracket)\nthrows IOException {\nint context = peek();\nif (context != nonempty && context != empty) {\nthrow new IllegalStateException(\"Nesting problem.\");\n}\nif (deferredName != null) {\nthrow new IllegalStateException(\"Dangling name: \" + deferredName);\n}\n\nstackSize--;\nif (context == nonempty) {\nnewline();\n}\nout.write(closeBracket);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:push(I)V",
                                    "method_body": "private void push(int newTop) {\nif (stackSize == stack.length) {\nint[] newStack = new int[stackSize * 2];\nSystem.arraycopy(stack, 0, newStack, 0, stackSize);\nstack = newStack;\n}\nstack[stackSize++] = newTop;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:peek()I",
                                    "method_body": "private int peek() {\nif (stackSize == 0) {\nthrow new IllegalStateException(\"JsonWriter is closed.\");\n}\nreturn stack[stackSize - 1];\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:replaceTop(I)V",
                                    "method_body": "private void replaceTop(int topOfStack) {\nstack[stackSize - 1] = topOfStack;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:name(Ljava/lang/String;)Lcom/google/gson/stream/JsonWriter;",
                                    "method_body": "public JsonWriter name(String name) throws IOException {\nif (name == null) {\nthrow new NullPointerException(\"name == null\");\n}\nif (deferredName != null) {\nthrow new IllegalStateException();\n}\nif (stackSize == 0) {\nthrow new IllegalStateException(\"JsonWriter is closed.\");\n}\ndeferredName = name;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:writeDeferredName()V",
                                    "method_body": "private void writeDeferredName() throws IOException {\nif (deferredName != null) {\nbeforeName();\nstring(deferredName);\ndeferredName = null;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:value(Ljava/lang/Number;)Lcom/google/gson/stream/JsonWriter;",
                                    "method_body": "public JsonWriter value(Number value) throws IOException {\nif (value == null) {\nreturn nullValue();\n}\n\nwriteDeferredName();\nString string = value.toString();\nif (!lenient\n&& (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\nthrow new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n}\nbeforeValue();\nout.append(string);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:string(Ljava/lang/String;)V",
                                    "method_body": "private void string(String value) throws IOException {\nString[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;\nout.write(\"\\\"\");\nint last = 0;\nint length = value.length();\nfor (int i = 0; i < length; i++) {\nchar c = value.charAt(i);\nString replacement;\nif (c < 128) {\nreplacement = replacements[c];\nif (replacement == null) {\ncontinue;\n}\n} else if (c == '\\u2028') {\nreplacement = \"\\\\u2028\";\n} else if (c == '\\u2029') {\nreplacement = \"\\\\u2029\";\n} else {\ncontinue;\n}\nif (last < i) {\nout.write(value, last, i - last);\n}\nout.write(replacement);\nlast = i + 1;\n}\nif (last < length) {\nout.write(value, last, length - last);\n}\nout.write(\"\\\"\");\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:newline()V",
                                    "method_body": "private void newline() throws IOException {\nif (indent == null) {\nreturn;\n}\n\nout.write(\"\\n\");\nfor (int i = 1, size = stackSize; i < size; i++) {\nout.write(indent);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:beforeName()V",
                                    "method_body": "private void beforeName() throws IOException {\nint context = peek();\nif (context == NONEMPTY_OBJECT) { // first in object\nout.write(',');\n} else if (context != EMPTY_OBJECT) { // not in an object!\nthrow new IllegalStateException(\"Nesting problem.\");\n}\nnewline();\nreplaceTop(DANGLING_NAME);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:beforeValue()V",
                                    "method_body": "private void beforeValue() throws IOException {\nswitch (peek()) {\ncase NONEMPTY_DOCUMENT:\nif (!lenient) {\nthrow new IllegalStateException(\n\"JSON must have only one top-level value.\");\n}\n// fall-through\ncase EMPTY_DOCUMENT: // first in document\nreplaceTop(NONEMPTY_DOCUMENT);\nbreak;\n\ncase EMPTY_ARRAY: // first in array\nreplaceTop(NONEMPTY_ARRAY);\nnewline();\nbreak;\n\ncase NONEMPTY_ARRAY: // another in array\nout.append(',');\nnewline();\nbreak;\n\ncase DANGLING_NAME: // value for name\nout.append(separator);\nreplaceTop(NONEMPTY_OBJECT);\nbreak;\n\ndefault:\nthrow new IllegalStateException(\"Nesting problem.\");\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson$FutureTypeAdapter:setDelegate(Lcom/google/gson/TypeAdapter;)V",
                                    "method_body": "public void setDelegate(TypeAdapter<T> typeAdapter) {\nif (delegate != null) {\nthrow new AssertionError();\n}\ndelegate = typeAdapter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor$3:construct()Ljava/lang/Object;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\ntry {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\n}\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"unchecked\") // T is the same raw type as is requested\n@Override public T construct() {\ntry {\nObject[] args = null;\nreturn (T) constructor.newInstance(args);\n} catch (InstantiationException e) {\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\", e);\n} catch (InvocationTargetException e) {\n// TODO: don't wrap if cause is unchecked!\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",\ne.getTargetException());\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\n}\n};\n} catch (NoSuchMethodException e) {\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter:<init>(Lcom/google/gson/internal/ObjectConstructor;Ljava/util/Map;)V",
                                    "method_body": "abstract boolean writeField(Object value) throws IOException, IllegalAccessException;\nabstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException;\nabstract void read(JsonReader reader, Object value) throws IOException, IllegalAccessException;\n}\n\npublic static final class Adapter<T> extends TypeAdapter<T> {\nprivate final ObjectConstructor<T> constructor;\nprivate final Map<String, BoundField> boundFields;\n\nAdapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {\nthis.constructor = constructor;\nthis.boundFields = boundFields;\n}\n\n@Override public T read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\n\nT instance = constructor.construct();\n\ntry {\nin.beginObject();\nwhile (in.hasNext()) {\nString name = in.nextName();\nBoundField field = boundFields.get(name);\nif (field == null || !field.deserialized) {\nin.skipValue();\n} else {\nfield.read(in, instance);\n}\n}\n} catch (IllegalStateException e) {\nthrow new JsonSyntaxException(e);\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\nin.endObject();\nreturn instance;\n}\n\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\n\nout.beginObject();\ntry {\nfor (BoundField boundField : boundFields.values()) {\nif (boundField.writeField(value)) {\nout.name(boundField.name);\nboundField.write(out, value);\n}\n}\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\nout.endObject();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter:write(Lcom/google/gson/stream/JsonWriter;Ljava/lang/Object;)V",
                                    "method_body": "abstract boolean writeField(Object value) throws IOException, IllegalAccessException;\nabstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException;\nabstract void read(JsonReader reader, Object value) throws IOException, IllegalAccessException;\n}\n\npublic static final class Adapter<T> extends TypeAdapter<T> {\nprivate final ObjectConstructor<T> constructor;\nprivate final Map<String, BoundField> boundFields;\n\nAdapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {\nthis.constructor = constructor;\nthis.boundFields = boundFields;\n}\n\n@Override public T read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\n\nT instance = constructor.construct();\n\ntry {\nin.beginObject();\nwhile (in.hasNext()) {\nString name = in.nextName();\nBoundField field = boundFields.get(name);\nif (field == null || !field.deserialized) {\nin.skipValue();\n} else {\nfield.read(in, instance);\n}\n}\n} catch (IllegalStateException e) {\nthrow new JsonSyntaxException(e);\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\nin.endObject();\nreturn instance;\n}\n\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\n\nout.beginObject();\ntry {\nfor (BoundField boundField : boundFields.values()) {\nif (boundField.writeField(value)) {\nout.name(boundField.name);\nboundField.write(out, value);\n}\n}\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\nout.endObject();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:<clinit>()V",
                                    "method_body": "private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;\n\n/** A map from wrapper types to their corresponding primitive types. */\nprivate static final Map<Class<?>, Class<?>> WRAPPER_TO_PRIMITIVE_TYPE;\n\n// Sad that we can't use a BiMap. :(\n\nstatic {\nMap<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);\nMap<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);\n\nadd(primToWrap, wrapToPrim, boolean.class, Boolean.class);\nadd(primToWrap, wrapToPrim, byte.class, Byte.class);\nadd(primToWrap, wrapToPrim, char.class, Character.class);\nadd(primToWrap, wrapToPrim, double.class, Double.class);\nadd(primToWrap, wrapToPrim, float.class, Float.class);\nadd(primToWrap, wrapToPrim, int.class, Integer.class);\nadd(primToWrap, wrapToPrim, long.class, Long.class);\nadd(primToWrap, wrapToPrim, short.class, Short.class);\nadd(primToWrap, wrapToPrim, void.class, Void.class);\n\nPRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);\nWRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:add(Ljava/util/Map;Ljava/util/Map;Ljava/lang/Class;Ljava/lang/Class;)V",
                                    "method_body": "private static void add(Map<Class<?>, Class<?>> forward,\nMap<Class<?>, Class<?>> backward, Class<?> key, Class<?> value) {\nforward.put(key, value);\nbackward.put(value, key);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:isPrimitive(Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public static boolean isPrimitive(Type type) {\nreturn PRIMITIVE_TO_WRAPPER_TYPE.containsKey(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$BoundField:<init>(Ljava/lang/String;ZZ)V",
                                    "method_body": "protected BoundField(String name, boolean serialized, boolean deserialized) {\nthis.name = name;\nthis.serialized = serialized;\nthis.deserialized = deserialized;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$1:write(Lcom/google/gson/stream/JsonWriter;Ljava/lang/Object;)V",
                                    "method_body": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(\nfinal Gson context, final Field field, final String name,\nfinal TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\nfinal boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n// special casing primitives here saves ~5% on Android...\nJsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\nTypeAdapter<?> mapped = null;\nif (annotation != null) {\nmapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n}\nfinal boolean jsonAdapterPresent = mapped != null;\nif (mapped == null) mapped = context.getAdapter(fieldType);\n\nfinal TypeAdapter<?> typeAdapter = mapped;\nreturn new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n@Override void write(JsonWriter writer, Object value)\nthrows IOException, IllegalAccessException {\nObject fieldValue = field.get(value);\nTypeAdapter t =\nnew TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\nt.write(writer, fieldValue);\n}\n@Override void read(JsonReader reader, Object value)\nthrows IOException, IllegalAccessException {\nObject fieldValue = typeAdapter.read(reader);\nif (fieldValue != null || !isPrimitive) {\nfield.set(value, fieldValue);\n}\n}\n@Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\nif (!serialized) return false;\nObject fieldValue = field.get(value);\nreturn fieldValue != value; // avoid recursion for example for Throwable.cause\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$1:writeField(Ljava/lang/Object;)Z",
                                    "method_body": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(\nfinal Gson context, final Field field, final String name,\nfinal TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\nfinal boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n// special casing primitives here saves ~5% on Android...\nJsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\nTypeAdapter<?> mapped = null;\nif (annotation != null) {\nmapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n}\nfinal boolean jsonAdapterPresent = mapped != null;\nif (mapped == null) mapped = context.getAdapter(fieldType);\n\nfinal TypeAdapter<?> typeAdapter = mapped;\nreturn new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n@Override void write(JsonWriter writer, Object value)\nthrows IOException, IllegalAccessException {\nObject fieldValue = field.get(value);\nTypeAdapter t =\nnew TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\nt.write(writer, fieldValue);\n}\n@Override void read(JsonReader reader, Object value)\nthrows IOException, IllegalAccessException {\nObject fieldValue = typeAdapter.read(reader);\nif (fieldValue != null || !isPrimitive) {\nfield.set(value, fieldValue);\n}\n}\n@Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\nif (!serialized) return false;\nObject fieldValue = field.get(value);\nreturn fieldValue != value; // avoid recursion for example for Throwable.cause\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:<init>(Lcom/google/gson/Gson;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeAdapterRuntimeTypeWrapper(Gson context, TypeAdapter<T> delegate, Type type) {\nthis.context = context;\nthis.delegate = delegate;\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:write(Lcom/google/gson/stream/JsonWriter;Ljava/lang/Object;)V",
                                    "method_body": "public void write(JsonWriter out, T value) throws IOException {\n// Order of preference for choosing type adapters\n// First preference: a type adapter registered for the runtime type\n// Second preference: a type adapter registered for the declared type\n// Third preference: reflective type adapter for the runtime type (if it is a sub class of the declared type)\n// Fourth preference: reflective type adapter for the declared type\n\nTypeAdapter chosen = delegate;\nType runtimeType = getRuntimeTypeIfMoreSpecific(type, value);\nif (runtimeType != type) {\nTypeAdapter runtimeTypeAdapter = context.getAdapter(TypeToken.get(runtimeType));\nif (!(runtimeTypeAdapter instanceof ReflectiveTypeAdapterFactory.Adapter)) {\n// The user registered a type adapter for the runtime type, so we will use that\nchosen = runtimeTypeAdapter;\n} else if (!(delegate instanceof ReflectiveTypeAdapterFactory.Adapter)) {\n// The user registered a type adapter for Base class, so we prefer it over the\n// reflective type adapter for the runtime type\nchosen = delegate;\n} else {\n// Use the type adapter for runtime type\nchosen = runtimeTypeAdapter;\n}\n}\nchosen.write(out, value);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:getRuntimeTypeIfMoreSpecific(Ljava/lang/reflect/Type;Ljava/lang/Object;)Ljava/lang/reflect/Type;",
                                    "method_body": "private Type getRuntimeTypeIfMoreSpecific(Type type, Object value) {\nif (value != null\n&& (type == Object.class || type instanceof TypeVariable<?> || type instanceof Class<?>)) {\ntype = value.getClass();\n}\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.UnsafeAllocator:create()Lcom/google/gson/internal/UnsafeAllocator;",
                                    "method_body": "public abstract <T> T newInstance(Class<T> c) throws Exception;\n\npublic static UnsafeAllocator create() {\n// try JVM\n// public class Unsafe {\n//   public Object allocateInstance(Class<?> type);\n// }\ntry {\nClass<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\nField f = unsafeClass.getDeclaredField(\"theUnsafe\");\nf.setAccessible(true);\nfinal Object unsafe = f.get(null);\nfinal Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nassertInstantiable(c);\nreturn (T) allocateInstance.invoke(unsafe, c);\n}\n};\n} catch (Exception ignored) {\n}\n\n// try dalvikvm, post-gingerbread\n// public class ObjectStreamClass {\n//   private static native int getConstructorId(Class<?> c);\n//   private static native Object newInstance(Class<?> instantiationClass, int methodId);\n// }\ntry {\nMethod getConstructorId = ObjectStreamClass.class\n.getDeclaredMethod(\"getConstructorId\", Class.class);\ngetConstructorId.setAccessible(true);\nfinal int constructorId = (Integer) getConstructorId.invoke(null, Object.class);\nfinal Method newInstance = ObjectStreamClass.class\n.getDeclaredMethod(\"newInstance\", Class.class, int.class);\nnewInstance.setAccessible(true);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nassertInstantiable(c);\nreturn (T) newInstance.invoke(null, c, constructorId);\n}\n};\n} catch (Exception ignored) {\n}\n\n// try dalvikvm, pre-gingerbread\n// public class ObjectInputStream {\n//   private static native Object newInstance(\n//     Class<?> instantiationClass, Class<?> constructorClass);\n// }\ntry {\nfinal Method newInstance = ObjectInputStream.class\n.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\nnewInstance.setAccessible(true);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nassertInstantiable(c);\nreturn (T) newInstance.invoke(null, c, Object.class);\n}\n};\n} catch (Exception ignored) {\n}\n\n// give up\nreturn new UnsafeAllocator() {\n@Override\npublic <T> T newInstance(Class<T> c) {\nthrow new UnsupportedOperationException(\"Cannot allocate \" + c);\n}\n};\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 11,
                    "tests": [
                        {
                            "test_name": "com.google.gson.functional.PrimitiveTest.testNumberAsStringDeserialization",
                            "test_body": "161: public void testNumberAsStringDeserialization() {\n162: Number value = gson.fromJson(\"\\\"18\\\"\", Number.class);\n163: assertEquals(18, value.intValue());\n164: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\nCollections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\nDEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\nDEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\nLongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,\nfinal Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,\nboolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\nboolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,\nLongSerializationPolicy longSerializationPolicy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.excluder = excluder;\nthis.fieldNamingStrategy = fieldNamingStrategy;\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nthis.lenient = lenient;\n\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n\n// built-in type adapters that cannot be overridden\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\n\n// the excluder must precede all adapters that handle user-defined types\nfactories.add(excluder);\n\n// user's type adapters\nfactories.addAll(typeAdapterFactories);\n\n// type adapters for basic platform types\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nTypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\ndoubleAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfloatAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\nfactories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\nfactories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.CURRENCY_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\n\n// type adapters for composite and user-defined types\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nthis.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);\nfactories.add(jsonAdapterFactory);\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nconstructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory));\n\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<clinit>()V",
                                    "method_body": "static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\nstatic final boolean DEFAULT_LENIENT = false;\nstatic final boolean DEFAULT_PRETTY_PRINT = false;\nstatic final boolean DEFAULT_ESCAPE_HTML = true;\nstatic final boolean DEFAULT_SERIALIZE_NULLS = false;\nstatic final boolean DEFAULT_COMPLEX_MAP_KEYS = false;\nstatic final boolean DEFAULT_SPECIALIZE_FLOAT_VALUES = false;\n\nprivate static final TypeToken<?> NULL_KEY_SURROGATE = new TypeToken<Object>() {};"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.DOUBLE;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Double read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\ndouble doubleValue = value.doubleValue();\ncheckValidFloatingPoint(doubleValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.FLOAT;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Float read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn (float) in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nfloat floatValue = value.floatValue();\ncheckValidFloatingPoint(floatValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Number read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextLong();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nout.value(value.toString());\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLong>() {\n@Override public void write(JsonWriter out, AtomicLong value) throws IOException {\nlongAdapter.write(out, value.get());\n}\n@Override public AtomicLong read(JsonReader in) throws IOException {\nNumber value = longAdapter.read(in);\nreturn new AtomicLong(value.longValue());\n}\n}.nullSafe();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongArrayAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLongArray>() {\n@Override public void write(JsonWriter out, AtomicLongArray value) throws IOException {\nout.beginArray();\nfor (int i = 0, length = value.length(); i < length; i++) {\nlongAdapter.write(out, value.get(i));\n}\nout.endArray();\n}\n@Override public AtomicLongArray read(JsonReader in) throws IOException {\nList<Long> list = new ArrayList<Long>();\nin.beginArray();\nwhile (in.hasNext()) {\nlong value = longAdapter.read(in).longValue();\nlist.add(value);\n}\nin.endArray();\nint length = list.size();\nAtomicLongArray array = new AtomicLongArray(length);\nfor (int i = 0; i < length; ++i) {\narray.set(i, list.get(i));\n}\nreturn array;\n}\n}.nullSafe();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);\nif (cached != null) {\nreturn (TypeAdapter<T>) cached;\n}\n\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\n}\n\n// the key and value type parameters always agree\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nreturn ongoingCall;\n}\n\ntry {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\n\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\n}\n}\nthrow new IllegalArgumentException(\"GSON cannot handle \" + type);\n} finally {\nthreadCalls.remove(type);\n\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:newJsonReader(Ljava/io/Reader;)Lcom/google/gson/stream/JsonReader;",
                                    "method_body": "public JsonReader newJsonReader(Reader reader) {\nJsonReader jsonReader = new JsonReader(reader);\njsonReader.setLenient(lenient);\nreturn jsonReader;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException {\nObject object = fromJson(json, (Type) classOfT);\nreturn Primitives.wrap(classOfT).cast(object);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {\nif (json == null) {\nreturn null;\n}\nStringReader reader = new StringReader(json);\nT target = (T) fromJson(reader, typeOfT);\nreturn target;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/io/Reader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nJsonReader jsonReader = newJsonReader(json);\nT object = (T) fromJson(jsonReader, typeOfT);\nassertFullConsumption(object, jsonReader);\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Lcom/google/gson/stream/JsonReader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nboolean isEmpty = true;\nboolean oldLenient = reader.isLenient();\nreader.setLenient(true);\ntry {\nreader.peek();\nisEmpty = false;\nTypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\nTypeAdapter<T> typeAdapter = getAdapter(typeToken);\nT object = typeAdapter.read(reader);\nreturn object;\n} catch (EOFException e) {\n/*\n* For compatibility with JSON 1.5 and earlier, we return null for empty\n* documents instead of throwing.\n*/\nif (isEmpty) {\nreturn null;\n}\nthrow new JsonSyntaxException(e);\n} catch (IllegalStateException e) {\nthrow new JsonSyntaxException(e);\n} catch (IOException e) {\n// TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException\nthrow new JsonSyntaxException(e);\n} finally {\nreader.setLenient(oldLenient);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>()V",
                                    "method_body": "protected TypeToken() {\nthis.type = getSuperclassTypeParameter(getClass());\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(type);\nthis.hashCode = type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getSuperclassTypeParameter(Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getSuperclassTypeParameter(Class<?> subclass) {\nType superclass = subclass.getGenericSuperclass();\nif (superclass instanceof Class) {\nthrow new RuntimeException(\"Missing type parameter.\");\n}\nParameterizedType parameterized = (ParameterizedType) superclass;\nreturn $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\np.getRawType(), p.getActualTypeArguments());\n\n} else if (type instanceof GenericArrayType) {\nGenericArrayType g = (GenericArrayType) type;\nreturn new GenericArrayTypeImpl(g.getGenericComponentType());\n\n} else if (type instanceof WildcardType) {\nWildcardType w = (WildcardType) type;\nreturn new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n} else {\n// type is either serializable as-is or unsupported\nreturn type;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\n// type is a normal class.\nreturn (Class<?>) type;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType parameterizedType = (ParameterizedType) type;\n\n// I'm not exactly sure why getRawType() returns Type instead of Class.\n// Neal isn't either but suspects some pathological case related\n// to nested classes exists.\nType rawType = parameterizedType.getRawType();\ncheckArgument(rawType instanceof Class);\nreturn (Class<?>) rawType;\n\n} else if (type instanceof GenericArrayType) {\nType componentType = ((GenericArrayType)type).getGenericComponentType();\nreturn Array.newInstance(getRawType(componentType), 0).getClass();\n\n} else if (type instanceof TypeVariable) {\n// we could use the variable's bounds, but that won't work if there are multiple.\n// having a raw type that's more general than necessary is okay\nreturn Object.class;\n\n} else if (type instanceof WildcardType) {\nreturn getRawType(((WildcardType) type).getUpperBounds()[0]);\n\n} else {\nString className = type == null ? \"null\" : type.getClass().getName();\nthrow new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n+ \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\n\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate boolean requireExpose;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n\n@Override protected Excluder clone() {\ntry {\nreturn (Excluder) super.clone();\n} catch (CloneNotSupportedException e) {\nthrow new AssertionError(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\n\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}\n\nreturn new TypeAdapter<T>() {\n/** The delegate is lazily created because it may not be needed, and creating it may fail. */\nprivate TypeAdapter<T> delegate;\n\n@Override public T read(JsonReader in) throws IOException {\nif (skipDeserialize) {\nin.skipValue();\nreturn null;\n}\nreturn delegate().read(in);\n}\n\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (skipSerialize) {\nout.nullValue();\nreturn;\n}\ndelegate().write(out, value);\n}\n\nprivate TypeAdapter<T> delegate() {\nTypeAdapter<T> d = delegate;\nreturn d != null\n? d\n: (delegate = gson.getDelegateAdapter(Excluder.this, type));\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\n&& !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\nreturn true;\n}\n\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nreturn true;\n}\n\nif (isAnonymousOrLocal(clazz)) {\nreturn true;\n}\n\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nif (exclusionStrategy.shouldSkipClass(clazz)) {\nreturn true;\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n&& (clazz.isAnonymousClass() || clazz.isLocalClass());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n@Override\npublic void write(JsonWriter out, Class value) throws IOException {\nif (value == null) {\nout.nullValue();\n} else {\nthrow new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n+ value.getName() + \". Forgot to register a type adapter?\");\n}\n}\n@Override\npublic Class read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n} else {\nthrow new UnsupportedOperationException(\n\"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n}\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:nullSafe()Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public final TypeAdapter<T> nullSafe() {\nreturn new TypeAdapter<T>() {\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (value == null) {\nout.nullValue();\n} else {\nTypeAdapter.this.write(out, value);\n}\n}\n@Override public T read(JsonReader reader) throws IOException {\nif (reader.peek() == JsonToken.NULL) {\nreader.nextNull();\nreturn null;\n}\nreturn TypeAdapter.this.read(reader);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$15:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Number;",
                                    "method_body": "public Number read(JsonReader in) throws IOException {\nJsonToken jsonToken = in.peek();\nswitch (jsonToken) {\ncase NULL:\nin.nextNull();\nreturn null;\ncase NUMBER:\nreturn new LazilyParsedNumber(in.nextString());\ndefault:\nthrow new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$35:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;Lcom/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nFieldNamingStrategy fieldNamingPolicy, Excluder excluder,\nJsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\nthis.jsonAdapterFactory = jsonAdapterFactory;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "public JsonReader(Reader in) {\nif (in == null) {\nthrow new NullPointerException(\"in == null\");\n}\nthis.in = in;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<clinit>()V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;\n\nprivate static final int PEEKED_NONE = 0;\nprivate static final int PEEKED_BEGIN_OBJECT = 1;\nprivate static final int PEEKED_END_OBJECT = 2;\nprivate static final int PEEKED_BEGIN_ARRAY = 3;\nprivate static final int PEEKED_END_ARRAY = 4;\nprivate static final int PEEKED_TRUE = 5;\nprivate static final int PEEKED_FALSE = 6;\nprivate static final int PEEKED_NULL = 7;\nprivate static final int PEEKED_SINGLE_QUOTED = 8;\nprivate static final int PEEKED_DOUBLE_QUOTED = 9;\nprivate static final int PEEKED_UNQUOTED = 10;\n/** When this is returned, the string value is stored in peekedString. */\nprivate static final int PEEKED_BUFFERED = 11;\nprivate static final int PEEKED_SINGLE_QUOTED_NAME = 12;\nprivate static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\nprivate static final int PEEKED_UNQUOTED_NAME = 14;\n/** When this is returned, the integer value is stored in peekedLong. */\nprivate static final int PEEKED_LONG = 15;\nprivate static final int PEEKED_NUMBER = 16;\nprivate static final int PEEKED_EOF = 17;\n\n/* State machine when parsing numbers */\nprivate static final int NUMBER_CHAR_NONE = 0;\nprivate static final int NUMBER_CHAR_SIGN = 1;\nprivate static final int NUMBER_CHAR_DIGIT = 2;\nprivate static final int NUMBER_CHAR_DECIMAL = 3;\nprivate static final int NUMBER_CHAR_FRACTION_DIGIT = 4;\nprivate static final int NUMBER_CHAR_EXP_E = 5;\nprivate static final int NUMBER_CHAR_EXP_SIGN = 6;\nprivate static final int NUMBER_CHAR_EXP_DIGIT = 7;\n\n/** The input JSON. */\nprivate final Reader in;\n\n/** True to accept non-spec compliant JSON */\nprivate boolean lenient = false;\n\n/**\n* Use a manual buffer to easily read and unread upcoming characters, and\n* also so we can create strings without an intermediate StringBuilder.\n* We decode literals directly out of this buffer, so it must be at least as\n* long as the longest token that can be reported as a number.\n*/\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\n\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\n\nint peeked = PEEKED_NONE;\n\n/**\n* A peeked value that was composed entirely of digits with an optional\n* leading dash. Positive values may not have a leading 0.\n*/\nprivate long peekedLong;\n\n/**\n* The number of characters in a peeked number literal. Increment 'pos' by\n* this after reading a number.\n*/\nprivate int peekedNumberLength;\n\n/**\n* A peeked string that should be parsed on the next double, long or string.\n* This is populated before a numeric value is parsed and used if that parsing\n* fails.\n*/\nprivate String peekedString;\n\n/*\n* The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n*/\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\n{\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:setLenient(Z)V",
                                    "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:isLenient()Z",
                                    "method_body": "public final boolean isLenient() {\nreturn lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\n\nswitch (p) {\ncase PEEKED_BEGIN_OBJECT:\nreturn JsonToken.BEGIN_OBJECT;\ncase PEEKED_END_OBJECT:\nreturn JsonToken.END_OBJECT;\ncase PEEKED_BEGIN_ARRAY:\nreturn JsonToken.BEGIN_ARRAY;\ncase PEEKED_END_ARRAY:\nreturn JsonToken.END_ARRAY;\ncase PEEKED_SINGLE_QUOTED_NAME:\ncase PEEKED_DOUBLE_QUOTED_NAME:\ncase PEEKED_UNQUOTED_NAME:\nreturn JsonToken.NAME;\ncase PEEKED_TRUE:\ncase PEEKED_FALSE:\nreturn JsonToken.BOOLEAN;\ncase PEEKED_NULL:\nreturn JsonToken.NULL;\ncase PEEKED_SINGLE_QUOTED:\ncase PEEKED_DOUBLE_QUOTED:\ncase PEEKED_UNQUOTED:\ncase PEEKED_BUFFERED:\nreturn JsonToken.STRING;\ncase PEEKED_LONG:\ncase PEEKED_NUMBER:\nreturn JsonToken.NUMBER;\ncase PEEKED_EOF:\nreturn JsonToken.END_DOCUMENT;\ndefault:\nthrow new AssertionError();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:doPeek()I",
                                    "method_body": "int doPeek() throws IOException {\nint peekStack = stack[stackSize - 1];\nif (peekStack == JsonScope.EMPTY_ARRAY) {\nstack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n} else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n// Look for a comma before the next element.\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase ']':\nreturn peeked = PEEKED_END_ARRAY;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated array\");\n}\n} else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\nstack[stackSize - 1] = JsonScope.DANGLING_NAME;\n// Look for a comma before the next element.\nif (peekStack == JsonScope.NONEMPTY_OBJECT) {\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '}':\nreturn peeked = PEEKED_END_OBJECT;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated object\");\n}\n}\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '\"':\nreturn peeked = PEEKED_DOUBLE_QUOTED_NAME;\ncase '\\'':\ncheckLenient();\nreturn peeked = PEEKED_SINGLE_QUOTED_NAME;\ncase '}':\nif (peekStack != JsonScope.NONEMPTY_OBJECT) {\nreturn peeked = PEEKED_END_OBJECT;\n} else {\nthrow syntaxError(\"Expected name\");\n}\ndefault:\ncheckLenient();\npos--; // Don't consume the first character in an unquoted string.\nif (isLiteral((char) c)) {\nreturn peeked = PEEKED_UNQUOTED_NAME;\n} else {\nthrow syntaxError(\"Expected name\");\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit -= pos;\nSystem.arraycopy(buffer, pos, buffer, 0, limit);\n} else {\nlimit = 0;\n}\n\npos = 0;\nint total;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\n\n// if this is the first read, consume an optional byte order mark (BOM) if it exists\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\npos++;\nlineStart++;\nminimum++;\n}\n\nif (limit >= minimum) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n/*\n* This code uses ugly local variables 'p' and 'l' representing the 'pos'\n* and 'limit' fields respectively. Using locals rather than fields saves\n* a few field reads for each whitespace character in a pretty-printed\n* document, resulting in a 5% speedup. We need to flush 'p' to its field\n* before any (potentially indirect) call to fillBuffer() and reread both\n* 'p' and 'l' after any (potentially indirect) call to the same method.\n*/\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nwhile (true) {\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\nbreak;\n}\np = pos;\nl = limit;\n}\n\nint c = buffer[p++];\nif (c == '\\n') {\nlineNumber++;\nlineStart = p;\ncontinue;\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\ncontinue;\n}\n\nif (c == '/') {\npos = p;\nif (p == l) {\npos--; // push back '/' so it's still in the buffer when this method returns\nboolean charsLoaded = fillBuffer(2);\npos++; // consume the '/' again\nif (!charsLoaded) {\nreturn c;\n}\n}\n\ncheckLenient();\nchar peek = buffer[pos];\nswitch (peek) {\ncase '*':\n// skip a /* c-style comment */\npos++;\nif (!skipTo(\"*/\")) {\nthrow syntaxError(\"Unterminated comment\");\n}\np = pos + 2;\nl = limit;\ncontinue;\n\ncase '/':\n// skip a // end-of-line comment\npos++;\nskipToEndOfLine();\np = pos;\nl = limit;\ncontinue;\n\ndefault:\nreturn c;\n}\n} else if (c == '#') {\npos = p;\n/*\n* Skip a # hash end-of-line comment. The JSON RFC doesn't\n* specify this behaviour, but it's required to parse\n* existing documents. See http://b/2571423.\n*/\ncheckLenient();\nskipToEndOfLine();\np = pos;\nl = limit;\n} else {\npos = p;\nreturn c;\n}\n}\nif (throwOnEof) {\nthrow new EOFException(\"End of input\" + locationString());\n} else {\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:consumeNonExecutePrefix()V",
                                    "method_body": "private void consumeNonExecutePrefix() throws IOException {\n// fast forward through the leading whitespace\nnextNonWhitespace(true);\npos--;\n\nif (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\nreturn;\n}\n\nfor (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\nif (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\nreturn; // not a security token!\n}\n}\n\n// we consumed a security token!\npos += NON_EXECUTE_PREFIX.length;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$36:<clinit>()V",
                                    "method_body": "@Override public BitSet read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\n\nBitSet bitset = new BitSet();\nin.beginArray();\nint i = 0;\nJsonToken tokenType = in.peek();\nwhile (tokenType != JsonToken.END_ARRAY) {\nboolean set;\nswitch (tokenType) {\ncase NUMBER:\nset = in.nextInt() != 0;\nbreak;\ncase BOOLEAN:\nset = in.nextBoolean();\nbreak;\ncase STRING:\nString stringValue = in.nextString();\ntry {\nset = Integer.parseInt(stringValue) != 0;\n} catch (NumberFormatException e) {\nthrow new JsonSyntaxException(\n\"Error: Expecting: bitset number value (1, 0), Found: \" + stringValue);\n}\nbreak;\ndefault:\nthrow new JsonSyntaxException(\"Invalid bitset value type: \" + tokenType);\n}\nif (set) {\nbitset.set(i);\n}\n++i;\ntokenType = in.peek();\n}\nin.endArray();\nreturn bitset;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nthrow new NullPointerException();\n}\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonParseException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public JsonParseException(String msg) {\nsuper(msg);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonSyntaxException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public JsonSyntaxException(String msg) {\nsuper(msg);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson$FutureTypeAdapter:setDelegate(Lcom/google/gson/TypeAdapter;)V",
                                    "method_body": "public void setDelegate(TypeAdapter<T> typeAdapter) {\nif (delegate != null) {\nthrow new AssertionError();\n}\ndelegate = typeAdapter;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 12,
                    "tests": [
                        {
                            "test_name": "com.google.gson.internal.bind.JsonTreeReaderTest.testSkipValue_emptyJsonObject",
                            "test_body": "27: public void testSkipValue_emptyJsonObject() throws IOException {\n28: JsonTreeReader in = new JsonTreeReader(new JsonObject());\n29: in.skipValue();\n30: assertEquals(JsonToken.END_DOCUMENT, in.peek());\n31: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "public JsonReader(Reader in) {\nif (in == null) {\nthrow new NullPointerException(\"in == null\");\n}\nthis.in = in;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<clinit>()V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;\n\nprivate static final int PEEKED_NONE = 0;\nprivate static final int PEEKED_BEGIN_OBJECT = 1;\nprivate static final int PEEKED_END_OBJECT = 2;\nprivate static final int PEEKED_BEGIN_ARRAY = 3;\nprivate static final int PEEKED_END_ARRAY = 4;\nprivate static final int PEEKED_TRUE = 5;\nprivate static final int PEEKED_FALSE = 6;\nprivate static final int PEEKED_NULL = 7;\nprivate static final int PEEKED_SINGLE_QUOTED = 8;\nprivate static final int PEEKED_DOUBLE_QUOTED = 9;\nprivate static final int PEEKED_UNQUOTED = 10;\n/** When this is returned, the string value is stored in peekedString. */\nprivate static final int PEEKED_BUFFERED = 11;\nprivate static final int PEEKED_SINGLE_QUOTED_NAME = 12;\nprivate static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\nprivate static final int PEEKED_UNQUOTED_NAME = 14;\n/** When this is returned, the integer value is stored in peekedLong. */\nprivate static final int PEEKED_LONG = 15;\nprivate static final int PEEKED_NUMBER = 16;\nprivate static final int PEEKED_EOF = 17;\n\n/* State machine when parsing numbers */\nprivate static final int NUMBER_CHAR_NONE = 0;\nprivate static final int NUMBER_CHAR_SIGN = 1;\nprivate static final int NUMBER_CHAR_DIGIT = 2;\nprivate static final int NUMBER_CHAR_DECIMAL = 3;\nprivate static final int NUMBER_CHAR_FRACTION_DIGIT = 4;\nprivate static final int NUMBER_CHAR_EXP_E = 5;\nprivate static final int NUMBER_CHAR_EXP_SIGN = 6;\nprivate static final int NUMBER_CHAR_EXP_DIGIT = 7;\n\n/** The input JSON. */\nprivate final Reader in;\n\n/** True to accept non-spec compliant JSON */\nprivate boolean lenient = false;\n\n/**\n* Use a manual buffer to easily read and unread upcoming characters, and\n* also so we can create strings without an intermediate StringBuilder.\n* We decode literals directly out of this buffer, so it must be at least as\n* long as the longest token that can be reported as a number.\n*/\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\n\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\n\nint peeked = PEEKED_NONE;\n\n/**\n* A peeked value that was composed entirely of digits with an optional\n* leading dash. Positive values may not have a leading 0.\n*/\nprivate long peekedLong;\n\n/**\n* The number of characters in a peeked number literal. Increment 'pos' by\n* this after reading a number.\n*/\nprivate int peekedNumberLength;\n\n/**\n* A peeked string that should be parsed on the next double, long or string.\n* This is populated before a numeric value is parsed and used if that parsing\n* fails.\n*/\nprivate String peekedString;\n\n/*\n* The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n*/\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\n{\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:<init>()V",
                                    "method_body": "public LinkedTreeMap() {\nthis((Comparator<? super K>) NATURAL_ORDER);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:<init>(Ljava/util/Comparator;)V",
                                    "method_body": "public LinkedTreeMap(Comparator<? super K> comparator) {\nthis.comparator = comparator != null\n? comparator\n: (Comparator) NATURAL_ORDER;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap$Node:<init>()V",
                                    "method_body": "Node() {\nkey = null;\nnext = prev = this;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:<init>(Lcom/google/gson/JsonElement;)V",
                                    "method_body": "public JsonTreeReader(JsonElement element) {\nsuper(UNREADABLE_READER);\npush(element);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:<clinit>()V",
                                    "method_body": "private static final Reader UNREADABLE_READER = new Reader() {\n@Override public int read(char[] buffer, int offset, int count) throws IOException {\nthrow new AssertionError();\n}\n@Override public void close() throws IOException {\nthrow new AssertionError();\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "@Override public JsonToken peek() throws IOException {\nif (stackSize == 0) {\nreturn JsonToken.END_DOCUMENT;\n}\n\nObject o = peekStack();\nif (o instanceof Iterator) {\nboolean isObject = stack[stackSize - 2] instanceof JsonObject;\nIterator<?> iterator = (Iterator<?>) o;\nif (iterator.hasNext()) {\nif (isObject) {\nreturn JsonToken.NAME;\n} else {\npush(iterator.next());\nreturn peek();\n}\n} else {\nreturn isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\n}\n} else if (o instanceof JsonObject) {\nreturn JsonToken.BEGIN_OBJECT;\n} else if (o instanceof JsonArray) {\nreturn JsonToken.BEGIN_ARRAY;\n} else if (o instanceof JsonPrimitive) {\nJsonPrimitive primitive = (JsonPrimitive) o;\nif (primitive.isString()) {\nreturn JsonToken.STRING;\n} else if (primitive.isBoolean()) {\nreturn JsonToken.BOOLEAN;\n} else if (primitive.isNumber()) {\nreturn JsonToken.NUMBER;\n} else {\nthrow new AssertionError();\n}\n} else if (o instanceof JsonNull) {\nreturn JsonToken.NULL;\n} else if (o == SENTINEL_CLOSED) {\nthrow new IllegalStateException(\"JsonReader is closed\");\n} else {\nthrow new AssertionError();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:peekStack()Ljava/lang/Object;",
                                    "method_body": "private Object peekStack() {\nreturn stack[stackSize - 1];\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:popStack()Ljava/lang/Object;",
                                    "method_body": "private Object popStack() {\nObject result = stack[--stackSize];\nstack[stackSize] = null;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:skipValue()V",
                                    "method_body": "@Override public void skipValue() throws IOException {\nif (peek() == JsonToken.NAME) {\nnextName();\npathNames[stackSize - 2] = \"null\";\n} else {\npopStack();\npathNames[stackSize - 1] = \"null\";\n}\npathIndices[stackSize - 1]++;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:push(Ljava/lang/Object;)V",
                                    "method_body": "private void push(Object newTop) {\nif (stackSize == stack.length) {\nObject[] newStack = new Object[stackSize * 2];\nint[] newPathIndices = new int[stackSize * 2];\nString[] newPathNames = new String[stackSize * 2];\nSystem.arraycopy(stack, 0, newStack, 0, stackSize);\nSystem.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\nSystem.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\nstack = newStack;\npathIndices = newPathIndices;\npathNames = newPathNames;\n}\nstack[stackSize++] = newTop;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.internal.bind.JsonTreeReaderTest.testSkipValue_filledJsonObject",
                            "test_body": "33: public void testSkipValue_filledJsonObject() throws IOException {\n34: JsonObject jsonObject = new JsonObject();\n35: JsonArray jsonArray = new JsonArray();\n36: jsonArray.add('c');\n37: jsonArray.add(\"text\");\n38: jsonObject.add(\"a\", jsonArray);\n39: jsonObject.addProperty(\"b\", true);\n40: jsonObject.addProperty(\"i\", 1);\n41: jsonObject.add(\"n\", JsonNull.INSTANCE);\n42: JsonObject jsonObject2 = new JsonObject();\n43: jsonObject2.addProperty(\"n\", 2L);\n44: jsonObject.add(\"o\", jsonObject2);\n45: jsonObject.addProperty(\"s\", \"text\");\n46: JsonTreeReader in = new JsonTreeReader(jsonObject);\n47: in.skipValue();\n48: assertEquals(JsonToken.END_DOCUMENT, in.peek());\n49: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "public JsonReader(Reader in) {\nif (in == null) {\nthrow new NullPointerException(\"in == null\");\n}\nthis.in = in;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<clinit>()V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;\n\nprivate static final int PEEKED_NONE = 0;\nprivate static final int PEEKED_BEGIN_OBJECT = 1;\nprivate static final int PEEKED_END_OBJECT = 2;\nprivate static final int PEEKED_BEGIN_ARRAY = 3;\nprivate static final int PEEKED_END_ARRAY = 4;\nprivate static final int PEEKED_TRUE = 5;\nprivate static final int PEEKED_FALSE = 6;\nprivate static final int PEEKED_NULL = 7;\nprivate static final int PEEKED_SINGLE_QUOTED = 8;\nprivate static final int PEEKED_DOUBLE_QUOTED = 9;\nprivate static final int PEEKED_UNQUOTED = 10;\n/** When this is returned, the string value is stored in peekedString. */\nprivate static final int PEEKED_BUFFERED = 11;\nprivate static final int PEEKED_SINGLE_QUOTED_NAME = 12;\nprivate static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\nprivate static final int PEEKED_UNQUOTED_NAME = 14;\n/** When this is returned, the integer value is stored in peekedLong. */\nprivate static final int PEEKED_LONG = 15;\nprivate static final int PEEKED_NUMBER = 16;\nprivate static final int PEEKED_EOF = 17;\n\n/* State machine when parsing numbers */\nprivate static final int NUMBER_CHAR_NONE = 0;\nprivate static final int NUMBER_CHAR_SIGN = 1;\nprivate static final int NUMBER_CHAR_DIGIT = 2;\nprivate static final int NUMBER_CHAR_DECIMAL = 3;\nprivate static final int NUMBER_CHAR_FRACTION_DIGIT = 4;\nprivate static final int NUMBER_CHAR_EXP_E = 5;\nprivate static final int NUMBER_CHAR_EXP_SIGN = 6;\nprivate static final int NUMBER_CHAR_EXP_DIGIT = 7;\n\n/** The input JSON. */\nprivate final Reader in;\n\n/** True to accept non-spec compliant JSON */\nprivate boolean lenient = false;\n\n/**\n* Use a manual buffer to easily read and unread upcoming characters, and\n* also so we can create strings without an intermediate StringBuilder.\n* We decode literals directly out of this buffer, so it must be at least as\n* long as the longest token that can be reported as a number.\n*/\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\n\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\n\nint peeked = PEEKED_NONE;\n\n/**\n* A peeked value that was composed entirely of digits with an optional\n* leading dash. Positive values may not have a leading 0.\n*/\nprivate long peekedLong;\n\n/**\n* The number of characters in a peeked number literal. Increment 'pos' by\n* this after reading a number.\n*/\nprivate int peekedNumberLength;\n\n/**\n* A peeked string that should be parsed on the next double, long or string.\n* This is populated before a numeric value is parsed and used if that parsing\n* fails.\n*/\nprivate String peekedString;\n\n/*\n* The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n*/\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\n{\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:<init>(Ljava/lang/String;)V",
                                    "method_body": "public JsonPrimitive(String string) {\nsetValue(string);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:<init>(Ljava/lang/Character;)V",
                                    "method_body": "public JsonPrimitive(Character c) {\nsetValue(c);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:<init>(Ljava/lang/Object;)V",
                                    "method_body": "JsonPrimitive(Object primitive) {\nsetValue(primitive);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:<clinit>()V",
                                    "method_body": "private static final Class<?>[] PRIMITIVE_TYPES = { int.class, long.class, short.class,\nfloat.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class,\nShort.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class };"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:setValue(Ljava/lang/Object;)V",
                                    "method_body": "void setValue(Object primitive) {\nif (primitive instanceof Character) {\n// convert characters to strings since in JSON, characters are represented as a single\n// character string\nchar c = ((Character) primitive).charValue();\nthis.value = String.valueOf(c);\n} else {\n$Gson$Preconditions.checkArgument(primitive instanceof Number\n|| isPrimitiveOrString(primitive));\nthis.value = primitive;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonPrimitive:isPrimitiveOrString(Ljava/lang/Object;)Z",
                                    "method_body": "private static boolean isPrimitiveOrString(Object target) {\nif (target instanceof String) {\nreturn true;\n}\n\nClass<?> classOfPrimitive = target.getClass();\nfor (Class<?> standardPrimitive : PRIMITIVE_TYPES) {\nif (standardPrimitive.isAssignableFrom(classOfPrimitive)) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\nthrow new IllegalArgumentException();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonObject:add(Ljava/lang/String;Lcom/google/gson/JsonElement;)V",
                                    "method_body": "public void add(String property, JsonElement value) {\nif (value == null) {\nvalue = JsonNull.INSTANCE;\n}\nmembers.put(property, value);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonObject:addProperty(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public void addProperty(String property, String value) {\nadd(property, createJsonElement(value));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonObject:addProperty(Ljava/lang/String;Ljava/lang/Number;)V",
                                    "method_body": "public void addProperty(String property, Number value) {\nadd(property, createJsonElement(value));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonObject:addProperty(Ljava/lang/String;Ljava/lang/Boolean;)V",
                                    "method_body": "public void addProperty(String property, Boolean value) {\nadd(property, createJsonElement(value));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonObject:createJsonElement(Ljava/lang/Object;)Lcom/google/gson/JsonElement;",
                                    "method_body": "private JsonElement createJsonElement(Object value) {\nreturn value == null ? JsonNull.INSTANCE : new JsonPrimitive(value);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:<init>()V",
                                    "method_body": "public LinkedTreeMap() {\nthis((Comparator<? super K>) NATURAL_ORDER);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:<init>(Ljava/util/Comparator;)V",
                                    "method_body": "public LinkedTreeMap(Comparator<? super K> comparator) {\nthis.comparator = comparator != null\n? comparator\n: (Comparator) NATURAL_ORDER;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:put(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "@Override public V put(K key, V value) {\nif (key == null) {\nthrow new NullPointerException(\"key == null\");\n}\nNode<K, V> created = find(key, true);\nV result = created.value;\ncreated.value = value;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:find(Ljava/lang/Object;Z)Lcom/google/gson/internal/LinkedTreeMap$Node;",
                                    "method_body": "Node<K, V> find(K key, boolean create) {\nComparator<? super K> comparator = this.comparator;\nNode<K, V> nearest = root;\nint comparison = 0;\n\nif (nearest != null) {\n// Micro-optimization: avoid polymorphic calls to Comparator.compare().\n@SuppressWarnings(\"unchecked\") // Throws a ClassCastException below if there's trouble.\nComparable<Object> comparableKey = (comparator == NATURAL_ORDER)\n? (Comparable<Object>) key\n: null;\n\nwhile (true) {\ncomparison = (comparableKey != null)\n? comparableKey.compareTo(nearest.key)\n: comparator.compare(key, nearest.key);\n\n// We found the requested key.\nif (comparison == 0) {\nreturn nearest;\n}\n\n// If it exists, the key is in a subtree. Go deeper.\nNode<K, V> child = (comparison < 0) ? nearest.left : nearest.right;\nif (child == null) {\nbreak;\n}\n\nnearest = child;\n}\n}\n\n// The key doesn't exist in this tree.\nif (!create) {\nreturn null;\n}\n\n// Create the node and add it to the tree or the table.\nNode<K, V> header = this.header;\nNode<K, V> created;\nif (nearest == null) {\n// Check that the value is comparable if we didn't do any comparisons.\nif (comparator == NATURAL_ORDER && !(key instanceof Comparable)) {\nthrow new ClassCastException(key.getClass().getName() + \" is not Comparable\");\n}\ncreated = new Node<K, V>(nearest, key, header, header.prev);\nroot = created;\n} else {\ncreated = new Node<K, V>(nearest, key, header, header.prev);\nif (comparison < 0) { // nearest.key is higher\nnearest.left = created;\n} else { // comparison > 0, nearest.key is lower\nnearest.right = created;\n}\nrebalance(nearest, true);\n}\nsize++;\nmodCount++;\n\nreturn created;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:replaceInParent(Lcom/google/gson/internal/LinkedTreeMap$Node;Lcom/google/gson/internal/LinkedTreeMap$Node;)V",
                                    "method_body": "private void replaceInParent(Node<K, V> node, Node<K, V> replacement) {\nNode<K, V> parent = node.parent;\nnode.parent = null;\nif (replacement != null) {\nreplacement.parent = parent;\n}\n\nif (parent != null) {\nif (parent.left == node) {\nparent.left = replacement;\n} else {\nassert (parent.right == node);\nparent.right = replacement;\n}\n} else {\nroot = replacement;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:rebalance(Lcom/google/gson/internal/LinkedTreeMap$Node;Z)V",
                                    "method_body": "private void rebalance(Node<K, V> unbalanced, boolean insert) {\nfor (Node<K, V> node = unbalanced; node != null; node = node.parent) {\nNode<K, V> left = node.left;\nNode<K, V> right = node.right;\nint leftHeight = left != null ? left.height : 0;\nint rightHeight = right != null ? right.height : 0;\n\nint delta = leftHeight - rightHeight;\nif (delta == -2) {\nNode<K, V> rightLeft = right.left;\nNode<K, V> rightRight = right.right;\nint rightRightHeight = rightRight != null ? rightRight.height : 0;\nint rightLeftHeight = rightLeft != null ? rightLeft.height : 0;\n\nint rightDelta = rightLeftHeight - rightRightHeight;\nif (rightDelta == -1 || (rightDelta == 0 && !insert)) {\nrotateLeft(node); // AVL right right\n} else {\nassert (rightDelta == 1);\nrotateRight(right); // AVL right left\nrotateLeft(node);\n}\nif (insert) {\nbreak; // no further rotations will be necessary\n}\n\n} else if (delta == 2) {\nNode<K, V> leftLeft = left.left;\nNode<K, V> leftRight = left.right;\nint leftRightHeight = leftRight != null ? leftRight.height : 0;\nint leftLeftHeight = leftLeft != null ? leftLeft.height : 0;\n\nint leftDelta = leftLeftHeight - leftRightHeight;\nif (leftDelta == 1 || (leftDelta == 0 && !insert)) {\nrotateRight(node); // AVL left left\n} else {\nassert (leftDelta == -1);\nrotateLeft(left); // AVL left right\nrotateRight(node);\n}\nif (insert) {\nbreak; // no further rotations will be necessary\n}\n\n} else if (delta == 0) {\nnode.height = leftHeight + 1; // leftHeight == rightHeight\nif (insert) {\nbreak; // the insert caused balance, so rebalancing is done!\n}\n\n} else {\nassert (delta == -1 || delta == 1);\nnode.height = Math.max(leftHeight, rightHeight) + 1;\nif (!insert) {\nbreak; // the height hasn't changed, so rebalancing is done!\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:rotateLeft(Lcom/google/gson/internal/LinkedTreeMap$Node;)V",
                                    "method_body": "private void rotateLeft(Node<K, V> root) {\nNode<K, V> left = root.left;\nNode<K, V> pivot = root.right;\nNode<K, V> pivotLeft = pivot.left;\nNode<K, V> pivotRight = pivot.right;\n\n// move the pivot's left child to the root's right\nroot.right = pivotLeft;\nif (pivotLeft != null) {\npivotLeft.parent = root;\n}\n\nreplaceInParent(root, pivot);\n\n// move the root to the pivot's left\npivot.left = root;\nroot.parent = pivot;\n\n// fix heights\nroot.height = Math.max(left != null ? left.height : 0,\npivotLeft != null ? pivotLeft.height : 0) + 1;\npivot.height = Math.max(root.height,\npivotRight != null ? pivotRight.height : 0) + 1;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap$Node:<init>()V",
                                    "method_body": "Node() {\nkey = null;\nnext = prev = this;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap$Node:<init>(Lcom/google/gson/internal/LinkedTreeMap$Node;Ljava/lang/Object;Lcom/google/gson/internal/LinkedTreeMap$Node;Lcom/google/gson/internal/LinkedTreeMap$Node;)V",
                                    "method_body": "Node(Node<K, V> parent, K key, Node<K, V> next, Node<K, V> prev) {\nthis.parent = parent;\nthis.key = key;\nthis.height = 1;\nthis.next = next;\nthis.prev = prev;\nprev.next = this;\nnext.prev = this;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:<init>(Lcom/google/gson/JsonElement;)V",
                                    "method_body": "public JsonTreeReader(JsonElement element) {\nsuper(UNREADABLE_READER);\npush(element);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:<clinit>()V",
                                    "method_body": "private static final Reader UNREADABLE_READER = new Reader() {\n@Override public int read(char[] buffer, int offset, int count) throws IOException {\nthrow new AssertionError();\n}\n@Override public void close() throws IOException {\nthrow new AssertionError();\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "@Override public JsonToken peek() throws IOException {\nif (stackSize == 0) {\nreturn JsonToken.END_DOCUMENT;\n}\n\nObject o = peekStack();\nif (o instanceof Iterator) {\nboolean isObject = stack[stackSize - 2] instanceof JsonObject;\nIterator<?> iterator = (Iterator<?>) o;\nif (iterator.hasNext()) {\nif (isObject) {\nreturn JsonToken.NAME;\n} else {\npush(iterator.next());\nreturn peek();\n}\n} else {\nreturn isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\n}\n} else if (o instanceof JsonObject) {\nreturn JsonToken.BEGIN_OBJECT;\n} else if (o instanceof JsonArray) {\nreturn JsonToken.BEGIN_ARRAY;\n} else if (o instanceof JsonPrimitive) {\nJsonPrimitive primitive = (JsonPrimitive) o;\nif (primitive.isString()) {\nreturn JsonToken.STRING;\n} else if (primitive.isBoolean()) {\nreturn JsonToken.BOOLEAN;\n} else if (primitive.isNumber()) {\nreturn JsonToken.NUMBER;\n} else {\nthrow new AssertionError();\n}\n} else if (o instanceof JsonNull) {\nreturn JsonToken.NULL;\n} else if (o == SENTINEL_CLOSED) {\nthrow new IllegalStateException(\"JsonReader is closed\");\n} else {\nthrow new AssertionError();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:peekStack()Ljava/lang/Object;",
                                    "method_body": "private Object peekStack() {\nreturn stack[stackSize - 1];\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:popStack()Ljava/lang/Object;",
                                    "method_body": "private Object popStack() {\nObject result = stack[--stackSize];\nstack[stackSize] = null;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:skipValue()V",
                                    "method_body": "@Override public void skipValue() throws IOException {\nif (peek() == JsonToken.NAME) {\nnextName();\npathNames[stackSize - 2] = \"null\";\n} else {\npopStack();\npathNames[stackSize - 1] = \"null\";\n}\npathIndices[stackSize - 1]++;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonTreeReader:push(Ljava/lang/Object;)V",
                                    "method_body": "private void push(Object newTop) {\nif (stackSize == stack.length) {\nObject[] newStack = new Object[stackSize * 2];\nint[] newPathIndices = new int[stackSize * 2];\nString[] newPathNames = new String[stackSize * 2];\nSystem.arraycopy(stack, 0, newStack, 0, stackSize);\nSystem.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\nSystem.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\nstack = newStack;\npathIndices = newPathIndices;\npathNames = newPathNames;\n}\nstack[stackSize++] = newTop;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonArray:<init>()V",
                                    "method_body": "public JsonArray() {\nelements = new ArrayList<JsonElement>();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonArray:add(Ljava/lang/Character;)V",
                                    "method_body": "public void add(Character character) {\nelements.add(character == null ? JsonNull.INSTANCE : new JsonPrimitive(character));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonArray:add(Ljava/lang/String;)V",
                                    "method_body": "public void add(String string) {\nelements.add(string == null ? JsonNull.INSTANCE : new JsonPrimitive(string));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonNull:<init>()V",
                                    "method_body": "public JsonNull() {\n// Do nothing\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonNull:<clinit>()V",
                                    "method_body": "public static final JsonNull INSTANCE = new JsonNull();\n\n/**\n* Creates a new JsonNull object.\n* Deprecated since Gson version 1.8. Use {@link #INSTANCE} instead"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 13,
                    "tests": [
                        {
                            "test_name": "com.google.gson.stream.JsonReaderTest.testNegativeZero",
                            "test_body": "568: public void testNegativeZero() throws Exception {\n569: JsonReader reader = new JsonReader(reader(\"[-0]\"));\n570: reader.setLenient(false);\n571: reader.beginArray();\n572: assertEquals(NUMBER, reader.peek());\n573: assertEquals(\"-0\", reader.nextString());\n574: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "public JsonReader(Reader in) {\nif (in == null) {\nthrow new NullPointerException(\"in == null\");\n}\nthis.in = in;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<clinit>()V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;\n\nprivate static final int PEEKED_NONE = 0;\nprivate static final int PEEKED_BEGIN_OBJECT = 1;\nprivate static final int PEEKED_END_OBJECT = 2;\nprivate static final int PEEKED_BEGIN_ARRAY = 3;\nprivate static final int PEEKED_END_ARRAY = 4;\nprivate static final int PEEKED_TRUE = 5;\nprivate static final int PEEKED_FALSE = 6;\nprivate static final int PEEKED_NULL = 7;\nprivate static final int PEEKED_SINGLE_QUOTED = 8;\nprivate static final int PEEKED_DOUBLE_QUOTED = 9;\nprivate static final int PEEKED_UNQUOTED = 10;\n/** When this is returned, the string value is stored in peekedString. */\nprivate static final int PEEKED_BUFFERED = 11;\nprivate static final int PEEKED_SINGLE_QUOTED_NAME = 12;\nprivate static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\nprivate static final int PEEKED_UNQUOTED_NAME = 14;\n/** When this is returned, the integer value is stored in peekedLong. */\nprivate static final int PEEKED_LONG = 15;\nprivate static final int PEEKED_NUMBER = 16;\nprivate static final int PEEKED_EOF = 17;\n\n/* State machine when parsing numbers */\nprivate static final int NUMBER_CHAR_NONE = 0;\nprivate static final int NUMBER_CHAR_SIGN = 1;\nprivate static final int NUMBER_CHAR_DIGIT = 2;\nprivate static final int NUMBER_CHAR_DECIMAL = 3;\nprivate static final int NUMBER_CHAR_FRACTION_DIGIT = 4;\nprivate static final int NUMBER_CHAR_EXP_E = 5;\nprivate static final int NUMBER_CHAR_EXP_SIGN = 6;\nprivate static final int NUMBER_CHAR_EXP_DIGIT = 7;\n\n/** The input JSON. */\nprivate final Reader in;\n\n/** True to accept non-spec compliant JSON */\nprivate boolean lenient = false;\n\n/**\n* Use a manual buffer to easily read and unread upcoming characters, and\n* also so we can create strings without an intermediate StringBuilder.\n* We decode literals directly out of this buffer, so it must be at least as\n* long as the longest token that can be reported as a number.\n*/\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\n\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\n\nint peeked = PEEKED_NONE;\n\n/**\n* A peeked value that was composed entirely of digits with an optional\n* leading dash. Positive values may not have a leading 0.\n*/\nprivate long peekedLong;\n\n/**\n* The number of characters in a peeked number literal. Increment 'pos' by\n* this after reading a number.\n*/\nprivate int peekedNumberLength;\n\n/**\n* A peeked string that should be parsed on the next double, long or string.\n* This is populated before a numeric value is parsed and used if that parsing\n* fails.\n*/\nprivate String peekedString;\n\n/*\n* The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n*/\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\n{\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:setLenient(Z)V",
                                    "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:beginArray()V",
                                    "method_body": "public void beginArray() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nif (p == PEEKED_BEGIN_ARRAY) {\npush(JsonScope.EMPTY_ARRAY);\npathIndices[stackSize - 1] = 0;\npeeked = PEEKED_NONE;\n} else {\nthrow new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek() + locationString());\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\n\nswitch (p) {\ncase PEEKED_BEGIN_OBJECT:\nreturn JsonToken.BEGIN_OBJECT;\ncase PEEKED_END_OBJECT:\nreturn JsonToken.END_OBJECT;\ncase PEEKED_BEGIN_ARRAY:\nreturn JsonToken.BEGIN_ARRAY;\ncase PEEKED_END_ARRAY:\nreturn JsonToken.END_ARRAY;\ncase PEEKED_SINGLE_QUOTED_NAME:\ncase PEEKED_DOUBLE_QUOTED_NAME:\ncase PEEKED_UNQUOTED_NAME:\nreturn JsonToken.NAME;\ncase PEEKED_TRUE:\ncase PEEKED_FALSE:\nreturn JsonToken.BOOLEAN;\ncase PEEKED_NULL:\nreturn JsonToken.NULL;\ncase PEEKED_SINGLE_QUOTED:\ncase PEEKED_DOUBLE_QUOTED:\ncase PEEKED_UNQUOTED:\ncase PEEKED_BUFFERED:\nreturn JsonToken.STRING;\ncase PEEKED_LONG:\ncase PEEKED_NUMBER:\nreturn JsonToken.NUMBER;\ncase PEEKED_EOF:\nreturn JsonToken.END_DOCUMENT;\ndefault:\nthrow new AssertionError();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:doPeek()I",
                                    "method_body": "int doPeek() throws IOException {\nint peekStack = stack[stackSize - 1];\nif (peekStack == JsonScope.EMPTY_ARRAY) {\nstack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n} else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n// Look for a comma before the next element.\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase ']':\nreturn peeked = PEEKED_END_ARRAY;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated array\");\n}\n} else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\nstack[stackSize - 1] = JsonScope.DANGLING_NAME;\n// Look for a comma before the next element.\nif (peekStack == JsonScope.NONEMPTY_OBJECT) {\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '}':\nreturn peeked = PEEKED_END_OBJECT;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated object\");\n}\n}\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '\"':\nreturn peeked = PEEKED_DOUBLE_QUOTED_NAME;\ncase '\\'':\ncheckLenient();\nreturn peeked = PEEKED_SINGLE_QUOTED_NAME;\ncase '}':\nif (peekStack != JsonScope.NONEMPTY_OBJECT) {\nreturn peeked = PEEKED_END_OBJECT;\n} else {\nthrow syntaxError(\"Expected name\");\n}\ndefault:\ncheckLenient();\npos--; // Don't consume the first character in an unquoted string.\nif (isLiteral((char) c)) {\nreturn peeked = PEEKED_UNQUOTED_NAME;\n} else {\nthrow syntaxError(\"Expected name\");\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peekKeyword()I",
                                    "method_body": "private int peekKeyword() throws IOException {\n// Figure out which keyword we're matching against by its first character.\nchar c = buffer[pos];\nString keyword;\nString keywordUpper;\nint peeking;\nif (c == 't' || c == 'T') {\nkeyword = \"true\";\nkeywordUpper = \"TRUE\";\npeeking = PEEKED_TRUE;\n} else if (c == 'f' || c == 'F') {\nkeyword = \"false\";\nkeywordUpper = \"FALSE\";\npeeking = PEEKED_FALSE;\n} else if (c == 'n' || c == 'N') {\nkeyword = \"null\";\nkeywordUpper = \"NULL\";\npeeking = PEEKED_NULL;\n} else {\nreturn PEEKED_NONE;\n}\n\n// Confirm that chars [1..length) match the keyword.\nint length = keyword.length();\nfor (int i = 1; i < length; i++) {\nif (pos + i >= limit && !fillBuffer(i + 1)) {\nreturn PEEKED_NONE;\n}\nc = buffer[pos + i];\nif (c != keyword.charAt(i) && c != keywordUpper.charAt(i)) {\nreturn PEEKED_NONE;\n}\n}\n\nif ((pos + length < limit || fillBuffer(length + 1))\n&& isLiteral(buffer[pos + length])) {\nreturn PEEKED_NONE; // Don't match trues, falsey or nullsoft!\n}\n\n// We've found the keyword followed either by EOF or by a non-literal character.\npos += length;\nreturn peeked = peeking;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peekNumber()I",
                                    "method_body": "private int peekNumber() throws IOException {\n// Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\n\nlong value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\nboolean negative = false;\nboolean fitsInLong = true;\nint last = NUMBER_CHAR_NONE;\n\nint i = 0;\n\ncharactersOfNumber:\nfor (; true; i++) {\nif (p + i == l) {\nif (i == buffer.length) {\n// Though this looks like a well-formed number, it's too long to continue reading. Give up\n// and let the application handle this as an unquoted literal.\nreturn PEEKED_NONE;\n}\nif (!fillBuffer(i + 1)) {\nbreak;\n}\np = pos;\nl = limit;\n}\n\nchar c = buffer[p + i];\nswitch (c) {\ncase '-':\nif (last == NUMBER_CHAR_NONE) {\nnegative = true;\nlast = NUMBER_CHAR_SIGN;\ncontinue;\n} else if (last == NUMBER_CHAR_EXP_E) {\nlast = NUMBER_CHAR_EXP_SIGN;\ncontinue;\n}\nreturn PEEKED_NONE;\n\ncase '+':\nif (last == NUMBER_CHAR_EXP_E) {\nlast = NUMBER_CHAR_EXP_SIGN;\ncontinue;\n}\nreturn PEEKED_NONE;\n\ncase 'e':\ncase 'E':\nif (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\nlast = NUMBER_CHAR_EXP_E;\ncontinue;\n}\nreturn PEEKED_NONE;\n\ncase '.':\nif (last == NUMBER_CHAR_DIGIT) {\nlast = NUMBER_CHAR_DECIMAL;\ncontinue;\n}\nreturn PEEKED_NONE;\n\ndefault:\nif (c < '0' || c > '9') {\nif (!isLiteral(c)) {\nbreak charactersOfNumber;\n}\nreturn PEEKED_NONE;\n}\nif (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\nvalue = -(c - '0');\nlast = NUMBER_CHAR_DIGIT;\n} else if (last == NUMBER_CHAR_DIGIT) {\nif (value == 0) {\nreturn PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n}\nlong newValue = value * 10 - (c - '0');\nfitsInLong &= value > MIN_INCOMPLETE_INTEGER\n|| (value == MIN_INCOMPLETE_INTEGER && newValue < value);\nvalue = newValue;\n} else if (last == NUMBER_CHAR_DECIMAL) {\nlast = NUMBER_CHAR_FRACTION_DIGIT;\n} else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\nlast = NUMBER_CHAR_EXP_DIGIT;\n}\n}\n}\n\n// We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\npeekedLong = negative ? value : -value;\npos += i;\nreturn peeked = PEEKED_LONG;\n} else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n|| last == NUMBER_CHAR_EXP_DIGIT) {\npeekedNumberLength = i;\nreturn peeked = PEEKED_NUMBER;\n} else {\nreturn PEEKED_NONE;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:isLiteral(C)Z",
                                    "method_body": "private boolean isLiteral(char c) throws IOException {\nswitch (c) {\ncase '/':\ncase '\\\\':\ncase ';':\ncase '#':\ncase '=':\ncheckLenient(); // fall-through\ncase '{':\ncase '}':\ncase '[':\ncase ']':\ncase ':':\ncase ',':\ncase ' ':\ncase '\\t':\ncase '\\f':\ncase '\\r':\ncase '\\n':\nreturn false;\ndefault:\nreturn true;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextString()Ljava/lang/String;",
                                    "method_body": "public String nextString() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nString result;\nif (p == PEEKED_UNQUOTED) {\nresult = nextUnquotedValue();\n} else if (p == PEEKED_SINGLE_QUOTED) {\nresult = nextQuotedValue('\\'');\n} else if (p == PEEKED_DOUBLE_QUOTED) {\nresult = nextQuotedValue('\"');\n} else if (p == PEEKED_BUFFERED) {\nresult = peekedString;\npeekedString = null;\n} else if (p == PEEKED_LONG) {\nresult = Long.toString(peekedLong);\n} else if (p == PEEKED_NUMBER) {\nresult = new String(buffer, pos, peekedNumberLength);\npos += peekedNumberLength;\n} else {\nthrow new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n}\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:push(I)V",
                                    "method_body": "private void push(int newTop) {\nif (stackSize == stack.length) {\nint[] newStack = new int[stackSize * 2];\nint[] newPathIndices = new int[stackSize * 2];\nString[] newPathNames = new String[stackSize * 2];\nSystem.arraycopy(stack, 0, newStack, 0, stackSize);\nSystem.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\nSystem.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\nstack = newStack;\npathIndices = newPathIndices;\npathNames = newPathNames;\n}\nstack[stackSize++] = newTop;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit -= pos;\nSystem.arraycopy(buffer, pos, buffer, 0, limit);\n} else {\nlimit = 0;\n}\n\npos = 0;\nint total;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\n\n// if this is the first read, consume an optional byte order mark (BOM) if it exists\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\npos++;\nlineStart++;\nminimum++;\n}\n\nif (limit >= minimum) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n/*\n* This code uses ugly local variables 'p' and 'l' representing the 'pos'\n* and 'limit' fields respectively. Using locals rather than fields saves\n* a few field reads for each whitespace character in a pretty-printed\n* document, resulting in a 5% speedup. We need to flush 'p' to its field\n* before any (potentially indirect) call to fillBuffer() and reread both\n* 'p' and 'l' after any (potentially indirect) call to the same method.\n*/\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nwhile (true) {\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\nbreak;\n}\np = pos;\nl = limit;\n}\n\nint c = buffer[p++];\nif (c == '\\n') {\nlineNumber++;\nlineStart = p;\ncontinue;\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\ncontinue;\n}\n\nif (c == '/') {\npos = p;\nif (p == l) {\npos--; // push back '/' so it's still in the buffer when this method returns\nboolean charsLoaded = fillBuffer(2);\npos++; // consume the '/' again\nif (!charsLoaded) {\nreturn c;\n}\n}\n\ncheckLenient();\nchar peek = buffer[pos];\nswitch (peek) {\ncase '*':\n// skip a /* c-style comment */\npos++;\nif (!skipTo(\"*/\")) {\nthrow syntaxError(\"Unterminated comment\");\n}\np = pos + 2;\nl = limit;\ncontinue;\n\ncase '/':\n// skip a // end-of-line comment\npos++;\nskipToEndOfLine();\np = pos;\nl = limit;\ncontinue;\n\ndefault:\nreturn c;\n}\n} else if (c == '#') {\npos = p;\n/*\n* Skip a # hash end-of-line comment. The JSON RFC doesn't\n* specify this behaviour, but it's required to parse\n* existing documents. See http://b/2571423.\n*/\ncheckLenient();\nskipToEndOfLine();\np = pos;\nl = limit;\n} else {\npos = p;\nreturn c;\n}\n}\nif (throwOnEof) {\nthrow new EOFException(\"End of input\" + locationString());\n} else {\nreturn -1;\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 14,
                    "tests": [
                        {
                            "test_name": "com.google.gson.internal.bind.RecursiveTypesResolveTest.testSuperSubtype",
                            "test_body": "80: public void testSuperSubtype() {\n81: assertEquals($Gson$Types.subtypeOf(Object.class),\n82: $Gson$Types.supertypeOf($Gson$Types.subtypeOf(Number.class)));\n83: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nthrow new NullPointerException();\n}\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\nthrow new IllegalArgumentException();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:supertypeOf(Ljava/lang/reflect/Type;)Ljava/lang/reflect/WildcardType;",
                                    "method_body": "public static WildcardType supertypeOf(Type bound) {\nType[] lowerBounds;\nlowerBounds = new Type[] { bound };\nreturn new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\np.getRawType(), p.getActualTypeArguments());\n\n} else if (type instanceof GenericArrayType) {\nGenericArrayType g = (GenericArrayType) type;\nreturn new GenericArrayTypeImpl(g.getGenericComponentType());\n\n} else if (type instanceof WildcardType) {\nWildcardType w = (WildcardType) type;\nreturn new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n} else {\n// type is either serializable as-is or unsupported\nreturn type;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:equals(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public static boolean equals(Type a, Type b) {\nif (a == b) {\n// also handles (a == null && b == null)\nreturn true;\n\n} else if (a instanceof Class) {\n// Class already specifies equals().\nreturn a.equals(b);\n\n} else if (a instanceof ParameterizedType) {\nif (!(b instanceof ParameterizedType)) {\nreturn false;\n}\n\n// TODO: save a .clone() call\nParameterizedType pa = (ParameterizedType) a;\nParameterizedType pb = (ParameterizedType) b;\nreturn equal(pa.getOwnerType(), pb.getOwnerType())\n&& pa.getRawType().equals(pb.getRawType())\n&& Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());\n\n} else if (a instanceof GenericArrayType) {\nif (!(b instanceof GenericArrayType)) {\nreturn false;\n}\n\nGenericArrayType ga = (GenericArrayType) a;\nGenericArrayType gb = (GenericArrayType) b;\nreturn equals(ga.getGenericComponentType(), gb.getGenericComponentType());\n\n} else if (a instanceof WildcardType) {\nif (!(b instanceof WildcardType)) {\nreturn false;\n}\n\nWildcardType wa = (WildcardType) a;\nWildcardType wb = (WildcardType) b;\nreturn Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())\n&& Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());\n\n} else if (a instanceof TypeVariable) {\nif (!(b instanceof TypeVariable)) {\nreturn false;\n}\nTypeVariable<?> va = (TypeVariable<?>) a;\nTypeVariable<?> vb = (TypeVariable<?>) b;\nreturn va.getGenericDeclaration() == vb.getGenericDeclaration()\n&& va.getName().equals(vb.getName());\n\n} else {\n// This isn't a type we support. Could be a generic array type, wildcard type, etc.\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:typeToString(Ljava/lang/reflect/Type;)Ljava/lang/String;",
                                    "method_body": "public static String typeToString(Type type) {\nreturn type instanceof Class ? ((Class<?>) type).getName() : type.toString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$WildcardTypeImpl:<init>([Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\ncheckArgument(lowerBounds.length <= 1);\ncheckArgument(upperBounds.length == 1);\n\nif (lowerBounds.length == 1) {\ncheckNotNull(lowerBounds[0]);\ncheckNotPrimitive(lowerBounds[0]);\ncheckArgument(upperBounds[0] == Object.class);\nthis.lowerBound = canonicalize(lowerBounds[0]);\nthis.upperBound = Object.class;\n\n} else {\ncheckNotNull(upperBounds[0]);\ncheckNotPrimitive(upperBounds[0]);\nthis.lowerBound = null;\nthis.upperBound = canonicalize(upperBounds[0]);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:subtypeOf(Ljava/lang/reflect/Type;)Ljava/lang/reflect/WildcardType;",
                                    "method_body": "public static WildcardType subtypeOf(Type bound) {\nType[] upperBounds;\nupperBounds = new Type[] { bound };\nreturn new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.internal.bind.RecursiveTypesResolveTest.testDoubleSupertype",
                            "test_body": "70: public void testDoubleSupertype() {\n71: assertEquals($Gson$Types.supertypeOf(Number.class),\n72: $Gson$Types.supertypeOf($Gson$Types.supertypeOf(Number.class)));\n73: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nthrow new NullPointerException();\n}\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\nthrow new IllegalArgumentException();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:supertypeOf(Ljava/lang/reflect/Type;)Ljava/lang/reflect/WildcardType;",
                                    "method_body": "public static WildcardType supertypeOf(Type bound) {\nType[] lowerBounds;\nlowerBounds = new Type[] { bound };\nreturn new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\np.getRawType(), p.getActualTypeArguments());\n\n} else if (type instanceof GenericArrayType) {\nGenericArrayType g = (GenericArrayType) type;\nreturn new GenericArrayTypeImpl(g.getGenericComponentType());\n\n} else if (type instanceof WildcardType) {\nWildcardType w = (WildcardType) type;\nreturn new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n} else {\n// type is either serializable as-is or unsupported\nreturn type;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:equals(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public static boolean equals(Type a, Type b) {\nif (a == b) {\n// also handles (a == null && b == null)\nreturn true;\n\n} else if (a instanceof Class) {\n// Class already specifies equals().\nreturn a.equals(b);\n\n} else if (a instanceof ParameterizedType) {\nif (!(b instanceof ParameterizedType)) {\nreturn false;\n}\n\n// TODO: save a .clone() call\nParameterizedType pa = (ParameterizedType) a;\nParameterizedType pb = (ParameterizedType) b;\nreturn equal(pa.getOwnerType(), pb.getOwnerType())\n&& pa.getRawType().equals(pb.getRawType())\n&& Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());\n\n} else if (a instanceof GenericArrayType) {\nif (!(b instanceof GenericArrayType)) {\nreturn false;\n}\n\nGenericArrayType ga = (GenericArrayType) a;\nGenericArrayType gb = (GenericArrayType) b;\nreturn equals(ga.getGenericComponentType(), gb.getGenericComponentType());\n\n} else if (a instanceof WildcardType) {\nif (!(b instanceof WildcardType)) {\nreturn false;\n}\n\nWildcardType wa = (WildcardType) a;\nWildcardType wb = (WildcardType) b;\nreturn Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())\n&& Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());\n\n} else if (a instanceof TypeVariable) {\nif (!(b instanceof TypeVariable)) {\nreturn false;\n}\nTypeVariable<?> va = (TypeVariable<?>) a;\nTypeVariable<?> vb = (TypeVariable<?>) b;\nreturn va.getGenericDeclaration() == vb.getGenericDeclaration()\n&& va.getName().equals(vb.getName());\n\n} else {\n// This isn't a type we support. Could be a generic array type, wildcard type, etc.\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:typeToString(Ljava/lang/reflect/Type;)Ljava/lang/String;",
                                    "method_body": "public static String typeToString(Type type) {\nreturn type instanceof Class ? ((Class<?>) type).getName() : type.toString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$WildcardTypeImpl:<init>([Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\ncheckArgument(lowerBounds.length <= 1);\ncheckArgument(upperBounds.length == 1);\n\nif (lowerBounds.length == 1) {\ncheckNotNull(lowerBounds[0]);\ncheckNotPrimitive(lowerBounds[0]);\ncheckArgument(upperBounds[0] == Object.class);\nthis.lowerBound = canonicalize(lowerBounds[0]);\nthis.upperBound = Object.class;\n\n} else {\ncheckNotNull(upperBounds[0]);\ncheckNotPrimitive(upperBounds[0]);\nthis.lowerBound = null;\nthis.upperBound = canonicalize(upperBounds[0]);\n}\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.internal.bind.RecursiveTypesResolveTest.testIssue603PrintStream",
                            "test_body": "56: public void testIssue603PrintStream() {\n57: TypeAdapter<PrintStream> adapter = new Gson().getAdapter(PrintStream.class);\n58: assertNotNull(adapter);\n59: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nthrow new NullPointerException();\n}\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\nthrow new IllegalArgumentException();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:supertypeOf(Ljava/lang/reflect/Type;)Ljava/lang/reflect/WildcardType;",
                                    "method_body": "public static WildcardType supertypeOf(Type bound) {\nType[] lowerBounds;\nlowerBounds = new Type[] { bound };\nreturn new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\np.getRawType(), p.getActualTypeArguments());\n\n} else if (type instanceof GenericArrayType) {\nGenericArrayType g = (GenericArrayType) type;\nreturn new GenericArrayTypeImpl(g.getGenericComponentType());\n\n} else if (type instanceof WildcardType) {\nWildcardType w = (WildcardType) type;\nreturn new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n} else {\n// type is either serializable as-is or unsupported\nreturn type;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:equals(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public static boolean equals(Type a, Type b) {\nif (a == b) {\n// also handles (a == null && b == null)\nreturn true;\n\n} else if (a instanceof Class) {\n// Class already specifies equals().\nreturn a.equals(b);\n\n} else if (a instanceof ParameterizedType) {\nif (!(b instanceof ParameterizedType)) {\nreturn false;\n}\n\n// TODO: save a .clone() call\nParameterizedType pa = (ParameterizedType) a;\nParameterizedType pb = (ParameterizedType) b;\nreturn equal(pa.getOwnerType(), pb.getOwnerType())\n&& pa.getRawType().equals(pb.getRawType())\n&& Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());\n\n} else if (a instanceof GenericArrayType) {\nif (!(b instanceof GenericArrayType)) {\nreturn false;\n}\n\nGenericArrayType ga = (GenericArrayType) a;\nGenericArrayType gb = (GenericArrayType) b;\nreturn equals(ga.getGenericComponentType(), gb.getGenericComponentType());\n\n} else if (a instanceof WildcardType) {\nif (!(b instanceof WildcardType)) {\nreturn false;\n}\n\nWildcardType wa = (WildcardType) a;\nWildcardType wb = (WildcardType) b;\nreturn Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())\n&& Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());\n\n} else if (a instanceof TypeVariable) {\nif (!(b instanceof TypeVariable)) {\nreturn false;\n}\nTypeVariable<?> va = (TypeVariable<?>) a;\nTypeVariable<?> vb = (TypeVariable<?>) b;\nreturn va.getGenericDeclaration() == vb.getGenericDeclaration()\n&& va.getName().equals(vb.getName());\n\n} else {\n// This isn't a type we support. Could be a generic array type, wildcard type, etc.\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$WildcardTypeImpl:<init>([Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\ncheckArgument(lowerBounds.length <= 1);\ncheckArgument(upperBounds.length == 1);\n\nif (lowerBounds.length == 1) {\ncheckNotNull(lowerBounds[0]);\ncheckNotPrimitive(lowerBounds[0]);\ncheckArgument(upperBounds[0] == Object.class);\nthis.lowerBound = canonicalize(lowerBounds[0]);\nthis.upperBound = Object.class;\n\n} else {\ncheckNotNull(upperBounds[0]);\ncheckNotPrimitive(upperBounds[0]);\nthis.lowerBound = null;\nthis.upperBound = canonicalize(upperBounds[0]);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\nCollections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\nDEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\nDEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\nLongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,\nfinal Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,\nboolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\nboolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,\nLongSerializationPolicy longSerializationPolicy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.excluder = excluder;\nthis.fieldNamingStrategy = fieldNamingStrategy;\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nthis.lenient = lenient;\n\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n\n// built-in type adapters that cannot be overridden\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\n\n// the excluder must precede all adapters that handle user-defined types\nfactories.add(excluder);\n\n// user's type adapters\nfactories.addAll(typeAdapterFactories);\n\n// type adapters for basic platform types\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nTypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\ndoubleAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfloatAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\nfactories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\nfactories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.CURRENCY_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\n\n// type adapters for composite and user-defined types\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nthis.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);\nfactories.add(jsonAdapterFactory);\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nconstructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory));\n\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<clinit>()V",
                                    "method_body": "static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\nstatic final boolean DEFAULT_LENIENT = false;\nstatic final boolean DEFAULT_PRETTY_PRINT = false;\nstatic final boolean DEFAULT_ESCAPE_HTML = true;\nstatic final boolean DEFAULT_SERIALIZE_NULLS = false;\nstatic final boolean DEFAULT_COMPLEX_MAP_KEYS = false;\nstatic final boolean DEFAULT_SPECIALIZE_FLOAT_VALUES = false;\n\nprivate static final TypeToken<?> NULL_KEY_SURROGATE = TypeToken.get(Object.class);\nprivate static final String JSON_NON_EXECUTABLE_PREFIX = \")]}'\\n\";\n\n/**\n* This thread local guards against reentrant calls to getAdapter(). In\n* certain object graphs, creating an adapter for a type may recursively\n* require an adapter for the same type! Without intervention, the recursive\n* lookup would stack overflow. We cheat by returning a proxy type adapter.\n* The proxy is wired up once the initial adapter has been created.\n*/\nprivate final ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>> calls\n= new ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>>();\n\nprivate final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache = new ConcurrentHashMap<TypeToken<?>, TypeAdapter<?>>();\n\nprivate final List<TypeAdapterFactory> factories;\nprivate final ConstructorConstructor constructorConstructor;\n\nprivate final Excluder excluder;\nprivate final FieldNamingStrategy fieldNamingStrategy;\nprivate final boolean serializeNulls;\nprivate final boolean htmlSafe;\nprivate final boolean generateNonExecutableJson;\nprivate final boolean prettyPrinting;\nprivate final boolean lenient;\nprivate final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;\n\n/**\n* Constructs a Gson object with default configuration. The default configuration has the\n* following settings:\n* <ul>\n*   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n*   means that all the unneeded white-space is removed. You can change this behavior with\n*   {@link GsonBuilder#setPrettyPrinting()}. </li>"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.DOUBLE;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Double read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\ndouble doubleValue = value.doubleValue();\ncheckValidFloatingPoint(doubleValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.FLOAT;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Float read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn (float) in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nfloat floatValue = value.floatValue();\ncheckValidFloatingPoint(floatValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Number read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextLong();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nout.value(value.toString());\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLong>() {\n@Override public void write(JsonWriter out, AtomicLong value) throws IOException {\nlongAdapter.write(out, value.get());\n}\n@Override public AtomicLong read(JsonReader in) throws IOException {\nNumber value = longAdapter.read(in);\nreturn new AtomicLong(value.longValue());\n}\n}.nullSafe();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongArrayAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLongArray>() {\n@Override public void write(JsonWriter out, AtomicLongArray value) throws IOException {\nout.beginArray();\nfor (int i = 0, length = value.length(); i < length; i++) {\nlongAdapter.write(out, value.get(i));\n}\nout.endArray();\n}\n@Override public AtomicLongArray read(JsonReader in) throws IOException {\nList<Long> list = new ArrayList<Long>();\nin.beginArray();\nwhile (in.hasNext()) {\nlong value = longAdapter.read(in).longValue();\nlist.add(value);\n}\nin.endArray();\nint length = list.size();\nAtomicLongArray array = new AtomicLongArray(length);\nfor (int i = 0; i < length; ++i) {\narray.set(i, list.get(i));\n}\nreturn array;\n}\n}.nullSafe();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);\nif (cached != null) {\nreturn (TypeAdapter<T>) cached;\n}\n\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\n}\n\n// the key and value type parameters always agree\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nreturn ongoingCall;\n}\n\ntry {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\n\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\n}\n}\nthrow new IllegalArgumentException(\"GSON cannot handle \" + type);\n} finally {\nthreadCalls.remove(type);\n\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Ljava/lang/Class;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(Class<T> type) {\nreturn getAdapter(TypeToken.get(type));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:equals(Ljava/lang/Object;)Z",
                                    "method_body": "@Override public final boolean equals(Object o) {\nreturn o instanceof TypeToken<?>\n&& $Gson$Types.equals(type, ((TypeToken<?>) o).type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/Class;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static <T> TypeToken<T> get(Class<T> type) {\nreturn new TypeToken<T>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:newParameterizedTypeWithOwner(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)Ljava/lang/reflect/ParameterizedType;",
                                    "method_body": "public static ParameterizedType newParameterizedTypeWithOwner(\nType ownerType, Type rawType, Type... typeArguments) {\nreturn new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:subtypeOf(Ljava/lang/reflect/Type;)Ljava/lang/reflect/WildcardType;",
                                    "method_body": "public static WildcardType subtypeOf(Type bound) {\nType[] upperBounds;\nupperBounds = new Type[] { bound };\nreturn new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\n// type is a normal class.\nreturn (Class<?>) type;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType parameterizedType = (ParameterizedType) type;\n\n// I'm not exactly sure why getRawType() returns Type instead of Class.\n// Neal isn't either but suspects some pathological case related\n// to nested classes exists.\nType rawType = parameterizedType.getRawType();\ncheckArgument(rawType instanceof Class);\nreturn (Class<?>) rawType;\n\n} else if (type instanceof GenericArrayType) {\nType componentType = ((GenericArrayType)type).getGenericComponentType();\nreturn Array.newInstance(getRawType(componentType), 0).getClass();\n\n} else if (type instanceof TypeVariable) {\n// we could use the variable's bounds, but that won't work if there are multiple.\n// having a raw type that's more general than necessary is okay\nreturn Object.class;\n\n} else if (type instanceof WildcardType) {\nreturn getRawType(((WildcardType) type).getUpperBounds()[0]);\n\n} else {\nString className = type == null ? \"null\" : type.getClass().getName();\nthrow new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n+ \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:hashCodeOrZero(Ljava/lang/Object;)I",
                                    "method_body": "static int hashCodeOrZero(Object o) {\nreturn o != null ? o.hashCode() : 0;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getGenericSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\nif (toResolve == rawType) {\nreturn context;\n}\n\n// we skip searching through interfaces if unknown is an interface\nif (toResolve.isInterface()) {\nClass<?>[] interfaces = rawType.getInterfaces();\nfor (int i = 0, length = interfaces.length; i < length; i++) {\nif (interfaces[i] == toResolve) {\nreturn rawType.getGenericInterfaces()[i];\n} else if (toResolve.isAssignableFrom(interfaces[i])) {\nreturn getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n}\n}\n}\n\n// check our supertypes\nif (!rawType.isInterface()) {\nwhile (rawType != Object.class) {\nClass<?> rawSupertype = rawType.getSuperclass();\nif (rawSupertype == toResolve) {\nreturn rawType.getGenericSuperclass();\n} else if (toResolve.isAssignableFrom(rawSupertype)) {\nreturn getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);\n}\nrawType = rawSupertype;\n}\n}\n\n// we can't resolve this further\nreturn toResolve;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\n// this implementation is made a little more complicated in an attempt to avoid object-creation\nwhile (true) {\nif (toResolve instanceof TypeVariable) {\nTypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\ntoResolve = resolveTypeVariable(context, contextRawType, typeVariable);\nif (toResolve == typeVariable) {\nreturn toResolve;\n}\n\n} else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\nClass<?> original = (Class<?>) toResolve;\nType componentType = original.getComponentType();\nType newComponentType = resolve(context, contextRawType, componentType);\nreturn componentType == newComponentType\n? original\n: arrayOf(newComponentType);\n\n} else if (toResolve instanceof GenericArrayType) {\nGenericArrayType original = (GenericArrayType) toResolve;\nType componentType = original.getGenericComponentType();\nType newComponentType = resolve(context, contextRawType, componentType);\nreturn componentType == newComponentType\n? original\n: arrayOf(newComponentType);\n\n} else if (toResolve instanceof ParameterizedType) {\nParameterizedType original = (ParameterizedType) toResolve;\nType ownerType = original.getOwnerType();\nType newOwnerType = resolve(context, contextRawType, ownerType);\nboolean changed = newOwnerType != ownerType;\n\nType[] args = original.getActualTypeArguments();\nfor (int t = 0, length = args.length; t < length; t++) {\nType resolvedTypeArgument = resolve(context, contextRawType, args[t]);\nif (resolvedTypeArgument != args[t]) {\nif (!changed) {\nargs = args.clone();\nchanged = true;\n}\nargs[t] = resolvedTypeArgument;\n}\n}\n\nreturn changed\n? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n: original;\n\n} else if (toResolve instanceof WildcardType) {\nWildcardType original = (WildcardType) toResolve;\nType[] originalLowerBound = original.getLowerBounds();\nType[] originalUpperBound = original.getUpperBounds();\n\nif (originalLowerBound.length == 1) {\nType lowerBound = resolve(context, contextRawType, originalLowerBound[0]);\nif (lowerBound != originalLowerBound[0]) {\nreturn supertypeOf(lowerBound);\n}\n} else if (originalUpperBound.length == 1) {\nType upperBound = resolve(context, contextRawType, originalUpperBound[0]);\nif (upperBound != originalUpperBound[0]) {\nreturn subtypeOf(upperBound);\n}\n}\nreturn original;\n\n} else {\nreturn toResolve;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolveTypeVariable(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/TypeVariable;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\nClass<?> declaredByRaw = declaringClassOf(unknown);\n\n// we can't reduce this further\nif (declaredByRaw == null) {\nreturn unknown;\n}\n\nType declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\nif (declaredBy instanceof ParameterizedType) {\nint index = indexOf(declaredByRaw.getTypeParameters(), unknown);\nreturn ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\n}\n\nreturn unknown;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:indexOf([Ljava/lang/Object;Ljava/lang/Object;)I",
                                    "method_body": "private static int indexOf(Object[] array, Object toFind) {\nfor (int i = 0, length = array.length; i < length; i++) {\nif (toFind.equals(array[i])) {\nreturn i;\n}\n}\nthrow new NoSuchElementException();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:declaringClassOf(Ljava/lang/reflect/TypeVariable;)Ljava/lang/Class;",
                                    "method_body": "private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\nGenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\nreturn genericDeclaration instanceof Class\n? (Class<?>) genericDeclaration\n: null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\n\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate boolean requireExpose;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n\n@Override protected Excluder clone() {\ntry {\nreturn (Excluder) super.clone();\n} catch (CloneNotSupportedException e) {\nthrow new AssertionError(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\n\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}\n\nreturn new TypeAdapter<T>() {\n/** The delegate is lazily created because it may not be needed, and creating it may fail. */\nprivate TypeAdapter<T> delegate;\n\n@Override public T read(JsonReader in) throws IOException {\nif (skipDeserialize) {\nin.skipValue();\nreturn null;\n}\nreturn delegate().read(in);\n}\n\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (skipSerialize) {\nout.nullValue();\nreturn;\n}\ndelegate().write(out, value);\n}\n\nprivate TypeAdapter<T> delegate() {\nTypeAdapter<T> d = delegate;\nreturn d != null\n? d\n: (delegate = gson.getDelegateAdapter(Excluder.this, type));\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field field, boolean serialize) {\nif ((modifiers & field.getModifiers()) != 0) {\nreturn true;\n}\n\nif (version != Excluder.IGNORE_VERSIONS\n&& !isValidVersion(field.getAnnotation(Since.class), field.getAnnotation(Until.class))) {\nreturn true;\n}\n\nif (field.isSynthetic()) {\nreturn true;\n}\n\nif (requireExpose) {\nExpose annotation = field.getAnnotation(Expose.class);\nif (annotation == null || (serialize ? !annotation.serialize() : !annotation.deserialize())) {\nreturn true;\n}\n}\n\nif (!serializeInnerClasses && isInnerClass(field.getType())) {\nreturn true;\n}\n\nif (isAnonymousOrLocal(field.getType())) {\nreturn true;\n}\n\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nif (!list.isEmpty()) {\nFieldAttributes fieldAttributes = new FieldAttributes(field);\nfor (ExclusionStrategy exclusionStrategy : list) {\nif (exclusionStrategy.shouldSkipField(fieldAttributes)) {\nreturn true;\n}\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\n&& !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\nreturn true;\n}\n\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nreturn true;\n}\n\nif (isAnonymousOrLocal(clazz)) {\nreturn true;\n}\n\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nif (exclusionStrategy.shouldSkipClass(clazz)) {\nreturn true;\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n&& (clazz.isAnonymousClass() || clazz.isLocalClass());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.FieldNamingPolicy$1:translateName(Ljava/lang/reflect/Field;)Ljava/lang/String;",
                                    "method_body": "@Override public String translateName(Field f) {\nreturn f.getName();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\n\n// first try an instance creator\n\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn typeCreator.createInstance(type);\n}\n};\n}\n\n// Next try raw type match for instance creators\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> rawTypeCreator =\n(InstanceCreator<T>) instanceCreators.get(rawType);\nif (rawTypeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn rawTypeCreator.createInstance(type);\n}\n};\n}\n\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nreturn defaultConstructor;\n}\n\nObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\nif (defaultImplementation != null) {\nreturn defaultImplementation;\n}\n\n// finally try unsafe\nreturn newUnsafeAllocator(type, rawType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultConstructor(Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\ntry {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\n}\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"unchecked\") // T is the same raw type as is requested\n@Override public T construct() {\ntry {\nObject[] args = null;\nreturn (T) constructor.newInstance(args);\n} catch (InstantiationException e) {\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\", e);\n} catch (InvocationTargetException e) {\n// TODO: don't wrap if cause is unchecked!\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",\ne.getTargetException());\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\n}\n};\n} catch (NoSuchMethodException e) {\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultImplementationConstructor(Ljava/lang/reflect/Type;Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nfinal Type type, Class<? super T> rawType) {\nif (Collection.class.isAssignableFrom(rawType)) {\nif (SortedSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeSet<Object>();\n}\n};\n} else if (EnumSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"rawtypes\")\n@Override public T construct() {\nif (type instanceof ParameterizedType) {\nType elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\nif (elementType instanceof Class) {\nreturn (T) EnumSet.noneOf((Class)elementType);\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n}\n};\n} else if (Set.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashSet<Object>();\n}\n};\n} else if (Queue.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ArrayDeque<Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ArrayList<Object>();\n}\n};\n}\n}\n\nif (Map.class.isAssignableFrom(rawType)) {\nif (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ConcurrentSkipListMap<Object, Object>();\n}\n};\n} else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ConcurrentHashMap<Object, Object>();\n}\n};\n} else if (SortedMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeMap<Object, Object>();\n}\n};\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nTypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashMap<Object, Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedTreeMap<String, Object>();\n}\n};\n}\n}\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newUnsafeAllocator(Ljava/lang/reflect/Type;Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newUnsafeAllocator(\nfinal Type type, final Class<? super T> rawType) {\nreturn new ObjectConstructor<T>() {\nprivate final UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();\n@SuppressWarnings(\"unchecked\")\n@Override public T construct() {\ntry {\nObject newInstance = unsafeAllocator.newInstance(rawType);\nreturn (T) newInstance;\n} catch (Exception e) {\nthrow new RuntimeException((\"Unable to invoke no-args constructor for \" + type + \". \"\n+ \"Register an InstanceCreator with Gson for this type may fix this problem.\"), e);\n}\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n@Override\npublic void write(JsonWriter out, Class value) throws IOException {\nthrow new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n+ value.getName() + \". Forgot to register a type adapter?\");\n}\n@Override\npublic Class read(JsonReader in) throws IOException {\nthrow new UnsupportedOperationException(\n\"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n}\n}.nullSafe();"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:nullSafe()Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public final TypeAdapter<T> nullSafe() {\nreturn new TypeAdapter<T>() {\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (value == null) {\nout.nullValue();\n} else {\nTypeAdapter.this.write(out, value);\n}\n}\n@Override public T read(JsonReader reader) throws IOException {\nif (reader.peek() == JsonToken.NULL) {\nreader.nextNull();\nreturn null;\n}\nreturn TypeAdapter.this.read(reader);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$35:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$26:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}\n\nfinal TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\nreturn (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n@Override public Timestamp read(JsonReader in) throws IOException {\nDate date = dateTypeAdapter.read(in);\nreturn date != null ? new Timestamp(date.getTime()) : null;\n}\n\n@Override public void write(JsonWriter out, Timestamp value) throws IOException {\ndateTypeAdapter.write(out, value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$34:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$30:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nif (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {\nreturn null;\n}\nif (!rawType.isEnum()) {\nrawType = rawType.getSuperclass(); // handle anonymous subclasses\n}\nreturn (TypeAdapter<T>) new EnumTypeAdapter(rawType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<init>(Lcom/google/gson/Gson;)V",
                                    "method_body": "ObjectTypeAdapter(Gson gson) {\nthis.gson = gson;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nType elementType = $Gson$Types.getCollectionElementType(type, rawType);\nTypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // create() doesn't define a type parameter\nTypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nClass<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\nType[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\nTypeAdapter<?> keyAdapter = getKeyAdapter(gson, keyAndValueTypes[0]);\nTypeAdapter<?> valueAdapter = gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n// we don't define a type parameter for the key or value types\nTypeAdapter<T> result = new Adapter(gson, keyAndValueTypes[0], keyAdapter,\nkeyAndValueTypes[1], valueAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\nClass<? super T> rawType = targetType.getRawType();\nJsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);\nif (annotation == null) {\nreturn null;\n}\nreturn (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;Lcom/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nFieldNamingStrategy fieldNamingPolicy, Excluder excluder,\nJsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\nthis.jsonAdapterFactory = jsonAdapterFactory;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field f, boolean serialize) {\nreturn excludeField(f, serialize, excluder);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;ZLcom/google/gson/internal/Excluder;)Z",
                                    "method_body": "static boolean excludeField(Field f, boolean serialize, Excluder excluder) {\nreturn !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getFieldNames(Ljava/lang/reflect/Field;)Ljava/util/List;",
                                    "method_body": "private List<String> getFieldNames(Field f) {\nSerializedName annotation = f.getAnnotation(SerializedName.class);\nif (annotation == null) {\nString name = fieldNamingPolicy.translateName(f);\nreturn Collections.singletonList(name);\n}\n\nString serializedName = annotation.value();\nString[] alternates = annotation.alternate();\nif (alternates.length == 0) {\nreturn Collections.singletonList(serializedName);\n}\n\nList<String> fieldNames = new ArrayList<String>(alternates.length + 1);\nfieldNames.add(serializedName);\nfor (String alternate : alternates) {\nfieldNames.add(alternate);\n}\nreturn fieldNames;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\nClass<? super T> raw = type.getRawType();\n\nif (!Object.class.isAssignableFrom(raw)) {\nreturn null; // it's a primitive!\n}\n\nObjectConstructor<T> constructor = constructorConstructor.get(type);\nreturn new Adapter<T>(constructor, getBoundFields(gson, type, raw));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:createBoundField(Lcom/google/gson/Gson;Ljava/lang/reflect/Field;Ljava/lang/String;Lcom/google/gson/reflect/TypeToken;ZZ)Lcom/google/gson/internal/bind/ReflectiveTypeAdapterFactory$BoundField;",
                                    "method_body": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(\nfinal Gson context, final Field field, final String name,\nfinal TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\nfinal boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n// special casing primitives here saves ~5% on Android...\nJsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\nTypeAdapter<?> mapped = null;\nif (annotation != null) {\nmapped = jsonAdapterFactory.getTypeAdapter(\nconstructorConstructor, context, fieldType, annotation);\n}\nfinal boolean jsonAdapterPresent = mapped != null;\nif (mapped == null) mapped = context.getAdapter(fieldType);\n\nfinal TypeAdapter<?> typeAdapter = mapped;\nreturn new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n@Override void write(JsonWriter writer, Object value)\nthrows IOException, IllegalAccessException {\nObject fieldValue = field.get(value);\nTypeAdapter t = jsonAdapterPresent ? typeAdapter\n: new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\nt.write(writer, fieldValue);\n}\n@Override void read(JsonReader reader, Object value)\nthrows IOException, IllegalAccessException {\nObject fieldValue = typeAdapter.read(reader);\nif (fieldValue != null || !isPrimitive) {\nfield.set(value, fieldValue);\n}\n}\n@Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\nif (!serialized) return false;\nObject fieldValue = field.get(value);\nreturn fieldValue != value; // avoid recursion for example for Throwable.cause\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getBoundFields(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;Ljava/lang/Class;)Ljava/util/Map;",
                                    "method_body": "private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {\nMap<String, BoundField> result = new LinkedHashMap<String, BoundField>();\nif (raw.isInterface()) {\nreturn result;\n}\n\nType declaredType = type.getType();\nwhile (raw != Object.class) {\nField[] fields = raw.getDeclaredFields();\nfor (Field field : fields) {\nboolean serialize = excludeField(field, true);\nboolean deserialize = excludeField(field, false);\nif (!serialize && !deserialize) {\ncontinue;\n}\nfield.setAccessible(true);\nType fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\nList<String> fieldNames = getFieldNames(field);\nBoundField previous = null;\nfor (int i = 0, size = fieldNames.size(); i < size; ++i) {\nString name = fieldNames.get(i);\nif (i != 0) serialize = false; // only serialize the default name\nBoundField boundField = createBoundField(context, field, name,\nTypeToken.get(fieldType), serialize, deserialize);\nBoundField replaced = result.put(name, boundField);\nif (previous == null) previous = replaced;\n}\nif (previous != null) {\nthrow new IllegalArgumentException(declaredType\n+ \" declares multiple JSON fields named \" + previous.name);\n}\n}\ntype = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\nraw = type.getRawType();\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$ParameterizedTypeImpl:<init>(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n// require an owner type if the raw type needs it\nif (rawType instanceof Class<?>) {\nClass<?> rawTypeAsClass = (Class<?>) rawType;\nboolean isStaticOrTopLevelClass = Modifier.isStatic(rawTypeAsClass.getModifiers())\n|| rawTypeAsClass.getEnclosingClass() == null;\ncheckArgument(ownerType != null || isStaticOrTopLevelClass);\n}\n\nthis.ownerType = ownerType == null ? null : canonicalize(ownerType);\nthis.rawType = canonicalize(rawType);\nthis.typeArguments = typeArguments.clone();\nfor (int t = 0, length = this.typeArguments.length; t < length; t++) {\ncheckNotNull(this.typeArguments[t]);\ncheckNotPrimitive(this.typeArguments[t]);\nthis.typeArguments[t] = canonicalize(this.typeArguments[t]);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson$FutureTypeAdapter:setDelegate(Lcom/google/gson/TypeAdapter;)V",
                                    "method_body": "public void setDelegate(TypeAdapter<T> typeAdapter) {\nif (delegate != null) {\nthrow new AssertionError();\n}\ndelegate = typeAdapter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter:<init>(Lcom/google/gson/internal/ObjectConstructor;Ljava/util/Map;)V",
                                    "method_body": "abstract boolean writeField(Object value) throws IOException, IllegalAccessException;\nabstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException;\nabstract void read(JsonReader reader, Object value) throws IOException, IllegalAccessException;\n}\n\npublic static final class Adapter<T> extends TypeAdapter<T> {\nprivate final ObjectConstructor<T> constructor;\nprivate final Map<String, BoundField> boundFields;\n\nAdapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {\nthis.constructor = constructor;\nthis.boundFields = boundFields;\n}\n\n@Override public T read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\n\nT instance = constructor.construct();\n\ntry {\nin.beginObject();\nwhile (in.hasNext()) {\nString name = in.nextName();\nBoundField field = boundFields.get(name);\nif (field == null || !field.deserialized) {\nin.skipValue();\n} else {\nfield.read(in, instance);\n}\n}\n} catch (IllegalStateException e) {\nthrow new JsonSyntaxException(e);\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\nin.endObject();\nreturn instance;\n}\n\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\n\nout.beginObject();\ntry {\nfor (BoundField boundField : boundFields.values()) {\nif (boundField.writeField(value)) {\nout.name(boundField.name);\nboundField.write(out, value);\n}\n}\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\nout.endObject();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:<clinit>()V",
                                    "method_body": "private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;\n\n/** A map from wrapper types to their corresponding primitive types. */\nprivate static final Map<Class<?>, Class<?>> WRAPPER_TO_PRIMITIVE_TYPE;\n\n// Sad that we can't use a BiMap. :(\n\nstatic {\nMap<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);\nMap<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);\n\nadd(primToWrap, wrapToPrim, boolean.class, Boolean.class);\nadd(primToWrap, wrapToPrim, byte.class, Byte.class);\nadd(primToWrap, wrapToPrim, char.class, Character.class);\nadd(primToWrap, wrapToPrim, double.class, Double.class);\nadd(primToWrap, wrapToPrim, float.class, Float.class);\nadd(primToWrap, wrapToPrim, int.class, Integer.class);\nadd(primToWrap, wrapToPrim, long.class, Long.class);\nadd(primToWrap, wrapToPrim, short.class, Short.class);\nadd(primToWrap, wrapToPrim, void.class, Void.class);\n\nPRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);\nWRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:add(Ljava/util/Map;Ljava/util/Map;Ljava/lang/Class;Ljava/lang/Class;)V",
                                    "method_body": "private static void add(Map<Class<?>, Class<?>> forward,\nMap<Class<?>, Class<?>> backward, Class<?> key, Class<?> value) {\nforward.put(key, value);\nbackward.put(value, key);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:isPrimitive(Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public static boolean isPrimitive(Type type) {\nreturn PRIMITIVE_TO_WRAPPER_TYPE.containsKey(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$BoundField:<init>(Ljava/lang/String;ZZ)V",
                                    "method_body": "protected BoundField(String name, boolean serialized, boolean deserialized) {\nthis.name = name;\nthis.serialized = serialized;\nthis.deserialized = deserialized;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.UnsafeAllocator:create()Lcom/google/gson/internal/UnsafeAllocator;",
                                    "method_body": "public abstract <T> T newInstance(Class<T> c) throws Exception;\n\npublic static UnsafeAllocator create() {\n// try JVM\n// public class Unsafe {\n//   public Object allocateInstance(Class<?> type);\n// }\ntry {\nClass<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\nField f = unsafeClass.getDeclaredField(\"theUnsafe\");\nf.setAccessible(true);\nfinal Object unsafe = f.get(null);\nfinal Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nassertInstantiable(c);\nreturn (T) allocateInstance.invoke(unsafe, c);\n}\n};\n} catch (Exception ignored) {\n}\n\n// try dalvikvm, post-gingerbread\n// public class ObjectStreamClass {\n//   private static native int getConstructorId(Class<?> c);\n//   private static native Object newInstance(Class<?> instantiationClass, int methodId);\n// }\ntry {\nMethod getConstructorId = ObjectStreamClass.class\n.getDeclaredMethod(\"getConstructorId\", Class.class);\ngetConstructorId.setAccessible(true);\nfinal int constructorId = (Integer) getConstructorId.invoke(null, Object.class);\nfinal Method newInstance = ObjectStreamClass.class\n.getDeclaredMethod(\"newInstance\", Class.class, int.class);\nnewInstance.setAccessible(true);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nassertInstantiable(c);\nreturn (T) newInstance.invoke(null, c, constructorId);\n}\n};\n} catch (Exception ignored) {\n}\n\n// try dalvikvm, pre-gingerbread\n// public class ObjectInputStream {\n//   private static native Object newInstance(\n//     Class<?> instantiationClass, Class<?> constructorClass);\n// }\ntry {\nfinal Method newInstance = ObjectInputStream.class\n.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\nnewInstance.setAccessible(true);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nassertInstantiable(c);\nreturn (T) newInstance.invoke(null, c, Object.class);\n}\n};\n} catch (Exception ignored) {\n}\n\n// give up\nreturn new UnsafeAllocator() {\n@Override\npublic <T> T newInstance(Class<T> c) {\nthrow new UnsupportedOperationException(\"Cannot allocate \" + c);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:equal(Ljava/lang/Object;Ljava/lang/Object;)Z",
                                    "method_body": "static boolean equal(Object a, Object b) {\nreturn a == b || (a != null && a.equals(b));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\ncheckArgument(supertype.isAssignableFrom(contextRawType));\nreturn resolve(context, contextRawType,\n$Gson$Types.getGenericSupertype(context, contextRawType, supertype));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getArrayComponentType(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type getArrayComponentType(Type array) {\nreturn array instanceof GenericArrayType\n? ((GenericArrayType) array).getGenericComponentType()\n: ((Class<?>) array).getComponentType();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getCollectionElementType(Ljava/lang/reflect/Type;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type getCollectionElementType(Type context, Class<?> contextRawType) {\nType collectionType = getSupertype(context, contextRawType, Collection.class);\n\nif (collectionType instanceof WildcardType) {\ncollectionType = ((WildcardType)collectionType).getUpperBounds()[0];\n}\nif (collectionType instanceof ParameterizedType) {\nreturn ((ParameterizedType) collectionType).getActualTypeArguments()[0];\n}\nreturn Object.class;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<init>(Lcom/google/gson/Gson;Lcom/google/gson/TypeAdapter;Ljava/lang/Class;)V",
                                    "method_body": "public ArrayTypeAdapter(Gson context, TypeAdapter<E> componentTypeAdapter, Class<E> componentType) {\nthis.componentTypeAdapter =\nnew TypeAdapterRuntimeTypeWrapper<E>(context, componentTypeAdapter, componentType);\nthis.componentType = componentType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:<init>(Lcom/google/gson/Gson;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeAdapterRuntimeTypeWrapper(Gson context, TypeAdapter<T> delegate, Type type) {\nthis.context = context;\nthis.delegate = delegate;\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory$Adapter:<init>(Lcom/google/gson/Gson;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Lcom/google/gson/internal/ObjectConstructor;)V",
                                    "method_body": "public Adapter(Gson context, Type elementType,\nTypeAdapter<E> elementTypeAdapter,\nObjectConstructor<? extends Collection<E>> constructor) {\nthis.elementTypeAdapter =\nnew TypeAdapterRuntimeTypeWrapper<E>(context, elementTypeAdapter, elementType);\nthis.constructor = constructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$GenericArrayTypeImpl:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "public GenericArrayTypeImpl(Type componentType) {\nthis.componentType = canonicalize(componentType);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.internal.bind.RecursiveTypesResolveTest.testDoubleSubtype",
                            "test_body": "75: public void testDoubleSubtype() {\n76: assertEquals($Gson$Types.subtypeOf(Number.class),\n77: $Gson$Types.subtypeOf($Gson$Types.subtypeOf(Number.class)));\n78: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nthrow new NullPointerException();\n}\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\nthrow new IllegalArgumentException();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\np.getRawType(), p.getActualTypeArguments());\n\n} else if (type instanceof GenericArrayType) {\nGenericArrayType g = (GenericArrayType) type;\nreturn new GenericArrayTypeImpl(g.getGenericComponentType());\n\n} else if (type instanceof WildcardType) {\nWildcardType w = (WildcardType) type;\nreturn new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n} else {\n// type is either serializable as-is or unsupported\nreturn type;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:equals(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public static boolean equals(Type a, Type b) {\nif (a == b) {\n// also handles (a == null && b == null)\nreturn true;\n\n} else if (a instanceof Class) {\n// Class already specifies equals().\nreturn a.equals(b);\n\n} else if (a instanceof ParameterizedType) {\nif (!(b instanceof ParameterizedType)) {\nreturn false;\n}\n\n// TODO: save a .clone() call\nParameterizedType pa = (ParameterizedType) a;\nParameterizedType pb = (ParameterizedType) b;\nreturn equal(pa.getOwnerType(), pb.getOwnerType())\n&& pa.getRawType().equals(pb.getRawType())\n&& Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());\n\n} else if (a instanceof GenericArrayType) {\nif (!(b instanceof GenericArrayType)) {\nreturn false;\n}\n\nGenericArrayType ga = (GenericArrayType) a;\nGenericArrayType gb = (GenericArrayType) b;\nreturn equals(ga.getGenericComponentType(), gb.getGenericComponentType());\n\n} else if (a instanceof WildcardType) {\nif (!(b instanceof WildcardType)) {\nreturn false;\n}\n\nWildcardType wa = (WildcardType) a;\nWildcardType wb = (WildcardType) b;\nreturn Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())\n&& Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());\n\n} else if (a instanceof TypeVariable) {\nif (!(b instanceof TypeVariable)) {\nreturn false;\n}\nTypeVariable<?> va = (TypeVariable<?>) a;\nTypeVariable<?> vb = (TypeVariable<?>) b;\nreturn va.getGenericDeclaration() == vb.getGenericDeclaration()\n&& va.getName().equals(vb.getName());\n\n} else {\n// This isn't a type we support. Could be a generic array type, wildcard type, etc.\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:typeToString(Ljava/lang/reflect/Type;)Ljava/lang/String;",
                                    "method_body": "public static String typeToString(Type type) {\nreturn type instanceof Class ? ((Class<?>) type).getName() : type.toString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$WildcardTypeImpl:<init>([Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\ncheckArgument(lowerBounds.length <= 1);\ncheckArgument(upperBounds.length == 1);\n\nif (lowerBounds.length == 1) {\ncheckNotNull(lowerBounds[0]);\ncheckNotPrimitive(lowerBounds[0]);\ncheckArgument(upperBounds[0] == Object.class);\nthis.lowerBound = canonicalize(lowerBounds[0]);\nthis.upperBound = Object.class;\n\n} else {\ncheckNotNull(upperBounds[0]);\ncheckNotPrimitive(upperBounds[0]);\nthis.lowerBound = null;\nthis.upperBound = canonicalize(upperBounds[0]);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:subtypeOf(Ljava/lang/reflect/Type;)Ljava/lang/reflect/WildcardType;",
                                    "method_body": "public static WildcardType subtypeOf(Type bound) {\nType[] upperBounds;\nupperBounds = new Type[] { bound };\nreturn new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.internal.bind.RecursiveTypesResolveTest.testSubSupertype",
                            "test_body": "85: public void testSubSupertype() {\n86: assertEquals($Gson$Types.subtypeOf(Object.class),\n87: $Gson$Types.subtypeOf($Gson$Types.supertypeOf(Number.class)));\n88: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nthrow new NullPointerException();\n}\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\nthrow new IllegalArgumentException();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:supertypeOf(Ljava/lang/reflect/Type;)Ljava/lang/reflect/WildcardType;",
                                    "method_body": "public static WildcardType supertypeOf(Type bound) {\nType[] lowerBounds;\nlowerBounds = new Type[] { bound };\nreturn new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\np.getRawType(), p.getActualTypeArguments());\n\n} else if (type instanceof GenericArrayType) {\nGenericArrayType g = (GenericArrayType) type;\nreturn new GenericArrayTypeImpl(g.getGenericComponentType());\n\n} else if (type instanceof WildcardType) {\nWildcardType w = (WildcardType) type;\nreturn new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n} else {\n// type is either serializable as-is or unsupported\nreturn type;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:equals(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public static boolean equals(Type a, Type b) {\nif (a == b) {\n// also handles (a == null && b == null)\nreturn true;\n\n} else if (a instanceof Class) {\n// Class already specifies equals().\nreturn a.equals(b);\n\n} else if (a instanceof ParameterizedType) {\nif (!(b instanceof ParameterizedType)) {\nreturn false;\n}\n\n// TODO: save a .clone() call\nParameterizedType pa = (ParameterizedType) a;\nParameterizedType pb = (ParameterizedType) b;\nreturn equal(pa.getOwnerType(), pb.getOwnerType())\n&& pa.getRawType().equals(pb.getRawType())\n&& Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());\n\n} else if (a instanceof GenericArrayType) {\nif (!(b instanceof GenericArrayType)) {\nreturn false;\n}\n\nGenericArrayType ga = (GenericArrayType) a;\nGenericArrayType gb = (GenericArrayType) b;\nreturn equals(ga.getGenericComponentType(), gb.getGenericComponentType());\n\n} else if (a instanceof WildcardType) {\nif (!(b instanceof WildcardType)) {\nreturn false;\n}\n\nWildcardType wa = (WildcardType) a;\nWildcardType wb = (WildcardType) b;\nreturn Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())\n&& Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());\n\n} else if (a instanceof TypeVariable) {\nif (!(b instanceof TypeVariable)) {\nreturn false;\n}\nTypeVariable<?> va = (TypeVariable<?>) a;\nTypeVariable<?> vb = (TypeVariable<?>) b;\nreturn va.getGenericDeclaration() == vb.getGenericDeclaration()\n&& va.getName().equals(vb.getName());\n\n} else {\n// This isn't a type we support. Could be a generic array type, wildcard type, etc.\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:typeToString(Ljava/lang/reflect/Type;)Ljava/lang/String;",
                                    "method_body": "public static String typeToString(Type type) {\nreturn type instanceof Class ? ((Class<?>) type).getName() : type.toString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$WildcardTypeImpl:<init>([Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\ncheckArgument(lowerBounds.length <= 1);\ncheckArgument(upperBounds.length == 1);\n\nif (lowerBounds.length == 1) {\ncheckNotNull(lowerBounds[0]);\ncheckNotPrimitive(lowerBounds[0]);\ncheckArgument(upperBounds[0] == Object.class);\nthis.lowerBound = canonicalize(lowerBounds[0]);\nthis.upperBound = Object.class;\n\n} else {\ncheckNotNull(upperBounds[0]);\ncheckNotPrimitive(upperBounds[0]);\nthis.lowerBound = null;\nthis.upperBound = canonicalize(upperBounds[0]);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:subtypeOf(Ljava/lang/reflect/Type;)Ljava/lang/reflect/WildcardType;",
                                    "method_body": "public static WildcardType subtypeOf(Type bound) {\nType[] upperBounds;\nupperBounds = new Type[] { bound };\nreturn new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.internal.bind.RecursiveTypesResolveTest.testRecursiveResolveSimple",
                            "test_body": "48: public void testRecursiveResolveSimple() {\n49: TypeAdapter<Foo1> adapter = new Gson().getAdapter(Foo1.class);\n50: assertNotNull(adapter);\n51: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nthrow new NullPointerException();\n}\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\nthrow new IllegalArgumentException();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:supertypeOf(Ljava/lang/reflect/Type;)Ljava/lang/reflect/WildcardType;",
                                    "method_body": "public static WildcardType supertypeOf(Type bound) {\nType[] lowerBounds;\nlowerBounds = new Type[] { bound };\nreturn new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\np.getRawType(), p.getActualTypeArguments());\n\n} else if (type instanceof GenericArrayType) {\nGenericArrayType g = (GenericArrayType) type;\nreturn new GenericArrayTypeImpl(g.getGenericComponentType());\n\n} else if (type instanceof WildcardType) {\nWildcardType w = (WildcardType) type;\nreturn new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n} else {\n// type is either serializable as-is or unsupported\nreturn type;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$WildcardTypeImpl:<init>([Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\ncheckArgument(lowerBounds.length <= 1);\ncheckArgument(upperBounds.length == 1);\n\nif (lowerBounds.length == 1) {\ncheckNotNull(lowerBounds[0]);\ncheckNotPrimitive(lowerBounds[0]);\ncheckArgument(upperBounds[0] == Object.class);\nthis.lowerBound = canonicalize(lowerBounds[0]);\nthis.upperBound = Object.class;\n\n} else {\ncheckNotNull(upperBounds[0]);\ncheckNotPrimitive(upperBounds[0]);\nthis.lowerBound = null;\nthis.upperBound = canonicalize(upperBounds[0]);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\nCollections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\nDEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\nDEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\nLongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,\nfinal Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,\nboolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\nboolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,\nLongSerializationPolicy longSerializationPolicy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.excluder = excluder;\nthis.fieldNamingStrategy = fieldNamingStrategy;\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nthis.lenient = lenient;\n\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n\n// built-in type adapters that cannot be overridden\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\n\n// the excluder must precede all adapters that handle user-defined types\nfactories.add(excluder);\n\n// user's type adapters\nfactories.addAll(typeAdapterFactories);\n\n// type adapters for basic platform types\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nTypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\ndoubleAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfloatAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\nfactories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\nfactories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.CURRENCY_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\n\n// type adapters for composite and user-defined types\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nthis.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);\nfactories.add(jsonAdapterFactory);\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nconstructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory));\n\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<clinit>()V",
                                    "method_body": "static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\nstatic final boolean DEFAULT_LENIENT = false;\nstatic final boolean DEFAULT_PRETTY_PRINT = false;\nstatic final boolean DEFAULT_ESCAPE_HTML = true;\nstatic final boolean DEFAULT_SERIALIZE_NULLS = false;\nstatic final boolean DEFAULT_COMPLEX_MAP_KEYS = false;\nstatic final boolean DEFAULT_SPECIALIZE_FLOAT_VALUES = false;\n\nprivate static final TypeToken<?> NULL_KEY_SURROGATE = TypeToken.get(Object.class);\nprivate static final String JSON_NON_EXECUTABLE_PREFIX = \")]}'\\n\";\n\n/**\n* This thread local guards against reentrant calls to getAdapter(). In\n* certain object graphs, creating an adapter for a type may recursively\n* require an adapter for the same type! Without intervention, the recursive\n* lookup would stack overflow. We cheat by returning a proxy type adapter.\n* The proxy is wired up once the initial adapter has been created.\n*/\nprivate final ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>> calls\n= new ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>>();\n\nprivate final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache = new ConcurrentHashMap<TypeToken<?>, TypeAdapter<?>>();\n\nprivate final List<TypeAdapterFactory> factories;\nprivate final ConstructorConstructor constructorConstructor;\n\nprivate final Excluder excluder;\nprivate final FieldNamingStrategy fieldNamingStrategy;\nprivate final boolean serializeNulls;\nprivate final boolean htmlSafe;\nprivate final boolean generateNonExecutableJson;\nprivate final boolean prettyPrinting;\nprivate final boolean lenient;\nprivate final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;\n\n/**\n* Constructs a Gson object with default configuration. The default configuration has the\n* following settings:\n* <ul>\n*   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n*   means that all the unneeded white-space is removed. You can change this behavior with\n*   {@link GsonBuilder#setPrettyPrinting()}. </li>"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.DOUBLE;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Double read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\ndouble doubleValue = value.doubleValue();\ncheckValidFloatingPoint(doubleValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.FLOAT;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Float read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn (float) in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nfloat floatValue = value.floatValue();\ncheckValidFloatingPoint(floatValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Number read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextLong();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nout.value(value.toString());\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLong>() {\n@Override public void write(JsonWriter out, AtomicLong value) throws IOException {\nlongAdapter.write(out, value.get());\n}\n@Override public AtomicLong read(JsonReader in) throws IOException {\nNumber value = longAdapter.read(in);\nreturn new AtomicLong(value.longValue());\n}\n}.nullSafe();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongArrayAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLongArray>() {\n@Override public void write(JsonWriter out, AtomicLongArray value) throws IOException {\nout.beginArray();\nfor (int i = 0, length = value.length(); i < length; i++) {\nlongAdapter.write(out, value.get(i));\n}\nout.endArray();\n}\n@Override public AtomicLongArray read(JsonReader in) throws IOException {\nList<Long> list = new ArrayList<Long>();\nin.beginArray();\nwhile (in.hasNext()) {\nlong value = longAdapter.read(in).longValue();\nlist.add(value);\n}\nin.endArray();\nint length = list.size();\nAtomicLongArray array = new AtomicLongArray(length);\nfor (int i = 0; i < length; ++i) {\narray.set(i, list.get(i));\n}\nreturn array;\n}\n}.nullSafe();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);\nif (cached != null) {\nreturn (TypeAdapter<T>) cached;\n}\n\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\n}\n\n// the key and value type parameters always agree\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nreturn ongoingCall;\n}\n\ntry {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\n\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\n}\n}\nthrow new IllegalArgumentException(\"GSON cannot handle \" + type);\n} finally {\nthreadCalls.remove(type);\n\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Ljava/lang/Class;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(Class<T> type) {\nreturn getAdapter(TypeToken.get(type));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/Class;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static <T> TypeToken<T> get(Class<T> type) {\nreturn new TypeToken<T>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:newParameterizedTypeWithOwner(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)Ljava/lang/reflect/ParameterizedType;",
                                    "method_body": "public static ParameterizedType newParameterizedTypeWithOwner(\nType ownerType, Type rawType, Type... typeArguments) {\nreturn new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\n// type is a normal class.\nreturn (Class<?>) type;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType parameterizedType = (ParameterizedType) type;\n\n// I'm not exactly sure why getRawType() returns Type instead of Class.\n// Neal isn't either but suspects some pathological case related\n// to nested classes exists.\nType rawType = parameterizedType.getRawType();\ncheckArgument(rawType instanceof Class);\nreturn (Class<?>) rawType;\n\n} else if (type instanceof GenericArrayType) {\nType componentType = ((GenericArrayType)type).getGenericComponentType();\nreturn Array.newInstance(getRawType(componentType), 0).getClass();\n\n} else if (type instanceof TypeVariable) {\n// we could use the variable's bounds, but that won't work if there are multiple.\n// having a raw type that's more general than necessary is okay\nreturn Object.class;\n\n} else if (type instanceof WildcardType) {\nreturn getRawType(((WildcardType) type).getUpperBounds()[0]);\n\n} else {\nString className = type == null ? \"null\" : type.getClass().getName();\nthrow new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n+ \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:hashCodeOrZero(Ljava/lang/Object;)I",
                                    "method_body": "static int hashCodeOrZero(Object o) {\nreturn o != null ? o.hashCode() : 0;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getGenericSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\nif (toResolve == rawType) {\nreturn context;\n}\n\n// we skip searching through interfaces if unknown is an interface\nif (toResolve.isInterface()) {\nClass<?>[] interfaces = rawType.getInterfaces();\nfor (int i = 0, length = interfaces.length; i < length; i++) {\nif (interfaces[i] == toResolve) {\nreturn rawType.getGenericInterfaces()[i];\n} else if (toResolve.isAssignableFrom(interfaces[i])) {\nreturn getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n}\n}\n}\n\n// check our supertypes\nif (!rawType.isInterface()) {\nwhile (rawType != Object.class) {\nClass<?> rawSupertype = rawType.getSuperclass();\nif (rawSupertype == toResolve) {\nreturn rawType.getGenericSuperclass();\n} else if (toResolve.isAssignableFrom(rawSupertype)) {\nreturn getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);\n}\nrawType = rawSupertype;\n}\n}\n\n// we can't resolve this further\nreturn toResolve;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\n// this implementation is made a little more complicated in an attempt to avoid object-creation\nwhile (true) {\nif (toResolve instanceof TypeVariable) {\nTypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\ntoResolve = resolveTypeVariable(context, contextRawType, typeVariable);\nif (toResolve == typeVariable) {\nreturn toResolve;\n}\n\n} else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\nClass<?> original = (Class<?>) toResolve;\nType componentType = original.getComponentType();\nType newComponentType = resolve(context, contextRawType, componentType);\nreturn componentType == newComponentType\n? original\n: arrayOf(newComponentType);\n\n} else if (toResolve instanceof GenericArrayType) {\nGenericArrayType original = (GenericArrayType) toResolve;\nType componentType = original.getGenericComponentType();\nType newComponentType = resolve(context, contextRawType, componentType);\nreturn componentType == newComponentType\n? original\n: arrayOf(newComponentType);\n\n} else if (toResolve instanceof ParameterizedType) {\nParameterizedType original = (ParameterizedType) toResolve;\nType ownerType = original.getOwnerType();\nType newOwnerType = resolve(context, contextRawType, ownerType);\nboolean changed = newOwnerType != ownerType;\n\nType[] args = original.getActualTypeArguments();\nfor (int t = 0, length = args.length; t < length; t++) {\nType resolvedTypeArgument = resolve(context, contextRawType, args[t]);\nif (resolvedTypeArgument != args[t]) {\nif (!changed) {\nargs = args.clone();\nchanged = true;\n}\nargs[t] = resolvedTypeArgument;\n}\n}\n\nreturn changed\n? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n: original;\n\n} else if (toResolve instanceof WildcardType) {\nWildcardType original = (WildcardType) toResolve;\nType[] originalLowerBound = original.getLowerBounds();\nType[] originalUpperBound = original.getUpperBounds();\n\nif (originalLowerBound.length == 1) {\nType lowerBound = resolve(context, contextRawType, originalLowerBound[0]);\nif (lowerBound != originalLowerBound[0]) {\nreturn supertypeOf(lowerBound);\n}\n} else if (originalUpperBound.length == 1) {\nType upperBound = resolve(context, contextRawType, originalUpperBound[0]);\nif (upperBound != originalUpperBound[0]) {\nreturn subtypeOf(upperBound);\n}\n}\nreturn original;\n\n} else {\nreturn toResolve;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolveTypeVariable(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/TypeVariable;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\nClass<?> declaredByRaw = declaringClassOf(unknown);\n\n// we can't reduce this further\nif (declaredByRaw == null) {\nreturn unknown;\n}\n\nType declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\nif (declaredBy instanceof ParameterizedType) {\nint index = indexOf(declaredByRaw.getTypeParameters(), unknown);\nreturn ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\n}\n\nreturn unknown;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:indexOf([Ljava/lang/Object;Ljava/lang/Object;)I",
                                    "method_body": "private static int indexOf(Object[] array, Object toFind) {\nfor (int i = 0, length = array.length; i < length; i++) {\nif (toFind.equals(array[i])) {\nreturn i;\n}\n}\nthrow new NoSuchElementException();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:declaringClassOf(Ljava/lang/reflect/TypeVariable;)Ljava/lang/Class;",
                                    "method_body": "private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\nGenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\nreturn genericDeclaration instanceof Class\n? (Class<?>) genericDeclaration\n: null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\n\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate boolean requireExpose;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n\n@Override protected Excluder clone() {\ntry {\nreturn (Excluder) super.clone();\n} catch (CloneNotSupportedException e) {\nthrow new AssertionError(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\n\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}\n\nreturn new TypeAdapter<T>() {\n/** The delegate is lazily created because it may not be needed, and creating it may fail. */\nprivate TypeAdapter<T> delegate;\n\n@Override public T read(JsonReader in) throws IOException {\nif (skipDeserialize) {\nin.skipValue();\nreturn null;\n}\nreturn delegate().read(in);\n}\n\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (skipSerialize) {\nout.nullValue();\nreturn;\n}\ndelegate().write(out, value);\n}\n\nprivate TypeAdapter<T> delegate() {\nTypeAdapter<T> d = delegate;\nreturn d != null\n? d\n: (delegate = gson.getDelegateAdapter(Excluder.this, type));\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field field, boolean serialize) {\nif ((modifiers & field.getModifiers()) != 0) {\nreturn true;\n}\n\nif (version != Excluder.IGNORE_VERSIONS\n&& !isValidVersion(field.getAnnotation(Since.class), field.getAnnotation(Until.class))) {\nreturn true;\n}\n\nif (field.isSynthetic()) {\nreturn true;\n}\n\nif (requireExpose) {\nExpose annotation = field.getAnnotation(Expose.class);\nif (annotation == null || (serialize ? !annotation.serialize() : !annotation.deserialize())) {\nreturn true;\n}\n}\n\nif (!serializeInnerClasses && isInnerClass(field.getType())) {\nreturn true;\n}\n\nif (isAnonymousOrLocal(field.getType())) {\nreturn true;\n}\n\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nif (!list.isEmpty()) {\nFieldAttributes fieldAttributes = new FieldAttributes(field);\nfor (ExclusionStrategy exclusionStrategy : list) {\nif (exclusionStrategy.shouldSkipField(fieldAttributes)) {\nreturn true;\n}\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\n&& !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\nreturn true;\n}\n\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nreturn true;\n}\n\nif (isAnonymousOrLocal(clazz)) {\nreturn true;\n}\n\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nif (exclusionStrategy.shouldSkipClass(clazz)) {\nreturn true;\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n&& (clazz.isAnonymousClass() || clazz.isLocalClass());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.FieldNamingPolicy$1:translateName(Ljava/lang/reflect/Field;)Ljava/lang/String;",
                                    "method_body": "@Override public String translateName(Field f) {\nreturn f.getName();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\n\n// first try an instance creator\n\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn typeCreator.createInstance(type);\n}\n};\n}\n\n// Next try raw type match for instance creators\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> rawTypeCreator =\n(InstanceCreator<T>) instanceCreators.get(rawType);\nif (rawTypeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn rawTypeCreator.createInstance(type);\n}\n};\n}\n\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nreturn defaultConstructor;\n}\n\nObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\nif (defaultImplementation != null) {\nreturn defaultImplementation;\n}\n\n// finally try unsafe\nreturn newUnsafeAllocator(type, rawType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultConstructor(Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\ntry {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\n}\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"unchecked\") // T is the same raw type as is requested\n@Override public T construct() {\ntry {\nObject[] args = null;\nreturn (T) constructor.newInstance(args);\n} catch (InstantiationException e) {\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\", e);\n} catch (InvocationTargetException e) {\n// TODO: don't wrap if cause is unchecked!\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",\ne.getTargetException());\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\n}\n};\n} catch (NoSuchMethodException e) {\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n@Override\npublic void write(JsonWriter out, Class value) throws IOException {\nthrow new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n+ value.getName() + \". Forgot to register a type adapter?\");\n}\n@Override\npublic Class read(JsonReader in) throws IOException {\nthrow new UnsupportedOperationException(\n\"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n}\n}.nullSafe();"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:nullSafe()Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public final TypeAdapter<T> nullSafe() {\nreturn new TypeAdapter<T>() {\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (value == null) {\nout.nullValue();\n} else {\nTypeAdapter.this.write(out, value);\n}\n}\n@Override public T read(JsonReader reader) throws IOException {\nif (reader.peek() == JsonToken.NULL) {\nreader.nextNull();\nreturn null;\n}\nreturn TypeAdapter.this.read(reader);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$35:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$26:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}\n\nfinal TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\nreturn (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n@Override public Timestamp read(JsonReader in) throws IOException {\nDate date = dateTypeAdapter.read(in);\nreturn date != null ? new Timestamp(date.getTime()) : null;\n}\n\n@Override public void write(JsonWriter out, Timestamp value) throws IOException {\ndateTypeAdapter.write(out, value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$34:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$30:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nif (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {\nreturn null;\n}\nif (!rawType.isEnum()) {\nrawType = rawType.getSuperclass(); // handle anonymous subclasses\n}\nreturn (TypeAdapter<T>) new EnumTypeAdapter(rawType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nType elementType = $Gson$Types.getCollectionElementType(type, rawType);\nTypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // create() doesn't define a type parameter\nTypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nClass<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\nType[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\nTypeAdapter<?> keyAdapter = getKeyAdapter(gson, keyAndValueTypes[0]);\nTypeAdapter<?> valueAdapter = gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n// we don't define a type parameter for the key or value types\nTypeAdapter<T> result = new Adapter(gson, keyAndValueTypes[0], keyAdapter,\nkeyAndValueTypes[1], valueAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\nClass<? super T> rawType = targetType.getRawType();\nJsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);\nif (annotation == null) {\nreturn null;\n}\nreturn (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;Lcom/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nFieldNamingStrategy fieldNamingPolicy, Excluder excluder,\nJsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\nthis.jsonAdapterFactory = jsonAdapterFactory;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field f, boolean serialize) {\nreturn excludeField(f, serialize, excluder);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;ZLcom/google/gson/internal/Excluder;)Z",
                                    "method_body": "static boolean excludeField(Field f, boolean serialize, Excluder excluder) {\nreturn !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getFieldNames(Ljava/lang/reflect/Field;)Ljava/util/List;",
                                    "method_body": "private List<String> getFieldNames(Field f) {\nSerializedName annotation = f.getAnnotation(SerializedName.class);\nif (annotation == null) {\nString name = fieldNamingPolicy.translateName(f);\nreturn Collections.singletonList(name);\n}\n\nString serializedName = annotation.value();\nString[] alternates = annotation.alternate();\nif (alternates.length == 0) {\nreturn Collections.singletonList(serializedName);\n}\n\nList<String> fieldNames = new ArrayList<String>(alternates.length + 1);\nfieldNames.add(serializedName);\nfor (String alternate : alternates) {\nfieldNames.add(alternate);\n}\nreturn fieldNames;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\nClass<? super T> raw = type.getRawType();\n\nif (!Object.class.isAssignableFrom(raw)) {\nreturn null; // it's a primitive!\n}\n\nObjectConstructor<T> constructor = constructorConstructor.get(type);\nreturn new Adapter<T>(constructor, getBoundFields(gson, type, raw));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:createBoundField(Lcom/google/gson/Gson;Ljava/lang/reflect/Field;Ljava/lang/String;Lcom/google/gson/reflect/TypeToken;ZZ)Lcom/google/gson/internal/bind/ReflectiveTypeAdapterFactory$BoundField;",
                                    "method_body": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(\nfinal Gson context, final Field field, final String name,\nfinal TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\nfinal boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n// special casing primitives here saves ~5% on Android...\nJsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\nTypeAdapter<?> mapped = null;\nif (annotation != null) {\nmapped = jsonAdapterFactory.getTypeAdapter(\nconstructorConstructor, context, fieldType, annotation);\n}\nfinal boolean jsonAdapterPresent = mapped != null;\nif (mapped == null) mapped = context.getAdapter(fieldType);\n\nfinal TypeAdapter<?> typeAdapter = mapped;\nreturn new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n@Override void write(JsonWriter writer, Object value)\nthrows IOException, IllegalAccessException {\nObject fieldValue = field.get(value);\nTypeAdapter t = jsonAdapterPresent ? typeAdapter\n: new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\nt.write(writer, fieldValue);\n}\n@Override void read(JsonReader reader, Object value)\nthrows IOException, IllegalAccessException {\nObject fieldValue = typeAdapter.read(reader);\nif (fieldValue != null || !isPrimitive) {\nfield.set(value, fieldValue);\n}\n}\n@Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\nif (!serialized) return false;\nObject fieldValue = field.get(value);\nreturn fieldValue != value; // avoid recursion for example for Throwable.cause\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getBoundFields(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;Ljava/lang/Class;)Ljava/util/Map;",
                                    "method_body": "private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {\nMap<String, BoundField> result = new LinkedHashMap<String, BoundField>();\nif (raw.isInterface()) {\nreturn result;\n}\n\nType declaredType = type.getType();\nwhile (raw != Object.class) {\nField[] fields = raw.getDeclaredFields();\nfor (Field field : fields) {\nboolean serialize = excludeField(field, true);\nboolean deserialize = excludeField(field, false);\nif (!serialize && !deserialize) {\ncontinue;\n}\nfield.setAccessible(true);\nType fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\nList<String> fieldNames = getFieldNames(field);\nBoundField previous = null;\nfor (int i = 0, size = fieldNames.size(); i < size; ++i) {\nString name = fieldNames.get(i);\nif (i != 0) serialize = false; // only serialize the default name\nBoundField boundField = createBoundField(context, field, name,\nTypeToken.get(fieldType), serialize, deserialize);\nBoundField replaced = result.put(name, boundField);\nif (previous == null) previous = replaced;\n}\nif (previous != null) {\nthrow new IllegalArgumentException(declaredType\n+ \" declares multiple JSON fields named \" + previous.name);\n}\n}\ntype = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\nraw = type.getRawType();\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$ParameterizedTypeImpl:<init>(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n// require an owner type if the raw type needs it\nif (rawType instanceof Class<?>) {\nClass<?> rawTypeAsClass = (Class<?>) rawType;\nboolean isStaticOrTopLevelClass = Modifier.isStatic(rawTypeAsClass.getModifiers())\n|| rawTypeAsClass.getEnclosingClass() == null;\ncheckArgument(ownerType != null || isStaticOrTopLevelClass);\n}\n\nthis.ownerType = ownerType == null ? null : canonicalize(ownerType);\nthis.rawType = canonicalize(rawType);\nthis.typeArguments = typeArguments.clone();\nfor (int t = 0, length = this.typeArguments.length; t < length; t++) {\ncheckNotNull(this.typeArguments[t]);\ncheckNotPrimitive(this.typeArguments[t]);\nthis.typeArguments[t] = canonicalize(this.typeArguments[t]);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:<clinit>()V",
                                    "method_body": "private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;\n\n/** A map from wrapper types to their corresponding primitive types. */\nprivate static final Map<Class<?>, Class<?>> WRAPPER_TO_PRIMITIVE_TYPE;\n\n// Sad that we can't use a BiMap. :(\n\nstatic {\nMap<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);\nMap<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);\n\nadd(primToWrap, wrapToPrim, boolean.class, Boolean.class);\nadd(primToWrap, wrapToPrim, byte.class, Byte.class);\nadd(primToWrap, wrapToPrim, char.class, Character.class);\nadd(primToWrap, wrapToPrim, double.class, Double.class);\nadd(primToWrap, wrapToPrim, float.class, Float.class);\nadd(primToWrap, wrapToPrim, int.class, Integer.class);\nadd(primToWrap, wrapToPrim, long.class, Long.class);\nadd(primToWrap, wrapToPrim, short.class, Short.class);\nadd(primToWrap, wrapToPrim, void.class, Void.class);\n\nPRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);\nWRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:add(Ljava/util/Map;Ljava/util/Map;Ljava/lang/Class;Ljava/lang/Class;)V",
                                    "method_body": "private static void add(Map<Class<?>, Class<?>> forward,\nMap<Class<?>, Class<?>> backward, Class<?> key, Class<?> value) {\nforward.put(key, value);\nbackward.put(value, key);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:isPrimitive(Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public static boolean isPrimitive(Type type) {\nreturn PRIMITIVE_TO_WRAPPER_TYPE.containsKey(type);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.internal.bind.RecursiveTypesResolveTest.testIssue440WeakReference",
                            "test_body": "61: public void testIssue440WeakReference() throws Exception {\n62: TypeAdapter<WeakReference> adapter = new Gson().getAdapter(WeakReference.class);\n63: assertNotNull(adapter);\n64: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nthrow new NullPointerException();\n}\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\nthrow new IllegalArgumentException();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:supertypeOf(Ljava/lang/reflect/Type;)Ljava/lang/reflect/WildcardType;",
                                    "method_body": "public static WildcardType supertypeOf(Type bound) {\nType[] lowerBounds;\nlowerBounds = new Type[] { bound };\nreturn new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\np.getRawType(), p.getActualTypeArguments());\n\n} else if (type instanceof GenericArrayType) {\nGenericArrayType g = (GenericArrayType) type;\nreturn new GenericArrayTypeImpl(g.getGenericComponentType());\n\n} else if (type instanceof WildcardType) {\nWildcardType w = (WildcardType) type;\nreturn new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n} else {\n// type is either serializable as-is or unsupported\nreturn type;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:equals(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public static boolean equals(Type a, Type b) {\nif (a == b) {\n// also handles (a == null && b == null)\nreturn true;\n\n} else if (a instanceof Class) {\n// Class already specifies equals().\nreturn a.equals(b);\n\n} else if (a instanceof ParameterizedType) {\nif (!(b instanceof ParameterizedType)) {\nreturn false;\n}\n\n// TODO: save a .clone() call\nParameterizedType pa = (ParameterizedType) a;\nParameterizedType pb = (ParameterizedType) b;\nreturn equal(pa.getOwnerType(), pb.getOwnerType())\n&& pa.getRawType().equals(pb.getRawType())\n&& Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());\n\n} else if (a instanceof GenericArrayType) {\nif (!(b instanceof GenericArrayType)) {\nreturn false;\n}\n\nGenericArrayType ga = (GenericArrayType) a;\nGenericArrayType gb = (GenericArrayType) b;\nreturn equals(ga.getGenericComponentType(), gb.getGenericComponentType());\n\n} else if (a instanceof WildcardType) {\nif (!(b instanceof WildcardType)) {\nreturn false;\n}\n\nWildcardType wa = (WildcardType) a;\nWildcardType wb = (WildcardType) b;\nreturn Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())\n&& Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());\n\n} else if (a instanceof TypeVariable) {\nif (!(b instanceof TypeVariable)) {\nreturn false;\n}\nTypeVariable<?> va = (TypeVariable<?>) a;\nTypeVariable<?> vb = (TypeVariable<?>) b;\nreturn va.getGenericDeclaration() == vb.getGenericDeclaration()\n&& va.getName().equals(vb.getName());\n\n} else {\n// This isn't a type we support. Could be a generic array type, wildcard type, etc.\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$WildcardTypeImpl:<init>([Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\ncheckArgument(lowerBounds.length <= 1);\ncheckArgument(upperBounds.length == 1);\n\nif (lowerBounds.length == 1) {\ncheckNotNull(lowerBounds[0]);\ncheckNotPrimitive(lowerBounds[0]);\ncheckArgument(upperBounds[0] == Object.class);\nthis.lowerBound = canonicalize(lowerBounds[0]);\nthis.upperBound = Object.class;\n\n} else {\ncheckNotNull(upperBounds[0]);\ncheckNotPrimitive(upperBounds[0]);\nthis.lowerBound = null;\nthis.upperBound = canonicalize(upperBounds[0]);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\nCollections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\nDEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\nDEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\nLongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,\nfinal Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,\nboolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\nboolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,\nLongSerializationPolicy longSerializationPolicy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.excluder = excluder;\nthis.fieldNamingStrategy = fieldNamingStrategy;\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nthis.lenient = lenient;\n\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n\n// built-in type adapters that cannot be overridden\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\n\n// the excluder must precede all adapters that handle user-defined types\nfactories.add(excluder);\n\n// user's type adapters\nfactories.addAll(typeAdapterFactories);\n\n// type adapters for basic platform types\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nTypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\ndoubleAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfloatAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\nfactories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\nfactories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.CURRENCY_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\n\n// type adapters for composite and user-defined types\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nthis.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);\nfactories.add(jsonAdapterFactory);\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nconstructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory));\n\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<clinit>()V",
                                    "method_body": "static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\nstatic final boolean DEFAULT_LENIENT = false;\nstatic final boolean DEFAULT_PRETTY_PRINT = false;\nstatic final boolean DEFAULT_ESCAPE_HTML = true;\nstatic final boolean DEFAULT_SERIALIZE_NULLS = false;\nstatic final boolean DEFAULT_COMPLEX_MAP_KEYS = false;\nstatic final boolean DEFAULT_SPECIALIZE_FLOAT_VALUES = false;\n\nprivate static final TypeToken<?> NULL_KEY_SURROGATE = TypeToken.get(Object.class);\nprivate static final String JSON_NON_EXECUTABLE_PREFIX = \")]}'\\n\";\n\n/**\n* This thread local guards against reentrant calls to getAdapter(). In\n* certain object graphs, creating an adapter for a type may recursively\n* require an adapter for the same type! Without intervention, the recursive\n* lookup would stack overflow. We cheat by returning a proxy type adapter.\n* The proxy is wired up once the initial adapter has been created.\n*/\nprivate final ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>> calls\n= new ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>>();\n\nprivate final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache = new ConcurrentHashMap<TypeToken<?>, TypeAdapter<?>>();\n\nprivate final List<TypeAdapterFactory> factories;\nprivate final ConstructorConstructor constructorConstructor;\n\nprivate final Excluder excluder;\nprivate final FieldNamingStrategy fieldNamingStrategy;\nprivate final boolean serializeNulls;\nprivate final boolean htmlSafe;\nprivate final boolean generateNonExecutableJson;\nprivate final boolean prettyPrinting;\nprivate final boolean lenient;\nprivate final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;\n\n/**\n* Constructs a Gson object with default configuration. The default configuration has the\n* following settings:\n* <ul>\n*   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n*   means that all the unneeded white-space is removed. You can change this behavior with\n*   {@link GsonBuilder#setPrettyPrinting()}. </li>"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.DOUBLE;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Double read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\ndouble doubleValue = value.doubleValue();\ncheckValidFloatingPoint(doubleValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.FLOAT;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Float read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn (float) in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nfloat floatValue = value.floatValue();\ncheckValidFloatingPoint(floatValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Number read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextLong();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nout.value(value.toString());\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLong>() {\n@Override public void write(JsonWriter out, AtomicLong value) throws IOException {\nlongAdapter.write(out, value.get());\n}\n@Override public AtomicLong read(JsonReader in) throws IOException {\nNumber value = longAdapter.read(in);\nreturn new AtomicLong(value.longValue());\n}\n}.nullSafe();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongArrayAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLongArray>() {\n@Override public void write(JsonWriter out, AtomicLongArray value) throws IOException {\nout.beginArray();\nfor (int i = 0, length = value.length(); i < length; i++) {\nlongAdapter.write(out, value.get(i));\n}\nout.endArray();\n}\n@Override public AtomicLongArray read(JsonReader in) throws IOException {\nList<Long> list = new ArrayList<Long>();\nin.beginArray();\nwhile (in.hasNext()) {\nlong value = longAdapter.read(in).longValue();\nlist.add(value);\n}\nin.endArray();\nint length = list.size();\nAtomicLongArray array = new AtomicLongArray(length);\nfor (int i = 0; i < length; ++i) {\narray.set(i, list.get(i));\n}\nreturn array;\n}\n}.nullSafe();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);\nif (cached != null) {\nreturn (TypeAdapter<T>) cached;\n}\n\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\n}\n\n// the key and value type parameters always agree\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nreturn ongoingCall;\n}\n\ntry {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\n\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\n}\n}\nthrow new IllegalArgumentException(\"GSON cannot handle \" + type);\n} finally {\nthreadCalls.remove(type);\n\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Ljava/lang/Class;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(Class<T> type) {\nreturn getAdapter(TypeToken.get(type));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:equals(Ljava/lang/Object;)Z",
                                    "method_body": "@Override public final boolean equals(Object o) {\nreturn o instanceof TypeToken<?>\n&& $Gson$Types.equals(type, ((TypeToken<?>) o).type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/Class;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static <T> TypeToken<T> get(Class<T> type) {\nreturn new TypeToken<T>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:newParameterizedTypeWithOwner(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)Ljava/lang/reflect/ParameterizedType;",
                                    "method_body": "public static ParameterizedType newParameterizedTypeWithOwner(\nType ownerType, Type rawType, Type... typeArguments) {\nreturn new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:subtypeOf(Ljava/lang/reflect/Type;)Ljava/lang/reflect/WildcardType;",
                                    "method_body": "public static WildcardType subtypeOf(Type bound) {\nType[] upperBounds;\nupperBounds = new Type[] { bound };\nreturn new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\n// type is a normal class.\nreturn (Class<?>) type;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType parameterizedType = (ParameterizedType) type;\n\n// I'm not exactly sure why getRawType() returns Type instead of Class.\n// Neal isn't either but suspects some pathological case related\n// to nested classes exists.\nType rawType = parameterizedType.getRawType();\ncheckArgument(rawType instanceof Class);\nreturn (Class<?>) rawType;\n\n} else if (type instanceof GenericArrayType) {\nType componentType = ((GenericArrayType)type).getGenericComponentType();\nreturn Array.newInstance(getRawType(componentType), 0).getClass();\n\n} else if (type instanceof TypeVariable) {\n// we could use the variable's bounds, but that won't work if there are multiple.\n// having a raw type that's more general than necessary is okay\nreturn Object.class;\n\n} else if (type instanceof WildcardType) {\nreturn getRawType(((WildcardType) type).getUpperBounds()[0]);\n\n} else {\nString className = type == null ? \"null\" : type.getClass().getName();\nthrow new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n+ \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:hashCodeOrZero(Ljava/lang/Object;)I",
                                    "method_body": "static int hashCodeOrZero(Object o) {\nreturn o != null ? o.hashCode() : 0;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getGenericSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\nif (toResolve == rawType) {\nreturn context;\n}\n\n// we skip searching through interfaces if unknown is an interface\nif (toResolve.isInterface()) {\nClass<?>[] interfaces = rawType.getInterfaces();\nfor (int i = 0, length = interfaces.length; i < length; i++) {\nif (interfaces[i] == toResolve) {\nreturn rawType.getGenericInterfaces()[i];\n} else if (toResolve.isAssignableFrom(interfaces[i])) {\nreturn getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n}\n}\n}\n\n// check our supertypes\nif (!rawType.isInterface()) {\nwhile (rawType != Object.class) {\nClass<?> rawSupertype = rawType.getSuperclass();\nif (rawSupertype == toResolve) {\nreturn rawType.getGenericSuperclass();\n} else if (toResolve.isAssignableFrom(rawSupertype)) {\nreturn getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);\n}\nrawType = rawSupertype;\n}\n}\n\n// we can't resolve this further\nreturn toResolve;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\n// this implementation is made a little more complicated in an attempt to avoid object-creation\nwhile (true) {\nif (toResolve instanceof TypeVariable) {\nTypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\ntoResolve = resolveTypeVariable(context, contextRawType, typeVariable);\nif (toResolve == typeVariable) {\nreturn toResolve;\n}\n\n} else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\nClass<?> original = (Class<?>) toResolve;\nType componentType = original.getComponentType();\nType newComponentType = resolve(context, contextRawType, componentType);\nreturn componentType == newComponentType\n? original\n: arrayOf(newComponentType);\n\n} else if (toResolve instanceof GenericArrayType) {\nGenericArrayType original = (GenericArrayType) toResolve;\nType componentType = original.getGenericComponentType();\nType newComponentType = resolve(context, contextRawType, componentType);\nreturn componentType == newComponentType\n? original\n: arrayOf(newComponentType);\n\n} else if (toResolve instanceof ParameterizedType) {\nParameterizedType original = (ParameterizedType) toResolve;\nType ownerType = original.getOwnerType();\nType newOwnerType = resolve(context, contextRawType, ownerType);\nboolean changed = newOwnerType != ownerType;\n\nType[] args = original.getActualTypeArguments();\nfor (int t = 0, length = args.length; t < length; t++) {\nType resolvedTypeArgument = resolve(context, contextRawType, args[t]);\nif (resolvedTypeArgument != args[t]) {\nif (!changed) {\nargs = args.clone();\nchanged = true;\n}\nargs[t] = resolvedTypeArgument;\n}\n}\n\nreturn changed\n? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n: original;\n\n} else if (toResolve instanceof WildcardType) {\nWildcardType original = (WildcardType) toResolve;\nType[] originalLowerBound = original.getLowerBounds();\nType[] originalUpperBound = original.getUpperBounds();\n\nif (originalLowerBound.length == 1) {\nType lowerBound = resolve(context, contextRawType, originalLowerBound[0]);\nif (lowerBound != originalLowerBound[0]) {\nreturn supertypeOf(lowerBound);\n}\n} else if (originalUpperBound.length == 1) {\nType upperBound = resolve(context, contextRawType, originalUpperBound[0]);\nif (upperBound != originalUpperBound[0]) {\nreturn subtypeOf(upperBound);\n}\n}\nreturn original;\n\n} else {\nreturn toResolve;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolveTypeVariable(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/TypeVariable;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\nClass<?> declaredByRaw = declaringClassOf(unknown);\n\n// we can't reduce this further\nif (declaredByRaw == null) {\nreturn unknown;\n}\n\nType declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\nif (declaredBy instanceof ParameterizedType) {\nint index = indexOf(declaredByRaw.getTypeParameters(), unknown);\nreturn ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\n}\n\nreturn unknown;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:indexOf([Ljava/lang/Object;Ljava/lang/Object;)I",
                                    "method_body": "private static int indexOf(Object[] array, Object toFind) {\nfor (int i = 0, length = array.length; i < length; i++) {\nif (toFind.equals(array[i])) {\nreturn i;\n}\n}\nthrow new NoSuchElementException();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:declaringClassOf(Ljava/lang/reflect/TypeVariable;)Ljava/lang/Class;",
                                    "method_body": "private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\nGenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\nreturn genericDeclaration instanceof Class\n? (Class<?>) genericDeclaration\n: null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\n\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate boolean requireExpose;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n\n@Override protected Excluder clone() {\ntry {\nreturn (Excluder) super.clone();\n} catch (CloneNotSupportedException e) {\nthrow new AssertionError(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\n\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}\n\nreturn new TypeAdapter<T>() {\n/** The delegate is lazily created because it may not be needed, and creating it may fail. */\nprivate TypeAdapter<T> delegate;\n\n@Override public T read(JsonReader in) throws IOException {\nif (skipDeserialize) {\nin.skipValue();\nreturn null;\n}\nreturn delegate().read(in);\n}\n\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (skipSerialize) {\nout.nullValue();\nreturn;\n}\ndelegate().write(out, value);\n}\n\nprivate TypeAdapter<T> delegate() {\nTypeAdapter<T> d = delegate;\nreturn d != null\n? d\n: (delegate = gson.getDelegateAdapter(Excluder.this, type));\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field field, boolean serialize) {\nif ((modifiers & field.getModifiers()) != 0) {\nreturn true;\n}\n\nif (version != Excluder.IGNORE_VERSIONS\n&& !isValidVersion(field.getAnnotation(Since.class), field.getAnnotation(Until.class))) {\nreturn true;\n}\n\nif (field.isSynthetic()) {\nreturn true;\n}\n\nif (requireExpose) {\nExpose annotation = field.getAnnotation(Expose.class);\nif (annotation == null || (serialize ? !annotation.serialize() : !annotation.deserialize())) {\nreturn true;\n}\n}\n\nif (!serializeInnerClasses && isInnerClass(field.getType())) {\nreturn true;\n}\n\nif (isAnonymousOrLocal(field.getType())) {\nreturn true;\n}\n\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nif (!list.isEmpty()) {\nFieldAttributes fieldAttributes = new FieldAttributes(field);\nfor (ExclusionStrategy exclusionStrategy : list) {\nif (exclusionStrategy.shouldSkipField(fieldAttributes)) {\nreturn true;\n}\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\n&& !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\nreturn true;\n}\n\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nreturn true;\n}\n\nif (isAnonymousOrLocal(clazz)) {\nreturn true;\n}\n\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nif (exclusionStrategy.shouldSkipClass(clazz)) {\nreturn true;\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n&& (clazz.isAnonymousClass() || clazz.isLocalClass());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.FieldNamingPolicy$1:translateName(Ljava/lang/reflect/Field;)Ljava/lang/String;",
                                    "method_body": "@Override public String translateName(Field f) {\nreturn f.getName();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\n\n// first try an instance creator\n\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn typeCreator.createInstance(type);\n}\n};\n}\n\n// Next try raw type match for instance creators\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> rawTypeCreator =\n(InstanceCreator<T>) instanceCreators.get(rawType);\nif (rawTypeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn rawTypeCreator.createInstance(type);\n}\n};\n}\n\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nreturn defaultConstructor;\n}\n\nObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\nif (defaultImplementation != null) {\nreturn defaultImplementation;\n}\n\n// finally try unsafe\nreturn newUnsafeAllocator(type, rawType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultConstructor(Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\ntry {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\n}\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"unchecked\") // T is the same raw type as is requested\n@Override public T construct() {\ntry {\nObject[] args = null;\nreturn (T) constructor.newInstance(args);\n} catch (InstantiationException e) {\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\", e);\n} catch (InvocationTargetException e) {\n// TODO: don't wrap if cause is unchecked!\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",\ne.getTargetException());\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\n}\n};\n} catch (NoSuchMethodException e) {\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultImplementationConstructor(Ljava/lang/reflect/Type;Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nfinal Type type, Class<? super T> rawType) {\nif (Collection.class.isAssignableFrom(rawType)) {\nif (SortedSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeSet<Object>();\n}\n};\n} else if (EnumSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"rawtypes\")\n@Override public T construct() {\nif (type instanceof ParameterizedType) {\nType elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\nif (elementType instanceof Class) {\nreturn (T) EnumSet.noneOf((Class)elementType);\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n}\n};\n} else if (Set.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashSet<Object>();\n}\n};\n} else if (Queue.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ArrayDeque<Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ArrayList<Object>();\n}\n};\n}\n}\n\nif (Map.class.isAssignableFrom(rawType)) {\nif (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ConcurrentSkipListMap<Object, Object>();\n}\n};\n} else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ConcurrentHashMap<Object, Object>();\n}\n};\n} else if (SortedMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeMap<Object, Object>();\n}\n};\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nTypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashMap<Object, Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedTreeMap<String, Object>();\n}\n};\n}\n}\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newUnsafeAllocator(Ljava/lang/reflect/Type;Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newUnsafeAllocator(\nfinal Type type, final Class<? super T> rawType) {\nreturn new ObjectConstructor<T>() {\nprivate final UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();\n@SuppressWarnings(\"unchecked\")\n@Override public T construct() {\ntry {\nObject newInstance = unsafeAllocator.newInstance(rawType);\nreturn (T) newInstance;\n} catch (Exception e) {\nthrow new RuntimeException((\"Unable to invoke no-args constructor for \" + type + \". \"\n+ \"Register an InstanceCreator with Gson for this type may fix this problem.\"), e);\n}\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n@Override\npublic void write(JsonWriter out, Class value) throws IOException {\nthrow new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n+ value.getName() + \". Forgot to register a type adapter?\");\n}\n@Override\npublic Class read(JsonReader in) throws IOException {\nthrow new UnsupportedOperationException(\n\"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n}\n}.nullSafe();"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:nullSafe()Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public final TypeAdapter<T> nullSafe() {\nreturn new TypeAdapter<T>() {\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (value == null) {\nout.nullValue();\n} else {\nTypeAdapter.this.write(out, value);\n}\n}\n@Override public T read(JsonReader reader) throws IOException {\nif (reader.peek() == JsonToken.NULL) {\nreader.nextNull();\nreturn null;\n}\nreturn TypeAdapter.this.read(reader);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$35:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$26:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}\n\nfinal TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\nreturn (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n@Override public Timestamp read(JsonReader in) throws IOException {\nDate date = dateTypeAdapter.read(in);\nreturn date != null ? new Timestamp(date.getTime()) : null;\n}\n\n@Override public void write(JsonWriter out, Timestamp value) throws IOException {\ndateTypeAdapter.write(out, value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$34:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$30:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nif (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {\nreturn null;\n}\nif (!rawType.isEnum()) {\nrawType = rawType.getSuperclass(); // handle anonymous subclasses\n}\nreturn (TypeAdapter<T>) new EnumTypeAdapter(rawType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<init>(Lcom/google/gson/Gson;)V",
                                    "method_body": "ObjectTypeAdapter(Gson gson) {\nthis.gson = gson;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nType elementType = $Gson$Types.getCollectionElementType(type, rawType);\nTypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // create() doesn't define a type parameter\nTypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nClass<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\nType[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\nTypeAdapter<?> keyAdapter = getKeyAdapter(gson, keyAndValueTypes[0]);\nTypeAdapter<?> valueAdapter = gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n// we don't define a type parameter for the key or value types\nTypeAdapter<T> result = new Adapter(gson, keyAndValueTypes[0], keyAdapter,\nkeyAndValueTypes[1], valueAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\nClass<? super T> rawType = targetType.getRawType();\nJsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);\nif (annotation == null) {\nreturn null;\n}\nreturn (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;Lcom/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nFieldNamingStrategy fieldNamingPolicy, Excluder excluder,\nJsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\nthis.jsonAdapterFactory = jsonAdapterFactory;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field f, boolean serialize) {\nreturn excludeField(f, serialize, excluder);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;ZLcom/google/gson/internal/Excluder;)Z",
                                    "method_body": "static boolean excludeField(Field f, boolean serialize, Excluder excluder) {\nreturn !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getFieldNames(Ljava/lang/reflect/Field;)Ljava/util/List;",
                                    "method_body": "private List<String> getFieldNames(Field f) {\nSerializedName annotation = f.getAnnotation(SerializedName.class);\nif (annotation == null) {\nString name = fieldNamingPolicy.translateName(f);\nreturn Collections.singletonList(name);\n}\n\nString serializedName = annotation.value();\nString[] alternates = annotation.alternate();\nif (alternates.length == 0) {\nreturn Collections.singletonList(serializedName);\n}\n\nList<String> fieldNames = new ArrayList<String>(alternates.length + 1);\nfieldNames.add(serializedName);\nfor (String alternate : alternates) {\nfieldNames.add(alternate);\n}\nreturn fieldNames;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\nClass<? super T> raw = type.getRawType();\n\nif (!Object.class.isAssignableFrom(raw)) {\nreturn null; // it's a primitive!\n}\n\nObjectConstructor<T> constructor = constructorConstructor.get(type);\nreturn new Adapter<T>(constructor, getBoundFields(gson, type, raw));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:createBoundField(Lcom/google/gson/Gson;Ljava/lang/reflect/Field;Ljava/lang/String;Lcom/google/gson/reflect/TypeToken;ZZ)Lcom/google/gson/internal/bind/ReflectiveTypeAdapterFactory$BoundField;",
                                    "method_body": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(\nfinal Gson context, final Field field, final String name,\nfinal TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\nfinal boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n// special casing primitives here saves ~5% on Android...\nJsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\nTypeAdapter<?> mapped = null;\nif (annotation != null) {\nmapped = jsonAdapterFactory.getTypeAdapter(\nconstructorConstructor, context, fieldType, annotation);\n}\nfinal boolean jsonAdapterPresent = mapped != null;\nif (mapped == null) mapped = context.getAdapter(fieldType);\n\nfinal TypeAdapter<?> typeAdapter = mapped;\nreturn new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n@Override void write(JsonWriter writer, Object value)\nthrows IOException, IllegalAccessException {\nObject fieldValue = field.get(value);\nTypeAdapter t = jsonAdapterPresent ? typeAdapter\n: new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\nt.write(writer, fieldValue);\n}\n@Override void read(JsonReader reader, Object value)\nthrows IOException, IllegalAccessException {\nObject fieldValue = typeAdapter.read(reader);\nif (fieldValue != null || !isPrimitive) {\nfield.set(value, fieldValue);\n}\n}\n@Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\nif (!serialized) return false;\nObject fieldValue = field.get(value);\nreturn fieldValue != value; // avoid recursion for example for Throwable.cause\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getBoundFields(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;Ljava/lang/Class;)Ljava/util/Map;",
                                    "method_body": "private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {\nMap<String, BoundField> result = new LinkedHashMap<String, BoundField>();\nif (raw.isInterface()) {\nreturn result;\n}\n\nType declaredType = type.getType();\nwhile (raw != Object.class) {\nField[] fields = raw.getDeclaredFields();\nfor (Field field : fields) {\nboolean serialize = excludeField(field, true);\nboolean deserialize = excludeField(field, false);\nif (!serialize && !deserialize) {\ncontinue;\n}\nfield.setAccessible(true);\nType fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\nList<String> fieldNames = getFieldNames(field);\nBoundField previous = null;\nfor (int i = 0, size = fieldNames.size(); i < size; ++i) {\nString name = fieldNames.get(i);\nif (i != 0) serialize = false; // only serialize the default name\nBoundField boundField = createBoundField(context, field, name,\nTypeToken.get(fieldType), serialize, deserialize);\nBoundField replaced = result.put(name, boundField);\nif (previous == null) previous = replaced;\n}\nif (previous != null) {\nthrow new IllegalArgumentException(declaredType\n+ \" declares multiple JSON fields named \" + previous.name);\n}\n}\ntype = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\nraw = type.getRawType();\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$ParameterizedTypeImpl:<init>(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n// require an owner type if the raw type needs it\nif (rawType instanceof Class<?>) {\nClass<?> rawTypeAsClass = (Class<?>) rawType;\nboolean isStaticOrTopLevelClass = Modifier.isStatic(rawTypeAsClass.getModifiers())\n|| rawTypeAsClass.getEnclosingClass() == null;\ncheckArgument(ownerType != null || isStaticOrTopLevelClass);\n}\n\nthis.ownerType = ownerType == null ? null : canonicalize(ownerType);\nthis.rawType = canonicalize(rawType);\nthis.typeArguments = typeArguments.clone();\nfor (int t = 0, length = this.typeArguments.length; t < length; t++) {\ncheckNotNull(this.typeArguments[t]);\ncheckNotPrimitive(this.typeArguments[t]);\nthis.typeArguments[t] = canonicalize(this.typeArguments[t]);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson$FutureTypeAdapter:setDelegate(Lcom/google/gson/TypeAdapter;)V",
                                    "method_body": "public void setDelegate(TypeAdapter<T> typeAdapter) {\nif (delegate != null) {\nthrow new AssertionError();\n}\ndelegate = typeAdapter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter:<init>(Lcom/google/gson/internal/ObjectConstructor;Ljava/util/Map;)V",
                                    "method_body": "abstract boolean writeField(Object value) throws IOException, IllegalAccessException;\nabstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException;\nabstract void read(JsonReader reader, Object value) throws IOException, IllegalAccessException;\n}\n\npublic static final class Adapter<T> extends TypeAdapter<T> {\nprivate final ObjectConstructor<T> constructor;\nprivate final Map<String, BoundField> boundFields;\n\nAdapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {\nthis.constructor = constructor;\nthis.boundFields = boundFields;\n}\n\n@Override public T read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\n\nT instance = constructor.construct();\n\ntry {\nin.beginObject();\nwhile (in.hasNext()) {\nString name = in.nextName();\nBoundField field = boundFields.get(name);\nif (field == null || !field.deserialized) {\nin.skipValue();\n} else {\nfield.read(in, instance);\n}\n}\n} catch (IllegalStateException e) {\nthrow new JsonSyntaxException(e);\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\nin.endObject();\nreturn instance;\n}\n\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\n\nout.beginObject();\ntry {\nfor (BoundField boundField : boundFields.values()) {\nif (boundField.writeField(value)) {\nout.name(boundField.name);\nboundField.write(out, value);\n}\n}\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\nout.endObject();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:<clinit>()V",
                                    "method_body": "private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;\n\n/** A map from wrapper types to their corresponding primitive types. */\nprivate static final Map<Class<?>, Class<?>> WRAPPER_TO_PRIMITIVE_TYPE;\n\n// Sad that we can't use a BiMap. :(\n\nstatic {\nMap<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);\nMap<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);\n\nadd(primToWrap, wrapToPrim, boolean.class, Boolean.class);\nadd(primToWrap, wrapToPrim, byte.class, Byte.class);\nadd(primToWrap, wrapToPrim, char.class, Character.class);\nadd(primToWrap, wrapToPrim, double.class, Double.class);\nadd(primToWrap, wrapToPrim, float.class, Float.class);\nadd(primToWrap, wrapToPrim, int.class, Integer.class);\nadd(primToWrap, wrapToPrim, long.class, Long.class);\nadd(primToWrap, wrapToPrim, short.class, Short.class);\nadd(primToWrap, wrapToPrim, void.class, Void.class);\n\nPRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);\nWRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:add(Ljava/util/Map;Ljava/util/Map;Ljava/lang/Class;Ljava/lang/Class;)V",
                                    "method_body": "private static void add(Map<Class<?>, Class<?>> forward,\nMap<Class<?>, Class<?>> backward, Class<?> key, Class<?> value) {\nforward.put(key, value);\nbackward.put(value, key);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:isPrimitive(Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public static boolean isPrimitive(Type type) {\nreturn PRIMITIVE_TO_WRAPPER_TYPE.containsKey(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$BoundField:<init>(Ljava/lang/String;ZZ)V",
                                    "method_body": "protected BoundField(String name, boolean serialized, boolean deserialized) {\nthis.name = name;\nthis.serialized = serialized;\nthis.deserialized = deserialized;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.UnsafeAllocator:create()Lcom/google/gson/internal/UnsafeAllocator;",
                                    "method_body": "public abstract <T> T newInstance(Class<T> c) throws Exception;\n\npublic static UnsafeAllocator create() {\n// try JVM\n// public class Unsafe {\n//   public Object allocateInstance(Class<?> type);\n// }\ntry {\nClass<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\nField f = unsafeClass.getDeclaredField(\"theUnsafe\");\nf.setAccessible(true);\nfinal Object unsafe = f.get(null);\nfinal Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nassertInstantiable(c);\nreturn (T) allocateInstance.invoke(unsafe, c);\n}\n};\n} catch (Exception ignored) {\n}\n\n// try dalvikvm, post-gingerbread\n// public class ObjectStreamClass {\n//   private static native int getConstructorId(Class<?> c);\n//   private static native Object newInstance(Class<?> instantiationClass, int methodId);\n// }\ntry {\nMethod getConstructorId = ObjectStreamClass.class\n.getDeclaredMethod(\"getConstructorId\", Class.class);\ngetConstructorId.setAccessible(true);\nfinal int constructorId = (Integer) getConstructorId.invoke(null, Object.class);\nfinal Method newInstance = ObjectStreamClass.class\n.getDeclaredMethod(\"newInstance\", Class.class, int.class);\nnewInstance.setAccessible(true);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nassertInstantiable(c);\nreturn (T) newInstance.invoke(null, c, constructorId);\n}\n};\n} catch (Exception ignored) {\n}\n\n// try dalvikvm, pre-gingerbread\n// public class ObjectInputStream {\n//   private static native Object newInstance(\n//     Class<?> instantiationClass, Class<?> constructorClass);\n// }\ntry {\nfinal Method newInstance = ObjectInputStream.class\n.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\nnewInstance.setAccessible(true);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nassertInstantiable(c);\nreturn (T) newInstance.invoke(null, c, Object.class);\n}\n};\n} catch (Exception ignored) {\n}\n\n// give up\nreturn new UnsafeAllocator() {\n@Override\npublic <T> T newInstance(Class<T> c) {\nthrow new UnsupportedOperationException(\"Cannot allocate \" + c);\n}\n};\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 15,
                    "tests": [
                        {
                            "test_name": "com.google.gson.stream.JsonWriterTest.testNonFiniteDoublesWhenLenient",
                            "test_body": "217: public void testNonFiniteDoublesWhenLenient() throws IOException {\n218: StringWriter stringWriter = new StringWriter();\n219: JsonWriter jsonWriter = new JsonWriter(stringWriter);\n220: jsonWriter.setLenient(true);\n221: jsonWriter.beginArray();\n222: jsonWriter.value(Double.NaN);\n223: jsonWriter.value(Double.NEGATIVE_INFINITY);\n224: jsonWriter.value(Double.POSITIVE_INFINITY);\n225: jsonWriter.endArray();\n226: assertEquals(\"[NaN,-Infinity,Infinity]\", stringWriter.toString());\n227: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:<init>(Ljava/io/Writer;)V",
                                    "method_body": "public JsonWriter(Writer out) {\nif (out == null) {\nthrow new NullPointerException(\"out == null\");\n}\nthis.out = out;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:<clinit>()V",
                                    "method_body": "private static final String[] REPLACEMENT_CHARS;\nprivate static final String[] HTML_SAFE_REPLACEMENT_CHARS;\nstatic {\nREPLACEMENT_CHARS = new String[128];\nfor (int i = 0; i <= 0x1f; i++) {\nREPLACEMENT_CHARS[i] = String.format(\"\\\\u%04x\", (int) i);\n}\nREPLACEMENT_CHARS['\"'] = \"\\\\\\\"\";\nREPLACEMENT_CHARS['\\\\'] = \"\\\\\\\\\";\nREPLACEMENT_CHARS['\\t'] = \"\\\\t\";\nREPLACEMENT_CHARS['\\b'] = \"\\\\b\";\nREPLACEMENT_CHARS['\\n'] = \"\\\\n\";\nREPLACEMENT_CHARS['\\r'] = \"\\\\r\";\nREPLACEMENT_CHARS['\\f'] = \"\\\\f\";\nHTML_SAFE_REPLACEMENT_CHARS = REPLACEMENT_CHARS.clone();\nHTML_SAFE_REPLACEMENT_CHARS['<'] = \"\\\\u003c\";\nHTML_SAFE_REPLACEMENT_CHARS['>'] = \"\\\\u003e\";\nHTML_SAFE_REPLACEMENT_CHARS['&'] = \"\\\\u0026\";\nHTML_SAFE_REPLACEMENT_CHARS['='] = \"\\\\u003d\";\nHTML_SAFE_REPLACEMENT_CHARS['\\''] = \"\\\\u0027\";\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:setLenient(Z)V",
                                    "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:beginArray()Lcom/google/gson/stream/JsonWriter;",
                                    "method_body": "public JsonWriter beginArray() throws IOException {\nwriteDeferredName();\nreturn open(EMPTY_ARRAY, \"[\");\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:open(ILjava/lang/String;)Lcom/google/gson/stream/JsonWriter;",
                                    "method_body": "private JsonWriter open(int empty, String openBracket) throws IOException {\nbeforeValue();\npush(empty);\nout.write(openBracket);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:push(I)V",
                                    "method_body": "private void push(int newTop) {\nif (stackSize == stack.length) {\nint[] newStack = new int[stackSize * 2];\nSystem.arraycopy(stack, 0, newStack, 0, stackSize);\nstack = newStack;\n}\nstack[stackSize++] = newTop;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:peek()I",
                                    "method_body": "private int peek() {\nif (stackSize == 0) {\nthrow new IllegalStateException(\"JsonWriter is closed.\");\n}\nreturn stack[stackSize - 1];\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:replaceTop(I)V",
                                    "method_body": "private void replaceTop(int topOfStack) {\nstack[stackSize - 1] = topOfStack;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:writeDeferredName()V",
                                    "method_body": "private void writeDeferredName() throws IOException {\nif (deferredName != null) {\nbeforeName();\nstring(deferredName);\ndeferredName = null;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:value(D)Lcom/google/gson/stream/JsonWriter;",
                                    "method_body": "public JsonWriter value(double value) throws IOException {\nwriteDeferredName();\nif (Double.isNaN(value) || Double.isInfinite(value)) {\nthrow new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n}\nbeforeValue();\nout.append(Double.toString(value));\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonWriter:beforeValue()V",
                                    "method_body": "private void beforeValue() throws IOException {\nswitch (peek()) {\ncase NONEMPTY_DOCUMENT:\nif (!lenient) {\nthrow new IllegalStateException(\n\"JSON must have only one top-level value.\");\n}\n// fall-through\ncase EMPTY_DOCUMENT: // first in document\nreplaceTop(NONEMPTY_DOCUMENT);\nbreak;\n\ncase EMPTY_ARRAY: // first in array\nreplaceTop(NONEMPTY_ARRAY);\nnewline();\nbreak;\n\ncase NONEMPTY_ARRAY: // another in array\nout.append(',');\nnewline();\nbreak;\n\ncase DANGLING_NAME: // value for name\nout.append(separator);\nreplaceTop(NONEMPTY_OBJECT);\nbreak;\n\ndefault:\nthrow new IllegalStateException(\"Nesting problem.\");\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 16,
                    "tests": [
                        {
                            "test_name": "com.google.gson.internal.bind.RecursiveTypesResolveTest.testRecursiveTypeVariablesResolve12",
                            "test_body": "107: public void testRecursiveTypeVariablesResolve12() throws Exception {\n108: TypeAdapter<TestType2> adapter = new Gson().getAdapter(TestType2.class);\n109: assertNotNull(adapter);\n110: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\nCollections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\nDEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\nDEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\nLongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,\nfinal Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,\nboolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\nboolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,\nLongSerializationPolicy longSerializationPolicy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.excluder = excluder;\nthis.fieldNamingStrategy = fieldNamingStrategy;\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nthis.lenient = lenient;\n\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n\n// built-in type adapters that cannot be overridden\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\n\n// the excluder must precede all adapters that handle user-defined types\nfactories.add(excluder);\n\n// user's type adapters\nfactories.addAll(typeAdapterFactories);\n\n// type adapters for basic platform types\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nTypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\ndoubleAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfloatAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\nfactories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\nfactories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.CURRENCY_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\n\n// type adapters for composite and user-defined types\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nthis.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);\nfactories.add(jsonAdapterFactory);\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nconstructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory));\n\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<clinit>()V",
                                    "method_body": "static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\nstatic final boolean DEFAULT_LENIENT = false;\nstatic final boolean DEFAULT_PRETTY_PRINT = false;\nstatic final boolean DEFAULT_ESCAPE_HTML = true;\nstatic final boolean DEFAULT_SERIALIZE_NULLS = false;\nstatic final boolean DEFAULT_COMPLEX_MAP_KEYS = false;\nstatic final boolean DEFAULT_SPECIALIZE_FLOAT_VALUES = false;\n\nprivate static final TypeToken<?> NULL_KEY_SURROGATE = TypeToken.get(Object.class);\nprivate static final String JSON_NON_EXECUTABLE_PREFIX = \")]}'\\n\";\n\n/**\n* This thread local guards against reentrant calls to getAdapter(). In\n* certain object graphs, creating an adapter for a type may recursively\n* require an adapter for the same type! Without intervention, the recursive\n* lookup would stack overflow. We cheat by returning a proxy type adapter.\n* The proxy is wired up once the initial adapter has been created.\n*/\nprivate final ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>> calls\n= new ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>>();\n\nprivate final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache = new ConcurrentHashMap<TypeToken<?>, TypeAdapter<?>>();\n\nprivate final List<TypeAdapterFactory> factories;\nprivate final ConstructorConstructor constructorConstructor;\n\nprivate final Excluder excluder;\nprivate final FieldNamingStrategy fieldNamingStrategy;\nprivate final boolean serializeNulls;\nprivate final boolean htmlSafe;\nprivate final boolean generateNonExecutableJson;\nprivate final boolean prettyPrinting;\nprivate final boolean lenient;\nprivate final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;\n\n/**\n* Constructs a Gson object with default configuration. The default configuration has the\n* following settings:\n* <ul>\n*   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n*   means that all the unneeded white-space is removed. You can change this behavior with\n*   {@link GsonBuilder#setPrettyPrinting()}. </li>"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.DOUBLE;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Double read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\ndouble doubleValue = value.doubleValue();\ncheckValidFloatingPoint(doubleValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.FLOAT;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Float read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn (float) in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nfloat floatValue = value.floatValue();\ncheckValidFloatingPoint(floatValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Number read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextLong();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nout.value(value.toString());\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLong>() {\n@Override public void write(JsonWriter out, AtomicLong value) throws IOException {\nlongAdapter.write(out, value.get());\n}\n@Override public AtomicLong read(JsonReader in) throws IOException {\nNumber value = longAdapter.read(in);\nreturn new AtomicLong(value.longValue());\n}\n}.nullSafe();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongArrayAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLongArray>() {\n@Override public void write(JsonWriter out, AtomicLongArray value) throws IOException {\nout.beginArray();\nfor (int i = 0, length = value.length(); i < length; i++) {\nlongAdapter.write(out, value.get(i));\n}\nout.endArray();\n}\n@Override public AtomicLongArray read(JsonReader in) throws IOException {\nList<Long> list = new ArrayList<Long>();\nin.beginArray();\nwhile (in.hasNext()) {\nlong value = longAdapter.read(in).longValue();\nlist.add(value);\n}\nin.endArray();\nint length = list.size();\nAtomicLongArray array = new AtomicLongArray(length);\nfor (int i = 0; i < length; ++i) {\narray.set(i, list.get(i));\n}\nreturn array;\n}\n}.nullSafe();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);\nif (cached != null) {\nreturn (TypeAdapter<T>) cached;\n}\n\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\n}\n\n// the key and value type parameters always agree\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nreturn ongoingCall;\n}\n\ntry {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\n\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\n}\n}\nthrow new IllegalArgumentException(\"GSON cannot handle \" + type);\n} finally {\nthreadCalls.remove(type);\n\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Ljava/lang/Class;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(Class<T> type) {\nreturn getAdapter(TypeToken.get(type));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/Class;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static <T> TypeToken<T> get(Class<T> type) {\nreturn new TypeToken<T>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nthrow new NullPointerException();\n}\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\nthrow new IllegalArgumentException();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\np.getRawType(), p.getActualTypeArguments());\n\n} else if (type instanceof GenericArrayType) {\nGenericArrayType g = (GenericArrayType) type;\nreturn new GenericArrayTypeImpl(g.getGenericComponentType());\n\n} else if (type instanceof WildcardType) {\nWildcardType w = (WildcardType) type;\nreturn new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n} else {\n// type is either serializable as-is or unsupported\nreturn type;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\n// type is a normal class.\nreturn (Class<?>) type;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType parameterizedType = (ParameterizedType) type;\n\n// I'm not exactly sure why getRawType() returns Type instead of Class.\n// Neal isn't either but suspects some pathological case related\n// to nested classes exists.\nType rawType = parameterizedType.getRawType();\ncheckArgument(rawType instanceof Class);\nreturn (Class<?>) rawType;\n\n} else if (type instanceof GenericArrayType) {\nType componentType = ((GenericArrayType)type).getGenericComponentType();\nreturn Array.newInstance(getRawType(componentType), 0).getClass();\n\n} else if (type instanceof TypeVariable) {\n// we could use the variable's bounds, but that won't work if there are multiple.\n// having a raw type that's more general than necessary is okay\nreturn Object.class;\n\n} else if (type instanceof WildcardType) {\nreturn getRawType(((WildcardType) type).getUpperBounds()[0]);\n\n} else {\nString className = type == null ? \"null\" : type.getClass().getName();\nthrow new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n+ \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:hashCodeOrZero(Ljava/lang/Object;)I",
                                    "method_body": "static int hashCodeOrZero(Object o) {\nreturn o != null ? o.hashCode() : 0;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getGenericSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\nif (toResolve == rawType) {\nreturn context;\n}\n\n// we skip searching through interfaces if unknown is an interface\nif (toResolve.isInterface()) {\nClass<?>[] interfaces = rawType.getInterfaces();\nfor (int i = 0, length = interfaces.length; i < length; i++) {\nif (interfaces[i] == toResolve) {\nreturn rawType.getGenericInterfaces()[i];\n} else if (toResolve.isAssignableFrom(interfaces[i])) {\nreturn getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n}\n}\n}\n\n// check our supertypes\nif (!rawType.isInterface()) {\nwhile (rawType != Object.class) {\nClass<?> rawSupertype = rawType.getSuperclass();\nif (rawSupertype == toResolve) {\nreturn rawType.getGenericSuperclass();\n} else if (toResolve.isAssignableFrom(rawSupertype)) {\nreturn getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);\n}\nrawType = rawSupertype;\n}\n}\n\n// we can't resolve this further\nreturn toResolve;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\nreturn resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;Ljava/util/Collection;)Ljava/lang/reflect/Type;",
                                    "method_body": "private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,\nCollection<TypeVariable> visitedTypeVariables) {\n// this implementation is made a little more complicated in an attempt to avoid object-creation\nwhile (true) {\nif (toResolve instanceof TypeVariable) {\nTypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n// cannot reduce due to infinite recursion\ntoResolve = resolveTypeVariable(context, contextRawType, typeVariable);\nif (toResolve == typeVariable) {\nreturn toResolve;\n}\n\n} else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\nClass<?> original = (Class<?>) toResolve;\nType componentType = original.getComponentType();\nType newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\nreturn componentType == newComponentType\n? original\n: arrayOf(newComponentType);\n\n} else if (toResolve instanceof GenericArrayType) {\nGenericArrayType original = (GenericArrayType) toResolve;\nType componentType = original.getGenericComponentType();\nType newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\nreturn componentType == newComponentType\n? original\n: arrayOf(newComponentType);\n\n} else if (toResolve instanceof ParameterizedType) {\nParameterizedType original = (ParameterizedType) toResolve;\nType ownerType = original.getOwnerType();\nType newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\nboolean changed = newOwnerType != ownerType;\n\nType[] args = original.getActualTypeArguments();\nfor (int t = 0, length = args.length; t < length; t++) {\nType resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\nif (resolvedTypeArgument != args[t]) {\nif (!changed) {\nargs = args.clone();\nchanged = true;\n}\nargs[t] = resolvedTypeArgument;\n}\n}\n\nreturn changed\n? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n: original;\n\n} else if (toResolve instanceof WildcardType) {\nWildcardType original = (WildcardType) toResolve;\nType[] originalLowerBound = original.getLowerBounds();\nType[] originalUpperBound = original.getUpperBounds();\n\nif (originalLowerBound.length == 1) {\nType lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\nif (lowerBound != originalLowerBound[0]) {\nreturn supertypeOf(lowerBound);\n}\n} else if (originalUpperBound.length == 1) {\nType upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\nif (upperBound != originalUpperBound[0]) {\nreturn subtypeOf(upperBound);\n}\n}\nreturn original;\n\n} else {\nreturn toResolve;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolveTypeVariable(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/TypeVariable;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\nClass<?> declaredByRaw = declaringClassOf(unknown);\n\n// we can't reduce this further\nif (declaredByRaw == null) {\nreturn unknown;\n}\n\nType declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\nif (declaredBy instanceof ParameterizedType) {\nint index = indexOf(declaredByRaw.getTypeParameters(), unknown);\nreturn ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\n}\n\nreturn unknown;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:indexOf([Ljava/lang/Object;Ljava/lang/Object;)I",
                                    "method_body": "private static int indexOf(Object[] array, Object toFind) {\nfor (int i = 0, length = array.length; i < length; i++) {\nif (toFind.equals(array[i])) {\nreturn i;\n}\n}\nthrow new NoSuchElementException();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:declaringClassOf(Ljava/lang/reflect/TypeVariable;)Ljava/lang/Class;",
                                    "method_body": "private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\nGenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\nreturn genericDeclaration instanceof Class\n? (Class<?>) genericDeclaration\n: null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\n\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate boolean requireExpose;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n\n@Override protected Excluder clone() {\ntry {\nreturn (Excluder) super.clone();\n} catch (CloneNotSupportedException e) {\nthrow new AssertionError(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\n\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}\n\nreturn new TypeAdapter<T>() {\n/** The delegate is lazily created because it may not be needed, and creating it may fail. */\nprivate TypeAdapter<T> delegate;\n\n@Override public T read(JsonReader in) throws IOException {\nif (skipDeserialize) {\nin.skipValue();\nreturn null;\n}\nreturn delegate().read(in);\n}\n\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (skipSerialize) {\nout.nullValue();\nreturn;\n}\ndelegate().write(out, value);\n}\n\nprivate TypeAdapter<T> delegate() {\nTypeAdapter<T> d = delegate;\nreturn d != null\n? d\n: (delegate = gson.getDelegateAdapter(Excluder.this, type));\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field field, boolean serialize) {\nif ((modifiers & field.getModifiers()) != 0) {\nreturn true;\n}\n\nif (version != Excluder.IGNORE_VERSIONS\n&& !isValidVersion(field.getAnnotation(Since.class), field.getAnnotation(Until.class))) {\nreturn true;\n}\n\nif (field.isSynthetic()) {\nreturn true;\n}\n\nif (requireExpose) {\nExpose annotation = field.getAnnotation(Expose.class);\nif (annotation == null || (serialize ? !annotation.serialize() : !annotation.deserialize())) {\nreturn true;\n}\n}\n\nif (!serializeInnerClasses && isInnerClass(field.getType())) {\nreturn true;\n}\n\nif (isAnonymousOrLocal(field.getType())) {\nreturn true;\n}\n\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nif (!list.isEmpty()) {\nFieldAttributes fieldAttributes = new FieldAttributes(field);\nfor (ExclusionStrategy exclusionStrategy : list) {\nif (exclusionStrategy.shouldSkipField(fieldAttributes)) {\nreturn true;\n}\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\n&& !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\nreturn true;\n}\n\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nreturn true;\n}\n\nif (isAnonymousOrLocal(clazz)) {\nreturn true;\n}\n\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nif (exclusionStrategy.shouldSkipClass(clazz)) {\nreturn true;\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n&& (clazz.isAnonymousClass() || clazz.isLocalClass());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.FieldNamingPolicy$1:translateName(Ljava/lang/reflect/Field;)Ljava/lang/String;",
                                    "method_body": "@Override public String translateName(Field f) {\nreturn f.getName();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\n\n// first try an instance creator\n\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn typeCreator.createInstance(type);\n}\n};\n}\n\n// Next try raw type match for instance creators\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> rawTypeCreator =\n(InstanceCreator<T>) instanceCreators.get(rawType);\nif (rawTypeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn rawTypeCreator.createInstance(type);\n}\n};\n}\n\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nreturn defaultConstructor;\n}\n\nObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\nif (defaultImplementation != null) {\nreturn defaultImplementation;\n}\n\n// finally try unsafe\nreturn newUnsafeAllocator(type, rawType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultConstructor(Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\ntry {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\n}\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"unchecked\") // T is the same raw type as is requested\n@Override public T construct() {\ntry {\nObject[] args = null;\nreturn (T) constructor.newInstance(args);\n} catch (InstantiationException e) {\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\", e);\n} catch (InvocationTargetException e) {\n// TODO: don't wrap if cause is unchecked!\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",\ne.getTargetException());\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\n}\n};\n} catch (NoSuchMethodException e) {\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n@Override\npublic void write(JsonWriter out, Class value) throws IOException {\nthrow new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n+ value.getName() + \". Forgot to register a type adapter?\");\n}\n@Override\npublic Class read(JsonReader in) throws IOException {\nthrow new UnsupportedOperationException(\n\"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n}\n}.nullSafe();"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:nullSafe()Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public final TypeAdapter<T> nullSafe() {\nreturn new TypeAdapter<T>() {\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (value == null) {\nout.nullValue();\n} else {\nTypeAdapter.this.write(out, value);\n}\n}\n@Override public T read(JsonReader reader) throws IOException {\nif (reader.peek() == JsonToken.NULL) {\nreader.nextNull();\nreturn null;\n}\nreturn TypeAdapter.this.read(reader);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$35:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$26:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}\n\nfinal TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\nreturn (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n@Override public Timestamp read(JsonReader in) throws IOException {\nDate date = dateTypeAdapter.read(in);\nreturn date != null ? new Timestamp(date.getTime()) : null;\n}\n\n@Override public void write(JsonWriter out, Timestamp value) throws IOException {\ndateTypeAdapter.write(out, value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$34:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$30:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nif (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {\nreturn null;\n}\nif (!rawType.isEnum()) {\nrawType = rawType.getSuperclass(); // handle anonymous subclasses\n}\nreturn (TypeAdapter<T>) new EnumTypeAdapter(rawType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nType elementType = $Gson$Types.getCollectionElementType(type, rawType);\nTypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // create() doesn't define a type parameter\nTypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nClass<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\nType[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\nTypeAdapter<?> keyAdapter = getKeyAdapter(gson, keyAndValueTypes[0]);\nTypeAdapter<?> valueAdapter = gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n// we don't define a type parameter for the key or value types\nTypeAdapter<T> result = new Adapter(gson, keyAndValueTypes[0], keyAdapter,\nkeyAndValueTypes[1], valueAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\nClass<? super T> rawType = targetType.getRawType();\nJsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);\nif (annotation == null) {\nreturn null;\n}\nreturn (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;Lcom/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nFieldNamingStrategy fieldNamingPolicy, Excluder excluder,\nJsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\nthis.jsonAdapterFactory = jsonAdapterFactory;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field f, boolean serialize) {\nreturn excludeField(f, serialize, excluder);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;ZLcom/google/gson/internal/Excluder;)Z",
                                    "method_body": "static boolean excludeField(Field f, boolean serialize, Excluder excluder) {\nreturn !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getFieldNames(Ljava/lang/reflect/Field;)Ljava/util/List;",
                                    "method_body": "private List<String> getFieldNames(Field f) {\nSerializedName annotation = f.getAnnotation(SerializedName.class);\nif (annotation == null) {\nString name = fieldNamingPolicy.translateName(f);\nreturn Collections.singletonList(name);\n}\n\nString serializedName = annotation.value();\nString[] alternates = annotation.alternate();\nif (alternates.length == 0) {\nreturn Collections.singletonList(serializedName);\n}\n\nList<String> fieldNames = new ArrayList<String>(alternates.length + 1);\nfieldNames.add(serializedName);\nfor (String alternate : alternates) {\nfieldNames.add(alternate);\n}\nreturn fieldNames;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\nClass<? super T> raw = type.getRawType();\n\nif (!Object.class.isAssignableFrom(raw)) {\nreturn null; // it's a primitive!\n}\n\nObjectConstructor<T> constructor = constructorConstructor.get(type);\nreturn new Adapter<T>(constructor, getBoundFields(gson, type, raw));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:createBoundField(Lcom/google/gson/Gson;Ljava/lang/reflect/Field;Ljava/lang/String;Lcom/google/gson/reflect/TypeToken;ZZ)Lcom/google/gson/internal/bind/ReflectiveTypeAdapterFactory$BoundField;",
                                    "method_body": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(\nfinal Gson context, final Field field, final String name,\nfinal TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\nfinal boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n// special casing primitives here saves ~5% on Android...\nJsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\nTypeAdapter<?> mapped = null;\nif (annotation != null) {\nmapped = jsonAdapterFactory.getTypeAdapter(\nconstructorConstructor, context, fieldType, annotation);\n}\nfinal boolean jsonAdapterPresent = mapped != null;\nif (mapped == null) mapped = context.getAdapter(fieldType);\n\nfinal TypeAdapter<?> typeAdapter = mapped;\nreturn new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n@Override void write(JsonWriter writer, Object value)\nthrows IOException, IllegalAccessException {\nObject fieldValue = field.get(value);\nTypeAdapter t = jsonAdapterPresent ? typeAdapter\n: new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\nt.write(writer, fieldValue);\n}\n@Override void read(JsonReader reader, Object value)\nthrows IOException, IllegalAccessException {\nObject fieldValue = typeAdapter.read(reader);\nif (fieldValue != null || !isPrimitive) {\nfield.set(value, fieldValue);\n}\n}\n@Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\nif (!serialized) return false;\nObject fieldValue = field.get(value);\nreturn fieldValue != value; // avoid recursion for example for Throwable.cause\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getBoundFields(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;Ljava/lang/Class;)Ljava/util/Map;",
                                    "method_body": "private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {\nMap<String, BoundField> result = new LinkedHashMap<String, BoundField>();\nif (raw.isInterface()) {\nreturn result;\n}\n\nType declaredType = type.getType();\nwhile (raw != Object.class) {\nField[] fields = raw.getDeclaredFields();\nfor (Field field : fields) {\nboolean serialize = excludeField(field, true);\nboolean deserialize = excludeField(field, false);\nif (!serialize && !deserialize) {\ncontinue;\n}\nfield.setAccessible(true);\nType fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\nList<String> fieldNames = getFieldNames(field);\nBoundField previous = null;\nfor (int i = 0, size = fieldNames.size(); i < size; ++i) {\nString name = fieldNames.get(i);\nif (i != 0) serialize = false; // only serialize the default name\nBoundField boundField = createBoundField(context, field, name,\nTypeToken.get(fieldType), serialize, deserialize);\nBoundField replaced = result.put(name, boundField);\nif (previous == null) previous = replaced;\n}\nif (previous != null) {\nthrow new IllegalArgumentException(declaredType\n+ \" declares multiple JSON fields named \" + previous.name);\n}\n}\ntype = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\nraw = type.getRawType();\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$ParameterizedTypeImpl:<init>(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n// require an owner type if the raw type needs it\nif (rawType instanceof Class<?>) {\nClass<?> rawTypeAsClass = (Class<?>) rawType;\nboolean isStaticOrTopLevelClass = Modifier.isStatic(rawTypeAsClass.getModifiers())\n|| rawTypeAsClass.getEnclosingClass() == null;\ncheckArgument(ownerType != null || isStaticOrTopLevelClass);\n}\n\nthis.ownerType = ownerType == null ? null : canonicalize(ownerType);\nthis.rawType = canonicalize(rawType);\nthis.typeArguments = typeArguments.clone();\nfor (int t = 0, length = this.typeArguments.length; t < length; t++) {\ncheckNotNull(this.typeArguments[t]);\ncheckNotPrimitive(this.typeArguments[t]);\nthis.typeArguments[t] = canonicalize(this.typeArguments[t]);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:<clinit>()V",
                                    "method_body": "private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;\n\n/** A map from wrapper types to their corresponding primitive types. */\nprivate static final Map<Class<?>, Class<?>> WRAPPER_TO_PRIMITIVE_TYPE;\n\n// Sad that we can't use a BiMap. :(\n\nstatic {\nMap<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);\nMap<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);\n\nadd(primToWrap, wrapToPrim, boolean.class, Boolean.class);\nadd(primToWrap, wrapToPrim, byte.class, Byte.class);\nadd(primToWrap, wrapToPrim, char.class, Character.class);\nadd(primToWrap, wrapToPrim, double.class, Double.class);\nadd(primToWrap, wrapToPrim, float.class, Float.class);\nadd(primToWrap, wrapToPrim, int.class, Integer.class);\nadd(primToWrap, wrapToPrim, long.class, Long.class);\nadd(primToWrap, wrapToPrim, short.class, Short.class);\nadd(primToWrap, wrapToPrim, void.class, Void.class);\n\nPRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);\nWRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:add(Ljava/util/Map;Ljava/util/Map;Ljava/lang/Class;Ljava/lang/Class;)V",
                                    "method_body": "private static void add(Map<Class<?>, Class<?>> forward,\nMap<Class<?>, Class<?>> backward, Class<?> key, Class<?> value) {\nforward.put(key, value);\nbackward.put(value, key);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:isPrimitive(Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public static boolean isPrimitive(Type type) {\nreturn PRIMITIVE_TO_WRAPPER_TYPE.containsKey(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$WildcardTypeImpl:<init>([Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\ncheckArgument(lowerBounds.length <= 1);\ncheckArgument(upperBounds.length == 1);\n\nif (lowerBounds.length == 1) {\ncheckNotNull(lowerBounds[0]);\ncheckNotPrimitive(lowerBounds[0]);\ncheckArgument(upperBounds[0] == Object.class);\nthis.lowerBound = canonicalize(lowerBounds[0]);\nthis.upperBound = Object.class;\n\n} else {\ncheckNotNull(upperBounds[0]);\ncheckNotPrimitive(upperBounds[0]);\nthis.lowerBound = null;\nthis.upperBound = canonicalize(upperBounds[0]);\n}\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.internal.bind.RecursiveTypesResolveTest.testRecursiveTypeVariablesResolve1",
                            "test_body": "102: public void testRecursiveTypeVariablesResolve1() throws Exception {\n103: TypeAdapter<TestType> adapter = new Gson().getAdapter(TestType.class);\n104: assertNotNull(adapter);\n105: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\nCollections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\nDEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\nDEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\nLongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,\nfinal Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,\nboolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\nboolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,\nLongSerializationPolicy longSerializationPolicy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.excluder = excluder;\nthis.fieldNamingStrategy = fieldNamingStrategy;\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nthis.lenient = lenient;\n\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n\n// built-in type adapters that cannot be overridden\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\n\n// the excluder must precede all adapters that handle user-defined types\nfactories.add(excluder);\n\n// user's type adapters\nfactories.addAll(typeAdapterFactories);\n\n// type adapters for basic platform types\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nTypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\ndoubleAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfloatAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\nfactories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\nfactories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.CURRENCY_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\n\n// type adapters for composite and user-defined types\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nthis.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);\nfactories.add(jsonAdapterFactory);\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nconstructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory));\n\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<clinit>()V",
                                    "method_body": "static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\nstatic final boolean DEFAULT_LENIENT = false;\nstatic final boolean DEFAULT_PRETTY_PRINT = false;\nstatic final boolean DEFAULT_ESCAPE_HTML = true;\nstatic final boolean DEFAULT_SERIALIZE_NULLS = false;\nstatic final boolean DEFAULT_COMPLEX_MAP_KEYS = false;\nstatic final boolean DEFAULT_SPECIALIZE_FLOAT_VALUES = false;\n\nprivate static final TypeToken<?> NULL_KEY_SURROGATE = TypeToken.get(Object.class);\nprivate static final String JSON_NON_EXECUTABLE_PREFIX = \")]}'\\n\";\n\n/**\n* This thread local guards against reentrant calls to getAdapter(). In\n* certain object graphs, creating an adapter for a type may recursively\n* require an adapter for the same type! Without intervention, the recursive\n* lookup would stack overflow. We cheat by returning a proxy type adapter.\n* The proxy is wired up once the initial adapter has been created.\n*/\nprivate final ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>> calls\n= new ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>>();\n\nprivate final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache = new ConcurrentHashMap<TypeToken<?>, TypeAdapter<?>>();\n\nprivate final List<TypeAdapterFactory> factories;\nprivate final ConstructorConstructor constructorConstructor;\n\nprivate final Excluder excluder;\nprivate final FieldNamingStrategy fieldNamingStrategy;\nprivate final boolean serializeNulls;\nprivate final boolean htmlSafe;\nprivate final boolean generateNonExecutableJson;\nprivate final boolean prettyPrinting;\nprivate final boolean lenient;\nprivate final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;\n\n/**\n* Constructs a Gson object with default configuration. The default configuration has the\n* following settings:\n* <ul>\n*   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n*   means that all the unneeded white-space is removed. You can change this behavior with\n*   {@link GsonBuilder#setPrettyPrinting()}. </li>"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.DOUBLE;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Double read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\ndouble doubleValue = value.doubleValue();\ncheckValidFloatingPoint(doubleValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.FLOAT;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Float read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn (float) in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nfloat floatValue = value.floatValue();\ncheckValidFloatingPoint(floatValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Number read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextLong();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nout.value(value.toString());\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLong>() {\n@Override public void write(JsonWriter out, AtomicLong value) throws IOException {\nlongAdapter.write(out, value.get());\n}\n@Override public AtomicLong read(JsonReader in) throws IOException {\nNumber value = longAdapter.read(in);\nreturn new AtomicLong(value.longValue());\n}\n}.nullSafe();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongArrayAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLongArray>() {\n@Override public void write(JsonWriter out, AtomicLongArray value) throws IOException {\nout.beginArray();\nfor (int i = 0, length = value.length(); i < length; i++) {\nlongAdapter.write(out, value.get(i));\n}\nout.endArray();\n}\n@Override public AtomicLongArray read(JsonReader in) throws IOException {\nList<Long> list = new ArrayList<Long>();\nin.beginArray();\nwhile (in.hasNext()) {\nlong value = longAdapter.read(in).longValue();\nlist.add(value);\n}\nin.endArray();\nint length = list.size();\nAtomicLongArray array = new AtomicLongArray(length);\nfor (int i = 0; i < length; ++i) {\narray.set(i, list.get(i));\n}\nreturn array;\n}\n}.nullSafe();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);\nif (cached != null) {\nreturn (TypeAdapter<T>) cached;\n}\n\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\n}\n\n// the key and value type parameters always agree\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nreturn ongoingCall;\n}\n\ntry {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\n\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\n}\n}\nthrow new IllegalArgumentException(\"GSON cannot handle \" + type);\n} finally {\nthreadCalls.remove(type);\n\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Ljava/lang/Class;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(Class<T> type) {\nreturn getAdapter(TypeToken.get(type));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/Class;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static <T> TypeToken<T> get(Class<T> type) {\nreturn new TypeToken<T>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nthrow new NullPointerException();\n}\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\nthrow new IllegalArgumentException();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\np.getRawType(), p.getActualTypeArguments());\n\n} else if (type instanceof GenericArrayType) {\nGenericArrayType g = (GenericArrayType) type;\nreturn new GenericArrayTypeImpl(g.getGenericComponentType());\n\n} else if (type instanceof WildcardType) {\nWildcardType w = (WildcardType) type;\nreturn new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n} else {\n// type is either serializable as-is or unsupported\nreturn type;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\n// type is a normal class.\nreturn (Class<?>) type;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType parameterizedType = (ParameterizedType) type;\n\n// I'm not exactly sure why getRawType() returns Type instead of Class.\n// Neal isn't either but suspects some pathological case related\n// to nested classes exists.\nType rawType = parameterizedType.getRawType();\ncheckArgument(rawType instanceof Class);\nreturn (Class<?>) rawType;\n\n} else if (type instanceof GenericArrayType) {\nType componentType = ((GenericArrayType)type).getGenericComponentType();\nreturn Array.newInstance(getRawType(componentType), 0).getClass();\n\n} else if (type instanceof TypeVariable) {\n// we could use the variable's bounds, but that won't work if there are multiple.\n// having a raw type that's more general than necessary is okay\nreturn Object.class;\n\n} else if (type instanceof WildcardType) {\nreturn getRawType(((WildcardType) type).getUpperBounds()[0]);\n\n} else {\nString className = type == null ? \"null\" : type.getClass().getName();\nthrow new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n+ \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:hashCodeOrZero(Ljava/lang/Object;)I",
                                    "method_body": "static int hashCodeOrZero(Object o) {\nreturn o != null ? o.hashCode() : 0;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getGenericSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\nif (toResolve == rawType) {\nreturn context;\n}\n\n// we skip searching through interfaces if unknown is an interface\nif (toResolve.isInterface()) {\nClass<?>[] interfaces = rawType.getInterfaces();\nfor (int i = 0, length = interfaces.length; i < length; i++) {\nif (interfaces[i] == toResolve) {\nreturn rawType.getGenericInterfaces()[i];\n} else if (toResolve.isAssignableFrom(interfaces[i])) {\nreturn getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n}\n}\n}\n\n// check our supertypes\nif (!rawType.isInterface()) {\nwhile (rawType != Object.class) {\nClass<?> rawSupertype = rawType.getSuperclass();\nif (rawSupertype == toResolve) {\nreturn rawType.getGenericSuperclass();\n} else if (toResolve.isAssignableFrom(rawSupertype)) {\nreturn getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);\n}\nrawType = rawSupertype;\n}\n}\n\n// we can't resolve this further\nreturn toResolve;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\nreturn resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;Ljava/util/Collection;)Ljava/lang/reflect/Type;",
                                    "method_body": "private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,\nCollection<TypeVariable> visitedTypeVariables) {\n// this implementation is made a little more complicated in an attempt to avoid object-creation\nwhile (true) {\nif (toResolve instanceof TypeVariable) {\nTypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n// cannot reduce due to infinite recursion\ntoResolve = resolveTypeVariable(context, contextRawType, typeVariable);\nif (toResolve == typeVariable) {\nreturn toResolve;\n}\n\n} else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\nClass<?> original = (Class<?>) toResolve;\nType componentType = original.getComponentType();\nType newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\nreturn componentType == newComponentType\n? original\n: arrayOf(newComponentType);\n\n} else if (toResolve instanceof GenericArrayType) {\nGenericArrayType original = (GenericArrayType) toResolve;\nType componentType = original.getGenericComponentType();\nType newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\nreturn componentType == newComponentType\n? original\n: arrayOf(newComponentType);\n\n} else if (toResolve instanceof ParameterizedType) {\nParameterizedType original = (ParameterizedType) toResolve;\nType ownerType = original.getOwnerType();\nType newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\nboolean changed = newOwnerType != ownerType;\n\nType[] args = original.getActualTypeArguments();\nfor (int t = 0, length = args.length; t < length; t++) {\nType resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\nif (resolvedTypeArgument != args[t]) {\nif (!changed) {\nargs = args.clone();\nchanged = true;\n}\nargs[t] = resolvedTypeArgument;\n}\n}\n\nreturn changed\n? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n: original;\n\n} else if (toResolve instanceof WildcardType) {\nWildcardType original = (WildcardType) toResolve;\nType[] originalLowerBound = original.getLowerBounds();\nType[] originalUpperBound = original.getUpperBounds();\n\nif (originalLowerBound.length == 1) {\nType lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\nif (lowerBound != originalLowerBound[0]) {\nreturn supertypeOf(lowerBound);\n}\n} else if (originalUpperBound.length == 1) {\nType upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\nif (upperBound != originalUpperBound[0]) {\nreturn subtypeOf(upperBound);\n}\n}\nreturn original;\n\n} else {\nreturn toResolve;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolveTypeVariable(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/TypeVariable;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\nClass<?> declaredByRaw = declaringClassOf(unknown);\n\n// we can't reduce this further\nif (declaredByRaw == null) {\nreturn unknown;\n}\n\nType declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\nif (declaredBy instanceof ParameterizedType) {\nint index = indexOf(declaredByRaw.getTypeParameters(), unknown);\nreturn ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\n}\n\nreturn unknown;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:indexOf([Ljava/lang/Object;Ljava/lang/Object;)I",
                                    "method_body": "private static int indexOf(Object[] array, Object toFind) {\nfor (int i = 0, length = array.length; i < length; i++) {\nif (toFind.equals(array[i])) {\nreturn i;\n}\n}\nthrow new NoSuchElementException();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:declaringClassOf(Ljava/lang/reflect/TypeVariable;)Ljava/lang/Class;",
                                    "method_body": "private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\nGenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\nreturn genericDeclaration instanceof Class\n? (Class<?>) genericDeclaration\n: null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\n\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate boolean requireExpose;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n\n@Override protected Excluder clone() {\ntry {\nreturn (Excluder) super.clone();\n} catch (CloneNotSupportedException e) {\nthrow new AssertionError(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\n\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}\n\nreturn new TypeAdapter<T>() {\n/** The delegate is lazily created because it may not be needed, and creating it may fail. */\nprivate TypeAdapter<T> delegate;\n\n@Override public T read(JsonReader in) throws IOException {\nif (skipDeserialize) {\nin.skipValue();\nreturn null;\n}\nreturn delegate().read(in);\n}\n\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (skipSerialize) {\nout.nullValue();\nreturn;\n}\ndelegate().write(out, value);\n}\n\nprivate TypeAdapter<T> delegate() {\nTypeAdapter<T> d = delegate;\nreturn d != null\n? d\n: (delegate = gson.getDelegateAdapter(Excluder.this, type));\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field field, boolean serialize) {\nif ((modifiers & field.getModifiers()) != 0) {\nreturn true;\n}\n\nif (version != Excluder.IGNORE_VERSIONS\n&& !isValidVersion(field.getAnnotation(Since.class), field.getAnnotation(Until.class))) {\nreturn true;\n}\n\nif (field.isSynthetic()) {\nreturn true;\n}\n\nif (requireExpose) {\nExpose annotation = field.getAnnotation(Expose.class);\nif (annotation == null || (serialize ? !annotation.serialize() : !annotation.deserialize())) {\nreturn true;\n}\n}\n\nif (!serializeInnerClasses && isInnerClass(field.getType())) {\nreturn true;\n}\n\nif (isAnonymousOrLocal(field.getType())) {\nreturn true;\n}\n\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nif (!list.isEmpty()) {\nFieldAttributes fieldAttributes = new FieldAttributes(field);\nfor (ExclusionStrategy exclusionStrategy : list) {\nif (exclusionStrategy.shouldSkipField(fieldAttributes)) {\nreturn true;\n}\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\n&& !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\nreturn true;\n}\n\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nreturn true;\n}\n\nif (isAnonymousOrLocal(clazz)) {\nreturn true;\n}\n\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nif (exclusionStrategy.shouldSkipClass(clazz)) {\nreturn true;\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n&& (clazz.isAnonymousClass() || clazz.isLocalClass());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.FieldNamingPolicy$1:translateName(Ljava/lang/reflect/Field;)Ljava/lang/String;",
                                    "method_body": "@Override public String translateName(Field f) {\nreturn f.getName();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\n\n// first try an instance creator\n\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn typeCreator.createInstance(type);\n}\n};\n}\n\n// Next try raw type match for instance creators\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> rawTypeCreator =\n(InstanceCreator<T>) instanceCreators.get(rawType);\nif (rawTypeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn rawTypeCreator.createInstance(type);\n}\n};\n}\n\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nreturn defaultConstructor;\n}\n\nObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\nif (defaultImplementation != null) {\nreturn defaultImplementation;\n}\n\n// finally try unsafe\nreturn newUnsafeAllocator(type, rawType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultConstructor(Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\ntry {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\n}\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"unchecked\") // T is the same raw type as is requested\n@Override public T construct() {\ntry {\nObject[] args = null;\nreturn (T) constructor.newInstance(args);\n} catch (InstantiationException e) {\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\", e);\n} catch (InvocationTargetException e) {\n// TODO: don't wrap if cause is unchecked!\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",\ne.getTargetException());\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\n}\n};\n} catch (NoSuchMethodException e) {\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n@Override\npublic void write(JsonWriter out, Class value) throws IOException {\nthrow new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n+ value.getName() + \". Forgot to register a type adapter?\");\n}\n@Override\npublic Class read(JsonReader in) throws IOException {\nthrow new UnsupportedOperationException(\n\"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n}\n}.nullSafe();"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:nullSafe()Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public final TypeAdapter<T> nullSafe() {\nreturn new TypeAdapter<T>() {\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (value == null) {\nout.nullValue();\n} else {\nTypeAdapter.this.write(out, value);\n}\n}\n@Override public T read(JsonReader reader) throws IOException {\nif (reader.peek() == JsonToken.NULL) {\nreader.nextNull();\nreturn null;\n}\nreturn TypeAdapter.this.read(reader);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$35:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$26:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}\n\nfinal TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\nreturn (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n@Override public Timestamp read(JsonReader in) throws IOException {\nDate date = dateTypeAdapter.read(in);\nreturn date != null ? new Timestamp(date.getTime()) : null;\n}\n\n@Override public void write(JsonWriter out, Timestamp value) throws IOException {\ndateTypeAdapter.write(out, value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$34:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$30:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nif (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {\nreturn null;\n}\nif (!rawType.isEnum()) {\nrawType = rawType.getSuperclass(); // handle anonymous subclasses\n}\nreturn (TypeAdapter<T>) new EnumTypeAdapter(rawType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nType elementType = $Gson$Types.getCollectionElementType(type, rawType);\nTypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // create() doesn't define a type parameter\nTypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nClass<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\nType[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\nTypeAdapter<?> keyAdapter = getKeyAdapter(gson, keyAndValueTypes[0]);\nTypeAdapter<?> valueAdapter = gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n// we don't define a type parameter for the key or value types\nTypeAdapter<T> result = new Adapter(gson, keyAndValueTypes[0], keyAdapter,\nkeyAndValueTypes[1], valueAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\nClass<? super T> rawType = targetType.getRawType();\nJsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);\nif (annotation == null) {\nreturn null;\n}\nreturn (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;Lcom/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nFieldNamingStrategy fieldNamingPolicy, Excluder excluder,\nJsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\nthis.jsonAdapterFactory = jsonAdapterFactory;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field f, boolean serialize) {\nreturn excludeField(f, serialize, excluder);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;ZLcom/google/gson/internal/Excluder;)Z",
                                    "method_body": "static boolean excludeField(Field f, boolean serialize, Excluder excluder) {\nreturn !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getFieldNames(Ljava/lang/reflect/Field;)Ljava/util/List;",
                                    "method_body": "private List<String> getFieldNames(Field f) {\nSerializedName annotation = f.getAnnotation(SerializedName.class);\nif (annotation == null) {\nString name = fieldNamingPolicy.translateName(f);\nreturn Collections.singletonList(name);\n}\n\nString serializedName = annotation.value();\nString[] alternates = annotation.alternate();\nif (alternates.length == 0) {\nreturn Collections.singletonList(serializedName);\n}\n\nList<String> fieldNames = new ArrayList<String>(alternates.length + 1);\nfieldNames.add(serializedName);\nfor (String alternate : alternates) {\nfieldNames.add(alternate);\n}\nreturn fieldNames;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\nClass<? super T> raw = type.getRawType();\n\nif (!Object.class.isAssignableFrom(raw)) {\nreturn null; // it's a primitive!\n}\n\nObjectConstructor<T> constructor = constructorConstructor.get(type);\nreturn new Adapter<T>(constructor, getBoundFields(gson, type, raw));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:createBoundField(Lcom/google/gson/Gson;Ljava/lang/reflect/Field;Ljava/lang/String;Lcom/google/gson/reflect/TypeToken;ZZ)Lcom/google/gson/internal/bind/ReflectiveTypeAdapterFactory$BoundField;",
                                    "method_body": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(\nfinal Gson context, final Field field, final String name,\nfinal TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\nfinal boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n// special casing primitives here saves ~5% on Android...\nJsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\nTypeAdapter<?> mapped = null;\nif (annotation != null) {\nmapped = jsonAdapterFactory.getTypeAdapter(\nconstructorConstructor, context, fieldType, annotation);\n}\nfinal boolean jsonAdapterPresent = mapped != null;\nif (mapped == null) mapped = context.getAdapter(fieldType);\n\nfinal TypeAdapter<?> typeAdapter = mapped;\nreturn new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n@Override void write(JsonWriter writer, Object value)\nthrows IOException, IllegalAccessException {\nObject fieldValue = field.get(value);\nTypeAdapter t = jsonAdapterPresent ? typeAdapter\n: new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\nt.write(writer, fieldValue);\n}\n@Override void read(JsonReader reader, Object value)\nthrows IOException, IllegalAccessException {\nObject fieldValue = typeAdapter.read(reader);\nif (fieldValue != null || !isPrimitive) {\nfield.set(value, fieldValue);\n}\n}\n@Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\nif (!serialized) return false;\nObject fieldValue = field.get(value);\nreturn fieldValue != value; // avoid recursion for example for Throwable.cause\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getBoundFields(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;Ljava/lang/Class;)Ljava/util/Map;",
                                    "method_body": "private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {\nMap<String, BoundField> result = new LinkedHashMap<String, BoundField>();\nif (raw.isInterface()) {\nreturn result;\n}\n\nType declaredType = type.getType();\nwhile (raw != Object.class) {\nField[] fields = raw.getDeclaredFields();\nfor (Field field : fields) {\nboolean serialize = excludeField(field, true);\nboolean deserialize = excludeField(field, false);\nif (!serialize && !deserialize) {\ncontinue;\n}\nfield.setAccessible(true);\nType fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\nList<String> fieldNames = getFieldNames(field);\nBoundField previous = null;\nfor (int i = 0, size = fieldNames.size(); i < size; ++i) {\nString name = fieldNames.get(i);\nif (i != 0) serialize = false; // only serialize the default name\nBoundField boundField = createBoundField(context, field, name,\nTypeToken.get(fieldType), serialize, deserialize);\nBoundField replaced = result.put(name, boundField);\nif (previous == null) previous = replaced;\n}\nif (previous != null) {\nthrow new IllegalArgumentException(declaredType\n+ \" declares multiple JSON fields named \" + previous.name);\n}\n}\ntype = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\nraw = type.getRawType();\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$ParameterizedTypeImpl:<init>(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n// require an owner type if the raw type needs it\nif (rawType instanceof Class<?>) {\nClass<?> rawTypeAsClass = (Class<?>) rawType;\nboolean isStaticOrTopLevelClass = Modifier.isStatic(rawTypeAsClass.getModifiers())\n|| rawTypeAsClass.getEnclosingClass() == null;\ncheckArgument(ownerType != null || isStaticOrTopLevelClass);\n}\n\nthis.ownerType = ownerType == null ? null : canonicalize(ownerType);\nthis.rawType = canonicalize(rawType);\nthis.typeArguments = typeArguments.clone();\nfor (int t = 0, length = this.typeArguments.length; t < length; t++) {\ncheckNotNull(this.typeArguments[t]);\ncheckNotPrimitive(this.typeArguments[t]);\nthis.typeArguments[t] = canonicalize(this.typeArguments[t]);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:<clinit>()V",
                                    "method_body": "private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;\n\n/** A map from wrapper types to their corresponding primitive types. */\nprivate static final Map<Class<?>, Class<?>> WRAPPER_TO_PRIMITIVE_TYPE;\n\n// Sad that we can't use a BiMap. :(\n\nstatic {\nMap<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);\nMap<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);\n\nadd(primToWrap, wrapToPrim, boolean.class, Boolean.class);\nadd(primToWrap, wrapToPrim, byte.class, Byte.class);\nadd(primToWrap, wrapToPrim, char.class, Character.class);\nadd(primToWrap, wrapToPrim, double.class, Double.class);\nadd(primToWrap, wrapToPrim, float.class, Float.class);\nadd(primToWrap, wrapToPrim, int.class, Integer.class);\nadd(primToWrap, wrapToPrim, long.class, Long.class);\nadd(primToWrap, wrapToPrim, short.class, Short.class);\nadd(primToWrap, wrapToPrim, void.class, Void.class);\n\nPRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);\nWRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:add(Ljava/util/Map;Ljava/util/Map;Ljava/lang/Class;Ljava/lang/Class;)V",
                                    "method_body": "private static void add(Map<Class<?>, Class<?>> forward,\nMap<Class<?>, Class<?>> backward, Class<?> key, Class<?> value) {\nforward.put(key, value);\nbackward.put(value, key);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:isPrimitive(Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public static boolean isPrimitive(Type type) {\nreturn PRIMITIVE_TO_WRAPPER_TYPE.containsKey(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$WildcardTypeImpl:<init>([Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\ncheckArgument(lowerBounds.length <= 1);\ncheckArgument(upperBounds.length == 1);\n\nif (lowerBounds.length == 1) {\ncheckNotNull(lowerBounds[0]);\ncheckNotPrimitive(lowerBounds[0]);\ncheckArgument(upperBounds[0] == Object.class);\nthis.lowerBound = canonicalize(lowerBounds[0]);\nthis.upperBound = Object.class;\n\n} else {\ncheckNotNull(upperBounds[0]);\ncheckNotPrimitive(upperBounds[0]);\nthis.lowerBound = null;\nthis.upperBound = canonicalize(upperBounds[0]);\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 17,
                    "tests": [
                        {
                            "test_name": "com.google.gson.DefaultDateTypeAdapterTest.testUnexpectedToken",
                            "test_body": "170: public void testUnexpectedToken() throws Exception {\n171: try {\n172: DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter(Date.class);\n173: adapter.fromJson(\"{}\");\n174: fail(\"Unexpected token should fail.\");\n175: } catch (IllegalStateException expected) { }\n176: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:fromJson(Ljava/io/Reader;)Ljava/lang/Object;",
                                    "method_body": "public final T fromJson(Reader in) throws IOException {\nJsonReader reader = new JsonReader(in);\nreturn read(reader);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:fromJson(Ljava/lang/String;)Ljava/lang/Object;",
                                    "method_body": "public final T fromJson(String json) throws IOException {\nreturn fromJson(new StringReader(json));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "public JsonReader(Reader in) {\nif (in == null) {\nthrow new NullPointerException(\"in == null\");\n}\nthis.in = in;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<clinit>()V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;\n\nprivate static final int PEEKED_NONE = 0;\nprivate static final int PEEKED_BEGIN_OBJECT = 1;\nprivate static final int PEEKED_END_OBJECT = 2;\nprivate static final int PEEKED_BEGIN_ARRAY = 3;\nprivate static final int PEEKED_END_ARRAY = 4;\nprivate static final int PEEKED_TRUE = 5;\nprivate static final int PEEKED_FALSE = 6;\nprivate static final int PEEKED_NULL = 7;\nprivate static final int PEEKED_SINGLE_QUOTED = 8;\nprivate static final int PEEKED_DOUBLE_QUOTED = 9;\nprivate static final int PEEKED_UNQUOTED = 10;\n/** When this is returned, the string value is stored in peekedString. */\nprivate static final int PEEKED_BUFFERED = 11;\nprivate static final int PEEKED_SINGLE_QUOTED_NAME = 12;\nprivate static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\nprivate static final int PEEKED_UNQUOTED_NAME = 14;\n/** When this is returned, the integer value is stored in peekedLong. */\nprivate static final int PEEKED_LONG = 15;\nprivate static final int PEEKED_NUMBER = 16;\nprivate static final int PEEKED_EOF = 17;\n\n/* State machine when parsing numbers */\nprivate static final int NUMBER_CHAR_NONE = 0;\nprivate static final int NUMBER_CHAR_SIGN = 1;\nprivate static final int NUMBER_CHAR_DIGIT = 2;\nprivate static final int NUMBER_CHAR_DECIMAL = 3;\nprivate static final int NUMBER_CHAR_FRACTION_DIGIT = 4;\nprivate static final int NUMBER_CHAR_EXP_E = 5;\nprivate static final int NUMBER_CHAR_EXP_SIGN = 6;\nprivate static final int NUMBER_CHAR_EXP_DIGIT = 7;\n\n/** The input JSON. */\nprivate final Reader in;\n\n/** True to accept non-spec compliant JSON */\nprivate boolean lenient = false;\n\n/**\n* Use a manual buffer to easily read and unread upcoming characters, and\n* also so we can create strings without an intermediate StringBuilder.\n* We decode literals directly out of this buffer, so it must be at least as\n* long as the longest token that can be reported as a number.\n*/\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\n\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\n\nint peeked = PEEKED_NONE;\n\n/**\n* A peeked value that was composed entirely of digits with an optional\n* leading dash. Positive values may not have a leading 0.\n*/\nprivate long peekedLong;\n\n/**\n* The number of characters in a peeked number literal. Increment 'pos' by\n* this after reading a number.\n*/\nprivate int peekedNumberLength;\n\n/**\n* A peeked string that should be parsed on the next double, long or string.\n* This is populated before a numeric value is parsed and used if that parsing\n* fails.\n*/\nprivate String peekedString;\n\n/*\n* The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n*/\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\n{\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\n\nswitch (p) {\ncase PEEKED_BEGIN_OBJECT:\nreturn JsonToken.BEGIN_OBJECT;\ncase PEEKED_END_OBJECT:\nreturn JsonToken.END_OBJECT;\ncase PEEKED_BEGIN_ARRAY:\nreturn JsonToken.BEGIN_ARRAY;\ncase PEEKED_END_ARRAY:\nreturn JsonToken.END_ARRAY;\ncase PEEKED_SINGLE_QUOTED_NAME:\ncase PEEKED_DOUBLE_QUOTED_NAME:\ncase PEEKED_UNQUOTED_NAME:\nreturn JsonToken.NAME;\ncase PEEKED_TRUE:\ncase PEEKED_FALSE:\nreturn JsonToken.BOOLEAN;\ncase PEEKED_NULL:\nreturn JsonToken.NULL;\ncase PEEKED_SINGLE_QUOTED:\ncase PEEKED_DOUBLE_QUOTED:\ncase PEEKED_UNQUOTED:\ncase PEEKED_BUFFERED:\nreturn JsonToken.STRING;\ncase PEEKED_LONG:\ncase PEEKED_NUMBER:\nreturn JsonToken.NUMBER;\ncase PEEKED_EOF:\nreturn JsonToken.END_DOCUMENT;\ndefault:\nthrow new AssertionError();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:doPeek()I",
                                    "method_body": "int doPeek() throws IOException {\nint peekStack = stack[stackSize - 1];\nif (peekStack == JsonScope.EMPTY_ARRAY) {\nstack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n} else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n// Look for a comma before the next element.\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase ']':\nreturn peeked = PEEKED_END_ARRAY;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated array\");\n}\n} else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\nstack[stackSize - 1] = JsonScope.DANGLING_NAME;\n// Look for a comma before the next element.\nif (peekStack == JsonScope.NONEMPTY_OBJECT) {\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '}':\nreturn peeked = PEEKED_END_OBJECT;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated object\");\n}\n}\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '\"':\nreturn peeked = PEEKED_DOUBLE_QUOTED_NAME;\ncase '\\'':\ncheckLenient();\nreturn peeked = PEEKED_SINGLE_QUOTED_NAME;\ncase '}':\nif (peekStack != JsonScope.NONEMPTY_OBJECT) {\nreturn peeked = PEEKED_END_OBJECT;\n} else {\nthrow syntaxError(\"Expected name\");\n}\ndefault:\ncheckLenient();\npos--; // Don't consume the first character in an unquoted string.\nif (isLiteral((char) c)) {\nreturn peeked = PEEKED_UNQUOTED_NAME;\n} else {\nthrow syntaxError(\"Expected name\");\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit -= pos;\nSystem.arraycopy(buffer, pos, buffer, 0, limit);\n} else {\nlimit = 0;\n}\n\npos = 0;\nint total;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\n\n// if this is the first read, consume an optional byte order mark (BOM) if it exists\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\npos++;\nlineStart++;\nminimum++;\n}\n\nif (limit >= minimum) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n/*\n* This code uses ugly local variables 'p' and 'l' representing the 'pos'\n* and 'limit' fields respectively. Using locals rather than fields saves\n* a few field reads for each whitespace character in a pretty-printed\n* document, resulting in a 5% speedup. We need to flush 'p' to its field\n* before any (potentially indirect) call to fillBuffer() and reread both\n* 'p' and 'l' after any (potentially indirect) call to the same method.\n*/\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nwhile (true) {\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\nbreak;\n}\np = pos;\nl = limit;\n}\n\nint c = buffer[p++];\nif (c == '\\n') {\nlineNumber++;\nlineStart = p;\ncontinue;\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\ncontinue;\n}\n\nif (c == '/') {\npos = p;\nif (p == l) {\npos--; // push back '/' so it's still in the buffer when this method returns\nboolean charsLoaded = fillBuffer(2);\npos++; // consume the '/' again\nif (!charsLoaded) {\nreturn c;\n}\n}\n\ncheckLenient();\nchar peek = buffer[pos];\nswitch (peek) {\ncase '*':\n// skip a /* c-style comment */\npos++;\nif (!skipTo(\"*/\")) {\nthrow syntaxError(\"Unterminated comment\");\n}\np = pos + 2;\nl = limit;\ncontinue;\n\ncase '/':\n// skip a // end-of-line comment\npos++;\nskipToEndOfLine();\np = pos;\nl = limit;\ncontinue;\n\ndefault:\nreturn c;\n}\n} else if (c == '#') {\npos = p;\n/*\n* Skip a # hash end-of-line comment. The JSON RFC doesn't\n* specify this behaviour, but it's required to parse\n* existing documents. See http://b/2571423.\n*/\ncheckLenient();\nskipToEndOfLine();\np = pos;\nl = limit;\n} else {\npos = p;\nreturn c;\n}\n}\nif (throwOnEof) {\nthrow new EOFException(\"End of input\" + locationString());\n} else {\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonParseException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public JsonParseException(String msg) {\nsuper(msg);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultDateTypeAdapter:<init>(Ljava/lang/Class;)V",
                                    "method_body": "DefaultDateTypeAdapter(Class<? extends Date> dateType) {\nthis(dateType,\nDateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),\nDateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultDateTypeAdapter:<init>(Ljava/lang/Class;Ljava/text/DateFormat;Ljava/text/DateFormat;)V",
                                    "method_body": "DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat) {\nif ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) {\nthrow new IllegalArgumentException(\"Date type must be one of \" + Date.class + \", \" + Timestamp.class + \", or \" + java.sql.Date.class + \" but was \" + dateType);\n}\nthis.dateType = dateType;\nthis.enUsFormat = enUsFormat;\nthis.localFormat = localFormat;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultDateTypeAdapter:read(Lcom/google/gson/stream/JsonReader;)Ljava/util/Date;",
                                    "method_body": "public Date read(JsonReader in) throws IOException {\nif (in.peek() != JsonToken.STRING) {\nthrow new JsonParseException(\"The date should be a string value\");\n}\nDate date = deserializeToDate(in.nextString());\nif (dateType == Date.class) {\nreturn date;\n} else if (dateType == Timestamp.class) {\nreturn new Timestamp(date.getTime());\n} else if (dateType == java.sql.Date.class) {\nreturn new java.sql.Date(date.getTime());\n} else {\n// This must never happen: dateType is guarded in the primary constructor\nthrow new AssertionError();\n}\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.google.gson.DefaultDateTypeAdapterTest.testNullValue",
                            "test_body": "164: public void testNullValue() throws Exception {\n165: DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter(Date.class);\n166: assertNull(adapter.fromJson(\"null\"));\n167: assertEquals(\"null\", adapter.toJson(null));\n168: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:fromJson(Ljava/io/Reader;)Ljava/lang/Object;",
                                    "method_body": "public final T fromJson(Reader in) throws IOException {\nJsonReader reader = new JsonReader(in);\nreturn read(reader);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:fromJson(Ljava/lang/String;)Ljava/lang/Object;",
                                    "method_body": "public final T fromJson(String json) throws IOException {\nreturn fromJson(new StringReader(json));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "public JsonReader(Reader in) {\nif (in == null) {\nthrow new NullPointerException(\"in == null\");\n}\nthis.in = in;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<clinit>()V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;\n\nprivate static final int PEEKED_NONE = 0;\nprivate static final int PEEKED_BEGIN_OBJECT = 1;\nprivate static final int PEEKED_END_OBJECT = 2;\nprivate static final int PEEKED_BEGIN_ARRAY = 3;\nprivate static final int PEEKED_END_ARRAY = 4;\nprivate static final int PEEKED_TRUE = 5;\nprivate static final int PEEKED_FALSE = 6;\nprivate static final int PEEKED_NULL = 7;\nprivate static final int PEEKED_SINGLE_QUOTED = 8;\nprivate static final int PEEKED_DOUBLE_QUOTED = 9;\nprivate static final int PEEKED_UNQUOTED = 10;\n/** When this is returned, the string value is stored in peekedString. */\nprivate static final int PEEKED_BUFFERED = 11;\nprivate static final int PEEKED_SINGLE_QUOTED_NAME = 12;\nprivate static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\nprivate static final int PEEKED_UNQUOTED_NAME = 14;\n/** When this is returned, the integer value is stored in peekedLong. */\nprivate static final int PEEKED_LONG = 15;\nprivate static final int PEEKED_NUMBER = 16;\nprivate static final int PEEKED_EOF = 17;\n\n/* State machine when parsing numbers */\nprivate static final int NUMBER_CHAR_NONE = 0;\nprivate static final int NUMBER_CHAR_SIGN = 1;\nprivate static final int NUMBER_CHAR_DIGIT = 2;\nprivate static final int NUMBER_CHAR_DECIMAL = 3;\nprivate static final int NUMBER_CHAR_FRACTION_DIGIT = 4;\nprivate static final int NUMBER_CHAR_EXP_E = 5;\nprivate static final int NUMBER_CHAR_EXP_SIGN = 6;\nprivate static final int NUMBER_CHAR_EXP_DIGIT = 7;\n\n/** The input JSON. */\nprivate final Reader in;\n\n/** True to accept non-spec compliant JSON */\nprivate boolean lenient = false;\n\n/**\n* Use a manual buffer to easily read and unread upcoming characters, and\n* also so we can create strings without an intermediate StringBuilder.\n* We decode literals directly out of this buffer, so it must be at least as\n* long as the longest token that can be reported as a number.\n*/\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\n\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\n\nint peeked = PEEKED_NONE;\n\n/**\n* A peeked value that was composed entirely of digits with an optional\n* leading dash. Positive values may not have a leading 0.\n*/\nprivate long peekedLong;\n\n/**\n* The number of characters in a peeked number literal. Increment 'pos' by\n* this after reading a number.\n*/\nprivate int peekedNumberLength;\n\n/**\n* A peeked string that should be parsed on the next double, long or string.\n* This is populated before a numeric value is parsed and used if that parsing\n* fails.\n*/\nprivate String peekedString;\n\n/*\n* The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n*/\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\n{\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\n\nswitch (p) {\ncase PEEKED_BEGIN_OBJECT:\nreturn JsonToken.BEGIN_OBJECT;\ncase PEEKED_END_OBJECT:\nreturn JsonToken.END_OBJECT;\ncase PEEKED_BEGIN_ARRAY:\nreturn JsonToken.BEGIN_ARRAY;\ncase PEEKED_END_ARRAY:\nreturn JsonToken.END_ARRAY;\ncase PEEKED_SINGLE_QUOTED_NAME:\ncase PEEKED_DOUBLE_QUOTED_NAME:\ncase PEEKED_UNQUOTED_NAME:\nreturn JsonToken.NAME;\ncase PEEKED_TRUE:\ncase PEEKED_FALSE:\nreturn JsonToken.BOOLEAN;\ncase PEEKED_NULL:\nreturn JsonToken.NULL;\ncase PEEKED_SINGLE_QUOTED:\ncase PEEKED_DOUBLE_QUOTED:\ncase PEEKED_UNQUOTED:\ncase PEEKED_BUFFERED:\nreturn JsonToken.STRING;\ncase PEEKED_LONG:\ncase PEEKED_NUMBER:\nreturn JsonToken.NUMBER;\ncase PEEKED_EOF:\nreturn JsonToken.END_DOCUMENT;\ndefault:\nthrow new AssertionError();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:doPeek()I",
                                    "method_body": "int doPeek() throws IOException {\nint peekStack = stack[stackSize - 1];\nif (peekStack == JsonScope.EMPTY_ARRAY) {\nstack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n} else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n// Look for a comma before the next element.\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase ']':\nreturn peeked = PEEKED_END_ARRAY;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated array\");\n}\n} else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\nstack[stackSize - 1] = JsonScope.DANGLING_NAME;\n// Look for a comma before the next element.\nif (peekStack == JsonScope.NONEMPTY_OBJECT) {\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '}':\nreturn peeked = PEEKED_END_OBJECT;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated object\");\n}\n}\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '\"':\nreturn peeked = PEEKED_DOUBLE_QUOTED_NAME;\ncase '\\'':\ncheckLenient();\nreturn peeked = PEEKED_SINGLE_QUOTED_NAME;\ncase '}':\nif (peekStack != JsonScope.NONEMPTY_OBJECT) {\nreturn peeked = PEEKED_END_OBJECT;\n} else {\nthrow syntaxError(\"Expected name\");\n}\ndefault:\ncheckLenient();\npos--; // Don't consume the first character in an unquoted string.\nif (isLiteral((char) c)) {\nreturn peeked = PEEKED_UNQUOTED_NAME;\n} else {\nthrow syntaxError(\"Expected name\");\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit -= pos;\nSystem.arraycopy(buffer, pos, buffer, 0, limit);\n} else {\nlimit = 0;\n}\n\npos = 0;\nint total;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\n\n// if this is the first read, consume an optional byte order mark (BOM) if it exists\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\npos++;\nlineStart++;\nminimum++;\n}\n\nif (limit >= minimum) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n/*\n* This code uses ugly local variables 'p' and 'l' representing the 'pos'\n* and 'limit' fields respectively. Using locals rather than fields saves\n* a few field reads for each whitespace character in a pretty-printed\n* document, resulting in a 5% speedup. We need to flush 'p' to its field\n* before any (potentially indirect) call to fillBuffer() and reread both\n* 'p' and 'l' after any (potentially indirect) call to the same method.\n*/\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nwhile (true) {\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\nbreak;\n}\np = pos;\nl = limit;\n}\n\nint c = buffer[p++];\nif (c == '\\n') {\nlineNumber++;\nlineStart = p;\ncontinue;\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\ncontinue;\n}\n\nif (c == '/') {\npos = p;\nif (p == l) {\npos--; // push back '/' so it's still in the buffer when this method returns\nboolean charsLoaded = fillBuffer(2);\npos++; // consume the '/' again\nif (!charsLoaded) {\nreturn c;\n}\n}\n\ncheckLenient();\nchar peek = buffer[pos];\nswitch (peek) {\ncase '*':\n// skip a /* c-style comment */\npos++;\nif (!skipTo(\"*/\")) {\nthrow syntaxError(\"Unterminated comment\");\n}\np = pos + 2;\nl = limit;\ncontinue;\n\ncase '/':\n// skip a // end-of-line comment\npos++;\nskipToEndOfLine();\np = pos;\nl = limit;\ncontinue;\n\ndefault:\nreturn c;\n}\n} else if (c == '#') {\npos = p;\n/*\n* Skip a # hash end-of-line comment. The JSON RFC doesn't\n* specify this behaviour, but it's required to parse\n* existing documents. See http://b/2571423.\n*/\ncheckLenient();\nskipToEndOfLine();\np = pos;\nl = limit;\n} else {\npos = p;\nreturn c;\n}\n}\nif (throwOnEof) {\nthrow new EOFException(\"End of input\" + locationString());\n} else {\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.JsonParseException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public JsonParseException(String msg) {\nsuper(msg);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultDateTypeAdapter:<init>(Ljava/lang/Class;)V",
                                    "method_body": "DefaultDateTypeAdapter(Class<? extends Date> dateType) {\nthis(dateType,\nDateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),\nDateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultDateTypeAdapter:<init>(Ljava/lang/Class;Ljava/text/DateFormat;Ljava/text/DateFormat;)V",
                                    "method_body": "DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat) {\nif ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) {\nthrow new IllegalArgumentException(\"Date type must be one of \" + Date.class + \", \" + Timestamp.class + \", or \" + java.sql.Date.class + \" but was \" + dateType);\n}\nthis.dateType = dateType;\nthis.enUsFormat = enUsFormat;\nthis.localFormat = localFormat;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.DefaultDateTypeAdapter:read(Lcom/google/gson/stream/JsonReader;)Ljava/util/Date;",
                                    "method_body": "public Date read(JsonReader in) throws IOException {\nif (in.peek() != JsonToken.STRING) {\nthrow new JsonParseException(\"The date should be a string value\");\n}\nDate date = deserializeToDate(in.nextString());\nif (dateType == Date.class) {\nreturn date;\n} else if (dateType == Timestamp.class) {\nreturn new Timestamp(date.getTime());\n} else if (dateType == java.sql.Date.class) {\nreturn new java.sql.Date(date.getTime());\n} else {\n// This must never happen: dateType is guarded in the primary constructor\nthrow new AssertionError();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peekKeyword()I",
                                    "method_body": "private int peekKeyword() throws IOException {\n// Figure out which keyword we're matching against by its first character.\nchar c = buffer[pos];\nString keyword;\nString keywordUpper;\nint peeking;\nif (c == 't' || c == 'T') {\nkeyword = \"true\";\nkeywordUpper = \"TRUE\";\npeeking = PEEKED_TRUE;\n} else if (c == 'f' || c == 'F') {\nkeyword = \"false\";\nkeywordUpper = \"FALSE\";\npeeking = PEEKED_FALSE;\n} else if (c == 'n' || c == 'N') {\nkeyword = \"null\";\nkeywordUpper = \"NULL\";\npeeking = PEEKED_NULL;\n} else {\nreturn PEEKED_NONE;\n}\n\n// Confirm that chars [1..length) match the keyword.\nint length = keyword.length();\nfor (int i = 1; i < length; i++) {\nif (pos + i >= limit && !fillBuffer(i + 1)) {\nreturn PEEKED_NONE;\n}\nc = buffer[pos + i];\nif (c != keyword.charAt(i) && c != keywordUpper.charAt(i)) {\nreturn PEEKED_NONE;\n}\n}\n\nif ((pos + length < limit || fillBuffer(length + 1))\n&& isLiteral(buffer[pos + length])) {\nreturn PEEKED_NONE; // Don't match trues, falsey or nullsoft!\n}\n\n// We've found the keyword followed either by EOF or by a non-literal character.\npos += length;\nreturn peeked = peeking;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 18,
                    "tests": [
                        {
                            "test_name": "com.google.gson.functional.CollectionTest.testIssue1107",
                            "test_body": "401: public void testIssue1107() {\n402: String json = \"{\\n\" +\n403: \"  \\\"inBig\\\": {\\n\" +\n404: \"    \\\"key\\\": [\\n\" +\n405: \"      { \\\"inSmall\\\": \\\"hello\\\" }\\n\" +\n406: \"    ]\\n\" +\n407: \"  }\\n\" +\n408: \"}\";\n409: BigClass bigClass = new Gson().fromJson(json, BigClass.class);\n410: SmallClass small = bigClass.inBig.get(\"key\").get(0);\n411: assertNotNull(small);\n412: assertEquals(\"hello\", small.inSmall);\n413: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.google.gson.Gson:<init>()V",
                                    "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\nCollections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\nDEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\nDEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\nLongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT, DateFormat.DEFAULT,\nCollections.<TypeAdapterFactory>emptyList(), Collections.<TypeAdapterFactory>emptyList(),\nCollections.<TypeAdapterFactory>emptyList());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/lang/String;IILjava/util/List;Ljava/util/List;Ljava/util/List;)V",
                                    "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,\nfinal Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,\nboolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\nboolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,\nLongSerializationPolicy longSerializationPolicy, String datePattern, int dateStyle,\nint timeStyle, List<TypeAdapterFactory> builderFactories,\nList<TypeAdapterFactory> builderHierarchyFactories,\nList<TypeAdapterFactory> factoriesToBeAdded) {\nthis.excluder = excluder;\nthis.fieldNamingStrategy = fieldNamingStrategy;\nthis.instanceCreators = instanceCreators;\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.serializeNulls = serializeNulls;\nthis.complexMapKeySerialization = complexMapKeySerialization;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nthis.lenient = lenient;\nthis.serializeSpecialFloatingPointValues = serializeSpecialFloatingPointValues;\nthis.longSerializationPolicy = longSerializationPolicy;\nthis.datePattern = datePattern;\nthis.dateStyle = dateStyle;\nthis.timeStyle = timeStyle;\nthis.builderFactories = builderFactories;\nthis.builderHierarchyFactories = builderHierarchyFactories;\n\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n\n// built-in type adapters that cannot be overridden\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\n\n// the excluder must precede all adapters that handle user-defined types\nfactories.add(excluder);\n\n// users' type adapters\nfactories.addAll(factoriesToBeAdded);\n\n// type adapters for basic platform types\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nTypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\ndoubleAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfloatAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\nfactories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\nfactories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.CURRENCY_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\n\n// type adapters for composite and user-defined types\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nthis.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);\nfactories.add(jsonAdapterFactory);\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nconstructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory));\n\nthis.factories = Collections.unmodifiableList(factories);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:<clinit>()V",
                                    "method_body": "static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\nstatic final boolean DEFAULT_LENIENT = false;\nstatic final boolean DEFAULT_PRETTY_PRINT = false;\nstatic final boolean DEFAULT_ESCAPE_HTML = true;\nstatic final boolean DEFAULT_SERIALIZE_NULLS = false;\nstatic final boolean DEFAULT_COMPLEX_MAP_KEYS = false;\nstatic final boolean DEFAULT_SPECIALIZE_FLOAT_VALUES = false;\n\nprivate static final TypeToken<?> NULL_KEY_SURROGATE = TypeToken.get(Object.class);\nprivate static final String JSON_NON_EXECUTABLE_PREFIX = \")]}'\\n\";\n\n/**\n* This thread local guards against reentrant calls to getAdapter(). In\n* certain object graphs, creating an adapter for a type may recursively\n* require an adapter for the same type! Without intervention, the recursive\n* lookup would stack overflow. We cheat by returning a proxy type adapter.\n* The proxy is wired up once the initial adapter has been created.\n*/\nprivate final ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>> calls\n= new ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>>();\n\nprivate final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache = new ConcurrentHashMap<TypeToken<?>, TypeAdapter<?>>();\n\nprivate final ConstructorConstructor constructorConstructor;\nprivate final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;\n\nfinal List<TypeAdapterFactory> factories;\n\nfinal Excluder excluder;\nfinal FieldNamingStrategy fieldNamingStrategy;\nfinal Map<Type, InstanceCreator<?>> instanceCreators;\nfinal boolean serializeNulls;\nfinal boolean complexMapKeySerialization;\nfinal boolean generateNonExecutableJson;\nfinal boolean htmlSafe;\nfinal boolean prettyPrinting;\nfinal boolean lenient;\nfinal boolean serializeSpecialFloatingPointValues;\nfinal String datePattern;\nfinal int dateStyle;\nfinal int timeStyle;\nfinal LongSerializationPolicy longSerializationPolicy;\nfinal List<TypeAdapterFactory> builderFactories;\nfinal List<TypeAdapterFactory> builderHierarchyFactories;\n\n/**\n* Constructs a Gson object with default configuration. The default configuration has the\n* following settings:\n* <ul>\n*   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n*   means that all the unneeded white-space is removed. You can change this behavior with\n*   {@link GsonBuilder#setPrettyPrinting()}. </li>"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.DOUBLE;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Double read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\ndouble doubleValue = value.doubleValue();\ncheckValidFloatingPoint(doubleValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.FLOAT;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Float read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn (float) in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nfloat floatValue = value.floatValue();\ncheckValidFloatingPoint(floatValue);\nout.value(value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Number read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextLong();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nout.value(value.toString());\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLong>() {\n@Override public void write(JsonWriter out, AtomicLong value) throws IOException {\nlongAdapter.write(out, value.get());\n}\n@Override public AtomicLong read(JsonReader in) throws IOException {\nNumber value = longAdapter.read(in);\nreturn new AtomicLong(value.longValue());\n}\n}.nullSafe();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:atomicLongArrayAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLongArray>() {\n@Override public void write(JsonWriter out, AtomicLongArray value) throws IOException {\nout.beginArray();\nfor (int i = 0, length = value.length(); i < length; i++) {\nlongAdapter.write(out, value.get(i));\n}\nout.endArray();\n}\n@Override public AtomicLongArray read(JsonReader in) throws IOException {\nList<Long> list = new ArrayList<Long>();\nin.beginArray();\nwhile (in.hasNext()) {\nlong value = longAdapter.read(in).longValue();\nlist.add(value);\n}\nin.endArray();\nint length = list.size();\nAtomicLongArray array = new AtomicLongArray(length);\nfor (int i = 0; i < length; ++i) {\narray.set(i, list.get(i));\n}\nreturn array;\n}\n}.nullSafe();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);\nif (cached != null) {\nreturn (TypeAdapter<T>) cached;\n}\n\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\n}\n\n// the key and value type parameters always agree\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nreturn ongoingCall;\n}\n\ntry {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\n\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\n}\n}\nthrow new IllegalArgumentException(\"GSON cannot handle \" + type);\n} finally {\nthreadCalls.remove(type);\n\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:newJsonReader(Ljava/io/Reader;)Lcom/google/gson/stream/JsonReader;",
                                    "method_body": "public JsonReader newJsonReader(Reader reader) {\nJsonReader jsonReader = new JsonReader(reader);\njsonReader.setLenient(lenient);\nreturn jsonReader;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException {\nObject object = fromJson(json, (Type) classOfT);\nreturn Primitives.wrap(classOfT).cast(object);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {\nif (json == null) {\nreturn null;\n}\nStringReader reader = new StringReader(json);\nT target = (T) fromJson(reader, typeOfT);\nreturn target;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Ljava/io/Reader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nJsonReader jsonReader = newJsonReader(json);\nT object = (T) fromJson(jsonReader, typeOfT);\nassertFullConsumption(object, jsonReader);\nreturn object;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:assertFullConsumption(Ljava/lang/Object;Lcom/google/gson/stream/JsonReader;)V",
                                    "method_body": "private static void assertFullConsumption(Object obj, JsonReader reader) {\ntry {\nif (obj != null && reader.peek() != JsonToken.END_DOCUMENT) {\nthrow new JsonIOException(\"JSON document was not fully consumed.\");\n}\n} catch (MalformedJsonException e) {\nthrow new JsonSyntaxException(e);\n} catch (IOException e) {\nthrow new JsonIOException(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson:fromJson(Lcom/google/gson/stream/JsonReader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
                                    "method_body": "public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nboolean isEmpty = true;\nboolean oldLenient = reader.isLenient();\nreader.setLenient(true);\ntry {\nreader.peek();\nisEmpty = false;\nTypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\nTypeAdapter<T> typeAdapter = getAdapter(typeToken);\nT object = typeAdapter.read(reader);\nreturn object;\n} catch (EOFException e) {\n/*\n* For compatibility with JSON 1.5 and earlier, we return null for empty\n* documents instead of throwing.\n*/\nif (isEmpty) {\nreturn null;\n}\nthrow new JsonSyntaxException(e);\n} catch (IllegalStateException e) {\nthrow new JsonSyntaxException(e);\n} catch (IOException e) {\n// TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException\nthrow new JsonSyntaxException(e);\n} finally {\nreader.setLenient(oldLenient);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
                                    "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
                                    "method_body": "public final Type getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
                                    "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/Class;)Lcom/google/gson/reflect/TypeToken;",
                                    "method_body": "public static <T> TypeToken<T> get(Class<T> type) {\nreturn new TypeToken<T>(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nthrow new NullPointerException();\n}\nreturn obj;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
                                    "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\nthrow new IllegalArgumentException();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
                                    "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\np.getRawType(), p.getActualTypeArguments());\n\n} else if (type instanceof GenericArrayType) {\nGenericArrayType g = (GenericArrayType) type;\nreturn new GenericArrayTypeImpl(g.getGenericComponentType());\n\n} else if (type instanceof WildcardType) {\nWildcardType w = (WildcardType) type;\nreturn new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n} else {\n// type is either serializable as-is or unsupported\nreturn type;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
                                    "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\n// type is a normal class.\nreturn (Class<?>) type;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType parameterizedType = (ParameterizedType) type;\n\n// I'm not exactly sure why getRawType() returns Type instead of Class.\n// Neal isn't either but suspects some pathological case related\n// to nested classes exists.\nType rawType = parameterizedType.getRawType();\ncheckArgument(rawType instanceof Class);\nreturn (Class<?>) rawType;\n\n} else if (type instanceof GenericArrayType) {\nType componentType = ((GenericArrayType)type).getGenericComponentType();\nreturn Array.newInstance(getRawType(componentType), 0).getClass();\n\n} else if (type instanceof TypeVariable) {\n// we could use the variable's bounds, but that won't work if there are multiple.\n// having a raw type that's more general than necessary is okay\nreturn Object.class;\n\n} else if (type instanceof WildcardType) {\nreturn getRawType(((WildcardType) type).getUpperBounds()[0]);\n\n} else {\nString className = type == null ? \"null\" : type.getClass().getName();\nthrow new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n+ \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:hashCodeOrZero(Ljava/lang/Object;)I",
                                    "method_body": "static int hashCodeOrZero(Object o) {\nreturn o != null ? o.hashCode() : 0;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getGenericSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\nif (toResolve == rawType) {\nreturn context;\n}\n\n// we skip searching through interfaces if unknown is an interface\nif (toResolve.isInterface()) {\nClass<?>[] interfaces = rawType.getInterfaces();\nfor (int i = 0, length = interfaces.length; i < length; i++) {\nif (interfaces[i] == toResolve) {\nreturn rawType.getGenericInterfaces()[i];\n} else if (toResolve.isAssignableFrom(interfaces[i])) {\nreturn getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n}\n}\n}\n\n// check our supertypes\nif (!rawType.isInterface()) {\nwhile (rawType != Object.class) {\nClass<?> rawSupertype = rawType.getSuperclass();\nif (rawSupertype == toResolve) {\nreturn rawType.getGenericSuperclass();\n} else if (toResolve.isAssignableFrom(rawSupertype)) {\nreturn getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);\n}\nrawType = rawSupertype;\n}\n}\n\n// we can't resolve this further\nreturn toResolve;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\n// wildcards are useless for resolving supertypes. As the upper bound has the same raw type, use it instead\ncheckArgument(supertype.isAssignableFrom(contextRawType));\nreturn resolve(context, contextRawType,\n$Gson$Types.getGenericSupertype(context, contextRawType, supertype));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getCollectionElementType(Ljava/lang/reflect/Type;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type getCollectionElementType(Type context, Class<?> contextRawType) {\nType collectionType = getSupertype(context, contextRawType, Collection.class);\n\nif (collectionType instanceof WildcardType) {\ncollectionType = ((WildcardType)collectionType).getUpperBounds()[0];\n}\nif (collectionType instanceof ParameterizedType) {\nreturn ((ParameterizedType) collectionType).getActualTypeArguments()[0];\n}\nreturn Object.class;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:getMapKeyAndValueTypes(Ljava/lang/reflect/Type;Ljava/lang/Class;)[Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {\n/*\n* Work around a problem with the declaration of java.util.Properties. That\n* class should extend Hashtable<String, String>, but it's declared to\n* extend Hashtable<Object, Object>.\n*/\nif (context == Properties.class) {\nreturn new Type[] { String.class, String.class }; // TODO: test subclasses of Properties!\n}\n\nType mapType = getSupertype(context, contextRawType, Map.class);\n// TODO: strip wildcards?\nif (mapType instanceof ParameterizedType) {\nParameterizedType mapParameterizedType = (ParameterizedType) mapType;\nreturn mapParameterizedType.getActualTypeArguments();\n}\nreturn new Type[] { Object.class, Object.class };\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
                                    "method_body": "public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\nreturn resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;Ljava/util/Collection;)Ljava/lang/reflect/Type;",
                                    "method_body": "private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,\nCollection<TypeVariable> visitedTypeVariables) {\n// this implementation is made a little more complicated in an attempt to avoid object-creation\nwhile (true) {\nif (toResolve instanceof TypeVariable) {\nTypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\nif (visitedTypeVariables.contains(typeVariable)) {\n// cannot reduce due to infinite recursion\nreturn toResolve;\n} else {\nvisitedTypeVariables.add(typeVariable);\n}\ntoResolve = resolveTypeVariable(context, contextRawType, typeVariable);\nif (toResolve == typeVariable) {\nreturn toResolve;\n}\n\n} else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\nClass<?> original = (Class<?>) toResolve;\nType componentType = original.getComponentType();\nType newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\nreturn componentType == newComponentType\n? original\n: arrayOf(newComponentType);\n\n} else if (toResolve instanceof GenericArrayType) {\nGenericArrayType original = (GenericArrayType) toResolve;\nType componentType = original.getGenericComponentType();\nType newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\nreturn componentType == newComponentType\n? original\n: arrayOf(newComponentType);\n\n} else if (toResolve instanceof ParameterizedType) {\nParameterizedType original = (ParameterizedType) toResolve;\nType ownerType = original.getOwnerType();\nType newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\nboolean changed = newOwnerType != ownerType;\n\nType[] args = original.getActualTypeArguments();\nfor (int t = 0, length = args.length; t < length; t++) {\nType resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\nif (resolvedTypeArgument != args[t]) {\nif (!changed) {\nargs = args.clone();\nchanged = true;\n}\nargs[t] = resolvedTypeArgument;\n}\n}\n\nreturn changed\n? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n: original;\n\n} else if (toResolve instanceof WildcardType) {\nWildcardType original = (WildcardType) toResolve;\nType[] originalLowerBound = original.getLowerBounds();\nType[] originalUpperBound = original.getUpperBounds();\n\nif (originalLowerBound.length == 1) {\nType lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\nif (lowerBound != originalLowerBound[0]) {\nreturn supertypeOf(lowerBound);\n}\n} else if (originalUpperBound.length == 1) {\nType upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\nif (upperBound != originalUpperBound[0]) {\nreturn subtypeOf(upperBound);\n}\n}\nreturn original;\n\n} else {\nreturn toResolve;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:resolveTypeVariable(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/TypeVariable;)Ljava/lang/reflect/Type;",
                                    "method_body": "static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\nClass<?> declaredByRaw = declaringClassOf(unknown);\n\n// we can't reduce this further\nif (declaredByRaw == null) {\nreturn unknown;\n}\n\nType declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\nif (declaredBy instanceof ParameterizedType) {\nint index = indexOf(declaredByRaw.getTypeParameters(), unknown);\nreturn ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\n}\n\nreturn unknown;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:declaringClassOf(Ljava/lang/reflect/TypeVariable;)Ljava/lang/Class;",
                                    "method_body": "private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\nGenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\nreturn genericDeclaration instanceof Class\n? (Class<?>) genericDeclaration\n: null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
                                    "method_body": "static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
                                    "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\n\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate boolean requireExpose;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n\n@Override protected Excluder clone() {\ntry {\nreturn (Excluder) super.clone();\n} catch (CloneNotSupportedException e) {\nthrow new AssertionError(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\n\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}\n\nreturn new TypeAdapter<T>() {\n/** The delegate is lazily created because it may not be needed, and creating it may fail. */\nprivate TypeAdapter<T> delegate;\n\n@Override public T read(JsonReader in) throws IOException {\nif (skipDeserialize) {\nin.skipValue();\nreturn null;\n}\nreturn delegate().read(in);\n}\n\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (skipSerialize) {\nout.nullValue();\nreturn;\n}\ndelegate().write(out, value);\n}\n\nprivate TypeAdapter<T> delegate() {\nTypeAdapter<T> d = delegate;\nreturn d != null\n? d\n: (delegate = gson.getDelegateAdapter(Excluder.this, type));\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field field, boolean serialize) {\nif ((modifiers & field.getModifiers()) != 0) {\nreturn true;\n}\n\nif (version != Excluder.IGNORE_VERSIONS\n&& !isValidVersion(field.getAnnotation(Since.class), field.getAnnotation(Until.class))) {\nreturn true;\n}\n\nif (field.isSynthetic()) {\nreturn true;\n}\n\nif (requireExpose) {\nExpose annotation = field.getAnnotation(Expose.class);\nif (annotation == null || (serialize ? !annotation.serialize() : !annotation.deserialize())) {\nreturn true;\n}\n}\n\nif (!serializeInnerClasses && isInnerClass(field.getType())) {\nreturn true;\n}\n\nif (isAnonymousOrLocal(field.getType())) {\nreturn true;\n}\n\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nif (!list.isEmpty()) {\nFieldAttributes fieldAttributes = new FieldAttributes(field);\nfor (ExclusionStrategy exclusionStrategy : list) {\nif (exclusionStrategy.shouldSkipField(fieldAttributes)) {\nreturn true;\n}\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
                                    "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\n&& !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\nreturn true;\n}\n\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nreturn true;\n}\n\nif (isAnonymousOrLocal(clazz)) {\nreturn true;\n}\n\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nif (exclusionStrategy.shouldSkipClass(clazz)) {\nreturn true;\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
                                    "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n&& (clazz.isAnonymousClass() || clazz.isLocalClass());\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.FieldNamingPolicy$1:translateName(Ljava/lang/reflect/Field;)Ljava/lang/String;",
                                    "method_body": "@Override public String translateName(Field f) {\nreturn f.getName();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
                                    "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\n\n// first try an instance creator\n\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn typeCreator.createInstance(type);\n}\n};\n}\n\n// Next try raw type match for instance creators\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> rawTypeCreator =\n(InstanceCreator<T>) instanceCreators.get(rawType);\nif (rawTypeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn rawTypeCreator.createInstance(type);\n}\n};\n}\n\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nreturn defaultConstructor;\n}\n\nObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\nif (defaultImplementation != null) {\nreturn defaultImplementation;\n}\n\n// finally try unsafe\nreturn newUnsafeAllocator(type, rawType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultConstructor(Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\ntry {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\n}\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"unchecked\") // T is the same raw type as is requested\n@Override public T construct() {\ntry {\nObject[] args = null;\nreturn (T) constructor.newInstance(args);\n} catch (InstantiationException e) {\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\", e);\n} catch (InvocationTargetException e) {\n// TODO: don't wrap if cause is unchecked!\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",\ne.getTargetException());\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\n}\n};\n} catch (NoSuchMethodException e) {\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultImplementationConstructor(Ljava/lang/reflect/Type;Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nfinal Type type, Class<? super T> rawType) {\nif (Collection.class.isAssignableFrom(rawType)) {\nif (SortedSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeSet<Object>();\n}\n};\n} else if (EnumSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"rawtypes\")\n@Override public T construct() {\nif (type instanceof ParameterizedType) {\nType elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\nif (elementType instanceof Class) {\nreturn (T) EnumSet.noneOf((Class)elementType);\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n}\n};\n} else if (Set.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashSet<Object>();\n}\n};\n} else if (Queue.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ArrayDeque<Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ArrayList<Object>();\n}\n};\n}\n}\n\nif (Map.class.isAssignableFrom(rawType)) {\nif (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ConcurrentSkipListMap<Object, Object>();\n}\n};\n} else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ConcurrentHashMap<Object, Object>();\n}\n};\n} else if (SortedMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeMap<Object, Object>();\n}\n};\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nTypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashMap<Object, Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedTreeMap<String, Object>();\n}\n};\n}\n}\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor:newUnsafeAllocator(Ljava/lang/reflect/Type;Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
                                    "method_body": "private <T> ObjectConstructor<T> newUnsafeAllocator(\nfinal Type type, final Class<? super T> rawType) {\nreturn new ObjectConstructor<T>() {\nprivate final UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();\n@SuppressWarnings(\"unchecked\")\n@Override public T construct() {\ntry {\nObject newInstance = unsafeAllocator.newInstance(rawType);\nreturn (T) newInstance;\n} catch (Exception e) {\nthrow new RuntimeException((\"Unable to invoke no-args constructor for \" + type + \". \"\n+ \"Registering an InstanceCreator with Gson for this type may fix this problem.\"), e);\n}\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
                                    "method_body": "public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n@Override\npublic void write(JsonWriter out, Class value) throws IOException {\nthrow new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n+ value.getName() + \". Forgot to register a type adapter?\");\n}\n@Override\npublic Class read(JsonReader in) throws IOException {\nthrow new UnsupportedOperationException(\n\"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n}\n}.nullSafe();"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.TypeAdapter:nullSafe()Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public final TypeAdapter<T> nullSafe() {\nreturn new TypeAdapter<T>() {\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (value == null) {\nout.nullValue();\n} else {\nTypeAdapter.this.write(out, value);\n}\n}\n@Override public T read(JsonReader reader) throws IOException {\nif (reader.peek() == JsonToken.NULL) {\nreader.nextNull();\nreturn null;\n}\nreturn TypeAdapter.this.read(reader);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$17:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/String;",
                                    "method_body": "public String read(JsonReader in) throws IOException {\nJsonToken peek = in.peek();\nif (peek == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\n/* coerce booleans to strings for backwards compatibility */\nif (peek == JsonToken.BOOLEAN) {\nreturn Boolean.toString(in.nextBoolean());\n}\nreturn in.nextString();\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$35:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$26:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}\n\nfinal TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\nreturn (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n@Override public Timestamp read(JsonReader in) throws IOException {\nDate date = dateTypeAdapter.read(in);\nreturn date != null ? new Timestamp(date.getTime()) : null;\n}\n\n@Override public void write(JsonWriter out, Timestamp value) throws IOException {\ndateTypeAdapter.write(out, value);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$34:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapters$30:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nif (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {\nreturn null;\n}\nif (!rawType.isEnum()) {\nrawType = rawType.getSuperclass(); // handle anonymous subclasses\n}\nreturn (TypeAdapter<T>) new EnumTypeAdapter(rawType);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<init>(Lcom/google/gson/Gson;)V",
                                    "method_body": "ObjectTypeAdapter(Gson gson) {\nthis.gson = gson;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Object;",
                                    "method_body": "@Override public Object read(JsonReader in) throws IOException {\nJsonToken token = in.peek();\nswitch (token) {\ncase BEGIN_ARRAY:\nList<Object> list = new ArrayList<Object>();\nin.beginArray();\nwhile (in.hasNext()) {\nlist.add(read(in));\n}\nin.endArray();\nreturn list;\n\ncase BEGIN_OBJECT:\nMap<String, Object> map = new LinkedTreeMap<String, Object>();\nin.beginObject();\nwhile (in.hasNext()) {\nmap.put(in.nextName(), read(in));\n}\nin.endObject();\nreturn map;\n\ncase STRING:\nreturn in.nextString();\n\ncase NUMBER:\nreturn in.nextDouble();\n\ncase BOOLEAN:\nreturn in.nextBoolean();\n\ncase NULL:\nin.nextNull();\nreturn null;\n\ndefault:\nthrow new IllegalStateException();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
                                    "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}\n};"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nType elementType = $Gson$Types.getCollectionElementType(type, rawType);\nTypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // create() doesn't define a type parameter\nTypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
                                    "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nClass<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\nType[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\nTypeAdapter<?> keyAdapter = getKeyAdapter(gson, keyAndValueTypes[0]);\nTypeAdapter<?> valueAdapter = gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n// we don't define a type parameter for the key or value types\nTypeAdapter<T> result = new Adapter(gson, keyAndValueTypes[0], keyAdapter,\nkeyAndValueTypes[1], valueAdapter, constructor);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:getKeyAdapter(Lcom/google/gson/Gson;Ljava/lang/reflect/Type;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "private TypeAdapter<?> getKeyAdapter(Gson context, Type keyType) {\nreturn (keyType == boolean.class || keyType == Boolean.class)\n? TypeAdapters.BOOLEAN_AS_STRING\n: context.getAdapter(TypeToken.get(keyType));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
                                    "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\nClass<? super T> rawType = targetType.getRawType();\nJsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);\nif (annotation == null) {\nreturn null;\n}\nreturn (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;Lcom/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory;)V",
                                    "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nFieldNamingStrategy fieldNamingPolicy, Excluder excluder,\nJsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\nthis.jsonAdapterFactory = jsonAdapterFactory;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;Z)Z",
                                    "method_body": "public boolean excludeField(Field f, boolean serialize) {\nreturn excludeField(f, serialize, excluder);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;ZLcom/google/gson/internal/Excluder;)Z",
                                    "method_body": "static boolean excludeField(Field f, boolean serialize, Excluder excluder) {\nreturn !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getFieldNames(Ljava/lang/reflect/Field;)Ljava/util/List;",
                                    "method_body": "private List<String> getFieldNames(Field f) {\nSerializedName annotation = f.getAnnotation(SerializedName.class);\nif (annotation == null) {\nString name = fieldNamingPolicy.translateName(f);\nreturn Collections.singletonList(name);\n}\n\nString serializedName = annotation.value();\nString[] alternates = annotation.alternate();\nif (alternates.length == 0) {\nreturn Collections.singletonList(serializedName);\n}\n\nList<String> fieldNames = new ArrayList<String>(alternates.length + 1);\nfieldNames.add(serializedName);\nfor (String alternate : alternates) {\nfieldNames.add(alternate);\n}\nreturn fieldNames;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
                                    "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\nClass<? super T> raw = type.getRawType();\n\nif (!Object.class.isAssignableFrom(raw)) {\nreturn null; // it's a primitive!\n}\n\nObjectConstructor<T> constructor = constructorConstructor.get(type);\nreturn new Adapter<T>(constructor, getBoundFields(gson, type, raw));\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:createBoundField(Lcom/google/gson/Gson;Ljava/lang/reflect/Field;Ljava/lang/String;Lcom/google/gson/reflect/TypeToken;ZZ)Lcom/google/gson/internal/bind/ReflectiveTypeAdapterFactory$BoundField;",
                                    "method_body": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(\nfinal Gson context, final Field field, final String name,\nfinal TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\nfinal boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n// special casing primitives here saves ~5% on Android...\nJsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\nTypeAdapter<?> mapped = null;\nif (annotation != null) {\nmapped = jsonAdapterFactory.getTypeAdapter(\nconstructorConstructor, context, fieldType, annotation);\n}\nfinal boolean jsonAdapterPresent = mapped != null;\nif (mapped == null) mapped = context.getAdapter(fieldType);\n\nfinal TypeAdapter<?> typeAdapter = mapped;\nreturn new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n@Override void write(JsonWriter writer, Object value)\nthrows IOException, IllegalAccessException {\nObject fieldValue = field.get(value);\nTypeAdapter t = jsonAdapterPresent ? typeAdapter\n: new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\nt.write(writer, fieldValue);\n}\n@Override void read(JsonReader reader, Object value)\nthrows IOException, IllegalAccessException {\nObject fieldValue = typeAdapter.read(reader);\nif (fieldValue != null || !isPrimitive) {\nfield.set(value, fieldValue);\n}\n}\n@Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\nif (!serialized) return false;\nObject fieldValue = field.get(value);\nreturn fieldValue != value; // avoid recursion for example for Throwable.cause\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getBoundFields(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;Ljava/lang/Class;)Ljava/util/Map;",
                                    "method_body": "private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {\nMap<String, BoundField> result = new LinkedHashMap<String, BoundField>();\nif (raw.isInterface()) {\nreturn result;\n}\n\nType declaredType = type.getType();\nwhile (raw != Object.class) {\nField[] fields = raw.getDeclaredFields();\nfor (Field field : fields) {\nboolean serialize = excludeField(field, true);\nboolean deserialize = excludeField(field, false);\nif (!serialize && !deserialize) {\ncontinue;\n}\nfield.setAccessible(true);\nType fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\nList<String> fieldNames = getFieldNames(field);\nBoundField previous = null;\nfor (int i = 0, size = fieldNames.size(); i < size; ++i) {\nString name = fieldNames.get(i);\nif (i != 0) serialize = false; // only serialize the default name\nBoundField boundField = createBoundField(context, field, name,\nTypeToken.get(fieldType), serialize, deserialize);\nBoundField replaced = result.put(name, boundField);\nif (previous == null) previous = replaced;\n}\nif (previous != null) {\nthrow new IllegalArgumentException(declaredType\n+ \" declares multiple JSON fields named \" + previous.name);\n}\n}\ntype = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\nraw = type.getRawType();\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
                                    "method_body": "public JsonReader(Reader in) {\nif (in == null) {\nthrow new NullPointerException(\"in == null\");\n}\nthis.in = in;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:<clinit>()V",
                                    "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;\n\nprivate static final int PEEKED_NONE = 0;\nprivate static final int PEEKED_BEGIN_OBJECT = 1;\nprivate static final int PEEKED_END_OBJECT = 2;\nprivate static final int PEEKED_BEGIN_ARRAY = 3;\nprivate static final int PEEKED_END_ARRAY = 4;\nprivate static final int PEEKED_TRUE = 5;\nprivate static final int PEEKED_FALSE = 6;\nprivate static final int PEEKED_NULL = 7;\nprivate static final int PEEKED_SINGLE_QUOTED = 8;\nprivate static final int PEEKED_DOUBLE_QUOTED = 9;\nprivate static final int PEEKED_UNQUOTED = 10;\n/** When this is returned, the string value is stored in peekedString. */\nprivate static final int PEEKED_BUFFERED = 11;\nprivate static final int PEEKED_SINGLE_QUOTED_NAME = 12;\nprivate static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\nprivate static final int PEEKED_UNQUOTED_NAME = 14;\n/** When this is returned, the integer value is stored in peekedLong. */\nprivate static final int PEEKED_LONG = 15;\nprivate static final int PEEKED_NUMBER = 16;\nprivate static final int PEEKED_EOF = 17;\n\n/* State machine when parsing numbers */\nprivate static final int NUMBER_CHAR_NONE = 0;\nprivate static final int NUMBER_CHAR_SIGN = 1;\nprivate static final int NUMBER_CHAR_DIGIT = 2;\nprivate static final int NUMBER_CHAR_DECIMAL = 3;\nprivate static final int NUMBER_CHAR_FRACTION_DIGIT = 4;\nprivate static final int NUMBER_CHAR_EXP_E = 5;\nprivate static final int NUMBER_CHAR_EXP_SIGN = 6;\nprivate static final int NUMBER_CHAR_EXP_DIGIT = 7;\n\n/** The input JSON. */\nprivate final Reader in;\n\n/** True to accept non-spec compliant JSON */\nprivate boolean lenient = false;\n\n/**\n* Use a manual buffer to easily read and unread upcoming characters, and\n* also so we can create strings without an intermediate StringBuilder.\n* We decode literals directly out of this buffer, so it must be at least as\n* long as the longest token that can be reported as a number.\n*/\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\n\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\n\nint peeked = PEEKED_NONE;\n\n/**\n* A peeked value that was composed entirely of digits with an optional\n* leading dash. Positive values may not have a leading 0.\n*/\nprivate long peekedLong;\n\n/**\n* The number of characters in a peeked number literal. Increment 'pos' by\n* this after reading a number.\n*/\nprivate int peekedNumberLength;\n\n/**\n* A peeked string that should be parsed on the next double, long or string.\n* This is populated before a numeric value is parsed and used if that parsing\n* fails.\n*/\nprivate String peekedString;\n\n/*\n* The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n*/\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\n{\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:setLenient(Z)V",
                                    "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:isLenient()Z",
                                    "method_body": "public final boolean isLenient() {\nreturn lenient;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:beginArray()V",
                                    "method_body": "public void beginArray() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nif (p == PEEKED_BEGIN_ARRAY) {\npush(JsonScope.EMPTY_ARRAY);\npathIndices[stackSize - 1] = 0;\npeeked = PEEKED_NONE;\n} else {\nthrow new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek() + locationString());\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:endArray()V",
                                    "method_body": "public void endArray() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nif (p == PEEKED_END_ARRAY) {\nstackSize--;\npathIndices[stackSize - 1]++;\npeeked = PEEKED_NONE;\n} else {\nthrow new IllegalStateException(\"Expected END_ARRAY but was \" + peek() + locationString());\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:beginObject()V",
                                    "method_body": "public void beginObject() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nif (p == PEEKED_BEGIN_OBJECT) {\npush(JsonScope.EMPTY_OBJECT);\npeeked = PEEKED_NONE;\n} else {\nthrow new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek() + locationString());\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:endObject()V",
                                    "method_body": "public void endObject() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nif (p == PEEKED_END_OBJECT) {\nstackSize--;\npathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!\npathIndices[stackSize - 1]++;\npeeked = PEEKED_NONE;\n} else {\nthrow new IllegalStateException(\"Expected END_OBJECT but was \" + peek() + locationString());\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:hasNext()Z",
                                    "method_body": "public boolean hasNext() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nreturn p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
                                    "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\n\nswitch (p) {\ncase PEEKED_BEGIN_OBJECT:\nreturn JsonToken.BEGIN_OBJECT;\ncase PEEKED_END_OBJECT:\nreturn JsonToken.END_OBJECT;\ncase PEEKED_BEGIN_ARRAY:\nreturn JsonToken.BEGIN_ARRAY;\ncase PEEKED_END_ARRAY:\nreturn JsonToken.END_ARRAY;\ncase PEEKED_SINGLE_QUOTED_NAME:\ncase PEEKED_DOUBLE_QUOTED_NAME:\ncase PEEKED_UNQUOTED_NAME:\nreturn JsonToken.NAME;\ncase PEEKED_TRUE:\ncase PEEKED_FALSE:\nreturn JsonToken.BOOLEAN;\ncase PEEKED_NULL:\nreturn JsonToken.NULL;\ncase PEEKED_SINGLE_QUOTED:\ncase PEEKED_DOUBLE_QUOTED:\ncase PEEKED_UNQUOTED:\ncase PEEKED_BUFFERED:\nreturn JsonToken.STRING;\ncase PEEKED_LONG:\ncase PEEKED_NUMBER:\nreturn JsonToken.NUMBER;\ncase PEEKED_EOF:\nreturn JsonToken.END_DOCUMENT;\ndefault:\nthrow new AssertionError();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:doPeek()I",
                                    "method_body": "int doPeek() throws IOException {\nint peekStack = stack[stackSize - 1];\nif (peekStack == JsonScope.EMPTY_ARRAY) {\nstack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n} else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n// Look for a comma before the next element.\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase ']':\nreturn peeked = PEEKED_END_ARRAY;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated array\");\n}\n} else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\nstack[stackSize - 1] = JsonScope.DANGLING_NAME;\n// Look for a comma before the next element.\nif (peekStack == JsonScope.NONEMPTY_OBJECT) {\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '}':\nreturn peeked = PEEKED_END_OBJECT;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated object\");\n}\n}\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '\"':\nreturn peeked = PEEKED_DOUBLE_QUOTED_NAME;\ncase '\\'':\ncheckLenient();\nreturn peeked = PEEKED_SINGLE_QUOTED_NAME;\ncase '}':\nif (peekStack != JsonScope.NONEMPTY_OBJECT) {\nreturn peeked = PEEKED_END_OBJECT;\n} else {\nthrow syntaxError(\"Expected name\");\n}\ndefault:\ncheckLenient();\npos--; // Don't consume the first character in an unquoted string.\nif (isLiteral((char) c)) {\nreturn peeked = PEEKED_UNQUOTED_NAME;\n} else {\nthrow syntaxError(\"Expected name\");\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextName()Ljava/lang/String;",
                                    "method_body": "public String nextName() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nString result;\nif (p == PEEKED_UNQUOTED_NAME) {\nresult = nextUnquotedValue();\n} else if (p == PEEKED_SINGLE_QUOTED_NAME) {\nresult = nextQuotedValue('\\'');\n} else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\nresult = nextQuotedValue('\"');\n} else {\nthrow new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n}\npeeked = PEEKED_NONE;\npathNames[stackSize - 1] = result;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextString()Ljava/lang/String;",
                                    "method_body": "public String nextString() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nString result;\nif (p == PEEKED_UNQUOTED) {\nresult = nextUnquotedValue();\n} else if (p == PEEKED_SINGLE_QUOTED) {\nresult = nextQuotedValue('\\'');\n} else if (p == PEEKED_DOUBLE_QUOTED) {\nresult = nextQuotedValue('\"');\n} else if (p == PEEKED_BUFFERED) {\nresult = peekedString;\npeekedString = null;\n} else if (p == PEEKED_LONG) {\nresult = Long.toString(peekedLong);\n} else if (p == PEEKED_NUMBER) {\nresult = new String(buffer, pos, peekedNumberLength);\npos += peekedNumberLength;\n} else {\nthrow new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n}\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextQuotedValue(C)Ljava/lang/String;",
                                    "method_body": "private String nextQuotedValue(char quote) throws IOException {\n// Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\nchar[] buffer = this.buffer;\nStringBuilder builder = null;\nwhile (true) {\nint p = pos;\nint l = limit;\n/* the index of the first character not yet appended to the builder. */\nint start = p;\nwhile (p < l) {\nint c = buffer[p++];\n\nif (c == quote) {\npos = p;\nint len = p - start - 1;\nif (builder == null) {\nreturn new String(buffer, start, len);\n} else {\nbuilder.append(buffer, start, len);\nreturn builder.toString();\n}\n} else if (c == '\\\\') {\npos = p;\nint len = p - start - 1;\nif (builder == null) {\nint estimatedLength = (len + 1) * 2;\nbuilder = new StringBuilder(Math.max(estimatedLength, 16));\n}\nbuilder.append(buffer, start, len);\nbuilder.append(readEscapeCharacter());\np = pos;\nl = limit;\nstart = p;\n} else if (c == '\\n') {\nlineNumber++;\nlineStart = p;\n}\n}\n\nif (builder == null) {\nint estimatedLength = (p - start) * 2;\nbuilder = new StringBuilder(Math.max(estimatedLength, 16));\n}\nbuilder.append(buffer, start, p - start);\npos = p;\nif (!fillBuffer(1)) {\nthrow syntaxError(\"Unterminated string\");\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:push(I)V",
                                    "method_body": "private void push(int newTop) {\nif (stackSize == stack.length) {\nint[] newStack = new int[stackSize * 2];\nint[] newPathIndices = new int[stackSize * 2];\nString[] newPathNames = new String[stackSize * 2];\nSystem.arraycopy(stack, 0, newStack, 0, stackSize);\nSystem.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\nSystem.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\nstack = newStack;\npathIndices = newPathIndices;\npathNames = newPathNames;\n}\nstack[stackSize++] = newTop;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
                                    "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit -= pos;\nSystem.arraycopy(buffer, pos, buffer, 0, limit);\n} else {\nlimit = 0;\n}\n\npos = 0;\nint total;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\n\n// if this is the first read, consume an optional byte order mark (BOM) if it exists\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\npos++;\nlineStart++;\nminimum++;\n}\n\nif (limit >= minimum) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
                                    "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n/*\n* This code uses ugly local variables 'p' and 'l' representing the 'pos'\n* and 'limit' fields respectively. Using locals rather than fields saves\n* a few field reads for each whitespace character in a pretty-printed\n* document, resulting in a 5% speedup. We need to flush 'p' to its field\n* before any (potentially indirect) call to fillBuffer() and reread both\n* 'p' and 'l' after any (potentially indirect) call to the same method.\n*/\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nwhile (true) {\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\nbreak;\n}\np = pos;\nl = limit;\n}\n\nint c = buffer[p++];\nif (c == '\\n') {\nlineNumber++;\nlineStart = p;\ncontinue;\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\ncontinue;\n}\n\nif (c == '/') {\npos = p;\nif (p == l) {\npos--; // push back '/' so it's still in the buffer when this method returns\nboolean charsLoaded = fillBuffer(2);\npos++; // consume the '/' again\nif (!charsLoaded) {\nreturn c;\n}\n}\n\ncheckLenient();\nchar peek = buffer[pos];\nswitch (peek) {\ncase '*':\n// skip a /* c-style comment */\npos++;\nif (!skipTo(\"*/\")) {\nthrow syntaxError(\"Unterminated comment\");\n}\np = pos + 2;\nl = limit;\ncontinue;\n\ncase '/':\n// skip a // end-of-line comment\npos++;\nskipToEndOfLine();\np = pos;\nl = limit;\ncontinue;\n\ndefault:\nreturn c;\n}\n} else if (c == '#') {\npos = p;\n/*\n* Skip a # hash end-of-line comment. The JSON RFC doesn't\n* specify this behaviour, but it's required to parse\n* existing documents. See http://b/2571423.\n*/\ncheckLenient();\nskipToEndOfLine();\np = pos;\nl = limit;\n} else {\npos = p;\nreturn c;\n}\n}\nif (throwOnEof) {\nthrow new EOFException(\"End of input\" + locationString());\n} else {\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader:consumeNonExecutePrefix()V",
                                    "method_body": "private void consumeNonExecutePrefix() throws IOException {\n// fast forward through the leading whitespace\nnextNonWhitespace(true);\npos--;\n\nif (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\nreturn;\n}\n\nfor (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\nif (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\nreturn; // not a security token!\n}\n}\n\n// we consumed a security token!\npos += NON_EXECUTE_PREFIX.length;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.stream.JsonReader$1:promoteNameToValue(Lcom/google/gson/stream/JsonReader;)V",
                                    "method_body": "@Override public void promoteNameToValue(JsonReader reader) throws IOException {\nif (reader instanceof JsonTreeReader) {\n((JsonTreeReader)reader).promoteNameToValue();\nreturn;\n}\nint p = reader.peeked;\nif (p == PEEKED_NONE) {\np = reader.doPeek();\n}\nif (p == PEEKED_DOUBLE_QUOTED_NAME) {\nreader.peeked = PEEKED_DOUBLE_QUOTED;\n} else if (p == PEEKED_SINGLE_QUOTED_NAME) {\nreader.peeked = PEEKED_SINGLE_QUOTED;\n} else if (p == PEEKED_UNQUOTED_NAME) {\nreader.peeked = PEEKED_UNQUOTED;\n} else {\nthrow new IllegalStateException(\n\"Expected a name but was \" + reader.peek() + reader.locationString());\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$ParameterizedTypeImpl:<init>(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n// require an owner type if the raw type needs it\nif (rawType instanceof Class<?>) {\nClass<?> rawTypeAsClass = (Class<?>) rawType;\nboolean isStaticOrTopLevelClass = Modifier.isStatic(rawTypeAsClass.getModifiers())\n|| rawTypeAsClass.getEnclosingClass() == null;\ncheckArgument(ownerType != null || isStaticOrTopLevelClass);\n}\n\nthis.ownerType = ownerType == null ? null : canonicalize(ownerType);\nthis.rawType = canonicalize(rawType);\nthis.typeArguments = typeArguments.clone();\nfor (int t = 0, length = this.typeArguments.length; t < length; t++) {\ncheckNotNull(this.typeArguments[t]);\ncheckNotPrimitive(this.typeArguments[t]);\nthis.typeArguments[t] = canonicalize(this.typeArguments[t]);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:<init>()V",
                                    "method_body": "public LinkedTreeMap() {\nthis((Comparator<? super K>) NATURAL_ORDER);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:<init>(Ljava/util/Comparator;)V",
                                    "method_body": "public LinkedTreeMap(Comparator<? super K> comparator) {\nthis.comparator = comparator != null\n? comparator\n: (Comparator) NATURAL_ORDER;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:get(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "@Override public V get(Object key) {\nNode<K, V> node = findByObject(key);\nreturn node != null ? node.value : null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:put(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "@Override public V put(K key, V value) {\nif (key == null) {\nthrow new NullPointerException(\"key == null\");\n}\nNode<K, V> created = find(key, true);\nV result = created.value;\ncreated.value = value;\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:find(Ljava/lang/Object;Z)Lcom/google/gson/internal/LinkedTreeMap$Node;",
                                    "method_body": "Node<K, V> find(K key, boolean create) {\nComparator<? super K> comparator = this.comparator;\nNode<K, V> nearest = root;\nint comparison = 0;\n\nif (nearest != null) {\n// Micro-optimization: avoid polymorphic calls to Comparator.compare().\n@SuppressWarnings(\"unchecked\") // Throws a ClassCastException below if there's trouble.\nComparable<Object> comparableKey = (comparator == NATURAL_ORDER)\n? (Comparable<Object>) key\n: null;\n\nwhile (true) {\ncomparison = (comparableKey != null)\n? comparableKey.compareTo(nearest.key)\n: comparator.compare(key, nearest.key);\n\n// We found the requested key.\nif (comparison == 0) {\nreturn nearest;\n}\n\n// If it exists, the key is in a subtree. Go deeper.\nNode<K, V> child = (comparison < 0) ? nearest.left : nearest.right;\nif (child == null) {\nbreak;\n}\n\nnearest = child;\n}\n}\n\n// The key doesn't exist in this tree.\nif (!create) {\nreturn null;\n}\n\n// Create the node and add it to the tree or the table.\nNode<K, V> header = this.header;\nNode<K, V> created;\nif (nearest == null) {\n// Check that the value is comparable if we didn't do any comparisons.\nif (comparator == NATURAL_ORDER && !(key instanceof Comparable)) {\nthrow new ClassCastException(key.getClass().getName() + \" is not Comparable\");\n}\ncreated = new Node<K, V>(nearest, key, header, header.prev);\nroot = created;\n} else {\ncreated = new Node<K, V>(nearest, key, header, header.prev);\nif (comparison < 0) { // nearest.key is higher\nnearest.left = created;\n} else { // comparison > 0, nearest.key is lower\nnearest.right = created;\n}\nrebalance(nearest, true);\n}\nsize++;\nmodCount++;\n\nreturn created;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap:findByObject(Ljava/lang/Object;)Lcom/google/gson/internal/LinkedTreeMap$Node;",
                                    "method_body": "Node<K, V> findByObject(Object key) {\ntry {\nreturn key != null ? find((K) key, false) : null;\n} catch (ClassCastException e) {\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap$Node:<init>()V",
                                    "method_body": "Node() {\nkey = null;\nnext = prev = this;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.LinkedTreeMap$Node:<init>(Lcom/google/gson/internal/LinkedTreeMap$Node;Ljava/lang/Object;Lcom/google/gson/internal/LinkedTreeMap$Node;Lcom/google/gson/internal/LinkedTreeMap$Node;)V",
                                    "method_body": "Node(Node<K, V> parent, K key, Node<K, V> next, Node<K, V> prev) {\nthis.parent = parent;\nthis.key = key;\nthis.height = 1;\nthis.next = next;\nthis.prev = prev;\nprev.next = this;\nnext.prev = this;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.Gson$FutureTypeAdapter:setDelegate(Lcom/google/gson/TypeAdapter;)V",
                                    "method_body": "public void setDelegate(TypeAdapter<T> typeAdapter) {\nif (delegate != null) {\nthrow new AssertionError();\n}\ndelegate = typeAdapter;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter:<init>(Lcom/google/gson/internal/ObjectConstructor;Ljava/util/Map;)V",
                                    "method_body": "abstract boolean writeField(Object value) throws IOException, IllegalAccessException;\nabstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException;\nabstract void read(JsonReader reader, Object value) throws IOException, IllegalAccessException;\n}\n\npublic static final class Adapter<T> extends TypeAdapter<T> {\nprivate final ObjectConstructor<T> constructor;\nprivate final Map<String, BoundField> boundFields;\n\nAdapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {\nthis.constructor = constructor;\nthis.boundFields = boundFields;\n}\n\n@Override public T read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\n\nT instance = constructor.construct();\n\ntry {\nin.beginObject();\nwhile (in.hasNext()) {\nString name = in.nextName();\nBoundField field = boundFields.get(name);\nif (field == null || !field.deserialized) {\nin.skipValue();\n} else {\nfield.read(in, instance);\n}\n}\n} catch (IllegalStateException e) {\nthrow new JsonSyntaxException(e);\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\nin.endObject();\nreturn instance;\n}\n\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\n\nout.beginObject();\ntry {\nfor (BoundField boundField : boundFields.values()) {\nif (boundField.writeField(value)) {\nout.name(boundField.name);\nboundField.write(out, value);\n}\n}\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\nout.endObject();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Object;",
                                    "method_body": "abstract boolean writeField(Object value) throws IOException, IllegalAccessException;\nabstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException;\nabstract void read(JsonReader reader, Object value) throws IOException, IllegalAccessException;\n}\n\npublic static final class Adapter<T> extends TypeAdapter<T> {\nprivate final ObjectConstructor<T> constructor;\nprivate final Map<String, BoundField> boundFields;\n\nAdapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {\nthis.constructor = constructor;\nthis.boundFields = boundFields;\n}\n\n@Override public T read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\n\nT instance = constructor.construct();\n\ntry {\nin.beginObject();\nwhile (in.hasNext()) {\nString name = in.nextName();\nBoundField field = boundFields.get(name);\nif (field == null || !field.deserialized) {\nin.skipValue();\n} else {\nfield.read(in, instance);\n}\n}\n} catch (IllegalStateException e) {\nthrow new JsonSyntaxException(e);\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\nin.endObject();\nreturn instance;\n}\n\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\n\nout.beginObject();\ntry {\nfor (BoundField boundField : boundFields.values()) {\nif (boundField.writeField(value)) {\nout.name(boundField.name);\nboundField.write(out, value);\n}\n}\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\nout.endObject();\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:<clinit>()V",
                                    "method_body": "private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;\n\n/** A map from wrapper types to their corresponding primitive types. */\nprivate static final Map<Class<?>, Class<?>> WRAPPER_TO_PRIMITIVE_TYPE;\n\n// Sad that we can't use a BiMap. :(\n\nstatic {\nMap<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);\nMap<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);\n\nadd(primToWrap, wrapToPrim, boolean.class, Boolean.class);\nadd(primToWrap, wrapToPrim, byte.class, Byte.class);\nadd(primToWrap, wrapToPrim, char.class, Character.class);\nadd(primToWrap, wrapToPrim, double.class, Double.class);\nadd(primToWrap, wrapToPrim, float.class, Float.class);\nadd(primToWrap, wrapToPrim, int.class, Integer.class);\nadd(primToWrap, wrapToPrim, long.class, Long.class);\nadd(primToWrap, wrapToPrim, short.class, Short.class);\nadd(primToWrap, wrapToPrim, void.class, Void.class);\n\nPRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);\nWRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:add(Ljava/util/Map;Ljava/util/Map;Ljava/lang/Class;Ljava/lang/Class;)V",
                                    "method_body": "private static void add(Map<Class<?>, Class<?>> forward,\nMap<Class<?>, Class<?>> backward, Class<?> key, Class<?> value) {\nforward.put(key, value);\nbackward.put(value, key);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:isPrimitive(Ljava/lang/reflect/Type;)Z",
                                    "method_body": "public static boolean isPrimitive(Type type) {\nreturn PRIMITIVE_TO_WRAPPER_TYPE.containsKey(type);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.Primitives:wrap(Ljava/lang/Class;)Ljava/lang/Class;",
                                    "method_body": "public static <T> Class<T> wrap(Class<T> type) {\n// cast is safe: long.class and Long.class are both of type Class<Long>\n@SuppressWarnings(\"unchecked\")\nClass<T> wrapped = (Class<T>) PRIMITIVE_TO_WRAPPER_TYPE.get(\n$Gson$Preconditions.checkNotNull(type));\nreturn (wrapped == null) ? type : wrapped;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$BoundField:<init>(Ljava/lang/String;ZZ)V",
                                    "method_body": "protected BoundField(String name, boolean serialized, boolean deserialized) {\nthis.name = name;\nthis.serialized = serialized;\nthis.deserialized = deserialized;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$1:read(Lcom/google/gson/stream/JsonReader;Ljava/lang/Object;)V",
                                    "method_body": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(\nfinal Gson context, final Field field, final String name,\nfinal TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\nfinal boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n// special casing primitives here saves ~5% on Android...\nJsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\nTypeAdapter<?> mapped = null;\nif (annotation != null) {\nmapped = jsonAdapterFactory.getTypeAdapter(\nconstructorConstructor, context, fieldType, annotation);\n}\nfinal boolean jsonAdapterPresent = mapped != null;\nif (mapped == null) mapped = context.getAdapter(fieldType);\n\nfinal TypeAdapter<?> typeAdapter = mapped;\nreturn new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n@Override void write(JsonWriter writer, Object value)\nthrows IOException, IllegalAccessException {\nObject fieldValue = field.get(value);\nTypeAdapter t = jsonAdapterPresent ? typeAdapter\n: new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\nt.write(writer, fieldValue);\n}\n@Override void read(JsonReader reader, Object value)\nthrows IOException, IllegalAccessException {\nObject fieldValue = typeAdapter.read(reader);\nif (fieldValue != null || !isPrimitive) {\nfield.set(value, fieldValue);\n}\n}\n@Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\nif (!serialized) return false;\nObject fieldValue = field.get(value);\nreturn fieldValue != value; // avoid recursion for example for Throwable.cause\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:<init>(Lcom/google/gson/Gson;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;)V",
                                    "method_body": "TypeAdapterRuntimeTypeWrapper(Gson context, TypeAdapter<T> delegate, Type type) {\nthis.context = context;\nthis.delegate = delegate;\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Object;",
                                    "method_body": "public T read(JsonReader in) throws IOException {\nreturn delegate.read(in);\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor$8:construct()Ljava/lang/Object;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nfinal Type type, Class<? super T> rawType) {\nif (Collection.class.isAssignableFrom(rawType)) {\nif (SortedSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeSet<Object>();\n}\n};\n} else if (EnumSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"rawtypes\")\n@Override public T construct() {\nif (type instanceof ParameterizedType) {\nType elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\nif (elementType instanceof Class) {\nreturn (T) EnumSet.noneOf((Class)elementType);\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n}\n};\n} else if (Set.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashSet<Object>();\n}\n};\n} else if (Queue.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ArrayDeque<Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ArrayList<Object>();\n}\n};\n}\n}\n\nif (Map.class.isAssignableFrom(rawType)) {\nif (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ConcurrentSkipListMap<Object, Object>();\n}\n};\n} else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ConcurrentHashMap<Object, Object>();\n}\n};\n} else if (SortedMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeMap<Object, Object>();\n}\n};\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nTypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashMap<Object, Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedTreeMap<String, Object>();\n}\n};\n}\n}\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory$Adapter:<init>(Lcom/google/gson/Gson;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Lcom/google/gson/internal/ObjectConstructor;)V",
                                    "method_body": "public Adapter(Gson context, Type elementType,\nTypeAdapter<E> elementTypeAdapter,\nObjectConstructor<? extends Collection<E>> constructor) {\nthis.elementTypeAdapter =\nnew TypeAdapterRuntimeTypeWrapper<E>(context, elementTypeAdapter, elementType);\nthis.constructor = constructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory$Adapter:read(Lcom/google/gson/stream/JsonReader;)Ljava/util/Collection;",
                                    "method_body": "@Override public Collection<E> read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\n\nCollection<E> collection = constructor.construct();\nin.beginArray();\nwhile (in.hasNext()) {\nE instance = elementTypeAdapter.read(in);\ncollection.add(instance);\n}\nin.endArray();\nreturn collection;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor$13:construct()Ljava/lang/Object;",
                                    "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nfinal Type type, Class<? super T> rawType) {\nif (Collection.class.isAssignableFrom(rawType)) {\nif (SortedSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeSet<Object>();\n}\n};\n} else if (EnumSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"rawtypes\")\n@Override public T construct() {\nif (type instanceof ParameterizedType) {\nType elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\nif (elementType instanceof Class) {\nreturn (T) EnumSet.noneOf((Class)elementType);\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n}\n};\n} else if (Set.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashSet<Object>();\n}\n};\n} else if (Queue.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ArrayDeque<Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ArrayList<Object>();\n}\n};\n}\n}\n\nif (Map.class.isAssignableFrom(rawType)) {\nif (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ConcurrentSkipListMap<Object, Object>();\n}\n};\n} else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ConcurrentHashMap<Object, Object>();\n}\n};\n} else if (SortedMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeMap<Object, Object>();\n}\n};\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nTypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashMap<Object, Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedTreeMap<String, Object>();\n}\n};\n}\n}\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter:<init>(Lcom/google/gson/internal/bind/MapTypeAdapterFactory;Lcom/google/gson/Gson;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Lcom/google/gson/internal/ObjectConstructor;)V",
                                    "method_body": "public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,\nType valueType, TypeAdapter<V> valueTypeAdapter,\nObjectConstructor<? extends Map<K, V>> constructor) {\nthis.keyTypeAdapter =\nnew TypeAdapterRuntimeTypeWrapper<K>(context, keyTypeAdapter, keyType);\nthis.valueTypeAdapter =\nnew TypeAdapterRuntimeTypeWrapper<V>(context, valueTypeAdapter, valueType);\nthis.constructor = constructor;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter:read(Lcom/google/gson/stream/JsonReader;)Ljava/util/Map;",
                                    "method_body": "@Override public Map<K, V> read(JsonReader in) throws IOException {\nJsonToken peek = in.peek();\nif (peek == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\n\nMap<K, V> map = constructor.construct();\n\nif (peek == JsonToken.BEGIN_ARRAY) {\nin.beginArray();\nwhile (in.hasNext()) {\nin.beginArray(); // entry array\nK key = keyTypeAdapter.read(in);\nV value = valueTypeAdapter.read(in);\nV replaced = map.put(key, value);\nif (replaced != null) {\nthrow new JsonSyntaxException(\"duplicate key: \" + key);\n}\nin.endArray();\n}\nin.endArray();\n} else {\nin.beginObject();\nwhile (in.hasNext()) {\nJsonReaderInternalAccess.INSTANCE.promoteNameToValue(in);\nK key = keyTypeAdapter.read(in);\nV value = valueTypeAdapter.read(in);\nV replaced = map.put(key, value);\nif (replaced != null) {\nthrow new JsonSyntaxException(\"duplicate key: \" + key);\n}\n}\nin.endObject();\n}\nreturn map;\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.$Gson$Types$WildcardTypeImpl:<init>([Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
                                    "method_body": "public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\ncheckArgument(lowerBounds.length <= 1);\ncheckArgument(upperBounds.length == 1);\n\nif (lowerBounds.length == 1) {\ncheckNotNull(lowerBounds[0]);\ncheckNotPrimitive(lowerBounds[0]);\ncheckArgument(upperBounds[0] == Object.class);\nthis.lowerBound = canonicalize(lowerBounds[0]);\nthis.upperBound = Object.class;\n\n} else {\ncheckNotNull(upperBounds[0]);\ncheckNotPrimitive(upperBounds[0]);\nthis.lowerBound = null;\nthis.upperBound = canonicalize(upperBounds[0]);\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.UnsafeAllocator:create()Lcom/google/gson/internal/UnsafeAllocator;",
                                    "method_body": "public abstract <T> T newInstance(Class<T> c) throws Exception;\n\npublic static UnsafeAllocator create() {\n// try JVM\n// public class Unsafe {\n//   public Object allocateInstance(Class<?> type);\n// }\ntry {\nClass<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\nField f = unsafeClass.getDeclaredField(\"theUnsafe\");\nf.setAccessible(true);\nfinal Object unsafe = f.get(null);\nfinal Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nassertInstantiable(c);\nreturn (T) allocateInstance.invoke(unsafe, c);\n}\n};\n} catch (Exception ignored) {\n}\n\n// try dalvikvm, post-gingerbread\n// public class ObjectStreamClass {\n//   private static native int getConstructorId(Class<?> c);\n//   private static native Object newInstance(Class<?> instantiationClass, int methodId);\n// }\ntry {\nMethod getConstructorId = ObjectStreamClass.class\n.getDeclaredMethod(\"getConstructorId\", Class.class);\ngetConstructorId.setAccessible(true);\nfinal int constructorId = (Integer) getConstructorId.invoke(null, Object.class);\nfinal Method newInstance = ObjectStreamClass.class\n.getDeclaredMethod(\"newInstance\", Class.class, int.class);\nnewInstance.setAccessible(true);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nassertInstantiable(c);\nreturn (T) newInstance.invoke(null, c, constructorId);\n}\n};\n} catch (Exception ignored) {\n}\n\n// try dalvikvm, pre-gingerbread\n// public class ObjectInputStream {\n//   private static native Object newInstance(\n//     Class<?> instantiationClass, Class<?> constructorClass);\n// }\ntry {\nfinal Method newInstance = ObjectInputStream.class\n.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\nnewInstance.setAccessible(true);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nassertInstantiable(c);\nreturn (T) newInstance.invoke(null, c, Object.class);\n}\n};\n} catch (Exception ignored) {\n}\n\n// give up\nreturn new UnsafeAllocator() {\n@Override\npublic <T> T newInstance(Class<T> c) {\nthrow new UnsupportedOperationException(\"Cannot allocate \" + c);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.UnsafeAllocator:assertInstantiable(Ljava/lang/Class;)V",
                                    "method_body": "static void assertInstantiable(Class<?> c) {\nint modifiers = c.getModifiers();\nif (Modifier.isInterface(modifiers)) {\nthrow new UnsupportedOperationException(\"Interface can't be instantiated! Interface name: \" + c.getName());\n}\nif (Modifier.isAbstract(modifiers)) {\nthrow new UnsupportedOperationException(\"Abstract class can't be instantiated! Class name: \" + c.getName());\n}\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.UnsafeAllocator$1:newInstance(Ljava/lang/Class;)Ljava/lang/Object;",
                                    "method_body": "public abstract <T> T newInstance(Class<T> c) throws Exception;\n\npublic static UnsafeAllocator create() {\n// try JVM\n// public class Unsafe {\n//   public Object allocateInstance(Class<?> type);\n// }\ntry {\nClass<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\nField f = unsafeClass.getDeclaredField(\"theUnsafe\");\nf.setAccessible(true);\nfinal Object unsafe = f.get(null);\nfinal Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nassertInstantiable(c);\nreturn (T) allocateInstance.invoke(unsafe, c);\n}\n};\n} catch (Exception ignored) {\n}\n\n// try dalvikvm, post-gingerbread\n// public class ObjectStreamClass {\n//   private static native int getConstructorId(Class<?> c);\n//   private static native Object newInstance(Class<?> instantiationClass, int methodId);\n// }\ntry {\nMethod getConstructorId = ObjectStreamClass.class\n.getDeclaredMethod(\"getConstructorId\", Class.class);\ngetConstructorId.setAccessible(true);\nfinal int constructorId = (Integer) getConstructorId.invoke(null, Object.class);\nfinal Method newInstance = ObjectStreamClass.class\n.getDeclaredMethod(\"newInstance\", Class.class, int.class);\nnewInstance.setAccessible(true);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nassertInstantiable(c);\nreturn (T) newInstance.invoke(null, c, constructorId);\n}\n};\n} catch (Exception ignored) {\n}\n\n// try dalvikvm, pre-gingerbread\n// public class ObjectInputStream {\n//   private static native Object newInstance(\n//     Class<?> instantiationClass, Class<?> constructorClass);\n// }\ntry {\nfinal Method newInstance = ObjectInputStream.class\n.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\nnewInstance.setAccessible(true);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nassertInstantiable(c);\nreturn (T) newInstance.invoke(null, c, Object.class);\n}\n};\n} catch (Exception ignored) {\n}\n\n// give up\nreturn new UnsafeAllocator() {\n@Override\npublic <T> T newInstance(Class<T> c) {\nthrow new UnsupportedOperationException(\"Cannot allocate \" + c);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.ConstructorConstructor$14:construct()Ljava/lang/Object;",
                                    "method_body": "private <T> ObjectConstructor<T> newUnsafeAllocator(\nfinal Type type, final Class<? super T> rawType) {\nreturn new ObjectConstructor<T>() {\nprivate final UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();\n@SuppressWarnings(\"unchecked\")\n@Override public T construct() {\ntry {\nObject newInstance = unsafeAllocator.newInstance(rawType);\nreturn (T) newInstance;\n} catch (Exception e) {\nthrow new RuntimeException((\"Unable to invoke no-args constructor for \" + type + \". \"\n+ \"Registering an InstanceCreator with Gson for this type may fix this problem.\"), e);\n}\n}\n};\n}"
                                },
                                {
                                    "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$2:<clinit>()V",
                                    "method_body": "@Override public Object read(JsonReader in) throws IOException {\nJsonToken token = in.peek();\nswitch (token) {\ncase BEGIN_ARRAY:\nList<Object> list = new ArrayList<Object>();\nin.beginArray();\nwhile (in.hasNext()) {\nlist.add(read(in));\n}\nin.endArray();\nreturn list;\n\ncase BEGIN_OBJECT:\nMap<String, Object> map = new LinkedTreeMap<String, Object>();\nin.beginObject();\nwhile (in.hasNext()) {\nmap.put(in.nextName(), read(in));\n}\nin.endObject();\nreturn map;\n\ncase STRING:\nreturn in.nextString();\n\ncase NUMBER:\nreturn in.nextDouble();\n\ncase BOOLEAN:\nreturn in.nextBoolean();\n\ncase NULL:\nin.nextNull();\nreturn null;\n\ndefault:\nthrow new IllegalStateException();\n}\n}"
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}