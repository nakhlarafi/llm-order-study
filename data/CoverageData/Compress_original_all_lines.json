{
    "projects": [
        {
            "name": "Compress",
            "bugs": [
                {
                    "bug_id": 1,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.CpioTestCase.testCpioUnarchive",
                            "test_body": "54: public void testCpioUnarchive() throws Exception {\n55: final File output = new File(dir, \"bla.cpio\");\n56: {\n57: final File file1 = getFile(\"test1.xml\");\n58: final File file2 = getFile(\"test2.xml\");\n59: 60: final OutputStream out = new FileOutputStream(output);\n61: final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\"cpio\", out);\n62: os.putArchiveEntry(new CpioArchiveEntry(\"test1.xml\", file1.length()));\n63: IOUtils.copy(new FileInputStream(file1), os);\n64: os.closeArchiveEntry();\n65: 66: os.putArchiveEntry(new CpioArchiveEntry(\"test2.xml\", file2.length()));\n67: IOUtils.copy(new FileInputStream(file2), os);\n68: os.closeArchiveEntry();\n69: 70: os.close();\n71: out.close();\n72: }\n73: 74: // Unarchive Operation\n75: final File input = output;\n76: final InputStream is = new FileInputStream(input);\n77: final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"cpio\", is);\n78: 79: 80: Map result = new HashMap();\n81: ArchiveEntry entry = null;\n82: while ((entry = in.getNextEntry()) != null) {\n83: File target = new File(dir, entry.getName());\n84: final OutputStream out = new FileOutputStream(target);\n85: IOUtils.copy(in, out);\n86: out.close();\n87: result.put(entry.getName(), target);\n88: }\n89: in.close();\n90: 91: int lineSepLength = System.getProperty(\"line.separator\").length();\n92: 93: File t = (File)result.get(\"test1.xml\");\n94: assertTrue(\"Expected \" + t.getAbsolutePath() + \" to exist\", t.exists());\n95: assertEquals(\"length of \" + t.getAbsolutePath(),\n96: 72 + 4 * lineSepLength, t.length());\n97: 98: t = (File)result.get(\"test2.xml\");\n99: assertTrue(\"Expected \" + t.getAbsolutePath() + \" to exist\", t.exists());\n100: assertEquals(\"length of \" + t.getAbsolutePath(),\n101: 73 + 5 * lineSepLength, t.length());\n102: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveInputStream(Ljava/lang/String;Ljava/io/InputStream;)Lorg/apache/commons/compress/archivers/ArchiveInputStream;",
                                    "method_body": "public ArchiveInputStream createArchiveInputStream(\nfinal String archiverName, final InputStream in)\nthrows ArchiveException {\nif (archiverName == null || in == null) {\nthrow new IllegalArgumentException(\"Archivername must not be null.\");\n}\n\nif (\"ar\".equalsIgnoreCase(archiverName)) {\nreturn new ArArchiveInputStream(in);\n} else if (\"zip\".equalsIgnoreCase(archiverName)) {\nreturn new ZipArchiveInputStream(in);\n} else if (\"tar\".equalsIgnoreCase(archiverName)) {\nreturn new TarArchiveInputStream(in);\n} else if (\"jar\".equalsIgnoreCase(archiverName)) {\nreturn new JarArchiveInputStream(in);\n} else if (\"cpio\".equalsIgnoreCase(archiverName)) {\nreturn new CpioArchiveInputStream(in);\n}\nthrow new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveOutputStream(Ljava/lang/String;Ljava/io/OutputStream;)Lorg/apache/commons/compress/archivers/ArchiveOutputStream;",
                                    "method_body": "public ArchiveOutputStream createArchiveOutputStream(\nfinal String archiverName, final OutputStream out)\nthrows ArchiveException {\nif (archiverName == null || out == null) {\nthrow new IllegalArgumentException(\n\"Archivername and stream must not be null.\");\n}\n\nif (\"ar\".equalsIgnoreCase(archiverName)) {\nreturn new ArArchiveOutputStream(out);\n} else if (\"zip\".equalsIgnoreCase(archiverName)) {\nreturn new ZipArchiveOutputStream(out);\n} else if (\"tar\".equalsIgnoreCase(archiverName)) {\nreturn new TarArchiveOutputStream(out);\n} else if (\"jar\".equalsIgnoreCase(archiverName)) {\nreturn new JarArchiveOutputStream(out);\n} else if (\"cpio\".equalsIgnoreCase(archiverName)) {\nreturn new CpioArchiveOutputStream(out);\n}\nthrow new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:copy(Ljava/io/InputStream;Ljava/io/OutputStream;)V",
                                    "method_body": "public static void copy(final InputStream input, final OutputStream output) throws IOException {\ncopy(input, output, 8024);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:copy(Ljava/io/InputStream;Ljava/io/OutputStream;I)V",
                                    "method_body": "public static void copy(final InputStream input, final OutputStream output, int buffersize) throws IOException {\nfinal byte[] buffer = new byte[buffersize];\nint n = 0;\nwhile (-1 != (n = input.read(buffer))) {\noutput.write(buffer, 0, n);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:<init>(Ljava/io/OutputStream;S)V",
                                    "method_body": "public CpioArchiveOutputStream(final OutputStream out, final short format) {\nthis.out = new FilterOutputStream(out);\nsetFormat(format);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public CpioArchiveOutputStream(final OutputStream out) {\nthis(out, FORMAT_NEW);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:ensureOpen()V",
                                    "method_body": "private void ensureOpen() throws IOException {\nif (this.closed) {\nthrow new IOException(\"Stream closed\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:setFormat(S)V",
                                    "method_body": "private void setFormat(final short format) {\nswitch (format) {\ncase FORMAT_NEW:\ncase FORMAT_NEW_CRC:\ncase FORMAT_OLD_ASCII:\ncase FORMAT_OLD_BINARY:\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"Unknown header type\");\n\n}\nsynchronized (this) {\nthis.entryFormat = format;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:putNextEntry(Lorg/apache/commons/compress/archivers/cpio/CpioArchiveEntry;)V",
                                    "method_body": "public void putNextEntry(final CpioArchiveEntry e) throws IOException {\nensureOpen();\nif (this.cpioEntry != null) {\ncloseArchiveEntry(); // close previous entry\n}\nif (e.getTime() == -1) {\ne.setTime(System.currentTimeMillis());\n}\n\n// TODO what happens if an entry has an other format than the\n// outputstream?\nif (e.getFormat() == -1) {\ne.setFormat(this.entryFormat);\n}\n\nif (this.names.put(e.getName(), e) != null) {\nthrow new IOException(\"duplicate entry: \" + e.getName());\n}\n\nwriteHeader(e);\nthis.cpioEntry = e;\nthis.written = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:writeHeader(Lorg/apache/commons/compress/archivers/cpio/CpioArchiveEntry;)V",
                                    "method_body": "private void writeHeader(final CpioArchiveEntry e) throws IOException {\nswitch (e.getFormat()) {\ncase FORMAT_NEW:\nout.write(MAGIC_NEW.getBytes());\nwriteNewEntry(e);\nbreak;\ncase FORMAT_NEW_CRC:\nout.write(MAGIC_NEW_CRC.getBytes());\nwriteNewEntry(e);\nbreak;\ncase FORMAT_OLD_ASCII:\nout.write(MAGIC_OLD_ASCII.getBytes());\nwriteOldAsciiEntry(e);\nbreak;\ncase FORMAT_OLD_BINARY:\nboolean swapHalfWord = true;\nwriteBinaryLong(MAGIC_OLD_BINARY, 2, swapHalfWord);\nwriteOldBinaryEntry(e, swapHalfWord);\nbreak;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:writeNewEntry(Lorg/apache/commons/compress/archivers/cpio/CpioArchiveEntry;)V",
                                    "method_body": "private void writeNewEntry(final CpioArchiveEntry entry) throws IOException {\nwriteAsciiLong(entry.getInode(), 8, 16);\nwriteAsciiLong(entry.getMode(), 8, 16);\nwriteAsciiLong(entry.getUID(), 8, 16);\nwriteAsciiLong(entry.getGID(), 8, 16);\nwriteAsciiLong(entry.getNumberOfLinks(), 8, 16);\nwriteAsciiLong(entry.getTime(), 8, 16);\nwriteAsciiLong(entry.getSize(), 8, 16);\nwriteAsciiLong(entry.getDeviceMaj(), 8, 16);\nwriteAsciiLong(entry.getDeviceMin(), 8, 16);\nwriteAsciiLong(entry.getRemoteDeviceMaj(), 8, 16);\nwriteAsciiLong(entry.getRemoteDeviceMin(), 8, 16);\nwriteAsciiLong(entry.getName().length() + 1, 8, 16);\nwriteAsciiLong(entry.getChksum(), 8, 16);\nwriteCString(entry.getName());\npad(entry.getHeaderSize() + entry.getName().length() + 1, 4);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nensureOpen();\n\nif (this.cpioEntry.getSize() != this.written) {\nthrow new IOException(\"invalid entry size (expected \"\n+ this.cpioEntry.getSize() + \" but got \" + this.written\n+ \" bytes)\");\n}\nif ((this.cpioEntry.getFormat() | FORMAT_NEW_MASK) == FORMAT_NEW_MASK) {\npad(this.cpioEntry.getSize(), 4);\n} else if ((this.cpioEntry.getFormat() | FORMAT_OLD_BINARY) == FORMAT_OLD_BINARY) {\npad(this.cpioEntry.getSize(), 2);\n}\nif ((this.cpioEntry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) {\nif (this.crc != this.cpioEntry.getChksum()) {\nthrow new IOException(\"CRC Error\");\n}\n}\nthis.cpioEntry = null;\nthis.crc = 0;\nthis.written = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int off, final int len)\nthrows IOException {\nensureOpen();\nif (off < 0 || len < 0 || off > b.length - len) {\nthrow new IndexOutOfBoundsException();\n} else if (len == 0) {\nreturn;\n}\n\nif (this.cpioEntry == null) {\nthrow new IOException(\"no current CPIO entry\");\n}\nif (this.written + len > this.cpioEntry.getSize()) {\nthrow new IOException(\"attempt to write past end of STORED entry\");\n}\nout.write(b, off, len);\nthis.written += len;\nif ((this.cpioEntry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) {\nfor (int pos = 0; pos < len; pos++) {\nthis.crc += b[pos] & 0xFF;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!this.closed) {\nsuper.close();\nthis.closed = true;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:pad(JI)V",
                                    "method_body": "private void pad(final long count, final int border) throws IOException {\nlong skip = count % border;\nif (skip > 0) {\nbyte tmp[] = new byte[(int) (border - skip)];\nout.write(tmp);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:writeAsciiLong(JII)V",
                                    "method_body": "private void writeAsciiLong(final long number, final int length,\nfinal int radix) throws IOException {\nStringBuffer tmp = new StringBuffer();\nString tmpStr;\nif (radix == 16) {\ntmp.append(Long.toHexString(number));\n} else if (radix == 8) {\ntmp.append(Long.toOctalString(number));\n} else {\ntmp.append(Long.toString(number));\n}\n\nif (tmp.length() <= length) {\nlong insertLength = length - tmp.length();\nfor (int pos = 0; pos < insertLength; pos++) {\ntmp.insert(0, \"0\");\n}\ntmpStr = tmp.toString();\n} else {\ntmpStr = tmp.substring(tmp.length() - length);\n}\nout.write(tmpStr.getBytes());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:writeCString(Ljava/lang/String;)V",
                                    "method_body": "private void writeCString(final String str) throws IOException {\nout.write(str.getBytes());\nout.write('\\0');\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry entry) throws IOException {\nthis.putNextEntry((CpioArchiveEntry) entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:<init>(S)V",
                                    "method_body": "public CpioArchiveEntry(final short format) {\nsetFormat(format);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:<init>(Ljava/lang/String;J)V",
                                    "method_body": "public CpioArchiveEntry(final String name, final long size) {\nthis(FORMAT_NEW);\nthis.name = name;\nthis.setSize(size);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:checkNewFormat()V",
                                    "method_body": "private void checkNewFormat() {\nif ((this.fileFormat & FORMAT_NEW_MASK) == 0) {\nthrow new UnsupportedOperationException();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getChksum()J",
                                    "method_body": "public long getChksum() {\ncheckNewFormat();\nreturn this.chksum;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getDeviceMaj()J",
                                    "method_body": "public long getDeviceMaj() {\ncheckNewFormat();\nreturn this.maj;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getDeviceMin()J",
                                    "method_body": "public long getDeviceMin() {\ncheckNewFormat();\nreturn this.min;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn this.filesize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getFormat()S",
                                    "method_body": "public short getFormat() {\nreturn this.fileFormat;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getGID()J",
                                    "method_body": "public long getGID() {\nreturn this.gid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getHeaderSize()J",
                                    "method_body": "public long getHeaderSize() {\nreturn this.headerSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getInode()J",
                                    "method_body": "public long getInode() {\nreturn this.inode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getMode()J",
                                    "method_body": "public long getMode() {\nreturn this.mode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn this.name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getNumberOfLinks()J",
                                    "method_body": "public long getNumberOfLinks() {\nreturn this.nlink;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getRemoteDeviceMaj()J",
                                    "method_body": "public long getRemoteDeviceMaj() {\ncheckNewFormat();\nreturn this.rmaj;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getRemoteDeviceMin()J",
                                    "method_body": "public long getRemoteDeviceMin() {\ncheckNewFormat();\nreturn this.rmin;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getTime()J",
                                    "method_body": "public long getTime() {\nreturn this.mtime;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getUID()J",
                                    "method_body": "public long getUID() {\nreturn this.uid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setChksum(J)V",
                                    "method_body": "public void setChksum(final long chksum) {\ncheckNewFormat();\nthis.chksum = chksum;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setDeviceMaj(J)V",
                                    "method_body": "public void setDeviceMaj(final long maj) {\ncheckNewFormat();\nthis.maj = maj;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setDeviceMin(J)V",
                                    "method_body": "public void setDeviceMin(final long min) {\ncheckNewFormat();\nthis.min = min;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(final long size) {\nif (size < 0 || size > 0xFFFFFFFFL) {\nthrow new IllegalArgumentException(\"invalid entry size <\" + size\n+ \">\");\n}\nthis.filesize = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setFormat(S)V",
                                    "method_body": "final void setFormat(final short format) {\nswitch (format) {\ncase FORMAT_NEW:\nthis.fileFormat = FORMAT_NEW;\nthis.headerSize = 110;\nbreak;\ncase FORMAT_NEW_CRC:\nthis.fileFormat = FORMAT_NEW_CRC;\nthis.headerSize = 110;\nbreak;\ncase FORMAT_OLD_ASCII:\nthis.fileFormat = FORMAT_OLD_ASCII;\nthis.headerSize = 76;\nbreak;\ncase FORMAT_OLD_BINARY:\nthis.fileFormat = FORMAT_OLD_BINARY;\nthis.headerSize = 26;\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"Unknown header type\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setGID(J)V",
                                    "method_body": "public void setGID(final long gid) {\nthis.gid = gid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setInode(J)V",
                                    "method_body": "public void setInode(final long inode) {\nthis.inode = inode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setMode(J)V",
                                    "method_body": "public void setMode(final long mode) {\nswitch ((int) (mode & S_IFMT)) {\ncase C_ISDIR:\ncase C_ISLNK:\ncase C_ISREG:\ncase C_ISFIFO:\ncase C_ISCHR:\ncase C_ISBLK:\ncase C_ISSOCK:\ncase C_ISNWK:\nbreak;\ndefault:\n// FIXME: testCpioUnarchive fails if I change the line to\n// actually throw the excpetion\nnew IllegalArgumentException(\"Unknown mode (full mode: \" + mode\n+ \", masked mode: \" + (mode & S_IFMT));\n}\n\nthis.mode = mode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "public void setName(final String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setNumberOfLinks(J)V",
                                    "method_body": "public void setNumberOfLinks(final long nlink) {\nthis.nlink = nlink;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setRemoteDeviceMaj(J)V",
                                    "method_body": "public void setRemoteDeviceMaj(final long rmaj) {\ncheckNewFormat();\nthis.rmaj = rmaj;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setRemoteDeviceMin(J)V",
                                    "method_body": "public void setRemoteDeviceMin(final long rmin) {\ncheckNewFormat();\nthis.rmin = rmin;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setTime(J)V",
                                    "method_body": "public void setTime(final long time) {\nthis.mtime = time;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setUID(J)V",
                                    "method_body": "public void setUID(final long uid) {\nthis.uid = uid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public CpioArchiveInputStream(final InputStream in) {\nthis.in = in;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:closeEntry()V",
                                    "method_body": "public void closeEntry() throws IOException {\nensureOpen();\nwhile (read(this.tmpbuf, 0, this.tmpbuf.length) != -1) {\n// do nothing\n}\n\nthis.entryEOF = true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:ensureOpen()V",
                                    "method_body": "private void ensureOpen() throws IOException {\nif (this.closed) {\nthrow new IOException(\"Stream closed\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:getNextCPIOEntry()Lorg/apache/commons/compress/archivers/cpio/CpioArchiveEntry;",
                                    "method_body": "public CpioArchiveEntry getNextCPIOEntry() throws IOException {\nensureOpen();\nif (this.entry != null) {\ncloseEntry();\n}\nbyte magic[] = new byte[2];\nreadFully(magic, 0, magic.length);\nif (CpioUtil.byteArray2long(magic, false) == MAGIC_OLD_BINARY) {\nthis.entry = readOldBinaryEntry(false);\n} else if (CpioUtil.byteArray2long(magic, true) == MAGIC_OLD_BINARY) {\nthis.entry = readOldBinaryEntry(true);\n} else {\nbyte more_magic[] = new byte[4];\nreadFully(more_magic, 0, more_magic.length);\nbyte tmp[] = new byte[6];\nSystem.arraycopy(magic, 0, tmp, 0, magic.length);\nSystem.arraycopy(more_magic, 0, tmp, magic.length,\nmore_magic.length);\nString magicString = new String(tmp);\nif (magicString.equals(MAGIC_NEW)) {\nthis.entry = readNewEntry(false);\n} else if (magicString.equals(MAGIC_NEW_CRC)) {\nthis.entry = readNewEntry(true);\n} else if (magicString.equals(MAGIC_OLD_ASCII)) {\nthis.entry = readOldAsciiEntry();\n} else {\nthrow new IOException(\"Unknown magic [\" + magicString + \"]\");\n}\n}\n\nthis.entryBytesRead = 0;\nthis.entryEOF = false;\nthis.crc = 0;\n\nif (this.entry.getName().equals(\"TRAILER!!!\")) {\nthis.entryEOF = true;\nreturn null;\n}\nreturn this.entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:pad(JI)J",
                                    "method_body": "private long pad(final long count, final int border) throws IOException {\nlong skip = count % border;\nif (skip > 0) {\nskip = this.in.skip(border - skip);\n}\nreturn skip;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:read([BII)I",
                                    "method_body": "public int read(final byte[] b, final int off, final int len)\nthrows IOException {\nensureOpen();\nif (off < 0 || len < 0 || off > b.length - len) {\nthrow new IndexOutOfBoundsException();\n} else if (len == 0) {\nreturn 0;\n}\n\nif (this.entry == null || this.entryEOF) {\nreturn -1;\n}\nif (this.entryBytesRead == this.entry.getSize()) {\nif ((this.entry.getFormat() | FORMAT_NEW_MASK) == FORMAT_NEW_MASK) {\npad(this.entry.getSize(), 4);\n} else if ((this.entry.getFormat() | FORMAT_OLD_BINARY) == FORMAT_OLD_BINARY) {\npad(this.entry.getSize(), 2);\n}\nthis.entryEOF = true;\nif ((this.entry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) {\nif (this.crc != this.entry.getChksum()) {\nthrow new IOException(\"CRC Error\");\n}\n}\nreturn -1;\n}\nint tmplength = (int) Math.min(len, this.entry.getSize()\n- this.entryBytesRead);\nif (tmplength < 0) {\nreturn -1;\n}\n\nint tmpread = this.in.read(b, off, tmplength);\nif ((this.entry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) {\nfor (int pos = 0; pos < tmpread; pos++) {\nthis.crc += b[pos] & 0xFF;\n}\n}\nthis.entryBytesRead += tmpread;\n\nreturn tmpread;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:readFully([BII)I",
                                    "method_body": "private final int readFully(final byte[] b, final int off, final int len)\nthrows IOException {\nif (len < 0) {\nthrow new IndexOutOfBoundsException();\n}\nint n = 0;\nwhile (n < len) {\nint count = this.in.read(b, off + n, len - n);\nif (count < 0) {\nthrow new EOFException();\n}\nn += count;\n}\nreturn n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:readAsciiLong(II)J",
                                    "method_body": "private long readAsciiLong(final int length, final int radix)\nthrows IOException {\nbyte tmpBuffer[] = new byte[length];\nreadFully(tmpBuffer, 0, tmpBuffer.length);\nreturn Long.parseLong(new String(tmpBuffer), radix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:readNewEntry(Z)Lorg/apache/commons/compress/archivers/cpio/CpioArchiveEntry;",
                                    "method_body": "private CpioArchiveEntry readNewEntry(final boolean hasCrc)\nthrows IOException {\nCpioArchiveEntry ret;\nif (hasCrc) {\nret = new CpioArchiveEntry(FORMAT_NEW_CRC);\n} else {\nret = new CpioArchiveEntry(FORMAT_NEW);\n}\n\nret.setInode(readAsciiLong(8, 16));\nret.setMode(readAsciiLong(8, 16));\nret.setUID(readAsciiLong(8, 16));\nret.setGID(readAsciiLong(8, 16));\nret.setNumberOfLinks(readAsciiLong(8, 16));\nret.setTime(readAsciiLong(8, 16));\nret.setSize(readAsciiLong(8, 16));\nret.setDeviceMaj(readAsciiLong(8, 16));\nret.setDeviceMin(readAsciiLong(8, 16));\nret.setRemoteDeviceMaj(readAsciiLong(8, 16));\nret.setRemoteDeviceMin(readAsciiLong(8, 16));\nlong namesize = readAsciiLong(8, 16);\nret.setChksum(readAsciiLong(8, 16));\nret.setName(readCString((int) namesize));\npad(ret.getHeaderSize() + namesize, 4);\n\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:readCString(I)Ljava/lang/String;",
                                    "method_body": "private String readCString(final int length) throws IOException {\nbyte tmpBuffer[] = new byte[length];\nreadFully(tmpBuffer, 0, tmpBuffer.length);\nreturn new String(tmpBuffer, 0, tmpBuffer.length - 1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:getNextEntry()Lorg/apache/commons/compress/archivers/ArchiveEntry;",
                                    "method_body": "public ArchiveEntry getNextEntry() throws IOException {\nreturn getNextCPIOEntry();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioUtil:byteArray2long([BZ)J",
                                    "method_body": "static long byteArray2long(final byte[] number, final boolean swapHalfWord) {\nlong ret = 0;\nint pos = 0;\nbyte tmp_number[] = new byte[number.length];\nSystem.arraycopy(number, 0, tmp_number, 0, number.length);\n\nif (tmp_number.length % 2 != 0) {\nthrow new UnsupportedOperationException();\n}\n\nif (!swapHalfWord) {\nbyte tmp = 0;\nfor (pos = 0; pos < tmp_number.length; pos++) {\ntmp = tmp_number[pos];\ntmp_number[pos++] = tmp_number[pos];\ntmp_number[pos] = tmp;\n}\n}\n\nret = tmp_number[0] & 0xFF;\nfor (pos = 1; pos < tmp_number.length; pos++) {\nret <<= 8;\nret |= tmp_number[pos] & 0xFF;\n}\nreturn ret;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 2,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.ArTestCase.testArDelete",
                            "test_body": "89: public void testArDelete() throws Exception {\n90: final File output = new File(dir, \"bla.ar\");\n91: 92: final File file1 = getFile(\"test1.xml\");\n93: final File file2 = getFile(\"test2.xml\");\n94: {\n95: // create\n96: 97: final OutputStream out = new FileOutputStream(output);\n98: final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\"ar\", out);\n99: os.putArchiveEntry(new ArArchiveEntry(\"test1.xml\", file1.length()));\n100: IOUtils.copy(new FileInputStream(file1), os);\n101: os.closeArchiveEntry();\n102: 103: os.putArchiveEntry(new ArArchiveEntry(\"test2.xml\", file2.length()));\n104: IOUtils.copy(new FileInputStream(file2), os);\n105: os.closeArchiveEntry();\n106: os.close();\n107: out.close();\n108: }\n109: 110: assertEquals(8\n111: + 60 + file1.length() + (file1.length() % 2)\n112: + 60 + file2.length() + (file2.length() % 2),\n113: output.length());\n114: 115: final File output2 = new File(dir, \"bla2.ar\");\n116: 117: int copied = 0;\n118: int deleted = 0;\n119: 120: {\n121: // remove all but one file\n122: 123: final InputStream is = new FileInputStream(output);\n124: final OutputStream os = new FileOutputStream(output2);\n125: final ArchiveOutputStream aos = new ArchiveStreamFactory().createArchiveOutputStream(\"ar\", os);\n126: final ArchiveInputStream ais = new ArchiveStreamFactory().createArchiveInputStream(new BufferedInputStream(is));\n127: while(true) {\n128: final ArArchiveEntry entry = (ArArchiveEntry)ais.getNextEntry();\n129: if (entry == null) {\n130: break;\n131: }\n132: 133: if (\"test1.xml\".equals(entry.getName())) {\n134: aos.putArchiveEntry(entry);\n135: IOUtils.copy(ais, aos);\n136: aos.closeArchiveEntry();\n137: copied++;\n138: } else {\n139: IOUtils.copy(ais, new ByteArrayOutputStream());\n140: deleted++;\n141: }\n142: 143: }\n144: ais.close();\n145: aos.close();\n146: is.close();\n147: os.close();\n148: }\n149: 150: assertEquals(1, copied);\n151: assertEquals(1, deleted);\n152: assertEquals(144, output2.length());\n153: 154: long files = 0;\n155: long sum = 0;\n156: 157: {\n158: final InputStream is = new FileInputStream(output2);\n159: final ArchiveInputStream ais = new ArchiveStreamFactory().createArchiveInputStream(new BufferedInputStream(is));\n160: while(true) {\n161: final ArArchiveEntry entry = (ArArchiveEntry)ais.getNextEntry();\n162: if (entry == null) {\n163: break;\n164: }\n165: 166: IOUtils.copy(ais, new ByteArrayOutputStream());\n167: 168: sum +=  entry.getLength();\n169: files++;\n170: }\n171: ais.close();\n172: is.close();\n173: }\n174: 175: assertEquals(1, files);\n176: assertEquals(76, sum);\n177: 178: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveOutputStream(Ljava/lang/String;Ljava/io/OutputStream;)Lorg/apache/commons/compress/archivers/ArchiveOutputStream;",
                                    "method_body": "public ArchiveOutputStream createArchiveOutputStream(\nfinal String archiverName, final OutputStream out)\nthrows ArchiveException {\nif (archiverName == null || out == null) {\nthrow new IllegalArgumentException(\n\"Archivername and stream must not be null.\");\n}\n\nif (\"ar\".equalsIgnoreCase(archiverName)) {\nreturn new ArArchiveOutputStream(out);\n} else if (\"zip\".equalsIgnoreCase(archiverName)) {\nreturn new ZipArchiveOutputStream(out);\n} else if (\"tar\".equalsIgnoreCase(archiverName)) {\nreturn new TarArchiveOutputStream(out);\n} else if (\"jar\".equalsIgnoreCase(archiverName)) {\nreturn new JarArchiveOutputStream(out);\n} else if (\"cpio\".equalsIgnoreCase(archiverName)) {\nreturn new CpioArchiveOutputStream(out);\n}\nthrow new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveInputStream(Ljava/io/InputStream;)Lorg/apache/commons/compress/archivers/ArchiveInputStream;",
                                    "method_body": "public ArchiveInputStream createArchiveInputStream(final InputStream in)\nthrows ArchiveException {\nif (in == null) {\nthrow new IllegalArgumentException(\"Stream must not be null.\");\n}\n\nif (!in.markSupported()) {\nthrow new IllegalArgumentException(\"Mark is not supported.\");\n}\n\nfinal byte[] signature = new byte[12];\nin.mark(signature.length);\ntry {\nint signatureLength = in.read(signature);\nin.reset();\nif (ZipArchiveInputStream.matches(signature, signatureLength)) {\nreturn new ZipArchiveInputStream(in);\n} else if (JarArchiveInputStream\n.matches(signature, signatureLength)) {\nreturn new JarArchiveInputStream(in);\n} else if (TarArchiveInputStream\n.matches(signature, signatureLength)) {\nreturn new TarArchiveInputStream(in);\n} else if (ArArchiveInputStream.matches(signature, signatureLength)) {\nreturn new ArArchiveInputStream(in);\n} else if (CpioArchiveInputStream.matches(signature,\nsignatureLength)) {\nreturn new CpioArchiveInputStream(in);\n}\n} catch (IOException e) {\nthrow new ArchiveException(\n\"Could not use reset and mark operations.\", e);\n}\n\nthrow new ArchiveException(\n\"No Archiver found for the stream signature\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final int BYTE_MASK = 0xFF;\nprivate static final int SHORT = 2;\nprivate static final int WORD = 4;\nstatic final int BUFFER_SIZE = 512;\n/*\n* Apparently Deflater.setInput gets slowed down a lot on Sun JVMs\n* when it gets handed a really big buffer.  See\n* https://issues.apache.org/bugzilla/show_bug.cgi?id=45396\n*\n* Using a buffer size of 8 kB proved to be a good compromise\n*/\nprivate static final int DEFLATER_BLOCK_SIZE = 8192;\n\n/**\n* Compression method for deflated entries.\n*/\npublic static final int DEFLATED = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* Default compression level for deflated entries.\n*/\npublic static final int DEFAULT_COMPRESSION = Deflater.DEFAULT_COMPRESSION;\n\n/**\n* Compression method for stored entries.\n*/\npublic static final int STORED = java.util.zip.ZipEntry.STORED;\n\n/**\n* default encoding for file names and comment.\n*/\nstatic final String DEFAULT_ENCODING = ZipEncodingHelper.UTF8;\n\n/**\n* General purpose flag, which indicates that filenames are\n* written in utf-8.\n*/\npublic static final int EFS_FLAG = 1 << 11;\n\n/**\n* Current entry.\n*/\nprivate ZipArchiveEntry entry;\n\n/**\n* The file comment.\n*/\nprivate String comment = \"\";\n\n/**\n* Compression level for next entry.\n*/\nprivate int level = DEFAULT_COMPRESSION;\n\n/**\n* Has the compression level changed when compared to the last\n* entry?\n*/\nprivate boolean hasCompressionLevelChanged = false;\n\n/**\n* Default compression method for next entry.\n*/\nprivate int method = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* List of ZipArchiveEntries written so far.\n*/\nprivate final List entries = new LinkedList();\n\n/**\n* CRC instance to avoid parsing DEFLATED data twice.\n*/\nprivate final CRC32 crc = new CRC32();\n\n/**\n* Count the bytes written to out.\n*/\nprivate long written = 0;\n\n/**\n* Data for local header data\n*/\nprivate long dataStart = 0;\n\n/**\n* Offset for CRC entry in the local file header data for the\n* current entry starts here.\n*/\nprivate long localDataStart = 0;\n\n/**\n* Start of central directory.\n*/\nprivate long cdOffset = 0;\n\n/**\n* Length of central directory.\n*/\nprivate long cdLength = 0;\n\n/**\n* Helper, a 0 as ZipShort.\n*/\nprivate static final byte[] ZERO = {0, 0};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n//private static final int BYTE_BIT_SIZE = 8;\nprivate static final int BYTE_MASK = 0xFF;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:copy(Ljava/io/InputStream;Ljava/io/OutputStream;)J",
                                    "method_body": "public static long copy(final InputStream input, final OutputStream output) throws IOException {\nreturn copy(input, output, 8024);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:copy(Ljava/io/InputStream;Ljava/io/OutputStream;I)J",
                                    "method_body": "public static long copy(final InputStream input, final OutputStream output, int buffersize) throws IOException {\nfinal byte[] buffer = new byte[buffersize];\nint n = 0;\nlong count=0;\nwhile (-1 != (n = input.read(buffer))) {\noutput.write(buffer, 0, n);\ncount += n;\n}\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < ZipArchiveOutputStream.LFH_SIG.length) {\nreturn false;\n}\n\nreturn checksig(signature, ZipArchiveOutputStream.LFH_SIG) // normal file\n|| checksig(signature, ZipArchiveOutputStream.EOCD_SIG); // empty zip\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:checksig([B[B)Z",
                                    "method_body": "private static boolean checksig(byte[] signature, byte[] expected){\nfor (int i = 0; i < expected.length; i++) {\nif (signature[i] != expected[i]) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\n// 6574 7473 2e31 6d78 == \"test1.xml\"\n// TODO replace with a proper test if possible - see COMPRESS-65\n\nif (length < 8) {\nreturn false;\n}\n\nif (signature[0] != 0x74) {\nreturn false;\n}\nif (signature[1] != 0x65) {\nreturn false;\n}\nif (signature[2] != 0x73) {\nreturn false;\n}\nif (signature[3] != 0x74) {\nreturn false;\n}\nif (signature[4] != 0x31) {\nreturn false;\n}\nif (signature[5] != 0x2e) {\nreturn false;\n}\nif (signature[6] != 0x78) {\nreturn false;\n}\nif (signature[7] != 0x6d) {\nreturn false;\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length ) {\nreturn ZipArchiveInputStream.matches(signature, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public ArArchiveOutputStream( final OutputStream pOut ) {\nthis.out = pOut;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:writeArchiveHeader()J",
                                    "method_body": "private long writeArchiveHeader() throws IOException {\nbyte [] header = ArArchiveEntry.HEADER.getBytes();\nout.write(header);\nreturn header.length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (prevEntry != null && haveUnclosedEntry && (entryOffset % 2) != 0) {\nout.write('\\n'); // Pad byte\narchiveOffset++;\n}\nhaveUnclosedEntry = false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry( final ArchiveEntry pEntry ) throws IOException {\nArArchiveEntry pArEntry = (ArArchiveEntry)pEntry;\nif (prevEntry == null) {\narchiveOffset += writeArchiveHeader();\n} else {\nif (prevEntry.getLength() != entryOffset) {\nthrow new IOException(\"length does not match entry (\" + prevEntry.getLength() + \" != \" + entryOffset);\n}\n\ncloseArchiveEntry();\n}\n\nprevEntry = pArEntry;\n\narchiveOffset += writeEntryHeader(pArEntry);\n\nentryOffset = 0;\nhaveUnclosedEntry = true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:fill(JJC)J",
                                    "method_body": "private long fill( final long pOffset, final long pNewOffset, final char pFill ) throws IOException {\nfinal long diff = pNewOffset - pOffset;\n\nif (diff > 0) {\nfor (int i = 0; i < diff; i++) {\nwrite(pFill);\n}\n}\n\nreturn pNewOffset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:write(Ljava/lang/String;)J",
                                    "method_body": "private long write( final String data ) throws IOException {\nfinal byte[] bytes = data.getBytes(\"ascii\");\nwrite(bytes);\nreturn bytes.length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:writeEntryHeader(Lorg/apache/commons/compress/archivers/ar/ArArchiveEntry;)J",
                                    "method_body": "private long writeEntryHeader( final ArArchiveEntry pEntry ) throws IOException {\n\nlong offset = 0;\n\nfinal String n = pEntry.getName();\nif (n.length() > 16) {\nthrow new IOException(\"filename too long\");\n}\noffset += write(n);\n\noffset = fill(offset, 16, ' ');\nfinal String m = \"\" + (pEntry.getLastModified() / 1000);\nif (m.length() > 12) {\nthrow new IOException(\"modified too long\");\n}\noffset += write(m);\n\noffset = fill(offset, 28, ' ');\nfinal String u = \"\" + pEntry.getUserId();\nif (u.length() > 6) {\nthrow new IOException(\"userid too long\");\n}\noffset += write(u);\n\noffset = fill(offset, 34, ' ');\nfinal String g = \"\" + pEntry.getGroupId();\nif (g.length() > 6) {\nthrow new IOException(\"groupid too long\");\n}\noffset += write(g);\n\noffset = fill(offset, 40, ' ');\nfinal String fm = \"\" + Integer.toString(pEntry.getMode(), 8);\nif (fm.length() > 8) {\nthrow new IOException(\"filemode too long\");\n}\noffset += write(fm);\n\noffset = fill(offset, 48, ' ');\nfinal String s = \"\" + pEntry.getLength();\nif (s.length() > 10) {\nthrow new IOException(\"size too long\");\n}\noffset += write(s);\n\noffset = fill(offset, 58, ' ');\n\noffset += write(ArArchiveEntry.TRAILER);\n\nreturn offset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:write(I)V",
                                    "method_body": "public void write(int b) throws IOException {\nout.write(b);\nentryOffset++;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int off, int len) throws IOException {\nout.write(b, off, len);\nentryOffset += len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:write([B)V",
                                    "method_body": "public void write(byte[] b) throws IOException {\nout.write(b);\nentryOffset += b.length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\ncloseArchiveEntry();\nout.close();\nprevEntry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:<init>(Ljava/lang/String;J)V",
                                    "method_body": "public ArArchiveEntry(String name, long length) {\nthis(name, length, 0, 0, DEFAULT_MODE, System.currentTimeMillis());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:<init>(Ljava/lang/String;JIIIJ)V",
                                    "method_body": "public ArArchiveEntry(String name, long length, int userId, int groupId, int mode, long lastModified) {\nthis.name = name;\nthis.length = length;\nthis.userId = userId;\nthis.groupId = groupId;\nthis.mode = mode;\nthis.lastModified = lastModified;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getUserId()I",
                                    "method_body": "public int getUserId() {\nreturn userId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getGroupId()I",
                                    "method_body": "public int getGroupId() {\nreturn groupId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getMode()I",
                                    "method_body": "public int getMode() {\nreturn mode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getLastModified()J",
                                    "method_body": "public long getLastModified() {\nreturn lastModified;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getLength()J",
                                    "method_body": "public long getLength() {\nreturn length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public ArArchiveInputStream( final InputStream pInput ) {\ninput = pInput;\nclosed = false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:getNextArEntry()Lorg/apache/commons/compress/archivers/ar/ArArchiveEntry;",
                                    "method_body": "public ArArchiveEntry getNextArEntry() throws IOException {\n// hit EOF before previous entry was complete\n// TODO: throw an exception instead?\n\nif (offset == 0) {\nfinal byte[] expected = ArArchiveEntry.HEADER.getBytes();\nfinal byte[] realized = new byte[expected.length];\nfinal int read = read(realized);\nif (read != expected.length) {\nthrow new IOException(\"failed to read header\");\n}\nfor (int i = 0; i < expected.length; i++) {\nif (expected[i] != realized[i]) {\nthrow new IOException(\"invalid header \" + new String(realized));\n}\n}\n}\n\n// hit eof\n\nif (input.available() == 0) {\nreturn null;\n}\n\nif (offset % 2 != 0) {\nread();\n}\nfinal byte[] name = new byte[16];\nfinal byte[] lastmodified = new byte[12];\nfinal byte[] userid = new byte[6];\nfinal byte[] groupid = new byte[6];\nfinal byte[] filemode = new byte[8];\nfinal byte[] length = new byte[10];\n\nread(name);\nread(lastmodified);\nread(userid);\nread(groupid);\nread(filemode);\nread(length);\n\n{\nfinal byte[] expected = ArArchiveEntry.TRAILER.getBytes();\nfinal byte[] realized = new byte[expected.length];\nfinal int read = read(realized);\nif (read != expected.length) {\nthrow new IOException(\"failed to read entry header\");\n}\nfor (int i = 0; i < expected.length; i++) {\nif (expected[i] != realized[i]) {\nthrow new IOException(\"invalid entry header. not read the content?\");\n}\n}\n}\n\nreturn new ArArchiveEntry(new String(name).trim(),\nLong.parseLong(new String(length)\n.trim()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:getNextEntry()Lorg/apache/commons/compress/archivers/ArchiveEntry;",
                                    "method_body": "public ArchiveEntry getNextEntry() throws IOException {\nreturn getNextArEntry();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!closed) {\nclosed = true;\ninput.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:read([B)I",
                                    "method_body": "public int read(byte[] b) throws IOException {\nreturn read(b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, final int off, final int len) throws IOException {\nint toRead = len;\nfinal int ret = this.input.read(b, off, toRead);\noffset += (ret > 0 ? ret : 0);\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\n// 3c21 7261 6863 0a3e\n\nif (length < 8) {\nreturn false;\n}\nif (signature[0] != 0x21) {\nreturn false;\n}\nif (signature[1] != 0x3c) {\nreturn false;\n}\nif (signature[2] != 0x61) {\nreturn false;\n}\nif (signature[3] != 0x72) {\nreturn false;\n}\nif (signature[4] != 0x63) {\nreturn false;\n}\nif (signature[5] != 0x68) {\nreturn false;\n}\nif (signature[6] != 0x3e) {\nreturn false;\n}\nif (signature[7] != 0x0a) {\nreturn false;\n}\n\nreturn true;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 3,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.ArchiveOutputStreamTest.testFinish",
                            "test_body": "24: public void testFinish() throws Exception {\n25: OutputStream out1 = new ByteArrayOutputStream();\n26: 27: ArchiveOutputStream aos1 = factory.createArchiveOutputStream(\"zip\", out1);\n28: aos1.putArchiveEntry(new ZipArchiveEntry(\"dummy\"));\n29: try {\n30: aos1.finish();\n31: fail(\"After putArchive should follow closeArchive\");\n32: } catch (IOException io) {\n33: // Exception expected\n34: }\n35: 36: aos1 = factory.createArchiveOutputStream(\"jar\", out1);\n37: aos1.putArchiveEntry(new JarArchiveEntry(\"dummy\"));\n38: try {\n39: aos1.finish();\n40: fail(\"After putArchive should follow closeArchive\");\n41: } catch (IOException io) {\n42: // Exception expected\n43: }\n44: 45: aos1 = factory.createArchiveOutputStream(\"ar\", out1);\n46: aos1.putArchiveEntry(new ArArchiveEntry(\"dummy\", 100));\n47: try {\n48: aos1.finish();\n49: fail(\"After putArchive should follow closeArchive\");\n50: } catch (IOException io) {\n51: // Exception expected\n52: }\n53: 54: aos1 = factory.createArchiveOutputStream(\"cpio\", out1);\n55: aos1.putArchiveEntry(new CpioArchiveEntry(\"dummy\"));\n56: try {\n57: aos1.finish();\n58: fail(\"After putArchive should follow closeArchive\");\n59: } catch (IOException io) {\n60: // Exception expected\n61: }\n62: 63: aos1 = factory.createArchiveOutputStream(\"tar\", out1);\n64: aos1.putArchiveEntry(new TarArchiveEntry(\"dummy\"));\n65: try {\n66: aos1.finish();\n67: fail(\"After putArchive should follow closeArchive\");\n68: } catch (IOException io) {\n69: // Exception expected\n70: }\n71: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveOutputStream(Ljava/lang/String;Ljava/io/OutputStream;)Lorg/apache/commons/compress/archivers/ArchiveOutputStream;",
                                    "method_body": "public ArchiveOutputStream createArchiveOutputStream(\nfinal String archiverName, final OutputStream out)\nthrows ArchiveException {\nif (archiverName == null || out == null) {\nthrow new IllegalArgumentException(\n\"Archivername and stream must not be null.\");\n}\n\nif (\"ar\".equalsIgnoreCase(archiverName)) {\nreturn new ArArchiveOutputStream(out);\n} else if (\"zip\".equalsIgnoreCase(archiverName)) {\nreturn new ZipArchiveOutputStream(out);\n} else if (\"tar\".equalsIgnoreCase(archiverName)) {\nreturn new TarArchiveOutputStream(out);\n} else if (\"jar\".equalsIgnoreCase(archiverName)) {\nreturn new JarArchiveOutputStream(out);\n} else if (\"cpio\".equalsIgnoreCase(archiverName)) {\nreturn new CpioArchiveOutputStream(out);\n}\nthrow new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:<init>(Ljava/lang/String;J)V",
                                    "method_body": "public ArArchiveEntry(String name, long length) {\nthis(name, length, 0, 0, DEFAULT_MODE, System.currentTimeMillis());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:<init>(Ljava/lang/String;JIIIJ)V",
                                    "method_body": "public ArArchiveEntry(String name, long length, int userId, int groupId, int mode, long lastModified) {\nthis.name = name;\nthis.length = length;\nthis.userId = userId;\nthis.groupId = groupId;\nthis.mode = mode;\nthis.lastModified = lastModified;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getUserId()I",
                                    "method_body": "public int getUserId() {\nreturn userId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getGroupId()I",
                                    "method_body": "public int getGroupId() {\nreturn groupId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getMode()I",
                                    "method_body": "public int getMode() {\nreturn mode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getLastModified()J",
                                    "method_body": "public long getLastModified() {\nreturn lastModified;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry:getLength()J",
                                    "method_body": "public long getLength() {\nreturn length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveOutputStream:write(I)V",
                                    "method_body": "public void write(int b) throws IOException {\noneByte[0] = (byte) (b & BYTE_MASK);\nwrite(oneByte, 0, 1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public ArArchiveOutputStream( final OutputStream pOut ) {\nthis.out = pOut;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:writeArchiveHeader()J",
                                    "method_body": "private long writeArchiveHeader() throws IOException {\nbyte [] header = ArchiveUtils.toAsciiBytes(ArArchiveEntry.HEADER);\nout.write(header);\nreturn header.length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry( final ArchiveEntry pEntry ) throws IOException {\nArArchiveEntry pArEntry = (ArArchiveEntry)pEntry;\nif (prevEntry == null) {\narchiveOffset += writeArchiveHeader();\n} else {\nif (prevEntry.getLength() != entryOffset) {\nthrow new IOException(\"length does not match entry (\" + prevEntry.getLength() + \" != \" + entryOffset);\n}\n\ncloseArchiveEntry();\n}\n\nprevEntry = pArEntry;\n\narchiveOffset += writeEntryHeader(pArEntry);\n\nentryOffset = 0;\nhaveUnclosedEntry = true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:fill(JJC)J",
                                    "method_body": "private long fill( final long pOffset, final long pNewOffset, final char pFill ) throws IOException {\nfinal long diff = pNewOffset - pOffset;\n\nif (diff > 0) {\nfor (int i = 0; i < diff; i++) {\nwrite(pFill);\n}\n}\n\nreturn pNewOffset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:write(Ljava/lang/String;)J",
                                    "method_body": "private long write( final String data ) throws IOException {\nfinal byte[] bytes = data.getBytes(\"ascii\");\nwrite(bytes);\nreturn bytes.length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:writeEntryHeader(Lorg/apache/commons/compress/archivers/ar/ArArchiveEntry;)J",
                                    "method_body": "private long writeEntryHeader( final ArArchiveEntry pEntry ) throws IOException {\n\nlong offset = 0;\n\nfinal String n = pEntry.getName();\nif (n.length() > 16) {\nthrow new IOException(\"filename too long, > 16 chars: \"+n);\n}\noffset += write(n);\n\noffset = fill(offset, 16, ' ');\nfinal String m = \"\" + (pEntry.getLastModified() / 1000);\nif (m.length() > 12) {\nthrow new IOException(\"modified too long\");\n}\noffset += write(m);\n\noffset = fill(offset, 28, ' ');\nfinal String u = \"\" + pEntry.getUserId();\nif (u.length() > 6) {\nthrow new IOException(\"userid too long\");\n}\noffset += write(u);\n\noffset = fill(offset, 34, ' ');\nfinal String g = \"\" + pEntry.getGroupId();\nif (g.length() > 6) {\nthrow new IOException(\"groupid too long\");\n}\noffset += write(g);\n\noffset = fill(offset, 40, ' ');\nfinal String fm = \"\" + Integer.toString(pEntry.getMode(), 8);\nif (fm.length() > 8) {\nthrow new IOException(\"filemode too long\");\n}\noffset += write(fm);\n\noffset = fill(offset, 48, ' ');\nfinal String s = \"\" + pEntry.getLength();\nif (s.length() > 10) {\nthrow new IOException(\"size too long\");\n}\noffset += write(s);\n\noffset = fill(offset, 58, ' ');\n\noffset += write(ArArchiveEntry.TRAILER);\n\nreturn offset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int off, int len) throws IOException {\nout.write(b, off, len);\nentryOffset += len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif(haveUnclosedEntry) {\nthrow new IOException(\"This archives contains unclosed entries.\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:toAsciiBytes(Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] toAsciiBytes(String inputString){\ntry {\nreturn inputString.getBytes(\"ASCII\");\n} catch (UnsupportedEncodingException e) {\nthrow new RuntimeException(e); // Should never happen\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:<init>(S)V",
                                    "method_body": "public CpioArchiveEntry(final short format) {\nswitch (format) {\ncase FORMAT_NEW:\nthis.headerSize = 110;\nthis.alignmentBoundary = 4;\nbreak;\ncase FORMAT_NEW_CRC:\nthis.headerSize = 110;\nthis.alignmentBoundary = 4;\nbreak;\ncase FORMAT_OLD_ASCII:\nthis.headerSize = 76;\nthis.alignmentBoundary = 0;\nbreak;\ncase FORMAT_OLD_BINARY:\nthis.headerSize = 26;\nthis.alignmentBoundary = 2;\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"Unknown header type\");\n}\nthis.fileFormat = format;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public CpioArchiveEntry(final String name) {\nthis(FORMAT_NEW);\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:checkNewFormat()V",
                                    "method_body": "private void checkNewFormat() {\nif ((this.fileFormat & FORMAT_NEW_MASK) == 0) {\nthrow new UnsupportedOperationException();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getChksum()J",
                                    "method_body": "public long getChksum() {\ncheckNewFormat();\nreturn this.chksum;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getDeviceMaj()J",
                                    "method_body": "public long getDeviceMaj() {\ncheckNewFormat();\nreturn this.maj;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getDeviceMin()J",
                                    "method_body": "public long getDeviceMin() {\ncheckNewFormat();\nreturn this.min;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn this.filesize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getFormat()S",
                                    "method_body": "public short getFormat() {\nreturn this.fileFormat;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getGID()J",
                                    "method_body": "public long getGID() {\nreturn this.gid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getHeaderPadCount()I",
                                    "method_body": "public int getHeaderPadCount(){\nif (this.alignmentBoundary == 0) return 0;\nint size = this.headerSize+this.name.length()+1; // Name has terminating null\nint remain = size % this.alignmentBoundary;\nif (remain > 0){\nreturn this.alignmentBoundary - remain;\n}\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getInode()J",
                                    "method_body": "public long getInode() {\nreturn this.inode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getMode()J",
                                    "method_body": "public long getMode() {\nreturn this.mode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn this.name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getNumberOfLinks()J",
                                    "method_body": "public long getNumberOfLinks() {\nreturn this.nlink;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getRemoteDeviceMaj()J",
                                    "method_body": "public long getRemoteDeviceMaj() {\ncheckNewFormat();\nreturn this.rmaj;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getRemoteDeviceMin()J",
                                    "method_body": "public long getRemoteDeviceMin() {\ncheckNewFormat();\nreturn this.rmin;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getTime()J",
                                    "method_body": "public long getTime() {\nreturn this.mtime;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getUID()J",
                                    "method_body": "public long getUID() {\nreturn this.uid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:<init>(Ljava/io/OutputStream;S)V",
                                    "method_body": "public CpioArchiveOutputStream(final OutputStream out, final short format) {\nthis.out = new FilterOutputStream(out);\nswitch (format) {\ncase FORMAT_NEW:\ncase FORMAT_NEW_CRC:\ncase FORMAT_OLD_ASCII:\ncase FORMAT_OLD_BINARY:\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"Unknown format: \"+format);\n\n}\nthis.entryFormat = format;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public CpioArchiveOutputStream(final OutputStream out) {\nthis(out, FORMAT_NEW);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:ensureOpen()V",
                                    "method_body": "private void ensureOpen() throws IOException {\nif (this.closed) {\nthrow new IOException(\"Stream closed\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry entry) throws IOException {\nCpioArchiveEntry e = (CpioArchiveEntry) entry;\nensureOpen();\nif (this.entry != null) {\ncloseArchiveEntry(); // close previous entry\n}\nif (e.getTime() == -1) {\ne.setTime(System.currentTimeMillis());\n}\n\nfinal short format = e.getFormat();\nif (format != this.entryFormat){\nthrow new IOException(\"Header format: \"+format+\" does not match existing format: \"+this.entryFormat);\n}\n\nif (this.names.put(e.getName(), e) != null) {\nthrow new IOException(\"duplicate entry: \" + e.getName());\n}\n\nwriteHeader(e);\nthis.entry = e;\nthis.written = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:writeHeader(Lorg/apache/commons/compress/archivers/cpio/CpioArchiveEntry;)V",
                                    "method_body": "private void writeHeader(final CpioArchiveEntry e) throws IOException {\nswitch (e.getFormat()) {\ncase FORMAT_NEW:\nout.write(ArchiveUtils.toAsciiBytes(MAGIC_NEW));\nwriteNewEntry(e);\nbreak;\ncase FORMAT_NEW_CRC:\nout.write(ArchiveUtils.toAsciiBytes(MAGIC_NEW_CRC));\nwriteNewEntry(e);\nbreak;\ncase FORMAT_OLD_ASCII:\nout.write(ArchiveUtils.toAsciiBytes(MAGIC_OLD_ASCII));\nwriteOldAsciiEntry(e);\nbreak;\ncase FORMAT_OLD_BINARY:\nboolean swapHalfWord = true;\nwriteBinaryLong(MAGIC_OLD_BINARY, 2, swapHalfWord);\nwriteOldBinaryEntry(e, swapHalfWord);\nbreak;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:writeNewEntry(Lorg/apache/commons/compress/archivers/cpio/CpioArchiveEntry;)V",
                                    "method_body": "private void writeNewEntry(final CpioArchiveEntry entry) throws IOException {\nwriteAsciiLong(entry.getInode(), 8, 16);\nwriteAsciiLong(entry.getMode(), 8, 16);\nwriteAsciiLong(entry.getUID(), 8, 16);\nwriteAsciiLong(entry.getGID(), 8, 16);\nwriteAsciiLong(entry.getNumberOfLinks(), 8, 16);\nwriteAsciiLong(entry.getTime(), 8, 16);\nwriteAsciiLong(entry.getSize(), 8, 16);\nwriteAsciiLong(entry.getDeviceMaj(), 8, 16);\nwriteAsciiLong(entry.getDeviceMin(), 8, 16);\nwriteAsciiLong(entry.getRemoteDeviceMaj(), 8, 16);\nwriteAsciiLong(entry.getRemoteDeviceMin(), 8, 16);\nwriteAsciiLong(entry.getName().length() + 1, 8, 16);\nwriteAsciiLong(entry.getChksum(), 8, 16);\nwriteCString(entry.getName());\npad(entry.getHeaderPadCount());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nensureOpen();\n\nif (this.finished) {\nreturn;\n}\nif (this.entry != null) {\nthrow new IOException(\"This archives contains unclosed entries.\");\n}\nthis.entry = new CpioArchiveEntry(this.entryFormat);\nthis.entry.setName(CPIO_TRAILER);\nthis.entry.setNumberOfLinks(1);\nwriteHeader(this.entry);\ncloseArchiveEntry();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:pad(I)V",
                                    "method_body": "private void pad(int count) throws IOException{\nif (count > 0){\nbyte buff[] = new byte[count];\nout.write(buff);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:writeAsciiLong(JII)V",
                                    "method_body": "private void writeAsciiLong(final long number, final int length,\nfinal int radix) throws IOException {\nStringBuffer tmp = new StringBuffer();\nString tmpStr;\nif (radix == 16) {\ntmp.append(Long.toHexString(number));\n} else if (radix == 8) {\ntmp.append(Long.toOctalString(number));\n} else {\ntmp.append(Long.toString(number));\n}\n\nif (tmp.length() <= length) {\nlong insertLength = length - tmp.length();\nfor (int pos = 0; pos < insertLength; pos++) {\ntmp.insert(0, \"0\");\n}\ntmpStr = tmp.toString();\n} else {\ntmpStr = tmp.substring(tmp.length() - length);\n}\nout.write(tmpStr.getBytes()); // TODO is it correct to use the default charset here?\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:writeCString(Ljava/lang/String;)V",
                                    "method_body": "private void writeCString(final String str) throws IOException {\nout.write(str.getBytes()); // TODO is it correct to use the default charset here?\nout.write('\\0');\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields() {\nif (extraFields == null) {\nreturn new ZipExtraField[0];\n}\nZipExtraField[] result = new ZipExtraField[extraFields.size()];\nreturn (ZipExtraField[]) extraFields.values().toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:addAsFirstExtraField(Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void addAsFirstExtraField(ZipExtraField ze) {\nLinkedHashMap copy = extraFields;\nextraFields = new LinkedHashMap();\nextraFields.put(ze.getHeaderId(), ze);\nif (copy != null) {\ncopy.remove(ze.getHeaderId());\nextraFields.putAll(copy);\n}\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
                                    "method_body": "public byte[] getLocalFileDataExtra() {\nbyte[] extra = getExtra();\nreturn extra != null ? extra : new byte[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\n// this method has severe consequences on performance. We cannot rely\n// on the super.hashCode() method since super.getName() always return\n// the empty string in the current implemention (there's no setter)\n// so it is basically draining the performance of a hashmap lookup\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public JarArchiveEntry(String name) {\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn super.hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public ZipArchiveOutputStream(OutputStream out) {\nthis.out = out;\nthis.raf = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final int BYTE_MASK = 0xFF;\nprivate static final int SHORT = 2;\nprivate static final int WORD = 4;\nstatic final int BUFFER_SIZE = 512;\n/*\n* Apparently Deflater.setInput gets slowed down a lot on Sun JVMs\n* when it gets handed a really big buffer.  See\n* https://issues.apache.org/bugzilla/show_bug.cgi?id=45396\n*\n* Using a buffer size of 8 kB proved to be a good compromise\n*/\nprivate static final int DEFLATER_BLOCK_SIZE = 8192;\n\n/**\n* Compression method for deflated entries.\n*/\npublic static final int DEFLATED = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* Default compression level for deflated entries.\n*/\npublic static final int DEFAULT_COMPRESSION = Deflater.DEFAULT_COMPRESSION;\n\n/**\n* Compression method for stored entries.\n*/\npublic static final int STORED = java.util.zip.ZipEntry.STORED;\n\n/**\n* default encoding for file names and comment.\n*/\nstatic final String DEFAULT_ENCODING = ZipEncodingHelper.UTF8;\n\n/**\n* General purpose flag, which indicates that filenames are\n* written in utf-8.\n*/\npublic static final int EFS_FLAG = 1 << 11;\n\n/**\n* Current entry.\n*/\nprivate ZipArchiveEntry entry;\n\n/**\n* The file comment.\n*/\nprivate String comment = \"\";\n\n/**\n* Compression level for next entry.\n*/\nprivate int level = DEFAULT_COMPRESSION;\n\n/**\n* Has the compression level changed when compared to the last\n* entry?\n*/\nprivate boolean hasCompressionLevelChanged = false;\n\n/**\n* Default compression method for next entry.\n*/\nprivate int method = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* List of ZipArchiveEntries written so far.\n*/\nprivate final List entries = new LinkedList();\n\n/**\n* CRC instance to avoid parsing DEFLATED data twice.\n*/\nprivate final CRC32 crc = new CRC32();\n\n/**\n* Count the bytes written to out.\n*/\nprivate long written = 0;\n\n/**\n* Data for local header data\n*/\nprivate long dataStart = 0;\n\n/**\n* Offset for CRC entry in the local file header data for the\n* current entry starts here.\n*/\nprivate long localDataStart = 0;\n\n/**\n* Start of central directory.\n*/\nprivate long cdOffset = 0;\n\n/**\n* Length of central directory.\n*/\nprivate long cdLength = 0;\n\n/**\n* Helper, a 0 as ZipShort.\n*/\nprivate static final byte[] ZERO = {0, 0};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif(entry != null) {\nthrow new IOException(\"This archives contains unclosed entries.\");\n}\n\ncdOffset = written;\nfor (Iterator i = entries.iterator(); i.hasNext(); ) {\nwriteCentralFileHeader((ZipArchiveEntry) i.next());\n}\ncdLength = written - cdOffset;\nwriteCentralDirectoryEnd();\noffsets.clear();\nentries.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (entry == null) {\nreturn;\n}\n\nlong realCrc = crc.getValue();\ncrc.reset();\n\nif (entry.getMethod() == DEFLATED) {\ndef.finish();\nwhile (!def.finished()) {\ndeflate();\n}\n\nentry.setSize(ZipUtil.adjustToLong(def.getTotalIn()));\nentry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut()));\nentry.setCrc(realCrc);\n\ndef.reset();\n\nwritten += entry.getCompressedSize();\n} else if (raf == null) {\nif (entry.getCrc() != realCrc) {\nthrow new ZipException(\"bad CRC checksum for entry \"\n+ entry.getName() + \": \"\n+ Long.toHexString(entry.getCrc())\n+ \" instead of \"\n+ Long.toHexString(realCrc));\n}\n\nif (entry.getSize() != written - dataStart) {\nthrow new ZipException(\"bad size for entry \"\n+ entry.getName() + \": \"\n+ entry.getSize()\n+ \" instead of \"\n+ (written - dataStart));\n}\n} else { /* method is STORED and we used RandomAccessFile */\nlong size = written - dataStart;\n\nentry.setSize(size);\nentry.setCompressedSize(size);\nentry.setCrc(realCrc);\n}\n\n// If random access output, write the local file header containing\n// the correct CRC and compressed/uncompressed sizes\nif (raf != null) {\nlong save = raf.getFilePointer();\n\nraf.seek(localDataStart);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\nraf.seek(save);\n}\n\nwriteDataDescriptor(entry);\nentry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\ncloseArchiveEntry();\n\nentry = ((ZipArchiveEntry) archiveEntry);\nentries.add(entry);\n\nif (entry.getMethod() == -1) { // not specified\nentry.setMethod(method);\n}\n\nif (entry.getTime() == -1) { // not specified\nentry.setTime(System.currentTimeMillis());\n}\n\n// Size/CRC not required if RandomAccessFile is used\nif (entry.getMethod() == STORED && raf == null) {\nif (entry.getSize() == -1) {\nthrow new ZipException(\"uncompressed size is required for\"\n+ \" STORED method when not writing to a\"\n+ \" file\");\n}\nif (entry.getCrc() == -1) {\nthrow new ZipException(\"crc checksum is required for STORED\"\n+ \" method when not writing to a file\");\n}\nentry.setCompressedSize(entry.getSize());\n}\n\nif (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\ndef.setLevel(level);\nhasCompressionLevelChanged = false;\n}\nwriteLocalFileHeader(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\nboolean encodable = zipEncoding.canEncode(ze.getName());\n\nfinal ZipEncoding entryEncoding;\n\nif (!encodable && fallbackToUTF8) {\nentryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n} else {\nentryEncoding = zipEncoding;\n}\n\nByteBuffer name = entryEncoding.encode(ze.getName());\n\nif (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n|| !encodable) {\nze.addExtraField(new UnicodePathExtraField(ze.getName(),\nname.array(),\nname.arrayOffset(),\nname.limit()));\n}\n\nString comm = ze.getComment();\nif (comm != null && !\"\".equals(comm)) {\n\nboolean commentEncodable = this.zipEncoding.canEncode(comm);\n\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n|| !commentEncodable) {\nByteBuffer commentB = entryEncoding.encode(comm);\nze.addExtraField(new UnicodeCommentExtraField(comm,\ncommentB.array(),\ncommentB.arrayOffset(),\ncommentB.limit())\n);\n}\n}\n}\n\noffsets.put(ze, ZipLong.getBytes(written));\n\nwriteOut(LFH_SIG);\nwritten += WORD;\n\n//store method in local variable to prevent multiple method calls\nfinal int zipMethod = ze.getMethod();\n\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n!encodable\n&& fallbackToUTF8);\nwritten += WORD;\n\n// compression method\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\n\n// last mod. time and date\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\n\n// CRC\n// compressed length\n// uncompressed length\nlocalDataStart = written;\nif (zipMethod == DEFLATED || raf != null) {\nwriteOut(LZERO);\nwriteOut(LZERO);\nwriteOut(LZERO);\n} else {\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\n}\n// CheckStyle:MagicNumber OFF\nwritten += 12;\n// CheckStyle:MagicNumber ON\n\n// file name length\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\n\n// extra field length\nbyte[] extra = ze.getLocalFileDataExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\n\n// file name\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\n\n// extra field\nwriteOut(extra);\nwritten += extra.length;\n\ndataStart = written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([B)V",
                                    "method_body": "protected final void writeOut(byte[] data) throws IOException {\nwriteOut(data, 0, data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([BII)V",
                                    "method_body": "protected final void writeOut(byte[] data, int offset, int length)\nthrows IOException {\nif (raf != null) {\nraf.write(data, offset, length);\n} else {\nout.write(data, offset, length);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeVersionNeededToExtractAndGeneralPurposeBits(IZ)V",
                                    "method_body": "private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\nzipMethod,\nfinal boolean\nutfFallback)\nthrows IOException {\n\n// CheckStyle:MagicNumber OFF\nint versionNeededToExtract = 10;\nint generalPurposeFlag = (useEFS || utfFallback) ? EFS_FLAG : 0;\nif (zipMethod == DEFLATED && raf == null) {\n// requires version 2 as we are going to store length info\n// in the data descriptor\nversionNeededToExtract =  20;\n// bit3 set to signal, we use a data descriptor\ngeneralPurposeFlag |= 8;\n}\n// CheckStyle:MagicNumber ON\n\n// version needed to extract\nwriteOut(ZipShort.getBytes(versionNeededToExtract));\n// general purpose bit flag\nwriteOut(ZipShort.getBytes(generalPurposeFlag));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n//private static final int BYTE_BIT_SIZE = 8;\nprivate static final int BYTE_MASK = 0xFF;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public JarArchiveOutputStream(final OutputStream out) {\nsuper(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry ze) throws IOException {\nif (!jarMarkerAdded) {\n((ZipArchiveEntry)ze).addAsFirstExtraField(JarMarker.getInstance());\njarMarkerAdded = true;\n}\nsuper.putArchiveEntry(ze);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map simpleEncodings;\n\nstatic {\nsimpleEncodings = new HashMap();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for utf-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h =\n(SimpleEncodingHolder) simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\n// check platform's default encoding\nencoding = System.getProperty(\"file.encoding\");\n}\nreturn UTF8.equalsIgnoreCase(encoding)\n|| \"utf-8\".equalsIgnoreCase(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:canEncode(Ljava/lang/String;)Z",
                                    "method_body": "public boolean canEncode(String name) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(String name) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn ByteBuffer.wrap(name.getBytes());\n} else {\nreturn ByteBuffer.wrap(name.getBytes(this.charset));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<init>(Ljava/lang/String;)V",
                                    "method_body": "private UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
                                    "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS =\nnew UnicodeExtraFieldPolicy(\"always\");\n/**\n* Never create Unicode extra fields.\n*/\npublic static final UnicodeExtraFieldPolicy NEVER =\nnew UnicodeExtraFieldPolicy(\"never\");\n/**\n* Create Unicode extra fields for filenames that cannot be\n* encoded using the specified encoding.\n*/\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nnew UnicodeExtraFieldPolicy(\"not encodeable\");\n\nprivate final String name;\nprivate UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\n\n/** No-arg constructor */\npublic JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getInstance()Lorg/apache/commons/compress/archivers/zip/JarMarker;",
                                    "method_body": "public static JarMarker getInstance() {\nreturn DEFAULT;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn NULL;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn NO_BYTES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes(I)[B",
                                    "method_body": "public static byte[] getBytes(int value) {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n\n/**\n* Static registry of known extra fields.\n*/\nprivate static final Map implementations;\n\nstatic {\nimplementations = new HashMap();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class c) {\ntry {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n} catch (ClassCastException cc) {\nthrow new RuntimeException(c + \" doesn\\'t implement ZipExtraField\");\n} catch (InstantiationException ie) {\nthrow new RuntimeException(c + \" is not a concrete class\");\n} catch (IllegalAccessException ie) {\nthrow new RuntimeException(c + \"\\'s no-arg constructor is not public\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\n}\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n0, result, start + 2, 2);\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate static final int      WORD = 4;\n/**\n* Standard Unix stat(2) file mode.\n*/\nprivate int mode = 0;\n/**\n* User ID.\n*/\nprivate int uid = 0;\n/**\n* Group ID.\n*/\nprivate int gid = 0;\n/**\n* File this entry points to, if it is a symbolic link.\n*\n* <p>empty string - if entry is not a symbolic link.</p>\n*/\nprivate String link = \"\";\n/**\n* Is this an entry for a directory?\n*/\nprivate boolean dirFlag = false;\n\n/**\n* Instance used to calculate checksums.\n*/\nprivate CRC32 crc = new CRC32();\n\n/** Constructor for AsiExtraField. */\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\n\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\n\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n\n/**\n* Convert a Date object to a DOS date/time field.\n* @param time the <code>Date</code> to convert\n* @return the date as a <code>ZipLong</code>\n*/\npublic static ZipLong toDosTime(Date time) {\nreturn new ZipLong(toDosTime(time.getTime()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(J)[B",
                                    "method_body": "public static byte[] toDosTime(long t) {\nCalendar c = Calendar.getInstance();\nc.setTimeInMillis(t);\n\nint year = c.get(Calendar.YEAR);\nif (year < 1980) {\nreturn (byte[]) DOS_TIME_MIN.clone(); // stop callers from changing the array\n}\nint month = c.get(Calendar.MONTH) + 1;\nlong value =  ((year - 1980) << 25)\n|         (month << 21)\n|         (c.get(Calendar.DAY_OF_MONTH) << 16)\n|         (c.get(Calendar.HOUR_OF_DAY) << 11)\n|         (c.get(Calendar.MINUTE) << 5)\n|         (c.get(Calendar.SECOND) >> 1);\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry () {\nthis.magic = MAGIC_POSIX;\nthis.version = VERSION_POSIX;\nthis.name = \"\";\nthis.linkName = \"\";\n\nString user = System.getProperty(\"user.name\", \"\");\n\nif (user.length() > MAX_NAMELEN) {\nuser = user.substring(0, MAX_NAMELEN);\n}\n\nthis.userId = 0;\nthis.groupId = 0;\nthis.userName = user;\nthis.groupName = \"\";\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public TarArchiveEntry(String name) {\nthis();\n\nname = normalizeFileName(name);\nboolean isDir = name.endsWith(\"/\");\n\nthis.devMajor = 0;\nthis.devMinor = 0;\nthis.name = name;\nthis.mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE;\nthis.linkFlag = isDir ? LF_DIR : LF_NORMAL;\nthis.userId = 0;\nthis.groupId = 0;\nthis.size = 0;\nthis.modTime = (new Date()).getTime() / MILLIS_PER_SECOND;\nthis.linkName = \"\";\nthis.userName = \"\";\nthis.groupName = \"\";\nthis.devMajor = 0;\nthis.devMinor = 0;\n\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nif (file != null) {\nreturn file.isDirectory();\n}\n\nif (linkFlag == LF_DIR) {\nreturn true;\n}\n\nif (getName().endsWith(\"/\")) {\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:writeEntryHeader([B)V",
                                    "method_body": "public void writeEntryHeader(byte[] outbuf) {\nint offset = 0;\n\noffset = TarUtils.formatNameBytes(name, outbuf, offset, NAMELEN);\noffset = TarUtils.formatOctalBytes(mode, outbuf, offset, MODELEN);\noffset = TarUtils.formatOctalBytes(userId, outbuf, offset, UIDLEN);\noffset = TarUtils.formatOctalBytes(groupId, outbuf, offset, GIDLEN);\noffset = TarUtils.formatLongOctalBytes(size, outbuf, offset, SIZELEN);\noffset = TarUtils.formatLongOctalBytes(modTime, outbuf, offset, MODTIMELEN);\n\nint csOffset = offset;\n\nfor (int c = 0; c < CHKSUMLEN; ++c) {\noutbuf[offset++] = (byte) ' ';\n}\n\noutbuf[offset++] = linkFlag;\noffset = TarUtils.formatNameBytes(linkName, outbuf, offset, NAMELEN);\noffset = TarUtils.formatNameBytes(magic, outbuf, offset, MAGICLEN);\noffset = TarUtils.formatNameBytes(version, outbuf, offset, VERSIONLEN);\noffset = TarUtils.formatNameBytes(userName, outbuf, offset, UNAMELEN);\noffset = TarUtils.formatNameBytes(groupName, outbuf, offset, GNAMELEN);\noffset = TarUtils.formatOctalBytes(devMajor, outbuf, offset, DEVLEN);\noffset = TarUtils.formatOctalBytes(devMinor, outbuf, offset, DEVLEN);\n\nwhile (offset < outbuf.length) {\noutbuf[offset++] = 0;\n}\n\nlong chk = TarUtils.computeCheckSum(outbuf);\n\nTarUtils.formatCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:normalizeFileName(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String normalizeFileName(String fileName) {\nString osname = System.getProperty(\"os.name\").toLowerCase(Locale.US);\n\nif (osname != null) {\n\n// Strip off drive letters!\n// REVIEW Would a better check be \"(File.separator == '\\')\"?\n\nif (osname.startsWith(\"windows\")) {\nif (fileName.length() > 2) {\nchar ch1 = fileName.charAt(0);\nchar ch2 = fileName.charAt(1);\n\nif (ch2 == ':'\n&& ((ch1 >= 'a' && ch1 <= 'z')\n|| (ch1 >= 'A' && ch1 <= 'Z'))) {\nfileName = fileName.substring(2);\n}\n}\n} else if (osname.indexOf(\"netware\") > -1) {\nint colon = fileName.indexOf(':');\nif (colon != -1) {\nfileName = fileName.substring(colon + 1);\n}\n}\n}\n\nfileName = fileName.replace(File.separatorChar, '/');\n\n// No absolute pathnames\n// Windows (and Posix?) paths can start with \"\\\\NetworkDrive\\\",\n// so we loop on starting /'s.\nwhile (fileName.startsWith(\"/\")) {\nfileName = fileName.substring(1);\n}\nreturn fileName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public TarArchiveOutputStream(OutputStream os) {\nthis(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;II)V",
                                    "method_body": "public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) {\nout = os;\n\nthis.buffer = new TarBuffer(os, blockSize, recordSize);\nthis.assemLen = 0;\nthis.assemBuf = new byte[recordSize];\nthis.recordBuf = new byte[recordSize];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nwriteEOFRecord();\nwriteEOFRecord();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\nTarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\nif (entry.getName().length() >= TarConstants.NAMELEN) {\n\nif (longFileMode == LONGFILE_GNU) {\n// create a TarEntry for the LongLink, the contents\n// of which are the entry's name\nTarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\nTarConstants.LF_GNUTYPE_LONGNAME);\n\nfinal byte[] nameBytes = entry.getName().getBytes(); // TODO is it correct to use the default charset here?\nlongLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL\nputArchiveEntry(longLinkEntry);\nwrite(nameBytes);\nwrite(0); // NUL terminator\ncloseArchiveEntry();\n} else if (longFileMode != LONGFILE_TRUNCATE) {\nthrow new RuntimeException(\"file name '\" + entry.getName()\n+ \"' is too long ( > \"\n+ TarConstants.NAMELEN + \" bytes)\");\n}\n}\n\nentry.writeEntryHeader(recordBuf);\nbuffer.writeRecord(recordBuf);\n\ncurrBytes = 0;\n\nif (entry.isDirectory()) {\ncurrSize = 0;\n} else {\ncurrSize = entry.getSize();\n}\ncurrName = entry.getName();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:writeEOFRecord()V",
                                    "method_body": "private void writeEOFRecord() throws IOException {\nfor (int i = 0; i < recordBuf.length; ++i) {\nrecordBuf[i] = 0;\n}\n\nbuffer.writeRecord(recordBuf);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/OutputStream;II)V",
                                    "method_body": "public TarBuffer(OutputStream outStream, int blockSize, int recordSize) {\nthis.inStream = null;\nthis.outStream = outStream;\n\nthis.initialize(blockSize, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:initialize(II)V",
                                    "method_body": "private void initialize(int blockSize, int recordSize) {\nthis.blockSize = blockSize;\nthis.recordSize = recordSize;\nthis.recsPerBlock = (this.blockSize / this.recordSize);\nthis.blockBuffer = new byte[this.blockSize];\n\nif (this.inStream != null) {\nthis.currBlkIdx = -1;\nthis.currRecIdx = this.recsPerBlock;\n} else {\nthis.currBlkIdx = 0;\nthis.currRecIdx = 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:writeRecord([B)V",
                                    "method_body": "public void writeRecord(byte[] record) throws IOException {\nif (outStream == null) {\nif (inStream == null){\nthrow new IOException(\"Output buffer is closed\");\n}\nthrow new IOException(\"writing to an input buffer\");\n}\n\nif (record.length != recordSize) {\nthrow new IOException(\"record to write has length '\"\n+ record.length\n+ \"' which is not the record size of '\"\n+ recordSize + \"'\");\n}\n\nif (currRecIdx >= recsPerBlock) {\nwriteBlock();\n}\n\nSystem.arraycopy(record, 0, blockBuffer,\n(currRecIdx * recordSize),\nrecordSize);\n\ncurrRecIdx++;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatNameBytes(Ljava/lang/String;[BII)I",
                                    "method_body": "public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {\nint i;\n\n// copy until end of input or output is reached.\nfor (i = 0; i < length && i < name.length(); ++i) {\nbuf[offset + i] = (byte) name.charAt(i);\n}\n\n// Pad any remaining output bytes with NUL\nfor (; i < length; ++i) {\nbuf[offset + i] = 0;\n}\n\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatUnsignedOctalString(J[BII)V",
                                    "method_body": "public static void formatUnsignedOctalString(final long value, byte[] buffer,\nfinal int offset, final int length) {\nint remaining = length;\nremaining--;\nif (value == 0) {\nbuffer[offset + remaining--] = (byte) '0';\n} else {\nlong val = value;\nfor (; remaining >= 0 && val != 0; --remaining) {\n// CheckStyle:MagicNumber OFF\nbuffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));\nval = val >>> 3;\n// CheckStyle:MagicNumber ON\n}\nif (val != 0){\nthrow new IllegalArgumentException\n(value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length);\n}\n}\n\nfor (; remaining >= 0; --remaining) { // leading zeros\nbuffer[offset + remaining] = (byte) '0';\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatOctalBytes(J[BII)I",
                                    "method_body": "public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\nint idx=length-2; // For space and trailing null\nformatUnsignedOctalString(value, buf, offset, idx);\n\nbuf[offset + idx++] = (byte) ' '; // Trailing space\nbuf[offset + idx]   = 0; // Trailing null\n\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatLongOctalBytes(J[BII)I",
                                    "method_body": "public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\nint idx=length-1; // For space\n\nformatUnsignedOctalString(value, buf, offset, idx);\nbuf[offset + idx] = (byte) ' '; // Trailing space\n\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatCheckSumOctalBytes(J[BII)I",
                                    "method_body": "public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\nint idx=length-2; // for NUL and space\nformatUnsignedOctalString(value, buf, offset, idx);\n\nbuf[offset + idx++]   = 0; // Trailing null\nbuf[offset + idx]     = (byte) ' '; // Trailing space\n\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:computeCheckSum([B)J",
                                    "method_body": "public static long computeCheckSum(final byte[] buf) {\nlong sum = 0;\n\nfor (int i = 0; i < buf.length; ++i) {\nsum += BYTE_MASK & buf[i];\n}\n\nreturn sum;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 4,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testASCIIFileRoundtripImplicitUnicodeExtra",
                            "test_body": "78: public void testASCIIFileRoundtripImplicitUnicodeExtra()\n79: throws IOException {\n80: testFileRoundtrip(US_ASCII, false, false);\n81: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getInternalAttributes()I",
                                    "method_body": "public int getInternalAttributes() {\nreturn internalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExternalAttributes()J",
                                    "method_body": "public long getExternalAttributes() {\nreturn externalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields() {\nif (extraFields == null) {\nreturn new ZipExtraField[0];\n}\nZipExtraField[] result = new ZipExtraField[extraFields.size()];\nreturn (ZipExtraField[]) extraFields.values().toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
                                    "method_body": "public byte[] getLocalFileDataExtra() {\nbyte[] extra = getExtra();\nreturn extra != null ? extra : new byte[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getCentralDirectoryExtra()[B",
                                    "method_body": "public byte[] getCentralDirectoryExtra() {\nreturn ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\n// this method has severe consequences on performance. We cannot rely\n// on the super.hashCode() method since super.getName() always return\n// the empty string in the current implemention (there's no setter)\n// so it is basically draining the performance of a hashmap lookup\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final int BYTE_MASK = 0xFF;\nprivate static final int SHORT = 2;\nprivate static final int WORD = 4;\nstatic final int BUFFER_SIZE = 512;\n/*\n* Apparently Deflater.setInput gets slowed down a lot on Sun JVMs\n* when it gets handed a really big buffer.  See\n* https://issues.apache.org/bugzilla/show_bug.cgi?id=45396\n*\n* Using a buffer size of 8 kB proved to be a good compromise\n*/\nprivate static final int DEFLATER_BLOCK_SIZE = 8192;\n\n/**\n* Compression method for deflated entries.\n*/\npublic static final int DEFLATED = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* Default compression level for deflated entries.\n*/\npublic static final int DEFAULT_COMPRESSION = Deflater.DEFAULT_COMPRESSION;\n\n/**\n* Compression method for stored entries.\n*/\npublic static final int STORED = java.util.zip.ZipEntry.STORED;\n\n/**\n* default encoding for file names and comment.\n*/\nstatic final String DEFAULT_ENCODING = ZipEncodingHelper.UTF8;\n\n/**\n* General purpose flag, which indicates that filenames are\n* written in utf-8.\n*/\npublic static final int EFS_FLAG = 1 << 11;\n\n/**\n* Current entry.\n*/\nprivate ZipArchiveEntry entry;\n\n/**\n* The file comment.\n*/\nprivate String comment = \"\";\n\n/**\n* Compression level for next entry.\n*/\nprivate int level = DEFAULT_COMPRESSION;\n\n/**\n* Has the compression level changed when compared to the last\n* entry?\n*/\nprivate boolean hasCompressionLevelChanged = false;\n\n/**\n* Default compression method for next entry.\n*/\nprivate int method = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* List of ZipArchiveEntries written so far.\n*/\nprivate final List entries = new LinkedList();\n\n/**\n* CRC instance to avoid parsing DEFLATED data twice.\n*/\nprivate final CRC32 crc = new CRC32();\n\n/**\n* Count the bytes written to out.\n*/\nprivate long written = 0;\n\n/**\n* Data for local header data\n*/\nprivate long dataStart = 0;\n\n/**\n* Offset for CRC entry in the local file header data for the\n* current entry starts here.\n*/\nprivate long localDataStart = 0;\n\n/**\n* Start of central directory.\n*/\nprivate long cdOffset = 0;\n\n/**\n* Length of central directory.\n*/\nprivate long cdLength = 0;\n\n/**\n* Helper, a 0 as ZipShort.\n*/\nprivate static final byte[] ZERO = {0, 0};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif(entry != null) {\nthrow new IOException(\"This archives contains unclosed entries.\");\n}\n\ncdOffset = written;\nfor (Iterator i = entries.iterator(); i.hasNext(); ) {\nwriteCentralFileHeader((ZipArchiveEntry) i.next());\n}\ncdLength = written - cdOffset;\nwriteCentralDirectoryEnd();\noffsets.clear();\nentries.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (entry == null) {\nreturn;\n}\n\nlong realCrc = crc.getValue();\ncrc.reset();\n\nif (entry.getMethod() == DEFLATED) {\ndef.finish();\nwhile (!def.finished()) {\ndeflate();\n}\n\nentry.setSize(ZipUtil.adjustToLong(def.getTotalIn()));\nentry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut()));\nentry.setCrc(realCrc);\n\ndef.reset();\n\nwritten += entry.getCompressedSize();\n} else if (raf == null) {\nif (entry.getCrc() != realCrc) {\nthrow new ZipException(\"bad CRC checksum for entry \"\n+ entry.getName() + \": \"\n+ Long.toHexString(entry.getCrc())\n+ \" instead of \"\n+ Long.toHexString(realCrc));\n}\n\nif (entry.getSize() != written - dataStart) {\nthrow new ZipException(\"bad size for entry \"\n+ entry.getName() + \": \"\n+ entry.getSize()\n+ \" instead of \"\n+ (written - dataStart));\n}\n} else { /* method is STORED and we used RandomAccessFile */\nlong size = written - dataStart;\n\nentry.setSize(size);\nentry.setCompressedSize(size);\nentry.setCrc(realCrc);\n}\n\n// If random access output, write the local file header containing\n// the correct CRC and compressed/uncompressed sizes\nif (raf != null) {\nlong save = raf.getFilePointer();\n\nraf.seek(localDataStart);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\nraf.seek(save);\n}\n\nwriteDataDescriptor(entry);\nentry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\ncloseArchiveEntry();\n\nentry = ((ZipArchiveEntry) archiveEntry);\nentries.add(entry);\n\nif (entry.getMethod() == -1) { // not specified\nentry.setMethod(method);\n}\n\nif (entry.getTime() == -1) { // not specified\nentry.setTime(System.currentTimeMillis());\n}\n\n// Size/CRC not required if RandomAccessFile is used\nif (entry.getMethod() == STORED && raf == null) {\nif (entry.getSize() == -1) {\nthrow new ZipException(\"uncompressed size is required for\"\n+ \" STORED method when not writing to a\"\n+ \" file\");\n}\nif (entry.getCrc() == -1) {\nthrow new ZipException(\"crc checksum is required for STORED\"\n+ \" method when not writing to a file\");\n}\nentry.setCompressedSize(entry.getSize());\n}\n\nif (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\ndef.setLevel(level);\nhasCompressionLevelChanged = false;\n}\nwriteLocalFileHeader(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nfinish();\nif (raf != null) {\nraf.close();\n}\nif (out != null) {\nout.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflate()V",
                                    "method_body": "protected final void deflate() throws IOException {\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\nboolean encodable = zipEncoding.canEncode(ze.getName());\n\nfinal ZipEncoding entryEncoding;\n\nif (!encodable && fallbackToUTF8) {\nentryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n} else {\nentryEncoding = zipEncoding;\n}\n\nByteBuffer name = entryEncoding.encode(ze.getName());\n\nif (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n|| !encodable) {\nze.addExtraField(new UnicodePathExtraField(ze.getName(),\nname.array(),\nname.arrayOffset(),\nname.limit()));\n}\n\nString comm = ze.getComment();\nif (comm != null && !\"\".equals(comm)) {\n\nboolean commentEncodable = this.zipEncoding.canEncode(comm);\n\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n|| !commentEncodable) {\nByteBuffer commentB = entryEncoding.encode(comm);\nze.addExtraField(new UnicodeCommentExtraField(comm,\ncommentB.array(),\ncommentB.arrayOffset(),\ncommentB.limit())\n);\n}\n}\n}\n\noffsets.put(ze, ZipLong.getBytes(written));\n\nwriteOut(LFH_SIG);\nwritten += WORD;\n\n//store method in local variable to prevent multiple method calls\nfinal int zipMethod = ze.getMethod();\n\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n!encodable\n&& fallbackToUTF8);\nwritten += WORD;\n\n// compression method\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\n\n// last mod. time and date\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\n\n// CRC\n// compressed length\n// uncompressed length\nlocalDataStart = written;\nif (zipMethod == DEFLATED || raf != null) {\nwriteOut(LZERO);\nwriteOut(LZERO);\nwriteOut(LZERO);\n} else {\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\n}\n// CheckStyle:MagicNumber OFF\nwritten += 12;\n// CheckStyle:MagicNumber ON\n\n// file name length\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\n\n// extra field length\nbyte[] extra = ze.getLocalFileDataExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\n\n// file name\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\n\n// extra field\nwriteOut(extra);\nwritten += extra.length;\n\ndataStart = written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeDataDescriptor(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeDataDescriptor(ZipArchiveEntry ze) throws IOException {\nif (ze.getMethod() != DEFLATED || raf != null) {\nreturn;\n}\nwriteOut(DD_SIG);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\n// CheckStyle:MagicNumber OFF\nwritten += 16;\n// CheckStyle:MagicNumber ON\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\nwriteOut(CFH_SIG);\nwritten += WORD;\n\n// version made by\n// CheckStyle:MagicNumber OFF\nwriteOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\nwritten += SHORT;\n\nfinal int zipMethod = ze.getMethod();\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n!encodable\n&& fallbackToUTF8);\nwritten += WORD;\n\n// compression method\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\n\n// last mod. time and date\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\n\n// CRC\n// compressed length\n// uncompressed length\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getCompressedSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\n// CheckStyle:MagicNumber OFF\nwritten += 12;\n// CheckStyle:MagicNumber ON\n\n// file name length\nfinal ZipEncoding entryEncoding;\n\nif (!encodable && fallbackToUTF8) {\nentryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n} else {\nentryEncoding = zipEncoding;\n}\n\nByteBuffer name = entryEncoding.encode(ze.getName());\n\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\n\n// extra field length\nbyte[] extra = ze.getCentralDirectoryExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\n\n// file comment length\nString comm = ze.getComment();\nif (comm == null) {\ncomm = \"\";\n}\n\nByteBuffer commentB = entryEncoding.encode(comm);\n\nwriteOut(ZipShort.getBytes(commentB.limit()));\nwritten += SHORT;\n\n// disk number start\nwriteOut(ZERO);\nwritten += SHORT;\n\n// internal file attributes\nwriteOut(ZipShort.getBytes(ze.getInternalAttributes()));\nwritten += SHORT;\n\n// external file attributes\nwriteOut(ZipLong.getBytes(ze.getExternalAttributes()));\nwritten += WORD;\n\n// relative offset of LFH\nwriteOut((byte[]) offsets.get(ze));\nwritten += WORD;\n\n// file name\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\n\n// extra field\nwriteOut(extra);\nwritten += extra.length;\n\n// file comment\nwriteOut(commentB.array(), commentB.arrayOffset(), commentB.limit());\nwritten += commentB.limit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryEnd()V",
                                    "method_body": "protected void writeCentralDirectoryEnd() throws IOException {\nwriteOut(EOCD_SIG);\n\n// disk numbers\nwriteOut(ZERO);\nwriteOut(ZERO);\n\n// number of entries\nbyte[] num = ZipShort.getBytes(entries.size());\nwriteOut(num);\nwriteOut(num);\n\n// length and location of CD\nwriteOut(ZipLong.getBytes(cdLength));\nwriteOut(ZipLong.getBytes(cdOffset));\n\n// ZIP file comment\nByteBuffer data = this.zipEncoding.encode(comment);\nwriteOut(ZipShort.getBytes(data.limit()));\nwriteOut(data.array(), data.arrayOffset(), data.limit());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([B)V",
                                    "method_body": "protected final void writeOut(byte[] data) throws IOException {\nwriteOut(data, 0, data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([BII)V",
                                    "method_body": "protected final void writeOut(byte[] data, int offset, int length)\nthrows IOException {\nif (raf != null) {\nraf.write(data, offset, length);\n} else {\nout.write(data, offset, length);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeVersionNeededToExtractAndGeneralPurposeBits(IZ)V",
                                    "method_body": "private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\nzipMethod,\nfinal boolean\nutfFallback)\nthrows IOException {\n\n// CheckStyle:MagicNumber OFF\nint versionNeededToExtract = 10;\nint generalPurposeFlag = (useEFS || utfFallback) ? EFS_FLAG : 0;\nif (zipMethod == DEFLATED && raf == null) {\n// requires version 2 as we are going to store length info\n// in the data descriptor\nversionNeededToExtract =  20;\n// bit3 set to signal, we use a data descriptor\ngeneralPurposeFlag |= 8;\n}\n// CheckStyle:MagicNumber ON\n\n// version needed to extract\nwriteOut(ZipShort.getBytes(versionNeededToExtract));\n// general purpose bit flag\nwriteOut(ZipShort.getBytes(generalPurposeFlag));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n//private static final int BYTE_BIT_SIZE = 8;\nprivate static final int BYTE_MASK = 0xFF;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map simpleEncodings;\n\nstatic {\nsimpleEncodings = new HashMap();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for utf-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h =\n(SimpleEncodingHolder) simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\n// check platform's default encoding\nencoding = System.getProperty(\"file.encoding\");\n}\nreturn UTF8.equalsIgnoreCase(encoding)\n|| \"utf-8\".equalsIgnoreCase(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<init>(Ljava/lang/String;)V",
                                    "method_body": "private UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
                                    "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS =\nnew UnicodeExtraFieldPolicy(\"always\");\n/**\n* Never create Unicode extra fields.\n*/\npublic static final UnicodeExtraFieldPolicy NEVER =\nnew UnicodeExtraFieldPolicy(\"never\");\n/**\n* Create Unicode extra fields for filenames that cannot be\n* encoded using the specified encoding.\n*/\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nnew UnicodeExtraFieldPolicy(\"not encodeable\");\n\nprivate final String name;\nprivate UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\n\n/** No-arg constructor */\npublic JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes(I)[B",
                                    "method_body": "public static byte[] getBytes(int value) {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n\n/**\n* Static registry of known extra fields.\n*/\nprivate static final Map implementations;\n\nstatic {\nimplementations = new HashMap();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class c) {\ntry {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n} catch (ClassCastException cc) {\nthrow new RuntimeException(c + \" doesn\\'t implement ZipExtraField\");\n} catch (InstantiationException ie) {\nthrow new RuntimeException(c + \" is not a concrete class\");\n} catch (IllegalAccessException ie) {\nthrow new RuntimeException(c + \"\\'s no-arg constructor is not public\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\n}\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n0, result, start + 2, 2);\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeCentralDirectoryData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getCentralDirectoryLength().getValue();\n}\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n0, result, start + 2, 2);\nbyte[] local = data[i].getCentralDirectoryData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate static final int      WORD = 4;\n/**\n* Standard Unix stat(2) file mode.\n*/\nprivate int mode = 0;\n/**\n* User ID.\n*/\nprivate int uid = 0;\n/**\n* Group ID.\n*/\nprivate int gid = 0;\n/**\n* File this entry points to, if it is a symbolic link.\n*\n* <p>empty string - if entry is not a symbolic link.</p>\n*/\nprivate String link = \"\";\n/**\n* Is this an entry for a directory?\n*/\nprivate boolean dirFlag = false;\n\n/**\n* Instance used to calculate checksums.\n*/\nprivate CRC32 crc = new CRC32();\n\n/** Constructor for AsiExtraField. */\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\n\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\n\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n\n/**\n* Convert a Date object to a DOS date/time field.\n* @param time the <code>Date</code> to convert\n* @return the date as a <code>ZipLong</code>\n*/\npublic static ZipLong toDosTime(Date time) {\nreturn new ZipLong(toDosTime(time.getTime()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(J)[B",
                                    "method_body": "public static byte[] toDosTime(long t) {\nCalendar c = Calendar.getInstance();\nc.setTimeInMillis(t);\n\nint year = c.get(Calendar.YEAR);\nif (year < 1980) {\nreturn (byte[]) DOS_TIME_MIN.clone(); // stop callers from changing the array\n}\nint month = c.get(Calendar.MONTH) + 1;\nlong value =  ((year - 1980) << 25)\n|         (month << 21)\n|         (c.get(Calendar.DAY_OF_MONTH) << 16)\n|         (c.get(Calendar.HOUR_OF_DAY) << 11)\n|         (c.get(Calendar.MINUTE) << 5)\n|         (c.get(Calendar.SECOND) >> 1);\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:adjustToLong(I)J",
                                    "method_body": "public static long adjustToLong(int i) {\nif (i < 0) {\nreturn 2 * ((long) Integer.MAX_VALUE) + 2 + i;\n} else {\nreturn i;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\nthrows IOException {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = new RandomAccessFile(f, \"r\");\nboolean success = false;\ntry {\nMap entriesWithoutEFS = populateFromCentralDirectory();\nresolveLocalFileHeaderData(entriesWithoutEFS);\nsuccess = true;\n} finally {\nif (!success) {\ntry {\narchive.close();\n} catch (IOException e2) {\n// swallow, throw the original exception instead\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
                                    "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\ntry {\nzipfile.close();\n} catch (IOException e) {\n//ignore\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map populateFromCentralDirectory()\nthrows IOException {\nHashMap noEFS = new HashMap();\n\npositionAtCentralDirectory();\n\nbyte[] cfh = new byte[CFH_LEN];\n\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nfinal long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\nif (sig != cfhSig && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n+ \" corrupt archive.\");\n}\nwhile (sig == cfhSig) {\narchive.readFully(cfh);\nint off = 0;\nZipArchiveEntry ze = new ZipArchiveEntry();\n\nint versionMadeBy = ZipShort.getValue(cfh, off);\noff += SHORT;\nze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\noff += SHORT; // skip version info\n\nfinal int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS =\n(generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0;\nfinal ZipEncoding entryEncoding =\nhasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\noff += SHORT;\n\nze.setMethod(ZipShort.getValue(cfh, off));\noff += SHORT;\n\n// FIXME this is actually not very cpu cycles friendly as we are converting from\n// dos to java while the underlying Sun implementation will convert\n// from java to dos time for internal storage...\nlong time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\nze.setTime(time);\noff += WORD;\n\nze.setCrc(ZipLong.getValue(cfh, off));\noff += WORD;\n\nze.setCompressedSize(ZipLong.getValue(cfh, off));\noff += WORD;\n\nze.setSize(ZipLong.getValue(cfh, off));\noff += WORD;\n\nint fileNameLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nint extraLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nint commentLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\noff += SHORT; // disk number\n\nze.setInternalAttributes(ZipShort.getValue(cfh, off));\noff += SHORT;\n\nze.setExternalAttributes(ZipLong.getValue(cfh, off));\noff += WORD;\n\nbyte[] fileName = new byte[fileNameLen];\narchive.readFully(fileName);\nze.setName(entryEncoding.decode(fileName));\n\n// LFH offset,\nOffsetEntry offset = new OffsetEntry();\noffset.headerOffset = ZipLong.getValue(cfh, off);\n// data offset will be filled later\nentries.put(ze, offset);\n\nnameMap.put(ze.getName(), ze);\n\nbyte[] cdExtraData = new byte[extraLen];\narchive.readFully(cdExtraData);\nze.setCentralDirectoryExtra(cdExtraData);\n\nbyte[] comment = new byte[commentLen];\narchive.readFully(comment);\nze.setComment(entryEncoding.decode(comment));\n\narchive.readFully(signatureBytes);\nsig = ZipLong.getValue(signatureBytes);\n\nif (!hasEFS && useUnicodeExtraFields) {\nnoEFS.put(ze, new NameAndComment(fileName, comment));\n}\n}\nreturn noEFS;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nthrows IOException {\nboolean found = false;\nlong off = archive.length() - MIN_EOCD_SIZE;\nlong stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE);\nif (off >= 0) {\narchive.seek(off);\nbyte[] sig = ZipArchiveOutputStream.EOCD_SIG;\nint curr = archive.read();\nwhile (off >= stopSearching && curr != -1) {\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\n}\n}\n}\n}\narchive.seek(--off);\ncurr = archive.read();\n}\n}\nif (!found) {\nthrow new ZipException(\"archive is not a ZIP archive\");\n}\narchive.seek(off + CFD_LOCATOR_OFFSET);\nbyte[] cfdOffset = new byte[WORD];\narchive.readFully(cfdOffset);\narchive.seek(ZipLong.getValue(cfdOffset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:startsWithLocalFileHeader()Z",
                                    "method_body": "private boolean startsWithLocalFileHeader() throws IOException {\narchive.seek(0);\nfinal byte[] start = new byte[WORD];\narchive.readFully(start);\nfor (int i = 0; i < start.length; i++) {\nif (start[i] != ZipArchiveOutputStream.LFH_SIG[i]) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipArchiveOutputStream(File file) throws IOException {\nOutputStream o = null;\nRandomAccessFile _raf = null;\ntry {\n_raf = new RandomAccessFile(file, \"rw\");\n_raf.setLength(0);\n} catch (IOException e) {\nif (_raf != null) {\ntry {\n_raf.close();\n} catch (IOException inner) {\n// ignore\n}\n_raf = null;\n}\no = new FileOutputStream(file);\n}\nout = o;\nraf = _raf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setEncoding(Ljava/lang/String;)V",
                                    "method_body": "public void setEncoding(final String encoding) {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nuseEFS &= ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setUseLanguageEncodingFlag(Z)V",
                                    "method_body": "public void setUseLanguageEncodingFlag(boolean b) {\nuseEFS = b && ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setCreateUnicodeExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveOutputStream$UnicodeExtraFieldPolicy;)V",
                                    "method_body": "public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b) {\ncreateUnicodeExtraFields = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int offset, int length) throws IOException {\nif (entry.getMethod() == DEFLATED) {\nif (length > 0) {\nif (!def.finished()) {\nif (length <= DEFLATER_BLOCK_SIZE) {\ndef.setInput(b, offset, length);\ndeflateUntilInputIsNeeded();\n} else {\nfinal int fullblocks = length / DEFLATER_BLOCK_SIZE;\nfor (int i = 0; i < fullblocks; i++) {\ndef.setInput(b, offset + i * DEFLATER_BLOCK_SIZE,\nDEFLATER_BLOCK_SIZE);\ndeflateUntilInputIsNeeded();\n}\nfinal int done = fullblocks * DEFLATER_BLOCK_SIZE;\nif (done < length) {\ndef.setInput(b, offset + done, length - done);\ndeflateUntilInputIsNeeded();\n}\n}\n}\n}\n} else {\nwriteOut(b, offset, length);\nwritten += length;\n}\ncrc.update(b, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflateUntilInputIsNeeded()V",
                                    "method_body": "private void deflateUntilInputIsNeeded() throws IOException {\nwhile (!def.needsInput()) {\ndeflate();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:addExtraField(Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void addExtraField(ZipExtraField ze) {\nif (extraFields == null) {\nextraFields = new LinkedHashMap();\n}\nextraFields.put(ze.getHeaderId(), ze);\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:appendSurrogate(Ljava/nio/ByteBuffer;C)V",
                                    "method_body": "static void appendSurrogate(ByteBuffer bb, char c) {\n\nbb.put((byte) '%');\nbb.put((byte) 'U');\n\nbb.put(HEX_DIGITS[(c >> 12)&0x0f]);\nbb.put(HEX_DIGITS[(c >> 8)&0x0f]);\nbb.put(HEX_DIGITS[(c >> 4)&0x0f]);\nbb.put(HEX_DIGITS[c & 0x0f]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "protected AbstractUnicodeExtraField(String text, byte[] bytes, int off,\nint len) {\nCRC32 crc32 = new CRC32();\ncrc32.update(bytes, off, len);\nnameCRC32 = crc32.getValue();\n\ntry {\nunicodeName = text.getBytes(\"UTF-8\");\n} catch (UnsupportedEncodingException e) {\nthrow new RuntimeException(\"FATAL: UTF-8 encoding not supported.\",\ne);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:assembleData()V",
                                    "method_body": "private void assembleData() {\nif (unicodeName == null) {\nreturn;\n}\n\ndata = new byte[5 + unicodeName.length];\n// version 1\ndata[0] = 0x01;\nSystem.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4);\nSystem.arraycopy(unicodeName, 0, data, 5, unicodeName.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryData()[B",
                                    "method_body": "public byte[] getCentralDirectoryData() {\nif (data == null) {\nthis.assembleData();\n}\nreturn data;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getCentralDirectoryLength() {\nif (data == null) {\nassembleData();\n}\nreturn new ZipShort(data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn getCentralDirectoryData();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn getCentralDirectoryLength();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "public UnicodePathExtraField(String text, byte[] bytes, int off, int len) {\nsuper(text, bytes, off, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:growBuffer(Ljava/nio/ByteBuffer;I)Ljava/nio/ByteBuffer;",
                                    "method_body": "static ByteBuffer growBuffer(ByteBuffer b, int newCapacity) {\nb.limit(b.position());\nb.rewind();\n\nint c2 = b.capacity() * 2;\nByteBuffer on = ByteBuffer.allocate(c2 < newCapacity ? newCapacity : c2);\n\non.put(b);\nreturn on;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:<init>(Ljava/nio/charset/Charset;)V",
                                    "method_body": "public NioZipEncoding(Charset charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:canEncode(Ljava/lang/String;)Z",
                                    "method_body": "public boolean canEncode(String name) {\nCharsetEncoder enc = this.charset.newEncoder();\nenc.onMalformedInput(CodingErrorAction.REPORT);\nenc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\nreturn enc.canEncode(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(String name) {\nCharsetEncoder enc = this.charset.newEncoder();\n\nenc.onMalformedInput(CodingErrorAction.REPORT);\nenc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\nCharBuffer cb = CharBuffer.wrap(name);\nByteBuffer out = ByteBuffer.allocate(name.length()\n+ (name.length() + 1) / 2);\n\nwhile (cb.remaining() > 0) {\nCoderResult res = enc.encode(cb, out,true);\n\nif (res.isUnmappable() || res.isMalformed()) {\n\n// write the unmappable characters in utf-16\n// pseudo-URL encoding style to ByteBuffer.\nif (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, out.position()\n+ res.length() * 6);\n}\n\nfor (int i=0; i<res.length(); ++i) {\nZipEncodingHelper.appendSurrogate(out,cb.get());\n}\n\n} else if (res.isOverflow()) {\n\nout = ZipEncodingHelper.growBuffer(out, 0);\n\n} else if (res.isUnderflow()) {\n\nenc.flush(out);\nbreak;\n\n}\n}\n\nout.limit(out.position());\nout.rewind();\nreturn out;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.jar.JarArchiveOutputStreamTest.testJarMarker",
                            "test_body": "33: public void testJarMarker() throws IOException {\n34: File testArchive = File.createTempFile(\"jar-aostest\", \".jar\");\n35: JarArchiveOutputStream out = null;\n36: ZipFile zf = null;\n37: try {\n38: 39: out = new JarArchiveOutputStream(new FileOutputStream(testArchive));\n40: out.putArchiveEntry(new ZipArchiveEntry(\"foo/\"));\n41: out.closeArchiveEntry();\n42: out.putArchiveEntry(new ZipArchiveEntry(\"bar/\"));\n43: out.closeArchiveEntry();\n44: out.finish();\n45: out.close();\n46: out = null;\n47: 48: zf = new ZipFile(testArchive);\n49: ZipArchiveEntry ze = zf.getEntry(\"foo/\");\n50: assertNotNull(ze);\n51: ZipExtraField[] fes = ze.getExtraFields();\n52: assertEquals(1, fes.length);\n53: assertTrue(fes[0] instanceof JarMarker);\n54: 55: ze = zf.getEntry(\"bar/\");\n56: assertNotNull(ze);\n57: fes = ze.getExtraFields();\n58: assertEquals(0, fes.length);\n59: } finally {\n60: if (out != null) {\n61: try {\n62: out.close();\n63: } catch (IOException e) { /* swallow */ }\n64: }\n65: ZipFile.closeQuietly(zf);\n66: if (testArchive.exists()) {\n67: testArchive.delete();\n68: }\n69: }\n70: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getInternalAttributes()I",
                                    "method_body": "public int getInternalAttributes() {\nreturn internalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExternalAttributes()J",
                                    "method_body": "public long getExternalAttributes() {\nreturn externalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields() {\nif (extraFields == null) {\nreturn new ZipExtraField[0];\n}\nZipExtraField[] result = new ZipExtraField[extraFields.size()];\nreturn (ZipExtraField[]) extraFields.values().toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:addAsFirstExtraField(Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void addAsFirstExtraField(ZipExtraField ze) {\nLinkedHashMap copy = extraFields;\nextraFields = new LinkedHashMap();\nextraFields.put(ze.getHeaderId(), ze);\nif (copy != null) {\ncopy.remove(ze.getHeaderId());\nextraFields.putAll(copy);\n}\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
                                    "method_body": "public byte[] getLocalFileDataExtra() {\nbyte[] extra = getExtra();\nreturn extra != null ? extra : new byte[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getCentralDirectoryExtra()[B",
                                    "method_body": "public byte[] getCentralDirectoryExtra() {\nreturn ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\n// this method has severe consequences on performance. We cannot rely\n// on the super.hashCode() method since super.getName() always return\n// the empty string in the current implemention (there's no setter)\n// so it is basically draining the performance of a hashmap lookup\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public ZipArchiveOutputStream(OutputStream out) {\nthis.out = out;\nthis.raf = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final int BYTE_MASK = 0xFF;\nprivate static final int SHORT = 2;\nprivate static final int WORD = 4;\nstatic final int BUFFER_SIZE = 512;\n/*\n* Apparently Deflater.setInput gets slowed down a lot on Sun JVMs\n* when it gets handed a really big buffer.  See\n* https://issues.apache.org/bugzilla/show_bug.cgi?id=45396\n*\n* Using a buffer size of 8 kB proved to be a good compromise\n*/\nprivate static final int DEFLATER_BLOCK_SIZE = 8192;\n\n/**\n* Compression method for deflated entries.\n*/\npublic static final int DEFLATED = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* Default compression level for deflated entries.\n*/\npublic static final int DEFAULT_COMPRESSION = Deflater.DEFAULT_COMPRESSION;\n\n/**\n* Compression method for stored entries.\n*/\npublic static final int STORED = java.util.zip.ZipEntry.STORED;\n\n/**\n* default encoding for file names and comment.\n*/\nstatic final String DEFAULT_ENCODING = ZipEncodingHelper.UTF8;\n\n/**\n* General purpose flag, which indicates that filenames are\n* written in utf-8.\n*/\npublic static final int EFS_FLAG = 1 << 11;\n\n/**\n* Current entry.\n*/\nprivate ZipArchiveEntry entry;\n\n/**\n* The file comment.\n*/\nprivate String comment = \"\";\n\n/**\n* Compression level for next entry.\n*/\nprivate int level = DEFAULT_COMPRESSION;\n\n/**\n* Has the compression level changed when compared to the last\n* entry?\n*/\nprivate boolean hasCompressionLevelChanged = false;\n\n/**\n* Default compression method for next entry.\n*/\nprivate int method = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* List of ZipArchiveEntries written so far.\n*/\nprivate final List entries = new LinkedList();\n\n/**\n* CRC instance to avoid parsing DEFLATED data twice.\n*/\nprivate final CRC32 crc = new CRC32();\n\n/**\n* Count the bytes written to out.\n*/\nprivate long written = 0;\n\n/**\n* Data for local header data\n*/\nprivate long dataStart = 0;\n\n/**\n* Offset for CRC entry in the local file header data for the\n* current entry starts here.\n*/\nprivate long localDataStart = 0;\n\n/**\n* Start of central directory.\n*/\nprivate long cdOffset = 0;\n\n/**\n* Length of central directory.\n*/\nprivate long cdLength = 0;\n\n/**\n* Helper, a 0 as ZipShort.\n*/\nprivate static final byte[] ZERO = {0, 0};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif(entry != null) {\nthrow new IOException(\"This archives contains unclosed entries.\");\n}\n\ncdOffset = written;\nfor (Iterator i = entries.iterator(); i.hasNext(); ) {\nwriteCentralFileHeader((ZipArchiveEntry) i.next());\n}\ncdLength = written - cdOffset;\nwriteCentralDirectoryEnd();\noffsets.clear();\nentries.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (entry == null) {\nreturn;\n}\n\nlong realCrc = crc.getValue();\ncrc.reset();\n\nif (entry.getMethod() == DEFLATED) {\ndef.finish();\nwhile (!def.finished()) {\ndeflate();\n}\n\nentry.setSize(ZipUtil.adjustToLong(def.getTotalIn()));\nentry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut()));\nentry.setCrc(realCrc);\n\ndef.reset();\n\nwritten += entry.getCompressedSize();\n} else if (raf == null) {\nif (entry.getCrc() != realCrc) {\nthrow new ZipException(\"bad CRC checksum for entry \"\n+ entry.getName() + \": \"\n+ Long.toHexString(entry.getCrc())\n+ \" instead of \"\n+ Long.toHexString(realCrc));\n}\n\nif (entry.getSize() != written - dataStart) {\nthrow new ZipException(\"bad size for entry \"\n+ entry.getName() + \": \"\n+ entry.getSize()\n+ \" instead of \"\n+ (written - dataStart));\n}\n} else { /* method is STORED and we used RandomAccessFile */\nlong size = written - dataStart;\n\nentry.setSize(size);\nentry.setCompressedSize(size);\nentry.setCrc(realCrc);\n}\n\n// If random access output, write the local file header containing\n// the correct CRC and compressed/uncompressed sizes\nif (raf != null) {\nlong save = raf.getFilePointer();\n\nraf.seek(localDataStart);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\nraf.seek(save);\n}\n\nwriteDataDescriptor(entry);\nentry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\ncloseArchiveEntry();\n\nentry = ((ZipArchiveEntry) archiveEntry);\nentries.add(entry);\n\nif (entry.getMethod() == -1) { // not specified\nentry.setMethod(method);\n}\n\nif (entry.getTime() == -1) { // not specified\nentry.setTime(System.currentTimeMillis());\n}\n\n// Size/CRC not required if RandomAccessFile is used\nif (entry.getMethod() == STORED && raf == null) {\nif (entry.getSize() == -1) {\nthrow new ZipException(\"uncompressed size is required for\"\n+ \" STORED method when not writing to a\"\n+ \" file\");\n}\nif (entry.getCrc() == -1) {\nthrow new ZipException(\"crc checksum is required for STORED\"\n+ \" method when not writing to a file\");\n}\nentry.setCompressedSize(entry.getSize());\n}\n\nif (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\ndef.setLevel(level);\nhasCompressionLevelChanged = false;\n}\nwriteLocalFileHeader(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nfinish();\nif (raf != null) {\nraf.close();\n}\nif (out != null) {\nout.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflate()V",
                                    "method_body": "protected final void deflate() throws IOException {\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\nboolean encodable = zipEncoding.canEncode(ze.getName());\n\nfinal ZipEncoding entryEncoding;\n\nif (!encodable && fallbackToUTF8) {\nentryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n} else {\nentryEncoding = zipEncoding;\n}\n\nByteBuffer name = entryEncoding.encode(ze.getName());\n\nif (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n|| !encodable) {\nze.addExtraField(new UnicodePathExtraField(ze.getName(),\nname.array(),\nname.arrayOffset(),\nname.limit()));\n}\n\nString comm = ze.getComment();\nif (comm != null && !\"\".equals(comm)) {\n\nboolean commentEncodable = this.zipEncoding.canEncode(comm);\n\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n|| !commentEncodable) {\nByteBuffer commentB = entryEncoding.encode(comm);\nze.addExtraField(new UnicodeCommentExtraField(comm,\ncommentB.array(),\ncommentB.arrayOffset(),\ncommentB.limit())\n);\n}\n}\n}\n\noffsets.put(ze, ZipLong.getBytes(written));\n\nwriteOut(LFH_SIG);\nwritten += WORD;\n\n//store method in local variable to prevent multiple method calls\nfinal int zipMethod = ze.getMethod();\n\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n!encodable\n&& fallbackToUTF8);\nwritten += WORD;\n\n// compression method\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\n\n// last mod. time and date\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\n\n// CRC\n// compressed length\n// uncompressed length\nlocalDataStart = written;\nif (zipMethod == DEFLATED || raf != null) {\nwriteOut(LZERO);\nwriteOut(LZERO);\nwriteOut(LZERO);\n} else {\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\n}\n// CheckStyle:MagicNumber OFF\nwritten += 12;\n// CheckStyle:MagicNumber ON\n\n// file name length\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\n\n// extra field length\nbyte[] extra = ze.getLocalFileDataExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\n\n// file name\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\n\n// extra field\nwriteOut(extra);\nwritten += extra.length;\n\ndataStart = written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeDataDescriptor(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeDataDescriptor(ZipArchiveEntry ze) throws IOException {\nif (ze.getMethod() != DEFLATED || raf != null) {\nreturn;\n}\nwriteOut(DD_SIG);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\n// CheckStyle:MagicNumber OFF\nwritten += 16;\n// CheckStyle:MagicNumber ON\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\nwriteOut(CFH_SIG);\nwritten += WORD;\n\n// version made by\n// CheckStyle:MagicNumber OFF\nwriteOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\nwritten += SHORT;\n\nfinal int zipMethod = ze.getMethod();\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n!encodable\n&& fallbackToUTF8);\nwritten += WORD;\n\n// compression method\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\n\n// last mod. time and date\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\n\n// CRC\n// compressed length\n// uncompressed length\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getCompressedSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\n// CheckStyle:MagicNumber OFF\nwritten += 12;\n// CheckStyle:MagicNumber ON\n\n// file name length\nfinal ZipEncoding entryEncoding;\n\nif (!encodable && fallbackToUTF8) {\nentryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n} else {\nentryEncoding = zipEncoding;\n}\n\nByteBuffer name = entryEncoding.encode(ze.getName());\n\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\n\n// extra field length\nbyte[] extra = ze.getCentralDirectoryExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\n\n// file comment length\nString comm = ze.getComment();\nif (comm == null) {\ncomm = \"\";\n}\n\nByteBuffer commentB = entryEncoding.encode(comm);\n\nwriteOut(ZipShort.getBytes(commentB.limit()));\nwritten += SHORT;\n\n// disk number start\nwriteOut(ZERO);\nwritten += SHORT;\n\n// internal file attributes\nwriteOut(ZipShort.getBytes(ze.getInternalAttributes()));\nwritten += SHORT;\n\n// external file attributes\nwriteOut(ZipLong.getBytes(ze.getExternalAttributes()));\nwritten += WORD;\n\n// relative offset of LFH\nwriteOut((byte[]) offsets.get(ze));\nwritten += WORD;\n\n// file name\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\n\n// extra field\nwriteOut(extra);\nwritten += extra.length;\n\n// file comment\nwriteOut(commentB.array(), commentB.arrayOffset(), commentB.limit());\nwritten += commentB.limit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryEnd()V",
                                    "method_body": "protected void writeCentralDirectoryEnd() throws IOException {\nwriteOut(EOCD_SIG);\n\n// disk numbers\nwriteOut(ZERO);\nwriteOut(ZERO);\n\n// number of entries\nbyte[] num = ZipShort.getBytes(entries.size());\nwriteOut(num);\nwriteOut(num);\n\n// length and location of CD\nwriteOut(ZipLong.getBytes(cdLength));\nwriteOut(ZipLong.getBytes(cdOffset));\n\n// ZIP file comment\nByteBuffer data = this.zipEncoding.encode(comment);\nwriteOut(ZipShort.getBytes(data.limit()));\nwriteOut(data.array(), data.arrayOffset(), data.limit());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([B)V",
                                    "method_body": "protected final void writeOut(byte[] data) throws IOException {\nwriteOut(data, 0, data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([BII)V",
                                    "method_body": "protected final void writeOut(byte[] data, int offset, int length)\nthrows IOException {\nif (raf != null) {\nraf.write(data, offset, length);\n} else {\nout.write(data, offset, length);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeVersionNeededToExtractAndGeneralPurposeBits(IZ)V",
                                    "method_body": "private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\nzipMethod,\nfinal boolean\nutfFallback)\nthrows IOException {\n\n// CheckStyle:MagicNumber OFF\nint versionNeededToExtract = 10;\nint generalPurposeFlag = (useEFS || utfFallback) ? EFS_FLAG : 0;\nif (zipMethod == DEFLATED && raf == null) {\n// requires version 2 as we are going to store length info\n// in the data descriptor\nversionNeededToExtract =  20;\n// bit3 set to signal, we use a data descriptor\ngeneralPurposeFlag |= 8;\n}\n// CheckStyle:MagicNumber ON\n\n// version needed to extract\nwriteOut(ZipShort.getBytes(versionNeededToExtract));\n// general purpose bit flag\nwriteOut(ZipShort.getBytes(generalPurposeFlag));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n//private static final int BYTE_BIT_SIZE = 8;\nprivate static final int BYTE_MASK = 0xFF;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public JarArchiveOutputStream(final OutputStream out) {\nsuper(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry ze) throws IOException {\nif (!jarMarkerAdded) {\n((ZipArchiveEntry)ze).addAsFirstExtraField(JarMarker.getInstance());\njarMarkerAdded = true;\n}\nsuper.putArchiveEntry(ze);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map simpleEncodings;\n\nstatic {\nsimpleEncodings = new HashMap();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for utf-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h =\n(SimpleEncodingHolder) simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\n// check platform's default encoding\nencoding = System.getProperty(\"file.encoding\");\n}\nreturn UTF8.equalsIgnoreCase(encoding)\n|| \"utf-8\".equalsIgnoreCase(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:canEncode(Ljava/lang/String;)Z",
                                    "method_body": "public boolean canEncode(String name) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(String name) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn ByteBuffer.wrap(name.getBytes());\n} else {\nreturn ByteBuffer.wrap(name.getBytes(this.charset));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<init>(Ljava/lang/String;)V",
                                    "method_body": "private UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
                                    "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS =\nnew UnicodeExtraFieldPolicy(\"always\");\n/**\n* Never create Unicode extra fields.\n*/\npublic static final UnicodeExtraFieldPolicy NEVER =\nnew UnicodeExtraFieldPolicy(\"never\");\n/**\n* Create Unicode extra fields for filenames that cannot be\n* encoded using the specified encoding.\n*/\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nnew UnicodeExtraFieldPolicy(\"not encodeable\");\n\nprivate final String name;\nprivate UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\n\n/** No-arg constructor */\npublic JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getInstance()Lorg/apache/commons/compress/archivers/zip/JarMarker;",
                                    "method_body": "public static JarMarker getInstance() {\nreturn DEFAULT;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn NULL;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getCentralDirectoryLength() {\nreturn NULL;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn NO_BYTES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getCentralDirectoryData()[B",
                                    "method_body": "public byte[] getCentralDirectoryData() {\nreturn NO_BYTES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes(I)[B",
                                    "method_body": "public static byte[] getBytes(int value) {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n\n/**\n* Static registry of known extra fields.\n*/\nprivate static final Map implementations;\n\nstatic {\nimplementations = new HashMap();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class c) {\ntry {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n} catch (ClassCastException cc) {\nthrow new RuntimeException(c + \" doesn\\'t implement ZipExtraField\");\n} catch (InstantiationException ie) {\nthrow new RuntimeException(c + \" is not a concrete class\");\n} catch (IllegalAccessException ie) {\nthrow new RuntimeException(c + \"\\'s no-arg constructor is not public\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\n}\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n0, result, start + 2, 2);\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeCentralDirectoryData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getCentralDirectoryLength().getValue();\n}\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n0, result, start + 2, 2);\nbyte[] local = data[i].getCentralDirectoryData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate static final int      WORD = 4;\n/**\n* Standard Unix stat(2) file mode.\n*/\nprivate int mode = 0;\n/**\n* User ID.\n*/\nprivate int uid = 0;\n/**\n* Group ID.\n*/\nprivate int gid = 0;\n/**\n* File this entry points to, if it is a symbolic link.\n*\n* <p>empty string - if entry is not a symbolic link.</p>\n*/\nprivate String link = \"\";\n/**\n* Is this an entry for a directory?\n*/\nprivate boolean dirFlag = false;\n\n/**\n* Instance used to calculate checksums.\n*/\nprivate CRC32 crc = new CRC32();\n\n/** Constructor for AsiExtraField. */\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\n\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\n\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n\n/**\n* Convert a Date object to a DOS date/time field.\n* @param time the <code>Date</code> to convert\n* @return the date as a <code>ZipLong</code>\n*/\npublic static ZipLong toDosTime(Date time) {\nreturn new ZipLong(toDosTime(time.getTime()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(J)[B",
                                    "method_body": "public static byte[] toDosTime(long t) {\nCalendar c = Calendar.getInstance();\nc.setTimeInMillis(t);\n\nint year = c.get(Calendar.YEAR);\nif (year < 1980) {\nreturn (byte[]) DOS_TIME_MIN.clone(); // stop callers from changing the array\n}\nint month = c.get(Calendar.MONTH) + 1;\nlong value =  ((year - 1980) << 25)\n|         (month << 21)\n|         (c.get(Calendar.DAY_OF_MONTH) << 16)\n|         (c.get(Calendar.HOUR_OF_DAY) << 11)\n|         (c.get(Calendar.MINUTE) << 5)\n|         (c.get(Calendar.SECOND) >> 1);\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:adjustToLong(I)J",
                                    "method_body": "public static long adjustToLong(int i) {\nif (i < 0) {\nreturn 2 * ((long) Integer.MAX_VALUE) + 2 + i;\n} else {\nreturn i;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipFile(File f) throws IOException {\nthis(f, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;)V",
                                    "method_body": "public ZipFile(File f, String encoding) throws IOException {\nthis(f, encoding, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\nthrows IOException {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = new RandomAccessFile(f, \"r\");\nboolean success = false;\ntry {\nMap entriesWithoutEFS = populateFromCentralDirectory();\nresolveLocalFileHeaderData(entriesWithoutEFS);\nsuccess = true;\n} finally {\nif (!success) {\ntry {\narchive.close();\n} catch (IOException e2) {\n// swallow, throw the original exception instead\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
                                    "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\ntry {\nzipfile.close();\n} catch (IOException e) {\n//ignore\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map populateFromCentralDirectory()\nthrows IOException {\nHashMap noEFS = new HashMap();\n\npositionAtCentralDirectory();\n\nbyte[] cfh = new byte[CFH_LEN];\n\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nfinal long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\nif (sig != cfhSig && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n+ \" corrupt archive.\");\n}\nwhile (sig == cfhSig) {\narchive.readFully(cfh);\nint off = 0;\nZipArchiveEntry ze = new ZipArchiveEntry();\n\nint versionMadeBy = ZipShort.getValue(cfh, off);\noff += SHORT;\nze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\noff += SHORT; // skip version info\n\nfinal int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS =\n(generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0;\nfinal ZipEncoding entryEncoding =\nhasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\noff += SHORT;\n\nze.setMethod(ZipShort.getValue(cfh, off));\noff += SHORT;\n\n// FIXME this is actually not very cpu cycles friendly as we are converting from\n// dos to java while the underlying Sun implementation will convert\n// from java to dos time for internal storage...\nlong time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\nze.setTime(time);\noff += WORD;\n\nze.setCrc(ZipLong.getValue(cfh, off));\noff += WORD;\n\nze.setCompressedSize(ZipLong.getValue(cfh, off));\noff += WORD;\n\nze.setSize(ZipLong.getValue(cfh, off));\noff += WORD;\n\nint fileNameLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nint extraLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nint commentLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\noff += SHORT; // disk number\n\nze.setInternalAttributes(ZipShort.getValue(cfh, off));\noff += SHORT;\n\nze.setExternalAttributes(ZipLong.getValue(cfh, off));\noff += WORD;\n\nbyte[] fileName = new byte[fileNameLen];\narchive.readFully(fileName);\nze.setName(entryEncoding.decode(fileName));\n\n// LFH offset,\nOffsetEntry offset = new OffsetEntry();\noffset.headerOffset = ZipLong.getValue(cfh, off);\n// data offset will be filled later\nentries.put(ze, offset);\n\nnameMap.put(ze.getName(), ze);\n\nbyte[] cdExtraData = new byte[extraLen];\narchive.readFully(cdExtraData);\nze.setCentralDirectoryExtra(cdExtraData);\n\nbyte[] comment = new byte[commentLen];\narchive.readFully(comment);\nze.setComment(entryEncoding.decode(comment));\n\narchive.readFully(signatureBytes);\nsig = ZipLong.getValue(signatureBytes);\n\nif (!hasEFS && useUnicodeExtraFields) {\nnoEFS.put(ze, new NameAndComment(fileName, comment));\n}\n}\nreturn noEFS;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nthrows IOException {\nboolean found = false;\nlong off = archive.length() - MIN_EOCD_SIZE;\nlong stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE);\nif (off >= 0) {\narchive.seek(off);\nbyte[] sig = ZipArchiveOutputStream.EOCD_SIG;\nint curr = archive.read();\nwhile (off >= stopSearching && curr != -1) {\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\n}\n}\n}\n}\narchive.seek(--off);\ncurr = archive.read();\n}\n}\nif (!found) {\nthrow new ZipException(\"archive is not a ZIP archive\");\n}\narchive.seek(off + CFD_LOCATOR_OFFSET);\nbyte[] cfdOffset = new byte[WORD];\narchive.readFully(cfdOffset);\narchive.seek(ZipLong.getValue(cfdOffset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:startsWithLocalFileHeader()Z",
                                    "method_body": "private boolean startsWithLocalFileHeader() throws IOException {\narchive.seek(0);\nfinal byte[] start = new byte[WORD];\narchive.readFully(start);\nfor (int i = 0; i < start.length; i++) {\nif (start[i] != ZipArchiveOutputStream.LFH_SIG[i]) {\nreturn false;\n}\n}\nreturn true;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testUtf8FileRoundtripNoEFSExplicitUnicodeExtra",
                            "test_body": "48: public void testUtf8FileRoundtripNoEFSExplicitUnicodeExtra()\n49: throws IOException {\n50: testFileRoundtrip(UTF_8, false, true);\n51: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getInternalAttributes()I",
                                    "method_body": "public int getInternalAttributes() {\nreturn internalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExternalAttributes()J",
                                    "method_body": "public long getExternalAttributes() {\nreturn externalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields() {\nif (extraFields == null) {\nreturn new ZipExtraField[0];\n}\nZipExtraField[] result = new ZipExtraField[extraFields.size()];\nreturn (ZipExtraField[]) extraFields.values().toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
                                    "method_body": "public byte[] getLocalFileDataExtra() {\nbyte[] extra = getExtra();\nreturn extra != null ? extra : new byte[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getCentralDirectoryExtra()[B",
                                    "method_body": "public byte[] getCentralDirectoryExtra() {\nreturn ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\n// this method has severe consequences on performance. We cannot rely\n// on the super.hashCode() method since super.getName() always return\n// the empty string in the current implemention (there's no setter)\n// so it is basically draining the performance of a hashmap lookup\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final int BYTE_MASK = 0xFF;\nprivate static final int SHORT = 2;\nprivate static final int WORD = 4;\nstatic final int BUFFER_SIZE = 512;\n/*\n* Apparently Deflater.setInput gets slowed down a lot on Sun JVMs\n* when it gets handed a really big buffer.  See\n* https://issues.apache.org/bugzilla/show_bug.cgi?id=45396\n*\n* Using a buffer size of 8 kB proved to be a good compromise\n*/\nprivate static final int DEFLATER_BLOCK_SIZE = 8192;\n\n/**\n* Compression method for deflated entries.\n*/\npublic static final int DEFLATED = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* Default compression level for deflated entries.\n*/\npublic static final int DEFAULT_COMPRESSION = Deflater.DEFAULT_COMPRESSION;\n\n/**\n* Compression method for stored entries.\n*/\npublic static final int STORED = java.util.zip.ZipEntry.STORED;\n\n/**\n* default encoding for file names and comment.\n*/\nstatic final String DEFAULT_ENCODING = ZipEncodingHelper.UTF8;\n\n/**\n* General purpose flag, which indicates that filenames are\n* written in utf-8.\n*/\npublic static final int EFS_FLAG = 1 << 11;\n\n/**\n* Current entry.\n*/\nprivate ZipArchiveEntry entry;\n\n/**\n* The file comment.\n*/\nprivate String comment = \"\";\n\n/**\n* Compression level for next entry.\n*/\nprivate int level = DEFAULT_COMPRESSION;\n\n/**\n* Has the compression level changed when compared to the last\n* entry?\n*/\nprivate boolean hasCompressionLevelChanged = false;\n\n/**\n* Default compression method for next entry.\n*/\nprivate int method = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* List of ZipArchiveEntries written so far.\n*/\nprivate final List entries = new LinkedList();\n\n/**\n* CRC instance to avoid parsing DEFLATED data twice.\n*/\nprivate final CRC32 crc = new CRC32();\n\n/**\n* Count the bytes written to out.\n*/\nprivate long written = 0;\n\n/**\n* Data for local header data\n*/\nprivate long dataStart = 0;\n\n/**\n* Offset for CRC entry in the local file header data for the\n* current entry starts here.\n*/\nprivate long localDataStart = 0;\n\n/**\n* Start of central directory.\n*/\nprivate long cdOffset = 0;\n\n/**\n* Length of central directory.\n*/\nprivate long cdLength = 0;\n\n/**\n* Helper, a 0 as ZipShort.\n*/\nprivate static final byte[] ZERO = {0, 0};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif(entry != null) {\nthrow new IOException(\"This archives contains unclosed entries.\");\n}\n\ncdOffset = written;\nfor (Iterator i = entries.iterator(); i.hasNext(); ) {\nwriteCentralFileHeader((ZipArchiveEntry) i.next());\n}\ncdLength = written - cdOffset;\nwriteCentralDirectoryEnd();\noffsets.clear();\nentries.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (entry == null) {\nreturn;\n}\n\nlong realCrc = crc.getValue();\ncrc.reset();\n\nif (entry.getMethod() == DEFLATED) {\ndef.finish();\nwhile (!def.finished()) {\ndeflate();\n}\n\nentry.setSize(ZipUtil.adjustToLong(def.getTotalIn()));\nentry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut()));\nentry.setCrc(realCrc);\n\ndef.reset();\n\nwritten += entry.getCompressedSize();\n} else if (raf == null) {\nif (entry.getCrc() != realCrc) {\nthrow new ZipException(\"bad CRC checksum for entry \"\n+ entry.getName() + \": \"\n+ Long.toHexString(entry.getCrc())\n+ \" instead of \"\n+ Long.toHexString(realCrc));\n}\n\nif (entry.getSize() != written - dataStart) {\nthrow new ZipException(\"bad size for entry \"\n+ entry.getName() + \": \"\n+ entry.getSize()\n+ \" instead of \"\n+ (written - dataStart));\n}\n} else { /* method is STORED and we used RandomAccessFile */\nlong size = written - dataStart;\n\nentry.setSize(size);\nentry.setCompressedSize(size);\nentry.setCrc(realCrc);\n}\n\n// If random access output, write the local file header containing\n// the correct CRC and compressed/uncompressed sizes\nif (raf != null) {\nlong save = raf.getFilePointer();\n\nraf.seek(localDataStart);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\nraf.seek(save);\n}\n\nwriteDataDescriptor(entry);\nentry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\ncloseArchiveEntry();\n\nentry = ((ZipArchiveEntry) archiveEntry);\nentries.add(entry);\n\nif (entry.getMethod() == -1) { // not specified\nentry.setMethod(method);\n}\n\nif (entry.getTime() == -1) { // not specified\nentry.setTime(System.currentTimeMillis());\n}\n\n// Size/CRC not required if RandomAccessFile is used\nif (entry.getMethod() == STORED && raf == null) {\nif (entry.getSize() == -1) {\nthrow new ZipException(\"uncompressed size is required for\"\n+ \" STORED method when not writing to a\"\n+ \" file\");\n}\nif (entry.getCrc() == -1) {\nthrow new ZipException(\"crc checksum is required for STORED\"\n+ \" method when not writing to a file\");\n}\nentry.setCompressedSize(entry.getSize());\n}\n\nif (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\ndef.setLevel(level);\nhasCompressionLevelChanged = false;\n}\nwriteLocalFileHeader(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nfinish();\nif (raf != null) {\nraf.close();\n}\nif (out != null) {\nout.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflate()V",
                                    "method_body": "protected final void deflate() throws IOException {\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\nboolean encodable = zipEncoding.canEncode(ze.getName());\n\nfinal ZipEncoding entryEncoding;\n\nif (!encodable && fallbackToUTF8) {\nentryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n} else {\nentryEncoding = zipEncoding;\n}\n\nByteBuffer name = entryEncoding.encode(ze.getName());\n\nif (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n|| !encodable) {\nze.addExtraField(new UnicodePathExtraField(ze.getName(),\nname.array(),\nname.arrayOffset(),\nname.limit()));\n}\n\nString comm = ze.getComment();\nif (comm != null && !\"\".equals(comm)) {\n\nboolean commentEncodable = this.zipEncoding.canEncode(comm);\n\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n|| !commentEncodable) {\nByteBuffer commentB = entryEncoding.encode(comm);\nze.addExtraField(new UnicodeCommentExtraField(comm,\ncommentB.array(),\ncommentB.arrayOffset(),\ncommentB.limit())\n);\n}\n}\n}\n\noffsets.put(ze, ZipLong.getBytes(written));\n\nwriteOut(LFH_SIG);\nwritten += WORD;\n\n//store method in local variable to prevent multiple method calls\nfinal int zipMethod = ze.getMethod();\n\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n!encodable\n&& fallbackToUTF8);\nwritten += WORD;\n\n// compression method\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\n\n// last mod. time and date\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\n\n// CRC\n// compressed length\n// uncompressed length\nlocalDataStart = written;\nif (zipMethod == DEFLATED || raf != null) {\nwriteOut(LZERO);\nwriteOut(LZERO);\nwriteOut(LZERO);\n} else {\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\n}\n// CheckStyle:MagicNumber OFF\nwritten += 12;\n// CheckStyle:MagicNumber ON\n\n// file name length\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\n\n// extra field length\nbyte[] extra = ze.getLocalFileDataExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\n\n// file name\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\n\n// extra field\nwriteOut(extra);\nwritten += extra.length;\n\ndataStart = written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeDataDescriptor(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeDataDescriptor(ZipArchiveEntry ze) throws IOException {\nif (ze.getMethod() != DEFLATED || raf != null) {\nreturn;\n}\nwriteOut(DD_SIG);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\n// CheckStyle:MagicNumber OFF\nwritten += 16;\n// CheckStyle:MagicNumber ON\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\nwriteOut(CFH_SIG);\nwritten += WORD;\n\n// version made by\n// CheckStyle:MagicNumber OFF\nwriteOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\nwritten += SHORT;\n\nfinal int zipMethod = ze.getMethod();\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n!encodable\n&& fallbackToUTF8);\nwritten += WORD;\n\n// compression method\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\n\n// last mod. time and date\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\n\n// CRC\n// compressed length\n// uncompressed length\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getCompressedSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\n// CheckStyle:MagicNumber OFF\nwritten += 12;\n// CheckStyle:MagicNumber ON\n\n// file name length\nfinal ZipEncoding entryEncoding;\n\nif (!encodable && fallbackToUTF8) {\nentryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n} else {\nentryEncoding = zipEncoding;\n}\n\nByteBuffer name = entryEncoding.encode(ze.getName());\n\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\n\n// extra field length\nbyte[] extra = ze.getCentralDirectoryExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\n\n// file comment length\nString comm = ze.getComment();\nif (comm == null) {\ncomm = \"\";\n}\n\nByteBuffer commentB = entryEncoding.encode(comm);\n\nwriteOut(ZipShort.getBytes(commentB.limit()));\nwritten += SHORT;\n\n// disk number start\nwriteOut(ZERO);\nwritten += SHORT;\n\n// internal file attributes\nwriteOut(ZipShort.getBytes(ze.getInternalAttributes()));\nwritten += SHORT;\n\n// external file attributes\nwriteOut(ZipLong.getBytes(ze.getExternalAttributes()));\nwritten += WORD;\n\n// relative offset of LFH\nwriteOut((byte[]) offsets.get(ze));\nwritten += WORD;\n\n// file name\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\n\n// extra field\nwriteOut(extra);\nwritten += extra.length;\n\n// file comment\nwriteOut(commentB.array(), commentB.arrayOffset(), commentB.limit());\nwritten += commentB.limit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryEnd()V",
                                    "method_body": "protected void writeCentralDirectoryEnd() throws IOException {\nwriteOut(EOCD_SIG);\n\n// disk numbers\nwriteOut(ZERO);\nwriteOut(ZERO);\n\n// number of entries\nbyte[] num = ZipShort.getBytes(entries.size());\nwriteOut(num);\nwriteOut(num);\n\n// length and location of CD\nwriteOut(ZipLong.getBytes(cdLength));\nwriteOut(ZipLong.getBytes(cdOffset));\n\n// ZIP file comment\nByteBuffer data = this.zipEncoding.encode(comment);\nwriteOut(ZipShort.getBytes(data.limit()));\nwriteOut(data.array(), data.arrayOffset(), data.limit());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([B)V",
                                    "method_body": "protected final void writeOut(byte[] data) throws IOException {\nwriteOut(data, 0, data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([BII)V",
                                    "method_body": "protected final void writeOut(byte[] data, int offset, int length)\nthrows IOException {\nif (raf != null) {\nraf.write(data, offset, length);\n} else {\nout.write(data, offset, length);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeVersionNeededToExtractAndGeneralPurposeBits(IZ)V",
                                    "method_body": "private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\nzipMethod,\nfinal boolean\nutfFallback)\nthrows IOException {\n\n// CheckStyle:MagicNumber OFF\nint versionNeededToExtract = 10;\nint generalPurposeFlag = (useEFS || utfFallback) ? EFS_FLAG : 0;\nif (zipMethod == DEFLATED && raf == null) {\n// requires version 2 as we are going to store length info\n// in the data descriptor\nversionNeededToExtract =  20;\n// bit3 set to signal, we use a data descriptor\ngeneralPurposeFlag |= 8;\n}\n// CheckStyle:MagicNumber ON\n\n// version needed to extract\nwriteOut(ZipShort.getBytes(versionNeededToExtract));\n// general purpose bit flag\nwriteOut(ZipShort.getBytes(generalPurposeFlag));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n//private static final int BYTE_BIT_SIZE = 8;\nprivate static final int BYTE_MASK = 0xFF;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map simpleEncodings;\n\nstatic {\nsimpleEncodings = new HashMap();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for utf-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h =\n(SimpleEncodingHolder) simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\n// check platform's default encoding\nencoding = System.getProperty(\"file.encoding\");\n}\nreturn UTF8.equalsIgnoreCase(encoding)\n|| \"utf-8\".equalsIgnoreCase(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:canEncode(Ljava/lang/String;)Z",
                                    "method_body": "public boolean canEncode(String name) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(String name) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn ByteBuffer.wrap(name.getBytes());\n} else {\nreturn ByteBuffer.wrap(name.getBytes(this.charset));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<init>(Ljava/lang/String;)V",
                                    "method_body": "private UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
                                    "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS =\nnew UnicodeExtraFieldPolicy(\"always\");\n/**\n* Never create Unicode extra fields.\n*/\npublic static final UnicodeExtraFieldPolicy NEVER =\nnew UnicodeExtraFieldPolicy(\"never\");\n/**\n* Create Unicode extra fields for filenames that cannot be\n* encoded using the specified encoding.\n*/\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nnew UnicodeExtraFieldPolicy(\"not encodeable\");\n\nprivate final String name;\nprivate UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\n\n/** No-arg constructor */\npublic JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes(I)[B",
                                    "method_body": "public static byte[] getBytes(int value) {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n\n/**\n* Static registry of known extra fields.\n*/\nprivate static final Map implementations;\n\nstatic {\nimplementations = new HashMap();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class c) {\ntry {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n} catch (ClassCastException cc) {\nthrow new RuntimeException(c + \" doesn\\'t implement ZipExtraField\");\n} catch (InstantiationException ie) {\nthrow new RuntimeException(c + \" is not a concrete class\");\n} catch (IllegalAccessException ie) {\nthrow new RuntimeException(c + \"\\'s no-arg constructor is not public\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeCentralDirectoryData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getCentralDirectoryLength().getValue();\n}\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n0, result, start + 2, 2);\nbyte[] local = data[i].getCentralDirectoryData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate static final int      WORD = 4;\n/**\n* Standard Unix stat(2) file mode.\n*/\nprivate int mode = 0;\n/**\n* User ID.\n*/\nprivate int uid = 0;\n/**\n* Group ID.\n*/\nprivate int gid = 0;\n/**\n* File this entry points to, if it is a symbolic link.\n*\n* <p>empty string - if entry is not a symbolic link.</p>\n*/\nprivate String link = \"\";\n/**\n* Is this an entry for a directory?\n*/\nprivate boolean dirFlag = false;\n\n/**\n* Instance used to calculate checksums.\n*/\nprivate CRC32 crc = new CRC32();\n\n/** Constructor for AsiExtraField. */\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\n\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\n\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n\n/**\n* Convert a Date object to a DOS date/time field.\n* @param time the <code>Date</code> to convert\n* @return the date as a <code>ZipLong</code>\n*/\npublic static ZipLong toDosTime(Date time) {\nreturn new ZipLong(toDosTime(time.getTime()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(J)[B",
                                    "method_body": "public static byte[] toDosTime(long t) {\nCalendar c = Calendar.getInstance();\nc.setTimeInMillis(t);\n\nint year = c.get(Calendar.YEAR);\nif (year < 1980) {\nreturn (byte[]) DOS_TIME_MIN.clone(); // stop callers from changing the array\n}\nint month = c.get(Calendar.MONTH) + 1;\nlong value =  ((year - 1980) << 25)\n|         (month << 21)\n|         (c.get(Calendar.DAY_OF_MONTH) << 16)\n|         (c.get(Calendar.HOUR_OF_DAY) << 11)\n|         (c.get(Calendar.MINUTE) << 5)\n|         (c.get(Calendar.SECOND) >> 1);\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:adjustToLong(I)J",
                                    "method_body": "public static long adjustToLong(int i) {\nif (i < 0) {\nreturn 2 * ((long) Integer.MAX_VALUE) + 2 + i;\n} else {\nreturn i;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\nthrows IOException {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = new RandomAccessFile(f, \"r\");\nboolean success = false;\ntry {\nMap entriesWithoutEFS = populateFromCentralDirectory();\nresolveLocalFileHeaderData(entriesWithoutEFS);\nsuccess = true;\n} finally {\nif (!success) {\ntry {\narchive.close();\n} catch (IOException e2) {\n// swallow, throw the original exception instead\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
                                    "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\ntry {\nzipfile.close();\n} catch (IOException e) {\n//ignore\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map populateFromCentralDirectory()\nthrows IOException {\nHashMap noEFS = new HashMap();\n\npositionAtCentralDirectory();\n\nbyte[] cfh = new byte[CFH_LEN];\n\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nfinal long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\nif (sig != cfhSig && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n+ \" corrupt archive.\");\n}\nwhile (sig == cfhSig) {\narchive.readFully(cfh);\nint off = 0;\nZipArchiveEntry ze = new ZipArchiveEntry();\n\nint versionMadeBy = ZipShort.getValue(cfh, off);\noff += SHORT;\nze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\noff += SHORT; // skip version info\n\nfinal int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS =\n(generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0;\nfinal ZipEncoding entryEncoding =\nhasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\noff += SHORT;\n\nze.setMethod(ZipShort.getValue(cfh, off));\noff += SHORT;\n\n// FIXME this is actually not very cpu cycles friendly as we are converting from\n// dos to java while the underlying Sun implementation will convert\n// from java to dos time for internal storage...\nlong time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\nze.setTime(time);\noff += WORD;\n\nze.setCrc(ZipLong.getValue(cfh, off));\noff += WORD;\n\nze.setCompressedSize(ZipLong.getValue(cfh, off));\noff += WORD;\n\nze.setSize(ZipLong.getValue(cfh, off));\noff += WORD;\n\nint fileNameLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nint extraLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nint commentLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\noff += SHORT; // disk number\n\nze.setInternalAttributes(ZipShort.getValue(cfh, off));\noff += SHORT;\n\nze.setExternalAttributes(ZipLong.getValue(cfh, off));\noff += WORD;\n\nbyte[] fileName = new byte[fileNameLen];\narchive.readFully(fileName);\nze.setName(entryEncoding.decode(fileName));\n\n// LFH offset,\nOffsetEntry offset = new OffsetEntry();\noffset.headerOffset = ZipLong.getValue(cfh, off);\n// data offset will be filled later\nentries.put(ze, offset);\n\nnameMap.put(ze.getName(), ze);\n\nbyte[] cdExtraData = new byte[extraLen];\narchive.readFully(cdExtraData);\nze.setCentralDirectoryExtra(cdExtraData);\n\nbyte[] comment = new byte[commentLen];\narchive.readFully(comment);\nze.setComment(entryEncoding.decode(comment));\n\narchive.readFully(signatureBytes);\nsig = ZipLong.getValue(signatureBytes);\n\nif (!hasEFS && useUnicodeExtraFields) {\nnoEFS.put(ze, new NameAndComment(fileName, comment));\n}\n}\nreturn noEFS;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nthrows IOException {\nboolean found = false;\nlong off = archive.length() - MIN_EOCD_SIZE;\nlong stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE);\nif (off >= 0) {\narchive.seek(off);\nbyte[] sig = ZipArchiveOutputStream.EOCD_SIG;\nint curr = archive.read();\nwhile (off >= stopSearching && curr != -1) {\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\n}\n}\n}\n}\narchive.seek(--off);\ncurr = archive.read();\n}\n}\nif (!found) {\nthrow new ZipException(\"archive is not a ZIP archive\");\n}\narchive.seek(off + CFD_LOCATOR_OFFSET);\nbyte[] cfdOffset = new byte[WORD];\narchive.readFully(cfdOffset);\narchive.seek(ZipLong.getValue(cfdOffset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:startsWithLocalFileHeader()Z",
                                    "method_body": "private boolean startsWithLocalFileHeader() throws IOException {\narchive.seek(0);\nfinal byte[] start = new byte[WORD];\narchive.readFully(start);\nfor (int i = 0; i < start.length; i++) {\nif (start[i] != ZipArchiveOutputStream.LFH_SIG[i]) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipArchiveOutputStream(File file) throws IOException {\nOutputStream o = null;\nRandomAccessFile _raf = null;\ntry {\n_raf = new RandomAccessFile(file, \"rw\");\n_raf.setLength(0);\n} catch (IOException e) {\nif (_raf != null) {\ntry {\n_raf.close();\n} catch (IOException inner) {\n// ignore\n}\n_raf = null;\n}\no = new FileOutputStream(file);\n}\nout = o;\nraf = _raf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setEncoding(Ljava/lang/String;)V",
                                    "method_body": "public void setEncoding(final String encoding) {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nuseEFS &= ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setUseLanguageEncodingFlag(Z)V",
                                    "method_body": "public void setUseLanguageEncodingFlag(boolean b) {\nuseEFS = b && ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setCreateUnicodeExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveOutputStream$UnicodeExtraFieldPolicy;)V",
                                    "method_body": "public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b) {\ncreateUnicodeExtraFields = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int offset, int length) throws IOException {\nif (entry.getMethod() == DEFLATED) {\nif (length > 0) {\nif (!def.finished()) {\nif (length <= DEFLATER_BLOCK_SIZE) {\ndef.setInput(b, offset, length);\ndeflateUntilInputIsNeeded();\n} else {\nfinal int fullblocks = length / DEFLATER_BLOCK_SIZE;\nfor (int i = 0; i < fullblocks; i++) {\ndef.setInput(b, offset + i * DEFLATER_BLOCK_SIZE,\nDEFLATER_BLOCK_SIZE);\ndeflateUntilInputIsNeeded();\n}\nfinal int done = fullblocks * DEFLATER_BLOCK_SIZE;\nif (done < length) {\ndef.setInput(b, offset + done, length - done);\ndeflateUntilInputIsNeeded();\n}\n}\n}\n}\n} else {\nwriteOut(b, offset, length);\nwritten += length;\n}\ncrc.update(b, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflateUntilInputIsNeeded()V",
                                    "method_body": "private void deflateUntilInputIsNeeded() throws IOException {\nwhile (!def.needsInput()) {\ndeflate();\n}\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testUtf8FileRoundtripExplicitUnicodeExtra",
                            "test_body": "43: public void testUtf8FileRoundtripExplicitUnicodeExtra()\n44: throws IOException {\n45: testFileRoundtrip(UTF_8, true, true);\n46: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getInternalAttributes()I",
                                    "method_body": "public int getInternalAttributes() {\nreturn internalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExternalAttributes()J",
                                    "method_body": "public long getExternalAttributes() {\nreturn externalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields() {\nif (extraFields == null) {\nreturn new ZipExtraField[0];\n}\nZipExtraField[] result = new ZipExtraField[extraFields.size()];\nreturn (ZipExtraField[]) extraFields.values().toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
                                    "method_body": "public byte[] getLocalFileDataExtra() {\nbyte[] extra = getExtra();\nreturn extra != null ? extra : new byte[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getCentralDirectoryExtra()[B",
                                    "method_body": "public byte[] getCentralDirectoryExtra() {\nreturn ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\n// this method has severe consequences on performance. We cannot rely\n// on the super.hashCode() method since super.getName() always return\n// the empty string in the current implemention (there's no setter)\n// so it is basically draining the performance of a hashmap lookup\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final int BYTE_MASK = 0xFF;\nprivate static final int SHORT = 2;\nprivate static final int WORD = 4;\nstatic final int BUFFER_SIZE = 512;\n/*\n* Apparently Deflater.setInput gets slowed down a lot on Sun JVMs\n* when it gets handed a really big buffer.  See\n* https://issues.apache.org/bugzilla/show_bug.cgi?id=45396\n*\n* Using a buffer size of 8 kB proved to be a good compromise\n*/\nprivate static final int DEFLATER_BLOCK_SIZE = 8192;\n\n/**\n* Compression method for deflated entries.\n*/\npublic static final int DEFLATED = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* Default compression level for deflated entries.\n*/\npublic static final int DEFAULT_COMPRESSION = Deflater.DEFAULT_COMPRESSION;\n\n/**\n* Compression method for stored entries.\n*/\npublic static final int STORED = java.util.zip.ZipEntry.STORED;\n\n/**\n* default encoding for file names and comment.\n*/\nstatic final String DEFAULT_ENCODING = ZipEncodingHelper.UTF8;\n\n/**\n* General purpose flag, which indicates that filenames are\n* written in utf-8.\n*/\npublic static final int EFS_FLAG = 1 << 11;\n\n/**\n* Current entry.\n*/\nprivate ZipArchiveEntry entry;\n\n/**\n* The file comment.\n*/\nprivate String comment = \"\";\n\n/**\n* Compression level for next entry.\n*/\nprivate int level = DEFAULT_COMPRESSION;\n\n/**\n* Has the compression level changed when compared to the last\n* entry?\n*/\nprivate boolean hasCompressionLevelChanged = false;\n\n/**\n* Default compression method for next entry.\n*/\nprivate int method = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* List of ZipArchiveEntries written so far.\n*/\nprivate final List entries = new LinkedList();\n\n/**\n* CRC instance to avoid parsing DEFLATED data twice.\n*/\nprivate final CRC32 crc = new CRC32();\n\n/**\n* Count the bytes written to out.\n*/\nprivate long written = 0;\n\n/**\n* Data for local header data\n*/\nprivate long dataStart = 0;\n\n/**\n* Offset for CRC entry in the local file header data for the\n* current entry starts here.\n*/\nprivate long localDataStart = 0;\n\n/**\n* Start of central directory.\n*/\nprivate long cdOffset = 0;\n\n/**\n* Length of central directory.\n*/\nprivate long cdLength = 0;\n\n/**\n* Helper, a 0 as ZipShort.\n*/\nprivate static final byte[] ZERO = {0, 0};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif(entry != null) {\nthrow new IOException(\"This archives contains unclosed entries.\");\n}\n\ncdOffset = written;\nfor (Iterator i = entries.iterator(); i.hasNext(); ) {\nwriteCentralFileHeader((ZipArchiveEntry) i.next());\n}\ncdLength = written - cdOffset;\nwriteCentralDirectoryEnd();\noffsets.clear();\nentries.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (entry == null) {\nreturn;\n}\n\nlong realCrc = crc.getValue();\ncrc.reset();\n\nif (entry.getMethod() == DEFLATED) {\ndef.finish();\nwhile (!def.finished()) {\ndeflate();\n}\n\nentry.setSize(ZipUtil.adjustToLong(def.getTotalIn()));\nentry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut()));\nentry.setCrc(realCrc);\n\ndef.reset();\n\nwritten += entry.getCompressedSize();\n} else if (raf == null) {\nif (entry.getCrc() != realCrc) {\nthrow new ZipException(\"bad CRC checksum for entry \"\n+ entry.getName() + \": \"\n+ Long.toHexString(entry.getCrc())\n+ \" instead of \"\n+ Long.toHexString(realCrc));\n}\n\nif (entry.getSize() != written - dataStart) {\nthrow new ZipException(\"bad size for entry \"\n+ entry.getName() + \": \"\n+ entry.getSize()\n+ \" instead of \"\n+ (written - dataStart));\n}\n} else { /* method is STORED and we used RandomAccessFile */\nlong size = written - dataStart;\n\nentry.setSize(size);\nentry.setCompressedSize(size);\nentry.setCrc(realCrc);\n}\n\n// If random access output, write the local file header containing\n// the correct CRC and compressed/uncompressed sizes\nif (raf != null) {\nlong save = raf.getFilePointer();\n\nraf.seek(localDataStart);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\nraf.seek(save);\n}\n\nwriteDataDescriptor(entry);\nentry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\ncloseArchiveEntry();\n\nentry = ((ZipArchiveEntry) archiveEntry);\nentries.add(entry);\n\nif (entry.getMethod() == -1) { // not specified\nentry.setMethod(method);\n}\n\nif (entry.getTime() == -1) { // not specified\nentry.setTime(System.currentTimeMillis());\n}\n\n// Size/CRC not required if RandomAccessFile is used\nif (entry.getMethod() == STORED && raf == null) {\nif (entry.getSize() == -1) {\nthrow new ZipException(\"uncompressed size is required for\"\n+ \" STORED method when not writing to a\"\n+ \" file\");\n}\nif (entry.getCrc() == -1) {\nthrow new ZipException(\"crc checksum is required for STORED\"\n+ \" method when not writing to a file\");\n}\nentry.setCompressedSize(entry.getSize());\n}\n\nif (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\ndef.setLevel(level);\nhasCompressionLevelChanged = false;\n}\nwriteLocalFileHeader(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nfinish();\nif (raf != null) {\nraf.close();\n}\nif (out != null) {\nout.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflate()V",
                                    "method_body": "protected final void deflate() throws IOException {\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\nboolean encodable = zipEncoding.canEncode(ze.getName());\n\nfinal ZipEncoding entryEncoding;\n\nif (!encodable && fallbackToUTF8) {\nentryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n} else {\nentryEncoding = zipEncoding;\n}\n\nByteBuffer name = entryEncoding.encode(ze.getName());\n\nif (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n|| !encodable) {\nze.addExtraField(new UnicodePathExtraField(ze.getName(),\nname.array(),\nname.arrayOffset(),\nname.limit()));\n}\n\nString comm = ze.getComment();\nif (comm != null && !\"\".equals(comm)) {\n\nboolean commentEncodable = this.zipEncoding.canEncode(comm);\n\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n|| !commentEncodable) {\nByteBuffer commentB = entryEncoding.encode(comm);\nze.addExtraField(new UnicodeCommentExtraField(comm,\ncommentB.array(),\ncommentB.arrayOffset(),\ncommentB.limit())\n);\n}\n}\n}\n\noffsets.put(ze, ZipLong.getBytes(written));\n\nwriteOut(LFH_SIG);\nwritten += WORD;\n\n//store method in local variable to prevent multiple method calls\nfinal int zipMethod = ze.getMethod();\n\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n!encodable\n&& fallbackToUTF8);\nwritten += WORD;\n\n// compression method\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\n\n// last mod. time and date\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\n\n// CRC\n// compressed length\n// uncompressed length\nlocalDataStart = written;\nif (zipMethod == DEFLATED || raf != null) {\nwriteOut(LZERO);\nwriteOut(LZERO);\nwriteOut(LZERO);\n} else {\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\n}\n// CheckStyle:MagicNumber OFF\nwritten += 12;\n// CheckStyle:MagicNumber ON\n\n// file name length\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\n\n// extra field length\nbyte[] extra = ze.getLocalFileDataExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\n\n// file name\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\n\n// extra field\nwriteOut(extra);\nwritten += extra.length;\n\ndataStart = written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeDataDescriptor(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeDataDescriptor(ZipArchiveEntry ze) throws IOException {\nif (ze.getMethod() != DEFLATED || raf != null) {\nreturn;\n}\nwriteOut(DD_SIG);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\n// CheckStyle:MagicNumber OFF\nwritten += 16;\n// CheckStyle:MagicNumber ON\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\nwriteOut(CFH_SIG);\nwritten += WORD;\n\n// version made by\n// CheckStyle:MagicNumber OFF\nwriteOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\nwritten += SHORT;\n\nfinal int zipMethod = ze.getMethod();\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n!encodable\n&& fallbackToUTF8);\nwritten += WORD;\n\n// compression method\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\n\n// last mod. time and date\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\n\n// CRC\n// compressed length\n// uncompressed length\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getCompressedSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\n// CheckStyle:MagicNumber OFF\nwritten += 12;\n// CheckStyle:MagicNumber ON\n\n// file name length\nfinal ZipEncoding entryEncoding;\n\nif (!encodable && fallbackToUTF8) {\nentryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n} else {\nentryEncoding = zipEncoding;\n}\n\nByteBuffer name = entryEncoding.encode(ze.getName());\n\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\n\n// extra field length\nbyte[] extra = ze.getCentralDirectoryExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\n\n// file comment length\nString comm = ze.getComment();\nif (comm == null) {\ncomm = \"\";\n}\n\nByteBuffer commentB = entryEncoding.encode(comm);\n\nwriteOut(ZipShort.getBytes(commentB.limit()));\nwritten += SHORT;\n\n// disk number start\nwriteOut(ZERO);\nwritten += SHORT;\n\n// internal file attributes\nwriteOut(ZipShort.getBytes(ze.getInternalAttributes()));\nwritten += SHORT;\n\n// external file attributes\nwriteOut(ZipLong.getBytes(ze.getExternalAttributes()));\nwritten += WORD;\n\n// relative offset of LFH\nwriteOut((byte[]) offsets.get(ze));\nwritten += WORD;\n\n// file name\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\n\n// extra field\nwriteOut(extra);\nwritten += extra.length;\n\n// file comment\nwriteOut(commentB.array(), commentB.arrayOffset(), commentB.limit());\nwritten += commentB.limit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryEnd()V",
                                    "method_body": "protected void writeCentralDirectoryEnd() throws IOException {\nwriteOut(EOCD_SIG);\n\n// disk numbers\nwriteOut(ZERO);\nwriteOut(ZERO);\n\n// number of entries\nbyte[] num = ZipShort.getBytes(entries.size());\nwriteOut(num);\nwriteOut(num);\n\n// length and location of CD\nwriteOut(ZipLong.getBytes(cdLength));\nwriteOut(ZipLong.getBytes(cdOffset));\n\n// ZIP file comment\nByteBuffer data = this.zipEncoding.encode(comment);\nwriteOut(ZipShort.getBytes(data.limit()));\nwriteOut(data.array(), data.arrayOffset(), data.limit());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([B)V",
                                    "method_body": "protected final void writeOut(byte[] data) throws IOException {\nwriteOut(data, 0, data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([BII)V",
                                    "method_body": "protected final void writeOut(byte[] data, int offset, int length)\nthrows IOException {\nif (raf != null) {\nraf.write(data, offset, length);\n} else {\nout.write(data, offset, length);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeVersionNeededToExtractAndGeneralPurposeBits(IZ)V",
                                    "method_body": "private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\nzipMethod,\nfinal boolean\nutfFallback)\nthrows IOException {\n\n// CheckStyle:MagicNumber OFF\nint versionNeededToExtract = 10;\nint generalPurposeFlag = (useEFS || utfFallback) ? EFS_FLAG : 0;\nif (zipMethod == DEFLATED && raf == null) {\n// requires version 2 as we are going to store length info\n// in the data descriptor\nversionNeededToExtract =  20;\n// bit3 set to signal, we use a data descriptor\ngeneralPurposeFlag |= 8;\n}\n// CheckStyle:MagicNumber ON\n\n// version needed to extract\nwriteOut(ZipShort.getBytes(versionNeededToExtract));\n// general purpose bit flag\nwriteOut(ZipShort.getBytes(generalPurposeFlag));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n//private static final int BYTE_BIT_SIZE = 8;\nprivate static final int BYTE_MASK = 0xFF;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map simpleEncodings;\n\nstatic {\nsimpleEncodings = new HashMap();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for utf-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h =\n(SimpleEncodingHolder) simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\n// check platform's default encoding\nencoding = System.getProperty(\"file.encoding\");\n}\nreturn UTF8.equalsIgnoreCase(encoding)\n|| \"utf-8\".equalsIgnoreCase(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:canEncode(Ljava/lang/String;)Z",
                                    "method_body": "public boolean canEncode(String name) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(String name) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn ByteBuffer.wrap(name.getBytes());\n} else {\nreturn ByteBuffer.wrap(name.getBytes(this.charset));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<init>(Ljava/lang/String;)V",
                                    "method_body": "private UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
                                    "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS =\nnew UnicodeExtraFieldPolicy(\"always\");\n/**\n* Never create Unicode extra fields.\n*/\npublic static final UnicodeExtraFieldPolicy NEVER =\nnew UnicodeExtraFieldPolicy(\"never\");\n/**\n* Create Unicode extra fields for filenames that cannot be\n* encoded using the specified encoding.\n*/\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nnew UnicodeExtraFieldPolicy(\"not encodeable\");\n\nprivate final String name;\nprivate UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\n\n/** No-arg constructor */\npublic JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes(I)[B",
                                    "method_body": "public static byte[] getBytes(int value) {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n\n/**\n* Static registry of known extra fields.\n*/\nprivate static final Map implementations;\n\nstatic {\nimplementations = new HashMap();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class c) {\ntry {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n} catch (ClassCastException cc) {\nthrow new RuntimeException(c + \" doesn\\'t implement ZipExtraField\");\n} catch (InstantiationException ie) {\nthrow new RuntimeException(c + \" is not a concrete class\");\n} catch (IllegalAccessException ie) {\nthrow new RuntimeException(c + \"\\'s no-arg constructor is not public\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeCentralDirectoryData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getCentralDirectoryLength().getValue();\n}\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n0, result, start + 2, 2);\nbyte[] local = data[i].getCentralDirectoryData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate static final int      WORD = 4;\n/**\n* Standard Unix stat(2) file mode.\n*/\nprivate int mode = 0;\n/**\n* User ID.\n*/\nprivate int uid = 0;\n/**\n* Group ID.\n*/\nprivate int gid = 0;\n/**\n* File this entry points to, if it is a symbolic link.\n*\n* <p>empty string - if entry is not a symbolic link.</p>\n*/\nprivate String link = \"\";\n/**\n* Is this an entry for a directory?\n*/\nprivate boolean dirFlag = false;\n\n/**\n* Instance used to calculate checksums.\n*/\nprivate CRC32 crc = new CRC32();\n\n/** Constructor for AsiExtraField. */\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\n\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\n\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n\n/**\n* Convert a Date object to a DOS date/time field.\n* @param time the <code>Date</code> to convert\n* @return the date as a <code>ZipLong</code>\n*/\npublic static ZipLong toDosTime(Date time) {\nreturn new ZipLong(toDosTime(time.getTime()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(J)[B",
                                    "method_body": "public static byte[] toDosTime(long t) {\nCalendar c = Calendar.getInstance();\nc.setTimeInMillis(t);\n\nint year = c.get(Calendar.YEAR);\nif (year < 1980) {\nreturn (byte[]) DOS_TIME_MIN.clone(); // stop callers from changing the array\n}\nint month = c.get(Calendar.MONTH) + 1;\nlong value =  ((year - 1980) << 25)\n|         (month << 21)\n|         (c.get(Calendar.DAY_OF_MONTH) << 16)\n|         (c.get(Calendar.HOUR_OF_DAY) << 11)\n|         (c.get(Calendar.MINUTE) << 5)\n|         (c.get(Calendar.SECOND) >> 1);\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:adjustToLong(I)J",
                                    "method_body": "public static long adjustToLong(int i) {\nif (i < 0) {\nreturn 2 * ((long) Integer.MAX_VALUE) + 2 + i;\n} else {\nreturn i;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\nthrows IOException {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = new RandomAccessFile(f, \"r\");\nboolean success = false;\ntry {\nMap entriesWithoutEFS = populateFromCentralDirectory();\nresolveLocalFileHeaderData(entriesWithoutEFS);\nsuccess = true;\n} finally {\nif (!success) {\ntry {\narchive.close();\n} catch (IOException e2) {\n// swallow, throw the original exception instead\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
                                    "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\ntry {\nzipfile.close();\n} catch (IOException e) {\n//ignore\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map populateFromCentralDirectory()\nthrows IOException {\nHashMap noEFS = new HashMap();\n\npositionAtCentralDirectory();\n\nbyte[] cfh = new byte[CFH_LEN];\n\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nfinal long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\nif (sig != cfhSig && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n+ \" corrupt archive.\");\n}\nwhile (sig == cfhSig) {\narchive.readFully(cfh);\nint off = 0;\nZipArchiveEntry ze = new ZipArchiveEntry();\n\nint versionMadeBy = ZipShort.getValue(cfh, off);\noff += SHORT;\nze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\noff += SHORT; // skip version info\n\nfinal int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS =\n(generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0;\nfinal ZipEncoding entryEncoding =\nhasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\noff += SHORT;\n\nze.setMethod(ZipShort.getValue(cfh, off));\noff += SHORT;\n\n// FIXME this is actually not very cpu cycles friendly as we are converting from\n// dos to java while the underlying Sun implementation will convert\n// from java to dos time for internal storage...\nlong time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\nze.setTime(time);\noff += WORD;\n\nze.setCrc(ZipLong.getValue(cfh, off));\noff += WORD;\n\nze.setCompressedSize(ZipLong.getValue(cfh, off));\noff += WORD;\n\nze.setSize(ZipLong.getValue(cfh, off));\noff += WORD;\n\nint fileNameLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nint extraLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nint commentLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\noff += SHORT; // disk number\n\nze.setInternalAttributes(ZipShort.getValue(cfh, off));\noff += SHORT;\n\nze.setExternalAttributes(ZipLong.getValue(cfh, off));\noff += WORD;\n\nbyte[] fileName = new byte[fileNameLen];\narchive.readFully(fileName);\nze.setName(entryEncoding.decode(fileName));\n\n// LFH offset,\nOffsetEntry offset = new OffsetEntry();\noffset.headerOffset = ZipLong.getValue(cfh, off);\n// data offset will be filled later\nentries.put(ze, offset);\n\nnameMap.put(ze.getName(), ze);\n\nbyte[] cdExtraData = new byte[extraLen];\narchive.readFully(cdExtraData);\nze.setCentralDirectoryExtra(cdExtraData);\n\nbyte[] comment = new byte[commentLen];\narchive.readFully(comment);\nze.setComment(entryEncoding.decode(comment));\n\narchive.readFully(signatureBytes);\nsig = ZipLong.getValue(signatureBytes);\n\nif (!hasEFS && useUnicodeExtraFields) {\nnoEFS.put(ze, new NameAndComment(fileName, comment));\n}\n}\nreturn noEFS;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nthrows IOException {\nboolean found = false;\nlong off = archive.length() - MIN_EOCD_SIZE;\nlong stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE);\nif (off >= 0) {\narchive.seek(off);\nbyte[] sig = ZipArchiveOutputStream.EOCD_SIG;\nint curr = archive.read();\nwhile (off >= stopSearching && curr != -1) {\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\n}\n}\n}\n}\narchive.seek(--off);\ncurr = archive.read();\n}\n}\nif (!found) {\nthrow new ZipException(\"archive is not a ZIP archive\");\n}\narchive.seek(off + CFD_LOCATOR_OFFSET);\nbyte[] cfdOffset = new byte[WORD];\narchive.readFully(cfdOffset);\narchive.seek(ZipLong.getValue(cfdOffset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:startsWithLocalFileHeader()Z",
                                    "method_body": "private boolean startsWithLocalFileHeader() throws IOException {\narchive.seek(0);\nfinal byte[] start = new byte[WORD];\narchive.readFully(start);\nfor (int i = 0; i < start.length; i++) {\nif (start[i] != ZipArchiveOutputStream.LFH_SIG[i]) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipArchiveOutputStream(File file) throws IOException {\nOutputStream o = null;\nRandomAccessFile _raf = null;\ntry {\n_raf = new RandomAccessFile(file, \"rw\");\n_raf.setLength(0);\n} catch (IOException e) {\nif (_raf != null) {\ntry {\n_raf.close();\n} catch (IOException inner) {\n// ignore\n}\n_raf = null;\n}\no = new FileOutputStream(file);\n}\nout = o;\nraf = _raf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setEncoding(Ljava/lang/String;)V",
                                    "method_body": "public void setEncoding(final String encoding) {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nuseEFS &= ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setUseLanguageEncodingFlag(Z)V",
                                    "method_body": "public void setUseLanguageEncodingFlag(boolean b) {\nuseEFS = b && ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setCreateUnicodeExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveOutputStream$UnicodeExtraFieldPolicy;)V",
                                    "method_body": "public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b) {\ncreateUnicodeExtraFields = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int offset, int length) throws IOException {\nif (entry.getMethod() == DEFLATED) {\nif (length > 0) {\nif (!def.finished()) {\nif (length <= DEFLATER_BLOCK_SIZE) {\ndef.setInput(b, offset, length);\ndeflateUntilInputIsNeeded();\n} else {\nfinal int fullblocks = length / DEFLATER_BLOCK_SIZE;\nfor (int i = 0; i < fullblocks; i++) {\ndef.setInput(b, offset + i * DEFLATER_BLOCK_SIZE,\nDEFLATER_BLOCK_SIZE);\ndeflateUntilInputIsNeeded();\n}\nfinal int done = fullblocks * DEFLATER_BLOCK_SIZE;\nif (done < length) {\ndef.setInput(b, offset + done, length - done);\ndeflateUntilInputIsNeeded();\n}\n}\n}\n}\n} else {\nwriteOut(b, offset, length);\nwritten += length;\n}\ncrc.update(b, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflateUntilInputIsNeeded()V",
                                    "method_body": "private void deflateUntilInputIsNeeded() throws IOException {\nwhile (!def.needsInput()) {\ndeflate();\n}\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testASCIIFileRoundtripExplicitUnicodeExtra",
                            "test_body": "58: public void testASCIIFileRoundtripExplicitUnicodeExtra()\n59: throws IOException {\n60: testFileRoundtrip(US_ASCII, false, true);\n61: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getInternalAttributes()I",
                                    "method_body": "public int getInternalAttributes() {\nreturn internalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExternalAttributes()J",
                                    "method_body": "public long getExternalAttributes() {\nreturn externalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields() {\nif (extraFields == null) {\nreturn new ZipExtraField[0];\n}\nZipExtraField[] result = new ZipExtraField[extraFields.size()];\nreturn (ZipExtraField[]) extraFields.values().toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
                                    "method_body": "public byte[] getLocalFileDataExtra() {\nbyte[] extra = getExtra();\nreturn extra != null ? extra : new byte[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getCentralDirectoryExtra()[B",
                                    "method_body": "public byte[] getCentralDirectoryExtra() {\nreturn ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\n// this method has severe consequences on performance. We cannot rely\n// on the super.hashCode() method since super.getName() always return\n// the empty string in the current implemention (there's no setter)\n// so it is basically draining the performance of a hashmap lookup\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final int BYTE_MASK = 0xFF;\nprivate static final int SHORT = 2;\nprivate static final int WORD = 4;\nstatic final int BUFFER_SIZE = 512;\n/*\n* Apparently Deflater.setInput gets slowed down a lot on Sun JVMs\n* when it gets handed a really big buffer.  See\n* https://issues.apache.org/bugzilla/show_bug.cgi?id=45396\n*\n* Using a buffer size of 8 kB proved to be a good compromise\n*/\nprivate static final int DEFLATER_BLOCK_SIZE = 8192;\n\n/**\n* Compression method for deflated entries.\n*/\npublic static final int DEFLATED = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* Default compression level for deflated entries.\n*/\npublic static final int DEFAULT_COMPRESSION = Deflater.DEFAULT_COMPRESSION;\n\n/**\n* Compression method for stored entries.\n*/\npublic static final int STORED = java.util.zip.ZipEntry.STORED;\n\n/**\n* default encoding for file names and comment.\n*/\nstatic final String DEFAULT_ENCODING = ZipEncodingHelper.UTF8;\n\n/**\n* General purpose flag, which indicates that filenames are\n* written in utf-8.\n*/\npublic static final int EFS_FLAG = 1 << 11;\n\n/**\n* Current entry.\n*/\nprivate ZipArchiveEntry entry;\n\n/**\n* The file comment.\n*/\nprivate String comment = \"\";\n\n/**\n* Compression level for next entry.\n*/\nprivate int level = DEFAULT_COMPRESSION;\n\n/**\n* Has the compression level changed when compared to the last\n* entry?\n*/\nprivate boolean hasCompressionLevelChanged = false;\n\n/**\n* Default compression method for next entry.\n*/\nprivate int method = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* List of ZipArchiveEntries written so far.\n*/\nprivate final List entries = new LinkedList();\n\n/**\n* CRC instance to avoid parsing DEFLATED data twice.\n*/\nprivate final CRC32 crc = new CRC32();\n\n/**\n* Count the bytes written to out.\n*/\nprivate long written = 0;\n\n/**\n* Data for local header data\n*/\nprivate long dataStart = 0;\n\n/**\n* Offset for CRC entry in the local file header data for the\n* current entry starts here.\n*/\nprivate long localDataStart = 0;\n\n/**\n* Start of central directory.\n*/\nprivate long cdOffset = 0;\n\n/**\n* Length of central directory.\n*/\nprivate long cdLength = 0;\n\n/**\n* Helper, a 0 as ZipShort.\n*/\nprivate static final byte[] ZERO = {0, 0};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif(entry != null) {\nthrow new IOException(\"This archives contains unclosed entries.\");\n}\n\ncdOffset = written;\nfor (Iterator i = entries.iterator(); i.hasNext(); ) {\nwriteCentralFileHeader((ZipArchiveEntry) i.next());\n}\ncdLength = written - cdOffset;\nwriteCentralDirectoryEnd();\noffsets.clear();\nentries.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (entry == null) {\nreturn;\n}\n\nlong realCrc = crc.getValue();\ncrc.reset();\n\nif (entry.getMethod() == DEFLATED) {\ndef.finish();\nwhile (!def.finished()) {\ndeflate();\n}\n\nentry.setSize(ZipUtil.adjustToLong(def.getTotalIn()));\nentry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut()));\nentry.setCrc(realCrc);\n\ndef.reset();\n\nwritten += entry.getCompressedSize();\n} else if (raf == null) {\nif (entry.getCrc() != realCrc) {\nthrow new ZipException(\"bad CRC checksum for entry \"\n+ entry.getName() + \": \"\n+ Long.toHexString(entry.getCrc())\n+ \" instead of \"\n+ Long.toHexString(realCrc));\n}\n\nif (entry.getSize() != written - dataStart) {\nthrow new ZipException(\"bad size for entry \"\n+ entry.getName() + \": \"\n+ entry.getSize()\n+ \" instead of \"\n+ (written - dataStart));\n}\n} else { /* method is STORED and we used RandomAccessFile */\nlong size = written - dataStart;\n\nentry.setSize(size);\nentry.setCompressedSize(size);\nentry.setCrc(realCrc);\n}\n\n// If random access output, write the local file header containing\n// the correct CRC and compressed/uncompressed sizes\nif (raf != null) {\nlong save = raf.getFilePointer();\n\nraf.seek(localDataStart);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\nraf.seek(save);\n}\n\nwriteDataDescriptor(entry);\nentry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\ncloseArchiveEntry();\n\nentry = ((ZipArchiveEntry) archiveEntry);\nentries.add(entry);\n\nif (entry.getMethod() == -1) { // not specified\nentry.setMethod(method);\n}\n\nif (entry.getTime() == -1) { // not specified\nentry.setTime(System.currentTimeMillis());\n}\n\n// Size/CRC not required if RandomAccessFile is used\nif (entry.getMethod() == STORED && raf == null) {\nif (entry.getSize() == -1) {\nthrow new ZipException(\"uncompressed size is required for\"\n+ \" STORED method when not writing to a\"\n+ \" file\");\n}\nif (entry.getCrc() == -1) {\nthrow new ZipException(\"crc checksum is required for STORED\"\n+ \" method when not writing to a file\");\n}\nentry.setCompressedSize(entry.getSize());\n}\n\nif (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\ndef.setLevel(level);\nhasCompressionLevelChanged = false;\n}\nwriteLocalFileHeader(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nfinish();\nif (raf != null) {\nraf.close();\n}\nif (out != null) {\nout.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflate()V",
                                    "method_body": "protected final void deflate() throws IOException {\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\nboolean encodable = zipEncoding.canEncode(ze.getName());\n\nfinal ZipEncoding entryEncoding;\n\nif (!encodable && fallbackToUTF8) {\nentryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n} else {\nentryEncoding = zipEncoding;\n}\n\nByteBuffer name = entryEncoding.encode(ze.getName());\n\nif (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n|| !encodable) {\nze.addExtraField(new UnicodePathExtraField(ze.getName(),\nname.array(),\nname.arrayOffset(),\nname.limit()));\n}\n\nString comm = ze.getComment();\nif (comm != null && !\"\".equals(comm)) {\n\nboolean commentEncodable = this.zipEncoding.canEncode(comm);\n\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n|| !commentEncodable) {\nByteBuffer commentB = entryEncoding.encode(comm);\nze.addExtraField(new UnicodeCommentExtraField(comm,\ncommentB.array(),\ncommentB.arrayOffset(),\ncommentB.limit())\n);\n}\n}\n}\n\noffsets.put(ze, ZipLong.getBytes(written));\n\nwriteOut(LFH_SIG);\nwritten += WORD;\n\n//store method in local variable to prevent multiple method calls\nfinal int zipMethod = ze.getMethod();\n\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n!encodable\n&& fallbackToUTF8);\nwritten += WORD;\n\n// compression method\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\n\n// last mod. time and date\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\n\n// CRC\n// compressed length\n// uncompressed length\nlocalDataStart = written;\nif (zipMethod == DEFLATED || raf != null) {\nwriteOut(LZERO);\nwriteOut(LZERO);\nwriteOut(LZERO);\n} else {\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\n}\n// CheckStyle:MagicNumber OFF\nwritten += 12;\n// CheckStyle:MagicNumber ON\n\n// file name length\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\n\n// extra field length\nbyte[] extra = ze.getLocalFileDataExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\n\n// file name\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\n\n// extra field\nwriteOut(extra);\nwritten += extra.length;\n\ndataStart = written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeDataDescriptor(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeDataDescriptor(ZipArchiveEntry ze) throws IOException {\nif (ze.getMethod() != DEFLATED || raf != null) {\nreturn;\n}\nwriteOut(DD_SIG);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\n// CheckStyle:MagicNumber OFF\nwritten += 16;\n// CheckStyle:MagicNumber ON\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\nwriteOut(CFH_SIG);\nwritten += WORD;\n\n// version made by\n// CheckStyle:MagicNumber OFF\nwriteOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\nwritten += SHORT;\n\nfinal int zipMethod = ze.getMethod();\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n!encodable\n&& fallbackToUTF8);\nwritten += WORD;\n\n// compression method\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\n\n// last mod. time and date\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\n\n// CRC\n// compressed length\n// uncompressed length\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getCompressedSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\n// CheckStyle:MagicNumber OFF\nwritten += 12;\n// CheckStyle:MagicNumber ON\n\n// file name length\nfinal ZipEncoding entryEncoding;\n\nif (!encodable && fallbackToUTF8) {\nentryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n} else {\nentryEncoding = zipEncoding;\n}\n\nByteBuffer name = entryEncoding.encode(ze.getName());\n\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\n\n// extra field length\nbyte[] extra = ze.getCentralDirectoryExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\n\n// file comment length\nString comm = ze.getComment();\nif (comm == null) {\ncomm = \"\";\n}\n\nByteBuffer commentB = entryEncoding.encode(comm);\n\nwriteOut(ZipShort.getBytes(commentB.limit()));\nwritten += SHORT;\n\n// disk number start\nwriteOut(ZERO);\nwritten += SHORT;\n\n// internal file attributes\nwriteOut(ZipShort.getBytes(ze.getInternalAttributes()));\nwritten += SHORT;\n\n// external file attributes\nwriteOut(ZipLong.getBytes(ze.getExternalAttributes()));\nwritten += WORD;\n\n// relative offset of LFH\nwriteOut((byte[]) offsets.get(ze));\nwritten += WORD;\n\n// file name\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\n\n// extra field\nwriteOut(extra);\nwritten += extra.length;\n\n// file comment\nwriteOut(commentB.array(), commentB.arrayOffset(), commentB.limit());\nwritten += commentB.limit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryEnd()V",
                                    "method_body": "protected void writeCentralDirectoryEnd() throws IOException {\nwriteOut(EOCD_SIG);\n\n// disk numbers\nwriteOut(ZERO);\nwriteOut(ZERO);\n\n// number of entries\nbyte[] num = ZipShort.getBytes(entries.size());\nwriteOut(num);\nwriteOut(num);\n\n// length and location of CD\nwriteOut(ZipLong.getBytes(cdLength));\nwriteOut(ZipLong.getBytes(cdOffset));\n\n// ZIP file comment\nByteBuffer data = this.zipEncoding.encode(comment);\nwriteOut(ZipShort.getBytes(data.limit()));\nwriteOut(data.array(), data.arrayOffset(), data.limit());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([B)V",
                                    "method_body": "protected final void writeOut(byte[] data) throws IOException {\nwriteOut(data, 0, data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([BII)V",
                                    "method_body": "protected final void writeOut(byte[] data, int offset, int length)\nthrows IOException {\nif (raf != null) {\nraf.write(data, offset, length);\n} else {\nout.write(data, offset, length);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeVersionNeededToExtractAndGeneralPurposeBits(IZ)V",
                                    "method_body": "private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\nzipMethod,\nfinal boolean\nutfFallback)\nthrows IOException {\n\n// CheckStyle:MagicNumber OFF\nint versionNeededToExtract = 10;\nint generalPurposeFlag = (useEFS || utfFallback) ? EFS_FLAG : 0;\nif (zipMethod == DEFLATED && raf == null) {\n// requires version 2 as we are going to store length info\n// in the data descriptor\nversionNeededToExtract =  20;\n// bit3 set to signal, we use a data descriptor\ngeneralPurposeFlag |= 8;\n}\n// CheckStyle:MagicNumber ON\n\n// version needed to extract\nwriteOut(ZipShort.getBytes(versionNeededToExtract));\n// general purpose bit flag\nwriteOut(ZipShort.getBytes(generalPurposeFlag));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n//private static final int BYTE_BIT_SIZE = 8;\nprivate static final int BYTE_MASK = 0xFF;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map simpleEncodings;\n\nstatic {\nsimpleEncodings = new HashMap();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for utf-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h =\n(SimpleEncodingHolder) simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\n// check platform's default encoding\nencoding = System.getProperty(\"file.encoding\");\n}\nreturn UTF8.equalsIgnoreCase(encoding)\n|| \"utf-8\".equalsIgnoreCase(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<init>(Ljava/lang/String;)V",
                                    "method_body": "private UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
                                    "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS =\nnew UnicodeExtraFieldPolicy(\"always\");\n/**\n* Never create Unicode extra fields.\n*/\npublic static final UnicodeExtraFieldPolicy NEVER =\nnew UnicodeExtraFieldPolicy(\"never\");\n/**\n* Create Unicode extra fields for filenames that cannot be\n* encoded using the specified encoding.\n*/\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nnew UnicodeExtraFieldPolicy(\"not encodeable\");\n\nprivate final String name;\nprivate UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\n\n/** No-arg constructor */\npublic JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes(I)[B",
                                    "method_body": "public static byte[] getBytes(int value) {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n\n/**\n* Static registry of known extra fields.\n*/\nprivate static final Map implementations;\n\nstatic {\nimplementations = new HashMap();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class c) {\ntry {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n} catch (ClassCastException cc) {\nthrow new RuntimeException(c + \" doesn\\'t implement ZipExtraField\");\n} catch (InstantiationException ie) {\nthrow new RuntimeException(c + \" is not a concrete class\");\n} catch (IllegalAccessException ie) {\nthrow new RuntimeException(c + \"\\'s no-arg constructor is not public\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\n}\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n0, result, start + 2, 2);\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeCentralDirectoryData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getCentralDirectoryLength().getValue();\n}\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n0, result, start + 2, 2);\nbyte[] local = data[i].getCentralDirectoryData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate static final int      WORD = 4;\n/**\n* Standard Unix stat(2) file mode.\n*/\nprivate int mode = 0;\n/**\n* User ID.\n*/\nprivate int uid = 0;\n/**\n* Group ID.\n*/\nprivate int gid = 0;\n/**\n* File this entry points to, if it is a symbolic link.\n*\n* <p>empty string - if entry is not a symbolic link.</p>\n*/\nprivate String link = \"\";\n/**\n* Is this an entry for a directory?\n*/\nprivate boolean dirFlag = false;\n\n/**\n* Instance used to calculate checksums.\n*/\nprivate CRC32 crc = new CRC32();\n\n/** Constructor for AsiExtraField. */\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\n\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\n\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n\n/**\n* Convert a Date object to a DOS date/time field.\n* @param time the <code>Date</code> to convert\n* @return the date as a <code>ZipLong</code>\n*/\npublic static ZipLong toDosTime(Date time) {\nreturn new ZipLong(toDosTime(time.getTime()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(J)[B",
                                    "method_body": "public static byte[] toDosTime(long t) {\nCalendar c = Calendar.getInstance();\nc.setTimeInMillis(t);\n\nint year = c.get(Calendar.YEAR);\nif (year < 1980) {\nreturn (byte[]) DOS_TIME_MIN.clone(); // stop callers from changing the array\n}\nint month = c.get(Calendar.MONTH) + 1;\nlong value =  ((year - 1980) << 25)\n|         (month << 21)\n|         (c.get(Calendar.DAY_OF_MONTH) << 16)\n|         (c.get(Calendar.HOUR_OF_DAY) << 11)\n|         (c.get(Calendar.MINUTE) << 5)\n|         (c.get(Calendar.SECOND) >> 1);\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:adjustToLong(I)J",
                                    "method_body": "public static long adjustToLong(int i) {\nif (i < 0) {\nreturn 2 * ((long) Integer.MAX_VALUE) + 2 + i;\n} else {\nreturn i;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\nthrows IOException {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = new RandomAccessFile(f, \"r\");\nboolean success = false;\ntry {\nMap entriesWithoutEFS = populateFromCentralDirectory();\nresolveLocalFileHeaderData(entriesWithoutEFS);\nsuccess = true;\n} finally {\nif (!success) {\ntry {\narchive.close();\n} catch (IOException e2) {\n// swallow, throw the original exception instead\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
                                    "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\ntry {\nzipfile.close();\n} catch (IOException e) {\n//ignore\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map populateFromCentralDirectory()\nthrows IOException {\nHashMap noEFS = new HashMap();\n\npositionAtCentralDirectory();\n\nbyte[] cfh = new byte[CFH_LEN];\n\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nfinal long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\nif (sig != cfhSig && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n+ \" corrupt archive.\");\n}\nwhile (sig == cfhSig) {\narchive.readFully(cfh);\nint off = 0;\nZipArchiveEntry ze = new ZipArchiveEntry();\n\nint versionMadeBy = ZipShort.getValue(cfh, off);\noff += SHORT;\nze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\noff += SHORT; // skip version info\n\nfinal int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS =\n(generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0;\nfinal ZipEncoding entryEncoding =\nhasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\noff += SHORT;\n\nze.setMethod(ZipShort.getValue(cfh, off));\noff += SHORT;\n\n// FIXME this is actually not very cpu cycles friendly as we are converting from\n// dos to java while the underlying Sun implementation will convert\n// from java to dos time for internal storage...\nlong time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\nze.setTime(time);\noff += WORD;\n\nze.setCrc(ZipLong.getValue(cfh, off));\noff += WORD;\n\nze.setCompressedSize(ZipLong.getValue(cfh, off));\noff += WORD;\n\nze.setSize(ZipLong.getValue(cfh, off));\noff += WORD;\n\nint fileNameLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nint extraLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nint commentLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\noff += SHORT; // disk number\n\nze.setInternalAttributes(ZipShort.getValue(cfh, off));\noff += SHORT;\n\nze.setExternalAttributes(ZipLong.getValue(cfh, off));\noff += WORD;\n\nbyte[] fileName = new byte[fileNameLen];\narchive.readFully(fileName);\nze.setName(entryEncoding.decode(fileName));\n\n// LFH offset,\nOffsetEntry offset = new OffsetEntry();\noffset.headerOffset = ZipLong.getValue(cfh, off);\n// data offset will be filled later\nentries.put(ze, offset);\n\nnameMap.put(ze.getName(), ze);\n\nbyte[] cdExtraData = new byte[extraLen];\narchive.readFully(cdExtraData);\nze.setCentralDirectoryExtra(cdExtraData);\n\nbyte[] comment = new byte[commentLen];\narchive.readFully(comment);\nze.setComment(entryEncoding.decode(comment));\n\narchive.readFully(signatureBytes);\nsig = ZipLong.getValue(signatureBytes);\n\nif (!hasEFS && useUnicodeExtraFields) {\nnoEFS.put(ze, new NameAndComment(fileName, comment));\n}\n}\nreturn noEFS;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nthrows IOException {\nboolean found = false;\nlong off = archive.length() - MIN_EOCD_SIZE;\nlong stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE);\nif (off >= 0) {\narchive.seek(off);\nbyte[] sig = ZipArchiveOutputStream.EOCD_SIG;\nint curr = archive.read();\nwhile (off >= stopSearching && curr != -1) {\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\n}\n}\n}\n}\narchive.seek(--off);\ncurr = archive.read();\n}\n}\nif (!found) {\nthrow new ZipException(\"archive is not a ZIP archive\");\n}\narchive.seek(off + CFD_LOCATOR_OFFSET);\nbyte[] cfdOffset = new byte[WORD];\narchive.readFully(cfdOffset);\narchive.seek(ZipLong.getValue(cfdOffset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:startsWithLocalFileHeader()Z",
                                    "method_body": "private boolean startsWithLocalFileHeader() throws IOException {\narchive.seek(0);\nfinal byte[] start = new byte[WORD];\narchive.readFully(start);\nfor (int i = 0; i < start.length; i++) {\nif (start[i] != ZipArchiveOutputStream.LFH_SIG[i]) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipArchiveOutputStream(File file) throws IOException {\nOutputStream o = null;\nRandomAccessFile _raf = null;\ntry {\n_raf = new RandomAccessFile(file, \"rw\");\n_raf.setLength(0);\n} catch (IOException e) {\nif (_raf != null) {\ntry {\n_raf.close();\n} catch (IOException inner) {\n// ignore\n}\n_raf = null;\n}\no = new FileOutputStream(file);\n}\nout = o;\nraf = _raf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setEncoding(Ljava/lang/String;)V",
                                    "method_body": "public void setEncoding(final String encoding) {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nuseEFS &= ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setUseLanguageEncodingFlag(Z)V",
                                    "method_body": "public void setUseLanguageEncodingFlag(boolean b) {\nuseEFS = b && ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setCreateUnicodeExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveOutputStream$UnicodeExtraFieldPolicy;)V",
                                    "method_body": "public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b) {\ncreateUnicodeExtraFields = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int offset, int length) throws IOException {\nif (entry.getMethod() == DEFLATED) {\nif (length > 0) {\nif (!def.finished()) {\nif (length <= DEFLATER_BLOCK_SIZE) {\ndef.setInput(b, offset, length);\ndeflateUntilInputIsNeeded();\n} else {\nfinal int fullblocks = length / DEFLATER_BLOCK_SIZE;\nfor (int i = 0; i < fullblocks; i++) {\ndef.setInput(b, offset + i * DEFLATER_BLOCK_SIZE,\nDEFLATER_BLOCK_SIZE);\ndeflateUntilInputIsNeeded();\n}\nfinal int done = fullblocks * DEFLATER_BLOCK_SIZE;\nif (done < length) {\ndef.setInput(b, offset + done, length - done);\ndeflateUntilInputIsNeeded();\n}\n}\n}\n}\n} else {\nwriteOut(b, offset, length);\nwritten += length;\n}\ncrc.update(b, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflateUntilInputIsNeeded()V",
                                    "method_body": "private void deflateUntilInputIsNeeded() throws IOException {\nwhile (!def.needsInput()) {\ndeflate();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:addExtraField(Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void addExtraField(ZipExtraField ze) {\nif (extraFields == null) {\nextraFields = new LinkedHashMap();\n}\nextraFields.put(ze.getHeaderId(), ze);\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:appendSurrogate(Ljava/nio/ByteBuffer;C)V",
                                    "method_body": "static void appendSurrogate(ByteBuffer bb, char c) {\n\nbb.put((byte) '%');\nbb.put((byte) 'U');\n\nbb.put(HEX_DIGITS[(c >> 12)&0x0f]);\nbb.put(HEX_DIGITS[(c >> 8)&0x0f]);\nbb.put(HEX_DIGITS[(c >> 4)&0x0f]);\nbb.put(HEX_DIGITS[c & 0x0f]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "protected AbstractUnicodeExtraField(String text, byte[] bytes, int off,\nint len) {\nCRC32 crc32 = new CRC32();\ncrc32.update(bytes, off, len);\nnameCRC32 = crc32.getValue();\n\ntry {\nunicodeName = text.getBytes(\"UTF-8\");\n} catch (UnsupportedEncodingException e) {\nthrow new RuntimeException(\"FATAL: UTF-8 encoding not supported.\",\ne);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:assembleData()V",
                                    "method_body": "private void assembleData() {\nif (unicodeName == null) {\nreturn;\n}\n\ndata = new byte[5 + unicodeName.length];\n// version 1\ndata[0] = 0x01;\nSystem.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4);\nSystem.arraycopy(unicodeName, 0, data, 5, unicodeName.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryData()[B",
                                    "method_body": "public byte[] getCentralDirectoryData() {\nif (data == null) {\nthis.assembleData();\n}\nreturn data;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getCentralDirectoryLength() {\nif (data == null) {\nassembleData();\n}\nreturn new ZipShort(data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn getCentralDirectoryData();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn getCentralDirectoryLength();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "public UnicodePathExtraField(String text, byte[] bytes, int off, int len) {\nsuper(text, bytes, off, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:growBuffer(Ljava/nio/ByteBuffer;I)Ljava/nio/ByteBuffer;",
                                    "method_body": "static ByteBuffer growBuffer(ByteBuffer b, int newCapacity) {\nb.limit(b.position());\nb.rewind();\n\nint c2 = b.capacity() * 2;\nByteBuffer on = ByteBuffer.allocate(c2 < newCapacity ? newCapacity : c2);\n\non.put(b);\nreturn on;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:<init>(Ljava/nio/charset/Charset;)V",
                                    "method_body": "public NioZipEncoding(Charset charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:canEncode(Ljava/lang/String;)Z",
                                    "method_body": "public boolean canEncode(String name) {\nCharsetEncoder enc = this.charset.newEncoder();\nenc.onMalformedInput(CodingErrorAction.REPORT);\nenc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\nreturn enc.canEncode(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(String name) {\nCharsetEncoder enc = this.charset.newEncoder();\n\nenc.onMalformedInput(CodingErrorAction.REPORT);\nenc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\nCharBuffer cb = CharBuffer.wrap(name);\nByteBuffer out = ByteBuffer.allocate(name.length()\n+ (name.length() + 1) / 2);\n\nwhile (cb.remaining() > 0) {\nCoderResult res = enc.encode(cb, out,true);\n\nif (res.isUnmappable() || res.isMalformed()) {\n\n// write the unmappable characters in utf-16\n// pseudo-URL encoding style to ByteBuffer.\nif (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, out.position()\n+ res.length() * 6);\n}\n\nfor (int i=0; i<res.length(); ++i) {\nZipEncodingHelper.appendSurrogate(out,cb.get());\n}\n\n} else if (res.isOverflow()) {\n\nout = ZipEncodingHelper.growBuffer(out, 0);\n\n} else if (res.isUnderflow()) {\n\nenc.flush(out);\nbreak;\n\n}\n}\n\nout.limit(out.position());\nout.rewind();\nreturn out;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testCP437FileRoundtripExplicitUnicodeExtra",
                            "test_body": "53: public void testCP437FileRoundtripExplicitUnicodeExtra()\n54: throws IOException {\n55: testFileRoundtrip(CP437, false, true);\n56: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getInternalAttributes()I",
                                    "method_body": "public int getInternalAttributes() {\nreturn internalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExternalAttributes()J",
                                    "method_body": "public long getExternalAttributes() {\nreturn externalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields() {\nif (extraFields == null) {\nreturn new ZipExtraField[0];\n}\nZipExtraField[] result = new ZipExtraField[extraFields.size()];\nreturn (ZipExtraField[]) extraFields.values().toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
                                    "method_body": "public byte[] getLocalFileDataExtra() {\nbyte[] extra = getExtra();\nreturn extra != null ? extra : new byte[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getCentralDirectoryExtra()[B",
                                    "method_body": "public byte[] getCentralDirectoryExtra() {\nreturn ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\n// this method has severe consequences on performance. We cannot rely\n// on the super.hashCode() method since super.getName() always return\n// the empty string in the current implemention (there's no setter)\n// so it is basically draining the performance of a hashmap lookup\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final int BYTE_MASK = 0xFF;\nprivate static final int SHORT = 2;\nprivate static final int WORD = 4;\nstatic final int BUFFER_SIZE = 512;\n/*\n* Apparently Deflater.setInput gets slowed down a lot on Sun JVMs\n* when it gets handed a really big buffer.  See\n* https://issues.apache.org/bugzilla/show_bug.cgi?id=45396\n*\n* Using a buffer size of 8 kB proved to be a good compromise\n*/\nprivate static final int DEFLATER_BLOCK_SIZE = 8192;\n\n/**\n* Compression method for deflated entries.\n*/\npublic static final int DEFLATED = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* Default compression level for deflated entries.\n*/\npublic static final int DEFAULT_COMPRESSION = Deflater.DEFAULT_COMPRESSION;\n\n/**\n* Compression method for stored entries.\n*/\npublic static final int STORED = java.util.zip.ZipEntry.STORED;\n\n/**\n* default encoding for file names and comment.\n*/\nstatic final String DEFAULT_ENCODING = ZipEncodingHelper.UTF8;\n\n/**\n* General purpose flag, which indicates that filenames are\n* written in utf-8.\n*/\npublic static final int EFS_FLAG = 1 << 11;\n\n/**\n* Current entry.\n*/\nprivate ZipArchiveEntry entry;\n\n/**\n* The file comment.\n*/\nprivate String comment = \"\";\n\n/**\n* Compression level for next entry.\n*/\nprivate int level = DEFAULT_COMPRESSION;\n\n/**\n* Has the compression level changed when compared to the last\n* entry?\n*/\nprivate boolean hasCompressionLevelChanged = false;\n\n/**\n* Default compression method for next entry.\n*/\nprivate int method = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* List of ZipArchiveEntries written so far.\n*/\nprivate final List entries = new LinkedList();\n\n/**\n* CRC instance to avoid parsing DEFLATED data twice.\n*/\nprivate final CRC32 crc = new CRC32();\n\n/**\n* Count the bytes written to out.\n*/\nprivate long written = 0;\n\n/**\n* Data for local header data\n*/\nprivate long dataStart = 0;\n\n/**\n* Offset for CRC entry in the local file header data for the\n* current entry starts here.\n*/\nprivate long localDataStart = 0;\n\n/**\n* Start of central directory.\n*/\nprivate long cdOffset = 0;\n\n/**\n* Length of central directory.\n*/\nprivate long cdLength = 0;\n\n/**\n* Helper, a 0 as ZipShort.\n*/\nprivate static final byte[] ZERO = {0, 0};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif(entry != null) {\nthrow new IOException(\"This archives contains unclosed entries.\");\n}\n\ncdOffset = written;\nfor (Iterator i = entries.iterator(); i.hasNext(); ) {\nwriteCentralFileHeader((ZipArchiveEntry) i.next());\n}\ncdLength = written - cdOffset;\nwriteCentralDirectoryEnd();\noffsets.clear();\nentries.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (entry == null) {\nreturn;\n}\n\nlong realCrc = crc.getValue();\ncrc.reset();\n\nif (entry.getMethod() == DEFLATED) {\ndef.finish();\nwhile (!def.finished()) {\ndeflate();\n}\n\nentry.setSize(ZipUtil.adjustToLong(def.getTotalIn()));\nentry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut()));\nentry.setCrc(realCrc);\n\ndef.reset();\n\nwritten += entry.getCompressedSize();\n} else if (raf == null) {\nif (entry.getCrc() != realCrc) {\nthrow new ZipException(\"bad CRC checksum for entry \"\n+ entry.getName() + \": \"\n+ Long.toHexString(entry.getCrc())\n+ \" instead of \"\n+ Long.toHexString(realCrc));\n}\n\nif (entry.getSize() != written - dataStart) {\nthrow new ZipException(\"bad size for entry \"\n+ entry.getName() + \": \"\n+ entry.getSize()\n+ \" instead of \"\n+ (written - dataStart));\n}\n} else { /* method is STORED and we used RandomAccessFile */\nlong size = written - dataStart;\n\nentry.setSize(size);\nentry.setCompressedSize(size);\nentry.setCrc(realCrc);\n}\n\n// If random access output, write the local file header containing\n// the correct CRC and compressed/uncompressed sizes\nif (raf != null) {\nlong save = raf.getFilePointer();\n\nraf.seek(localDataStart);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\nraf.seek(save);\n}\n\nwriteDataDescriptor(entry);\nentry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\ncloseArchiveEntry();\n\nentry = ((ZipArchiveEntry) archiveEntry);\nentries.add(entry);\n\nif (entry.getMethod() == -1) { // not specified\nentry.setMethod(method);\n}\n\nif (entry.getTime() == -1) { // not specified\nentry.setTime(System.currentTimeMillis());\n}\n\n// Size/CRC not required if RandomAccessFile is used\nif (entry.getMethod() == STORED && raf == null) {\nif (entry.getSize() == -1) {\nthrow new ZipException(\"uncompressed size is required for\"\n+ \" STORED method when not writing to a\"\n+ \" file\");\n}\nif (entry.getCrc() == -1) {\nthrow new ZipException(\"crc checksum is required for STORED\"\n+ \" method when not writing to a file\");\n}\nentry.setCompressedSize(entry.getSize());\n}\n\nif (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\ndef.setLevel(level);\nhasCompressionLevelChanged = false;\n}\nwriteLocalFileHeader(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nfinish();\nif (raf != null) {\nraf.close();\n}\nif (out != null) {\nout.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflate()V",
                                    "method_body": "protected final void deflate() throws IOException {\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\nboolean encodable = zipEncoding.canEncode(ze.getName());\n\nfinal ZipEncoding entryEncoding;\n\nif (!encodable && fallbackToUTF8) {\nentryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n} else {\nentryEncoding = zipEncoding;\n}\n\nByteBuffer name = entryEncoding.encode(ze.getName());\n\nif (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n|| !encodable) {\nze.addExtraField(new UnicodePathExtraField(ze.getName(),\nname.array(),\nname.arrayOffset(),\nname.limit()));\n}\n\nString comm = ze.getComment();\nif (comm != null && !\"\".equals(comm)) {\n\nboolean commentEncodable = this.zipEncoding.canEncode(comm);\n\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n|| !commentEncodable) {\nByteBuffer commentB = entryEncoding.encode(comm);\nze.addExtraField(new UnicodeCommentExtraField(comm,\ncommentB.array(),\ncommentB.arrayOffset(),\ncommentB.limit())\n);\n}\n}\n}\n\noffsets.put(ze, ZipLong.getBytes(written));\n\nwriteOut(LFH_SIG);\nwritten += WORD;\n\n//store method in local variable to prevent multiple method calls\nfinal int zipMethod = ze.getMethod();\n\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n!encodable\n&& fallbackToUTF8);\nwritten += WORD;\n\n// compression method\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\n\n// last mod. time and date\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\n\n// CRC\n// compressed length\n// uncompressed length\nlocalDataStart = written;\nif (zipMethod == DEFLATED || raf != null) {\nwriteOut(LZERO);\nwriteOut(LZERO);\nwriteOut(LZERO);\n} else {\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\n}\n// CheckStyle:MagicNumber OFF\nwritten += 12;\n// CheckStyle:MagicNumber ON\n\n// file name length\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\n\n// extra field length\nbyte[] extra = ze.getLocalFileDataExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\n\n// file name\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\n\n// extra field\nwriteOut(extra);\nwritten += extra.length;\n\ndataStart = written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeDataDescriptor(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeDataDescriptor(ZipArchiveEntry ze) throws IOException {\nif (ze.getMethod() != DEFLATED || raf != null) {\nreturn;\n}\nwriteOut(DD_SIG);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\n// CheckStyle:MagicNumber OFF\nwritten += 16;\n// CheckStyle:MagicNumber ON\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\nwriteOut(CFH_SIG);\nwritten += WORD;\n\n// version made by\n// CheckStyle:MagicNumber OFF\nwriteOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\nwritten += SHORT;\n\nfinal int zipMethod = ze.getMethod();\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n!encodable\n&& fallbackToUTF8);\nwritten += WORD;\n\n// compression method\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\n\n// last mod. time and date\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\n\n// CRC\n// compressed length\n// uncompressed length\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getCompressedSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\n// CheckStyle:MagicNumber OFF\nwritten += 12;\n// CheckStyle:MagicNumber ON\n\n// file name length\nfinal ZipEncoding entryEncoding;\n\nif (!encodable && fallbackToUTF8) {\nentryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n} else {\nentryEncoding = zipEncoding;\n}\n\nByteBuffer name = entryEncoding.encode(ze.getName());\n\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\n\n// extra field length\nbyte[] extra = ze.getCentralDirectoryExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\n\n// file comment length\nString comm = ze.getComment();\nif (comm == null) {\ncomm = \"\";\n}\n\nByteBuffer commentB = entryEncoding.encode(comm);\n\nwriteOut(ZipShort.getBytes(commentB.limit()));\nwritten += SHORT;\n\n// disk number start\nwriteOut(ZERO);\nwritten += SHORT;\n\n// internal file attributes\nwriteOut(ZipShort.getBytes(ze.getInternalAttributes()));\nwritten += SHORT;\n\n// external file attributes\nwriteOut(ZipLong.getBytes(ze.getExternalAttributes()));\nwritten += WORD;\n\n// relative offset of LFH\nwriteOut((byte[]) offsets.get(ze));\nwritten += WORD;\n\n// file name\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\n\n// extra field\nwriteOut(extra);\nwritten += extra.length;\n\n// file comment\nwriteOut(commentB.array(), commentB.arrayOffset(), commentB.limit());\nwritten += commentB.limit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryEnd()V",
                                    "method_body": "protected void writeCentralDirectoryEnd() throws IOException {\nwriteOut(EOCD_SIG);\n\n// disk numbers\nwriteOut(ZERO);\nwriteOut(ZERO);\n\n// number of entries\nbyte[] num = ZipShort.getBytes(entries.size());\nwriteOut(num);\nwriteOut(num);\n\n// length and location of CD\nwriteOut(ZipLong.getBytes(cdLength));\nwriteOut(ZipLong.getBytes(cdOffset));\n\n// ZIP file comment\nByteBuffer data = this.zipEncoding.encode(comment);\nwriteOut(ZipShort.getBytes(data.limit()));\nwriteOut(data.array(), data.arrayOffset(), data.limit());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([B)V",
                                    "method_body": "protected final void writeOut(byte[] data) throws IOException {\nwriteOut(data, 0, data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([BII)V",
                                    "method_body": "protected final void writeOut(byte[] data, int offset, int length)\nthrows IOException {\nif (raf != null) {\nraf.write(data, offset, length);\n} else {\nout.write(data, offset, length);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeVersionNeededToExtractAndGeneralPurposeBits(IZ)V",
                                    "method_body": "private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\nzipMethod,\nfinal boolean\nutfFallback)\nthrows IOException {\n\n// CheckStyle:MagicNumber OFF\nint versionNeededToExtract = 10;\nint generalPurposeFlag = (useEFS || utfFallback) ? EFS_FLAG : 0;\nif (zipMethod == DEFLATED && raf == null) {\n// requires version 2 as we are going to store length info\n// in the data descriptor\nversionNeededToExtract =  20;\n// bit3 set to signal, we use a data descriptor\ngeneralPurposeFlag |= 8;\n}\n// CheckStyle:MagicNumber ON\n\n// version needed to extract\nwriteOut(ZipShort.getBytes(versionNeededToExtract));\n// general purpose bit flag\nwriteOut(ZipShort.getBytes(generalPurposeFlag));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n//private static final int BYTE_BIT_SIZE = 8;\nprivate static final int BYTE_MASK = 0xFF;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map simpleEncodings;\n\nstatic {\nsimpleEncodings = new HashMap();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for utf-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h =\n(SimpleEncodingHolder) simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\n// check platform's default encoding\nencoding = System.getProperty(\"file.encoding\");\n}\nreturn UTF8.equalsIgnoreCase(encoding)\n|| \"utf-8\".equalsIgnoreCase(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<init>(Ljava/lang/String;)V",
                                    "method_body": "private UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
                                    "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS =\nnew UnicodeExtraFieldPolicy(\"always\");\n/**\n* Never create Unicode extra fields.\n*/\npublic static final UnicodeExtraFieldPolicy NEVER =\nnew UnicodeExtraFieldPolicy(\"never\");\n/**\n* Create Unicode extra fields for filenames that cannot be\n* encoded using the specified encoding.\n*/\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nnew UnicodeExtraFieldPolicy(\"not encodeable\");\n\nprivate final String name;\nprivate UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\n\n/** No-arg constructor */\npublic JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes(I)[B",
                                    "method_body": "public static byte[] getBytes(int value) {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n\n/**\n* Static registry of known extra fields.\n*/\nprivate static final Map implementations;\n\nstatic {\nimplementations = new HashMap();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class c) {\ntry {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n} catch (ClassCastException cc) {\nthrow new RuntimeException(c + \" doesn\\'t implement ZipExtraField\");\n} catch (InstantiationException ie) {\nthrow new RuntimeException(c + \" is not a concrete class\");\n} catch (IllegalAccessException ie) {\nthrow new RuntimeException(c + \"\\'s no-arg constructor is not public\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\n}\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n0, result, start + 2, 2);\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeCentralDirectoryData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getCentralDirectoryLength().getValue();\n}\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n0, result, start + 2, 2);\nbyte[] local = data[i].getCentralDirectoryData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate static final int      WORD = 4;\n/**\n* Standard Unix stat(2) file mode.\n*/\nprivate int mode = 0;\n/**\n* User ID.\n*/\nprivate int uid = 0;\n/**\n* Group ID.\n*/\nprivate int gid = 0;\n/**\n* File this entry points to, if it is a symbolic link.\n*\n* <p>empty string - if entry is not a symbolic link.</p>\n*/\nprivate String link = \"\";\n/**\n* Is this an entry for a directory?\n*/\nprivate boolean dirFlag = false;\n\n/**\n* Instance used to calculate checksums.\n*/\nprivate CRC32 crc = new CRC32();\n\n/** Constructor for AsiExtraField. */\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\n\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\n\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n\n/**\n* Convert a Date object to a DOS date/time field.\n* @param time the <code>Date</code> to convert\n* @return the date as a <code>ZipLong</code>\n*/\npublic static ZipLong toDosTime(Date time) {\nreturn new ZipLong(toDosTime(time.getTime()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(J)[B",
                                    "method_body": "public static byte[] toDosTime(long t) {\nCalendar c = Calendar.getInstance();\nc.setTimeInMillis(t);\n\nint year = c.get(Calendar.YEAR);\nif (year < 1980) {\nreturn (byte[]) DOS_TIME_MIN.clone(); // stop callers from changing the array\n}\nint month = c.get(Calendar.MONTH) + 1;\nlong value =  ((year - 1980) << 25)\n|         (month << 21)\n|         (c.get(Calendar.DAY_OF_MONTH) << 16)\n|         (c.get(Calendar.HOUR_OF_DAY) << 11)\n|         (c.get(Calendar.MINUTE) << 5)\n|         (c.get(Calendar.SECOND) >> 1);\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:adjustToLong(I)J",
                                    "method_body": "public static long adjustToLong(int i) {\nif (i < 0) {\nreturn 2 * ((long) Integer.MAX_VALUE) + 2 + i;\n} else {\nreturn i;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\nthrows IOException {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = new RandomAccessFile(f, \"r\");\nboolean success = false;\ntry {\nMap entriesWithoutEFS = populateFromCentralDirectory();\nresolveLocalFileHeaderData(entriesWithoutEFS);\nsuccess = true;\n} finally {\nif (!success) {\ntry {\narchive.close();\n} catch (IOException e2) {\n// swallow, throw the original exception instead\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
                                    "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\ntry {\nzipfile.close();\n} catch (IOException e) {\n//ignore\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map populateFromCentralDirectory()\nthrows IOException {\nHashMap noEFS = new HashMap();\n\npositionAtCentralDirectory();\n\nbyte[] cfh = new byte[CFH_LEN];\n\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nfinal long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\nif (sig != cfhSig && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n+ \" corrupt archive.\");\n}\nwhile (sig == cfhSig) {\narchive.readFully(cfh);\nint off = 0;\nZipArchiveEntry ze = new ZipArchiveEntry();\n\nint versionMadeBy = ZipShort.getValue(cfh, off);\noff += SHORT;\nze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\noff += SHORT; // skip version info\n\nfinal int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS =\n(generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0;\nfinal ZipEncoding entryEncoding =\nhasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\noff += SHORT;\n\nze.setMethod(ZipShort.getValue(cfh, off));\noff += SHORT;\n\n// FIXME this is actually not very cpu cycles friendly as we are converting from\n// dos to java while the underlying Sun implementation will convert\n// from java to dos time for internal storage...\nlong time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\nze.setTime(time);\noff += WORD;\n\nze.setCrc(ZipLong.getValue(cfh, off));\noff += WORD;\n\nze.setCompressedSize(ZipLong.getValue(cfh, off));\noff += WORD;\n\nze.setSize(ZipLong.getValue(cfh, off));\noff += WORD;\n\nint fileNameLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nint extraLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nint commentLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\noff += SHORT; // disk number\n\nze.setInternalAttributes(ZipShort.getValue(cfh, off));\noff += SHORT;\n\nze.setExternalAttributes(ZipLong.getValue(cfh, off));\noff += WORD;\n\nbyte[] fileName = new byte[fileNameLen];\narchive.readFully(fileName);\nze.setName(entryEncoding.decode(fileName));\n\n// LFH offset,\nOffsetEntry offset = new OffsetEntry();\noffset.headerOffset = ZipLong.getValue(cfh, off);\n// data offset will be filled later\nentries.put(ze, offset);\n\nnameMap.put(ze.getName(), ze);\n\nbyte[] cdExtraData = new byte[extraLen];\narchive.readFully(cdExtraData);\nze.setCentralDirectoryExtra(cdExtraData);\n\nbyte[] comment = new byte[commentLen];\narchive.readFully(comment);\nze.setComment(entryEncoding.decode(comment));\n\narchive.readFully(signatureBytes);\nsig = ZipLong.getValue(signatureBytes);\n\nif (!hasEFS && useUnicodeExtraFields) {\nnoEFS.put(ze, new NameAndComment(fileName, comment));\n}\n}\nreturn noEFS;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nthrows IOException {\nboolean found = false;\nlong off = archive.length() - MIN_EOCD_SIZE;\nlong stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE);\nif (off >= 0) {\narchive.seek(off);\nbyte[] sig = ZipArchiveOutputStream.EOCD_SIG;\nint curr = archive.read();\nwhile (off >= stopSearching && curr != -1) {\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\n}\n}\n}\n}\narchive.seek(--off);\ncurr = archive.read();\n}\n}\nif (!found) {\nthrow new ZipException(\"archive is not a ZIP archive\");\n}\narchive.seek(off + CFD_LOCATOR_OFFSET);\nbyte[] cfdOffset = new byte[WORD];\narchive.readFully(cfdOffset);\narchive.seek(ZipLong.getValue(cfdOffset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:startsWithLocalFileHeader()Z",
                                    "method_body": "private boolean startsWithLocalFileHeader() throws IOException {\narchive.seek(0);\nfinal byte[] start = new byte[WORD];\narchive.readFully(start);\nfor (int i = 0; i < start.length; i++) {\nif (start[i] != ZipArchiveOutputStream.LFH_SIG[i]) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipArchiveOutputStream(File file) throws IOException {\nOutputStream o = null;\nRandomAccessFile _raf = null;\ntry {\n_raf = new RandomAccessFile(file, \"rw\");\n_raf.setLength(0);\n} catch (IOException e) {\nif (_raf != null) {\ntry {\n_raf.close();\n} catch (IOException inner) {\n// ignore\n}\n_raf = null;\n}\no = new FileOutputStream(file);\n}\nout = o;\nraf = _raf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setEncoding(Ljava/lang/String;)V",
                                    "method_body": "public void setEncoding(final String encoding) {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nuseEFS &= ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setUseLanguageEncodingFlag(Z)V",
                                    "method_body": "public void setUseLanguageEncodingFlag(boolean b) {\nuseEFS = b && ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setCreateUnicodeExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveOutputStream$UnicodeExtraFieldPolicy;)V",
                                    "method_body": "public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b) {\ncreateUnicodeExtraFields = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int offset, int length) throws IOException {\nif (entry.getMethod() == DEFLATED) {\nif (length > 0) {\nif (!def.finished()) {\nif (length <= DEFLATER_BLOCK_SIZE) {\ndef.setInput(b, offset, length);\ndeflateUntilInputIsNeeded();\n} else {\nfinal int fullblocks = length / DEFLATER_BLOCK_SIZE;\nfor (int i = 0; i < fullblocks; i++) {\ndef.setInput(b, offset + i * DEFLATER_BLOCK_SIZE,\nDEFLATER_BLOCK_SIZE);\ndeflateUntilInputIsNeeded();\n}\nfinal int done = fullblocks * DEFLATER_BLOCK_SIZE;\nif (done < length) {\ndef.setInput(b, offset + done, length - done);\ndeflateUntilInputIsNeeded();\n}\n}\n}\n}\n} else {\nwriteOut(b, offset, length);\nwritten += length;\n}\ncrc.update(b, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflateUntilInputIsNeeded()V",
                                    "method_body": "private void deflateUntilInputIsNeeded() throws IOException {\nwhile (!def.needsInput()) {\ndeflate();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:addExtraField(Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void addExtraField(ZipExtraField ze) {\nif (extraFields == null) {\nextraFields = new LinkedHashMap();\n}\nextraFields.put(ze.getHeaderId(), ze);\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:appendSurrogate(Ljava/nio/ByteBuffer;C)V",
                                    "method_body": "static void appendSurrogate(ByteBuffer bb, char c) {\n\nbb.put((byte) '%');\nbb.put((byte) 'U');\n\nbb.put(HEX_DIGITS[(c >> 12)&0x0f]);\nbb.put(HEX_DIGITS[(c >> 8)&0x0f]);\nbb.put(HEX_DIGITS[(c >> 4)&0x0f]);\nbb.put(HEX_DIGITS[c & 0x0f]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:getEncoding()Lorg/apache/commons/compress/archivers/zip/Simple8BitZipEncoding;",
                                    "method_body": "public synchronized Simple8BitZipEncoding getEncoding() {\nif (this.encoding == null) {\nthis.encoding = new Simple8BitZipEncoding(this.highChars);\n}\nreturn this.encoding;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "protected AbstractUnicodeExtraField(String text, byte[] bytes, int off,\nint len) {\nCRC32 crc32 = new CRC32();\ncrc32.update(bytes, off, len);\nnameCRC32 = crc32.getValue();\n\ntry {\nunicodeName = text.getBytes(\"UTF-8\");\n} catch (UnsupportedEncodingException e) {\nthrow new RuntimeException(\"FATAL: UTF-8 encoding not supported.\",\ne);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:assembleData()V",
                                    "method_body": "private void assembleData() {\nif (unicodeName == null) {\nreturn;\n}\n\ndata = new byte[5 + unicodeName.length];\n// version 1\ndata[0] = 0x01;\nSystem.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4);\nSystem.arraycopy(unicodeName, 0, data, 5, unicodeName.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryData()[B",
                                    "method_body": "public byte[] getCentralDirectoryData() {\nif (data == null) {\nthis.assembleData();\n}\nreturn data;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getCentralDirectoryLength() {\nif (data == null) {\nassembleData();\n}\nreturn new ZipShort(data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn getCentralDirectoryData();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn getCentralDirectoryLength();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "public UnicodePathExtraField(String text, byte[] bytes, int off, int len) {\nsuper(text, bytes, off, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding:<init>([C)V",
                                    "method_body": "public Simple8BitZipEncoding(char[] highChars) {\nthis.highChars = (char[]) highChars.clone();\nList temp = new ArrayList(this.highChars.length);\n\nbyte code = 127;\n\nfor (int i = 0; i < this.highChars.length; ++i) {\ntemp.add(new Simple8BitChar(++code, this.highChars[i]));\n}\n\nCollections.sort(temp);\nthis.reverseMapping = Collections.unmodifiableList(temp);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding:canEncodeChar(C)Z",
                                    "method_body": "public boolean canEncodeChar(char c) {\n\nif (c >= 0 && c < 128) {\nreturn true;\n}\n\nSimple8BitChar r = this.encodeHighChar(c);\nreturn r != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding:pushEncodedChar(Ljava/nio/ByteBuffer;C)Z",
                                    "method_body": "public boolean pushEncodedChar(ByteBuffer bb, char c) {\n\nif (c >= 0 && c < 128) {\nbb.put((byte) c);\nreturn true;\n}\n\nSimple8BitChar r = this.encodeHighChar(c);\nif (r == null) {\nreturn false;\n}\nbb.put(r.code);\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding:encodeHighChar(C)Lorg/apache/commons/compress/archivers/zip/Simple8BitZipEncoding$Simple8BitChar;",
                                    "method_body": "private Simple8BitChar encodeHighChar(char c) {\n// for performance an simplicity, yet another reincarnation of\n// binary search...\nint i0 = 0;\nint i1 = this.reverseMapping.size();\n\nwhile (i1 > i0) {\n\nint i = i0 + (i1 - i0) / 2;\n\nSimple8BitChar m = (Simple8BitChar) this.reverseMapping.get(i);\n\nif (m.unicode == c) {\nreturn m;\n}\n\nif (m.unicode < c) {\ni0 = i + 1;\n} else {\ni1 = i;\n}\n}\n\nif (i0 >= this.reverseMapping.size()) {\nreturn null;\n}\n\nSimple8BitChar r = (Simple8BitChar) this.reverseMapping.get(i0);\n\nif (r.unicode != c) {\nreturn null;\n}\n\nreturn r;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding:canEncode(Ljava/lang/String;)Z",
                                    "method_body": "public boolean canEncode(String name) {\n\nfor (int i=0;i<name.length();++i) {\n\nchar c = name.charAt(i);\n\nif (!this.canEncodeChar(c)) {\nreturn false;\n}\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(String name) {\nByteBuffer out = ByteBuffer.allocate(name.length()\n+ 6 + (name.length() + 1) / 2);\n\nfor (int i=0;i<name.length();++i) {\n\nchar c = name.charAt(i);\n\nif (out.remaining() < 6) {\nout = ZipEncodingHelper.growBuffer(out,out.position() + 6);\n}\n\nif (!this.pushEncodedChar(out,c)) {\n\nZipEncodingHelper.appendSurrogate(out,c);\n}\n}\n\nout.limit(out.position());\nout.rewind();\nreturn out;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding$Simple8BitChar:<init>(BC)V",
                                    "method_body": "Simple8BitChar(byte code, char unicode) {\nthis.code = code;\nthis.unicode = unicode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding$Simple8BitChar:compareTo(Ljava/lang/Object;)I",
                                    "method_body": "public int compareTo(Object o) {\nSimple8BitChar a = (Simple8BitChar) o;\n\nreturn this.unicode - a.unicode;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testZipArchiveInputStreamReadsUnicodeFields",
                            "test_body": "177: public void testZipArchiveInputStreamReadsUnicodeFields()\n178: throws IOException {\n179: File file = File.createTempFile(\"unicode-test\", \".zip\");\n180: ZipFile zf = null;\n181: try {\n182: createTestFile(file, US_ASCII, false, true);\n183: zf = new ZipFile(file, US_ASCII, true);\n184: assertNotNull(zf.getEntry(ASCII_TXT));\n185: assertNotNull(zf.getEntry(EURO_FOR_DOLLAR_TXT));\n186: assertNotNull(zf.getEntry(OIL_BARREL_TXT));\n187: } finally {\n188: ZipFile.closeQuietly(zf);\n189: if (file.exists()) {\n190: file.delete();\n191: }\n192: }\n193: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getInternalAttributes()I",
                                    "method_body": "public int getInternalAttributes() {\nreturn internalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExternalAttributes()J",
                                    "method_body": "public long getExternalAttributes() {\nreturn externalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields() {\nif (extraFields == null) {\nreturn new ZipExtraField[0];\n}\nZipExtraField[] result = new ZipExtraField[extraFields.size()];\nreturn (ZipExtraField[]) extraFields.values().toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
                                    "method_body": "public byte[] getLocalFileDataExtra() {\nbyte[] extra = getExtra();\nreturn extra != null ? extra : new byte[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getCentralDirectoryExtra()[B",
                                    "method_body": "public byte[] getCentralDirectoryExtra() {\nreturn ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\n// this method has severe consequences on performance. We cannot rely\n// on the super.hashCode() method since super.getName() always return\n// the empty string in the current implemention (there's no setter)\n// so it is basically draining the performance of a hashmap lookup\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final int BYTE_MASK = 0xFF;\nprivate static final int SHORT = 2;\nprivate static final int WORD = 4;\nstatic final int BUFFER_SIZE = 512;\n/*\n* Apparently Deflater.setInput gets slowed down a lot on Sun JVMs\n* when it gets handed a really big buffer.  See\n* https://issues.apache.org/bugzilla/show_bug.cgi?id=45396\n*\n* Using a buffer size of 8 kB proved to be a good compromise\n*/\nprivate static final int DEFLATER_BLOCK_SIZE = 8192;\n\n/**\n* Compression method for deflated entries.\n*/\npublic static final int DEFLATED = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* Default compression level for deflated entries.\n*/\npublic static final int DEFAULT_COMPRESSION = Deflater.DEFAULT_COMPRESSION;\n\n/**\n* Compression method for stored entries.\n*/\npublic static final int STORED = java.util.zip.ZipEntry.STORED;\n\n/**\n* default encoding for file names and comment.\n*/\nstatic final String DEFAULT_ENCODING = ZipEncodingHelper.UTF8;\n\n/**\n* General purpose flag, which indicates that filenames are\n* written in utf-8.\n*/\npublic static final int EFS_FLAG = 1 << 11;\n\n/**\n* Current entry.\n*/\nprivate ZipArchiveEntry entry;\n\n/**\n* The file comment.\n*/\nprivate String comment = \"\";\n\n/**\n* Compression level for next entry.\n*/\nprivate int level = DEFAULT_COMPRESSION;\n\n/**\n* Has the compression level changed when compared to the last\n* entry?\n*/\nprivate boolean hasCompressionLevelChanged = false;\n\n/**\n* Default compression method for next entry.\n*/\nprivate int method = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* List of ZipArchiveEntries written so far.\n*/\nprivate final List entries = new LinkedList();\n\n/**\n* CRC instance to avoid parsing DEFLATED data twice.\n*/\nprivate final CRC32 crc = new CRC32();\n\n/**\n* Count the bytes written to out.\n*/\nprivate long written = 0;\n\n/**\n* Data for local header data\n*/\nprivate long dataStart = 0;\n\n/**\n* Offset for CRC entry in the local file header data for the\n* current entry starts here.\n*/\nprivate long localDataStart = 0;\n\n/**\n* Start of central directory.\n*/\nprivate long cdOffset = 0;\n\n/**\n* Length of central directory.\n*/\nprivate long cdLength = 0;\n\n/**\n* Helper, a 0 as ZipShort.\n*/\nprivate static final byte[] ZERO = {0, 0};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif(entry != null) {\nthrow new IOException(\"This archives contains unclosed entries.\");\n}\n\ncdOffset = written;\nfor (Iterator i = entries.iterator(); i.hasNext(); ) {\nwriteCentralFileHeader((ZipArchiveEntry) i.next());\n}\ncdLength = written - cdOffset;\nwriteCentralDirectoryEnd();\noffsets.clear();\nentries.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (entry == null) {\nreturn;\n}\n\nlong realCrc = crc.getValue();\ncrc.reset();\n\nif (entry.getMethod() == DEFLATED) {\ndef.finish();\nwhile (!def.finished()) {\ndeflate();\n}\n\nentry.setSize(ZipUtil.adjustToLong(def.getTotalIn()));\nentry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut()));\nentry.setCrc(realCrc);\n\ndef.reset();\n\nwritten += entry.getCompressedSize();\n} else if (raf == null) {\nif (entry.getCrc() != realCrc) {\nthrow new ZipException(\"bad CRC checksum for entry \"\n+ entry.getName() + \": \"\n+ Long.toHexString(entry.getCrc())\n+ \" instead of \"\n+ Long.toHexString(realCrc));\n}\n\nif (entry.getSize() != written - dataStart) {\nthrow new ZipException(\"bad size for entry \"\n+ entry.getName() + \": \"\n+ entry.getSize()\n+ \" instead of \"\n+ (written - dataStart));\n}\n} else { /* method is STORED and we used RandomAccessFile */\nlong size = written - dataStart;\n\nentry.setSize(size);\nentry.setCompressedSize(size);\nentry.setCrc(realCrc);\n}\n\n// If random access output, write the local file header containing\n// the correct CRC and compressed/uncompressed sizes\nif (raf != null) {\nlong save = raf.getFilePointer();\n\nraf.seek(localDataStart);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\nraf.seek(save);\n}\n\nwriteDataDescriptor(entry);\nentry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\ncloseArchiveEntry();\n\nentry = ((ZipArchiveEntry) archiveEntry);\nentries.add(entry);\n\nif (entry.getMethod() == -1) { // not specified\nentry.setMethod(method);\n}\n\nif (entry.getTime() == -1) { // not specified\nentry.setTime(System.currentTimeMillis());\n}\n\n// Size/CRC not required if RandomAccessFile is used\nif (entry.getMethod() == STORED && raf == null) {\nif (entry.getSize() == -1) {\nthrow new ZipException(\"uncompressed size is required for\"\n+ \" STORED method when not writing to a\"\n+ \" file\");\n}\nif (entry.getCrc() == -1) {\nthrow new ZipException(\"crc checksum is required for STORED\"\n+ \" method when not writing to a file\");\n}\nentry.setCompressedSize(entry.getSize());\n}\n\nif (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\ndef.setLevel(level);\nhasCompressionLevelChanged = false;\n}\nwriteLocalFileHeader(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nfinish();\nif (raf != null) {\nraf.close();\n}\nif (out != null) {\nout.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflate()V",
                                    "method_body": "protected final void deflate() throws IOException {\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\nboolean encodable = zipEncoding.canEncode(ze.getName());\n\nfinal ZipEncoding entryEncoding;\n\nif (!encodable && fallbackToUTF8) {\nentryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n} else {\nentryEncoding = zipEncoding;\n}\n\nByteBuffer name = entryEncoding.encode(ze.getName());\n\nif (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n|| !encodable) {\nze.addExtraField(new UnicodePathExtraField(ze.getName(),\nname.array(),\nname.arrayOffset(),\nname.limit()));\n}\n\nString comm = ze.getComment();\nif (comm != null && !\"\".equals(comm)) {\n\nboolean commentEncodable = this.zipEncoding.canEncode(comm);\n\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n|| !commentEncodable) {\nByteBuffer commentB = entryEncoding.encode(comm);\nze.addExtraField(new UnicodeCommentExtraField(comm,\ncommentB.array(),\ncommentB.arrayOffset(),\ncommentB.limit())\n);\n}\n}\n}\n\noffsets.put(ze, ZipLong.getBytes(written));\n\nwriteOut(LFH_SIG);\nwritten += WORD;\n\n//store method in local variable to prevent multiple method calls\nfinal int zipMethod = ze.getMethod();\n\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n!encodable\n&& fallbackToUTF8);\nwritten += WORD;\n\n// compression method\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\n\n// last mod. time and date\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\n\n// CRC\n// compressed length\n// uncompressed length\nlocalDataStart = written;\nif (zipMethod == DEFLATED || raf != null) {\nwriteOut(LZERO);\nwriteOut(LZERO);\nwriteOut(LZERO);\n} else {\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\n}\n// CheckStyle:MagicNumber OFF\nwritten += 12;\n// CheckStyle:MagicNumber ON\n\n// file name length\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\n\n// extra field length\nbyte[] extra = ze.getLocalFileDataExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\n\n// file name\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\n\n// extra field\nwriteOut(extra);\nwritten += extra.length;\n\ndataStart = written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeDataDescriptor(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeDataDescriptor(ZipArchiveEntry ze) throws IOException {\nif (ze.getMethod() != DEFLATED || raf != null) {\nreturn;\n}\nwriteOut(DD_SIG);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\n// CheckStyle:MagicNumber OFF\nwritten += 16;\n// CheckStyle:MagicNumber ON\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\nwriteOut(CFH_SIG);\nwritten += WORD;\n\n// version made by\n// CheckStyle:MagicNumber OFF\nwriteOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\nwritten += SHORT;\n\nfinal int zipMethod = ze.getMethod();\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n!encodable\n&& fallbackToUTF8);\nwritten += WORD;\n\n// compression method\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\n\n// last mod. time and date\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\n\n// CRC\n// compressed length\n// uncompressed length\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getCompressedSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\n// CheckStyle:MagicNumber OFF\nwritten += 12;\n// CheckStyle:MagicNumber ON\n\n// file name length\nfinal ZipEncoding entryEncoding;\n\nif (!encodable && fallbackToUTF8) {\nentryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n} else {\nentryEncoding = zipEncoding;\n}\n\nByteBuffer name = entryEncoding.encode(ze.getName());\n\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\n\n// extra field length\nbyte[] extra = ze.getCentralDirectoryExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\n\n// file comment length\nString comm = ze.getComment();\nif (comm == null) {\ncomm = \"\";\n}\n\nByteBuffer commentB = entryEncoding.encode(comm);\n\nwriteOut(ZipShort.getBytes(commentB.limit()));\nwritten += SHORT;\n\n// disk number start\nwriteOut(ZERO);\nwritten += SHORT;\n\n// internal file attributes\nwriteOut(ZipShort.getBytes(ze.getInternalAttributes()));\nwritten += SHORT;\n\n// external file attributes\nwriteOut(ZipLong.getBytes(ze.getExternalAttributes()));\nwritten += WORD;\n\n// relative offset of LFH\nwriteOut((byte[]) offsets.get(ze));\nwritten += WORD;\n\n// file name\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\n\n// extra field\nwriteOut(extra);\nwritten += extra.length;\n\n// file comment\nwriteOut(commentB.array(), commentB.arrayOffset(), commentB.limit());\nwritten += commentB.limit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryEnd()V",
                                    "method_body": "protected void writeCentralDirectoryEnd() throws IOException {\nwriteOut(EOCD_SIG);\n\n// disk numbers\nwriteOut(ZERO);\nwriteOut(ZERO);\n\n// number of entries\nbyte[] num = ZipShort.getBytes(entries.size());\nwriteOut(num);\nwriteOut(num);\n\n// length and location of CD\nwriteOut(ZipLong.getBytes(cdLength));\nwriteOut(ZipLong.getBytes(cdOffset));\n\n// ZIP file comment\nByteBuffer data = this.zipEncoding.encode(comment);\nwriteOut(ZipShort.getBytes(data.limit()));\nwriteOut(data.array(), data.arrayOffset(), data.limit());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([B)V",
                                    "method_body": "protected final void writeOut(byte[] data) throws IOException {\nwriteOut(data, 0, data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([BII)V",
                                    "method_body": "protected final void writeOut(byte[] data, int offset, int length)\nthrows IOException {\nif (raf != null) {\nraf.write(data, offset, length);\n} else {\nout.write(data, offset, length);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeVersionNeededToExtractAndGeneralPurposeBits(IZ)V",
                                    "method_body": "private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\nzipMethod,\nfinal boolean\nutfFallback)\nthrows IOException {\n\n// CheckStyle:MagicNumber OFF\nint versionNeededToExtract = 10;\nint generalPurposeFlag = (useEFS || utfFallback) ? EFS_FLAG : 0;\nif (zipMethod == DEFLATED && raf == null) {\n// requires version 2 as we are going to store length info\n// in the data descriptor\nversionNeededToExtract =  20;\n// bit3 set to signal, we use a data descriptor\ngeneralPurposeFlag |= 8;\n}\n// CheckStyle:MagicNumber ON\n\n// version needed to extract\nwriteOut(ZipShort.getBytes(versionNeededToExtract));\n// general purpose bit flag\nwriteOut(ZipShort.getBytes(generalPurposeFlag));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n//private static final int BYTE_BIT_SIZE = 8;\nprivate static final int BYTE_MASK = 0xFF;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map simpleEncodings;\n\nstatic {\nsimpleEncodings = new HashMap();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for utf-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h =\n(SimpleEncodingHolder) simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\n// check platform's default encoding\nencoding = System.getProperty(\"file.encoding\");\n}\nreturn UTF8.equalsIgnoreCase(encoding)\n|| \"utf-8\".equalsIgnoreCase(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<init>(Ljava/lang/String;)V",
                                    "method_body": "private UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
                                    "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS =\nnew UnicodeExtraFieldPolicy(\"always\");\n/**\n* Never create Unicode extra fields.\n*/\npublic static final UnicodeExtraFieldPolicy NEVER =\nnew UnicodeExtraFieldPolicy(\"never\");\n/**\n* Create Unicode extra fields for filenames that cannot be\n* encoded using the specified encoding.\n*/\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nnew UnicodeExtraFieldPolicy(\"not encodeable\");\n\nprivate final String name;\nprivate UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\n\n/** No-arg constructor */\npublic JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes(I)[B",
                                    "method_body": "public static byte[] getBytes(int value) {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n\n/**\n* Static registry of known extra fields.\n*/\nprivate static final Map implementations;\n\nstatic {\nimplementations = new HashMap();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class c) {\ntry {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n} catch (ClassCastException cc) {\nthrow new RuntimeException(c + \" doesn\\'t implement ZipExtraField\");\n} catch (InstantiationException ie) {\nthrow new RuntimeException(c + \" is not a concrete class\");\n} catch (IllegalAccessException ie) {\nthrow new RuntimeException(c + \"\\'s no-arg constructor is not public\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\n}\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n0, result, start + 2, 2);\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeCentralDirectoryData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getCentralDirectoryLength().getValue();\n}\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n0, result, start + 2, 2);\nbyte[] local = data[i].getCentralDirectoryData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate static final int      WORD = 4;\n/**\n* Standard Unix stat(2) file mode.\n*/\nprivate int mode = 0;\n/**\n* User ID.\n*/\nprivate int uid = 0;\n/**\n* Group ID.\n*/\nprivate int gid = 0;\n/**\n* File this entry points to, if it is a symbolic link.\n*\n* <p>empty string - if entry is not a symbolic link.</p>\n*/\nprivate String link = \"\";\n/**\n* Is this an entry for a directory?\n*/\nprivate boolean dirFlag = false;\n\n/**\n* Instance used to calculate checksums.\n*/\nprivate CRC32 crc = new CRC32();\n\n/** Constructor for AsiExtraField. */\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\n\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\n\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n\n/**\n* Convert a Date object to a DOS date/time field.\n* @param time the <code>Date</code> to convert\n* @return the date as a <code>ZipLong</code>\n*/\npublic static ZipLong toDosTime(Date time) {\nreturn new ZipLong(toDosTime(time.getTime()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(J)[B",
                                    "method_body": "public static byte[] toDosTime(long t) {\nCalendar c = Calendar.getInstance();\nc.setTimeInMillis(t);\n\nint year = c.get(Calendar.YEAR);\nif (year < 1980) {\nreturn (byte[]) DOS_TIME_MIN.clone(); // stop callers from changing the array\n}\nint month = c.get(Calendar.MONTH) + 1;\nlong value =  ((year - 1980) << 25)\n|         (month << 21)\n|         (c.get(Calendar.DAY_OF_MONTH) << 16)\n|         (c.get(Calendar.HOUR_OF_DAY) << 11)\n|         (c.get(Calendar.MINUTE) << 5)\n|         (c.get(Calendar.SECOND) >> 1);\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:adjustToLong(I)J",
                                    "method_body": "public static long adjustToLong(int i) {\nif (i < 0) {\nreturn 2 * ((long) Integer.MAX_VALUE) + 2 + i;\n} else {\nreturn i;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\nthrows IOException {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = new RandomAccessFile(f, \"r\");\nboolean success = false;\ntry {\nMap entriesWithoutEFS = populateFromCentralDirectory();\nresolveLocalFileHeaderData(entriesWithoutEFS);\nsuccess = true;\n} finally {\nif (!success) {\ntry {\narchive.close();\n} catch (IOException e2) {\n// swallow, throw the original exception instead\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
                                    "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\ntry {\nzipfile.close();\n} catch (IOException e) {\n//ignore\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map populateFromCentralDirectory()\nthrows IOException {\nHashMap noEFS = new HashMap();\n\npositionAtCentralDirectory();\n\nbyte[] cfh = new byte[CFH_LEN];\n\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nfinal long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\nif (sig != cfhSig && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n+ \" corrupt archive.\");\n}\nwhile (sig == cfhSig) {\narchive.readFully(cfh);\nint off = 0;\nZipArchiveEntry ze = new ZipArchiveEntry();\n\nint versionMadeBy = ZipShort.getValue(cfh, off);\noff += SHORT;\nze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\noff += SHORT; // skip version info\n\nfinal int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS =\n(generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0;\nfinal ZipEncoding entryEncoding =\nhasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\noff += SHORT;\n\nze.setMethod(ZipShort.getValue(cfh, off));\noff += SHORT;\n\n// FIXME this is actually not very cpu cycles friendly as we are converting from\n// dos to java while the underlying Sun implementation will convert\n// from java to dos time for internal storage...\nlong time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\nze.setTime(time);\noff += WORD;\n\nze.setCrc(ZipLong.getValue(cfh, off));\noff += WORD;\n\nze.setCompressedSize(ZipLong.getValue(cfh, off));\noff += WORD;\n\nze.setSize(ZipLong.getValue(cfh, off));\noff += WORD;\n\nint fileNameLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nint extraLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nint commentLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\noff += SHORT; // disk number\n\nze.setInternalAttributes(ZipShort.getValue(cfh, off));\noff += SHORT;\n\nze.setExternalAttributes(ZipLong.getValue(cfh, off));\noff += WORD;\n\nbyte[] fileName = new byte[fileNameLen];\narchive.readFully(fileName);\nze.setName(entryEncoding.decode(fileName));\n\n// LFH offset,\nOffsetEntry offset = new OffsetEntry();\noffset.headerOffset = ZipLong.getValue(cfh, off);\n// data offset will be filled later\nentries.put(ze, offset);\n\nnameMap.put(ze.getName(), ze);\n\nbyte[] cdExtraData = new byte[extraLen];\narchive.readFully(cdExtraData);\nze.setCentralDirectoryExtra(cdExtraData);\n\nbyte[] comment = new byte[commentLen];\narchive.readFully(comment);\nze.setComment(entryEncoding.decode(comment));\n\narchive.readFully(signatureBytes);\nsig = ZipLong.getValue(signatureBytes);\n\nif (!hasEFS && useUnicodeExtraFields) {\nnoEFS.put(ze, new NameAndComment(fileName, comment));\n}\n}\nreturn noEFS;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nthrows IOException {\nboolean found = false;\nlong off = archive.length() - MIN_EOCD_SIZE;\nlong stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE);\nif (off >= 0) {\narchive.seek(off);\nbyte[] sig = ZipArchiveOutputStream.EOCD_SIG;\nint curr = archive.read();\nwhile (off >= stopSearching && curr != -1) {\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\n}\n}\n}\n}\narchive.seek(--off);\ncurr = archive.read();\n}\n}\nif (!found) {\nthrow new ZipException(\"archive is not a ZIP archive\");\n}\narchive.seek(off + CFD_LOCATOR_OFFSET);\nbyte[] cfdOffset = new byte[WORD];\narchive.readFully(cfdOffset);\narchive.seek(ZipLong.getValue(cfdOffset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:startsWithLocalFileHeader()Z",
                                    "method_body": "private boolean startsWithLocalFileHeader() throws IOException {\narchive.seek(0);\nfinal byte[] start = new byte[WORD];\narchive.readFully(start);\nfor (int i = 0; i < start.length; i++) {\nif (start[i] != ZipArchiveOutputStream.LFH_SIG[i]) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipArchiveOutputStream(File file) throws IOException {\nOutputStream o = null;\nRandomAccessFile _raf = null;\ntry {\n_raf = new RandomAccessFile(file, \"rw\");\n_raf.setLength(0);\n} catch (IOException e) {\nif (_raf != null) {\ntry {\n_raf.close();\n} catch (IOException inner) {\n// ignore\n}\n_raf = null;\n}\no = new FileOutputStream(file);\n}\nout = o;\nraf = _raf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setEncoding(Ljava/lang/String;)V",
                                    "method_body": "public void setEncoding(final String encoding) {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nuseEFS &= ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setUseLanguageEncodingFlag(Z)V",
                                    "method_body": "public void setUseLanguageEncodingFlag(boolean b) {\nuseEFS = b && ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setCreateUnicodeExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveOutputStream$UnicodeExtraFieldPolicy;)V",
                                    "method_body": "public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b) {\ncreateUnicodeExtraFields = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int offset, int length) throws IOException {\nif (entry.getMethod() == DEFLATED) {\nif (length > 0) {\nif (!def.finished()) {\nif (length <= DEFLATER_BLOCK_SIZE) {\ndef.setInput(b, offset, length);\ndeflateUntilInputIsNeeded();\n} else {\nfinal int fullblocks = length / DEFLATER_BLOCK_SIZE;\nfor (int i = 0; i < fullblocks; i++) {\ndef.setInput(b, offset + i * DEFLATER_BLOCK_SIZE,\nDEFLATER_BLOCK_SIZE);\ndeflateUntilInputIsNeeded();\n}\nfinal int done = fullblocks * DEFLATER_BLOCK_SIZE;\nif (done < length) {\ndef.setInput(b, offset + done, length - done);\ndeflateUntilInputIsNeeded();\n}\n}\n}\n}\n} else {\nwriteOut(b, offset, length);\nwritten += length;\n}\ncrc.update(b, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflateUntilInputIsNeeded()V",
                                    "method_body": "private void deflateUntilInputIsNeeded() throws IOException {\nwhile (!def.needsInput()) {\ndeflate();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:addExtraField(Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void addExtraField(ZipExtraField ze) {\nif (extraFields == null) {\nextraFields = new LinkedHashMap();\n}\nextraFields.put(ze.getHeaderId(), ze);\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:appendSurrogate(Ljava/nio/ByteBuffer;C)V",
                                    "method_body": "static void appendSurrogate(ByteBuffer bb, char c) {\n\nbb.put((byte) '%');\nbb.put((byte) 'U');\n\nbb.put(HEX_DIGITS[(c >> 12)&0x0f]);\nbb.put(HEX_DIGITS[(c >> 8)&0x0f]);\nbb.put(HEX_DIGITS[(c >> 4)&0x0f]);\nbb.put(HEX_DIGITS[c & 0x0f]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "protected AbstractUnicodeExtraField(String text, byte[] bytes, int off,\nint len) {\nCRC32 crc32 = new CRC32();\ncrc32.update(bytes, off, len);\nnameCRC32 = crc32.getValue();\n\ntry {\nunicodeName = text.getBytes(\"UTF-8\");\n} catch (UnsupportedEncodingException e) {\nthrow new RuntimeException(\"FATAL: UTF-8 encoding not supported.\",\ne);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:assembleData()V",
                                    "method_body": "private void assembleData() {\nif (unicodeName == null) {\nreturn;\n}\n\ndata = new byte[5 + unicodeName.length];\n// version 1\ndata[0] = 0x01;\nSystem.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4);\nSystem.arraycopy(unicodeName, 0, data, 5, unicodeName.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryData()[B",
                                    "method_body": "public byte[] getCentralDirectoryData() {\nif (data == null) {\nthis.assembleData();\n}\nreturn data;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getCentralDirectoryLength() {\nif (data == null) {\nassembleData();\n}\nreturn new ZipShort(data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn getCentralDirectoryData();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn getCentralDirectoryLength();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "public UnicodePathExtraField(String text, byte[] bytes, int off, int len) {\nsuper(text, bytes, off, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:growBuffer(Ljava/nio/ByteBuffer;I)Ljava/nio/ByteBuffer;",
                                    "method_body": "static ByteBuffer growBuffer(ByteBuffer b, int newCapacity) {\nb.limit(b.position());\nb.rewind();\n\nint c2 = b.capacity() * 2;\nByteBuffer on = ByteBuffer.allocate(c2 < newCapacity ? newCapacity : c2);\n\non.put(b);\nreturn on;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:<init>(Ljava/nio/charset/Charset;)V",
                                    "method_body": "public NioZipEncoding(Charset charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:canEncode(Ljava/lang/String;)Z",
                                    "method_body": "public boolean canEncode(String name) {\nCharsetEncoder enc = this.charset.newEncoder();\nenc.onMalformedInput(CodingErrorAction.REPORT);\nenc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\nreturn enc.canEncode(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(String name) {\nCharsetEncoder enc = this.charset.newEncoder();\n\nenc.onMalformedInput(CodingErrorAction.REPORT);\nenc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\nCharBuffer cb = CharBuffer.wrap(name);\nByteBuffer out = ByteBuffer.allocate(name.length()\n+ (name.length() + 1) / 2);\n\nwhile (cb.remaining() > 0) {\nCoderResult res = enc.encode(cb, out,true);\n\nif (res.isUnmappable() || res.isMalformed()) {\n\n// write the unmappable characters in utf-16\n// pseudo-URL encoding style to ByteBuffer.\nif (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, out.position()\n+ res.length() * 6);\n}\n\nfor (int i=0; i<res.length(); ++i) {\nZipEncodingHelper.appendSurrogate(out,cb.get());\n}\n\n} else if (res.isOverflow()) {\n\nout = ZipEncodingHelper.growBuffer(out, 0);\n\n} else if (res.isUnderflow()) {\n\nenc.flush(out);\nbreak;\n\n}\n}\n\nout.limit(out.position());\nout.rewind();\nreturn out;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testUtf8FileRoundtripImplicitUnicodeExtra",
                            "test_body": "63: public void testUtf8FileRoundtripImplicitUnicodeExtra()\n64: throws IOException {\n65: testFileRoundtrip(UTF_8, true, false);\n66: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getInternalAttributes()I",
                                    "method_body": "public int getInternalAttributes() {\nreturn internalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExternalAttributes()J",
                                    "method_body": "public long getExternalAttributes() {\nreturn externalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields() {\nif (extraFields == null) {\nreturn new ZipExtraField[0];\n}\nZipExtraField[] result = new ZipExtraField[extraFields.size()];\nreturn (ZipExtraField[]) extraFields.values().toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
                                    "method_body": "public byte[] getLocalFileDataExtra() {\nbyte[] extra = getExtra();\nreturn extra != null ? extra : new byte[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getCentralDirectoryExtra()[B",
                                    "method_body": "public byte[] getCentralDirectoryExtra() {\nreturn ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\n// this method has severe consequences on performance. We cannot rely\n// on the super.hashCode() method since super.getName() always return\n// the empty string in the current implemention (there's no setter)\n// so it is basically draining the performance of a hashmap lookup\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final int BYTE_MASK = 0xFF;\nprivate static final int SHORT = 2;\nprivate static final int WORD = 4;\nstatic final int BUFFER_SIZE = 512;\n/*\n* Apparently Deflater.setInput gets slowed down a lot on Sun JVMs\n* when it gets handed a really big buffer.  See\n* https://issues.apache.org/bugzilla/show_bug.cgi?id=45396\n*\n* Using a buffer size of 8 kB proved to be a good compromise\n*/\nprivate static final int DEFLATER_BLOCK_SIZE = 8192;\n\n/**\n* Compression method for deflated entries.\n*/\npublic static final int DEFLATED = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* Default compression level for deflated entries.\n*/\npublic static final int DEFAULT_COMPRESSION = Deflater.DEFAULT_COMPRESSION;\n\n/**\n* Compression method for stored entries.\n*/\npublic static final int STORED = java.util.zip.ZipEntry.STORED;\n\n/**\n* default encoding for file names and comment.\n*/\nstatic final String DEFAULT_ENCODING = ZipEncodingHelper.UTF8;\n\n/**\n* General purpose flag, which indicates that filenames are\n* written in utf-8.\n*/\npublic static final int EFS_FLAG = 1 << 11;\n\n/**\n* Current entry.\n*/\nprivate ZipArchiveEntry entry;\n\n/**\n* The file comment.\n*/\nprivate String comment = \"\";\n\n/**\n* Compression level for next entry.\n*/\nprivate int level = DEFAULT_COMPRESSION;\n\n/**\n* Has the compression level changed when compared to the last\n* entry?\n*/\nprivate boolean hasCompressionLevelChanged = false;\n\n/**\n* Default compression method for next entry.\n*/\nprivate int method = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* List of ZipArchiveEntries written so far.\n*/\nprivate final List entries = new LinkedList();\n\n/**\n* CRC instance to avoid parsing DEFLATED data twice.\n*/\nprivate final CRC32 crc = new CRC32();\n\n/**\n* Count the bytes written to out.\n*/\nprivate long written = 0;\n\n/**\n* Data for local header data\n*/\nprivate long dataStart = 0;\n\n/**\n* Offset for CRC entry in the local file header data for the\n* current entry starts here.\n*/\nprivate long localDataStart = 0;\n\n/**\n* Start of central directory.\n*/\nprivate long cdOffset = 0;\n\n/**\n* Length of central directory.\n*/\nprivate long cdLength = 0;\n\n/**\n* Helper, a 0 as ZipShort.\n*/\nprivate static final byte[] ZERO = {0, 0};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif(entry != null) {\nthrow new IOException(\"This archives contains unclosed entries.\");\n}\n\ncdOffset = written;\nfor (Iterator i = entries.iterator(); i.hasNext(); ) {\nwriteCentralFileHeader((ZipArchiveEntry) i.next());\n}\ncdLength = written - cdOffset;\nwriteCentralDirectoryEnd();\noffsets.clear();\nentries.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (entry == null) {\nreturn;\n}\n\nlong realCrc = crc.getValue();\ncrc.reset();\n\nif (entry.getMethod() == DEFLATED) {\ndef.finish();\nwhile (!def.finished()) {\ndeflate();\n}\n\nentry.setSize(ZipUtil.adjustToLong(def.getTotalIn()));\nentry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut()));\nentry.setCrc(realCrc);\n\ndef.reset();\n\nwritten += entry.getCompressedSize();\n} else if (raf == null) {\nif (entry.getCrc() != realCrc) {\nthrow new ZipException(\"bad CRC checksum for entry \"\n+ entry.getName() + \": \"\n+ Long.toHexString(entry.getCrc())\n+ \" instead of \"\n+ Long.toHexString(realCrc));\n}\n\nif (entry.getSize() != written - dataStart) {\nthrow new ZipException(\"bad size for entry \"\n+ entry.getName() + \": \"\n+ entry.getSize()\n+ \" instead of \"\n+ (written - dataStart));\n}\n} else { /* method is STORED and we used RandomAccessFile */\nlong size = written - dataStart;\n\nentry.setSize(size);\nentry.setCompressedSize(size);\nentry.setCrc(realCrc);\n}\n\n// If random access output, write the local file header containing\n// the correct CRC and compressed/uncompressed sizes\nif (raf != null) {\nlong save = raf.getFilePointer();\n\nraf.seek(localDataStart);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\nraf.seek(save);\n}\n\nwriteDataDescriptor(entry);\nentry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\ncloseArchiveEntry();\n\nentry = ((ZipArchiveEntry) archiveEntry);\nentries.add(entry);\n\nif (entry.getMethod() == -1) { // not specified\nentry.setMethod(method);\n}\n\nif (entry.getTime() == -1) { // not specified\nentry.setTime(System.currentTimeMillis());\n}\n\n// Size/CRC not required if RandomAccessFile is used\nif (entry.getMethod() == STORED && raf == null) {\nif (entry.getSize() == -1) {\nthrow new ZipException(\"uncompressed size is required for\"\n+ \" STORED method when not writing to a\"\n+ \" file\");\n}\nif (entry.getCrc() == -1) {\nthrow new ZipException(\"crc checksum is required for STORED\"\n+ \" method when not writing to a file\");\n}\nentry.setCompressedSize(entry.getSize());\n}\n\nif (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\ndef.setLevel(level);\nhasCompressionLevelChanged = false;\n}\nwriteLocalFileHeader(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nfinish();\nif (raf != null) {\nraf.close();\n}\nif (out != null) {\nout.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflate()V",
                                    "method_body": "protected final void deflate() throws IOException {\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\nboolean encodable = zipEncoding.canEncode(ze.getName());\n\nfinal ZipEncoding entryEncoding;\n\nif (!encodable && fallbackToUTF8) {\nentryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n} else {\nentryEncoding = zipEncoding;\n}\n\nByteBuffer name = entryEncoding.encode(ze.getName());\n\nif (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n|| !encodable) {\nze.addExtraField(new UnicodePathExtraField(ze.getName(),\nname.array(),\nname.arrayOffset(),\nname.limit()));\n}\n\nString comm = ze.getComment();\nif (comm != null && !\"\".equals(comm)) {\n\nboolean commentEncodable = this.zipEncoding.canEncode(comm);\n\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n|| !commentEncodable) {\nByteBuffer commentB = entryEncoding.encode(comm);\nze.addExtraField(new UnicodeCommentExtraField(comm,\ncommentB.array(),\ncommentB.arrayOffset(),\ncommentB.limit())\n);\n}\n}\n}\n\noffsets.put(ze, ZipLong.getBytes(written));\n\nwriteOut(LFH_SIG);\nwritten += WORD;\n\n//store method in local variable to prevent multiple method calls\nfinal int zipMethod = ze.getMethod();\n\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n!encodable\n&& fallbackToUTF8);\nwritten += WORD;\n\n// compression method\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\n\n// last mod. time and date\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\n\n// CRC\n// compressed length\n// uncompressed length\nlocalDataStart = written;\nif (zipMethod == DEFLATED || raf != null) {\nwriteOut(LZERO);\nwriteOut(LZERO);\nwriteOut(LZERO);\n} else {\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\n}\n// CheckStyle:MagicNumber OFF\nwritten += 12;\n// CheckStyle:MagicNumber ON\n\n// file name length\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\n\n// extra field length\nbyte[] extra = ze.getLocalFileDataExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\n\n// file name\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\n\n// extra field\nwriteOut(extra);\nwritten += extra.length;\n\ndataStart = written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeDataDescriptor(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeDataDescriptor(ZipArchiveEntry ze) throws IOException {\nif (ze.getMethod() != DEFLATED || raf != null) {\nreturn;\n}\nwriteOut(DD_SIG);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\n// CheckStyle:MagicNumber OFF\nwritten += 16;\n// CheckStyle:MagicNumber ON\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\nwriteOut(CFH_SIG);\nwritten += WORD;\n\n// version made by\n// CheckStyle:MagicNumber OFF\nwriteOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\nwritten += SHORT;\n\nfinal int zipMethod = ze.getMethod();\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n!encodable\n&& fallbackToUTF8);\nwritten += WORD;\n\n// compression method\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\n\n// last mod. time and date\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\n\n// CRC\n// compressed length\n// uncompressed length\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getCompressedSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\n// CheckStyle:MagicNumber OFF\nwritten += 12;\n// CheckStyle:MagicNumber ON\n\n// file name length\nfinal ZipEncoding entryEncoding;\n\nif (!encodable && fallbackToUTF8) {\nentryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n} else {\nentryEncoding = zipEncoding;\n}\n\nByteBuffer name = entryEncoding.encode(ze.getName());\n\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\n\n// extra field length\nbyte[] extra = ze.getCentralDirectoryExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\n\n// file comment length\nString comm = ze.getComment();\nif (comm == null) {\ncomm = \"\";\n}\n\nByteBuffer commentB = entryEncoding.encode(comm);\n\nwriteOut(ZipShort.getBytes(commentB.limit()));\nwritten += SHORT;\n\n// disk number start\nwriteOut(ZERO);\nwritten += SHORT;\n\n// internal file attributes\nwriteOut(ZipShort.getBytes(ze.getInternalAttributes()));\nwritten += SHORT;\n\n// external file attributes\nwriteOut(ZipLong.getBytes(ze.getExternalAttributes()));\nwritten += WORD;\n\n// relative offset of LFH\nwriteOut((byte[]) offsets.get(ze));\nwritten += WORD;\n\n// file name\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\n\n// extra field\nwriteOut(extra);\nwritten += extra.length;\n\n// file comment\nwriteOut(commentB.array(), commentB.arrayOffset(), commentB.limit());\nwritten += commentB.limit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryEnd()V",
                                    "method_body": "protected void writeCentralDirectoryEnd() throws IOException {\nwriteOut(EOCD_SIG);\n\n// disk numbers\nwriteOut(ZERO);\nwriteOut(ZERO);\n\n// number of entries\nbyte[] num = ZipShort.getBytes(entries.size());\nwriteOut(num);\nwriteOut(num);\n\n// length and location of CD\nwriteOut(ZipLong.getBytes(cdLength));\nwriteOut(ZipLong.getBytes(cdOffset));\n\n// ZIP file comment\nByteBuffer data = this.zipEncoding.encode(comment);\nwriteOut(ZipShort.getBytes(data.limit()));\nwriteOut(data.array(), data.arrayOffset(), data.limit());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([B)V",
                                    "method_body": "protected final void writeOut(byte[] data) throws IOException {\nwriteOut(data, 0, data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([BII)V",
                                    "method_body": "protected final void writeOut(byte[] data, int offset, int length)\nthrows IOException {\nif (raf != null) {\nraf.write(data, offset, length);\n} else {\nout.write(data, offset, length);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeVersionNeededToExtractAndGeneralPurposeBits(IZ)V",
                                    "method_body": "private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\nzipMethod,\nfinal boolean\nutfFallback)\nthrows IOException {\n\n// CheckStyle:MagicNumber OFF\nint versionNeededToExtract = 10;\nint generalPurposeFlag = (useEFS || utfFallback) ? EFS_FLAG : 0;\nif (zipMethod == DEFLATED && raf == null) {\n// requires version 2 as we are going to store length info\n// in the data descriptor\nversionNeededToExtract =  20;\n// bit3 set to signal, we use a data descriptor\ngeneralPurposeFlag |= 8;\n}\n// CheckStyle:MagicNumber ON\n\n// version needed to extract\nwriteOut(ZipShort.getBytes(versionNeededToExtract));\n// general purpose bit flag\nwriteOut(ZipShort.getBytes(generalPurposeFlag));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n//private static final int BYTE_BIT_SIZE = 8;\nprivate static final int BYTE_MASK = 0xFF;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map simpleEncodings;\n\nstatic {\nsimpleEncodings = new HashMap();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for utf-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h =\n(SimpleEncodingHolder) simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\n// check platform's default encoding\nencoding = System.getProperty(\"file.encoding\");\n}\nreturn UTF8.equalsIgnoreCase(encoding)\n|| \"utf-8\".equalsIgnoreCase(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:canEncode(Ljava/lang/String;)Z",
                                    "method_body": "public boolean canEncode(String name) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(String name) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn ByteBuffer.wrap(name.getBytes());\n} else {\nreturn ByteBuffer.wrap(name.getBytes(this.charset));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<init>(Ljava/lang/String;)V",
                                    "method_body": "private UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
                                    "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS =\nnew UnicodeExtraFieldPolicy(\"always\");\n/**\n* Never create Unicode extra fields.\n*/\npublic static final UnicodeExtraFieldPolicy NEVER =\nnew UnicodeExtraFieldPolicy(\"never\");\n/**\n* Create Unicode extra fields for filenames that cannot be\n* encoded using the specified encoding.\n*/\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nnew UnicodeExtraFieldPolicy(\"not encodeable\");\n\nprivate final String name;\nprivate UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\n\n/** No-arg constructor */\npublic JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes(I)[B",
                                    "method_body": "public static byte[] getBytes(int value) {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n\n/**\n* Static registry of known extra fields.\n*/\nprivate static final Map implementations;\n\nstatic {\nimplementations = new HashMap();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class c) {\ntry {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n} catch (ClassCastException cc) {\nthrow new RuntimeException(c + \" doesn\\'t implement ZipExtraField\");\n} catch (InstantiationException ie) {\nthrow new RuntimeException(c + \" is not a concrete class\");\n} catch (IllegalAccessException ie) {\nthrow new RuntimeException(c + \"\\'s no-arg constructor is not public\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\n}\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n0, result, start + 2, 2);\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeCentralDirectoryData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getCentralDirectoryLength().getValue();\n}\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n0, result, start + 2, 2);\nbyte[] local = data[i].getCentralDirectoryData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate static final int      WORD = 4;\n/**\n* Standard Unix stat(2) file mode.\n*/\nprivate int mode = 0;\n/**\n* User ID.\n*/\nprivate int uid = 0;\n/**\n* Group ID.\n*/\nprivate int gid = 0;\n/**\n* File this entry points to, if it is a symbolic link.\n*\n* <p>empty string - if entry is not a symbolic link.</p>\n*/\nprivate String link = \"\";\n/**\n* Is this an entry for a directory?\n*/\nprivate boolean dirFlag = false;\n\n/**\n* Instance used to calculate checksums.\n*/\nprivate CRC32 crc = new CRC32();\n\n/** Constructor for AsiExtraField. */\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\n\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\n\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n\n/**\n* Convert a Date object to a DOS date/time field.\n* @param time the <code>Date</code> to convert\n* @return the date as a <code>ZipLong</code>\n*/\npublic static ZipLong toDosTime(Date time) {\nreturn new ZipLong(toDosTime(time.getTime()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(J)[B",
                                    "method_body": "public static byte[] toDosTime(long t) {\nCalendar c = Calendar.getInstance();\nc.setTimeInMillis(t);\n\nint year = c.get(Calendar.YEAR);\nif (year < 1980) {\nreturn (byte[]) DOS_TIME_MIN.clone(); // stop callers from changing the array\n}\nint month = c.get(Calendar.MONTH) + 1;\nlong value =  ((year - 1980) << 25)\n|         (month << 21)\n|         (c.get(Calendar.DAY_OF_MONTH) << 16)\n|         (c.get(Calendar.HOUR_OF_DAY) << 11)\n|         (c.get(Calendar.MINUTE) << 5)\n|         (c.get(Calendar.SECOND) >> 1);\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:adjustToLong(I)J",
                                    "method_body": "public static long adjustToLong(int i) {\nif (i < 0) {\nreturn 2 * ((long) Integer.MAX_VALUE) + 2 + i;\n} else {\nreturn i;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\nthrows IOException {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = new RandomAccessFile(f, \"r\");\nboolean success = false;\ntry {\nMap entriesWithoutEFS = populateFromCentralDirectory();\nresolveLocalFileHeaderData(entriesWithoutEFS);\nsuccess = true;\n} finally {\nif (!success) {\ntry {\narchive.close();\n} catch (IOException e2) {\n// swallow, throw the original exception instead\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
                                    "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\ntry {\nzipfile.close();\n} catch (IOException e) {\n//ignore\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map populateFromCentralDirectory()\nthrows IOException {\nHashMap noEFS = new HashMap();\n\npositionAtCentralDirectory();\n\nbyte[] cfh = new byte[CFH_LEN];\n\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nfinal long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\nif (sig != cfhSig && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n+ \" corrupt archive.\");\n}\nwhile (sig == cfhSig) {\narchive.readFully(cfh);\nint off = 0;\nZipArchiveEntry ze = new ZipArchiveEntry();\n\nint versionMadeBy = ZipShort.getValue(cfh, off);\noff += SHORT;\nze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\noff += SHORT; // skip version info\n\nfinal int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS =\n(generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0;\nfinal ZipEncoding entryEncoding =\nhasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\noff += SHORT;\n\nze.setMethod(ZipShort.getValue(cfh, off));\noff += SHORT;\n\n// FIXME this is actually not very cpu cycles friendly as we are converting from\n// dos to java while the underlying Sun implementation will convert\n// from java to dos time for internal storage...\nlong time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\nze.setTime(time);\noff += WORD;\n\nze.setCrc(ZipLong.getValue(cfh, off));\noff += WORD;\n\nze.setCompressedSize(ZipLong.getValue(cfh, off));\noff += WORD;\n\nze.setSize(ZipLong.getValue(cfh, off));\noff += WORD;\n\nint fileNameLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nint extraLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nint commentLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\noff += SHORT; // disk number\n\nze.setInternalAttributes(ZipShort.getValue(cfh, off));\noff += SHORT;\n\nze.setExternalAttributes(ZipLong.getValue(cfh, off));\noff += WORD;\n\nbyte[] fileName = new byte[fileNameLen];\narchive.readFully(fileName);\nze.setName(entryEncoding.decode(fileName));\n\n// LFH offset,\nOffsetEntry offset = new OffsetEntry();\noffset.headerOffset = ZipLong.getValue(cfh, off);\n// data offset will be filled later\nentries.put(ze, offset);\n\nnameMap.put(ze.getName(), ze);\n\nbyte[] cdExtraData = new byte[extraLen];\narchive.readFully(cdExtraData);\nze.setCentralDirectoryExtra(cdExtraData);\n\nbyte[] comment = new byte[commentLen];\narchive.readFully(comment);\nze.setComment(entryEncoding.decode(comment));\n\narchive.readFully(signatureBytes);\nsig = ZipLong.getValue(signatureBytes);\n\nif (!hasEFS && useUnicodeExtraFields) {\nnoEFS.put(ze, new NameAndComment(fileName, comment));\n}\n}\nreturn noEFS;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nthrows IOException {\nboolean found = false;\nlong off = archive.length() - MIN_EOCD_SIZE;\nlong stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE);\nif (off >= 0) {\narchive.seek(off);\nbyte[] sig = ZipArchiveOutputStream.EOCD_SIG;\nint curr = archive.read();\nwhile (off >= stopSearching && curr != -1) {\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\n}\n}\n}\n}\narchive.seek(--off);\ncurr = archive.read();\n}\n}\nif (!found) {\nthrow new ZipException(\"archive is not a ZIP archive\");\n}\narchive.seek(off + CFD_LOCATOR_OFFSET);\nbyte[] cfdOffset = new byte[WORD];\narchive.readFully(cfdOffset);\narchive.seek(ZipLong.getValue(cfdOffset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:startsWithLocalFileHeader()Z",
                                    "method_body": "private boolean startsWithLocalFileHeader() throws IOException {\narchive.seek(0);\nfinal byte[] start = new byte[WORD];\narchive.readFully(start);\nfor (int i = 0; i < start.length; i++) {\nif (start[i] != ZipArchiveOutputStream.LFH_SIG[i]) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipArchiveOutputStream(File file) throws IOException {\nOutputStream o = null;\nRandomAccessFile _raf = null;\ntry {\n_raf = new RandomAccessFile(file, \"rw\");\n_raf.setLength(0);\n} catch (IOException e) {\nif (_raf != null) {\ntry {\n_raf.close();\n} catch (IOException inner) {\n// ignore\n}\n_raf = null;\n}\no = new FileOutputStream(file);\n}\nout = o;\nraf = _raf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setEncoding(Ljava/lang/String;)V",
                                    "method_body": "public void setEncoding(final String encoding) {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nuseEFS &= ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setUseLanguageEncodingFlag(Z)V",
                                    "method_body": "public void setUseLanguageEncodingFlag(boolean b) {\nuseEFS = b && ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setCreateUnicodeExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveOutputStream$UnicodeExtraFieldPolicy;)V",
                                    "method_body": "public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b) {\ncreateUnicodeExtraFields = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int offset, int length) throws IOException {\nif (entry.getMethod() == DEFLATED) {\nif (length > 0) {\nif (!def.finished()) {\nif (length <= DEFLATER_BLOCK_SIZE) {\ndef.setInput(b, offset, length);\ndeflateUntilInputIsNeeded();\n} else {\nfinal int fullblocks = length / DEFLATER_BLOCK_SIZE;\nfor (int i = 0; i < fullblocks; i++) {\ndef.setInput(b, offset + i * DEFLATER_BLOCK_SIZE,\nDEFLATER_BLOCK_SIZE);\ndeflateUntilInputIsNeeded();\n}\nfinal int done = fullblocks * DEFLATER_BLOCK_SIZE;\nif (done < length) {\ndef.setInput(b, offset + done, length - done);\ndeflateUntilInputIsNeeded();\n}\n}\n}\n}\n} else {\nwriteOut(b, offset, length);\nwritten += length;\n}\ncrc.update(b, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflateUntilInputIsNeeded()V",
                                    "method_body": "private void deflateUntilInputIsNeeded() throws IOException {\nwhile (!def.needsInput()) {\ndeflate();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:addExtraField(Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void addExtraField(ZipExtraField ze) {\nif (extraFields == null) {\nextraFields = new LinkedHashMap();\n}\nextraFields.put(ze.getHeaderId(), ze);\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "protected AbstractUnicodeExtraField(String text, byte[] bytes, int off,\nint len) {\nCRC32 crc32 = new CRC32();\ncrc32.update(bytes, off, len);\nnameCRC32 = crc32.getValue();\n\ntry {\nunicodeName = text.getBytes(\"UTF-8\");\n} catch (UnsupportedEncodingException e) {\nthrow new RuntimeException(\"FATAL: UTF-8 encoding not supported.\",\ne);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:assembleData()V",
                                    "method_body": "private void assembleData() {\nif (unicodeName == null) {\nreturn;\n}\n\ndata = new byte[5 + unicodeName.length];\n// version 1\ndata[0] = 0x01;\nSystem.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4);\nSystem.arraycopy(unicodeName, 0, data, 5, unicodeName.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryData()[B",
                                    "method_body": "public byte[] getCentralDirectoryData() {\nif (data == null) {\nthis.assembleData();\n}\nreturn data;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getCentralDirectoryLength() {\nif (data == null) {\nassembleData();\n}\nreturn new ZipShort(data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn getCentralDirectoryData();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn getCentralDirectoryLength();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "public UnicodePathExtraField(String text, byte[] bytes, int off, int len) {\nsuper(text, bytes, off, len);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testUtf8FileRoundtripNoEFSImplicitUnicodeExtra",
                            "test_body": "68: public void testUtf8FileRoundtripNoEFSImplicitUnicodeExtra()\n69: throws IOException {\n70: testFileRoundtrip(UTF_8, false, false);\n71: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getInternalAttributes()I",
                                    "method_body": "public int getInternalAttributes() {\nreturn internalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExternalAttributes()J",
                                    "method_body": "public long getExternalAttributes() {\nreturn externalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields() {\nif (extraFields == null) {\nreturn new ZipExtraField[0];\n}\nZipExtraField[] result = new ZipExtraField[extraFields.size()];\nreturn (ZipExtraField[]) extraFields.values().toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
                                    "method_body": "public byte[] getLocalFileDataExtra() {\nbyte[] extra = getExtra();\nreturn extra != null ? extra : new byte[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getCentralDirectoryExtra()[B",
                                    "method_body": "public byte[] getCentralDirectoryExtra() {\nreturn ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\n// this method has severe consequences on performance. We cannot rely\n// on the super.hashCode() method since super.getName() always return\n// the empty string in the current implemention (there's no setter)\n// so it is basically draining the performance of a hashmap lookup\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final int BYTE_MASK = 0xFF;\nprivate static final int SHORT = 2;\nprivate static final int WORD = 4;\nstatic final int BUFFER_SIZE = 512;\n/*\n* Apparently Deflater.setInput gets slowed down a lot on Sun JVMs\n* when it gets handed a really big buffer.  See\n* https://issues.apache.org/bugzilla/show_bug.cgi?id=45396\n*\n* Using a buffer size of 8 kB proved to be a good compromise\n*/\nprivate static final int DEFLATER_BLOCK_SIZE = 8192;\n\n/**\n* Compression method for deflated entries.\n*/\npublic static final int DEFLATED = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* Default compression level for deflated entries.\n*/\npublic static final int DEFAULT_COMPRESSION = Deflater.DEFAULT_COMPRESSION;\n\n/**\n* Compression method for stored entries.\n*/\npublic static final int STORED = java.util.zip.ZipEntry.STORED;\n\n/**\n* default encoding for file names and comment.\n*/\nstatic final String DEFAULT_ENCODING = ZipEncodingHelper.UTF8;\n\n/**\n* General purpose flag, which indicates that filenames are\n* written in utf-8.\n*/\npublic static final int EFS_FLAG = 1 << 11;\n\n/**\n* Current entry.\n*/\nprivate ZipArchiveEntry entry;\n\n/**\n* The file comment.\n*/\nprivate String comment = \"\";\n\n/**\n* Compression level for next entry.\n*/\nprivate int level = DEFAULT_COMPRESSION;\n\n/**\n* Has the compression level changed when compared to the last\n* entry?\n*/\nprivate boolean hasCompressionLevelChanged = false;\n\n/**\n* Default compression method for next entry.\n*/\nprivate int method = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* List of ZipArchiveEntries written so far.\n*/\nprivate final List entries = new LinkedList();\n\n/**\n* CRC instance to avoid parsing DEFLATED data twice.\n*/\nprivate final CRC32 crc = new CRC32();\n\n/**\n* Count the bytes written to out.\n*/\nprivate long written = 0;\n\n/**\n* Data for local header data\n*/\nprivate long dataStart = 0;\n\n/**\n* Offset for CRC entry in the local file header data for the\n* current entry starts here.\n*/\nprivate long localDataStart = 0;\n\n/**\n* Start of central directory.\n*/\nprivate long cdOffset = 0;\n\n/**\n* Length of central directory.\n*/\nprivate long cdLength = 0;\n\n/**\n* Helper, a 0 as ZipShort.\n*/\nprivate static final byte[] ZERO = {0, 0};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif(entry != null) {\nthrow new IOException(\"This archives contains unclosed entries.\");\n}\n\ncdOffset = written;\nfor (Iterator i = entries.iterator(); i.hasNext(); ) {\nwriteCentralFileHeader((ZipArchiveEntry) i.next());\n}\ncdLength = written - cdOffset;\nwriteCentralDirectoryEnd();\noffsets.clear();\nentries.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (entry == null) {\nreturn;\n}\n\nlong realCrc = crc.getValue();\ncrc.reset();\n\nif (entry.getMethod() == DEFLATED) {\ndef.finish();\nwhile (!def.finished()) {\ndeflate();\n}\n\nentry.setSize(ZipUtil.adjustToLong(def.getTotalIn()));\nentry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut()));\nentry.setCrc(realCrc);\n\ndef.reset();\n\nwritten += entry.getCompressedSize();\n} else if (raf == null) {\nif (entry.getCrc() != realCrc) {\nthrow new ZipException(\"bad CRC checksum for entry \"\n+ entry.getName() + \": \"\n+ Long.toHexString(entry.getCrc())\n+ \" instead of \"\n+ Long.toHexString(realCrc));\n}\n\nif (entry.getSize() != written - dataStart) {\nthrow new ZipException(\"bad size for entry \"\n+ entry.getName() + \": \"\n+ entry.getSize()\n+ \" instead of \"\n+ (written - dataStart));\n}\n} else { /* method is STORED and we used RandomAccessFile */\nlong size = written - dataStart;\n\nentry.setSize(size);\nentry.setCompressedSize(size);\nentry.setCrc(realCrc);\n}\n\n// If random access output, write the local file header containing\n// the correct CRC and compressed/uncompressed sizes\nif (raf != null) {\nlong save = raf.getFilePointer();\n\nraf.seek(localDataStart);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\nraf.seek(save);\n}\n\nwriteDataDescriptor(entry);\nentry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\ncloseArchiveEntry();\n\nentry = ((ZipArchiveEntry) archiveEntry);\nentries.add(entry);\n\nif (entry.getMethod() == -1) { // not specified\nentry.setMethod(method);\n}\n\nif (entry.getTime() == -1) { // not specified\nentry.setTime(System.currentTimeMillis());\n}\n\n// Size/CRC not required if RandomAccessFile is used\nif (entry.getMethod() == STORED && raf == null) {\nif (entry.getSize() == -1) {\nthrow new ZipException(\"uncompressed size is required for\"\n+ \" STORED method when not writing to a\"\n+ \" file\");\n}\nif (entry.getCrc() == -1) {\nthrow new ZipException(\"crc checksum is required for STORED\"\n+ \" method when not writing to a file\");\n}\nentry.setCompressedSize(entry.getSize());\n}\n\nif (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\ndef.setLevel(level);\nhasCompressionLevelChanged = false;\n}\nwriteLocalFileHeader(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nfinish();\nif (raf != null) {\nraf.close();\n}\nif (out != null) {\nout.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflate()V",
                                    "method_body": "protected final void deflate() throws IOException {\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\nboolean encodable = zipEncoding.canEncode(ze.getName());\n\nfinal ZipEncoding entryEncoding;\n\nif (!encodable && fallbackToUTF8) {\nentryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n} else {\nentryEncoding = zipEncoding;\n}\n\nByteBuffer name = entryEncoding.encode(ze.getName());\n\nif (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n|| !encodable) {\nze.addExtraField(new UnicodePathExtraField(ze.getName(),\nname.array(),\nname.arrayOffset(),\nname.limit()));\n}\n\nString comm = ze.getComment();\nif (comm != null && !\"\".equals(comm)) {\n\nboolean commentEncodable = this.zipEncoding.canEncode(comm);\n\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n|| !commentEncodable) {\nByteBuffer commentB = entryEncoding.encode(comm);\nze.addExtraField(new UnicodeCommentExtraField(comm,\ncommentB.array(),\ncommentB.arrayOffset(),\ncommentB.limit())\n);\n}\n}\n}\n\noffsets.put(ze, ZipLong.getBytes(written));\n\nwriteOut(LFH_SIG);\nwritten += WORD;\n\n//store method in local variable to prevent multiple method calls\nfinal int zipMethod = ze.getMethod();\n\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n!encodable\n&& fallbackToUTF8);\nwritten += WORD;\n\n// compression method\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\n\n// last mod. time and date\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\n\n// CRC\n// compressed length\n// uncompressed length\nlocalDataStart = written;\nif (zipMethod == DEFLATED || raf != null) {\nwriteOut(LZERO);\nwriteOut(LZERO);\nwriteOut(LZERO);\n} else {\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\n}\n// CheckStyle:MagicNumber OFF\nwritten += 12;\n// CheckStyle:MagicNumber ON\n\n// file name length\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\n\n// extra field length\nbyte[] extra = ze.getLocalFileDataExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\n\n// file name\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\n\n// extra field\nwriteOut(extra);\nwritten += extra.length;\n\ndataStart = written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeDataDescriptor(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeDataDescriptor(ZipArchiveEntry ze) throws IOException {\nif (ze.getMethod() != DEFLATED || raf != null) {\nreturn;\n}\nwriteOut(DD_SIG);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\n// CheckStyle:MagicNumber OFF\nwritten += 16;\n// CheckStyle:MagicNumber ON\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\nwriteOut(CFH_SIG);\nwritten += WORD;\n\n// version made by\n// CheckStyle:MagicNumber OFF\nwriteOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\nwritten += SHORT;\n\nfinal int zipMethod = ze.getMethod();\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n!encodable\n&& fallbackToUTF8);\nwritten += WORD;\n\n// compression method\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\n\n// last mod. time and date\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\n\n// CRC\n// compressed length\n// uncompressed length\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getCompressedSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\n// CheckStyle:MagicNumber OFF\nwritten += 12;\n// CheckStyle:MagicNumber ON\n\n// file name length\nfinal ZipEncoding entryEncoding;\n\nif (!encodable && fallbackToUTF8) {\nentryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n} else {\nentryEncoding = zipEncoding;\n}\n\nByteBuffer name = entryEncoding.encode(ze.getName());\n\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\n\n// extra field length\nbyte[] extra = ze.getCentralDirectoryExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\n\n// file comment length\nString comm = ze.getComment();\nif (comm == null) {\ncomm = \"\";\n}\n\nByteBuffer commentB = entryEncoding.encode(comm);\n\nwriteOut(ZipShort.getBytes(commentB.limit()));\nwritten += SHORT;\n\n// disk number start\nwriteOut(ZERO);\nwritten += SHORT;\n\n// internal file attributes\nwriteOut(ZipShort.getBytes(ze.getInternalAttributes()));\nwritten += SHORT;\n\n// external file attributes\nwriteOut(ZipLong.getBytes(ze.getExternalAttributes()));\nwritten += WORD;\n\n// relative offset of LFH\nwriteOut((byte[]) offsets.get(ze));\nwritten += WORD;\n\n// file name\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\n\n// extra field\nwriteOut(extra);\nwritten += extra.length;\n\n// file comment\nwriteOut(commentB.array(), commentB.arrayOffset(), commentB.limit());\nwritten += commentB.limit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryEnd()V",
                                    "method_body": "protected void writeCentralDirectoryEnd() throws IOException {\nwriteOut(EOCD_SIG);\n\n// disk numbers\nwriteOut(ZERO);\nwriteOut(ZERO);\n\n// number of entries\nbyte[] num = ZipShort.getBytes(entries.size());\nwriteOut(num);\nwriteOut(num);\n\n// length and location of CD\nwriteOut(ZipLong.getBytes(cdLength));\nwriteOut(ZipLong.getBytes(cdOffset));\n\n// ZIP file comment\nByteBuffer data = this.zipEncoding.encode(comment);\nwriteOut(ZipShort.getBytes(data.limit()));\nwriteOut(data.array(), data.arrayOffset(), data.limit());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([B)V",
                                    "method_body": "protected final void writeOut(byte[] data) throws IOException {\nwriteOut(data, 0, data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([BII)V",
                                    "method_body": "protected final void writeOut(byte[] data, int offset, int length)\nthrows IOException {\nif (raf != null) {\nraf.write(data, offset, length);\n} else {\nout.write(data, offset, length);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeVersionNeededToExtractAndGeneralPurposeBits(IZ)V",
                                    "method_body": "private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\nzipMethod,\nfinal boolean\nutfFallback)\nthrows IOException {\n\n// CheckStyle:MagicNumber OFF\nint versionNeededToExtract = 10;\nint generalPurposeFlag = (useEFS || utfFallback) ? EFS_FLAG : 0;\nif (zipMethod == DEFLATED && raf == null) {\n// requires version 2 as we are going to store length info\n// in the data descriptor\nversionNeededToExtract =  20;\n// bit3 set to signal, we use a data descriptor\ngeneralPurposeFlag |= 8;\n}\n// CheckStyle:MagicNumber ON\n\n// version needed to extract\nwriteOut(ZipShort.getBytes(versionNeededToExtract));\n// general purpose bit flag\nwriteOut(ZipShort.getBytes(generalPurposeFlag));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n//private static final int BYTE_BIT_SIZE = 8;\nprivate static final int BYTE_MASK = 0xFF;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map simpleEncodings;\n\nstatic {\nsimpleEncodings = new HashMap();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for utf-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h =\n(SimpleEncodingHolder) simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\n// check platform's default encoding\nencoding = System.getProperty(\"file.encoding\");\n}\nreturn UTF8.equalsIgnoreCase(encoding)\n|| \"utf-8\".equalsIgnoreCase(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:canEncode(Ljava/lang/String;)Z",
                                    "method_body": "public boolean canEncode(String name) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(String name) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn ByteBuffer.wrap(name.getBytes());\n} else {\nreturn ByteBuffer.wrap(name.getBytes(this.charset));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<init>(Ljava/lang/String;)V",
                                    "method_body": "private UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
                                    "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS =\nnew UnicodeExtraFieldPolicy(\"always\");\n/**\n* Never create Unicode extra fields.\n*/\npublic static final UnicodeExtraFieldPolicy NEVER =\nnew UnicodeExtraFieldPolicy(\"never\");\n/**\n* Create Unicode extra fields for filenames that cannot be\n* encoded using the specified encoding.\n*/\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nnew UnicodeExtraFieldPolicy(\"not encodeable\");\n\nprivate final String name;\nprivate UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\n\n/** No-arg constructor */\npublic JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes(I)[B",
                                    "method_body": "public static byte[] getBytes(int value) {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n\n/**\n* Static registry of known extra fields.\n*/\nprivate static final Map implementations;\n\nstatic {\nimplementations = new HashMap();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class c) {\ntry {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n} catch (ClassCastException cc) {\nthrow new RuntimeException(c + \" doesn\\'t implement ZipExtraField\");\n} catch (InstantiationException ie) {\nthrow new RuntimeException(c + \" is not a concrete class\");\n} catch (IllegalAccessException ie) {\nthrow new RuntimeException(c + \"\\'s no-arg constructor is not public\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\n}\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n0, result, start + 2, 2);\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeCentralDirectoryData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getCentralDirectoryLength().getValue();\n}\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n0, result, start + 2, 2);\nbyte[] local = data[i].getCentralDirectoryData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate static final int      WORD = 4;\n/**\n* Standard Unix stat(2) file mode.\n*/\nprivate int mode = 0;\n/**\n* User ID.\n*/\nprivate int uid = 0;\n/**\n* Group ID.\n*/\nprivate int gid = 0;\n/**\n* File this entry points to, if it is a symbolic link.\n*\n* <p>empty string - if entry is not a symbolic link.</p>\n*/\nprivate String link = \"\";\n/**\n* Is this an entry for a directory?\n*/\nprivate boolean dirFlag = false;\n\n/**\n* Instance used to calculate checksums.\n*/\nprivate CRC32 crc = new CRC32();\n\n/** Constructor for AsiExtraField. */\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\n\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\n\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n\n/**\n* Convert a Date object to a DOS date/time field.\n* @param time the <code>Date</code> to convert\n* @return the date as a <code>ZipLong</code>\n*/\npublic static ZipLong toDosTime(Date time) {\nreturn new ZipLong(toDosTime(time.getTime()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(J)[B",
                                    "method_body": "public static byte[] toDosTime(long t) {\nCalendar c = Calendar.getInstance();\nc.setTimeInMillis(t);\n\nint year = c.get(Calendar.YEAR);\nif (year < 1980) {\nreturn (byte[]) DOS_TIME_MIN.clone(); // stop callers from changing the array\n}\nint month = c.get(Calendar.MONTH) + 1;\nlong value =  ((year - 1980) << 25)\n|         (month << 21)\n|         (c.get(Calendar.DAY_OF_MONTH) << 16)\n|         (c.get(Calendar.HOUR_OF_DAY) << 11)\n|         (c.get(Calendar.MINUTE) << 5)\n|         (c.get(Calendar.SECOND) >> 1);\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:adjustToLong(I)J",
                                    "method_body": "public static long adjustToLong(int i) {\nif (i < 0) {\nreturn 2 * ((long) Integer.MAX_VALUE) + 2 + i;\n} else {\nreturn i;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\nthrows IOException {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = new RandomAccessFile(f, \"r\");\nboolean success = false;\ntry {\nMap entriesWithoutEFS = populateFromCentralDirectory();\nresolveLocalFileHeaderData(entriesWithoutEFS);\nsuccess = true;\n} finally {\nif (!success) {\ntry {\narchive.close();\n} catch (IOException e2) {\n// swallow, throw the original exception instead\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
                                    "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\ntry {\nzipfile.close();\n} catch (IOException e) {\n//ignore\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map populateFromCentralDirectory()\nthrows IOException {\nHashMap noEFS = new HashMap();\n\npositionAtCentralDirectory();\n\nbyte[] cfh = new byte[CFH_LEN];\n\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nfinal long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\nif (sig != cfhSig && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n+ \" corrupt archive.\");\n}\nwhile (sig == cfhSig) {\narchive.readFully(cfh);\nint off = 0;\nZipArchiveEntry ze = new ZipArchiveEntry();\n\nint versionMadeBy = ZipShort.getValue(cfh, off);\noff += SHORT;\nze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\noff += SHORT; // skip version info\n\nfinal int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS =\n(generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0;\nfinal ZipEncoding entryEncoding =\nhasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\noff += SHORT;\n\nze.setMethod(ZipShort.getValue(cfh, off));\noff += SHORT;\n\n// FIXME this is actually not very cpu cycles friendly as we are converting from\n// dos to java while the underlying Sun implementation will convert\n// from java to dos time for internal storage...\nlong time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\nze.setTime(time);\noff += WORD;\n\nze.setCrc(ZipLong.getValue(cfh, off));\noff += WORD;\n\nze.setCompressedSize(ZipLong.getValue(cfh, off));\noff += WORD;\n\nze.setSize(ZipLong.getValue(cfh, off));\noff += WORD;\n\nint fileNameLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nint extraLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nint commentLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\noff += SHORT; // disk number\n\nze.setInternalAttributes(ZipShort.getValue(cfh, off));\noff += SHORT;\n\nze.setExternalAttributes(ZipLong.getValue(cfh, off));\noff += WORD;\n\nbyte[] fileName = new byte[fileNameLen];\narchive.readFully(fileName);\nze.setName(entryEncoding.decode(fileName));\n\n// LFH offset,\nOffsetEntry offset = new OffsetEntry();\noffset.headerOffset = ZipLong.getValue(cfh, off);\n// data offset will be filled later\nentries.put(ze, offset);\n\nnameMap.put(ze.getName(), ze);\n\nbyte[] cdExtraData = new byte[extraLen];\narchive.readFully(cdExtraData);\nze.setCentralDirectoryExtra(cdExtraData);\n\nbyte[] comment = new byte[commentLen];\narchive.readFully(comment);\nze.setComment(entryEncoding.decode(comment));\n\narchive.readFully(signatureBytes);\nsig = ZipLong.getValue(signatureBytes);\n\nif (!hasEFS && useUnicodeExtraFields) {\nnoEFS.put(ze, new NameAndComment(fileName, comment));\n}\n}\nreturn noEFS;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nthrows IOException {\nboolean found = false;\nlong off = archive.length() - MIN_EOCD_SIZE;\nlong stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE);\nif (off >= 0) {\narchive.seek(off);\nbyte[] sig = ZipArchiveOutputStream.EOCD_SIG;\nint curr = archive.read();\nwhile (off >= stopSearching && curr != -1) {\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\n}\n}\n}\n}\narchive.seek(--off);\ncurr = archive.read();\n}\n}\nif (!found) {\nthrow new ZipException(\"archive is not a ZIP archive\");\n}\narchive.seek(off + CFD_LOCATOR_OFFSET);\nbyte[] cfdOffset = new byte[WORD];\narchive.readFully(cfdOffset);\narchive.seek(ZipLong.getValue(cfdOffset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:startsWithLocalFileHeader()Z",
                                    "method_body": "private boolean startsWithLocalFileHeader() throws IOException {\narchive.seek(0);\nfinal byte[] start = new byte[WORD];\narchive.readFully(start);\nfor (int i = 0; i < start.length; i++) {\nif (start[i] != ZipArchiveOutputStream.LFH_SIG[i]) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipArchiveOutputStream(File file) throws IOException {\nOutputStream o = null;\nRandomAccessFile _raf = null;\ntry {\n_raf = new RandomAccessFile(file, \"rw\");\n_raf.setLength(0);\n} catch (IOException e) {\nif (_raf != null) {\ntry {\n_raf.close();\n} catch (IOException inner) {\n// ignore\n}\n_raf = null;\n}\no = new FileOutputStream(file);\n}\nout = o;\nraf = _raf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setEncoding(Ljava/lang/String;)V",
                                    "method_body": "public void setEncoding(final String encoding) {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nuseEFS &= ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setUseLanguageEncodingFlag(Z)V",
                                    "method_body": "public void setUseLanguageEncodingFlag(boolean b) {\nuseEFS = b && ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setCreateUnicodeExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveOutputStream$UnicodeExtraFieldPolicy;)V",
                                    "method_body": "public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b) {\ncreateUnicodeExtraFields = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int offset, int length) throws IOException {\nif (entry.getMethod() == DEFLATED) {\nif (length > 0) {\nif (!def.finished()) {\nif (length <= DEFLATER_BLOCK_SIZE) {\ndef.setInput(b, offset, length);\ndeflateUntilInputIsNeeded();\n} else {\nfinal int fullblocks = length / DEFLATER_BLOCK_SIZE;\nfor (int i = 0; i < fullblocks; i++) {\ndef.setInput(b, offset + i * DEFLATER_BLOCK_SIZE,\nDEFLATER_BLOCK_SIZE);\ndeflateUntilInputIsNeeded();\n}\nfinal int done = fullblocks * DEFLATER_BLOCK_SIZE;\nif (done < length) {\ndef.setInput(b, offset + done, length - done);\ndeflateUntilInputIsNeeded();\n}\n}\n}\n}\n} else {\nwriteOut(b, offset, length);\nwritten += length;\n}\ncrc.update(b, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflateUntilInputIsNeeded()V",
                                    "method_body": "private void deflateUntilInputIsNeeded() throws IOException {\nwhile (!def.needsInput()) {\ndeflate();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:addExtraField(Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void addExtraField(ZipExtraField ze) {\nif (extraFields == null) {\nextraFields = new LinkedHashMap();\n}\nextraFields.put(ze.getHeaderId(), ze);\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "protected AbstractUnicodeExtraField(String text, byte[] bytes, int off,\nint len) {\nCRC32 crc32 = new CRC32();\ncrc32.update(bytes, off, len);\nnameCRC32 = crc32.getValue();\n\ntry {\nunicodeName = text.getBytes(\"UTF-8\");\n} catch (UnsupportedEncodingException e) {\nthrow new RuntimeException(\"FATAL: UTF-8 encoding not supported.\",\ne);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:assembleData()V",
                                    "method_body": "private void assembleData() {\nif (unicodeName == null) {\nreturn;\n}\n\ndata = new byte[5 + unicodeName.length];\n// version 1\ndata[0] = 0x01;\nSystem.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4);\nSystem.arraycopy(unicodeName, 0, data, 5, unicodeName.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryData()[B",
                                    "method_body": "public byte[] getCentralDirectoryData() {\nif (data == null) {\nthis.assembleData();\n}\nreturn data;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getCentralDirectoryLength() {\nif (data == null) {\nassembleData();\n}\nreturn new ZipShort(data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn getCentralDirectoryData();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn getCentralDirectoryLength();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "public UnicodePathExtraField(String text, byte[] bytes, int off, int len) {\nsuper(text, bytes, off, len);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testCP437FileRoundtripImplicitUnicodeExtra",
                            "test_body": "73: public void testCP437FileRoundtripImplicitUnicodeExtra()\n74: throws IOException {\n75: testFileRoundtrip(CP437, false, false);\n76: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getInternalAttributes()I",
                                    "method_body": "public int getInternalAttributes() {\nreturn internalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExternalAttributes()J",
                                    "method_body": "public long getExternalAttributes() {\nreturn externalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields() {\nif (extraFields == null) {\nreturn new ZipExtraField[0];\n}\nZipExtraField[] result = new ZipExtraField[extraFields.size()];\nreturn (ZipExtraField[]) extraFields.values().toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
                                    "method_body": "public byte[] getLocalFileDataExtra() {\nbyte[] extra = getExtra();\nreturn extra != null ? extra : new byte[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getCentralDirectoryExtra()[B",
                                    "method_body": "public byte[] getCentralDirectoryExtra() {\nreturn ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\n// this method has severe consequences on performance. We cannot rely\n// on the super.hashCode() method since super.getName() always return\n// the empty string in the current implemention (there's no setter)\n// so it is basically draining the performance of a hashmap lookup\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "static final int BYTE_MASK = 0xFF;\nprivate static final int SHORT = 2;\nprivate static final int WORD = 4;\nstatic final int BUFFER_SIZE = 512;\n/*\n* Apparently Deflater.setInput gets slowed down a lot on Sun JVMs\n* when it gets handed a really big buffer.  See\n* https://issues.apache.org/bugzilla/show_bug.cgi?id=45396\n*\n* Using a buffer size of 8 kB proved to be a good compromise\n*/\nprivate static final int DEFLATER_BLOCK_SIZE = 8192;\n\n/**\n* Compression method for deflated entries.\n*/\npublic static final int DEFLATED = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* Default compression level for deflated entries.\n*/\npublic static final int DEFAULT_COMPRESSION = Deflater.DEFAULT_COMPRESSION;\n\n/**\n* Compression method for stored entries.\n*/\npublic static final int STORED = java.util.zip.ZipEntry.STORED;\n\n/**\n* default encoding for file names and comment.\n*/\nstatic final String DEFAULT_ENCODING = ZipEncodingHelper.UTF8;\n\n/**\n* General purpose flag, which indicates that filenames are\n* written in utf-8.\n*/\npublic static final int EFS_FLAG = 1 << 11;\n\n/**\n* Current entry.\n*/\nprivate ZipArchiveEntry entry;\n\n/**\n* The file comment.\n*/\nprivate String comment = \"\";\n\n/**\n* Compression level for next entry.\n*/\nprivate int level = DEFAULT_COMPRESSION;\n\n/**\n* Has the compression level changed when compared to the last\n* entry?\n*/\nprivate boolean hasCompressionLevelChanged = false;\n\n/**\n* Default compression method for next entry.\n*/\nprivate int method = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* List of ZipArchiveEntries written so far.\n*/\nprivate final List entries = new LinkedList();\n\n/**\n* CRC instance to avoid parsing DEFLATED data twice.\n*/\nprivate final CRC32 crc = new CRC32();\n\n/**\n* Count the bytes written to out.\n*/\nprivate long written = 0;\n\n/**\n* Data for local header data\n*/\nprivate long dataStart = 0;\n\n/**\n* Offset for CRC entry in the local file header data for the\n* current entry starts here.\n*/\nprivate long localDataStart = 0;\n\n/**\n* Start of central directory.\n*/\nprivate long cdOffset = 0;\n\n/**\n* Length of central directory.\n*/\nprivate long cdLength = 0;\n\n/**\n* Helper, a 0 as ZipShort.\n*/\nprivate static final byte[] ZERO = {0, 0};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif(entry != null) {\nthrow new IOException(\"This archives contains unclosed entries.\");\n}\n\ncdOffset = written;\nfor (Iterator i = entries.iterator(); i.hasNext(); ) {\nwriteCentralFileHeader((ZipArchiveEntry) i.next());\n}\ncdLength = written - cdOffset;\nwriteCentralDirectoryEnd();\noffsets.clear();\nentries.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (entry == null) {\nreturn;\n}\n\nlong realCrc = crc.getValue();\ncrc.reset();\n\nif (entry.getMethod() == DEFLATED) {\ndef.finish();\nwhile (!def.finished()) {\ndeflate();\n}\n\nentry.setSize(ZipUtil.adjustToLong(def.getTotalIn()));\nentry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut()));\nentry.setCrc(realCrc);\n\ndef.reset();\n\nwritten += entry.getCompressedSize();\n} else if (raf == null) {\nif (entry.getCrc() != realCrc) {\nthrow new ZipException(\"bad CRC checksum for entry \"\n+ entry.getName() + \": \"\n+ Long.toHexString(entry.getCrc())\n+ \" instead of \"\n+ Long.toHexString(realCrc));\n}\n\nif (entry.getSize() != written - dataStart) {\nthrow new ZipException(\"bad size for entry \"\n+ entry.getName() + \": \"\n+ entry.getSize()\n+ \" instead of \"\n+ (written - dataStart));\n}\n} else { /* method is STORED and we used RandomAccessFile */\nlong size = written - dataStart;\n\nentry.setSize(size);\nentry.setCompressedSize(size);\nentry.setCrc(realCrc);\n}\n\n// If random access output, write the local file header containing\n// the correct CRC and compressed/uncompressed sizes\nif (raf != null) {\nlong save = raf.getFilePointer();\n\nraf.seek(localDataStart);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\nraf.seek(save);\n}\n\nwriteDataDescriptor(entry);\nentry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\ncloseArchiveEntry();\n\nentry = ((ZipArchiveEntry) archiveEntry);\nentries.add(entry);\n\nif (entry.getMethod() == -1) { // not specified\nentry.setMethod(method);\n}\n\nif (entry.getTime() == -1) { // not specified\nentry.setTime(System.currentTimeMillis());\n}\n\n// Size/CRC not required if RandomAccessFile is used\nif (entry.getMethod() == STORED && raf == null) {\nif (entry.getSize() == -1) {\nthrow new ZipException(\"uncompressed size is required for\"\n+ \" STORED method when not writing to a\"\n+ \" file\");\n}\nif (entry.getCrc() == -1) {\nthrow new ZipException(\"crc checksum is required for STORED\"\n+ \" method when not writing to a file\");\n}\nentry.setCompressedSize(entry.getSize());\n}\n\nif (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\ndef.setLevel(level);\nhasCompressionLevelChanged = false;\n}\nwriteLocalFileHeader(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nfinish();\nif (raf != null) {\nraf.close();\n}\nif (out != null) {\nout.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflate()V",
                                    "method_body": "protected final void deflate() throws IOException {\nint len = def.deflate(buf, 0, buf.length);\nif (len > 0) {\nwriteOut(buf, 0, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\nboolean encodable = zipEncoding.canEncode(ze.getName());\n\nfinal ZipEncoding entryEncoding;\n\nif (!encodable && fallbackToUTF8) {\nentryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n} else {\nentryEncoding = zipEncoding;\n}\n\nByteBuffer name = entryEncoding.encode(ze.getName());\n\nif (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n|| !encodable) {\nze.addExtraField(new UnicodePathExtraField(ze.getName(),\nname.array(),\nname.arrayOffset(),\nname.limit()));\n}\n\nString comm = ze.getComment();\nif (comm != null && !\"\".equals(comm)) {\n\nboolean commentEncodable = this.zipEncoding.canEncode(comm);\n\nif (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n|| !commentEncodable) {\nByteBuffer commentB = entryEncoding.encode(comm);\nze.addExtraField(new UnicodeCommentExtraField(comm,\ncommentB.array(),\ncommentB.arrayOffset(),\ncommentB.limit())\n);\n}\n}\n}\n\noffsets.put(ze, ZipLong.getBytes(written));\n\nwriteOut(LFH_SIG);\nwritten += WORD;\n\n//store method in local variable to prevent multiple method calls\nfinal int zipMethod = ze.getMethod();\n\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n!encodable\n&& fallbackToUTF8);\nwritten += WORD;\n\n// compression method\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\n\n// last mod. time and date\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\n\n// CRC\n// compressed length\n// uncompressed length\nlocalDataStart = written;\nif (zipMethod == DEFLATED || raf != null) {\nwriteOut(LZERO);\nwriteOut(LZERO);\nwriteOut(LZERO);\n} else {\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\n}\n// CheckStyle:MagicNumber OFF\nwritten += 12;\n// CheckStyle:MagicNumber ON\n\n// file name length\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\n\n// extra field length\nbyte[] extra = ze.getLocalFileDataExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\n\n// file name\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\n\n// extra field\nwriteOut(extra);\nwritten += extra.length;\n\ndataStart = written;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeDataDescriptor(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeDataDescriptor(ZipArchiveEntry ze) throws IOException {\nif (ze.getMethod() != DEFLATED || raf != null) {\nreturn;\n}\nwriteOut(DD_SIG);\nwriteOut(ZipLong.getBytes(entry.getCrc()));\nwriteOut(ZipLong.getBytes(entry.getCompressedSize()));\nwriteOut(ZipLong.getBytes(entry.getSize()));\n// CheckStyle:MagicNumber OFF\nwritten += 16;\n// CheckStyle:MagicNumber ON\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\nwriteOut(CFH_SIG);\nwritten += WORD;\n\n// version made by\n// CheckStyle:MagicNumber OFF\nwriteOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\nwritten += SHORT;\n\nfinal int zipMethod = ze.getMethod();\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nwriteVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n!encodable\n&& fallbackToUTF8);\nwritten += WORD;\n\n// compression method\nwriteOut(ZipShort.getBytes(zipMethod));\nwritten += SHORT;\n\n// last mod. time and date\nwriteOut(ZipUtil.toDosTime(ze.getTime()));\nwritten += WORD;\n\n// CRC\n// compressed length\n// uncompressed length\nwriteOut(ZipLong.getBytes(ze.getCrc()));\nwriteOut(ZipLong.getBytes(ze.getCompressedSize()));\nwriteOut(ZipLong.getBytes(ze.getSize()));\n// CheckStyle:MagicNumber OFF\nwritten += 12;\n// CheckStyle:MagicNumber ON\n\n// file name length\nfinal ZipEncoding entryEncoding;\n\nif (!encodable && fallbackToUTF8) {\nentryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n} else {\nentryEncoding = zipEncoding;\n}\n\nByteBuffer name = entryEncoding.encode(ze.getName());\n\nwriteOut(ZipShort.getBytes(name.limit()));\nwritten += SHORT;\n\n// extra field length\nbyte[] extra = ze.getCentralDirectoryExtra();\nwriteOut(ZipShort.getBytes(extra.length));\nwritten += SHORT;\n\n// file comment length\nString comm = ze.getComment();\nif (comm == null) {\ncomm = \"\";\n}\n\nByteBuffer commentB = entryEncoding.encode(comm);\n\nwriteOut(ZipShort.getBytes(commentB.limit()));\nwritten += SHORT;\n\n// disk number start\nwriteOut(ZERO);\nwritten += SHORT;\n\n// internal file attributes\nwriteOut(ZipShort.getBytes(ze.getInternalAttributes()));\nwritten += SHORT;\n\n// external file attributes\nwriteOut(ZipLong.getBytes(ze.getExternalAttributes()));\nwritten += WORD;\n\n// relative offset of LFH\nwriteOut((byte[]) offsets.get(ze));\nwritten += WORD;\n\n// file name\nwriteOut(name.array(), name.arrayOffset(), name.limit());\nwritten += name.limit();\n\n// extra field\nwriteOut(extra);\nwritten += extra.length;\n\n// file comment\nwriteOut(commentB.array(), commentB.arrayOffset(), commentB.limit());\nwritten += commentB.limit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryEnd()V",
                                    "method_body": "protected void writeCentralDirectoryEnd() throws IOException {\nwriteOut(EOCD_SIG);\n\n// disk numbers\nwriteOut(ZERO);\nwriteOut(ZERO);\n\n// number of entries\nbyte[] num = ZipShort.getBytes(entries.size());\nwriteOut(num);\nwriteOut(num);\n\n// length and location of CD\nwriteOut(ZipLong.getBytes(cdLength));\nwriteOut(ZipLong.getBytes(cdOffset));\n\n// ZIP file comment\nByteBuffer data = this.zipEncoding.encode(comment);\nwriteOut(ZipShort.getBytes(data.limit()));\nwriteOut(data.array(), data.arrayOffset(), data.limit());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([B)V",
                                    "method_body": "protected final void writeOut(byte[] data) throws IOException {\nwriteOut(data, 0, data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeOut([BII)V",
                                    "method_body": "protected final void writeOut(byte[] data, int offset, int length)\nthrows IOException {\nif (raf != null) {\nraf.write(data, offset, length);\n} else {\nout.write(data, offset, length);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeVersionNeededToExtractAndGeneralPurposeBits(IZ)V",
                                    "method_body": "private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\nzipMethod,\nfinal boolean\nutfFallback)\nthrows IOException {\n\n// CheckStyle:MagicNumber OFF\nint versionNeededToExtract = 10;\nint generalPurposeFlag = (useEFS || utfFallback) ? EFS_FLAG : 0;\nif (zipMethod == DEFLATED && raf == null) {\n// requires version 2 as we are going to store length info\n// in the data descriptor\nversionNeededToExtract =  20;\n// bit3 set to signal, we use a data descriptor\ngeneralPurposeFlag |= 8;\n}\n// CheckStyle:MagicNumber ON\n\n// version needed to extract\nwriteOut(ZipShort.getBytes(versionNeededToExtract));\n// general purpose bit flag\nwriteOut(ZipShort.getBytes(generalPurposeFlag));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n//private static final int BYTE_BIT_SIZE = 8;\nprivate static final int BYTE_MASK = 0xFF;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map simpleEncodings;\n\nstatic {\nsimpleEncodings = new HashMap();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for utf-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h =\n(SimpleEncodingHolder) simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\n// check platform's default encoding\nencoding = System.getProperty(\"file.encoding\");\n}\nreturn UTF8.equalsIgnoreCase(encoding)\n|| \"utf-8\".equalsIgnoreCase(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<init>(Ljava/lang/String;)V",
                                    "method_body": "private UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
                                    "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS =\nnew UnicodeExtraFieldPolicy(\"always\");\n/**\n* Never create Unicode extra fields.\n*/\npublic static final UnicodeExtraFieldPolicy NEVER =\nnew UnicodeExtraFieldPolicy(\"never\");\n/**\n* Create Unicode extra fields for filenames that cannot be\n* encoded using the specified encoding.\n*/\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nnew UnicodeExtraFieldPolicy(\"not encodeable\");\n\nprivate final String name;\nprivate UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\n\n/** No-arg constructor */\npublic JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes(I)[B",
                                    "method_body": "public static byte[] getBytes(int value) {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n\n/**\n* Static registry of known extra fields.\n*/\nprivate static final Map implementations;\n\nstatic {\nimplementations = new HashMap();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class c) {\ntry {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n} catch (ClassCastException cc) {\nthrow new RuntimeException(c + \" doesn\\'t implement ZipExtraField\");\n} catch (InstantiationException ie) {\nthrow new RuntimeException(c + \" is not a concrete class\");\n} catch (IllegalAccessException ie) {\nthrow new RuntimeException(c + \"\\'s no-arg constructor is not public\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\n}\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n0, result, start + 2, 2);\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeCentralDirectoryData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getCentralDirectoryLength().getValue();\n}\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n0, result, start + 2, 2);\nbyte[] local = data[i].getCentralDirectoryData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate static final int      WORD = 4;\n/**\n* Standard Unix stat(2) file mode.\n*/\nprivate int mode = 0;\n/**\n* User ID.\n*/\nprivate int uid = 0;\n/**\n* Group ID.\n*/\nprivate int gid = 0;\n/**\n* File this entry points to, if it is a symbolic link.\n*\n* <p>empty string - if entry is not a symbolic link.</p>\n*/\nprivate String link = \"\";\n/**\n* Is this an entry for a directory?\n*/\nprivate boolean dirFlag = false;\n\n/**\n* Instance used to calculate checksums.\n*/\nprivate CRC32 crc = new CRC32();\n\n/** Constructor for AsiExtraField. */\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\n\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\n\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n\n/**\n* Convert a Date object to a DOS date/time field.\n* @param time the <code>Date</code> to convert\n* @return the date as a <code>ZipLong</code>\n*/\npublic static ZipLong toDosTime(Date time) {\nreturn new ZipLong(toDosTime(time.getTime()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(J)[B",
                                    "method_body": "public static byte[] toDosTime(long t) {\nCalendar c = Calendar.getInstance();\nc.setTimeInMillis(t);\n\nint year = c.get(Calendar.YEAR);\nif (year < 1980) {\nreturn (byte[]) DOS_TIME_MIN.clone(); // stop callers from changing the array\n}\nint month = c.get(Calendar.MONTH) + 1;\nlong value =  ((year - 1980) << 25)\n|         (month << 21)\n|         (c.get(Calendar.DAY_OF_MONTH) << 16)\n|         (c.get(Calendar.HOUR_OF_DAY) << 11)\n|         (c.get(Calendar.MINUTE) << 5)\n|         (c.get(Calendar.SECOND) >> 1);\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:adjustToLong(I)J",
                                    "method_body": "public static long adjustToLong(int i) {\nif (i < 0) {\nreturn 2 * ((long) Integer.MAX_VALUE) + 2 + i;\n} else {\nreturn i;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\nthrows IOException {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = new RandomAccessFile(f, \"r\");\nboolean success = false;\ntry {\nMap entriesWithoutEFS = populateFromCentralDirectory();\nresolveLocalFileHeaderData(entriesWithoutEFS);\nsuccess = true;\n} finally {\nif (!success) {\ntry {\narchive.close();\n} catch (IOException e2) {\n// swallow, throw the original exception instead\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
                                    "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\ntry {\nzipfile.close();\n} catch (IOException e) {\n//ignore\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map populateFromCentralDirectory()\nthrows IOException {\nHashMap noEFS = new HashMap();\n\npositionAtCentralDirectory();\n\nbyte[] cfh = new byte[CFH_LEN];\n\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\nfinal long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\nif (sig != cfhSig && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n+ \" corrupt archive.\");\n}\nwhile (sig == cfhSig) {\narchive.readFully(cfh);\nint off = 0;\nZipArchiveEntry ze = new ZipArchiveEntry();\n\nint versionMadeBy = ZipShort.getValue(cfh, off);\noff += SHORT;\nze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\noff += SHORT; // skip version info\n\nfinal int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS =\n(generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0;\nfinal ZipEncoding entryEncoding =\nhasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\noff += SHORT;\n\nze.setMethod(ZipShort.getValue(cfh, off));\noff += SHORT;\n\n// FIXME this is actually not very cpu cycles friendly as we are converting from\n// dos to java while the underlying Sun implementation will convert\n// from java to dos time for internal storage...\nlong time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\nze.setTime(time);\noff += WORD;\n\nze.setCrc(ZipLong.getValue(cfh, off));\noff += WORD;\n\nze.setCompressedSize(ZipLong.getValue(cfh, off));\noff += WORD;\n\nze.setSize(ZipLong.getValue(cfh, off));\noff += WORD;\n\nint fileNameLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nint extraLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nint commentLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\noff += SHORT; // disk number\n\nze.setInternalAttributes(ZipShort.getValue(cfh, off));\noff += SHORT;\n\nze.setExternalAttributes(ZipLong.getValue(cfh, off));\noff += WORD;\n\nbyte[] fileName = new byte[fileNameLen];\narchive.readFully(fileName);\nze.setName(entryEncoding.decode(fileName));\n\n// LFH offset,\nOffsetEntry offset = new OffsetEntry();\noffset.headerOffset = ZipLong.getValue(cfh, off);\n// data offset will be filled later\nentries.put(ze, offset);\n\nnameMap.put(ze.getName(), ze);\n\nbyte[] cdExtraData = new byte[extraLen];\narchive.readFully(cdExtraData);\nze.setCentralDirectoryExtra(cdExtraData);\n\nbyte[] comment = new byte[commentLen];\narchive.readFully(comment);\nze.setComment(entryEncoding.decode(comment));\n\narchive.readFully(signatureBytes);\nsig = ZipLong.getValue(signatureBytes);\n\nif (!hasEFS && useUnicodeExtraFields) {\nnoEFS.put(ze, new NameAndComment(fileName, comment));\n}\n}\nreturn noEFS;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nthrows IOException {\nboolean found = false;\nlong off = archive.length() - MIN_EOCD_SIZE;\nlong stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE);\nif (off >= 0) {\narchive.seek(off);\nbyte[] sig = ZipArchiveOutputStream.EOCD_SIG;\nint curr = archive.read();\nwhile (off >= stopSearching && curr != -1) {\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\n}\n}\n}\n}\narchive.seek(--off);\ncurr = archive.read();\n}\n}\nif (!found) {\nthrow new ZipException(\"archive is not a ZIP archive\");\n}\narchive.seek(off + CFD_LOCATOR_OFFSET);\nbyte[] cfdOffset = new byte[WORD];\narchive.readFully(cfdOffset);\narchive.seek(ZipLong.getValue(cfdOffset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:startsWithLocalFileHeader()Z",
                                    "method_body": "private boolean startsWithLocalFileHeader() throws IOException {\narchive.seek(0);\nfinal byte[] start = new byte[WORD];\narchive.readFully(start);\nfor (int i = 0; i < start.length; i++) {\nif (start[i] != ZipArchiveOutputStream.LFH_SIG[i]) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipArchiveOutputStream(File file) throws IOException {\nOutputStream o = null;\nRandomAccessFile _raf = null;\ntry {\n_raf = new RandomAccessFile(file, \"rw\");\n_raf.setLength(0);\n} catch (IOException e) {\nif (_raf != null) {\ntry {\n_raf.close();\n} catch (IOException inner) {\n// ignore\n}\n_raf = null;\n}\no = new FileOutputStream(file);\n}\nout = o;\nraf = _raf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setEncoding(Ljava/lang/String;)V",
                                    "method_body": "public void setEncoding(final String encoding) {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nuseEFS &= ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setUseLanguageEncodingFlag(Z)V",
                                    "method_body": "public void setUseLanguageEncodingFlag(boolean b) {\nuseEFS = b && ZipEncodingHelper.isUTF8(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setCreateUnicodeExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveOutputStream$UnicodeExtraFieldPolicy;)V",
                                    "method_body": "public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b) {\ncreateUnicodeExtraFields = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int offset, int length) throws IOException {\nif (entry.getMethod() == DEFLATED) {\nif (length > 0) {\nif (!def.finished()) {\nif (length <= DEFLATER_BLOCK_SIZE) {\ndef.setInput(b, offset, length);\ndeflateUntilInputIsNeeded();\n} else {\nfinal int fullblocks = length / DEFLATER_BLOCK_SIZE;\nfor (int i = 0; i < fullblocks; i++) {\ndef.setInput(b, offset + i * DEFLATER_BLOCK_SIZE,\nDEFLATER_BLOCK_SIZE);\ndeflateUntilInputIsNeeded();\n}\nfinal int done = fullblocks * DEFLATER_BLOCK_SIZE;\nif (done < length) {\ndef.setInput(b, offset + done, length - done);\ndeflateUntilInputIsNeeded();\n}\n}\n}\n}\n} else {\nwriteOut(b, offset, length);\nwritten += length;\n}\ncrc.update(b, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:deflateUntilInputIsNeeded()V",
                                    "method_body": "private void deflateUntilInputIsNeeded() throws IOException {\nwhile (!def.needsInput()) {\ndeflate();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:addExtraField(Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void addExtraField(ZipExtraField ze) {\nif (extraFields == null) {\nextraFields = new LinkedHashMap();\n}\nextraFields.put(ze.getHeaderId(), ze);\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:appendSurrogate(Ljava/nio/ByteBuffer;C)V",
                                    "method_body": "static void appendSurrogate(ByteBuffer bb, char c) {\n\nbb.put((byte) '%');\nbb.put((byte) 'U');\n\nbb.put(HEX_DIGITS[(c >> 12)&0x0f]);\nbb.put(HEX_DIGITS[(c >> 8)&0x0f]);\nbb.put(HEX_DIGITS[(c >> 4)&0x0f]);\nbb.put(HEX_DIGITS[c & 0x0f]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:getEncoding()Lorg/apache/commons/compress/archivers/zip/Simple8BitZipEncoding;",
                                    "method_body": "public synchronized Simple8BitZipEncoding getEncoding() {\nif (this.encoding == null) {\nthis.encoding = new Simple8BitZipEncoding(this.highChars);\n}\nreturn this.encoding;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "protected AbstractUnicodeExtraField(String text, byte[] bytes, int off,\nint len) {\nCRC32 crc32 = new CRC32();\ncrc32.update(bytes, off, len);\nnameCRC32 = crc32.getValue();\n\ntry {\nunicodeName = text.getBytes(\"UTF-8\");\n} catch (UnsupportedEncodingException e) {\nthrow new RuntimeException(\"FATAL: UTF-8 encoding not supported.\",\ne);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:assembleData()V",
                                    "method_body": "private void assembleData() {\nif (unicodeName == null) {\nreturn;\n}\n\ndata = new byte[5 + unicodeName.length];\n// version 1\ndata[0] = 0x01;\nSystem.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4);\nSystem.arraycopy(unicodeName, 0, data, 5, unicodeName.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryData()[B",
                                    "method_body": "public byte[] getCentralDirectoryData() {\nif (data == null) {\nthis.assembleData();\n}\nreturn data;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getCentralDirectoryLength() {\nif (data == null) {\nassembleData();\n}\nreturn new ZipShort(data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn getCentralDirectoryData();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn getCentralDirectoryLength();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>(Ljava/lang/String;[BII)V",
                                    "method_body": "public UnicodePathExtraField(String text, byte[] bytes, int off, int len) {\nsuper(text, bytes, off, len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding:<init>([C)V",
                                    "method_body": "public Simple8BitZipEncoding(char[] highChars) {\nthis.highChars = (char[]) highChars.clone();\nList temp = new ArrayList(this.highChars.length);\n\nbyte code = 127;\n\nfor (int i = 0; i < this.highChars.length; ++i) {\ntemp.add(new Simple8BitChar(++code, this.highChars[i]));\n}\n\nCollections.sort(temp);\nthis.reverseMapping = Collections.unmodifiableList(temp);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding:canEncodeChar(C)Z",
                                    "method_body": "public boolean canEncodeChar(char c) {\n\nif (c >= 0 && c < 128) {\nreturn true;\n}\n\nSimple8BitChar r = this.encodeHighChar(c);\nreturn r != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding:pushEncodedChar(Ljava/nio/ByteBuffer;C)Z",
                                    "method_body": "public boolean pushEncodedChar(ByteBuffer bb, char c) {\n\nif (c >= 0 && c < 128) {\nbb.put((byte) c);\nreturn true;\n}\n\nSimple8BitChar r = this.encodeHighChar(c);\nif (r == null) {\nreturn false;\n}\nbb.put(r.code);\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding:encodeHighChar(C)Lorg/apache/commons/compress/archivers/zip/Simple8BitZipEncoding$Simple8BitChar;",
                                    "method_body": "private Simple8BitChar encodeHighChar(char c) {\n// for performance an simplicity, yet another reincarnation of\n// binary search...\nint i0 = 0;\nint i1 = this.reverseMapping.size();\n\nwhile (i1 > i0) {\n\nint i = i0 + (i1 - i0) / 2;\n\nSimple8BitChar m = (Simple8BitChar) this.reverseMapping.get(i);\n\nif (m.unicode == c) {\nreturn m;\n}\n\nif (m.unicode < c) {\ni0 = i + 1;\n} else {\ni1 = i;\n}\n}\n\nif (i0 >= this.reverseMapping.size()) {\nreturn null;\n}\n\nSimple8BitChar r = (Simple8BitChar) this.reverseMapping.get(i0);\n\nif (r.unicode != c) {\nreturn null;\n}\n\nreturn r;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding:canEncode(Ljava/lang/String;)Z",
                                    "method_body": "public boolean canEncode(String name) {\n\nfor (int i=0;i<name.length();++i) {\n\nchar c = name.charAt(i);\n\nif (!this.canEncodeChar(c)) {\nreturn false;\n}\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(String name) {\nByteBuffer out = ByteBuffer.allocate(name.length()\n+ 6 + (name.length() + 1) / 2);\n\nfor (int i=0;i<name.length();++i) {\n\nchar c = name.charAt(i);\n\nif (out.remaining() < 6) {\nout = ZipEncodingHelper.growBuffer(out,out.position() + 6);\n}\n\nif (!this.pushEncodedChar(out,c)) {\n\nZipEncodingHelper.appendSurrogate(out,c);\n}\n}\n\nout.limit(out.position());\nout.rewind();\nreturn out;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding$Simple8BitChar:<init>(BC)V",
                                    "method_body": "Simple8BitChar(byte code, char unicode) {\nthis.code = code;\nthis.unicode = unicode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Simple8BitZipEncoding$Simple8BitChar:compareTo(Ljava/lang/Object;)I",
                                    "method_body": "public int compareTo(Object o) {\nSimple8BitChar a = (Simple8BitChar) o;\n\nreturn this.unicode - a.unicode;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 5,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.Maven221MultiVolumeTest.testRead7ZipMultiVolumeArchiveForStream",
                            "test_body": "69: public void testRead7ZipMultiVolumeArchiveForStream() throws IOException,\n70: URISyntaxException {\n71: 72: URL zip = getClass().getResource(\"/apache-maven-2.2.1.zip.001\");\n73: FileInputStream archive = new FileInputStream(\n74: new File(new URI(zip.toString())));\n75: ZipArchiveInputStream zi = null;\n76: try {\n77: zi = new ZipArchiveInputStream(archive,null,false);\n78: 79: // these are the entries that are supposed to be processed\n80: // correctly without any problems\n81: for (int i = 0; i < ENTRIES.length; i++) {\n82: assertEquals(ENTRIES[i], zi.getNextEntry().getName());\n83: }\n84: 85: // this is the last entry that is truncated\n86: ArchiveEntry lastEntry = zi.getNextEntry();\n87: assertEquals(LAST_ENTRY_NAME, lastEntry.getName());\n88: byte [] buffer = new byte [4096];\n89: 90: // before the fix, we'd get 0 bytes on this read and all\n91: // subsequent reads thus a client application might enter\n92: // an infinite loop after the fix, we should get an\n93: // exception\n94: try {\n95: int read = 0;\n96: while ((read = zi.read(buffer)) > 0) { }\n97: fail(\"shouldn't be able to read from truncated entry\");\n98: } catch (IOException e) {\n99: assertEquals(\"Truncated ZIP file\", e.getMessage());\n100: }\n101: 102: // and now we get another entry, which should also yield\n103: // an exception\n104: try {\n105: zi.getNextEntry();\n106: fail(\"shouldn't be able to read another entry from truncated\"\n107: + \" file\");\n108: } catch (IOException e) {\n109: // this is to be expected\n110: }\n111: } finally {\n112: if (zi != null) {\n113: zi.close();\n114: }\n115: }\n116: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "protected ZipArchiveEntry() {\nsuper(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setPlatform(I)V",
                                    "method_body": "protected void setPlatform(int platform) {\nthis.platform = platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void setExtraFields(ZipExtraField[] fields) {\nextraFields = new LinkedHashMap();\nfor (int i = 0; i < fields.length; i++) {\nextraFields.put(fields[i].getHeaderId(), fields[i]);\n}\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields() {\nif (extraFields == null) {\nreturn new ZipExtraField[0];\n}\nZipExtraField[] result = new ZipExtraField[extraFields.size()];\nreturn (ZipExtraField[]) extraFields.values().toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra([B)V",
                                    "method_body": "public void setExtra(byte[] extra) throws RuntimeException {\ntry {\nZipExtraField[] local = ExtraFieldUtils.parse(extra, true);\nmergeExtraFields(local, true);\n} catch (ZipException e) {\nthrow new RuntimeException(e.getMessage(), e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "protected void setName(String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:mergeExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;Z)V",
                                    "method_body": "private void mergeExtraFields(ZipExtraField[] f, boolean local)\nthrows ZipException {\nif (extraFields == null) {\nsetExtraFields(f);\n} else {\nfor (int i = 0; i < f.length; i++) {\nZipExtraField existing = getExtraField(f[i].getHeaderId());\nif (existing == null) {\naddExtraField(f[i]);\n} else {\nif (local) {\nbyte[] b = f[i].getLocalFileDataData();\nexisting.parseFromLocalFileData(b, 0, b.length);\n} else {\nbyte[] b = f[i].getCentralDirectoryData();\nexisting.parseFromCentralDirectoryData(b, 0, b.length);\n}\n}\n}\nsetExtra();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>([B)V",
                                    "method_body": "public ZipLong (byte[] bytes) {\nthis(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>([BI)V",
                                    "method_body": "public ZipLong (byte[] bytes, int offset) {\nvalue = ZipLong.getValue(bytes, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n//private static final int BYTE_BIT_SIZE = 8;\nprivate static final int BYTE_MASK = 0xFF;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue()J",
                                    "method_body": "public long getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object o) {\nif (o == null || !(o instanceof ZipLong)) {\nreturn false;\n}\nreturn value == ((ZipLong) o).getValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map simpleEncodings;\n\nstatic {\nsimpleEncodings = new HashMap();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for utf-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h =\n(SimpleEncodingHolder) simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\n// check platform's default encoding\nencoding = System.getProperty(\"file.encoding\");\n}\nreturn UTF8.equalsIgnoreCase(encoding)\n|| \"utf-8\".equalsIgnoreCase(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data);\n} else {\nreturn new String(data,this.charset);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\n\n/** No-arg constructor */\npublic JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([BI)I",
                                    "method_body": "public static int getValue(byte[] bytes, int offset) {\nint value = (bytes[offset + 1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n\n/**\n* Static registry of known extra fields.\n*/\nprivate static final Map implementations;\n\nstatic {\nimplementations = new HashMap();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class c) {\ntry {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n} catch (ClassCastException cc) {\nthrow new RuntimeException(c + \" doesn\\'t implement ZipExtraField\");\n} catch (InstantiationException ie) {\nthrow new RuntimeException(c + \" is not a concrete class\");\n} catch (IllegalAccessException ie) {\nthrow new RuntimeException(c + \"\\'s no-arg constructor is not public\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:parse([BZ)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField[] parse(byte[] data, boolean local)\nthrows ZipException {\nList v = new ArrayList();\nint start = 0;\nwhile (start <= data.length - WORD) {\nZipShort headerId = new ZipShort(data, start);\nint length = (new ZipShort(data, start + 2)).getValue();\nif (start + WORD + length > data.length) {\nthrow new ZipException(\"data starting at \" + start\n+ \" is in unknown format\");\n}\ntry {\nZipExtraField ze = createExtraField(headerId);\nif (local) {\nze.parseFromLocalFileData(data, start + WORD, length);\n} else {\nze.parseFromCentralDirectoryData(data, start + WORD,\nlength);\n}\nv.add(ze);\n} catch (InstantiationException ie) {\nthrow new ZipException(ie.getMessage());\n} catch (IllegalAccessException iae) {\nthrow new ZipException(iae.getMessage());\n}\nstart += (length + WORD);\n}\n\nZipExtraField[] result = new ZipExtraField[v.size()];\nreturn (ZipExtraField[]) v.toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nint sum = WORD * data.length;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\n}\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < data.length; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n0, result, start + 2, 2);\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate static final int      WORD = 4;\n/**\n* Standard Unix stat(2) file mode.\n*/\nprivate int mode = 0;\n/**\n* User ID.\n*/\nprivate int uid = 0;\n/**\n* Group ID.\n*/\nprivate int gid = 0;\n/**\n* File this entry points to, if it is a symbolic link.\n*\n* <p>empty string - if entry is not a symbolic link.</p>\n*/\nprivate String link = \"\";\n/**\n* Is this an entry for a directory?\n*/\nprivate boolean dirFlag = false;\n\n/**\n* Instance used to calculate checksums.\n*/\nprivate CRC32 crc = new CRC32();\n\n/** Constructor for AsiExtraField. */\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\n\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\n\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n\n/**\n* Convert a Date object to a DOS date/time field.\n* @param time the <code>Date</code> to convert\n* @return the date as a <code>ZipLong</code>\n*/\npublic static ZipLong toDosTime(Date time) {\nreturn new ZipLong(toDosTime(time.getTime()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:dosToJavaTime(J)J",
                                    "method_body": "public static long dosToJavaTime(long dosTime) {\nCalendar cal = Calendar.getInstance();\n// CheckStyle:MagicNumberCheck OFF - no point\ncal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\ncal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\ncal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);\ncal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);\ncal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);\ncal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);\n// CheckStyle:MagicNumberCheck ON\nreturn cal.getTime().getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream,\nString encoding,\nboolean useUnicodeExtraFields) {\nzipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\nin = new PushbackInputStream(inputStream, buf.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:getNextZipEntry()Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;",
                                    "method_body": "public ZipArchiveEntry getNextZipEntry() throws IOException {\nif (closed || hitCentralDirectory) {\nreturn null;\n}\nif (current != null) {\ncloseEntry();\n}\nbyte[] lfh = new byte[LFH_LEN];\ntry {\nreadFully(lfh);\n} catch (EOFException e) {\nreturn null;\n}\nZipLong sig = new ZipLong(lfh);\nif (sig.equals(ZipLong.CFH_SIG)) {\nhitCentralDirectory = true;\nreturn null;\n}\nif (!sig.equals(ZipLong.LFH_SIG)) {\nreturn null;\n}\n\nint off = WORD;\ncurrent = new ZipArchiveEntry();\n\nint versionMadeBy = ZipShort.getValue(lfh, off);\noff += SHORT;\ncurrent.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT)\n& ZipFile.NIBLET_MASK);\n\nfinal int generalPurposeFlag = ZipShort.getValue(lfh, off);\nfinal boolean hasEFS =\n(generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0;\nfinal ZipEncoding entryEncoding =\nhasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\nhasDataDescriptor = (generalPurposeFlag & 8) != 0;\n\noff += SHORT;\n\ncurrent.setMethod(ZipShort.getValue(lfh, off));\noff += SHORT;\n\nlong time = ZipUtil.dosToJavaTime(ZipLong.getValue(lfh, off));\ncurrent.setTime(time);\noff += WORD;\n\nif (!hasDataDescriptor) {\ncurrent.setCrc(ZipLong.getValue(lfh, off));\noff += WORD;\n\ncurrent.setCompressedSize(ZipLong.getValue(lfh, off));\noff += WORD;\n\ncurrent.setSize(ZipLong.getValue(lfh, off));\noff += WORD;\n} else {\noff += 3 * WORD;\n}\n\nint fileNameLen = ZipShort.getValue(lfh, off);\n\noff += SHORT;\n\nint extraLen = ZipShort.getValue(lfh, off);\noff += SHORT;\n\nbyte[] fileName = new byte[fileNameLen];\nreadFully(fileName);\ncurrent.setName(entryEncoding.decode(fileName));\n\nbyte[] extraData = new byte[extraLen];\nreadFully(extraData);\ncurrent.setExtra(extraData);\n\nif (!hasEFS && useUnicodeExtraFields) {\nZipUtil.setNameAndCommentFromExtraFields(current, fileName, null);\n}\nreturn current;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:getNextEntry()Lorg/apache/commons/compress/archivers/ArchiveEntry;",
                                    "method_body": "public ArchiveEntry getNextEntry() throws IOException {\nreturn getNextZipEntry();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] buffer, int start, int length) throws IOException {\nif (closed) {\nthrow new IOException(\"The stream is closed\");\n}\nif (inf.finished() || current == null) {\nreturn -1;\n}\n\n// avoid int overflow, check null buffer\nif (start <= buffer.length && length >= 0 && start >= 0\n&& buffer.length - start >= length) {\nif (current.getMethod() == ZipArchiveOutputStream.STORED) {\nint csize = (int) current.getSize();\nif (readBytesOfEntry >= csize) {\nreturn -1;\n}\nif (offsetInBuffer >= lengthOfLastRead) {\noffsetInBuffer = 0;\nif ((lengthOfLastRead = in.read(buf)) == -1) {\nreturn -1;\n}\ncount(lengthOfLastRead);\nbytesReadFromStream += lengthOfLastRead;\n}\nint toRead = length > lengthOfLastRead\n? lengthOfLastRead - offsetInBuffer\n: length;\nif ((csize - readBytesOfEntry) < toRead) {\ntoRead = csize - readBytesOfEntry;\n}\nSystem.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\noffsetInBuffer += toRead;\nreadBytesOfEntry += toRead;\ncrc.update(buffer, start, toRead);\nreturn toRead;\n}\nif (inf.needsInput()) {\nfill();\nif (lengthOfLastRead > 0) {\nbytesReadFromStream += lengthOfLastRead;\n}\n}\nint read = 0;\ntry {\nread = inf.inflate(buffer, start, length);\n} catch (DataFormatException e) {\nthrow new ZipException(e.getMessage());\n}\nif (read == 0 && inf.finished()) {\nreturn -1;\n}\ncrc.update(buffer, start, read);\nreturn read;\n}\nthrow new ArrayIndexOutOfBoundsException();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!closed) {\nclosed = true;\nin.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:skip(J)J",
                                    "method_body": "public long skip(long value) throws IOException {\nif (value >= 0) {\nlong skipped = 0;\nbyte[] b = new byte[1024];\nwhile (skipped != value) {\nlong rem = value - skipped;\nint x = read(b, 0, (int) (b.length > rem ? rem : b.length));\nif (x == -1) {\nreturn skipped;\n}\nskipped += x;\n}\nreturn skipped;\n}\nthrow new IllegalArgumentException();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:closeEntry()V",
                                    "method_body": "private void closeEntry() throws IOException {\nif (closed) {\nthrow new IOException(\"The stream is closed\");\n}\nif (current == null) {\nreturn;\n}\n// Ensure all entry bytes are read\nskip(Long.MAX_VALUE);\nint inB;\nif (current.getMethod() == ZipArchiveOutputStream.DEFLATED) {\ninB = inf.getTotalIn();\n} else {\ninB = readBytesOfEntry;\n}\nint diff = 0;\n\n// Pushback any required bytes\nif ((diff = bytesReadFromStream - inB) != 0) {\n((PushbackInputStream) in).unread(buf,\nlengthOfLastRead - diff, diff);\n}\n\nif (hasDataDescriptor) {\nreadFully(new byte[4 * WORD]);\n}\n\ninf.reset();\nreadBytesOfEntry = offsetInBuffer = bytesReadFromStream =\nlengthOfLastRead = 0;\ncrc.reset();\ncurrent = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:fill()V",
                                    "method_body": "private void fill() throws IOException {\nif (closed) {\nthrow new IOException(\"The stream is closed\");\n}\nif ((lengthOfLastRead = in.read(buf)) > 0) {\ninf.setInput(buf, 0, lengthOfLastRead);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readFully([B)V",
                                    "method_body": "private void readFully(byte[] b) throws IOException {\nint count = 0, x = 0;\nwhile (count != b.length) {\ncount += x = in.read(b, count, b.length - count);\nif (x == -1) {\nthrow new EOFException();\n}\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 6,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveEntryTest.testNotEquals",
                            "test_body": "227: public void testNotEquals() {\n228: ZipArchiveEntry entry1 = new ZipArchiveEntry(\"foo\");\n229: ZipArchiveEntry entry2 = new ZipArchiveEntry(\"bar\");\n230: assertFalse(entry1.equals(entry2));\n231: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object obj) {\nif (this == obj) {\nreturn true;\n}\nif (obj == null || getClass() != obj.getClass()) {\nreturn false;\n}\nZipArchiveEntry other = (ZipArchiveEntry) obj;\nif (name == null) {\nif (other.name != null) {\nreturn false;\n}\n} else if (!name.equals(other.name)) {\nreturn false;\n}\nreturn true;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 7,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarUtilsTest.testRoundTripNames",
                            "test_body": "120: public void testRoundTripNames(){\n121: checkName(\"\");\n122: checkName(\"The quick brown fox\\n\");\n123: checkName(\"\\177\");\n124: // checkName(\"\\0\"); // does not work, because NUL is ignored\n125: // COMPRESS-114\n126: checkName(\"0302-0601-3\u00b1\u00b1\u00b1F06\u00b1W220\u00b1ZB\u00b1LALALA\u00b1\u00b1\u00b1\u00b1\u00b1\u00b1\u00b1\u00b1\u00b1\u00b1CAN\u00b1\u00b1DC\u00b1\u00b1\u00b104\u00b1060302\u00b1MOE.model\");\n127: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BII)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset, final int length) {\nStringBuffer result = new StringBuffer(length);\nint          end = offset + length;\n\nfor (int i = offset; i < end; ++i) {\nif (buffer[i] == 0) {\nbreak;\n}\nresult.append((char) buffer[i]);\n}\n\nreturn result.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatNameBytes(Ljava/lang/String;[BII)I",
                                    "method_body": "public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {\nint i;\n\n// copy until end of input or output is reached.\nfor (i = 0; i < length && i < name.length(); ++i) {\nbuf[offset + i] = (byte) name.charAt(i);\n}\n\n// Pad any remaining output bytes with NUL\nfor (; i < length; ++i) {\nbuf[offset + i] = 0;\n}\n\nreturn offset + length;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 8,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarUtilsTest.testParseOctalInvalid",
                            "test_body": "61: public void testParseOctalInvalid() throws Exception{\n62: byte [] buffer;\n63: buffer=new byte[0]; // empty byte array\n64: try {\n65: TarUtils.parseOctal(buffer,0, buffer.length);\n66: fail(\"Expected IllegalArgumentException - should be at least 2 bytes long\");\n67: } catch (IllegalArgumentException expected) {\n68: }\n69: buffer=new byte[]{0}; // 1-byte array\n70: try {\n71: TarUtils.parseOctal(buffer,0, buffer.length);\n72: fail(\"Expected IllegalArgumentException - should be at least 2 bytes long\");\n73: } catch (IllegalArgumentException expected) {\n74: }\n75: buffer=new byte[]{0,0,' '}; // not all NULs\n76: try {\n77: TarUtils.parseOctal(buffer,0, buffer.length);\n78: fail(\"Expected IllegalArgumentException - not all NULs\");\n79: } catch (IllegalArgumentException expected) {\n80: }\n81: buffer=new byte[]{' ',0,0,0}; // not all NULs\n82: try {\n83: TarUtils.parseOctal(buffer,0, buffer.length);\n84: fail(\"Expected IllegalArgumentException - not all NULs\");\n85: } catch (IllegalArgumentException expected) {\n86: }\n87: buffer = \"abcdef \".getBytes(\"UTF-8\"); // Invalid input\n88: try {\n89: TarUtils.parseOctal(buffer,0, buffer.length);\n90: fail(\"Expected IllegalArgumentException\");\n91: } catch (IllegalArgumentException expected) {\n92: }\n93: buffer = \"77777777777\".getBytes(\"UTF-8\"); // Invalid input - no trailer\n94: try {\n95: TarUtils.parseOctal(buffer,0, buffer.length);\n96: fail(\"Expected IllegalArgumentException - no trailer\");\n97: } catch (IllegalArgumentException expected) {\n98: }\n99: buffer = \" 0 07 \".getBytes(\"UTF-8\"); // Invalid - embedded space\n100: try {\n101: TarUtils.parseOctal(buffer,0, buffer.length);\n102: fail(\"Expected IllegalArgumentException - embedded space\");\n103: } catch (IllegalArgumentException expected) {\n104: }\n105: buffer = \" 0\\00007 \".getBytes(\"UTF-8\"); // Invalid - embedded NUL\n106: try {\n107: TarUtils.parseOctal(buffer,0, buffer.length);\n108: fail(\"Expected IllegalArgumentException - embedded NUL\");\n109: } catch (IllegalArgumentException expected) {\n110: }\n111: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nboolean stillPadding = true;\nint     end = offset + length;\nint     start = offset;\n\nfor (int i = start; i < end; i++){\nfinal byte currentByte = buffer[i];\nif (currentByte == 0) {\nbreak;\n}\n\n// Skip leading spaces\nif (currentByte == (byte) ' ' || currentByte == '0') {\nif (stillPadding) {\ncontinue;\n}\nif (currentByte == (byte) ' ') {\nbreak;\n}\n}\n\n// Must have trailing NUL or space\n// May have additional NUL or space\n\nstillPadding = false;\n// CheckStyle:MagicNumber OFF\nif (currentByte < '0' || currentByte > '7'){\nthrow new IllegalArgumentException(\nexceptionMessage(buffer, offset, length, start, currentByte));\n}\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\n// CheckStyle:MagicNumber ON\n}\n\nreturn result;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 9,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest.testCount",
                            "test_body": "31: public void testCount() throws Exception {\n32: File f = File.createTempFile(\"commons-compress-tarcount\", \".tar\");\n33: f.deleteOnExit();\n34: FileOutputStream fos = new FileOutputStream(f);\n35: 36: ArchiveOutputStream tarOut = new ArchiveStreamFactory()\n37: .createArchiveOutputStream(ArchiveStreamFactory.TAR, fos);\n38: 39: File file1 = getFile(\"test1.xml\");\n40: TarArchiveEntry sEntry = new TarArchiveEntry(file1);\n41: tarOut.putArchiveEntry(sEntry);\n42: 43: FileInputStream in = new FileInputStream(file1);\n44: byte[] buf = new byte[8192];\n45: 46: int read = 0;\n47: while ((read = in.read(buf)) > 0) {\n48: tarOut.write(buf, 0, read);\n49: }\n50: 51: in.close();\n52: tarOut.closeArchiveEntry();\n53: tarOut.close();\n54: 55: assertEquals(f.length(), tarOut.getBytesWritten());\n56: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveOutputStream(Ljava/lang/String;Ljava/io/OutputStream;)Lorg/apache/commons/compress/archivers/ArchiveOutputStream;",
                                    "method_body": "public ArchiveOutputStream createArchiveOutputStream(\nfinal String archiverName, final OutputStream out)\nthrows ArchiveException {\nif (archiverName == null) {\nthrow new IllegalArgumentException(\"Archivername must not be null.\");\n}\nif (out == null) {\nthrow new IllegalArgumentException(\"OutputStream must not be null.\");\n}\n\nif (AR.equalsIgnoreCase(archiverName)) {\nreturn new ArArchiveOutputStream(out);\n}\nif (ZIP.equalsIgnoreCase(archiverName)) {\nreturn new ZipArchiveOutputStream(out);\n}\nif (TAR.equalsIgnoreCase(archiverName)) {\nreturn new TarArchiveOutputStream(out);\n}\nif (JAR.equalsIgnoreCase(archiverName)) {\nreturn new JarArchiveOutputStream(out);\n}\nif (CPIO.equalsIgnoreCase(archiverName)) {\nreturn new CpioArchiveOutputStream(out);\n}\nthrow new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveOutputStream:count(I)V",
                                    "method_body": "protected void count(int written) {\ncount((long) written);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveOutputStream:count(J)V",
                                    "method_body": "protected void count(long written) {\nif (written != -1) {\nbytesWritten = bytesWritten + written;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveOutputStream:getBytesWritten()J",
                                    "method_body": "public long getBytesWritten() {\nreturn bytesWritten;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry () {\nthis.magic = MAGIC_POSIX;\nthis.version = VERSION_POSIX;\nthis.name = \"\";\nthis.linkName = \"\";\n\nString user = System.getProperty(\"user.name\", \"\");\n\nif (user.length() > MAX_NAMELEN) {\nuser = user.substring(0, MAX_NAMELEN);\n}\n\nthis.userId = 0;\nthis.groupId = 0;\nthis.userName = user;\nthis.groupName = \"\";\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/io/File;)V",
                                    "method_body": "public TarArchiveEntry(File file) {\nthis(file, normalizeFileName(file.getPath(), false));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/io/File;Ljava/lang/String;)V",
                                    "method_body": "public TarArchiveEntry(File file, String fileName) {\nthis();\n\nthis.file = file;\n\nthis.linkName = \"\";\n\nif (file.isDirectory()) {\nthis.mode = DEFAULT_DIR_MODE;\nthis.linkFlag = LF_DIR;\n\nint nameLength = fileName.length();\nif (nameLength == 0 || fileName.charAt(nameLength - 1) != '/') {\nthis.name = fileName + \"/\";\n} else {\nthis.name = fileName;\n}\nthis.size = 0;\n} else {\nthis.mode = DEFAULT_FILE_MODE;\nthis.linkFlag = LF_NORMAL;\nthis.size = file.length();\nthis.name = fileName;\n}\n\nthis.modTime = file.lastModified() / MILLIS_PER_SECOND;\nthis.devMajor = 0;\nthis.devMinor = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nif (file != null) {\nreturn file.isDirectory();\n}\n\nif (linkFlag == LF_DIR) {\nreturn true;\n}\n\nif (getName().endsWith(\"/\")) {\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:writeEntryHeader([B)V",
                                    "method_body": "public void writeEntryHeader(byte[] outbuf) {\nint offset = 0;\n\noffset = TarUtils.formatNameBytes(name, outbuf, offset, NAMELEN);\noffset = TarUtils.formatOctalBytes(mode, outbuf, offset, MODELEN);\noffset = TarUtils.formatOctalBytes(userId, outbuf, offset, UIDLEN);\noffset = TarUtils.formatOctalBytes(groupId, outbuf, offset, GIDLEN);\noffset = TarUtils.formatLongOctalBytes(size, outbuf, offset, SIZELEN);\noffset = TarUtils.formatLongOctalBytes(modTime, outbuf, offset, MODTIMELEN);\n\nint csOffset = offset;\n\nfor (int c = 0; c < CHKSUMLEN; ++c) {\noutbuf[offset++] = (byte) ' ';\n}\n\noutbuf[offset++] = linkFlag;\noffset = TarUtils.formatNameBytes(linkName, outbuf, offset, NAMELEN);\noffset = TarUtils.formatNameBytes(magic, outbuf, offset, MAGICLEN);\noffset = TarUtils.formatNameBytes(version, outbuf, offset, VERSIONLEN);\noffset = TarUtils.formatNameBytes(userName, outbuf, offset, UNAMELEN);\noffset = TarUtils.formatNameBytes(groupName, outbuf, offset, GNAMELEN);\noffset = TarUtils.formatOctalBytes(devMajor, outbuf, offset, DEVLEN);\noffset = TarUtils.formatOctalBytes(devMinor, outbuf, offset, DEVLEN);\n\nwhile (offset < outbuf.length) {\noutbuf[offset++] = 0;\n}\n\nlong chk = TarUtils.computeCheckSum(outbuf);\n\nTarUtils.formatCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:normalizeFileName(Ljava/lang/String;Z)Ljava/lang/String;",
                                    "method_body": "private static String normalizeFileName(String fileName,\nboolean preserveLeadingSlashes) {\nString osname = System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH);\n\nif (osname != null) {\n\n// Strip off drive letters!\n// REVIEW Would a better check be \"(File.separator == '\\')\"?\n\nif (osname.startsWith(\"windows\")) {\nif (fileName.length() > 2) {\nchar ch1 = fileName.charAt(0);\nchar ch2 = fileName.charAt(1);\n\nif (ch2 == ':'\n&& ((ch1 >= 'a' && ch1 <= 'z')\n|| (ch1 >= 'A' && ch1 <= 'Z'))) {\nfileName = fileName.substring(2);\n}\n}\n} else if (osname.indexOf(\"netware\") > -1) {\nint colon = fileName.indexOf(':');\nif (colon != -1) {\nfileName = fileName.substring(colon + 1);\n}\n}\n}\n\nfileName = fileName.replace(File.separatorChar, '/');\n\n// No absolute pathnames\n// Windows (and Posix?) paths can start with \"\\\\NetworkDrive\\\",\n// so we loop on starting /'s.\nwhile (!preserveLeadingSlashes && fileName.startsWith(\"/\")) {\nfileName = fileName.substring(1);\n}\nreturn fileName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public TarArchiveOutputStream(OutputStream os) {\nthis(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;II)V",
                                    "method_body": "public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) {\nout = new CountingOutputStream(os);\n\nthis.buffer = new TarBuffer(out, blockSize, recordSize);\nthis.assemLen = 0;\nthis.assemBuf = new byte[recordSize];\nthis.recordBuf = new byte[recordSize];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif (finished) {\nthrow new IOException(\"This archive has already been finished\");\n}\n\nif(haveUnclosedEntry) {\nthrow new IOException(\"This archives contains unclosed entries.\");\n}\nwriteEOFRecord();\nwriteEOFRecord();\nbuffer.flushBlock();\nfinished = true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif(!finished) {\nfinish();\n}\n\nif (!closed) {\nbuffer.close();\nout.close();\nclosed = true;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\nif(finished) {\nthrow new IOException(\"Stream has already been finished\");\n}\nTarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\nif (entry.getName().length() >= TarConstants.NAMELEN) {\n\nif (longFileMode == LONGFILE_GNU) {\n// create a TarEntry for the LongLink, the contents\n// of which are the entry's name\nTarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\nTarConstants.LF_GNUTYPE_LONGNAME);\n\nfinal byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName());\nlongLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL\nputArchiveEntry(longLinkEntry);\nwrite(nameBytes);\nwrite(0); // NUL terminator\ncloseArchiveEntry();\n} else if (longFileMode != LONGFILE_TRUNCATE) {\nthrow new RuntimeException(\"file name '\" + entry.getName()\n+ \"' is too long ( > \"\n+ TarConstants.NAMELEN + \" bytes)\");\n}\n}\n\nentry.writeEntryHeader(recordBuf);\nbuffer.writeRecord(recordBuf);\n\ncurrBytes = 0;\n\nif (entry.isDirectory()) {\ncurrSize = 0;\n} else {\ncurrSize = entry.getSize();\n}\ncurrName = entry.getName();\nhaveUnclosedEntry = true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif(finished) {\nthrow new IOException(\"Stream has already been finished\");\n}\nif (!haveUnclosedEntry){\nthrow new IOException(\"No current entry to close\");\n}\nif (assemLen > 0) {\nfor (int i = assemLen; i < assemBuf.length; ++i) {\nassemBuf[i] = 0;\n}\n\nbuffer.writeRecord(assemBuf);\n\ncurrBytes += assemLen;\nassemLen = 0;\n}\n\nif (currBytes < currSize) {\nthrow new IOException(\"entry '\" + currName + \"' closed at '\"\n+ currBytes\n+ \"' before the '\" + currSize\n+ \"' bytes specified in the header were written\");\n}\nhaveUnclosedEntry = false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\nif ((currBytes + numToWrite) > currSize) {\nthrow new IOException(\"request to write '\" + numToWrite\n+ \"' bytes exceeds size in header of '\"\n+ currSize + \"' bytes for entry '\"\n+ currName + \"'\");\n\n//\n// We have to deal with assembly!!!\n// The programmer can be writing little 32 byte chunks for all\n// we know, and we must assemble complete records for writing.\n// REVIEW Maybe this should be in TarBuffer? Could that help to\n// eliminate some of the buffer copying.\n//\n}\n\nif (assemLen > 0) {\nif ((assemLen + numToWrite) >= recordBuf.length) {\nint aLen = recordBuf.length - assemLen;\n\nSystem.arraycopy(assemBuf, 0, recordBuf, 0,\nassemLen);\nSystem.arraycopy(wBuf, wOffset, recordBuf,\nassemLen, aLen);\nbuffer.writeRecord(recordBuf);\n\ncurrBytes += recordBuf.length;\nwOffset += aLen;\nnumToWrite -= aLen;\nassemLen = 0;\n} else {\nSystem.arraycopy(wBuf, wOffset, assemBuf, assemLen,\nnumToWrite);\n\nwOffset += numToWrite;\nassemLen += numToWrite;\nnumToWrite = 0;\n}\n}\n\n//\n// When we get here we have EITHER:\n// o An empty \"assemble\" buffer.\n// o No bytes to write (numToWrite == 0)\n//\nwhile (numToWrite > 0) {\nif (numToWrite < recordBuf.length) {\nSystem.arraycopy(wBuf, wOffset, assemBuf, assemLen,\nnumToWrite);\n\nassemLen += numToWrite;\n\nbreak;\n}\n\nbuffer.writeRecord(wBuf, wOffset);\n\nint num = recordBuf.length;\n\ncurrBytes += num;\nnumToWrite -= num;\nwOffset += num;\n}\ncount(numToWrite);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:writeEOFRecord()V",
                                    "method_body": "private void writeEOFRecord() throws IOException {\nfor (int i = 0; i < recordBuf.length; ++i) {\nrecordBuf[i] = 0;\n}\n\nbuffer.writeRecord(recordBuf);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public CountingOutputStream(final OutputStream out) {\nsuper(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int off, int len) throws IOException {\nout.write(b, off, len);\ncount(len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:count(J)V",
                                    "method_body": "protected void count(long written) {\nif (written != -1) {\nbytesWritten.addAndGet(written);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/OutputStream;II)V",
                                    "method_body": "public TarBuffer(OutputStream outStream, int blockSize, int recordSize) {\nthis.inStream = null;\nthis.outStream = outStream;\n\nthis.initialize(blockSize, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:initialize(II)V",
                                    "method_body": "private void initialize(int blockSize, int recordSize) {\nthis.blockSize = blockSize;\nthis.recordSize = recordSize;\nthis.recsPerBlock = (this.blockSize / this.recordSize);\nthis.blockBuffer = new byte[this.blockSize];\n\nif (this.inStream != null) {\nthis.currBlkIdx = -1;\nthis.currRecIdx = this.recsPerBlock;\n} else {\nthis.currBlkIdx = 0;\nthis.currRecIdx = 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:writeRecord([B)V",
                                    "method_body": "public void writeRecord(byte[] record) throws IOException {\nif (outStream == null) {\nif (inStream == null){\nthrow new IOException(\"Output buffer is closed\");\n}\nthrow new IOException(\"writing to an input buffer\");\n}\n\nif (record.length != recordSize) {\nthrow new IOException(\"record to write has length '\"\n+ record.length\n+ \"' which is not the record size of '\"\n+ recordSize + \"'\");\n}\n\nif (currRecIdx >= recsPerBlock) {\nwriteBlock();\n}\n\nSystem.arraycopy(record, 0, blockBuffer,\n(currRecIdx * recordSize),\nrecordSize);\n\ncurrRecIdx++;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:writeBlock()V",
                                    "method_body": "private void writeBlock() throws IOException {\nif (outStream == null) {\nthrow new IOException(\"writing to an input buffer\");\n}\n\noutStream.write(blockBuffer, 0, blockSize);\noutStream.flush();\n\ncurrRecIdx = 0;\ncurrBlkIdx++;\nArrays.fill(blockBuffer, (byte) 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:flushBlock()V",
                                    "method_body": "void flushBlock() throws IOException {\nif (outStream == null) {\nthrow new IOException(\"writing to an input buffer\");\n}\n\nif (currRecIdx > 0) {\nwriteBlock();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:close()V",
                                    "method_body": "public void close() throws IOException {\nif (outStream != null) {\nflushBlock();\n\nif (outStream != System.out\n&& outStream != System.err) {\noutStream.close();\n\noutStream = null;\n}\n} else if (inStream != null) {\nif (inStream != System.in) {\ninStream.close();\n}\ninStream = null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatNameBytes(Ljava/lang/String;[BII)I",
                                    "method_body": "public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {\nint i;\n\n// copy until end of input or output is reached.\nfor (i = 0; i < length && i < name.length(); ++i) {\nbuf[offset + i] = (byte) name.charAt(i);\n}\n\n// Pad any remaining output bytes with NUL\nfor (; i < length; ++i) {\nbuf[offset + i] = 0;\n}\n\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatUnsignedOctalString(J[BII)V",
                                    "method_body": "public static void formatUnsignedOctalString(final long value, byte[] buffer,\nfinal int offset, final int length) {\nint remaining = length;\nremaining--;\nif (value == 0) {\nbuffer[offset + remaining--] = (byte) '0';\n} else {\nlong val = value;\nfor (; remaining >= 0 && val != 0; --remaining) {\n// CheckStyle:MagicNumber OFF\nbuffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));\nval = val >>> 3;\n// CheckStyle:MagicNumber ON\n}\nif (val != 0){\nthrow new IllegalArgumentException\n(value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length);\n}\n}\n\nfor (; remaining >= 0; --remaining) { // leading zeros\nbuffer[offset + remaining] = (byte) '0';\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatOctalBytes(J[BII)I",
                                    "method_body": "public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\nint idx=length-2; // For space and trailing null\nformatUnsignedOctalString(value, buf, offset, idx);\n\nbuf[offset + idx++] = (byte) ' '; // Trailing space\nbuf[offset + idx]   = 0; // Trailing null\n\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatLongOctalBytes(J[BII)I",
                                    "method_body": "public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\nint idx=length-1; // For space\n\nformatUnsignedOctalString(value, buf, offset, idx);\nbuf[offset + idx] = (byte) ' '; // Trailing space\n\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatCheckSumOctalBytes(J[BII)I",
                                    "method_body": "public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\nint idx=length-2; // for NUL and space\nformatUnsignedOctalString(value, buf, offset, idx);\n\nbuf[offset + idx++]   = 0; // Trailing null\nbuf[offset + idx]     = (byte) ' '; // Trailing space\n\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:computeCheckSum([B)J",
                                    "method_body": "public static long computeCheckSum(final byte[] buf) {\nlong sum = 0;\n\nfor (int i = 0; i < buf.length; ++i) {\nsum += BYTE_MASK & buf[i];\n}\n\nreturn sum;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 10,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testReadWinZipArchive",
                            "test_body": "126: public void testReadWinZipArchive() throws IOException, URISyntaxException {\n127: URL zip = getClass().getResource(\"/utf8-winzip-test.zip\");\n128: File archive = new File(new URI(zip.toString()));\n129: ZipFile zf = null;\n130: try {\n131: zf = new ZipFile(archive, null, true);\n132: assertCanRead(zf, ASCII_TXT);\n133: assertCanRead(zf, EURO_FOR_DOLLAR_TXT);\n134: assertCanRead(zf, OIL_BARREL_TXT);\n135: } finally {\n136: ZipFile.closeQuietly(zf);\n137: }\n138: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "protected ZipArchiveEntry() {\nthis(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getMethod()I",
                                    "method_body": "public int getMethod() {\nreturn method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setMethod(I)V",
                                    "method_body": "public void setMethod(int method) {\nif (method < 0) {\nthrow new IllegalArgumentException(\n\"ZIP compression method can not be negative: \" + method);\n}\nthis.method = method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setInternalAttributes(I)V",
                                    "method_body": "public void setInternalAttributes(int value) {\ninternalAttributes = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExternalAttributes(J)V",
                                    "method_body": "public void setExternalAttributes(long value) {\nexternalAttributes = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setPlatform(I)V",
                                    "method_body": "protected void setPlatform(int platform) {\nthis.platform = platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void setExtraFields(ZipExtraField[] fields) {\nextraFields = new LinkedHashMap<ZipShort, ZipExtraField>();\nfor (int i = 0; i < fields.length; i++) {\nif (fields[i] instanceof UnparseableExtraFieldData) {\nunparseableExtra = (UnparseableExtraFieldData) fields[i];\n} else {\nextraFields.put(fields[i].getHeaderId(), fields[i]);\n}\n}\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields(Z)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields(boolean includeUnparseable) {\nif (extraFields == null) {\nreturn !includeUnparseable || unparseableExtra == null\n? new ZipExtraField[0]\n: new ZipExtraField[] { unparseableExtra };\n}\nList<ZipExtraField> result =\nnew ArrayList<ZipExtraField>(extraFields.values());\nif (includeUnparseable && unparseableExtra != null) {\nresult.add(unparseableExtra);\n}\nreturn result.toArray(new ZipExtraField[0]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField getExtraField(ZipShort type) {\nif (extraFields != null) {\nreturn extraFields.get(type);\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra([B)V",
                                    "method_body": "public void setExtra(byte[] extra) throws RuntimeException {\ntry {\nZipExtraField[] local =\nExtraFieldUtils.parse(extra, true,\nExtraFieldUtils.UnparseableExtraField.READ);\nmergeExtraFields(local, true);\n} catch (ZipException e) {\n// actually this is not possible as of Commons Compress 1.1\nthrow new RuntimeException(\"Error parsing extra fields for entry: \"\n+ getName() + \" - \" + e.getMessage(), e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields(true)));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setCentralDirectoryExtra([B)V",
                                    "method_body": "public void setCentralDirectoryExtra(byte[] b) {\ntry {\nZipExtraField[] central =\nExtraFieldUtils.parse(b, false,\nExtraFieldUtils.UnparseableExtraField.READ);\nmergeExtraFields(central, false);\n} catch (ZipException e) {\nthrow new RuntimeException(e.getMessage(), e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "protected void setName(String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nif (size < 0) {\nthrow new IllegalArgumentException(\"invalid entry size\");\n}\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;[B)V",
                                    "method_body": "protected void setName(String name, byte[] rawName) {\nsetName(name);\nthis.rawName = rawName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\n// this method has severe consequences on performance. We cannot rely\n// on the super.hashCode() method since super.getName() always return\n// the empty string in the current implemention (there's no setter)\n// so it is basically draining the performance of a hashmap lookup\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getGeneralPurposeBit()Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "public GeneralPurposeBit getGeneralPurposeBit() {\nreturn gpb;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setGeneralPurposeBit(Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;)V",
                                    "method_body": "public void setGeneralPurposeBit(GeneralPurposeBit b) {\ngpb = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:mergeExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;Z)V",
                                    "method_body": "private void mergeExtraFields(ZipExtraField[] f, boolean local)\nthrows ZipException {\nif (extraFields == null) {\nsetExtraFields(f);\n} else {\nfor (int i = 0; i < f.length; i++) {\nZipExtraField existing;\nif (f[i] instanceof UnparseableExtraFieldData) {\nexisting = unparseableExtra;\n} else {\nexisting = getExtraField(f[i].getHeaderId());\n}\nif (existing == null) {\naddExtraField(f[i]);\n} else {\nif (local) {\nbyte[] b = f[i].getLocalFileDataData();\nexisting.parseFromLocalFileData(b, 0, b.length);\n} else {\nbyte[] b = f[i].getCentralDirectoryData();\nexisting.parseFromCentralDirectoryData(b, 0, b.length);\n}\n}\n}\nsetExtra();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:<init>()V",
                                    "method_body": "public GeneralPurposeBit() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesUTF8ForNames()Z",
                                    "method_body": "public boolean usesUTF8ForNames() {\nreturn languageEncodingFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useUTF8ForNames(Z)V",
                                    "method_body": "public void useUTF8ForNames(boolean b) {\nlanguageEncodingFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useDataDescriptor(Z)V",
                                    "method_body": "public void useDataDescriptor(boolean b) {\ndataDescriptorFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesEncryption()Z",
                                    "method_body": "public boolean usesEncryption() {\nreturn encryptionFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useEncryption(Z)V",
                                    "method_body": "public void useEncryption(boolean b) {\nencryptionFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useStrongEncryption(Z)V",
                                    "method_body": "public void useStrongEncryption(boolean b) {\nstrongEncryptionFlag = b;\nif (b) {\nuseEncryption(true);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:parse([BI)Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "public static GeneralPurposeBit parse(final byte[] data, final int offset) {\nfinal int generalPurposeFlag = ZipShort.getValue(data, offset);\nGeneralPurposeBit b = new GeneralPurposeBit();\nb.useDataDescriptor((generalPurposeFlag & DATA_DESCRIPTOR_FLAG) != 0);\nb.useUTF8ForNames((generalPurposeFlag & UFT8_NAMES_FLAG) != 0);\nb.useStrongEncryption((generalPurposeFlag & STRONG_ENCRYPTION_FLAG)\n!= 0);\nb.useEncryption((generalPurposeFlag & ENCRYPTION_FLAG) != 0);\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "public static final int EFS_FLAG = GeneralPurposeBit.UFT8_NAMES_FLAG;\n\n/**\n* Current entry.\n*/\nprivate CurrentEntry entry;\n\n/**\n* The file comment.\n*/\nprivate String comment = \"\";\n\n/**\n* Compression level for next entry.\n*/\nprivate int level = DEFAULT_COMPRESSION;\n\n/**\n* Has the compression level changed when compared to the last\n* entry?\n*/\nprivate boolean hasCompressionLevelChanged = false;\n\n/**\n* Default compression method for next entry.\n*/\nprivate int method = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* List of ZipArchiveEntries written so far.\n*/\nprivate final List<ZipArchiveEntry> entries =\nnew LinkedList<ZipArchiveEntry>();\n\n/**\n* CRC instance to avoid parsing DEFLATED data twice.\n*/\nprivate final CRC32 crc = new CRC32();\n\n/**\n* Count the bytes written to out.\n*/\nprivate long written = 0;\n\n/**\n* Start of central directory.\n*/\nprivate long cdOffset = 0;\n\n/**\n* Length of central directory.\n*/\nprivate long cdLength = 0;\n\n/**\n* Helper, a 0 as ZipShort.\n*/\nprivate static final byte[] ZERO = {0, 0};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Data Descriptor signature\n* @since Apache Commons Compress 1.1\n*/\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\n\n/**\n* Value stored in size and similar fields if ZIP64 extensions are\n* used.\n* @since Apache Commons Compress 1.3\n*/\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n\nstatic {\nsimpleEncodings = new HashMap<String, SimpleEncodingHolder>();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for utf-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h = simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\n// check platform's default encoding\nencoding = System.getProperty(\"file.encoding\");\n}\nreturn UTF8.equalsIgnoreCase(encoding)\n|| UTF_DASH_8.equalsIgnoreCase(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data);\n} else {\nreturn new String(data,this.charset);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\n\n/** No-arg constructor */\npublic JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>([BI)V",
                                    "method_body": "public ZipShort (byte[] bytes, int offset) {\nvalue = ZipShort.getValue(bytes, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([BI)I",
                                    "method_body": "public static int getValue(byte[] bytes, int offset) {\nint value = (bytes[offset + 1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([B)I",
                                    "method_body": "public static int getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object o) {\nif (o == null || !(o instanceof ZipShort)) {\nreturn false;\n}\nreturn value == ((ZipShort) o).getValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n\n/**\n* Static registry of known extra fields.\n*/\nprivate static final Map<ZipShort, Class<?>> implementations;\n\nstatic {\nimplementations = new HashMap<ZipShort, Class<?>>();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\nregister(Zip64ExtendedInformationExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class<?> c) {\ntry {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n} catch (ClassCastException cc) {\nthrow new RuntimeException(c + \" doesn\\'t implement ZipExtraField\");\n} catch (InstantiationException ie) {\nthrow new RuntimeException(c + \" is not a concrete class\");\n} catch (IllegalAccessException ie) {\nthrow new RuntimeException(c + \"\\'s no-arg constructor is not public\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:createExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField createExtraField(ZipShort headerId)\nthrows InstantiationException, IllegalAccessException {\nClass<?> c = implementations.get(headerId);\nif (c != null) {\nreturn (ZipExtraField) c.newInstance();\n}\nUnrecognizedExtraField u = new UnrecognizedExtraField();\nu.setHeaderId(headerId);\nreturn u;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:parse([BZLorg/apache/commons/compress/archivers/zip/ExtraFieldUtils$UnparseableExtraField;)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField[] parse(byte[] data, boolean local,\nUnparseableExtraField onUnparseableData)\nthrows ZipException {\nList<ZipExtraField> v = new ArrayList<ZipExtraField>();\nint start = 0;\nLOOP:\nwhile (start <= data.length - WORD) {\nZipShort headerId = new ZipShort(data, start);\nint length = (new ZipShort(data, start + 2)).getValue();\nif (start + WORD + length > data.length) {\nswitch(onUnparseableData.getKey()) {\ncase UnparseableExtraField.THROW_KEY:\nthrow new ZipException(\"bad extra field starting at \"\n+ start + \".  Block length of \"\n+ length + \" bytes exceeds remaining\"\n+ \" data of \"\n+ (data.length - start - WORD)\n+ \" bytes.\");\ncase UnparseableExtraField.READ_KEY:\nUnparseableExtraFieldData field =\nnew UnparseableExtraFieldData();\nif (local) {\nfield.parseFromLocalFileData(data, start,\ndata.length - start);\n} else {\nfield.parseFromCentralDirectoryData(data, start,\ndata.length - start);\n}\nv.add(field);\n//$FALL-THROUGH$\ncase UnparseableExtraField.SKIP_KEY:\n// since we cannot parse the data we must assume\n// the extra field consumes the whole rest of the\n// available data\nbreak LOOP;\ndefault:\nthrow new ZipException(\"unknown UnparseableExtraField key: \"\n+ onUnparseableData.getKey());\n}\n}\ntry {\nZipExtraField ze = createExtraField(headerId);\nif (local) {\nze.parseFromLocalFileData(data, start + WORD, length);\n} else {\nze.parseFromCentralDirectoryData(data, start + WORD,\nlength);\n}\nv.add(ze);\n} catch (InstantiationException ie) {\nthrow new ZipException(ie.getMessage());\n} catch (IllegalAccessException iae) {\nthrow new ZipException(iae.getMessage());\n}\nstart += (length + WORD);\n}\n\nZipExtraField[] result = new ZipExtraField[v.size()];\nreturn v.toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nfinal boolean lastIsUnparseableHolder = data.length > 0\n&& data[data.length - 1] instanceof UnparseableExtraFieldData;\nint regularExtraFieldCount =\nlastIsUnparseableHolder ? data.length - 1 : data.length;\n\nint sum = WORD * regularExtraFieldCount;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\n}\n\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n0, result, start + 2, 2);\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\n}\nif (lastIsUnparseableHolder) {\nbyte[] local = data[data.length - 1].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start, local.length);\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate static final int      WORD = 4;\n/**\n* Standard Unix stat(2) file mode.\n*/\nprivate int mode = 0;\n/**\n* User ID.\n*/\nprivate int uid = 0;\n/**\n* Group ID.\n*/\nprivate int gid = 0;\n/**\n* File this entry points to, if it is a symbolic link.\n*\n* <p>empty string - if entry is not a symbolic link.</p>\n*/\nprivate String link = \"\";\n/**\n* Is this an entry for a directory?\n*/\nprivate boolean dirFlag = false;\n\n/**\n* Instance used to calculate checksums.\n*/\nprivate CRC32 crc = new CRC32();\n\n/** Constructor for AsiExtraField. */\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:assembleData()V",
                                    "method_body": "private void assembleData() {\nif (unicodeName == null) {\nreturn;\n}\n\ndata = new byte[5 + unicodeName.length];\n// version 1\ndata[0] = 0x01;\nSystem.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4);\nSystem.arraycopy(unicodeName, 0, data, 5, unicodeName.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getNameCRC32()J",
                                    "method_body": "public long getNameCRC32() {\nreturn nameCRC32;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getUnicodeName()[B",
                                    "method_body": "public byte[] getUnicodeName() {\nbyte[] b = null;\nif (unicodeName != null) {\nb = new byte[unicodeName.length];\nSystem.arraycopy(unicodeName, 0, b, 0, b.length);\n}\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryData()[B",
                                    "method_body": "public byte[] getCentralDirectoryData() {\nif (data == null) {\nthis.assembleData();\n}\nbyte[] b = null;\nif (data != null) {\nb = new byte[data.length];\nSystem.arraycopy(data, 0, b, 0, b.length);\n}\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getCentralDirectoryLength() {\nif (data == null) {\nassembleData();\n}\nreturn new ZipShort(data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn getCentralDirectoryData();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn getCentralDirectoryLength();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:parseFromLocalFileData([BII)V",
                                    "method_body": "public void parseFromLocalFileData(byte[] buffer, int offset, int length)\nthrows ZipException {\n\nif (length < 5) {\nthrow new ZipException(\"UniCode path extra data must have at least 5 bytes.\");\n}\n\nint version = buffer[offset];\n\nif (version != 0x01) {\nthrow new ZipException(\"Unsupported version [\" + version\n+ \"] for UniCode path extra data.\");\n}\n\nnameCRC32 = ZipLong.getValue(buffer, offset + 1);\nunicodeName = new byte[length - 5];\nSystem.arraycopy(buffer, offset + 5, unicodeName, 0, length - 5);\ndata = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:parseFromCentralDirectoryData([BII)V",
                                    "method_body": "public void parseFromCentralDirectoryData(byte[] buffer, int offset,\nint length)\nthrows ZipException {\nparseFromLocalFileData(buffer, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\n\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\n\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<init>()V",
                                    "method_body": "public Zip64ExtendedInformationExtraField() { }\npublic Zip64ExtendedInformationExtraField() { }"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<clinit>()V",
                                    "method_body": "static final ZipShort HEADER_ID = new ZipShort(0x0001);\n\nprivate static final String LFH_MUST_HAVE_BOTH_SIZES_MSG =\n\"Zip64 extended information must contain\"\n+ \" both size values in the local file header.\";\n\nprivate ZipEightByteInteger size, compressedSize, relativeHeaderOffset;\nprivate ZipLong diskStart;\n\n/**\n* Stored in {@link #parseFromCentralDirectoryData\n* parseFromCentralDirectoryData} so it can be reused when ZipFile"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n\n/**\n* Convert a Date object to a DOS date/time field.\n* @param time the <code>Date</code> to convert\n* @return the date as a <code>ZipLong</code>\n*/\npublic static ZipLong toDosTime(Date time) {\nreturn new ZipLong(toDosTime(time.getTime()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:dosToJavaTime(J)J",
                                    "method_body": "public static long dosToJavaTime(long dosTime) {\nCalendar cal = Calendar.getInstance();\n// CheckStyle:MagicNumberCheck OFF - no point\ncal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\ncal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\ncal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);\ncal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);\ncal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);\ncal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);\n// CheckStyle:MagicNumberCheck ON\nreturn cal.getTime().getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:setNameAndCommentFromExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;[B[B)V",
                                    "method_body": "static void setNameAndCommentFromExtraFields(ZipArchiveEntry ze,\nbyte[] originalNameBytes,\nbyte[] commentBytes) {\nUnicodePathExtraField name = (UnicodePathExtraField)\nze.getExtraField(UnicodePathExtraField.UPATH_ID);\nString originalName = ze.getName();\nString newName = getUnicodeStringIfOriginalMatches(name,\noriginalNameBytes);\nif (newName != null && !originalName.equals(newName)) {\nze.setName(newName);\n}\n\nif (commentBytes != null && commentBytes.length > 0) {\nUnicodeCommentExtraField cmt = (UnicodeCommentExtraField)\nze.getExtraField(UnicodeCommentExtraField.UCOM_ID);\nString newComment =\ngetUnicodeStringIfOriginalMatches(cmt, commentBytes);\nif (newComment != null) {\nze.setComment(newComment);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:getUnicodeStringIfOriginalMatches(Lorg/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField;[B)Ljava/lang/String;",
                                    "method_body": "String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f,\nbyte[] orig) {\nif (f != null) {\nCRC32 crc32 = new CRC32();\ncrc32.update(orig);\nlong origCRC32 = crc32.getValue();\n\nif (origCRC32 == f.getNameCRC32()) {\ntry {\nreturn ZipEncodingHelper\n.UTF8_ZIP_ENCODING.decode(f.getUnicodeName());\n} catch (IOException ex) {\n// UTF-8 unsupported?  should be impossible the\n// Unicode*ExtraField must contain some bad bytes\n\n// TODO log this anywhere?\nreturn null;\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:copy([B)[B",
                                    "method_body": "static byte[] copy(byte[] from) {\nif (from != null) {\nbyte[] to = new byte[from.length];\nSystem.arraycopy(from, 0, to, 0, to.length);\nreturn to;\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:supportsEncryptionOf(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private static boolean supportsEncryptionOf(ZipArchiveEntry entry) {\nreturn !entry.getGeneralPurposeBit().usesEncryption();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:supportsMethodOf(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private static boolean supportsMethodOf(ZipArchiveEntry entry) {\nreturn entry.getMethod() == ZipArchiveEntry.STORED\n|| entry.getMethod() == ZipArchiveEntry.DEFLATED;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:checkRequestedFeatures(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "static void checkRequestedFeatures(ZipArchiveEntry ze)\nthrows UnsupportedZipFeatureException {\nif (!supportsEncryptionOf(ze)) {\nthrow\nnew UnsupportedZipFeatureException(UnsupportedZipFeatureException\n.Feature.ENCRYPTION, ze);\n}\nif (!supportsMethodOf(ze)) {\nthrow\nnew UnsupportedZipFeatureException(UnsupportedZipFeatureException\n.Feature.METHOD, ze);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<init>(I)V",
                                    "method_body": "private UnparseableExtraField(int k) {\nkey = k;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<clinit>()V",
                                    "method_body": "public static final int THROW_KEY = 0;\n/**\n* Key for \"skip\" action.\n*/\npublic static final int SKIP_KEY = 1;\n/**\n* Key for \"read\" action.\n*/\npublic static final int READ_KEY = 2;\n\n/**\n* Throw an exception if field cannot be parsed.\n*/\npublic static final UnparseableExtraField THROW\n= new UnparseableExtraField(THROW_KEY);\n\n/**\n* Skip the extra field entirely and don't make its data\n* available - effectively removing the extra field data.\n*/\npublic static final UnparseableExtraField SKIP\n= new UnparseableExtraField(SKIP_KEY);\n\n/**\n* Read the extra field data into an instance of {@link\n* UnparseableExtraFieldData UnparseableExtraFieldData}."
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setHeaderId(Lorg/apache/commons/compress/archivers/zip/ZipShort;)V",
                                    "method_body": "public void setHeaderId(ZipShort headerId) {\nthis.headerId = headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setLocalFileDataData([B)V",
                                    "method_body": "public void setLocalFileDataData(byte[] data) {\nlocalData = ZipUtil.copy(data);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn new ZipShort(localData.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn ZipUtil.copy(localData);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setCentralDirectoryData([B)V",
                                    "method_body": "public void setCentralDirectoryData(byte[] data) {\ncentralData = ZipUtil.copy(data);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:parseFromCentralDirectoryData([BII)V",
                                    "method_body": "public void parseFromCentralDirectoryData(byte[] data, int offset,\nint length) {\nbyte[] tmp = new byte[length];\nSystem.arraycopy(data, offset, tmp, 0, length);\nsetCentralDirectoryData(tmp);\nif (localData == null) {\nsetLocalFileDataData(tmp);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\nthrows IOException {\nthis.archiveName = f.getAbsolutePath();\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = new RandomAccessFile(f, \"r\");\nboolean success = false;\ntry {\nMap<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag =\npopulateFromCentralDirectory();\nresolveLocalFileHeaderData(entriesWithoutUTF8Flag);\nsuccess = true;\n} finally {\nif (!success) {\ntry {\nclosed = true;\narchive.close();\n} catch (IOException e2) { // NOPMD\n// swallow, throw the original exception instead\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<clinit>()V",
                                    "method_body": "private static final int CFH_LEN =\n/* version made by                 */ SHORT\n/* version needed to extract       */ + SHORT\n/* general purpose bit flag        */ + SHORT\n/* compression method              */ + SHORT\n/* last mod file time              */ + SHORT\n/* last mod file date              */ + SHORT\n/* crc-32                          */ + WORD\n/* compressed size                 */ + WORD\n/* uncompressed size               */ + WORD\n/* filename length                 */ + SHORT\n/* extra field length              */ + SHORT\n/* file comment length             */ + SHORT\n/* disk number start               */ + SHORT\n/* internal file attributes        */ + SHORT\n/* external file attributes        */ + WORD\n/* relative offset of local header */ + WORD;\n\nprivate static final long CFH_SIG =\nZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n\n/**\n* Reads the central directory of the given archive and populates\n* the internal tables with ZipArchiveEntry instances.\n*\n* <p>The ZipArchiveEntrys will know all data that can be obtained from\n* the central directory alone, but not the data that requires the\n* local file header or additional data to be read.</p>\n*\n* @return a map of zipentries that didn't have the language\n* encoding flag set when read.\n*/\nprivate Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory()\nthrows IOException {\nHashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\nnew HashMap<ZipArchiveEntry, NameAndComment>();\n\npositionAtCentralDirectory();\n\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\n\nif (sig != CFH_SIG && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n+ \" corrupt archive.\");\n}\n\nwhile (sig == CFH_SIG) {\nreadCentralDirectoryEntry(noUTF8Flag);\narchive.readFully(signatureBytes);\nsig = ZipLong.getValue(signatureBytes);\n}\nreturn noUTF8Flag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:close()V",
                                    "method_body": "public void close() throws IOException {\n// this flag is only written here and read in finalize() which\n// can never be run in parallel.\n// no synchronization needed.\nclosed = true;\n\narchive.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
                                    "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\ntry {\nzipfile.close();\n} catch (IOException e) { // NOPMD\n//ignore, that's why the method is called \"quietly\"\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:getEntry(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;",
                                    "method_body": "public ZipArchiveEntry getEntry(String name) {\nreturn nameMap.get(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:getInputStream(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Ljava/io/InputStream;",
                                    "method_body": "public InputStream getInputStream(ZipArchiveEntry ze)\nthrows IOException, ZipException {\nOffsetEntry offsetEntry = entries.get(ze);\nif (offsetEntry == null) {\nreturn null;\n}\nZipUtil.checkRequestedFeatures(ze);\nlong start = offsetEntry.dataOffset;\nBoundedInputStream bis =\nnew BoundedInputStream(start, ze.getCompressedSize());\nswitch (ze.getMethod()) {\ncase ZipArchiveEntry.STORED:\nreturn bis;\ncase ZipArchiveEntry.DEFLATED:\nbis.addDummy();\nfinal Inflater inflater = new Inflater(true);\nreturn new InflaterInputStream(bis, inflater) {\n@Override\npublic void close() throws IOException {\nsuper.close();\ninflater.end();\n}\n};\ndefault:\nthrow new ZipException(\"Found unsupported compression method \"\n+ ze.getMethod());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory()\nthrows IOException {\nHashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\nnew HashMap<ZipArchiveEntry, NameAndComment>();\n\npositionAtCentralDirectory();\n\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\n\nif (sig != CFH_SIG && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n+ \" corrupt archive.\");\n}\n\nwhile (sig == CFH_SIG) {\nreadCentralDirectoryEntry(noUTF8Flag);\narchive.readFully(signatureBytes);\nsig = ZipLong.getValue(signatureBytes);\n}\nreturn noUTF8Flag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:readCentralDirectoryEntry(Ljava/util/Map;)V",
                                    "method_body": "private void\nreadCentralDirectoryEntry(Map<ZipArchiveEntry, NameAndComment> noUTF8Flag)\nthrows IOException {\nbyte[] cfh = new byte[CFH_LEN];\n\narchive.readFully(cfh);\nint off = 0;\nZipArchiveEntry ze = new ZipArchiveEntry();\n\nint versionMadeBy = ZipShort.getValue(cfh, off);\noff += SHORT;\nze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\noff += SHORT; // skip version info\n\nfinal GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(cfh, off);\nfinal boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\nfinal ZipEncoding entryEncoding =\nhasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\nze.setGeneralPurposeBit(gpFlag);\n\noff += SHORT;\n\nze.setMethod(ZipShort.getValue(cfh, off));\noff += SHORT;\n\nlong time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\nze.setTime(time);\noff += WORD;\n\nze.setCrc(ZipLong.getValue(cfh, off));\noff += WORD;\n\nze.setCompressedSize(ZipLong.getValue(cfh, off));\noff += WORD;\n\nze.setSize(ZipLong.getValue(cfh, off));\noff += WORD;\n\nint fileNameLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nint extraLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nint commentLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nint diskStart = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nze.setInternalAttributes(ZipShort.getValue(cfh, off));\noff += SHORT;\n\nze.setExternalAttributes(ZipLong.getValue(cfh, off));\noff += WORD;\n\nbyte[] fileName = new byte[fileNameLen];\narchive.readFully(fileName);\nze.setName(entryEncoding.decode(fileName), fileName);\n\n// LFH offset,\nOffsetEntry offset = new OffsetEntry();\noffset.headerOffset = ZipLong.getValue(cfh, off);\n// data offset will be filled later\nentries.put(ze, offset);\n\nnameMap.put(ze.getName(), ze);\n\nbyte[] cdExtraData = new byte[extraLen];\narchive.readFully(cdExtraData);\nze.setCentralDirectoryExtra(cdExtraData);\n\nsetSizesAndOffsetFromZip64Extra(ze, offset, diskStart);\n\nbyte[] comment = new byte[commentLen];\narchive.readFully(comment);\nze.setComment(entryEncoding.decode(comment));\n\nif (!hasUTF8Flag && useUnicodeExtraFields) {\nnoUTF8Flag.put(ze, new NameAndComment(fileName, comment));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:setSizesAndOffsetFromZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Lorg/apache/commons/compress/archivers/zip/ZipFile$OffsetEntry;I)V",
                                    "method_body": "private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze,\nOffsetEntry offset,\nint diskStart)\nthrows IOException {\nZip64ExtendedInformationExtraField z64 =\n(Zip64ExtendedInformationExtraField)\nze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\nif (z64 != null) {\nboolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\nboolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\nboolean hasRelativeHeaderOffset =\noffset.headerOffset == ZIP64_MAGIC;\nz64.reparseCentralDirectoryData(hasUncompressedSize,\nhasCompressedSize,\nhasRelativeHeaderOffset,\ndiskStart == ZIP64_MAGIC_SHORT);\n\nif (hasUncompressedSize) {\nze.setSize(z64.getSize().getLongValue());\n} else if (hasCompressedSize) {\nz64.setSize(new ZipEightByteInteger(ze.getSize()));\n}\n\nif (hasCompressedSize) {\nze.setCompressedSize(z64.getCompressedSize().getLongValue());\n} else if (hasUncompressedSize) {\nz64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));\n}\n\nif (hasRelativeHeaderOffset) {\noffset.headerOffset =\nz64.getRelativeHeaderOffset().getLongValue();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nthrows IOException {\nboolean found = tryToLocateSignature(MIN_EOCD_SIZE + ZIP64_EOCDL_LENGTH,\nMAX_EOCD_SIZE + ZIP64_EOCDL_LENGTH,\nZipArchiveOutputStream\n.ZIP64_EOCD_LOC_SIG);\nif (!found) {\n// not a ZIP64 archive\npositionAtCentralDirectory32();\n} else {\npositionAtCentralDirectory64();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory32()V",
                                    "method_body": "private void positionAtCentralDirectory32()\nthrows IOException {\nboolean found = tryToLocateSignature(MIN_EOCD_SIZE, MAX_EOCD_SIZE,\nZipArchiveOutputStream.EOCD_SIG);\nif (!found) {\nthrow new ZipException(\"archive is not a ZIP archive\");\n}\nskipBytes(CFD_LOCATOR_OFFSET);\nbyte[] cfdOffset = new byte[WORD];\narchive.readFully(cfdOffset);\narchive.seek(ZipLong.getValue(cfdOffset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:tryToLocateSignature(JJ[B)Z",
                                    "method_body": "private boolean tryToLocateSignature(long minDistanceFromEnd,\nlong maxDistanceFromEnd,\nbyte[] sig) throws IOException {\nboolean found = false;\nlong off = archive.length() - minDistanceFromEnd;\nfinal long stopSearching =\nMath.max(0L, archive.length() - maxDistanceFromEnd);\nif (off >= 0) {\nfor (; off >= stopSearching; off--) {\narchive.seek(off);\nint curr = archive.read();\nif (curr == -1) {\nbreak;\n}\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\n}\n}\n}\n}\n}\n}\nif (found) {\narchive.seek(off);\n}\nreturn found;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:skipBytes(I)V",
                                    "method_body": "private void skipBytes(final int count) throws IOException {\nint totalSkipped = 0;\nwhile (totalSkipped < count) {\nint skippedNow = archive.skipBytes(count - totalSkipped);\nif (skippedNow <= 0) {\nthrow new EOFException();\n}\ntotalSkipped += skippedNow;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:resolveLocalFileHeaderData(Ljava/util/Map;)V",
                                    "method_body": "private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\nentriesWithoutUTF8Flag)\nthrows IOException {\n// changing the name of a ZipArchiveEntry is going to change\n// the hashcode - see COMPRESS-164\n// Map needs to be reconstructed in order to keep central\n// directory order\nfor (ZipArchiveEntry ze : entries.keySet()) {\nOffsetEntry offsetEntry = entries.get(ze);\nlong offset = offsetEntry.headerOffset;\narchive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\nbyte[] b = new byte[SHORT];\narchive.readFully(b);\nint fileNameLen = ZipShort.getValue(b);\narchive.readFully(b);\nint extraFieldLen = ZipShort.getValue(b);\nint lenToSkip = fileNameLen;\nwhile (lenToSkip > 0) {\nint skipped = archive.skipBytes(lenToSkip);\nif (skipped <= 0) {\nthrow new RuntimeException(\"failed to skip file name in\"\n+ \" local file header\");\n}\nlenToSkip -= skipped;\n}\nbyte[] localExtraData = new byte[extraFieldLen];\narchive.readFully(localExtraData);\nze.setExtra(localExtraData);\noffsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n+ SHORT + SHORT + fileNameLen + extraFieldLen;\n\nif (entriesWithoutUTF8Flag.containsKey(ze)) {\nString orig = ze.getName();\nNameAndComment nc = entriesWithoutUTF8Flag.get(ze);\nZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\nnc.comment);\nif (!orig.equals(ze.getName())) {\nnameMap.remove(orig);\nnameMap.put(ze.getName(), ze);\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$OffsetEntry:access$002(Lorg/apache/commons/compress/archivers/zip/ZipFile$OffsetEntry;J)J",
                                    "method_body": "private static final int HASH_SIZE = 509;\nstatic final int NIBLET_MASK = 0x0f;\nstatic final int BYTE_SHIFT = 8;\nprivate static final int POS_0 = 0;\nprivate static final int POS_1 = 1;\nprivate static final int POS_2 = 2;\nprivate static final int POS_3 = 3;\n\n/**\n* Maps ZipArchiveEntrys to two longs, recording the offsets of\n* the local file headers and the start of entry data.\n*/\nprivate final Map<ZipArchiveEntry, OffsetEntry> entries =\nnew LinkedHashMap<ZipArchiveEntry, OffsetEntry>(HASH_SIZE);\n\n/**\n* Maps String to ZipArchiveEntrys, name -> actual entry.\n*/\nprivate final Map<String, ZipArchiveEntry> nameMap =\nnew HashMap<String, ZipArchiveEntry>(HASH_SIZE);\n\nprivate static final class OffsetEntry {\nprivate long headerOffset = -1;\nprivate long dataOffset = -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$NameAndComment:<init>([B[B)V",
                                    "method_body": "private NameAndComment(byte[] name, byte[] comment) {\nthis.name = name;\nthis.comment = comment;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$BoundedInputStream:<init>(Lorg/apache/commons/compress/archivers/zip/ZipFile;JJ)V",
                                    "method_body": "BoundedInputStream(long start, long remaining) {\nthis.remaining = remaining;\nloc = start;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$BoundedInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (remaining-- <= 0) {\nif (addDummyByte) {\naddDummyByte = false;\nreturn 0;\n}\nreturn -1;\n}\nsynchronized (archive) {\narchive.seek(loc++);\nreturn archive.read();\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 11,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest.shortTextFilesAreNoTARs",
                            "test_body": "32: public void shortTextFilesAreNoTARs() throws Exception {\n33: try {\n34: new ArchiveStreamFactory()\n35: .createArchiveInputStream(new ByteArrayInputStream(\"This certainly is not a tar archive, really, no kidding\".getBytes()));\n36: fail(\"created an input stream for a non-archive\");\n37: } catch (ArchiveException ae) {\n38: assertTrue(ae.getMessage().startsWith(\"No Archiver found\"));\n39: }\n40: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveInputStream(Ljava/io/InputStream;)Lorg/apache/commons/compress/archivers/ArchiveInputStream;",
                                    "method_body": "public ArchiveInputStream createArchiveInputStream(final InputStream in)\nthrows ArchiveException {\nif (in == null) {\nthrow new IllegalArgumentException(\"Stream must not be null.\");\n}\n\nif (!in.markSupported()) {\nthrow new IllegalArgumentException(\"Mark is not supported.\");\n}\n\nfinal byte[] signature = new byte[12];\nin.mark(signature.length);\ntry {\nint signatureLength = in.read(signature);\nin.reset();\nif (ZipArchiveInputStream.matches(signature, signatureLength)) {\nreturn new ZipArchiveInputStream(in);\n} else if (JarArchiveInputStream.matches(signature, signatureLength)) {\nreturn new JarArchiveInputStream(in);\n} else if (ArArchiveInputStream.matches(signature, signatureLength)) {\nreturn new ArArchiveInputStream(in);\n} else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\nreturn new CpioArchiveInputStream(in);\n}\n\n// Dump needs a bigger buffer to check the signature;\nfinal byte[] dumpsig = new byte[32];\nin.mark(dumpsig.length);\nsignatureLength = in.read(dumpsig);\nin.reset();\nif (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\nreturn new DumpArchiveInputStream(in);\n}\n\n// Tar needs an even bigger buffer to check the signature; read the first block\nfinal byte[] tarheader = new byte[512];\nin.mark(tarheader.length);\nsignatureLength = in.read(tarheader);\nin.reset();\nif (TarArchiveInputStream.matches(tarheader, signatureLength)) {\nreturn new TarArchiveInputStream(in);\n}\n// COMPRESS-117 - improve auto-recognition\ntry {\nTarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\ntais.getNextEntry();\nreturn new TarArchiveInputStream(in);\n} catch (Exception e) { // NOPMD\n// can generate IllegalArgumentException as well as IOException\n// autodetection, simply not a TAR\n// ignored\n}\n} catch (IOException e) {\nthrow new ArchiveException(\"Could not use reset and mark operations.\", e);\n}\n\nthrow new ArchiveException(\"No Archiver found for the stream signature\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "public static final int EFS_FLAG = GeneralPurposeBit.UFT8_NAMES_FLAG;\n\n/**\n* Current entry.\n*/\nprivate CurrentEntry entry;\n\n/**\n* The file comment.\n*/\nprivate String comment = \"\";\n\n/**\n* Compression level for next entry.\n*/\nprivate int level = DEFAULT_COMPRESSION;\n\n/**\n* Has the compression level changed when compared to the last\n* entry?\n*/\nprivate boolean hasCompressionLevelChanged = false;\n\n/**\n* Default compression method for next entry.\n*/\nprivate int method = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* List of ZipArchiveEntries written so far.\n*/\nprivate final List<ZipArchiveEntry> entries =\nnew LinkedList<ZipArchiveEntry>();\n\n/**\n* CRC instance to avoid parsing DEFLATED data twice.\n*/\nprivate final CRC32 crc = new CRC32();\n\n/**\n* Count the bytes written to out.\n*/\nprivate long written = 0;\n\n/**\n* Start of central directory.\n*/\nprivate long cdOffset = 0;\n\n/**\n* Length of central directory.\n*/\nprivate long cdLength = 0;\n\n/**\n* Helper, a 0 as ZipShort.\n*/\nprivate static final byte[] ZERO = {0, 0};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Data Descriptor signature\n* @since Apache Commons Compress 1.1\n*/\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\n\n/**\n* Value stored in size and similar fields if ZIP64 extensions are\n* used.\n* @since Apache Commons Compress 1.3\n*/\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry () {\nthis.magic = MAGIC_POSIX;\nthis.version = VERSION_POSIX;\nthis.name = \"\";\nthis.linkName = \"\";\n\nString user = System.getProperty(\"user.name\", \"\");\n\nif (user.length() > MAX_NAMELEN) {\nuser = user.substring(0, MAX_NAMELEN);\n}\n\nthis.userId = 0;\nthis.groupId = 0;\nthis.userName = user;\nthis.groupName = \"\";\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>([B)V",
                                    "method_body": "public TarArchiveEntry(byte[] headerBuf) {\nthis();\nparseTarHeader(headerBuf);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNUSparse()Z",
                                    "method_body": "public boolean isGNUSparse() {\nreturn linkFlag == LF_GNUTYPE_SPARSE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongNameEntry()Z",
                                    "method_body": "public boolean isGNULongNameEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGNAME\n&& name.toString().equals(GNU_LONGLINK);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isPaxHeader()Z",
                                    "method_body": "public boolean isPaxHeader(){\nreturn linkFlag == LF_PAX_EXTENDED_HEADER_LC\n|| linkFlag == LF_PAX_EXTENDED_HEADER_UC;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nif (file != null) {\nreturn file.isDirectory();\n}\n\nif (linkFlag == LF_DIR) {\nreturn true;\n}\n\nif (getName().endsWith(\"/\")) {\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([B)V",
                                    "method_body": "public void parseTarHeader(byte[] header) {\nint offset = 0;\n\nname = TarUtils.parseName(header, offset, NAMELEN);\noffset += NAMELEN;\nmode = (int) TarUtils.parseOctal(header, offset, MODELEN);\noffset += MODELEN;\nuserId = (int) TarUtils.parseOctal(header, offset, UIDLEN);\noffset += UIDLEN;\ngroupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);\noffset += GIDLEN;\nsize = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\noffset += SIZELEN;\nmodTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\noffset += MODTIMELEN;\noffset += CHKSUMLEN;\nlinkFlag = header[offset++];\nlinkName = TarUtils.parseName(header, offset, NAMELEN);\noffset += NAMELEN;\nmagic = TarUtils.parseName(header, offset, MAGICLEN);\noffset += MAGICLEN;\nversion = TarUtils.parseName(header, offset, VERSIONLEN);\noffset += VERSIONLEN;\nuserName = TarUtils.parseName(header, offset, UNAMELEN);\noffset += UNAMELEN;\ngroupName = TarUtils.parseName(header, offset, GNAMELEN);\noffset += GNAMELEN;\ndevMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\noffset += DEVLEN;\ndevMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\noffset += DEVLEN;\n\nint type = evaluateType(header);\nswitch (type) {\ncase FORMAT_OLDGNU: {\noffset += ATIMELEN_GNU;\noffset += CTIMELEN_GNU;\noffset += OFFSETLEN_GNU;\noffset += LONGNAMESLEN_GNU;\noffset += PAD2LEN_GNU;\noffset += SPARSELEN_GNU;\nisExtended = TarUtils.parseBoolean(header, offset);\noffset += ISEXTENDEDLEN_GNU;\nrealSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU);\noffset += REALSIZELEN_GNU;\nbreak;\n}\ncase FORMAT_POSIX:\ndefault: {\nString prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n// SunOS tar -E does not add / to directory names, so fix\n// up to be consistent\nif (isDirectory() && !name.endsWith(\"/\")){\nname = name + \"/\";\n}\nif (prefix.length() > 0){\nname = prefix + \"/\" + name;\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:evaluateType([B)I",
                                    "method_body": "private int evaluateType(byte[] header) {\nfinal ByteBuffer magic = ByteBuffer.wrap(header, MAGIC_OFFSET, MAGICLEN);\nif (magic.compareTo(ByteBuffer.wrap(MAGIC_GNU.getBytes())) == 0)\nreturn FORMAT_OLDGNU;\nif (magic.compareTo(ByteBuffer.wrap(MAGIC_POSIX.getBytes())) == 0)\nreturn FORMAT_POSIX;\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarBuffer(InputStream inStream, int blockSize, int recordSize) {\nthis.inStream = inStream;\nthis.outStream = null;\n\nthis.initialize(blockSize, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:initialize(II)V",
                                    "method_body": "private void initialize(int blockSize, int recordSize) {\nthis.blockSize = blockSize;\nthis.recordSize = recordSize;\nthis.recsPerBlock = (this.blockSize / this.recordSize);\nthis.blockBuffer = new byte[this.blockSize];\n\nif (this.inStream != null) {\nthis.currBlkIdx = -1;\nthis.currRecIdx = this.recsPerBlock;\n} else {\nthis.currBlkIdx = 0;\nthis.currRecIdx = 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:getRecordSize()I",
                                    "method_body": "public int getRecordSize() {\nreturn this.recordSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:isEOFRecord([B)Z",
                                    "method_body": "public boolean isEOFRecord(byte[] record) {\nfor (int i = 0, sz = getRecordSize(); i < sz; ++i) {\nif (record[i] != 0) {\nreturn false;\n}\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:readRecord()[B",
                                    "method_body": "public byte[] readRecord() throws IOException {\nif (inStream == null) {\nif (outStream == null) {\nthrow new IOException(\"input buffer is closed\");\n}\nthrow new IOException(\"reading from an output buffer\");\n}\n\nif (currRecIdx >= recsPerBlock && !readBlock()) {\nreturn null;\n}\n\nbyte[] result = new byte[recordSize];\n\nSystem.arraycopy(blockBuffer,\n(currRecIdx * recordSize), result, 0,\nrecordSize);\n\ncurrRecIdx++;\n\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:readBlock()Z",
                                    "method_body": "private boolean readBlock() throws IOException {\nif (inStream == null) {\nthrow new IOException(\"reading from an output buffer\");\n}\n\ncurrRecIdx = 0;\n\nint offset = 0;\nint bytesNeeded = blockSize;\n\nwhile (bytesNeeded > 0) {\nlong numBytes = inStream.read(blockBuffer, offset,\nbytesNeeded);\n\n//\n// NOTE\n// We have fit EOF, and the block is not full!\n//\n// This is a broken archive. It does not follow the standard\n// blocking algorithm. However, because we are generous, and\n// it requires little effort, we will simply ignore the error\n// and continue as if the entire block were read. This does\n// not appear to break anything upstream. We used to return\n// false in this case.\n//\n// Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n//\nif (numBytes == -1) {\nif (offset == 0) {\n// Ensure that we do not read gigabytes of zeros\n// for a corrupt tar file.\n// See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\nreturn false;\n}\n// However, just leaving the unread portion of the buffer dirty does\n// cause problems in some cases.  This problem is described in\n// http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n//\n// The solution is to fill the unused portion of the buffer with zeros.\n\nArrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\nbreak;\n}\n\noffset += numBytes;\nbytesNeeded -= numBytes;\n\nif (numBytes != blockSize) {\n// TODO: Incomplete Read occured - throw exception?\n}\n}\n\ncurrBlkIdx++;\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\n\nif (length < 2){\nthrow new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n}\n\nboolean allNUL = true;\nfor (int i = start; i < end; i++){\nif (buffer[i] != 0){\nallNUL = false;\nbreak;\n}\n}\nif (allNUL) {\nreturn 0L;\n}\n\n// Skip leading spaces\nwhile (start < end){\nif (buffer[start] == ' '){\nstart++;\n} else {\nbreak;\n}\n}\n\n// Must have trailing NUL or space\nbyte trailer;\ntrailer = buffer[end-1];\nif (trailer == 0 || trailer == ' '){\nend--;\n} else {\nthrow new IllegalArgumentException(\nexceptionMessage(buffer, offset, length, end-1, trailer));\n}\n// May have additional NUL or space\ntrailer = buffer[end-1];\nif (trailer == 0 || trailer == ' '){\nend--;\n}\n\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\n// CheckStyle:MagicNumber OFF\nif (currentByte < '0' || currentByte > '7'){\nthrow new IllegalArgumentException(\nexceptionMessage(buffer, offset, length, start, currentByte));\n}\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\n// CheckStyle:MagicNumber ON\n}\n\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctalOrBinary([BII)J",
                                    "method_body": "public static long parseOctalOrBinary(final byte[] buffer, final int offset,\nfinal int length) {\n\nif ((buffer[offset] & 0x80) == 0) {\nreturn parseOctal(buffer, offset, length);\n}\n\nlong val = buffer[offset] & 0x7f;\nfor (int i = 1; i < length; i++) {\nif (val >= (1L << (63 - 8))) {\nthrow new IllegalArgumentException(\n\"At offset \" + offset + \", \" + length + \" byte \" +\n\"binary number exceeds maximum signed long value\");\n}\nval = (val << 8) + (buffer[offset + i] & 0xff);\n}\nreturn val;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BII)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset, final int length) {\nStringBuffer result = new StringBuffer(length);\nint          end = offset + length;\n\nfor (int i = offset; i < end; ++i) {\nbyte b = buffer[i];\nif (b == 0) { // Trailing null\nbreak;\n}\nresult.append((char) (b & 0xFF)); // Allow for sign-extension\n}\n\nreturn result.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:<clinit>()V",
                                    "method_body": "static final String BSD_LONGNAME_PREFIX = \"#1/\";\nprivate static final int BSD_LONGNAME_PREFIX_LEN =\nBSD_LONGNAME_PREFIX.length();\nprivate static final String BSD_LONGNAME_PATTERN =\n\"^\" + BSD_LONGNAME_PREFIX + \"\\\\d+\";\n\n/**\n* Does the name look like it is a long name (or a name containing\n* spaces) as encoded by BSD ar?\n*\n* <p>From the FreeBSD ar(5) man page:</p>\n* <pre>\n* BSD   In the BSD variant, names that are shorter than 16\n*\t     characters and without embedded spaces are stored\n*\t     directly in this field.  If a name has an embedded\n*\t     space, or if it is longer than 16 characters, then\n*\t     the string \"#1/\" followed by the decimal represen-\n*\t     tation of the length of the file name is placed in\n*\t     this field.\tThe actual file name is stored immedi-\n*\t     ately after the archive header.  The content of the\n*\t     archive member follows the file name.  The ar_size\n*\t     field of the header (see below) will then hold the\n*\t     sum of the size of the file name and the size of\n*\t     the member.\n* </pre>\n*\n* @since Apache Commons Compress 1.3\n*/\nprivate static boolean isBSDLongName(String name) {\nreturn name != null && name.matches(BSD_LONGNAME_PATTERN);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\n// 3c21 7261 6863 0a3e\n\nif (length < 8) {\nreturn false;\n}\nif (signature[0] != 0x21) {\nreturn false;\n}\nif (signature[1] != 0x3c) {\nreturn false;\n}\nif (signature[2] != 0x61) {\nreturn false;\n}\nif (signature[3] != 0x72) {\nreturn false;\n}\nif (signature[4] != 0x63) {\nreturn false;\n}\nif (signature[5] != 0x68) {\nreturn false;\n}\nif (signature[6] != 0x3e) {\nreturn false;\n}\nif (signature[7] != 0x0a) {\nreturn false;\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < 6) {\nreturn false;\n}\n\n// Check binary values\nif (signature[0] == 0x71 && (signature[1] & 0xFF) == 0xc7) {\nreturn true;\n}\nif (signature[1] == 0x71 && (signature[0] & 0xFF) == 0xc7) {\nreturn true;\n}\n\n// Check Ascii (String) values\n// 3037 3037 30nn\nif (signature[0] != 0x30) {\nreturn false;\n}\nif (signature[1] != 0x37) {\nreturn false;\n}\nif (signature[2] != 0x30) {\nreturn false;\n}\nif (signature[3] != 0x37) {\nreturn false;\n}\nif (signature[4] != 0x30) {\nreturn false;\n}\n// Check last byte\nif (signature[5] == 0x31) {\nreturn true;\n}\nif (signature[5] == 0x32) {\nreturn true;\n}\nif (signature[5] == 0x37) {\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<clinit>()V",
                                    "method_body": "private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\nprivate static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\nprivate static final byte[] DD = ZipLong.DD_SIG.getBytes();\n\n/**\n* Checks whether the current buffer contains the signature of a\n* &quot;data decsriptor&quot;, &quot;local file header&quot; or\n* &quot;central directory entry&quot;.\n*\n* <p>If it contains such a signature, reads the data descriptor\n* and positions the stream right after the data descriptor.</p>\n*/\nprivate boolean bufferContainsSignature(ByteArrayOutputStream bos,\nint offset, int lastRead,\nint expectedDDLen)\nthrows IOException {\nboolean done = false;\nint readTooMuch = 0;\nfor (int i = 0; !done && i < lastRead - 4; i++) {\nif (buf.buf[i] == LFH[0] && buf.buf[i + 1] == LFH[1]) {\nif ((buf.buf[i + 2] == LFH[2] && buf.buf[i + 3] == LFH[3])\n|| (buf.buf[i] == CFH[2] && buf.buf[i + 3] == CFH[3])) {\n// found a LFH or CFH:\nreadTooMuch = offset + lastRead - i - expectedDDLen;\ndone = true;\n}\nelse if (buf.buf[i + 2] == DD[2] && buf.buf[i + 3] == DD[3]) {\n// found DD:\nreadTooMuch = offset + lastRead - i;\ndone = true;\n}\nif (done) {\n// * push back bytes read in excess as well as the data\n//   descriptor\n// * copy the remaining bytes to cache\n// * read data descriptor\npushback(buf.buf, offset + lastRead - readTooMuch,\nreadTooMuch);\nbos.write(buf.buf, 0, i);\nreadDataDescriptor();\n}\n}\n}\nreturn done;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < ZipArchiveOutputStream.LFH_SIG.length) {\nreturn false;\n}\n\nreturn checksig(signature, ZipArchiveOutputStream.LFH_SIG) // normal file\n|| checksig(signature, ZipArchiveOutputStream.EOCD_SIG); // empty zip\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:checksig([B[B)Z",
                                    "method_body": "private static boolean checksig(byte[] signature, byte[] expected){\nfor (int i = 0; i < expected.length; i++) {\nif (signature[i] != expected[i]) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length ) {\nreturn ZipArchiveInputStream.matches(signature, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is) {\nthis(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\nthis.buffer = new TarBuffer(is, blockSize, recordSize);\nthis.readBuf = null;\nthis.hasHitEOF = false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextTarEntry()Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;",
                                    "method_body": "public TarArchiveEntry getNextTarEntry() throws IOException {\nif (hasHitEOF) {\nreturn null;\n}\n\nif (currEntry != null) {\nlong numToSkip = entrySize - entryOffset;\n\nwhile (numToSkip > 0) {\nlong skipped = skip(numToSkip);\nif (skipped <= 0) {\nthrow new RuntimeException(\"failed to skip current tar entry\");\n}\nnumToSkip -= skipped;\n}\n\nreadBuf = null;\n}\n\nbyte[] headerBuf = getRecord();\n\nif (hasHitEOF) {\ncurrEntry = null;\nreturn null;\n}\n\ncurrEntry = new TarArchiveEntry(headerBuf);\nentryOffset = 0;\nentrySize = currEntry.getSize();\n\nif (currEntry.isGNULongNameEntry()) {\n// read in the name\nStringBuffer longName = new StringBuffer();\nbyte[] buf = new byte[SMALL_BUFFER_SIZE];\nint length = 0;\nwhile ((length = read(buf)) >= 0) {\nlongName.append(new String(buf, 0, length));\n}\ngetNextEntry();\nif (currEntry == null) {\n// Bugzilla: 40334\n// Malformed tar file - long entry name not followed by entry\nreturn null;\n}\n// remove trailing null terminator\nif (longName.length() > 0\n&& longName.charAt(longName.length() - 1) == 0) {\nlongName.deleteCharAt(longName.length() - 1);\n}\ncurrEntry.setName(longName.toString());\n}\n\nif (currEntry.isPaxHeader()){ // Process Pax headers\npaxHeaders();\n}\n\nif (currEntry.isGNUSparse()){ // Process sparse files\nreadGNUSparse();\n}\n\n// If the size of the next element in the archive has changed\n// due to a new size being reported in the posix header\n// information, we update entrySize here so that it contains\n// the correct value.\nentrySize = currEntry.getSize();\nreturn currEntry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getRecord()[B",
                                    "method_body": "private byte[] getRecord() throws IOException {\nif (hasHitEOF) {\nreturn null;\n}\n\nbyte[] headerBuf = buffer.readRecord();\n\nif (headerBuf == null) {\nhasHitEOF = true;\n} else if (buffer.isEOFRecord(headerBuf)) {\nhasHitEOF = true;\n}\n\nreturn hasHitEOF ? null : headerBuf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextEntry()Lorg/apache/commons/compress/archivers/ArchiveEntry;",
                                    "method_body": "public ArchiveEntry getNextEntry() throws IOException {\nreturn getNextTarEntry();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < TarConstants.VERSION_OFFSET+TarConstants.VERSIONLEN) {\nreturn false;\n}\n\nif (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_POSIX,\nsignature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n&&\nArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_POSIX,\nsignature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n){\nreturn true;\n}\nif (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_GNU,\nsignature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n&&\n(\nArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_SPACE,\nsignature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n||\nArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_ZERO,\nsignature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n)\n){\nreturn true;\n}\n// COMPRESS-107 - recognise Ant tar files\nif (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_ANT,\nsignature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n&&\nArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_ANT,\nsignature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n){\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] buffer, int length) {\n// do we have enough of the header?\nif (length < 32) {\nreturn false;\n}\n\n// this is the best test\nif (length >= DumpArchiveConstants.TP_SIZE) {\nreturn DumpArchiveUtil.verify(buffer);\n}\n\n// this will work in a pinch.\nreturn DumpArchiveConstants.NFS_MAGIC == DumpArchiveUtil.convert32(buffer,\n24);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert32([BI)I",
                                    "method_body": "public static final int convert32(byte[] buffer, int offset) {\nint i = 0;\ni = buffer[offset + 3] << 24;\ni += (buffer[offset + 2] << 16) & 0x00FF0000;\ni += (buffer[offset + 1] << 8) & 0x0000FF00;\ni += buffer[offset] & 0x000000FF;\n\nreturn i;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 12,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.TarTestCase.testCOMPRESS178",
                            "test_body": "304: public void testCOMPRESS178() throws Exception {\n305: final File input = getFile(\"COMPRESS-178.tar\");\n306: final InputStream is = new FileInputStream(input);\n307: final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"tar\", is);\n308: try {\n309: in.getNextEntry();\n310: fail(\"Expected IOException\");\n311: } catch (IOException e) {\n312: Throwable t = e.getCause();\n313: assertTrue(\"Expected cause = IllegalArgumentException\", t instanceof IllegalArgumentException);\n314: }\n315: in.close();\n316: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveInputStream(Ljava/lang/String;Ljava/io/InputStream;)Lorg/apache/commons/compress/archivers/ArchiveInputStream;",
                                    "method_body": "public ArchiveInputStream createArchiveInputStream(\nfinal String archiverName, final InputStream in)\nthrows ArchiveException {\n\nif (archiverName == null) {\nthrow new IllegalArgumentException(\"Archivername must not be null.\");\n}\n\nif (in == null) {\nthrow new IllegalArgumentException(\"InputStream must not be null.\");\n}\n\nif (AR.equalsIgnoreCase(archiverName)) {\nreturn new ArArchiveInputStream(in);\n}\nif (ZIP.equalsIgnoreCase(archiverName)) {\nreturn new ZipArchiveInputStream(in);\n}\nif (TAR.equalsIgnoreCase(archiverName)) {\nreturn new TarArchiveInputStream(in);\n}\nif (JAR.equalsIgnoreCase(archiverName)) {\nreturn new JarArchiveInputStream(in);\n}\nif (CPIO.equalsIgnoreCase(archiverName)) {\nreturn new CpioArchiveInputStream(in);\n}\nif (DUMP.equalsIgnoreCase(archiverName)) {\nreturn new DumpArchiveInputStream(in);\n}\n\nthrow new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry () {\nthis.magic = MAGIC_POSIX;\nthis.version = VERSION_POSIX;\nthis.name = \"\";\nthis.linkName = \"\";\n\nString user = System.getProperty(\"user.name\", \"\");\n\nif (user.length() > MAX_NAMELEN) {\nuser = user.substring(0, MAX_NAMELEN);\n}\n\nthis.userId = 0;\nthis.groupId = 0;\nthis.userName = user;\nthis.groupName = \"\";\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>([B)V",
                                    "method_body": "public TarArchiveEntry(byte[] headerBuf) {\nthis();\nparseTarHeader(headerBuf);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([B)V",
                                    "method_body": "public void parseTarHeader(byte[] header) {\nint offset = 0;\n\nname = TarUtils.parseName(header, offset, NAMELEN);\noffset += NAMELEN;\nmode = (int) TarUtils.parseOctal(header, offset, MODELEN);\noffset += MODELEN;\nuserId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\noffset += UIDLEN;\ngroupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\noffset += GIDLEN;\nsize = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\noffset += SIZELEN;\nmodTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\noffset += MODTIMELEN;\noffset += CHKSUMLEN;\nlinkFlag = header[offset++];\nlinkName = TarUtils.parseName(header, offset, NAMELEN);\noffset += NAMELEN;\nmagic = TarUtils.parseName(header, offset, MAGICLEN);\noffset += MAGICLEN;\nversion = TarUtils.parseName(header, offset, VERSIONLEN);\noffset += VERSIONLEN;\nuserName = TarUtils.parseName(header, offset, UNAMELEN);\noffset += UNAMELEN;\ngroupName = TarUtils.parseName(header, offset, GNAMELEN);\noffset += GNAMELEN;\ndevMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\noffset += DEVLEN;\ndevMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\noffset += DEVLEN;\n\nint type = evaluateType(header);\nswitch (type) {\ncase FORMAT_OLDGNU: {\noffset += ATIMELEN_GNU;\noffset += CTIMELEN_GNU;\noffset += OFFSETLEN_GNU;\noffset += LONGNAMESLEN_GNU;\noffset += PAD2LEN_GNU;\noffset += SPARSELEN_GNU;\nisExtended = TarUtils.parseBoolean(header, offset);\noffset += ISEXTENDEDLEN_GNU;\nrealSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU);\noffset += REALSIZELEN_GNU;\nbreak;\n}\ncase FORMAT_POSIX:\ndefault: {\nString prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n// SunOS tar -E does not add / to directory names, so fix\n// up to be consistent\nif (isDirectory() && !name.endsWith(\"/\")){\nname = name + \"/\";\n}\nif (prefix.length() > 0){\nname = prefix + \"/\" + name;\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarBuffer(InputStream inStream, int blockSize, int recordSize) {\nthis.inStream = inStream;\nthis.outStream = null;\n\nthis.initialize(blockSize, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:initialize(II)V",
                                    "method_body": "private void initialize(int blockSize, int recordSize) {\nthis.blockSize = blockSize;\nthis.recordSize = recordSize;\nthis.recsPerBlock = (this.blockSize / this.recordSize);\nthis.blockBuffer = new byte[this.blockSize];\n\nif (this.inStream != null) {\nthis.currBlkIdx = -1;\nthis.currRecIdx = this.recsPerBlock;\n} else {\nthis.currBlkIdx = 0;\nthis.currRecIdx = 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:getRecordSize()I",
                                    "method_body": "public int getRecordSize() {\nreturn this.recordSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:isEOFRecord([B)Z",
                                    "method_body": "public boolean isEOFRecord(byte[] record) {\nfor (int i = 0, sz = getRecordSize(); i < sz; ++i) {\nif (record[i] != 0) {\nreturn false;\n}\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:readRecord()[B",
                                    "method_body": "public byte[] readRecord() throws IOException {\nif (inStream == null) {\nif (outStream == null) {\nthrow new IOException(\"input buffer is closed\");\n}\nthrow new IOException(\"reading from an output buffer\");\n}\n\nif (currRecIdx >= recsPerBlock && !readBlock()) {\nreturn null;\n}\n\nbyte[] result = new byte[recordSize];\n\nSystem.arraycopy(blockBuffer,\n(currRecIdx * recordSize), result, 0,\nrecordSize);\n\ncurrRecIdx++;\n\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:readBlock()Z",
                                    "method_body": "private boolean readBlock() throws IOException {\nif (inStream == null) {\nthrow new IOException(\"reading from an output buffer\");\n}\n\ncurrRecIdx = 0;\n\nint offset = 0;\nint bytesNeeded = blockSize;\n\nwhile (bytesNeeded > 0) {\nlong numBytes = inStream.read(blockBuffer, offset,\nbytesNeeded);\n\n//\n// NOTE\n// We have fit EOF, and the block is not full!\n//\n// This is a broken archive. It does not follow the standard\n// blocking algorithm. However, because we are generous, and\n// it requires little effort, we will simply ignore the error\n// and continue as if the entire block were read. This does\n// not appear to break anything upstream. We used to return\n// false in this case.\n//\n// Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n//\nif (numBytes == -1) {\nif (offset == 0) {\n// Ensure that we do not read gigabytes of zeros\n// for a corrupt tar file.\n// See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\nreturn false;\n}\n// However, just leaving the unread portion of the buffer dirty does\n// cause problems in some cases.  This problem is described in\n// http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n//\n// The solution is to fill the unused portion of the buffer with zeros.\n\nArrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\nbreak;\n}\n\noffset += numBytes;\nbytesNeeded -= numBytes;\n\nif (numBytes != blockSize) {\n// TODO: Incomplete Read occured - throw exception?\n}\n}\n\ncurrBlkIdx++;\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\n\nif (length < 2){\nthrow new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n}\n\nboolean allNUL = true;\nfor (int i = start; i < end; i++){\nif (buffer[i] != 0){\nallNUL = false;\nbreak;\n}\n}\nif (allNUL) {\nreturn 0L;\n}\n\n// Skip leading spaces\nwhile (start < end){\nif (buffer[start] == ' '){\nstart++;\n} else {\nbreak;\n}\n}\n\n// Must have trailing NUL or space\nbyte trailer;\ntrailer = buffer[end-1];\nif (trailer == 0 || trailer == ' '){\nend--;\n} else {\nthrow new IllegalArgumentException(\nexceptionMessage(buffer, offset, length, end-1, trailer));\n}\n// May have additional NUL or space\ntrailer = buffer[end-1];\nif (trailer == 0 || trailer == ' '){\nend--;\n}\n\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\n// CheckStyle:MagicNumber OFF\nif (currentByte < '0' || currentByte > '7'){\nthrow new IllegalArgumentException(\nexceptionMessage(buffer, offset, length, start, currentByte));\n}\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\n// CheckStyle:MagicNumber ON\n}\n\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctalOrBinary([BII)J",
                                    "method_body": "public static long parseOctalOrBinary(final byte[] buffer, final int offset,\nfinal int length) {\n\nif ((buffer[offset] & 0x80) == 0) {\nreturn parseOctal(buffer, offset, length);\n}\n\nlong val = buffer[offset] & 0x7f;\nfor (int i = 1; i < length; i++) {\nif (val >= (1L << (63 - 8))) {\nthrow new IllegalArgumentException(\n\"At offset \" + offset + \", \" + length + \" byte \" +\n\"binary number exceeds maximum signed long value\");\n}\nval = (val << 8) + (buffer[offset + i] & 0xff);\n}\nreturn val;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:exceptionMessage([BIIIB)Ljava/lang/String;",
                                    "method_body": "private static String exceptionMessage(byte[] buffer, final int offset,\nfinal int length, int current, final byte currentByte) {\nString string = new String(buffer, offset, length);\nstring=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed\nfinal String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;\nreturn s;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BII)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset, final int length) {\nStringBuffer result = new StringBuffer(length);\nint          end = offset + length;\n\nfor (int i = offset; i < end; ++i) {\nbyte b = buffer[i];\nif (b == 0) { // Trailing null\nbreak;\n}\nresult.append((char) (b & 0xFF)); // Allow for sign-extension\n}\n\nreturn result.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is) {\nthis(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\nthis.buffer = new TarBuffer(is, blockSize, recordSize);\nthis.readBuf = null;\nthis.hasHitEOF = false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextTarEntry()Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;",
                                    "method_body": "public TarArchiveEntry getNextTarEntry() throws IOException {\nif (hasHitEOF) {\nreturn null;\n}\n\nif (currEntry != null) {\nlong numToSkip = entrySize - entryOffset;\n\nwhile (numToSkip > 0) {\nlong skipped = skip(numToSkip);\nif (skipped <= 0) {\nthrow new RuntimeException(\"failed to skip current tar entry\");\n}\nnumToSkip -= skipped;\n}\n\nreadBuf = null;\n}\n\nbyte[] headerBuf = getRecord();\n\nif (hasHitEOF) {\ncurrEntry = null;\nreturn null;\n}\n\ncurrEntry = new TarArchiveEntry(headerBuf);\nentryOffset = 0;\nentrySize = currEntry.getSize();\n\nif (currEntry.isGNULongNameEntry()) {\n// read in the name\nStringBuffer longName = new StringBuffer();\nbyte[] buf = new byte[SMALL_BUFFER_SIZE];\nint length = 0;\nwhile ((length = read(buf)) >= 0) {\nlongName.append(new String(buf, 0, length));\n}\ngetNextEntry();\nif (currEntry == null) {\n// Bugzilla: 40334\n// Malformed tar file - long entry name not followed by entry\nreturn null;\n}\n// remove trailing null terminator\nif (longName.length() > 0\n&& longName.charAt(longName.length() - 1) == 0) {\nlongName.deleteCharAt(longName.length() - 1);\n}\ncurrEntry.setName(longName.toString());\n}\n\nif (currEntry.isPaxHeader()){ // Process Pax headers\npaxHeaders();\n}\n\nif (currEntry.isGNUSparse()){ // Process sparse files\nreadGNUSparse();\n}\n\n// If the size of the next element in the archive has changed\n// due to a new size being reported in the posix header\n// information, we update entrySize here so that it contains\n// the correct value.\nentrySize = currEntry.getSize();\nreturn currEntry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getRecord()[B",
                                    "method_body": "private byte[] getRecord() throws IOException {\nif (hasHitEOF) {\nreturn null;\n}\n\nbyte[] headerBuf = buffer.readRecord();\n\nif (headerBuf == null) {\nhasHitEOF = true;\n} else if (buffer.isEOFRecord(headerBuf)) {\nhasHitEOF = true;\n}\n\nreturn hasHitEOF ? null : headerBuf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextEntry()Lorg/apache/commons/compress/archivers/ArchiveEntry;",
                                    "method_body": "public ArchiveEntry getNextEntry() throws IOException {\nreturn getNextTarEntry();\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 13,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest.winzipBackSlashWorkaround",
                            "test_body": "35: public void winzipBackSlashWorkaround() throws Exception {\n36: URL zip = getClass().getResource(\"/test-winzip.zip\");\n37: ZipArchiveInputStream in = null;\n38: try {\n39: in = new ZipArchiveInputStream(new FileInputStream(new File(new URI(zip.toString()))));\n40: ZipArchiveEntry zae = in.getNextZipEntry();\n41: zae = in.getNextZipEntry();\n42: zae = in.getNextZipEntry();\n43: assertEquals(\"\\u00e4/\", zae.getName());\n44: } finally {\n45: if (in != null) {\n46: in.close();\n47: }\n48: }\n49: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "protected ZipArchiveEntry() {\nthis(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setMethod(I)V",
                                    "method_body": "public void setMethod(int method) {\nif (method < 0) {\nthrow new IllegalArgumentException(\n\"ZIP compression method can not be negative: \" + method);\n}\nthis.method = method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setPlatform(I)V",
                                    "method_body": "protected void setPlatform(int platform) {\nthis.platform = platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void setExtraFields(ZipExtraField[] fields) {\nextraFields = new LinkedHashMap<ZipShort, ZipExtraField>();\nfor (int i = 0; i < fields.length; i++) {\nif (fields[i] instanceof UnparseableExtraFieldData) {\nunparseableExtra = (UnparseableExtraFieldData) fields[i];\n} else {\nextraFields.put(fields[i].getHeaderId(), fields[i]);\n}\n}\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields(Z)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields(boolean includeUnparseable) {\nif (extraFields == null) {\nreturn !includeUnparseable || unparseableExtra == null\n? new ZipExtraField[0]\n: new ZipExtraField[] { unparseableExtra };\n}\nList<ZipExtraField> result =\nnew ArrayList<ZipExtraField>(extraFields.values());\nif (includeUnparseable && unparseableExtra != null) {\nresult.add(unparseableExtra);\n}\nreturn result.toArray(new ZipExtraField[0]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField getExtraField(ZipShort type) {\nif (extraFields != null) {\nreturn extraFields.get(type);\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra([B)V",
                                    "method_body": "public void setExtra(byte[] extra) throws RuntimeException {\ntry {\nZipExtraField[] local =\nExtraFieldUtils.parse(extra, true,\nExtraFieldUtils.UnparseableExtraField.READ);\nmergeExtraFields(local, true);\n} catch (ZipException e) {\n// actually this is not possible as of Commons Compress 1.1\nthrow new RuntimeException(\"Error parsing extra fields for entry: \"\n+ getName() + \" - \" + e.getMessage(), e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields(true)));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "protected void setName(String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nif (size < 0) {\nthrow new IllegalArgumentException(\"invalid entry size\");\n}\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;[B)V",
                                    "method_body": "protected void setName(String name, byte[] rawName) {\nsetName(name);\nthis.rawName = rawName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setGeneralPurposeBit(Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;)V",
                                    "method_body": "public void setGeneralPurposeBit(GeneralPurposeBit b) {\ngpb = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:mergeExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;Z)V",
                                    "method_body": "private void mergeExtraFields(ZipExtraField[] f, boolean local)\nthrows ZipException {\nif (extraFields == null) {\nsetExtraFields(f);\n} else {\nfor (int i = 0; i < f.length; i++) {\nZipExtraField existing;\nif (f[i] instanceof UnparseableExtraFieldData) {\nexisting = unparseableExtra;\n} else {\nexisting = getExtraField(f[i].getHeaderId());\n}\nif (existing == null) {\naddExtraField(f[i]);\n} else {\nif (local) {\nbyte[] b = f[i].getLocalFileDataData();\nexisting.parseFromLocalFileData(b, 0, b.length);\n} else {\nbyte[] b = f[i].getCentralDirectoryData();\nexisting.parseFromCentralDirectoryData(b, 0, b.length);\n}\n}\n}\nsetExtra();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:<init>()V",
                                    "method_body": "public GeneralPurposeBit() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesUTF8ForNames()Z",
                                    "method_body": "public boolean usesUTF8ForNames() {\nreturn languageEncodingFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useUTF8ForNames(Z)V",
                                    "method_body": "public void useUTF8ForNames(boolean b) {\nlanguageEncodingFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useDataDescriptor(Z)V",
                                    "method_body": "public void useDataDescriptor(boolean b) {\ndataDescriptorFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useEncryption(Z)V",
                                    "method_body": "public void useEncryption(boolean b) {\nencryptionFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useStrongEncryption(Z)V",
                                    "method_body": "public void useStrongEncryption(boolean b) {\nstrongEncryptionFlag = b;\nif (b) {\nuseEncryption(true);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:parse([BI)Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "public static GeneralPurposeBit parse(final byte[] data, final int offset) {\nfinal int generalPurposeFlag = ZipShort.getValue(data, offset);\nGeneralPurposeBit b = new GeneralPurposeBit();\nb.useDataDescriptor((generalPurposeFlag & DATA_DESCRIPTOR_FLAG) != 0);\nb.useUTF8ForNames((generalPurposeFlag & UFT8_NAMES_FLAG) != 0);\nb.useStrongEncryption((generalPurposeFlag & STRONG_ENCRYPTION_FLAG)\n!= 0);\nb.useEncryption((generalPurposeFlag & ENCRYPTION_FLAG) != 0);\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Data Descriptor signature\n* @since Apache Commons Compress 1.1\n*/\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\n\n/**\n* Value stored in size and similar fields if ZIP64 extensions are\n* used.\n* @since Apache Commons Compress 1.3\n*/\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n\nstatic {\nsimpleEncodings = new HashMap<String, SimpleEncodingHolder>();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for utf-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h = simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\n// check platform's default encoding\nencoding = System.getProperty(\"file.encoding\");\n}\nreturn UTF8.equalsIgnoreCase(encoding)\n|| UTF_DASH_8.equalsIgnoreCase(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data);\n} else {\nreturn new String(data,this.charset);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\n\n/** No-arg constructor */\npublic JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>([BI)V",
                                    "method_body": "public ZipShort (byte[] bytes, int offset) {\nvalue = ZipShort.getValue(bytes, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([BI)I",
                                    "method_body": "public static int getValue(byte[] bytes, int offset) {\nint value = (bytes[offset + 1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object o) {\nif (o == null || !(o instanceof ZipShort)) {\nreturn false;\n}\nreturn value == ((ZipShort) o).getValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n\n/**\n* Static registry of known extra fields.\n*/\nprivate static final Map<ZipShort, Class<?>> implementations;\n\nstatic {\nimplementations = new HashMap<ZipShort, Class<?>>();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\nregister(Zip64ExtendedInformationExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class<?> c) {\ntry {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n} catch (ClassCastException cc) {\nthrow new RuntimeException(c + \" doesn\\'t implement ZipExtraField\");\n} catch (InstantiationException ie) {\nthrow new RuntimeException(c + \" is not a concrete class\");\n} catch (IllegalAccessException ie) {\nthrow new RuntimeException(c + \"\\'s no-arg constructor is not public\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:createExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField createExtraField(ZipShort headerId)\nthrows InstantiationException, IllegalAccessException {\nClass<?> c = implementations.get(headerId);\nif (c != null) {\nreturn (ZipExtraField) c.newInstance();\n}\nUnrecognizedExtraField u = new UnrecognizedExtraField();\nu.setHeaderId(headerId);\nreturn u;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:parse([BZLorg/apache/commons/compress/archivers/zip/ExtraFieldUtils$UnparseableExtraField;)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField[] parse(byte[] data, boolean local,\nUnparseableExtraField onUnparseableData)\nthrows ZipException {\nList<ZipExtraField> v = new ArrayList<ZipExtraField>();\nint start = 0;\nLOOP:\nwhile (start <= data.length - WORD) {\nZipShort headerId = new ZipShort(data, start);\nint length = (new ZipShort(data, start + 2)).getValue();\nif (start + WORD + length > data.length) {\nswitch(onUnparseableData.getKey()) {\ncase UnparseableExtraField.THROW_KEY:\nthrow new ZipException(\"bad extra field starting at \"\n+ start + \".  Block length of \"\n+ length + \" bytes exceeds remaining\"\n+ \" data of \"\n+ (data.length - start - WORD)\n+ \" bytes.\");\ncase UnparseableExtraField.READ_KEY:\nUnparseableExtraFieldData field =\nnew UnparseableExtraFieldData();\nif (local) {\nfield.parseFromLocalFileData(data, start,\ndata.length - start);\n} else {\nfield.parseFromCentralDirectoryData(data, start,\ndata.length - start);\n}\nv.add(field);\n//$FALL-THROUGH$\ncase UnparseableExtraField.SKIP_KEY:\n// since we cannot parse the data we must assume\n// the extra field consumes the whole rest of the\n// available data\nbreak LOOP;\ndefault:\nthrow new ZipException(\"unknown UnparseableExtraField key: \"\n+ onUnparseableData.getKey());\n}\n}\ntry {\nZipExtraField ze = createExtraField(headerId);\nif (local) {\nze.parseFromLocalFileData(data, start + WORD, length);\n} else {\nze.parseFromCentralDirectoryData(data, start + WORD,\nlength);\n}\nv.add(ze);\n} catch (InstantiationException ie) {\nthrow new ZipException(ie.getMessage());\n} catch (IllegalAccessException iae) {\nthrow new ZipException(iae.getMessage());\n}\nstart += (length + WORD);\n}\n\nZipExtraField[] result = new ZipExtraField[v.size()];\nreturn v.toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nfinal boolean lastIsUnparseableHolder = data.length > 0\n&& data[data.length - 1] instanceof UnparseableExtraFieldData;\nint regularExtraFieldCount =\nlastIsUnparseableHolder ? data.length - 1 : data.length;\n\nint sum = WORD * regularExtraFieldCount;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\n}\n\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n0, result, start + 2, 2);\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\n}\nif (lastIsUnparseableHolder) {\nbyte[] local = data[data.length - 1].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start, local.length);\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate static final int      WORD = 4;\n/**\n* Standard Unix stat(2) file mode.\n*/\nprivate int mode = 0;\n/**\n* User ID.\n*/\nprivate int uid = 0;\n/**\n* Group ID.\n*/\nprivate int gid = 0;\n/**\n* File this entry points to, if it is a symbolic link.\n*\n* <p>empty string - if entry is not a symbolic link.</p>\n*/\nprivate String link = \"\";\n/**\n* Is this an entry for a directory?\n*/\nprivate boolean dirFlag = false;\n\n/**\n* Instance used to calculate checksums.\n*/\nprivate CRC32 crc = new CRC32();\n\n/** Constructor for AsiExtraField. */\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:assembleData()V",
                                    "method_body": "private void assembleData() {\nif (unicodeName == null) {\nreturn;\n}\n\ndata = new byte[5 + unicodeName.length];\n// version 1\ndata[0] = 0x01;\nSystem.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4);\nSystem.arraycopy(unicodeName, 0, data, 5, unicodeName.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getNameCRC32()J",
                                    "method_body": "public long getNameCRC32() {\nreturn nameCRC32;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getUnicodeName()[B",
                                    "method_body": "public byte[] getUnicodeName() {\nbyte[] b = null;\nif (unicodeName != null) {\nb = new byte[unicodeName.length];\nSystem.arraycopy(unicodeName, 0, b, 0, b.length);\n}\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryData()[B",
                                    "method_body": "public byte[] getCentralDirectoryData() {\nif (data == null) {\nthis.assembleData();\n}\nbyte[] b = null;\nif (data != null) {\nb = new byte[data.length];\nSystem.arraycopy(data, 0, b, 0, b.length);\n}\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getCentralDirectoryLength() {\nif (data == null) {\nassembleData();\n}\nreturn new ZipShort(data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn getCentralDirectoryData();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn getCentralDirectoryLength();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:parseFromLocalFileData([BII)V",
                                    "method_body": "public void parseFromLocalFileData(byte[] buffer, int offset, int length)\nthrows ZipException {\n\nif (length < 5) {\nthrow new ZipException(\"UniCode path extra data must have at least 5 bytes.\");\n}\n\nint version = buffer[offset];\n\nif (version != 0x01) {\nthrow new ZipException(\"Unsupported version [\" + version\n+ \"] for UniCode path extra data.\");\n}\n\nnameCRC32 = ZipLong.getValue(buffer, offset + 1);\nunicodeName = new byte[length - 5];\nSystem.arraycopy(buffer, offset + 5, unicodeName, 0, length - 5);\ndata = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\n\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\n\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<init>()V",
                                    "method_body": "public Zip64ExtendedInformationExtraField() { }\npublic Zip64ExtendedInformationExtraField() { }"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<clinit>()V",
                                    "method_body": "static final ZipShort HEADER_ID = new ZipShort(0x0001);\n\nprivate static final String LFH_MUST_HAVE_BOTH_SIZES_MSG =\n\"Zip64 extended information must contain\"\n+ \" both size values in the local file header.\";\n\nprivate ZipEightByteInteger size, compressedSize, relativeHeaderOffset;\nprivate ZipLong diskStart;\n\n/**\n* Stored in {@link #parseFromCentralDirectoryData\n* parseFromCentralDirectoryData} so it can be reused when ZipFile"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n\n/**\n* Convert a Date object to a DOS date/time field.\n* @param time the <code>Date</code> to convert\n* @return the date as a <code>ZipLong</code>\n*/\npublic static ZipLong toDosTime(Date time) {\nreturn new ZipLong(toDosTime(time.getTime()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:dosToJavaTime(J)J",
                                    "method_body": "public static long dosToJavaTime(long dosTime) {\nCalendar cal = Calendar.getInstance();\n// CheckStyle:MagicNumberCheck OFF - no point\ncal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\ncal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\ncal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);\ncal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);\ncal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);\ncal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);\n// CheckStyle:MagicNumberCheck ON\nreturn cal.getTime().getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:setNameAndCommentFromExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;[B[B)V",
                                    "method_body": "static void setNameAndCommentFromExtraFields(ZipArchiveEntry ze,\nbyte[] originalNameBytes,\nbyte[] commentBytes) {\nUnicodePathExtraField name = (UnicodePathExtraField)\nze.getExtraField(UnicodePathExtraField.UPATH_ID);\nString originalName = ze.getName();\nString newName = getUnicodeStringIfOriginalMatches(name,\noriginalNameBytes);\nif (newName != null && !originalName.equals(newName)) {\nze.setName(newName);\n}\n\nif (commentBytes != null && commentBytes.length > 0) {\nUnicodeCommentExtraField cmt = (UnicodeCommentExtraField)\nze.getExtraField(UnicodeCommentExtraField.UCOM_ID);\nString newComment =\ngetUnicodeStringIfOriginalMatches(cmt, commentBytes);\nif (newComment != null) {\nze.setComment(newComment);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:getUnicodeStringIfOriginalMatches(Lorg/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField;[B)Ljava/lang/String;",
                                    "method_body": "String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f,\nbyte[] orig) {\nif (f != null) {\nCRC32 crc32 = new CRC32();\ncrc32.update(orig);\nlong origCRC32 = crc32.getValue();\n\nif (origCRC32 == f.getNameCRC32()) {\ntry {\nreturn ZipEncodingHelper\n.UTF8_ZIP_ENCODING.decode(f.getUnicodeName());\n} catch (IOException ex) {\n// UTF-8 unsupported?  should be impossible the\n// Unicode*ExtraField must contain some bad bytes\n\n// TODO log this anywhere?\nreturn null;\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<init>(I)V",
                                    "method_body": "private UnparseableExtraField(int k) {\nkey = k;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<clinit>()V",
                                    "method_body": "public static final int THROW_KEY = 0;\n/**\n* Key for \"skip\" action.\n*/\npublic static final int SKIP_KEY = 1;\n/**\n* Key for \"read\" action.\n*/\npublic static final int READ_KEY = 2;\n\n/**\n* Throw an exception if field cannot be parsed.\n*/\npublic static final UnparseableExtraField THROW\n= new UnparseableExtraField(THROW_KEY);\n\n/**\n* Skip the extra field entirely and don't make its data\n* available - effectively removing the extra field data.\n*/\npublic static final UnparseableExtraField SKIP\n= new UnparseableExtraField(SKIP_KEY);\n\n/**\n* Read the extra field data into an instance of {@link\n* UnparseableExtraFieldData UnparseableExtraFieldData}."
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesDataDescriptor()Z",
                                    "method_body": "public boolean usesDataDescriptor() {\nreturn dataDescriptorFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>([B)V",
                                    "method_body": "public ZipLong (byte[] bytes) {\nthis(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>([BI)V",
                                    "method_body": "public ZipLong (byte[] bytes, int offset) {\nvalue = ZipLong.getValue(bytes, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue()J",
                                    "method_body": "public long getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object o) {\nif (o == null || !(o instanceof ZipLong)) {\nreturn false;\n}\nreturn value == ((ZipLong) o).getValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream) {\nthis(inputStream, ZipEncodingHelper.UTF8, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream,\nString encoding,\nboolean useUnicodeExtraFields) {\nthis(inputStream, encoding, useUnicodeExtraFields, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;ZZ)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream,\nString encoding,\nboolean useUnicodeExtraFields,\nboolean allowStoredEntriesWithDataDescriptor) {\nzipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\nin = new PushbackInputStream(inputStream, buf.buf.length);\nthis.allowStoredEntriesWithDataDescriptor =\nallowStoredEntriesWithDataDescriptor;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<clinit>()V",
                                    "method_body": "private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\nprivate static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\nprivate static final byte[] DD = ZipLong.DD_SIG.getBytes();\n\n/**\n* Checks whether the current buffer contains the signature of a\n* &quot;data decsriptor&quot;, &quot;local file header&quot; or\n* &quot;central directory entry&quot;.\n*\n* <p>If it contains such a signature, reads the data descriptor\n* and positions the stream right after the data descriptor.</p>\n*/\nprivate boolean bufferContainsSignature(ByteArrayOutputStream bos,\nint offset, int lastRead,\nint expectedDDLen)\nthrows IOException {\nboolean done = false;\nint readTooMuch = 0;\nfor (int i = 0; !done && i < lastRead - 4; i++) {\nif (buf.buf[i] == LFH[0] && buf.buf[i + 1] == LFH[1]) {\nif ((buf.buf[i + 2] == LFH[2] && buf.buf[i + 3] == LFH[3])\n|| (buf.buf[i] == CFH[2] && buf.buf[i + 3] == CFH[3])) {\n// found a LFH or CFH:\nreadTooMuch = offset + lastRead - i - expectedDDLen;\ndone = true;\n}\nelse if (buf.buf[i + 2] == DD[2] && buf.buf[i + 3] == DD[3]) {\n// found DD:\nreadTooMuch = offset + lastRead - i;\ndone = true;\n}\nif (done) {\n// * push back bytes read in excess as well as the data\n//   descriptor\n// * copy the remaining bytes to cache\n// * read data descriptor\npushback(buf.buf, offset + lastRead - readTooMuch,\nreadTooMuch);\nbos.write(buf.buf, 0, i);\nreadDataDescriptor();\n}\n}\n}\nreturn done;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:getNextZipEntry()Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;",
                                    "method_body": "public ZipArchiveEntry getNextZipEntry() throws IOException {\nif (closed || hitCentralDirectory) {\nreturn null;\n}\nif (current != null) {\ncloseEntry();\n}\nbyte[] lfh = new byte[LFH_LEN];\ntry {\nreadFully(lfh);\n} catch (EOFException e) {\nreturn null;\n}\nZipLong sig = new ZipLong(lfh);\nif (sig.equals(ZipLong.CFH_SIG)) {\nhitCentralDirectory = true;\nreturn null;\n}\nif (!sig.equals(ZipLong.LFH_SIG)) {\nreturn null;\n}\n\nint off = WORD;\ncurrent = new CurrentEntry();\n\nint versionMadeBy = ZipShort.getValue(lfh, off);\noff += SHORT;\ncurrent.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT)\n& ZipFile.NIBLET_MASK);\n\nfinal GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(lfh, off);\nfinal boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\nfinal ZipEncoding entryEncoding =\nhasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\ncurrent.hasDataDescriptor = gpFlag.usesDataDescriptor();\ncurrent.entry.setGeneralPurposeBit(gpFlag);\n\noff += SHORT;\n\ncurrent.entry.setMethod(ZipShort.getValue(lfh, off));\noff += SHORT;\n\nlong time = ZipUtil.dosToJavaTime(ZipLong.getValue(lfh, off));\ncurrent.entry.setTime(time);\noff += WORD;\n\nZipLong size = null, cSize = null;\nif (!current.hasDataDescriptor) {\ncurrent.entry.setCrc(ZipLong.getValue(lfh, off));\noff += WORD;\n\ncSize = new ZipLong(lfh, off);\noff += WORD;\n\nsize = new ZipLong(lfh, off);\noff += WORD;\n} else {\noff += 3 * WORD;\n}\n\nint fileNameLen = ZipShort.getValue(lfh, off);\n\noff += SHORT;\n\nint extraLen = ZipShort.getValue(lfh, off);\noff += SHORT;\n\nbyte[] fileName = new byte[fileNameLen];\nreadFully(fileName);\ncurrent.entry.setName(entryEncoding.decode(fileName), fileName);\n\nbyte[] extraData = new byte[extraLen];\nreadFully(extraData);\ncurrent.entry.setExtra(extraData);\n\nif (!hasUTF8Flag && useUnicodeExtraFields) {\nZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName,\nnull);\n}\n\nprocessZip64Extra(size, cSize);\nreturn current.entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:processZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipLong;Lorg/apache/commons/compress/archivers/zip/ZipLong;)V",
                                    "method_body": "private void processZip64Extra(ZipLong size, ZipLong cSize) {\nZip64ExtendedInformationExtraField z64 =\n(Zip64ExtendedInformationExtraField)\ncurrent.entry.getExtraField(Zip64ExtendedInformationExtraField\n.HEADER_ID);\ncurrent.usesZip64 = z64 != null;\nif (!current.hasDataDescriptor) {\nif (current.usesZip64 && (cSize.equals(ZipLong.ZIP64_MAGIC)\n|| size.equals(ZipLong.ZIP64_MAGIC))\n) {\ncurrent.entry.setCompressedSize(z64.getCompressedSize() // z64 cannot be null here\n.getLongValue());\ncurrent.entry.setSize(z64.getSize().getLongValue());\n} else {\ncurrent.entry.setCompressedSize(cSize.getValue());\ncurrent.entry.setSize(size.getValue());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!closed) {\nclosed = true;\nin.close();\ninf.end();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:closeEntry()V",
                                    "method_body": "private void closeEntry() throws IOException {\nif (closed) {\nthrow new IOException(\"The stream is closed\");\n}\nif (current == null) {\nreturn;\n}\n\n// Ensure all entry bytes are read\nif (current.bytesReadFromStream <= current.entry.getCompressedSize()\n&& !current.hasDataDescriptor) {\ndrainCurrentEntryData();\n} else {\nskip(Long.MAX_VALUE);\n\nlong inB =\ncurrent.entry.getMethod() == ZipArchiveOutputStream.DEFLATED\n? getBytesInflated() : current.bytesRead;\n\n// this is at most a single read() operation and can't\n// exceed the range of int\nint diff = (int) (current.bytesReadFromStream - inB);\n\n// Pushback any required bytes\nif (diff > 0) {\npushback(buf.buf, buf.lengthOfLastRead - diff, diff);\n}\n}\n\nif (lastStoredEntry == null && current.hasDataDescriptor) {\nreadDataDescriptor();\n}\n\ninf.reset();\nbuf.reset();\ncrc.reset();\ncurrent = null;\nlastStoredEntry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:drainCurrentEntryData()V",
                                    "method_body": "private void drainCurrentEntryData() throws IOException {\nlong remaining = current.entry.getCompressedSize()\n- current.bytesReadFromStream;\nwhile (remaining > 0) {\nlong n = in.read(buf.buf, 0, (int) Math.min(buf.buf.length,\nremaining));\nif (n < 0) {\nthrow new EOFException(\n\"Truncated ZIP entry: \" + current.entry.getName());\n} else {\ncount(n);\nremaining -= n;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readFully([B)V",
                                    "method_body": "private void readFully(byte[] b) throws IOException {\nint count = 0, x = 0;\nwhile (count != b.length) {\ncount += x = in.read(b, count, b.length - count);\nif (x == -1) {\nthrow new EOFException();\n}\ncount(x);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream$Buffer:access$1000(Lorg/apache/commons/compress/archivers/zip/ZipArchiveInputStream$Buffer;)V",
                                    "method_body": "private final ZipArchiveEntry entry = new ZipArchiveEntry();\n/**\n* Does the entry use a data descriptor?\n*/\nprivate boolean hasDataDescriptor;\n/**\n* Does the entry have a ZIP64 extended information extra field.\n*/\nprivate boolean usesZip64;\n/**\n* Number of bytes of entry content read by the client if the\n* entry is STORED.\n*/\nprivate long bytesRead;\n/**\n* Number of bytes of entry content read so from the stream.\n*\n* <p>This may be more than the actual entry's length as some\n* stuff gets buffered up and needs to be pushed back when the\n* end of the entry has been reached.</p>\n*/\nprivate long bytesReadFromStream;\n}\n\n/**\n* Contains a temporary buffer used to read from the wrapped\n* stream together with some information needed for internal\n* housekeeping.\n*/\nprivate static final class Buffer {\n/**\n* Buffer used as temporary buffer when reading from the stream.\n*/\nprivate final byte[] buf = new byte[ZipArchiveOutputStream.BUFFER_SIZE];\n/**\n* {@link #buf buf} may contain data the client hasnt read, yet,\n* this is the first byte that hasn't been read so far.\n*/\nprivate int offsetInBuffer = 0;\n/**\n* Number of bytes read from the wrapped stream into {@link #buf\n* buf} with the last read operation.\n*/\nprivate int lengthOfLastRead = 0;\n/**\n* Reset internal housekeeping.\n*/\nprivate void reset() {\noffsetInBuffer = lengthOfLastRead = 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream$Buffer:reset()V",
                                    "method_body": "private void reset() {\noffsetInBuffer = lengthOfLastRead = 0;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.ZipFileTest.testWinzipBackSlashWorkaround",
                            "test_body": "145: public void testWinzipBackSlashWorkaround() throws Exception {\n146: URL zip = getClass().getResource(\"/test-winzip.zip\");\n147: File archive = new File(new URI(zip.toString()));\n148: zf = new ZipFile(archive);\n149: assertNull(zf.getEntry(\"\\u00e4\\\\\\u00fc.txt\"));\n150: assertNotNull(zf.getEntry(\"\\u00e4/\\u00fc.txt\"));\n151: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "protected ZipArchiveEntry() {\nthis(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setMethod(I)V",
                                    "method_body": "public void setMethod(int method) {\nif (method < 0) {\nthrow new IllegalArgumentException(\n\"ZIP compression method can not be negative: \" + method);\n}\nthis.method = method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setInternalAttributes(I)V",
                                    "method_body": "public void setInternalAttributes(int value) {\ninternalAttributes = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExternalAttributes(J)V",
                                    "method_body": "public void setExternalAttributes(long value) {\nexternalAttributes = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setPlatform(I)V",
                                    "method_body": "protected void setPlatform(int platform) {\nthis.platform = platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void setExtraFields(ZipExtraField[] fields) {\nextraFields = new LinkedHashMap<ZipShort, ZipExtraField>();\nfor (int i = 0; i < fields.length; i++) {\nif (fields[i] instanceof UnparseableExtraFieldData) {\nunparseableExtra = (UnparseableExtraFieldData) fields[i];\n} else {\nextraFields.put(fields[i].getHeaderId(), fields[i]);\n}\n}\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields(Z)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields(boolean includeUnparseable) {\nif (extraFields == null) {\nreturn !includeUnparseable || unparseableExtra == null\n? new ZipExtraField[0]\n: new ZipExtraField[] { unparseableExtra };\n}\nList<ZipExtraField> result =\nnew ArrayList<ZipExtraField>(extraFields.values());\nif (includeUnparseable && unparseableExtra != null) {\nresult.add(unparseableExtra);\n}\nreturn result.toArray(new ZipExtraField[0]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField getExtraField(ZipShort type) {\nif (extraFields != null) {\nreturn extraFields.get(type);\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra([B)V",
                                    "method_body": "public void setExtra(byte[] extra) throws RuntimeException {\ntry {\nZipExtraField[] local =\nExtraFieldUtils.parse(extra, true,\nExtraFieldUtils.UnparseableExtraField.READ);\nmergeExtraFields(local, true);\n} catch (ZipException e) {\n// actually this is not possible as of Commons Compress 1.1\nthrow new RuntimeException(\"Error parsing extra fields for entry: \"\n+ getName() + \" - \" + e.getMessage(), e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields(true)));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setCentralDirectoryExtra([B)V",
                                    "method_body": "public void setCentralDirectoryExtra(byte[] b) {\ntry {\nZipExtraField[] central =\nExtraFieldUtils.parse(b, false,\nExtraFieldUtils.UnparseableExtraField.READ);\nmergeExtraFields(central, false);\n} catch (ZipException e) {\nthrow new RuntimeException(e.getMessage(), e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "protected void setName(String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nif (size < 0) {\nthrow new IllegalArgumentException(\"invalid entry size\");\n}\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;[B)V",
                                    "method_body": "protected void setName(String name, byte[] rawName) {\nsetName(name);\nthis.rawName = rawName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\n// this method has severe consequences on performance. We cannot rely\n// on the super.hashCode() method since super.getName() always return\n// the empty string in the current implemention (there's no setter)\n// so it is basically draining the performance of a hashmap lookup\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setGeneralPurposeBit(Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;)V",
                                    "method_body": "public void setGeneralPurposeBit(GeneralPurposeBit b) {\ngpb = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:mergeExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;Z)V",
                                    "method_body": "private void mergeExtraFields(ZipExtraField[] f, boolean local)\nthrows ZipException {\nif (extraFields == null) {\nsetExtraFields(f);\n} else {\nfor (int i = 0; i < f.length; i++) {\nZipExtraField existing;\nif (f[i] instanceof UnparseableExtraFieldData) {\nexisting = unparseableExtra;\n} else {\nexisting = getExtraField(f[i].getHeaderId());\n}\nif (existing == null) {\naddExtraField(f[i]);\n} else {\nif (local) {\nbyte[] b = f[i].getLocalFileDataData();\nexisting.parseFromLocalFileData(b, 0, b.length);\n} else {\nbyte[] b = f[i].getCentralDirectoryData();\nexisting.parseFromCentralDirectoryData(b, 0, b.length);\n}\n}\n}\nsetExtra();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:<init>()V",
                                    "method_body": "public GeneralPurposeBit() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesUTF8ForNames()Z",
                                    "method_body": "public boolean usesUTF8ForNames() {\nreturn languageEncodingFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useUTF8ForNames(Z)V",
                                    "method_body": "public void useUTF8ForNames(boolean b) {\nlanguageEncodingFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useDataDescriptor(Z)V",
                                    "method_body": "public void useDataDescriptor(boolean b) {\ndataDescriptorFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useEncryption(Z)V",
                                    "method_body": "public void useEncryption(boolean b) {\nencryptionFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useStrongEncryption(Z)V",
                                    "method_body": "public void useStrongEncryption(boolean b) {\nstrongEncryptionFlag = b;\nif (b) {\nuseEncryption(true);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:parse([BI)Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "public static GeneralPurposeBit parse(final byte[] data, final int offset) {\nfinal int generalPurposeFlag = ZipShort.getValue(data, offset);\nGeneralPurposeBit b = new GeneralPurposeBit();\nb.useDataDescriptor((generalPurposeFlag & DATA_DESCRIPTOR_FLAG) != 0);\nb.useUTF8ForNames((generalPurposeFlag & UFT8_NAMES_FLAG) != 0);\nb.useStrongEncryption((generalPurposeFlag & STRONG_ENCRYPTION_FLAG)\n!= 0);\nb.useEncryption((generalPurposeFlag & ENCRYPTION_FLAG) != 0);\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "public static final int EFS_FLAG = GeneralPurposeBit.UFT8_NAMES_FLAG;\n\n/**\n* Current entry.\n*/\nprivate CurrentEntry entry;\n\n/**\n* The file comment.\n*/\nprivate String comment = \"\";\n\n/**\n* Compression level for next entry.\n*/\nprivate int level = DEFAULT_COMPRESSION;\n\n/**\n* Has the compression level changed when compared to the last\n* entry?\n*/\nprivate boolean hasCompressionLevelChanged = false;\n\n/**\n* Default compression method for next entry.\n*/\nprivate int method = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* List of ZipArchiveEntries written so far.\n*/\nprivate final List<ZipArchiveEntry> entries =\nnew LinkedList<ZipArchiveEntry>();\n\n/**\n* CRC instance to avoid parsing DEFLATED data twice.\n*/\nprivate final CRC32 crc = new CRC32();\n\n/**\n* Count the bytes written to out.\n*/\nprivate long written = 0;\n\n/**\n* Start of central directory.\n*/\nprivate long cdOffset = 0;\n\n/**\n* Length of central directory.\n*/\nprivate long cdLength = 0;\n\n/**\n* Helper, a 0 as ZipShort.\n*/\nprivate static final byte[] ZERO = {0, 0};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Data Descriptor signature\n* @since Apache Commons Compress 1.1\n*/\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\n\n/**\n* Value stored in size and similar fields if ZIP64 extensions are\n* used.\n* @since Apache Commons Compress 1.3\n*/\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n\nstatic {\nsimpleEncodings = new HashMap<String, SimpleEncodingHolder>();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for utf-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h = simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\n// check platform's default encoding\nencoding = System.getProperty(\"file.encoding\");\n}\nreturn UTF8.equalsIgnoreCase(encoding)\n|| UTF_DASH_8.equalsIgnoreCase(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data);\n} else {\nreturn new String(data,this.charset);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\n\n/** No-arg constructor */\npublic JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>([BI)V",
                                    "method_body": "public ZipShort (byte[] bytes, int offset) {\nvalue = ZipShort.getValue(bytes, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([BI)I",
                                    "method_body": "public static int getValue(byte[] bytes, int offset) {\nint value = (bytes[offset + 1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([B)I",
                                    "method_body": "public static int getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object o) {\nif (o == null || !(o instanceof ZipShort)) {\nreturn false;\n}\nreturn value == ((ZipShort) o).getValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n\n/**\n* Static registry of known extra fields.\n*/\nprivate static final Map<ZipShort, Class<?>> implementations;\n\nstatic {\nimplementations = new HashMap<ZipShort, Class<?>>();\nregister(AsiExtraField.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\nregister(Zip64ExtendedInformationExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class<?> c) {\ntry {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n} catch (ClassCastException cc) {\nthrow new RuntimeException(c + \" doesn\\'t implement ZipExtraField\");\n} catch (InstantiationException ie) {\nthrow new RuntimeException(c + \" is not a concrete class\");\n} catch (IllegalAccessException ie) {\nthrow new RuntimeException(c + \"\\'s no-arg constructor is not public\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:createExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField createExtraField(ZipShort headerId)\nthrows InstantiationException, IllegalAccessException {\nClass<?> c = implementations.get(headerId);\nif (c != null) {\nreturn (ZipExtraField) c.newInstance();\n}\nUnrecognizedExtraField u = new UnrecognizedExtraField();\nu.setHeaderId(headerId);\nreturn u;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:parse([BZLorg/apache/commons/compress/archivers/zip/ExtraFieldUtils$UnparseableExtraField;)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField[] parse(byte[] data, boolean local,\nUnparseableExtraField onUnparseableData)\nthrows ZipException {\nList<ZipExtraField> v = new ArrayList<ZipExtraField>();\nint start = 0;\nLOOP:\nwhile (start <= data.length - WORD) {\nZipShort headerId = new ZipShort(data, start);\nint length = (new ZipShort(data, start + 2)).getValue();\nif (start + WORD + length > data.length) {\nswitch(onUnparseableData.getKey()) {\ncase UnparseableExtraField.THROW_KEY:\nthrow new ZipException(\"bad extra field starting at \"\n+ start + \".  Block length of \"\n+ length + \" bytes exceeds remaining\"\n+ \" data of \"\n+ (data.length - start - WORD)\n+ \" bytes.\");\ncase UnparseableExtraField.READ_KEY:\nUnparseableExtraFieldData field =\nnew UnparseableExtraFieldData();\nif (local) {\nfield.parseFromLocalFileData(data, start,\ndata.length - start);\n} else {\nfield.parseFromCentralDirectoryData(data, start,\ndata.length - start);\n}\nv.add(field);\n//$FALL-THROUGH$\ncase UnparseableExtraField.SKIP_KEY:\n// since we cannot parse the data we must assume\n// the extra field consumes the whole rest of the\n// available data\nbreak LOOP;\ndefault:\nthrow new ZipException(\"unknown UnparseableExtraField key: \"\n+ onUnparseableData.getKey());\n}\n}\ntry {\nZipExtraField ze = createExtraField(headerId);\nif (local) {\nze.parseFromLocalFileData(data, start + WORD, length);\n} else {\nze.parseFromCentralDirectoryData(data, start + WORD,\nlength);\n}\nv.add(ze);\n} catch (InstantiationException ie) {\nthrow new ZipException(ie.getMessage());\n} catch (IllegalAccessException iae) {\nthrow new ZipException(iae.getMessage());\n}\nstart += (length + WORD);\n}\n\nZipExtraField[] result = new ZipExtraField[v.size()];\nreturn v.toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nfinal boolean lastIsUnparseableHolder = data.length > 0\n&& data[data.length - 1] instanceof UnparseableExtraFieldData;\nint regularExtraFieldCount =\nlastIsUnparseableHolder ? data.length - 1 : data.length;\n\nint sum = WORD * regularExtraFieldCount;\nfor (int i = 0; i < data.length; i++) {\nsum += data[i].getLocalFileDataLength().getValue();\n}\n\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n0, result, start + 2, 2);\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\n}\nif (lastIsUnparseableHolder) {\nbyte[] local = data[data.length - 1].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start, local.length);\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate static final int      WORD = 4;\n/**\n* Standard Unix stat(2) file mode.\n*/\nprivate int mode = 0;\n/**\n* User ID.\n*/\nprivate int uid = 0;\n/**\n* Group ID.\n*/\nprivate int gid = 0;\n/**\n* File this entry points to, if it is a symbolic link.\n*\n* <p>empty string - if entry is not a symbolic link.</p>\n*/\nprivate String link = \"\";\n/**\n* Is this an entry for a directory?\n*/\nprivate boolean dirFlag = false;\n\n/**\n* Instance used to calculate checksums.\n*/\nprivate CRC32 crc = new CRC32();\n\n/** Constructor for AsiExtraField. */\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:assembleData()V",
                                    "method_body": "private void assembleData() {\nif (unicodeName == null) {\nreturn;\n}\n\ndata = new byte[5 + unicodeName.length];\n// version 1\ndata[0] = 0x01;\nSystem.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4);\nSystem.arraycopy(unicodeName, 0, data, 5, unicodeName.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getNameCRC32()J",
                                    "method_body": "public long getNameCRC32() {\nreturn nameCRC32;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getUnicodeName()[B",
                                    "method_body": "public byte[] getUnicodeName() {\nbyte[] b = null;\nif (unicodeName != null) {\nb = new byte[unicodeName.length];\nSystem.arraycopy(unicodeName, 0, b, 0, b.length);\n}\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryData()[B",
                                    "method_body": "public byte[] getCentralDirectoryData() {\nif (data == null) {\nthis.assembleData();\n}\nbyte[] b = null;\nif (data != null) {\nb = new byte[data.length];\nSystem.arraycopy(data, 0, b, 0, b.length);\n}\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getCentralDirectoryLength() {\nif (data == null) {\nassembleData();\n}\nreturn new ZipShort(data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn getCentralDirectoryData();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn getCentralDirectoryLength();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:parseFromLocalFileData([BII)V",
                                    "method_body": "public void parseFromLocalFileData(byte[] buffer, int offset, int length)\nthrows ZipException {\n\nif (length < 5) {\nthrow new ZipException(\"UniCode path extra data must have at least 5 bytes.\");\n}\n\nint version = buffer[offset];\n\nif (version != 0x01) {\nthrow new ZipException(\"Unsupported version [\" + version\n+ \"] for UniCode path extra data.\");\n}\n\nnameCRC32 = ZipLong.getValue(buffer, offset + 1);\nunicodeName = new byte[length - 5];\nSystem.arraycopy(buffer, offset + 5, unicodeName, 0, length - 5);\ndata = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:parseFromCentralDirectoryData([BII)V",
                                    "method_body": "public void parseFromCentralDirectoryData(byte[] buffer, int offset,\nint length)\nthrows ZipException {\nparseFromLocalFileData(buffer, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\n\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\n\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<init>()V",
                                    "method_body": "public Zip64ExtendedInformationExtraField() { }\npublic Zip64ExtendedInformationExtraField() { }"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<clinit>()V",
                                    "method_body": "static final ZipShort HEADER_ID = new ZipShort(0x0001);\n\nprivate static final String LFH_MUST_HAVE_BOTH_SIZES_MSG =\n\"Zip64 extended information must contain\"\n+ \" both size values in the local file header.\";\n\nprivate ZipEightByteInteger size, compressedSize, relativeHeaderOffset;\nprivate ZipLong diskStart;\n\n/**\n* Stored in {@link #parseFromCentralDirectoryData\n* parseFromCentralDirectoryData} so it can be reused when ZipFile"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n\n/**\n* Convert a Date object to a DOS date/time field.\n* @param time the <code>Date</code> to convert\n* @return the date as a <code>ZipLong</code>\n*/\npublic static ZipLong toDosTime(Date time) {\nreturn new ZipLong(toDosTime(time.getTime()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:dosToJavaTime(J)J",
                                    "method_body": "public static long dosToJavaTime(long dosTime) {\nCalendar cal = Calendar.getInstance();\n// CheckStyle:MagicNumberCheck OFF - no point\ncal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\ncal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\ncal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);\ncal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);\ncal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);\ncal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);\n// CheckStyle:MagicNumberCheck ON\nreturn cal.getTime().getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:setNameAndCommentFromExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;[B[B)V",
                                    "method_body": "static void setNameAndCommentFromExtraFields(ZipArchiveEntry ze,\nbyte[] originalNameBytes,\nbyte[] commentBytes) {\nUnicodePathExtraField name = (UnicodePathExtraField)\nze.getExtraField(UnicodePathExtraField.UPATH_ID);\nString originalName = ze.getName();\nString newName = getUnicodeStringIfOriginalMatches(name,\noriginalNameBytes);\nif (newName != null && !originalName.equals(newName)) {\nze.setName(newName);\n}\n\nif (commentBytes != null && commentBytes.length > 0) {\nUnicodeCommentExtraField cmt = (UnicodeCommentExtraField)\nze.getExtraField(UnicodeCommentExtraField.UCOM_ID);\nString newComment =\ngetUnicodeStringIfOriginalMatches(cmt, commentBytes);\nif (newComment != null) {\nze.setComment(newComment);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:getUnicodeStringIfOriginalMatches(Lorg/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField;[B)Ljava/lang/String;",
                                    "method_body": "String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f,\nbyte[] orig) {\nif (f != null) {\nCRC32 crc32 = new CRC32();\ncrc32.update(orig);\nlong origCRC32 = crc32.getValue();\n\nif (origCRC32 == f.getNameCRC32()) {\ntry {\nreturn ZipEncodingHelper\n.UTF8_ZIP_ENCODING.decode(f.getUnicodeName());\n} catch (IOException ex) {\n// UTF-8 unsupported?  should be impossible the\n// Unicode*ExtraField must contain some bad bytes\n\n// TODO log this anywhere?\nreturn null;\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:copy([B)[B",
                                    "method_body": "static byte[] copy(byte[] from) {\nif (from != null) {\nbyte[] to = new byte[from.length];\nSystem.arraycopy(from, 0, to, 0, to.length);\nreturn to;\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<init>(I)V",
                                    "method_body": "private UnparseableExtraField(int k) {\nkey = k;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<clinit>()V",
                                    "method_body": "public static final int THROW_KEY = 0;\n/**\n* Key for \"skip\" action.\n*/\npublic static final int SKIP_KEY = 1;\n/**\n* Key for \"read\" action.\n*/\npublic static final int READ_KEY = 2;\n\n/**\n* Throw an exception if field cannot be parsed.\n*/\npublic static final UnparseableExtraField THROW\n= new UnparseableExtraField(THROW_KEY);\n\n/**\n* Skip the extra field entirely and don't make its data\n* available - effectively removing the extra field data.\n*/\npublic static final UnparseableExtraField SKIP\n= new UnparseableExtraField(SKIP_KEY);\n\n/**\n* Read the extra field data into an instance of {@link\n* UnparseableExtraFieldData UnparseableExtraFieldData}."
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setHeaderId(Lorg/apache/commons/compress/archivers/zip/ZipShort;)V",
                                    "method_body": "public void setHeaderId(ZipShort headerId) {\nthis.headerId = headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setLocalFileDataData([B)V",
                                    "method_body": "public void setLocalFileDataData(byte[] data) {\nlocalData = ZipUtil.copy(data);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn new ZipShort(localData.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn ZipUtil.copy(localData);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setCentralDirectoryData([B)V",
                                    "method_body": "public void setCentralDirectoryData(byte[] data) {\ncentralData = ZipUtil.copy(data);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:parseFromCentralDirectoryData([BII)V",
                                    "method_body": "public void parseFromCentralDirectoryData(byte[] data, int offset,\nint length) {\nbyte[] tmp = new byte[length];\nSystem.arraycopy(data, offset, tmp, 0, length);\nsetCentralDirectoryData(tmp);\nif (localData == null) {\nsetLocalFileDataData(tmp);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipFile(File f) throws IOException {\nthis(f, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;)V",
                                    "method_body": "public ZipFile(File f, String encoding) throws IOException {\nthis(f, encoding, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\nthrows IOException {\nthis.archiveName = f.getAbsolutePath();\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = new RandomAccessFile(f, \"r\");\nboolean success = false;\ntry {\nMap<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag =\npopulateFromCentralDirectory();\nresolveLocalFileHeaderData(entriesWithoutUTF8Flag);\nsuccess = true;\n} finally {\nif (!success) {\ntry {\nclosed = true;\narchive.close();\n} catch (IOException e2) { // NOPMD\n// swallow, throw the original exception instead\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<clinit>()V",
                                    "method_body": "private static final int CFH_LEN =\n/* version made by                 */ SHORT\n/* version needed to extract       */ + SHORT\n/* general purpose bit flag        */ + SHORT\n/* compression method              */ + SHORT\n/* last mod file time              */ + SHORT\n/* last mod file date              */ + SHORT\n/* crc-32                          */ + WORD\n/* compressed size                 */ + WORD\n/* uncompressed size               */ + WORD\n/* filename length                 */ + SHORT\n/* extra field length              */ + SHORT\n/* file comment length             */ + SHORT\n/* disk number start               */ + SHORT\n/* internal file attributes        */ + SHORT\n/* external file attributes        */ + WORD\n/* relative offset of local header */ + WORD;\n\nprivate static final long CFH_SIG =\nZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n\n/**\n* Reads the central directory of the given archive and populates\n* the internal tables with ZipArchiveEntry instances.\n*\n* <p>The ZipArchiveEntrys will know all data that can be obtained from\n* the central directory alone, but not the data that requires the\n* local file header or additional data to be read.</p>\n*\n* @return a map of zipentries that didn't have the language\n* encoding flag set when read.\n*/\nprivate Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory()\nthrows IOException {\nHashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\nnew HashMap<ZipArchiveEntry, NameAndComment>();\n\npositionAtCentralDirectory();\n\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\n\nif (sig != CFH_SIG && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n+ \" corrupt archive.\");\n}\n\nwhile (sig == CFH_SIG) {\nreadCentralDirectoryEntry(noUTF8Flag);\narchive.readFully(signatureBytes);\nsig = ZipLong.getValue(signatureBytes);\n}\nreturn noUTF8Flag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:close()V",
                                    "method_body": "public void close() throws IOException {\n// this flag is only written here and read in finalize() which\n// can never be run in parallel.\n// no synchronization needed.\nclosed = true;\n\narchive.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
                                    "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\ntry {\nzipfile.close();\n} catch (IOException e) { // NOPMD\n//ignore, that's why the method is called \"quietly\"\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:getEntry(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;",
                                    "method_body": "public ZipArchiveEntry getEntry(String name) {\nreturn nameMap.get(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory()\nthrows IOException {\nHashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\nnew HashMap<ZipArchiveEntry, NameAndComment>();\n\npositionAtCentralDirectory();\n\nbyte[] signatureBytes = new byte[WORD];\narchive.readFully(signatureBytes);\nlong sig = ZipLong.getValue(signatureBytes);\n\nif (sig != CFH_SIG && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n+ \" corrupt archive.\");\n}\n\nwhile (sig == CFH_SIG) {\nreadCentralDirectoryEntry(noUTF8Flag);\narchive.readFully(signatureBytes);\nsig = ZipLong.getValue(signatureBytes);\n}\nreturn noUTF8Flag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:readCentralDirectoryEntry(Ljava/util/Map;)V",
                                    "method_body": "private void\nreadCentralDirectoryEntry(Map<ZipArchiveEntry, NameAndComment> noUTF8Flag)\nthrows IOException {\nbyte[] cfh = new byte[CFH_LEN];\n\narchive.readFully(cfh);\nint off = 0;\nZipArchiveEntry ze = new ZipArchiveEntry();\n\nint versionMadeBy = ZipShort.getValue(cfh, off);\noff += SHORT;\nze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\noff += SHORT; // skip version info\n\nfinal GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(cfh, off);\nfinal boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\nfinal ZipEncoding entryEncoding =\nhasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\nze.setGeneralPurposeBit(gpFlag);\n\noff += SHORT;\n\nze.setMethod(ZipShort.getValue(cfh, off));\noff += SHORT;\n\nlong time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\nze.setTime(time);\noff += WORD;\n\nze.setCrc(ZipLong.getValue(cfh, off));\noff += WORD;\n\nze.setCompressedSize(ZipLong.getValue(cfh, off));\noff += WORD;\n\nze.setSize(ZipLong.getValue(cfh, off));\noff += WORD;\n\nint fileNameLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nint extraLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nint commentLen = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nint diskStart = ZipShort.getValue(cfh, off);\noff += SHORT;\n\nze.setInternalAttributes(ZipShort.getValue(cfh, off));\noff += SHORT;\n\nze.setExternalAttributes(ZipLong.getValue(cfh, off));\noff += WORD;\n\nbyte[] fileName = new byte[fileNameLen];\narchive.readFully(fileName);\nze.setName(entryEncoding.decode(fileName), fileName);\n\n// LFH offset,\nOffsetEntry offset = new OffsetEntry();\noffset.headerOffset = ZipLong.getValue(cfh, off);\n// data offset will be filled later\nentries.put(ze, offset);\n\nnameMap.put(ze.getName(), ze);\n\nbyte[] cdExtraData = new byte[extraLen];\narchive.readFully(cdExtraData);\nze.setCentralDirectoryExtra(cdExtraData);\n\nsetSizesAndOffsetFromZip64Extra(ze, offset, diskStart);\n\nbyte[] comment = new byte[commentLen];\narchive.readFully(comment);\nze.setComment(entryEncoding.decode(comment));\n\nif (!hasUTF8Flag && useUnicodeExtraFields) {\nnoUTF8Flag.put(ze, new NameAndComment(fileName, comment));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:setSizesAndOffsetFromZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Lorg/apache/commons/compress/archivers/zip/ZipFile$OffsetEntry;I)V",
                                    "method_body": "private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze,\nOffsetEntry offset,\nint diskStart)\nthrows IOException {\nZip64ExtendedInformationExtraField z64 =\n(Zip64ExtendedInformationExtraField)\nze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\nif (z64 != null) {\nboolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\nboolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\nboolean hasRelativeHeaderOffset =\noffset.headerOffset == ZIP64_MAGIC;\nz64.reparseCentralDirectoryData(hasUncompressedSize,\nhasCompressedSize,\nhasRelativeHeaderOffset,\ndiskStart == ZIP64_MAGIC_SHORT);\n\nif (hasUncompressedSize) {\nze.setSize(z64.getSize().getLongValue());\n} else if (hasCompressedSize) {\nz64.setSize(new ZipEightByteInteger(ze.getSize()));\n}\n\nif (hasCompressedSize) {\nze.setCompressedSize(z64.getCompressedSize().getLongValue());\n} else if (hasUncompressedSize) {\nz64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));\n}\n\nif (hasRelativeHeaderOffset) {\noffset.headerOffset =\nz64.getRelativeHeaderOffset().getLongValue();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nthrows IOException {\nboolean found = tryToLocateSignature(MIN_EOCD_SIZE + ZIP64_EOCDL_LENGTH,\nMAX_EOCD_SIZE + ZIP64_EOCDL_LENGTH,\nZipArchiveOutputStream\n.ZIP64_EOCD_LOC_SIG);\nif (!found) {\n// not a ZIP64 archive\npositionAtCentralDirectory32();\n} else {\npositionAtCentralDirectory64();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory32()V",
                                    "method_body": "private void positionAtCentralDirectory32()\nthrows IOException {\nboolean found = tryToLocateSignature(MIN_EOCD_SIZE, MAX_EOCD_SIZE,\nZipArchiveOutputStream.EOCD_SIG);\nif (!found) {\nthrow new ZipException(\"archive is not a ZIP archive\");\n}\nskipBytes(CFD_LOCATOR_OFFSET);\nbyte[] cfdOffset = new byte[WORD];\narchive.readFully(cfdOffset);\narchive.seek(ZipLong.getValue(cfdOffset));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:tryToLocateSignature(JJ[B)Z",
                                    "method_body": "private boolean tryToLocateSignature(long minDistanceFromEnd,\nlong maxDistanceFromEnd,\nbyte[] sig) throws IOException {\nboolean found = false;\nlong off = archive.length() - minDistanceFromEnd;\nfinal long stopSearching =\nMath.max(0L, archive.length() - maxDistanceFromEnd);\nif (off >= 0) {\nfor (; off >= stopSearching; off--) {\narchive.seek(off);\nint curr = archive.read();\nif (curr == -1) {\nbreak;\n}\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\n}\n}\n}\n}\n}\n}\nif (found) {\narchive.seek(off);\n}\nreturn found;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:skipBytes(I)V",
                                    "method_body": "private void skipBytes(final int count) throws IOException {\nint totalSkipped = 0;\nwhile (totalSkipped < count) {\nint skippedNow = archive.skipBytes(count - totalSkipped);\nif (skippedNow <= 0) {\nthrow new EOFException();\n}\ntotalSkipped += skippedNow;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:resolveLocalFileHeaderData(Ljava/util/Map;)V",
                                    "method_body": "private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\nentriesWithoutUTF8Flag)\nthrows IOException {\n// changing the name of a ZipArchiveEntry is going to change\n// the hashcode - see COMPRESS-164\n// Map needs to be reconstructed in order to keep central\n// directory order\nMap<ZipArchiveEntry, OffsetEntry> origMap =\nnew LinkedHashMap<ZipArchiveEntry, OffsetEntry>(entries);\nentries.clear();\nfor (ZipArchiveEntry ze : origMap.keySet()) {\nOffsetEntry offsetEntry = origMap.get(ze);\nlong offset = offsetEntry.headerOffset;\narchive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\nbyte[] b = new byte[SHORT];\narchive.readFully(b);\nint fileNameLen = ZipShort.getValue(b);\narchive.readFully(b);\nint extraFieldLen = ZipShort.getValue(b);\nint lenToSkip = fileNameLen;\nwhile (lenToSkip > 0) {\nint skipped = archive.skipBytes(lenToSkip);\nif (skipped <= 0) {\nthrow new IOException(\"failed to skip file name in\"\n+ \" local file header\");\n}\nlenToSkip -= skipped;\n}\nbyte[] localExtraData = new byte[extraFieldLen];\narchive.readFully(localExtraData);\nze.setExtra(localExtraData);\noffsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n+ SHORT + SHORT + fileNameLen + extraFieldLen;\n\nif (entriesWithoutUTF8Flag.containsKey(ze)) {\nString orig = ze.getName();\nNameAndComment nc = entriesWithoutUTF8Flag.get(ze);\nZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\nnc.comment);\nif (!orig.equals(ze.getName())) {\nnameMap.remove(orig);\nnameMap.put(ze.getName(), ze);\n}\n}\nentries.put(ze, offsetEntry);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$OffsetEntry:access$002(Lorg/apache/commons/compress/archivers/zip/ZipFile$OffsetEntry;J)J",
                                    "method_body": "private static final int HASH_SIZE = 509;\nstatic final int NIBLET_MASK = 0x0f;\nstatic final int BYTE_SHIFT = 8;\nprivate static final int POS_0 = 0;\nprivate static final int POS_1 = 1;\nprivate static final int POS_2 = 2;\nprivate static final int POS_3 = 3;\n\n/**\n* Maps ZipArchiveEntrys to two longs, recording the offsets of\n* the local file headers and the start of entry data.\n*/\nprivate final Map<ZipArchiveEntry, OffsetEntry> entries =\nnew LinkedHashMap<ZipArchiveEntry, OffsetEntry>(HASH_SIZE);\n\n/**\n* Maps String to ZipArchiveEntrys, name -> actual entry.\n*/\nprivate final Map<String, ZipArchiveEntry> nameMap =\nnew HashMap<String, ZipArchiveEntry>(HASH_SIZE);\n\nprivate static final class OffsetEntry {\nprivate long headerOffset = -1;\nprivate long dataOffset = -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$NameAndComment:<init>([B[B)V",
                                    "method_body": "private NameAndComment(byte[] name, byte[] comment) {\nthis.name = name;\nthis.comment = comment;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 14,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest.workaroundForBrokenTimeHeader",
                            "test_body": "51: public void workaroundForBrokenTimeHeader() throws Exception {\n52: URL tar = getClass().getResource(\"/simple-aix-native-tar.tar\");\n53: TarArchiveInputStream in = null;\n54: try {\n55: in = new TarArchiveInputStream(new FileInputStream(new File(new URI(tar.toString()))));\n56: TarArchiveEntry tae = in.getNextTarEntry();\n57: tae = in.getNextTarEntry();\n58: assertEquals(\"sample/link-to-txt-file.lnk\", tae.getName());\n59: assertEquals(new Date(0), tae.getLastModifiedDate());\n60: assertTrue(tae.isSymbolicLink());\n61: } finally {\n62: if (in != null) {\n63: in.close();\n64: }\n65: }\n66: }        \n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry () {\nthis.magic = MAGIC_POSIX;\nthis.version = VERSION_POSIX;\nthis.name = \"\";\nthis.linkName = \"\";\n\nString user = System.getProperty(\"user.name\", \"\");\n\nif (user.length() > MAX_NAMELEN) {\nuser = user.substring(0, MAX_NAMELEN);\n}\n\nthis.userId = 0;\nthis.groupId = 0;\nthis.userName = user;\nthis.groupName = \"\";\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>([B)V",
                                    "method_body": "public TarArchiveEntry(byte[] headerBuf) {\nthis();\nparseTarHeader(headerBuf);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNUSparse()Z",
                                    "method_body": "public boolean isGNUSparse() {\nreturn linkFlag == LF_GNUTYPE_SPARSE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongNameEntry()Z",
                                    "method_body": "public boolean isGNULongNameEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGNAME\n&& name.toString().equals(GNU_LONGLINK);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isPaxHeader()Z",
                                    "method_body": "public boolean isPaxHeader(){\nreturn linkFlag == LF_PAX_EXTENDED_HEADER_LC\n|| linkFlag == LF_PAX_EXTENDED_HEADER_UC;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nif (file != null) {\nreturn file.isDirectory();\n}\n\nif (linkFlag == LF_DIR) {\nreturn true;\n}\n\nif (getName().endsWith(\"/\")) {\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([B)V",
                                    "method_body": "public void parseTarHeader(byte[] header) {\nint offset = 0;\n\nname = TarUtils.parseName(header, offset, NAMELEN);\noffset += NAMELEN;\nmode = (int) TarUtils.parseOctal(header, offset, MODELEN);\noffset += MODELEN;\nuserId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\noffset += UIDLEN;\ngroupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\noffset += GIDLEN;\nsize = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\noffset += SIZELEN;\nmodTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\noffset += MODTIMELEN;\noffset += CHKSUMLEN;\nlinkFlag = header[offset++];\nlinkName = TarUtils.parseName(header, offset, NAMELEN);\noffset += NAMELEN;\nmagic = TarUtils.parseName(header, offset, MAGICLEN);\noffset += MAGICLEN;\nversion = TarUtils.parseName(header, offset, VERSIONLEN);\noffset += VERSIONLEN;\nuserName = TarUtils.parseName(header, offset, UNAMELEN);\noffset += UNAMELEN;\ngroupName = TarUtils.parseName(header, offset, GNAMELEN);\noffset += GNAMELEN;\ndevMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\noffset += DEVLEN;\ndevMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\noffset += DEVLEN;\n\nint type = evaluateType(header);\nswitch (type) {\ncase FORMAT_OLDGNU: {\noffset += ATIMELEN_GNU;\noffset += CTIMELEN_GNU;\noffset += OFFSETLEN_GNU;\noffset += LONGNAMESLEN_GNU;\noffset += PAD2LEN_GNU;\noffset += SPARSELEN_GNU;\nisExtended = TarUtils.parseBoolean(header, offset);\noffset += ISEXTENDEDLEN_GNU;\nrealSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU);\noffset += REALSIZELEN_GNU;\nbreak;\n}\ncase FORMAT_POSIX:\ndefault: {\nString prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n// SunOS tar -E does not add / to directory names, so fix\n// up to be consistent\nif (isDirectory() && !name.endsWith(\"/\")){\nname = name + \"/\";\n}\nif (prefix.length() > 0){\nname = prefix + \"/\" + name;\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:evaluateType([B)I",
                                    "method_body": "private int evaluateType(byte[] header) {\nfinal ByteBuffer magic = ByteBuffer.wrap(header, MAGIC_OFFSET, MAGICLEN);\nif (magic.compareTo(ByteBuffer.wrap(MAGIC_GNU.getBytes())) == 0)\nreturn FORMAT_OLDGNU;\nif (magic.compareTo(ByteBuffer.wrap(MAGIC_POSIX.getBytes())) == 0)\nreturn FORMAT_POSIX;\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarBuffer(InputStream inStream, int blockSize, int recordSize) {\nthis(inStream, null, blockSize, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/InputStream;Ljava/io/OutputStream;II)V",
                                    "method_body": "private TarBuffer(InputStream inStream, OutputStream outStream, int blockSize, int recordSize) {\nthis.inStream = inStream;\nthis.outStream = outStream;\nthis.blockSize = blockSize;\nthis.recordSize = recordSize;\nthis.recsPerBlock = (this.blockSize / this.recordSize);\nthis.blockBuffer = new byte[this.blockSize];\n\nif (this.inStream != null) {\nthis.currBlkIdx = -1;\nthis.currRecIdx = this.recsPerBlock;\n} else {\nthis.currBlkIdx = 0;\nthis.currRecIdx = 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:getRecordSize()I",
                                    "method_body": "public int getRecordSize() {\nreturn this.recordSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:isEOFRecord([B)Z",
                                    "method_body": "public boolean isEOFRecord(byte[] record) {\nfor (int i = 0, sz = getRecordSize(); i < sz; ++i) {\nif (record[i] != 0) {\nreturn false;\n}\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:readRecord()[B",
                                    "method_body": "public byte[] readRecord() throws IOException {\nif (inStream == null) {\nif (outStream == null) {\nthrow new IOException(\"input buffer is closed\");\n}\nthrow new IOException(\"reading from an output buffer\");\n}\n\nif (currRecIdx >= recsPerBlock && !readBlock()) {\nreturn null;\n}\n\nbyte[] result = new byte[recordSize];\n\nSystem.arraycopy(blockBuffer,\n(currRecIdx * recordSize), result, 0,\nrecordSize);\n\ncurrRecIdx++;\n\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:readBlock()Z",
                                    "method_body": "private boolean readBlock() throws IOException {\nif (inStream == null) {\nthrow new IOException(\"reading from an output buffer\");\n}\n\ncurrRecIdx = 0;\n\nint offset = 0;\nint bytesNeeded = blockSize;\n\nwhile (bytesNeeded > 0) {\nlong numBytes = inStream.read(blockBuffer, offset,\nbytesNeeded);\n\n//\n// NOTE\n// We have fit EOF, and the block is not full!\n//\n// This is a broken archive. It does not follow the standard\n// blocking algorithm. However, because we are generous, and\n// it requires little effort, we will simply ignore the error\n// and continue as if the entire block were read. This does\n// not appear to break anything upstream. We used to return\n// false in this case.\n//\n// Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n//\nif (numBytes == -1) {\nif (offset == 0) {\n// Ensure that we do not read gigabytes of zeros\n// for a corrupt tar file.\n// See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\nreturn false;\n}\n// However, just leaving the unread portion of the buffer dirty does\n// cause problems in some cases.  This problem is described in\n// http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n//\n// The solution is to fill the unused portion of the buffer with zeros.\n\nArrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\nbreak;\n}\n\noffset += numBytes;\nbytesNeeded -= numBytes;\n\nif (numBytes != blockSize) {\n// TODO: Incomplete Read occured - throw exception?\n}\n}\n\ncurrBlkIdx++;\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:close()V",
                                    "method_body": "public void close() throws IOException {\nif (outStream != null) {\nflushBlock();\n\nif (outStream != System.out\n&& outStream != System.err) {\noutStream.close();\n\noutStream = null;\n}\n} else if (inStream != null) {\nif (inStream != System.in) {\ninStream.close();\n}\ninStream = null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\n\nif (length < 2){\nthrow new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n}\n\nboolean allNUL = true;\nfor (int i = start; i < end; i++){\nif (buffer[i] != 0){\nallNUL = false;\nbreak;\n}\n}\nif (allNUL) {\nreturn 0L;\n}\n\n// Skip leading spaces\nwhile (start < end){\nif (buffer[start] == ' '){\nstart++;\n} else {\nbreak;\n}\n}\n\n// Must have trailing NUL or space\nbyte trailer;\ntrailer = buffer[end-1];\nif (trailer == 0 || trailer == ' '){\nend--;\n} else {\nthrow new IllegalArgumentException(\nexceptionMessage(buffer, offset, length, end-1, trailer));\n}\n// May have additional NUL or space\ntrailer = buffer[end-1];\nif (trailer == 0 || trailer == ' '){\nend--;\n}\n\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\n// CheckStyle:MagicNumber OFF\nif (currentByte < '0' || currentByte > '7'){\nthrow new IllegalArgumentException(\nexceptionMessage(buffer, offset, length, start, currentByte));\n}\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\n// CheckStyle:MagicNumber ON\n}\n\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctalOrBinary([BII)J",
                                    "method_body": "public static long parseOctalOrBinary(final byte[] buffer, final int offset,\nfinal int length) {\n\nif ((buffer[offset] & 0x80) == 0) {\nreturn parseOctal(buffer, offset, length);\n}\n\nlong val = buffer[offset] & 0x7f;\nfor (int i = 1; i < length; i++) {\nif (val >= (1L << (63 - 8))) {\nthrow new IllegalArgumentException(\n\"At offset \" + offset + \", \" + length + \" byte \" +\n\"binary number exceeds maximum signed long value\");\n}\nval = (val << 8) + (buffer[offset + i] & 0xff);\n}\nreturn val;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:exceptionMessage([BIIIB)Ljava/lang/String;",
                                    "method_body": "private static String exceptionMessage(byte[] buffer, final int offset,\nfinal int length, int current, final byte currentByte) {\nString string = new String(buffer, offset, length);\nstring=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed\nfinal String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;\nreturn s;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BII)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset, final int length) {\nStringBuffer result = new StringBuffer(length);\nint          end = offset + length;\n\nfor (int i = offset; i < end; ++i) {\nbyte b = buffer[i];\nif (b == 0) { // Trailing null\nbreak;\n}\nresult.append((char) (b & 0xFF)); // Allow for sign-extension\n}\n\nreturn result.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is) {\nthis(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\nthis.buffer = new TarBuffer(is, blockSize, recordSize);\nthis.readBuf = null;\nthis.hasHitEOF = false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nbuffer.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextTarEntry()Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;",
                                    "method_body": "public TarArchiveEntry getNextTarEntry() throws IOException {\nif (hasHitEOF) {\nreturn null;\n}\n\nif (currEntry != null) {\nlong numToSkip = entrySize - entryOffset;\n\nwhile (numToSkip > 0) {\nlong skipped = skip(numToSkip);\nif (skipped <= 0) {\nthrow new RuntimeException(\"failed to skip current tar entry\");\n}\nnumToSkip -= skipped;\n}\n\nreadBuf = null;\n}\n\nbyte[] headerBuf = getRecord();\n\nif (hasHitEOF) {\ncurrEntry = null;\nreturn null;\n}\n\ntry {\ncurrEntry = new TarArchiveEntry(headerBuf);\n} catch (IllegalArgumentException e) {\nIOException ioe = new IOException(\"Error detected parsing the header\");\nioe.initCause(e);\nthrow ioe;\n}\nentryOffset = 0;\nentrySize = currEntry.getSize();\n\nif (currEntry.isGNULongNameEntry()) {\n// read in the name\nStringBuffer longName = new StringBuffer();\nbyte[] buf = new byte[SMALL_BUFFER_SIZE];\nint length = 0;\nwhile ((length = read(buf)) >= 0) {\nlongName.append(new String(buf, 0, length));\n}\ngetNextEntry();\nif (currEntry == null) {\n// Bugzilla: 40334\n// Malformed tar file - long entry name not followed by entry\nreturn null;\n}\n// remove trailing null terminator\nif (longName.length() > 0\n&& longName.charAt(longName.length() - 1) == 0) {\nlongName.deleteCharAt(longName.length() - 1);\n}\ncurrEntry.setName(longName.toString());\n}\n\nif (currEntry.isPaxHeader()){ // Process Pax headers\npaxHeaders();\n}\n\nif (currEntry.isGNUSparse()){ // Process sparse files\nreadGNUSparse();\n}\n\n// If the size of the next element in the archive has changed\n// due to a new size being reported in the posix header\n// information, we update entrySize here so that it contains\n// the correct value.\nentrySize = currEntry.getSize();\nreturn currEntry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getRecord()[B",
                                    "method_body": "private byte[] getRecord() throws IOException {\nif (hasHitEOF) {\nreturn null;\n}\n\nbyte[] headerBuf = buffer.readRecord();\n\nif (headerBuf == null) {\nhasHitEOF = true;\n} else if (buffer.isEOFRecord(headerBuf)) {\nhasHitEOF = true;\n}\n\nreturn hasHitEOF ? null : headerBuf;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 15,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveEntryTest.testNullCommentEqualsEmptyComment",
                            "test_body": "243: public void testNullCommentEqualsEmptyComment() {\n244: ZipArchiveEntry entry1 = new ZipArchiveEntry(\"foo\");\n245: ZipArchiveEntry entry2 = new ZipArchiveEntry(\"foo\");\n246: ZipArchiveEntry entry3 = new ZipArchiveEntry(\"foo\");\n247: entry1.setComment(null);\n248: entry2.setComment(\"\");\n249: entry3.setComment(\"bar\");\n250: assertEquals(entry1, entry2);\n251: assertFalse(entry1.equals(entry3));\n252: assertFalse(entry2.equals(entry3));\n253: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "protected void setName(String name) {\nif (name != null && getPlatform() == PLATFORM_FAT\n&& name.indexOf(\"/\") == -1) {\nname = name.replace('\\\\', '/');\n}\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object obj) {\nif (this == obj) {\nreturn true;\n}\nif (obj == null || getClass() != obj.getClass()) {\nreturn false;\n}\nZipArchiveEntry other = (ZipArchiveEntry) obj;\nString myName = getName();\nString otherName = other.getName();\nif (myName == null) {\nif (otherName != null) {\nreturn false;\n}\n} else if (!myName.equals(otherName)) {\nreturn false;\n}\nString myComment = getComment();\nString otherComment = other.getComment();\nif (myComment == null) {\nif (otherComment != null) {\nreturn false;\n}\n} else if (!myComment.equals(otherComment)) {\nreturn false;\n}\nreturn getTime() == other.getTime()\n&& getInternalAttributes() == other.getInternalAttributes()\n&& getPlatform() == other.getPlatform()\n&& getExternalAttributes() == other.getExternalAttributes()\n&& getMethod() == other.getMethod()\n&& getSize() == other.getSize()\n&& getCrc() == other.getCrc()\n&& getCompressedSize() == other.getCompressedSize()\n&& Arrays.equals(getCentralDirectoryExtra(),\nother.getCentralDirectoryExtra())\n&& Arrays.equals(getLocalFileDataExtra(),\nother.getLocalFileDataExtra())\n&& gpb.equals(other.gpb);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:<init>()V",
                                    "method_body": "public GeneralPurposeBit() {\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 16,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest.aiffFilesAreNoTARs",
                            "test_body": "51: public void aiffFilesAreNoTARs() throws Exception {\n52: InputStream is = null;\n53: try {\n54: is = new BufferedInputStream(new FileInputStream(\"src/test/resources/testAIFF.aif\"));\n55: new ArchiveStreamFactory().createArchiveInputStream(is);\n56: fail(\"created an input stream for a non-archive\");\n57: } catch (ArchiveException ae) {\n58: assertTrue(ae.getMessage().startsWith(\"No Archiver found\"));\n59: } finally {\n60: if (is != null) {\n61: is.close();\n62: }\n63: }\n64: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveInputStream(Ljava/io/InputStream;)Lorg/apache/commons/compress/archivers/ArchiveInputStream;",
                                    "method_body": "public ArchiveInputStream createArchiveInputStream(final InputStream in)\nthrows ArchiveException {\nif (in == null) {\nthrow new IllegalArgumentException(\"Stream must not be null.\");\n}\n\nif (!in.markSupported()) {\nthrow new IllegalArgumentException(\"Mark is not supported.\");\n}\n\nfinal byte[] signature = new byte[12];\nin.mark(signature.length);\ntry {\nint signatureLength = in.read(signature);\nin.reset();\nif (ZipArchiveInputStream.matches(signature, signatureLength)) {\nreturn new ZipArchiveInputStream(in);\n} else if (JarArchiveInputStream.matches(signature, signatureLength)) {\nreturn new JarArchiveInputStream(in);\n} else if (ArArchiveInputStream.matches(signature, signatureLength)) {\nreturn new ArArchiveInputStream(in);\n} else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\nreturn new CpioArchiveInputStream(in);\n}\n\n// Dump needs a bigger buffer to check the signature;\nfinal byte[] dumpsig = new byte[32];\nin.mark(dumpsig.length);\nsignatureLength = in.read(dumpsig);\nin.reset();\nif (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\nreturn new DumpArchiveInputStream(in);\n}\n\n// Tar needs an even bigger buffer to check the signature; read the first block\nfinal byte[] tarheader = new byte[512];\nin.mark(tarheader.length);\nsignatureLength = in.read(tarheader);\nin.reset();\nif (TarArchiveInputStream.matches(tarheader, signatureLength)) {\nreturn new TarArchiveInputStream(in);\n}\n// COMPRESS-117 - improve auto-recognition\nif (signatureLength >= 512) {\ntry {\nTarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n// COMPRESS-191 - verify the header checksum\ntais.getNextEntry();\nreturn new TarArchiveInputStream(in);\n} catch (Exception e) { // NOPMD\n// can generate IllegalArgumentException as well\n// as IOException\n// autodetection, simply not a TAR\n// ignored\n}\n}\n} catch (IOException e) {\nthrow new ArchiveException(\"Could not use reset and mark operations.\", e);\n}\n\nthrow new ArchiveException(\"No Archiver found for the stream signature\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:matchAsciiBuffer(Ljava/lang/String;[BII)Z",
                                    "method_body": "public static boolean matchAsciiBuffer(\nString expected, byte[] buffer, int offset, int length){\nbyte[] buffer1;\ntry {\nbuffer1 = expected.getBytes(\"ASCII\");\n} catch (UnsupportedEncodingException e) {\nthrow new RuntimeException(e); // Should not happen\n}\nreturn isEqual(buffer1, 0, buffer1.length, buffer, offset, length, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isEqual([BII[BIIZ)Z",
                                    "method_body": "public static boolean isEqual(\nfinal byte[] buffer1, final int offset1, final int length1,\nfinal byte[] buffer2, final int offset2, final int length2,\nboolean ignoreTrailingNulls){\nint minLen=length1 < length2 ? length1 : length2;\nfor (int i=0; i < minLen; i++){\nif (buffer1[offset1+i] != buffer2[offset2+i]){\nreturn false;\n}\n}\nif (length1 == length2){\nreturn true;\n}\nif (ignoreTrailingNulls){\nif (length1 > length2){\nfor(int i = length2; i < length1; i++){\nif (buffer1[offset1+i] != 0){\nreturn false;\n}\n}\n} else {\nfor(int i = length1; i < length2; i++){\nif (buffer2[offset2+i] != 0){\nreturn false;\n}\n}\n}\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "public static final int EFS_FLAG = GeneralPurposeBit.UFT8_NAMES_FLAG;\n\n/**\n* Current entry.\n*/\nprivate CurrentEntry entry;\n\n/**\n* The file comment.\n*/\nprivate String comment = \"\";\n\n/**\n* Compression level for next entry.\n*/\nprivate int level = DEFAULT_COMPRESSION;\n\n/**\n* Has the compression level changed when compared to the last\n* entry?\n*/\nprivate boolean hasCompressionLevelChanged = false;\n\n/**\n* Default compression method for next entry.\n*/\nprivate int method = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* List of ZipArchiveEntries written so far.\n*/\nprivate final List<ZipArchiveEntry> entries =\nnew LinkedList<ZipArchiveEntry>();\n\n/**\n* CRC instance to avoid parsing DEFLATED data twice.\n*/\nprivate final CRC32 crc = new CRC32();\n\n/**\n* Count the bytes written to out.\n*/\nprivate long written = 0;\n\n/**\n* Start of central directory.\n*/\nprivate long cdOffset = 0;\n\n/**\n* Length of central directory.\n*/\nprivate long cdLength = 0;\n\n/**\n* Helper, a 0 as ZipShort.\n*/\nprivate static final byte[] ZERO = {0, 0};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Data Descriptor signature\n* @since 1.1\n*/\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\n\n/**\n* Value stored in size and similar fields if ZIP64 extensions are\n* used.\n* @since 1.3\n*/\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n\nstatic {\nsimpleEncodings = new HashMap<String, SimpleEncodingHolder>();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for utf-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h = simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\n// check platform's default encoding\nencoding = System.getProperty(\"file.encoding\");\n}\nreturn UTF8.equalsIgnoreCase(encoding)\n|| UTF_DASH_8.equalsIgnoreCase(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data);\n} else {\nreturn new String(data,this.charset);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry() {\nthis.magic = MAGIC_POSIX;\nthis.version = VERSION_POSIX;\nthis.name = \"\";\nthis.linkName = \"\";\n\nString user = System.getProperty(\"user.name\", \"\");\n\nif (user.length() > MAX_NAMELEN) {\nuser = user.substring(0, MAX_NAMELEN);\n}\n\nthis.userId = 0;\nthis.groupId = 0;\nthis.userName = user;\nthis.groupName = \"\";\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public TarArchiveEntry(byte[] headerBuf, ZipEncoding encoding)\nthrows IOException {\nthis();\nparseTarHeader(headerBuf, encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNUSparse()Z",
                                    "method_body": "public boolean isGNUSparse() {\nreturn linkFlag == LF_GNUTYPE_SPARSE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongNameEntry()Z",
                                    "method_body": "public boolean isGNULongNameEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGNAME\n&& name.equals(GNU_LONGLINK);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isPaxHeader()Z",
                                    "method_body": "public boolean isPaxHeader(){\nreturn linkFlag == LF_PAX_EXTENDED_HEADER_LC\n|| linkFlag == LF_PAX_EXTENDED_HEADER_UC;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nif (file != null) {\nreturn file.isDirectory();\n}\n\nif (linkFlag == LF_DIR) {\nreturn true;\n}\n\nif (getName().endsWith(\"/\")) {\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public void parseTarHeader(byte[] header, ZipEncoding encoding)\nthrows IOException {\nparseTarHeader(header, encoding, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;Z)V",
                                    "method_body": "private void parseTarHeader(byte[] header, ZipEncoding encoding,\nfinal boolean oldStyle)\nthrows IOException {\nint offset = 0;\n\nname = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n: TarUtils.parseName(header, offset, NAMELEN, encoding);\noffset += NAMELEN;\nmode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN);\noffset += MODELEN;\nuserId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\noffset += UIDLEN;\ngroupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\noffset += GIDLEN;\nsize = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\noffset += SIZELEN;\nmodTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN);\noffset += MODTIMELEN;\ncheckSumOK = TarUtils.verifyCheckSum(header);\noffset += CHKSUMLEN;\nlinkFlag = header[offset++];\nlinkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n: TarUtils.parseName(header, offset, NAMELEN, encoding);\noffset += NAMELEN;\nmagic = TarUtils.parseName(header, offset, MAGICLEN);\noffset += MAGICLEN;\nversion = TarUtils.parseName(header, offset, VERSIONLEN);\noffset += VERSIONLEN;\nuserName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)\n: TarUtils.parseName(header, offset, UNAMELEN, encoding);\noffset += UNAMELEN;\ngroupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN)\n: TarUtils.parseName(header, offset, GNAMELEN, encoding);\noffset += GNAMELEN;\ndevMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\ndevMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\n\nint type = evaluateType(header);\nswitch (type) {\ncase FORMAT_OLDGNU: {\noffset += ATIMELEN_GNU;\noffset += CTIMELEN_GNU;\noffset += OFFSETLEN_GNU;\noffset += LONGNAMESLEN_GNU;\noffset += PAD2LEN_GNU;\noffset += SPARSELEN_GNU;\nisExtended = TarUtils.parseBoolean(header, offset);\noffset += ISEXTENDEDLEN_GNU;\nrealSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU);\noffset += REALSIZELEN_GNU;\nbreak;\n}\ncase FORMAT_POSIX:\ndefault: {\nString prefix = oldStyle\n? TarUtils.parseName(header, offset, PREFIXLEN)\n: TarUtils.parseName(header, offset, PREFIXLEN, encoding);\n// SunOS tar -E does not add / to directory names, so fix\n// up to be consistent\nif (isDirectory() && !name.endsWith(\"/\")){\nname = name + \"/\";\n}\nif (prefix.length() > 0){\nname = prefix + \"/\" + name;\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:evaluateType([B)I",
                                    "method_body": "private int evaluateType(byte[] header) {\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_GNU, header, MAGIC_OFFSET, MAGICLEN)) {\nreturn FORMAT_OLDGNU;\n}\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_POSIX, header, MAGIC_OFFSET, MAGICLEN)) {\nreturn FORMAT_POSIX;\n}\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarBuffer(InputStream inStream, int blockSize, int recordSize) {\nthis(inStream, null, blockSize, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/InputStream;Ljava/io/OutputStream;II)V",
                                    "method_body": "private TarBuffer(InputStream inStream, OutputStream outStream, int blockSize, int recordSize) {\nthis.inStream = inStream;\nthis.outStream = outStream;\nthis.blockSize = blockSize;\nthis.recordSize = recordSize;\nthis.recsPerBlock = (this.blockSize / this.recordSize);\nthis.blockBuffer = new byte[this.blockSize];\n\nif (this.inStream != null) {\nthis.currBlkIdx = -1;\nthis.currRecIdx = this.recsPerBlock;\n} else {\nthis.currBlkIdx = 0;\nthis.currRecIdx = 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:getRecordSize()I",
                                    "method_body": "public int getRecordSize() {\nreturn this.recordSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:isEOFRecord([B)Z",
                                    "method_body": "public boolean isEOFRecord(byte[] record) {\nfor (int i = 0, sz = getRecordSize(); i < sz; ++i) {\nif (record[i] != 0) {\nreturn false;\n}\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:readRecord()[B",
                                    "method_body": "public byte[] readRecord() throws IOException {\nif (inStream == null) {\nif (outStream == null) {\nthrow new IOException(\"input buffer is closed\");\n}\nthrow new IOException(\"reading from an output buffer\");\n}\n\nif (currRecIdx >= recsPerBlock && !readBlock()) {\nreturn null;\n}\n\nbyte[] result = new byte[recordSize];\n\nSystem.arraycopy(blockBuffer,\n(currRecIdx * recordSize), result, 0,\nrecordSize);\n\ncurrRecIdx++;\n\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:readBlock()Z",
                                    "method_body": "private boolean readBlock() throws IOException {\nif (inStream == null) {\nthrow new IOException(\"reading from an output buffer\");\n}\n\ncurrRecIdx = 0;\n\nint offset = 0;\nint bytesNeeded = blockSize;\n\nwhile (bytesNeeded > 0) {\nlong numBytes = inStream.read(blockBuffer, offset,\nbytesNeeded);\n\n//\n// NOTE\n// We have fit EOF, and the block is not full!\n//\n// This is a broken archive. It does not follow the standard\n// blocking algorithm. However, because we are generous, and\n// it requires little effort, we will simply ignore the error\n// and continue as if the entire block were read. This does\n// not appear to break anything upstream. We used to return\n// false in this case.\n//\n// Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n//\nif (numBytes == -1) {\nif (offset == 0) {\n// Ensure that we do not read gigabytes of zeros\n// for a corrupt tar file.\n// See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\nreturn false;\n}\n// However, just leaving the unread portion of the buffer dirty does\n// cause problems in some cases.  This problem is described in\n// http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n//\n// The solution is to fill the unused portion of the buffer with zeros.\n\nArrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\nbreak;\n}\n\noffset += numBytes;\nbytesNeeded -= numBytes;\n\nif (numBytes != blockSize) {\n// TODO: Incomplete Read occured - throw exception?\n}\n}\n\ncurrBlkIdx++;\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:<clinit>()V",
                                    "method_body": "private static final int BYTE_MASK = 255;\n\nstatic final ZipEncoding DEFAULT_ENCODING =\nZipEncodingHelper.getZipEncoding(null);\n\n/**\n* Encapsulates the algorithms used up to Commons Compress 1.3 as\n* ZipEncoding.\n*/\nstatic final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\npublic boolean canEncode(String name) { return true; }\n\npublic ByteBuffer encode(String name) {\nfinal int length = name.length();\nbyte[] buf = new byte[length];\n\n// copy until end of input or output is reached.\nfor (int i = 0; i < length; ++i) {\nbuf[i] = (byte) name.charAt(i);\n}\nreturn ByteBuffer.wrap(buf);\n}\n\npublic String decode(byte[] buffer) {\nfinal int length = buffer.length;\nStringBuffer result = new StringBuffer(length);\n\nfor (int i = 0; i < length; ++i) {\nbyte b = buffer[i];\nif (b == 0) { // Trailing null\nbreak;\n}\nresult.append((char) (b & 0xFF)); // Allow for sign-extension\n}\n\nreturn result.toString();\n}\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\n\nif (length < 2){\nthrow new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n}\n\nif (buffer[start] == 0) {\nreturn 0L;\n}\n\n// Skip leading spaces\nwhile (start < end){\nif (buffer[start] == ' '){\nstart++;\n} else {\nbreak;\n}\n}\n\n// Must have trailing NUL or space\nbyte trailer;\ntrailer = buffer[end-1];\nif (trailer == 0 || trailer == ' '){\nend--;\n} else {\nthrow new IllegalArgumentException(\nexceptionMessage(buffer, offset, length, end-1, trailer));\n}\n// May have additional NUL or space\ntrailer = buffer[end-1];\nif (trailer == 0 || trailer == ' '){\nend--;\n}\n\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\n// CheckStyle:MagicNumber OFF\nif (currentByte < '0' || currentByte > '7'){\nthrow new IllegalArgumentException(\nexceptionMessage(buffer, offset, length, start, currentByte));\n}\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\n// CheckStyle:MagicNumber ON\n}\n\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctalOrBinary([BII)J",
                                    "method_body": "public static long parseOctalOrBinary(final byte[] buffer, final int offset,\nfinal int length) {\n\nif ((buffer[offset] & 0x80) == 0) {\nreturn parseOctal(buffer, offset, length);\n}\nfinal boolean negative = buffer[offset] == (byte) 0xff;\nif (length < 9) {\nreturn parseBinaryLong(buffer, offset, length, negative);\n}\nreturn parseBinaryBigInteger(buffer, offset, length, negative);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseBinaryLong([BIIZ)J",
                                    "method_body": "private static long parseBinaryLong(final byte[] buffer, final int offset,\nfinal int length,\nfinal boolean negative) {\nif (length >= 9) {\nthrow new IllegalArgumentException(\"At offset \" + offset + \", \"\n+ length + \" byte binary number\"\n+ \" exceeds maximum signed long\"\n+ \" value\");\n}\nlong val = 0;\nfor (int i = 1; i < length; i++) {\nval = (val << 8) + (buffer[offset + i] & 0xff);\n}\nif (negative) {\n// 2's complement\nval--;\nval ^= ((long) Math.pow(2, (length - 1) * 8) - 1);\n}\nreturn negative ? -val : val;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BII)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset, final int length) {\ntry {\nreturn parseName(buffer, offset, length, DEFAULT_ENCODING);\n} catch (IOException ex) {\ntry {\nreturn parseName(buffer, offset, length, FALLBACK_ENCODING);\n} catch (IOException ex2) {\n// impossible\nthrow new RuntimeException(ex2);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BIILorg/apache/commons/compress/archivers/zip/ZipEncoding;)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset,\nfinal int length,\nfinal ZipEncoding encoding)\nthrows IOException {\n\nint len = length;\nfor (; len > 0; len--) {\nif (buffer[offset + len - 1] != 0) {\nbreak;\n}\n}\nif (len > 0) {\nbyte[] b = new byte[len];\nSystem.arraycopy(buffer, offset, b, 0, len);\nreturn encoding.decode(b);\n}\nreturn \"\";\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:verifyCheckSum([B)Z",
                                    "method_body": "public static boolean verifyCheckSum(byte[] header) {\nlong storedSum = 0;\nlong unsignedSum = 0;\nlong signedSum = 0;\n\nint digits = 0;\nfor (int i = 0; i < header.length; i++) {\nbyte b = header[i];\nif (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\nif ('0' <= b && b <= '7' && digits++ < 6) {\nstoredSum = storedSum * 8 + b - '0';\n} else if (digits > 0) {\ndigits = 6; // only look at the first octal digit sequence\n}\nb = ' ';\n}\nunsignedSum += 0xff & b;\nsignedSum += b;\n}\n\nreturn storedSum == unsignedSum || storedSum == signedSum\n|| storedSum > unsignedSum; // COMPRESS-177\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:<clinit>()V",
                                    "method_body": "static final String BSD_LONGNAME_PREFIX = \"#1/\";\nprivate static final int BSD_LONGNAME_PREFIX_LEN =\nBSD_LONGNAME_PREFIX.length();\nprivate static final String BSD_LONGNAME_PATTERN =\n\"^\" + BSD_LONGNAME_PREFIX + \"\\\\d+\";\n\n/**\n* Does the name look like it is a long name (or a name containing\n* spaces) as encoded by BSD ar?\n*\n* <p>From the FreeBSD ar(5) man page:</p>\n* <pre>\n* BSD   In the BSD variant, names that are shorter than 16\n*       characters and without embedded spaces are stored\n*       directly in this field.  If a name has an embedded\n*       space, or if it is longer than 16 characters, then\n*       the string \"#1/\" followed by the decimal represen-\n*       tation of the length of the file name is placed in\n*       this field. The actual file name is stored immedi-\n*       ately after the archive header.  The content of the\n*       archive member follows the file name.  The ar_size\n*       field of the header (see below) will then hold the\n*       sum of the size of the file name and the size of\n*       the member.\n* </pre>\n*\n* @since 1.3\n*/\nprivate static boolean isBSDLongName(String name) {\nreturn name != null && name.matches(BSD_LONGNAME_PATTERN);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\n// 3c21 7261 6863 0a3e\n\nif (length < 8) {\nreturn false;\n}\nif (signature[0] != 0x21) {\nreturn false;\n}\nif (signature[1] != 0x3c) {\nreturn false;\n}\nif (signature[2] != 0x61) {\nreturn false;\n}\nif (signature[3] != 0x72) {\nreturn false;\n}\nif (signature[4] != 0x63) {\nreturn false;\n}\nif (signature[5] != 0x68) {\nreturn false;\n}\nif (signature[6] != 0x3e) {\nreturn false;\n}\nif (signature[7] != 0x0a) {\nreturn false;\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < 6) {\nreturn false;\n}\n\n// Check binary values\nif (signature[0] == 0x71 && (signature[1] & 0xFF) == 0xc7) {\nreturn true;\n}\nif (signature[1] == 0x71 && (signature[0] & 0xFF) == 0xc7) {\nreturn true;\n}\n\n// Check Ascii (String) values\n// 3037 3037 30nn\nif (signature[0] != 0x30) {\nreturn false;\n}\nif (signature[1] != 0x37) {\nreturn false;\n}\nif (signature[2] != 0x30) {\nreturn false;\n}\nif (signature[3] != 0x37) {\nreturn false;\n}\nif (signature[4] != 0x30) {\nreturn false;\n}\n// Check last byte\nif (signature[5] == 0x31) {\nreturn true;\n}\nif (signature[5] == 0x32) {\nreturn true;\n}\nif (signature[5] == 0x37) {\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<clinit>()V",
                                    "method_body": "private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\nprivate static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\nprivate static final byte[] DD = ZipLong.DD_SIG.getBytes();\n\n/**\n* Checks whether the current buffer contains the signature of a\n* &quot;data decsriptor&quot;, &quot;local file header&quot; or\n* &quot;central directory entry&quot;.\n*\n* <p>If it contains such a signature, reads the data descriptor\n* and positions the stream right after the data descriptor.</p>\n*/\nprivate boolean bufferContainsSignature(ByteArrayOutputStream bos,\nint offset, int lastRead,\nint expectedDDLen)\nthrows IOException {\nboolean done = false;\nint readTooMuch = 0;\nfor (int i = 0; !done && i < lastRead - 4; i++) {\nif (buf.buf[i] == LFH[0] && buf.buf[i + 1] == LFH[1]) {\nif ((buf.buf[i + 2] == LFH[2] && buf.buf[i + 3] == LFH[3])\n|| (buf.buf[i] == CFH[2] && buf.buf[i + 3] == CFH[3])) {\n// found a LFH or CFH:\nreadTooMuch = offset + lastRead - i - expectedDDLen;\ndone = true;\n}\nelse if (buf.buf[i + 2] == DD[2] && buf.buf[i + 3] == DD[3]) {\n// found DD:\nreadTooMuch = offset + lastRead - i;\ndone = true;\n}\nif (done) {\n// * push back bytes read in excess as well as the data\n//   descriptor\n// * copy the remaining bytes to cache\n// * read data descriptor\npushback(buf.buf, offset + lastRead - readTooMuch,\nreadTooMuch);\nbos.write(buf.buf, 0, i);\nreadDataDescriptor();\n}\n}\n}\nreturn done;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < ZipArchiveOutputStream.LFH_SIG.length) {\nreturn false;\n}\n\nreturn checksig(signature, ZipArchiveOutputStream.LFH_SIG) // normal file\n|| checksig(signature, ZipArchiveOutputStream.EOCD_SIG); // empty zip\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:checksig([B[B)Z",
                                    "method_body": "private static boolean checksig(byte[] signature, byte[] expected){\nfor (int i = 0; i < expected.length; i++) {\nif (signature[i] != expected[i]) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length ) {\nreturn ZipArchiveInputStream.matches(signature, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is) {\nthis(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\nthis(is, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;IILjava/lang/String;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize,\nString encoding) {\nthis.buffer = new TarBuffer(is, blockSize, recordSize);\nthis.readBuf = null;\nthis.hasHitEOF = false;\nthis.encoding = ZipEncodingHelper.getZipEncoding(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextTarEntry()Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;",
                                    "method_body": "public TarArchiveEntry getNextTarEntry() throws IOException {\nif (hasHitEOF) {\nreturn null;\n}\n\nif (currEntry != null) {\nlong numToSkip = entrySize - entryOffset;\n\nwhile (numToSkip > 0) {\nlong skipped = skip(numToSkip);\nif (skipped <= 0) {\nthrow new RuntimeException(\"failed to skip current tar\"\n+ \" entry\");\n}\nnumToSkip -= skipped;\n}\n\nreadBuf = null;\n}\n\nbyte[] headerBuf = getRecord();\n\nif (hasHitEOF) {\ncurrEntry = null;\nreturn null;\n}\n\ntry {\ncurrEntry = new TarArchiveEntry(headerBuf, encoding);\n} catch (IllegalArgumentException e) {\nIOException ioe = new IOException(\"Error detected parsing the header\");\nioe.initCause(e);\nthrow ioe;\n}\nentryOffset = 0;\nentrySize = currEntry.getSize();\n\nif (currEntry.isGNULongNameEntry()) {\n// read in the name\nStringBuffer longName = new StringBuffer();\nbyte[] buf = new byte[SMALL_BUFFER_SIZE];\nint length = 0;\nwhile ((length = read(buf)) >= 0) {\nlongName.append(new String(buf, 0, length)); // TODO default charset?\n}\ngetNextEntry();\nif (currEntry == null) {\n// Bugzilla: 40334\n// Malformed tar file - long entry name not followed by entry\nreturn null;\n}\n// remove trailing null terminator\nif (longName.length() > 0\n&& longName.charAt(longName.length() - 1) == 0) {\nlongName.deleteCharAt(longName.length() - 1);\n}\ncurrEntry.setName(longName.toString());\n}\n\nif (currEntry.isPaxHeader()){ // Process Pax headers\npaxHeaders();\n}\n\nif (currEntry.isGNUSparse()){ // Process sparse files\nreadGNUSparse();\n}\n\n// If the size of the next element in the archive has changed\n// due to a new size being reported in the posix header\n// information, we update entrySize here so that it contains\n// the correct value.\nentrySize = currEntry.getSize();\nreturn currEntry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getRecord()[B",
                                    "method_body": "private byte[] getRecord() throws IOException {\nif (hasHitEOF) {\nreturn null;\n}\n\nbyte[] headerBuf = buffer.readRecord();\n\nif (headerBuf == null) {\nhasHitEOF = true;\n} else if (buffer.isEOFRecord(headerBuf)) {\nhasHitEOF = true;\n}\n\nreturn hasHitEOF ? null : headerBuf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextEntry()Lorg/apache/commons/compress/archivers/ArchiveEntry;",
                                    "method_body": "public ArchiveEntry getNextEntry() throws IOException {\nreturn getNextTarEntry();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < TarConstants.VERSION_OFFSET+TarConstants.VERSIONLEN) {\nreturn false;\n}\n\nif (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_POSIX,\nsignature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n&&\nArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_POSIX,\nsignature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n){\nreturn true;\n}\nif (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_GNU,\nsignature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n&&\n(\nArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_SPACE,\nsignature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n||\nArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_ZERO,\nsignature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n)\n){\nreturn true;\n}\n// COMPRESS-107 - recognise Ant tar files\nif (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_ANT,\nsignature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n&&\nArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_ANT,\nsignature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n){\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] buffer, int length) {\n// do we have enough of the header?\nif (length < 32) {\nreturn false;\n}\n\n// this is the best test\nif (length >= DumpArchiveConstants.TP_SIZE) {\nreturn DumpArchiveUtil.verify(buffer);\n}\n\n// this will work in a pinch.\nreturn DumpArchiveConstants.NFS_MAGIC == DumpArchiveUtil.convert32(buffer,\n24);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert32([BI)I",
                                    "method_body": "public static final int convert32(byte[] buffer, int offset) {\nint i = 0;\ni = buffer[offset + 3] << 24;\ni += (buffer[offset + 2] << 16) & 0x00FF0000;\ni += (buffer[offset + 1] << 8) & 0x0000FF00;\ni += buffer[offset] & 0x000000FF;\n\nreturn i;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 17,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest.testCompress197",
                            "test_body": "126: public void testCompress197() throws Exception {\n127: TarArchiveInputStream tar = getTestStream(\"/COMPRESS-197.tar\");\n128: try {\n129: TarArchiveEntry entry = tar.getNextTarEntry();\n130: while (entry != null) {\n131: entry = tar.getNextTarEntry();\n132: }\n133: } catch (IOException e) {\n134: fail(\"COMPRESS-197: \" + e.getMessage());\n135: } finally {\n136: tar.close();\n137: }\n138: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n\nstatic {\nsimpleEncodings = new HashMap<String, SimpleEncodingHolder>();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nsimpleEncodings.put(\"CP437\",cp437);\nsimpleEncodings.put(\"Cp437\",cp437);\nsimpleEncodings.put(\"cp437\",cp437);\nsimpleEncodings.put(\"IBM437\",cp437);\nsimpleEncodings.put(\"ibm437\",cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nsimpleEncodings.put(\"CP850\",cp850);\nsimpleEncodings.put(\"Cp850\",cp850);\nsimpleEncodings.put(\"cp850\",cp850);\nsimpleEncodings.put(\"IBM850\",cp850);\nsimpleEncodings.put(\"ibm850\",cp850);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for utf-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h = simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\n// check platform's default encoding\nencoding = System.getProperty(\"file.encoding\");\n}\nreturn UTF8.equalsIgnoreCase(encoding)\n|| UTF_DASH_8.equalsIgnoreCase(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data);\n} else {\nreturn new String(data,this.charset);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry() {\nthis.magic = MAGIC_POSIX;\nthis.version = VERSION_POSIX;\nthis.name = \"\";\nthis.linkName = \"\";\n\nString user = System.getProperty(\"user.name\", \"\");\n\nif (user.length() > MAX_NAMELEN) {\nuser = user.substring(0, MAX_NAMELEN);\n}\n\nthis.userId = 0;\nthis.groupId = 0;\nthis.userName = user;\nthis.groupName = \"\";\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public TarArchiveEntry(byte[] headerBuf, ZipEncoding encoding)\nthrows IOException {\nthis();\nparseTarHeader(headerBuf, encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public void parseTarHeader(byte[] header, ZipEncoding encoding)\nthrows IOException {\nparseTarHeader(header, encoding, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;Z)V",
                                    "method_body": "private void parseTarHeader(byte[] header, ZipEncoding encoding,\nfinal boolean oldStyle)\nthrows IOException {\nint offset = 0;\n\nname = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n: TarUtils.parseName(header, offset, NAMELEN, encoding);\noffset += NAMELEN;\nmode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN);\noffset += MODELEN;\nuserId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\noffset += UIDLEN;\ngroupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\noffset += GIDLEN;\nsize = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\noffset += SIZELEN;\nmodTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN);\noffset += MODTIMELEN;\ncheckSumOK = TarUtils.verifyCheckSum(header);\noffset += CHKSUMLEN;\nlinkFlag = header[offset++];\nlinkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n: TarUtils.parseName(header, offset, NAMELEN, encoding);\noffset += NAMELEN;\nmagic = TarUtils.parseName(header, offset, MAGICLEN);\noffset += MAGICLEN;\nversion = TarUtils.parseName(header, offset, VERSIONLEN);\noffset += VERSIONLEN;\nuserName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)\n: TarUtils.parseName(header, offset, UNAMELEN, encoding);\noffset += UNAMELEN;\ngroupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN)\n: TarUtils.parseName(header, offset, GNAMELEN, encoding);\noffset += GNAMELEN;\ndevMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\ndevMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\n\nint type = evaluateType(header);\nswitch (type) {\ncase FORMAT_OLDGNU: {\noffset += ATIMELEN_GNU;\noffset += CTIMELEN_GNU;\noffset += OFFSETLEN_GNU;\noffset += LONGNAMESLEN_GNU;\noffset += PAD2LEN_GNU;\noffset += SPARSELEN_GNU;\nisExtended = TarUtils.parseBoolean(header, offset);\noffset += ISEXTENDEDLEN_GNU;\nrealSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU);\noffset += REALSIZELEN_GNU;\nbreak;\n}\ncase FORMAT_POSIX:\ndefault: {\nString prefix = oldStyle\n? TarUtils.parseName(header, offset, PREFIXLEN)\n: TarUtils.parseName(header, offset, PREFIXLEN, encoding);\n// SunOS tar -E does not add / to directory names, so fix\n// up to be consistent\nif (isDirectory() && !name.endsWith(\"/\")){\nname = name + \"/\";\n}\nif (prefix.length() > 0){\nname = prefix + \"/\" + name;\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarBuffer(InputStream inStream, int blockSize, int recordSize) {\nthis(inStream, null, blockSize, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/InputStream;Ljava/io/OutputStream;II)V",
                                    "method_body": "private TarBuffer(InputStream inStream, OutputStream outStream, int blockSize, int recordSize) {\nthis.inStream = inStream;\nthis.outStream = outStream;\nthis.blockSize = blockSize;\nthis.recordSize = recordSize;\nthis.recsPerBlock = (this.blockSize / this.recordSize);\nthis.blockBuffer = new byte[this.blockSize];\n\nif (this.inStream != null) {\nthis.currBlkIdx = -1;\nthis.currRecIdx = this.recsPerBlock;\n} else {\nthis.currBlkIdx = 0;\nthis.currRecIdx = 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:getRecordSize()I",
                                    "method_body": "public int getRecordSize() {\nreturn this.recordSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:isEOFRecord([B)Z",
                                    "method_body": "public boolean isEOFRecord(byte[] record) {\nfor (int i = 0, sz = getRecordSize(); i < sz; ++i) {\nif (record[i] != 0) {\nreturn false;\n}\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:readRecord()[B",
                                    "method_body": "public byte[] readRecord() throws IOException {\nif (inStream == null) {\nif (outStream == null) {\nthrow new IOException(\"input buffer is closed\");\n}\nthrow new IOException(\"reading from an output buffer\");\n}\n\nif (currRecIdx >= recsPerBlock && !readBlock()) {\nreturn null;\n}\n\nbyte[] result = new byte[recordSize];\n\nSystem.arraycopy(blockBuffer,\n(currRecIdx * recordSize), result, 0,\nrecordSize);\n\ncurrRecIdx++;\n\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:readBlock()Z",
                                    "method_body": "private boolean readBlock() throws IOException {\nif (inStream == null) {\nthrow new IOException(\"reading from an output buffer\");\n}\n\ncurrRecIdx = 0;\n\nint offset = 0;\nint bytesNeeded = blockSize;\n\nwhile (bytesNeeded > 0) {\nlong numBytes = inStream.read(blockBuffer, offset,\nbytesNeeded);\n\n//\n// NOTE\n// We have fit EOF, and the block is not full!\n//\n// This is a broken archive. It does not follow the standard\n// blocking algorithm. However, because we are generous, and\n// it requires little effort, we will simply ignore the error\n// and continue as if the entire block were read. This does\n// not appear to break anything upstream. We used to return\n// false in this case.\n//\n// Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n//\nif (numBytes == -1) {\nif (offset == 0) {\n// Ensure that we do not read gigabytes of zeros\n// for a corrupt tar file.\n// See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\nreturn false;\n}\n// However, just leaving the unread portion of the buffer dirty does\n// cause problems in some cases.  This problem is described in\n// http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n//\n// The solution is to fill the unused portion of the buffer with zeros.\n\nArrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\nbreak;\n}\n\noffset += numBytes;\nbytesNeeded -= numBytes;\n\nif (numBytes != blockSize) {\n// TODO: Incomplete Read occured - throw exception?\n}\n}\n\ncurrBlkIdx++;\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:close()V",
                                    "method_body": "public void close() throws IOException {\nif (outStream != null) {\nflushBlock();\n\nif (outStream != System.out\n&& outStream != System.err) {\noutStream.close();\n\noutStream = null;\n}\n} else if (inStream != null) {\nif (inStream != System.in) {\ninStream.close();\n}\ninStream = null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:<clinit>()V",
                                    "method_body": "private static final int BYTE_MASK = 255;\n\nstatic final ZipEncoding DEFAULT_ENCODING =\nZipEncodingHelper.getZipEncoding(null);\n\n/**\n* Encapsulates the algorithms used up to Commons Compress 1.3 as\n* ZipEncoding.\n*/\nstatic final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\npublic boolean canEncode(String name) { return true; }\n\npublic ByteBuffer encode(String name) {\nfinal int length = name.length();\nbyte[] buf = new byte[length];\n\n// copy until end of input or output is reached.\nfor (int i = 0; i < length; ++i) {\nbuf[i] = (byte) name.charAt(i);\n}\nreturn ByteBuffer.wrap(buf);\n}\n\npublic String decode(byte[] buffer) {\nfinal int length = buffer.length;\nStringBuffer result = new StringBuffer(length);\n\nfor (int i = 0; i < length; ++i) {\nbyte b = buffer[i];\nif (b == 0) { // Trailing null\nbreak;\n}\nresult.append((char) (b & 0xFF)); // Allow for sign-extension\n}\n\nreturn result.toString();\n}\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\n\nif (length < 2){\nthrow new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n}\n\nif (buffer[start] == 0) {\nreturn 0L;\n}\n\n// Skip leading spaces\nwhile (start < end){\nif (buffer[start] == ' '){\nstart++;\n} else {\nbreak;\n}\n}\n\n// Must have trailing NUL or space\nbyte trailer;\ntrailer = buffer[end-1];\nif (trailer == 0 || trailer == ' '){\nend--;\n} else {\nthrow new IllegalArgumentException(\nexceptionMessage(buffer, offset, length, end-1, trailer));\n}\n// May have additional NULs or spaces\ntrailer = buffer[end - 1];\nif (trailer == 0 || trailer == ' '){\nend--;\n}\n\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\n// CheckStyle:MagicNumber OFF\nif (currentByte < '0' || currentByte > '7'){\nthrow new IllegalArgumentException(\nexceptionMessage(buffer, offset, length, start, currentByte));\n}\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\n// CheckStyle:MagicNumber ON\n}\n\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctalOrBinary([BII)J",
                                    "method_body": "public static long parseOctalOrBinary(final byte[] buffer, final int offset,\nfinal int length) {\n\nif ((buffer[offset] & 0x80) == 0) {\nreturn parseOctal(buffer, offset, length);\n}\nfinal boolean negative = buffer[offset] == (byte) 0xff;\nif (length < 9) {\nreturn parseBinaryLong(buffer, offset, length, negative);\n}\nreturn parseBinaryBigInteger(buffer, offset, length, negative);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:exceptionMessage([BIIIB)Ljava/lang/String;",
                                    "method_body": "private static String exceptionMessage(byte[] buffer, final int offset,\nfinal int length, int current, final byte currentByte) {\nString string = new String(buffer, offset, length); // TODO default charset?\nstring=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed\nfinal String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;\nreturn s;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BIILorg/apache/commons/compress/archivers/zip/ZipEncoding;)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset,\nfinal int length,\nfinal ZipEncoding encoding)\nthrows IOException {\n\nint len = length;\nfor (; len > 0; len--) {\nif (buffer[offset + len - 1] != 0) {\nbreak;\n}\n}\nif (len > 0) {\nbyte[] b = new byte[len];\nSystem.arraycopy(buffer, offset, b, 0, len);\nreturn encoding.decode(b);\n}\nreturn \"\";\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is) {\nthis(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\nthis(is, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;IILjava/lang/String;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize,\nString encoding) {\nthis.buffer = new TarBuffer(is, blockSize, recordSize);\nthis.readBuf = null;\nthis.hasHitEOF = false;\nthis.encoding = ZipEncodingHelper.getZipEncoding(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nbuffer.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextTarEntry()Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;",
                                    "method_body": "public TarArchiveEntry getNextTarEntry() throws IOException {\nif (hasHitEOF) {\nreturn null;\n}\n\nif (currEntry != null) {\nlong numToSkip = entrySize - entryOffset;\n\nwhile (numToSkip > 0) {\nlong skipped = skip(numToSkip);\nif (skipped <= 0) {\nthrow new RuntimeException(\"failed to skip current tar\"\n+ \" entry\");\n}\nnumToSkip -= skipped;\n}\n\nreadBuf = null;\n}\n\nbyte[] headerBuf = getRecord();\n\nif (hasHitEOF) {\ncurrEntry = null;\nreturn null;\n}\n\ntry {\ncurrEntry = new TarArchiveEntry(headerBuf, encoding);\n} catch (IllegalArgumentException e) {\nIOException ioe = new IOException(\"Error detected parsing the header\");\nioe.initCause(e);\nthrow ioe;\n}\nentryOffset = 0;\nentrySize = currEntry.getSize();\n\nif (currEntry.isGNULongNameEntry()) {\n// read in the name\nStringBuffer longName = new StringBuffer();\nbyte[] buf = new byte[SMALL_BUFFER_SIZE];\nint length = 0;\nwhile ((length = read(buf)) >= 0) {\nlongName.append(new String(buf, 0, length)); // TODO default charset?\n}\ngetNextEntry();\nif (currEntry == null) {\n// Bugzilla: 40334\n// Malformed tar file - long entry name not followed by entry\nreturn null;\n}\n// remove trailing null terminator\nif (longName.length() > 0\n&& longName.charAt(longName.length() - 1) == 0) {\nlongName.deleteCharAt(longName.length() - 1);\n}\ncurrEntry.setName(longName.toString());\n}\n\nif (currEntry.isPaxHeader()){ // Process Pax headers\npaxHeaders();\n}\n\nif (currEntry.isGNUSparse()){ // Process sparse files\nreadGNUSparse();\n}\n\n// If the size of the next element in the archive has changed\n// due to a new size being reported in the posix header\n// information, we update entrySize here so that it contains\n// the correct value.\nentrySize = currEntry.getSize();\nreturn currEntry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getRecord()[B",
                                    "method_body": "private byte[] getRecord() throws IOException {\nif (hasHitEOF) {\nreturn null;\n}\n\nbyte[] headerBuf = buffer.readRecord();\n\nif (headerBuf == null) {\nhasHitEOF = true;\n} else if (buffer.isEOFRecord(headerBuf)) {\nhasHitEOF = true;\n}\n\nreturn hasHitEOF ? null : headerBuf;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 18,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest.testWriteNonAsciiDirectoryNamePosixMode",
                            "test_body": "412: public void testWriteNonAsciiDirectoryNamePosixMode() throws Exception {\n413: String n = \"f\\u00f6\\u00f6/\";\n414: TarArchiveEntry t = new TarArchiveEntry(n);\n415: ByteArrayOutputStream bos = new ByteArrayOutputStream();\n416: TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n417: tos.setAddPaxHeadersForNonAsciiNames(true);\n418: tos.putArchiveEntry(t);\n419: tos.closeArchiveEntry();\n420: tos.close();\n421: byte[] data = bos.toByteArray();\n422: TarArchiveInputStream tin =\n423: new TarArchiveInputStream(new ByteArrayInputStream(data));\n424: TarArchiveEntry e = tin.getNextTarEntry();\n425: assertEquals(n, e.getName());\n426: assertTrue(e.isDirectory());\n427: tin.close();\n428: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n\nstatic {\nMap<String, SimpleEncodingHolder> se =\nnew HashMap<String, SimpleEncodingHolder>();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for utf-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h = simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\n// check platform's default encoding\nencoding = System.getProperty(\"file.encoding\");\n}\nreturn UTF8.equalsIgnoreCase(encoding)\n|| UTF_DASH_8.equalsIgnoreCase(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(String name) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn ByteBuffer.wrap(name.getBytes());\n} else {\nreturn ByteBuffer.wrap(name.getBytes(this.charset));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry() {\nthis.magic = MAGIC_POSIX;\nthis.version = VERSION_POSIX;\nthis.name = \"\";\nthis.linkName = \"\";\n\nString user = System.getProperty(\"user.name\", \"\");\n\nif (user.length() > MAX_NAMELEN) {\nuser = user.substring(0, MAX_NAMELEN);\n}\n\nthis.userId = 0;\nthis.groupId = 0;\nthis.userName = user;\nthis.groupName = \"\";\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public TarArchiveEntry(String name) {\nthis(name, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/lang/String;Z)V",
                                    "method_body": "public TarArchiveEntry(String name, boolean preserveLeadingSlashes) {\nthis();\n\nname = normalizeFileName(name, preserveLeadingSlashes);\nboolean isDir = name.endsWith(\"/\");\n\nthis.devMajor = 0;\nthis.devMinor = 0;\nthis.name = name;\nthis.mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE;\nthis.linkFlag = isDir ? LF_DIR : LF_NORMAL;\nthis.userId = 0;\nthis.groupId = 0;\nthis.size = 0;\nthis.modTime = (new Date()).getTime() / MILLIS_PER_SECOND;\nthis.linkName = \"\";\nthis.userName = \"\";\nthis.groupName = \"\";\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/lang/String;B)V",
                                    "method_body": "public TarArchiveEntry(String name, byte linkFlag) {\nthis(name);\nthis.linkFlag = linkFlag;\nif (linkFlag == LF_GNUTYPE_LONGNAME) {\nmagic = MAGIC_GNU;\nversion = VERSION_GNU_SPACE;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getUserId()I",
                                    "method_body": "public int getUserId() {\nreturn userId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getGroupId()I",
                                    "method_body": "public int getGroupId() {\nreturn groupId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getModTime()Ljava/util/Date;",
                                    "method_body": "public Date getModTime() {\nreturn new Date(modTime * MILLIS_PER_SECOND);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getMode()I",
                                    "method_body": "public int getMode() {\nreturn mode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nif (size < 0){\nthrow new IllegalArgumentException(\"Size is out of range: \"+size);\n}\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getDevMajor()I",
                                    "method_body": "public int getDevMajor() {\nreturn devMajor;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getDevMinor()I",
                                    "method_body": "public int getDevMinor() {\nreturn devMinor;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nif (file != null) {\nreturn file.isDirectory();\n}\n\nif (linkFlag == LF_DIR) {\nreturn true;\n}\n\nif (getName().endsWith(\"/\")) {\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isSymbolicLink()Z",
                                    "method_body": "public boolean isSymbolicLink() {\nreturn linkFlag == LF_SYMLINK;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isLink()Z",
                                    "method_body": "public boolean isLink() {\nreturn linkFlag == LF_LINK;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:writeEntryHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;Z)V",
                                    "method_body": "public void writeEntryHeader(byte[] outbuf, ZipEncoding encoding,\nboolean starMode) throws IOException {\nint offset = 0;\n\noffset = TarUtils.formatNameBytes(name, outbuf, offset, NAMELEN,\nencoding);\noffset = writeEntryHeaderField(mode, outbuf, offset, MODELEN, starMode);\noffset = writeEntryHeaderField(userId, outbuf, offset, UIDLEN,\nstarMode);\noffset = writeEntryHeaderField(groupId, outbuf, offset, GIDLEN,\nstarMode);\noffset = writeEntryHeaderField(size, outbuf, offset, SIZELEN, starMode);\noffset = writeEntryHeaderField(modTime, outbuf, offset, MODTIMELEN,\nstarMode);\n\nint csOffset = offset;\n\nfor (int c = 0; c < CHKSUMLEN; ++c) {\noutbuf[offset++] = (byte) ' ';\n}\n\noutbuf[offset++] = linkFlag;\noffset = TarUtils.formatNameBytes(linkName, outbuf, offset, NAMELEN,\nencoding);\noffset = TarUtils.formatNameBytes(magic, outbuf, offset, MAGICLEN);\noffset = TarUtils.formatNameBytes(version, outbuf, offset, VERSIONLEN);\noffset = TarUtils.formatNameBytes(userName, outbuf, offset, UNAMELEN,\nencoding);\noffset = TarUtils.formatNameBytes(groupName, outbuf, offset, GNAMELEN,\nencoding);\noffset = writeEntryHeaderField(devMajor, outbuf, offset, DEVLEN,\nstarMode);\noffset = writeEntryHeaderField(devMinor, outbuf, offset, DEVLEN,\nstarMode);\n\nwhile (offset < outbuf.length) {\noutbuf[offset++] = 0;\n}\n\nlong chk = TarUtils.computeCheckSum(outbuf);\n\nTarUtils.formatCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:writeEntryHeaderField(J[BIIZ)I",
                                    "method_body": "private int writeEntryHeaderField(long value, byte[] outbuf, int offset,\nint length, boolean starMode) {\nif (!starMode && (value < 0\n|| value >= (1l << (3 * (length - 1))))) {\n// value doesn't fit into field when written as octal\n// number, will be written to PAX header or causes an\n// error\nreturn TarUtils.formatLongOctalBytes(0, outbuf, offset, length);\n}\nreturn TarUtils.formatLongOctalOrBinaryBytes(value, outbuf, offset,\nlength);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:normalizeFileName(Ljava/lang/String;Z)Ljava/lang/String;",
                                    "method_body": "private static String normalizeFileName(String fileName,\nboolean preserveLeadingSlashes) {\nString osname = System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH);\n\nif (osname != null) {\n\n// Strip off drive letters!\n// REVIEW Would a better check be \"(File.separator == '\\')\"?\n\nif (osname.startsWith(\"windows\")) {\nif (fileName.length() > 2) {\nchar ch1 = fileName.charAt(0);\nchar ch2 = fileName.charAt(1);\n\nif (ch2 == ':'\n&& ((ch1 >= 'a' && ch1 <= 'z')\n|| (ch1 >= 'A' && ch1 <= 'Z'))) {\nfileName = fileName.substring(2);\n}\n}\n} else if (osname.indexOf(\"netware\") > -1) {\nint colon = fileName.indexOf(':');\nif (colon != -1) {\nfileName = fileName.substring(colon + 1);\n}\n}\n}\n\nfileName = fileName.replace(File.separatorChar, '/');\n\n// No absolute pathnames\n// Windows (and Posix?) paths can start with \"\\\\NetworkDrive\\\",\n// so we loop on starting /'s.\nwhile (!preserveLeadingSlashes && fileName.startsWith(\"/\")) {\nfileName = fileName.substring(1);\n}\nreturn fileName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public TarArchiveOutputStream(OutputStream os) {\nthis(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;II)V",
                                    "method_body": "public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) {\nthis(os, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;IILjava/lang/String;)V",
                                    "method_body": "public TarArchiveOutputStream(OutputStream os, int blockSize,\nint recordSize, String encoding) {\nout = new CountingOutputStream(os);\nthis.encoding = ZipEncodingHelper.getZipEncoding(encoding);\n\nthis.buffer = new TarBuffer(out, blockSize, recordSize);\nthis.assemLen = 0;\nthis.assemBuf = new byte[recordSize];\nthis.recordBuf = new byte[recordSize];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<clinit>()V",
                                    "method_body": "public static final int LONGFILE_ERROR = 0;\n\n/** Long paths will be truncated in the archive. */\npublic static final int LONGFILE_TRUNCATE = 1;\n\n/** GNU tar extensions are used to store long file names in the archive. */\npublic static final int LONGFILE_GNU = 2;\n\n/** POSIX/PAX extensions are used to store long file names in the archive. */\npublic static final int LONGFILE_POSIX = 3;\n\n/** Fail if a big number (e.g. size &gt; 8GiB) is required in the archive. */\npublic static final int BIGNUMBER_ERROR = 0;\n\n/** star/GNU tar/BSD tar extensions are used to store big number in the archive. */\npublic static final int BIGNUMBER_STAR = 1;\n\n/** POSIX/PAX extensions are used to store big numbers in the archive. */\npublic static final int BIGNUMBER_POSIX = 2;\n\nprivate long      currSize;\nprivate String    currName;\nprivate long      currBytes;\nprivate final byte[]    recordBuf;\nprivate int       assemLen;\nprivate final byte[]    assemBuf;\nprotected final TarBuffer buffer;\nprivate int       longFileMode = LONGFILE_ERROR;\nprivate int       bigNumberMode = BIGNUMBER_ERROR;\n\nprivate boolean closed = false;\n\n/** Indicates if putArchiveEntry has been called without closeArchiveEntry */\nprivate boolean haveUnclosedEntry = false;\n\n/** indicates if this archive is finished */\nprivate boolean finished = false;\n\nprivate final OutputStream out;\n\nprivate final ZipEncoding encoding;\n\nprivate boolean addPaxHeadersForNonAsciiNames = false;\nprivate static final ZipEncoding ASCII =\nZipEncodingHelper.getZipEncoding(\"ASCII\");\n\n/**\n* Constructor for TarInputStream.\n* @param os the output stream to use\n*/\npublic TarArchiveOutputStream(OutputStream os) {\nthis(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:setAddPaxHeadersForNonAsciiNames(Z)V",
                                    "method_body": "public void setAddPaxHeadersForNonAsciiNames(boolean b) {\naddPaxHeadersForNonAsciiNames = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\nif(finished) {\nthrow new IOException(\"Stream has already been finished\");\n}\nTarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\nMap<String, String> paxHeaders = new HashMap<String, String>();\nfinal String entryName = entry.getName();\nfinal ByteBuffer encodedName = encoding.encode(entryName);\nfinal int nameLen = encodedName.limit() - encodedName.position();\nboolean paxHeaderContainsPath = false;\nif (nameLen >= TarConstants.NAMELEN) {\n\nif (longFileMode == LONGFILE_POSIX) {\npaxHeaders.put(\"path\", entryName);\npaxHeaderContainsPath = true;\n} else if (longFileMode == LONGFILE_GNU) {\n// create a TarEntry for the LongLink, the contents\n// of which are the entry's name\nTarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\nTarConstants.LF_GNUTYPE_LONGNAME);\n\nlongLinkEntry.setSize(nameLen + 1); // +1 for NUL\nputArchiveEntry(longLinkEntry);\nwrite(encodedName.array(), encodedName.arrayOffset(), nameLen);\nwrite(0); // NUL terminator\ncloseArchiveEntry();\n} else if (longFileMode != LONGFILE_TRUNCATE) {\nthrow new RuntimeException(\"file name '\" + entryName\n+ \"' is too long ( > \"\n+ TarConstants.NAMELEN + \" bytes)\");\n}\n}\n\nif (bigNumberMode == BIGNUMBER_POSIX) {\naddPaxHeadersForBigNumbers(paxHeaders, entry);\n} else if (bigNumberMode != BIGNUMBER_STAR) {\nfailForBigNumbers(entry);\n}\n\nif (addPaxHeadersForNonAsciiNames && !paxHeaderContainsPath\n&& !ASCII.canEncode(entryName)) {\npaxHeaders.put(\"path\", entryName);\n}\n\nif (addPaxHeadersForNonAsciiNames\n&& (entry.isLink() || entry.isSymbolicLink())\n&& !ASCII.canEncode(entry.getLinkName())) {\npaxHeaders.put(\"linkpath\", entry.getLinkName());\n}\n\nif (paxHeaders.size() > 0) {\nwritePaxHeaders(entryName, paxHeaders);\n}\n\nentry.writeEntryHeader(recordBuf, encoding,\nbigNumberMode == BIGNUMBER_STAR);\nbuffer.writeRecord(recordBuf);\n\ncurrBytes = 0;\n\nif (entry.isDirectory()) {\ncurrSize = 0;\n} else {\ncurrSize = entry.getSize();\n}\ncurrName = entryName;\nhaveUnclosedEntry = true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\nif ((currBytes + numToWrite) > currSize) {\nthrow new IOException(\"request to write '\" + numToWrite\n+ \"' bytes exceeds size in header of '\"\n+ currSize + \"' bytes for entry '\"\n+ currName + \"'\");\n\n//\n// We have to deal with assembly!!!\n// The programmer can be writing little 32 byte chunks for all\n// we know, and we must assemble complete records for writing.\n// REVIEW Maybe this should be in TarBuffer? Could that help to\n// eliminate some of the buffer copying.\n//\n}\n\nif (assemLen > 0) {\nif ((assemLen + numToWrite) >= recordBuf.length) {\nint aLen = recordBuf.length - assemLen;\n\nSystem.arraycopy(assemBuf, 0, recordBuf, 0,\nassemLen);\nSystem.arraycopy(wBuf, wOffset, recordBuf,\nassemLen, aLen);\nbuffer.writeRecord(recordBuf);\n\ncurrBytes += recordBuf.length;\nwOffset += aLen;\nnumToWrite -= aLen;\nassemLen = 0;\n} else {\nSystem.arraycopy(wBuf, wOffset, assemBuf, assemLen,\nnumToWrite);\n\nwOffset += numToWrite;\nassemLen += numToWrite;\nnumToWrite = 0;\n}\n}\n\n//\n// When we get here we have EITHER:\n// o An empty \"assemble\" buffer.\n// o No bytes to write (numToWrite == 0)\n//\nwhile (numToWrite > 0) {\nif (numToWrite < recordBuf.length) {\nSystem.arraycopy(wBuf, wOffset, assemBuf, assemLen,\nnumToWrite);\n\nassemLen += numToWrite;\n\nbreak;\n}\n\nbuffer.writeRecord(wBuf, wOffset);\n\nint num = recordBuf.length;\n\ncurrBytes += num;\nnumToWrite -= num;\nwOffset += num;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:writePaxHeaders(Ljava/lang/String;Ljava/util/Map;)V",
                                    "method_body": "void writePaxHeaders(String entryName,\nMap<String, String> headers) throws IOException {\nString name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n// TarEntry's constructor would think this is a directory\n// and not allow any data to be written\nif (name.length() >= TarConstants.NAMELEN) {\nname = name.substring(0, TarConstants.NAMELEN - 1);\n}\nTarArchiveEntry pex = new TarArchiveEntry(name,\nTarConstants.LF_PAX_EXTENDED_HEADER_LC);\n\nStringWriter w = new StringWriter();\nfor (Map.Entry<String, String> h : headers.entrySet()) {\nString key = h.getKey();\nString value = h.getValue();\nint len = key.length() + value.length()\n+ 3 /* blank, equals and newline */\n+ 2 /* guess 9 < actual length < 100 */;\nString line = len + \" \" + key + \"=\" + value + \"\\n\";\nint actualLength = line.getBytes(CharsetNames.UTF_8).length;\nwhile (len != actualLength) {\n// Adjust for cases where length < 10 or > 100\n// or where UTF-8 encoding isn't a single octet\n// per character.\n// Must be in loop as size may go from 99 to 100 in\n// first pass so we'd need a second.\nlen = actualLength;\nline = len + \" \" + key + \"=\" + value + \"\\n\";\nactualLength = line.getBytes(CharsetNames.UTF_8).length;\n}\nw.write(line);\n}\nbyte[] data = w.toString().getBytes(CharsetNames.UTF_8);\npex.setSize(data.length);\nputArchiveEntry(pex);\nwrite(data);\ncloseArchiveEntry();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:stripTo7Bits(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private String stripTo7Bits(String name) {\nfinal int length = name.length();\nStringBuffer result = new StringBuffer(length);\nfor (int i = 0; i < length; i++) {\nchar stripped = (char) (name.charAt(i) & 0x7F);\nif (stripped != 0) { // would be read as Trailing null\nresult.append(stripped);\n}\n}\nreturn result.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:failForBigNumbers(Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;)V",
                                    "method_body": "private void failForBigNumbers(TarArchiveEntry entry) {\nfailForBigNumber(\"entry size\", entry.getSize(), TarConstants.MAXSIZE);\nfailForBigNumber(\"group id\", entry.getGroupId(), TarConstants.MAXID);\nfailForBigNumber(\"last modification time\",\nentry.getModTime().getTime() / 1000,\nTarConstants.MAXSIZE);\nfailForBigNumber(\"user id\", entry.getUserId(), TarConstants.MAXID);\nfailForBigNumber(\"mode\", entry.getMode(), TarConstants.MAXID);\nfailForBigNumber(\"major device number\", entry.getDevMajor(),\nTarConstants.MAXID);\nfailForBigNumber(\"minor device number\", entry.getDevMinor(),\nTarConstants.MAXID);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:failForBigNumber(Ljava/lang/String;JJ)V",
                                    "method_body": "private void failForBigNumber(String field, long value, long maxValue) {\nif (value < 0 || value > maxValue) {\nthrow new RuntimeException(field + \" '\" + value\n+ \"' is too big ( > \"\n+ maxValue + \" )\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:<init>(Ljava/nio/charset/Charset;)V",
                                    "method_body": "public NioZipEncoding(Charset charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:canEncode(Ljava/lang/String;)Z",
                                    "method_body": "public boolean canEncode(String name) {\nCharsetEncoder enc = this.charset.newEncoder();\nenc.onMalformedInput(CodingErrorAction.REPORT);\nenc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\nreturn enc.canEncode(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public CountingOutputStream(final OutputStream out) {\nsuper(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/OutputStream;II)V",
                                    "method_body": "public TarBuffer(OutputStream outStream, int blockSize, int recordSize) {\nthis(null, outStream, blockSize, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/InputStream;Ljava/io/OutputStream;II)V",
                                    "method_body": "private TarBuffer(InputStream inStream, OutputStream outStream, int blockSize, int recordSize) {\nthis.inStream = inStream;\nthis.outStream = outStream;\nthis.blockSize = blockSize;\nthis.recordSize = recordSize;\nthis.recsPerBlock = (this.blockSize / this.recordSize);\nthis.blockBuffer = new byte[this.blockSize];\n\nif (this.inStream != null) {\nthis.currBlkIdx = -1;\nthis.currRecIdx = this.recsPerBlock;\n} else {\nthis.currBlkIdx = 0;\nthis.currRecIdx = 0;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:writeRecord([B)V",
                                    "method_body": "public void writeRecord(byte[] record) throws IOException {\nif (outStream == null) {\nif (inStream == null){\nthrow new IOException(\"Output buffer is closed\");\n}\nthrow new IOException(\"writing to an input buffer\");\n}\n\nif (record.length != recordSize) {\nthrow new IOException(\"record to write has length '\"\n+ record.length\n+ \"' which is not the record size of '\"\n+ recordSize + \"'\");\n}\n\nif (currRecIdx >= recsPerBlock) {\nwriteBlock();\n}\n\nSystem.arraycopy(record, 0, blockBuffer,\n(currRecIdx * recordSize),\nrecordSize);\n\ncurrRecIdx++;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:<clinit>()V",
                                    "method_body": "private static final int BYTE_MASK = 255;\n\nstatic final ZipEncoding DEFAULT_ENCODING =\nZipEncodingHelper.getZipEncoding(null);\n\n/**\n* Encapsulates the algorithms used up to Commons Compress 1.3 as\n* ZipEncoding.\n*/\nstatic final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\npublic boolean canEncode(String name) { return true; }\n\npublic ByteBuffer encode(String name) {\nfinal int length = name.length();\nbyte[] buf = new byte[length];\n\n// copy until end of input or output is reached.\nfor (int i = 0; i < length; ++i) {\nbuf[i] = (byte) name.charAt(i);\n}\nreturn ByteBuffer.wrap(buf);\n}\n\npublic String decode(byte[] buffer) {\nfinal int length = buffer.length;\nStringBuffer result = new StringBuffer(length);\n\nfor (int i = 0; i < length; ++i) {\nbyte b = buffer[i];\nif (b == 0) { // Trailing null\nbreak;\n}\nresult.append((char) (b & 0xFF)); // Allow for sign-extension\n}\n\nreturn result.toString();\n}\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatNameBytes(Ljava/lang/String;[BII)I",
                                    "method_body": "public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {\ntry {\nreturn formatNameBytes(name, buf, offset, length, DEFAULT_ENCODING);\n} catch (IOException ex) {\ntry {\nreturn formatNameBytes(name, buf, offset, length,\nFALLBACK_ENCODING);\n} catch (IOException ex2) {\n// impossible\nthrow new RuntimeException(ex2);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatNameBytes(Ljava/lang/String;[BIILorg/apache/commons/compress/archivers/zip/ZipEncoding;)I",
                                    "method_body": "public static int formatNameBytes(String name, byte[] buf, final int offset,\nfinal int length,\nfinal ZipEncoding encoding)\nthrows IOException {\nint len = name.length();\nByteBuffer b = encoding.encode(name);\nwhile (b.limit() > length && len > 0) {\nb = encoding.encode(name.substring(0, --len));\n}\nfinal int limit = b.limit() - b.position();\nSystem.arraycopy(b.array(), b.arrayOffset(), buf, offset, limit);\n\n// Pad any remaining output bytes with NUL\nfor (int i = limit; i < length; ++i) {\nbuf[offset + i] = 0;\n}\n\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatUnsignedOctalString(J[BII)V",
                                    "method_body": "public static void formatUnsignedOctalString(final long value, byte[] buffer,\nfinal int offset, final int length) {\nint remaining = length;\nremaining--;\nif (value == 0) {\nbuffer[offset + remaining--] = (byte) '0';\n} else {\nlong val = value;\nfor (; remaining >= 0 && val != 0; --remaining) {\n// CheckStyle:MagicNumber OFF\nbuffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));\nval = val >>> 3;\n// CheckStyle:MagicNumber ON\n}\nif (val != 0){\nthrow new IllegalArgumentException\n(value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length);\n}\n}\n\nfor (; remaining >= 0; --remaining) { // leading zeros\nbuffer[offset + remaining] = (byte) '0';\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatLongOctalBytes(J[BII)I",
                                    "method_body": "public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\nint idx=length-1; // For space\n\nformatUnsignedOctalString(value, buf, offset, idx);\nbuf[offset + idx] = (byte) ' '; // Trailing space\n\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatLongOctalOrBinaryBytes(J[BII)I",
                                    "method_body": "public static int formatLongOctalOrBinaryBytes(\nfinal long value, byte[] buf, final int offset, final int length) {\n\n// Check whether we are dealing with UID/GID or SIZE field\nfinal long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\nfinal boolean negative = value < 0;\nif (!negative && value <= maxAsOctalChar) { // OK to store as octal chars\nreturn formatLongOctalBytes(value, buf, offset, length);\n}\n\nif (length < 9) {\nformatLongBinary(value, buf, offset, length, negative);\n}\nformatBigIntegerBinary(value, buf, offset, length, negative);\n\nbuf[offset] = (byte) (negative ? 0xff : 0x80);\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatCheckSumOctalBytes(J[BII)I",
                                    "method_body": "public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\nint idx=length-2; // for NUL and space\nformatUnsignedOctalString(value, buf, offset, idx);\n\nbuf[offset + idx++]   = 0; // Trailing null\nbuf[offset + idx]     = (byte) ' '; // Trailing space\n\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:computeCheckSum([B)J",
                                    "method_body": "public static long computeCheckSum(final byte[] buf) {\nlong sum = 0;\n\nfor (int i = 0; i < buf.length; ++i) {\nsum += BYTE_MASK & buf[i];\n}\n\nreturn sum;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 19,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.ZipFileTest.testExcessDataInZip64ExtraField",
                            "test_body": "232: public void testExcessDataInZip64ExtraField() throws Exception {\n233: File archive = getFile(\"COMPRESS-228.zip\");\n234: zf = new ZipFile(archive);\n235: // actually, if we get here, the test already has passed\n236: 237: ZipArchiveEntry ze = zf.getEntry(\"src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\");\n238: assertEquals(26101, ze.getSize());\n239: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "protected ZipArchiveEntry() {\nthis(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<clinit>()V",
                                    "method_body": "public static final int PLATFORM_UNIX = 3;\npublic static final int PLATFORM_FAT  = 0;\nprivate static final int SHORT_MASK = 0xFFFF;\nprivate static final int SHORT_SHIFT = 16;\nprivate static final byte[] EMPTY = new byte[0];\n\n/**\n* The {@link java.util.zip.ZipEntry} base class only supports"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setMethod(I)V",
                                    "method_body": "public void setMethod(int method) {\nif (method < 0) {\nthrow new IllegalArgumentException(\n\"ZIP compression method can not be negative: \" + method);\n}\nthis.method = method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setInternalAttributes(I)V",
                                    "method_body": "public void setInternalAttributes(int value) {\ninternalAttributes = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExternalAttributes(J)V",
                                    "method_body": "public void setExternalAttributes(long value) {\nexternalAttributes = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setPlatform(I)V",
                                    "method_body": "protected void setPlatform(int platform) {\nthis.platform = platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void setExtraFields(ZipExtraField[] fields) {\nextraFields = new LinkedHashMap<ZipShort, ZipExtraField>();\nfor (ZipExtraField field : fields) {\nif (field instanceof UnparseableExtraFieldData) {\nunparseableExtra = (UnparseableExtraFieldData) field;\n} else {\nextraFields.put(field.getHeaderId(), field);\n}\n}\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields(Z)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields(boolean includeUnparseable) {\nif (extraFields == null) {\nreturn !includeUnparseable || unparseableExtra == null\n? new ZipExtraField[0]\n: new ZipExtraField[] { unparseableExtra };\n}\nList<ZipExtraField> result =\nnew ArrayList<ZipExtraField>(extraFields.values());\nif (includeUnparseable && unparseableExtra != null) {\nresult.add(unparseableExtra);\n}\nreturn result.toArray(new ZipExtraField[0]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField getExtraField(ZipShort type) {\nif (extraFields != null) {\nreturn extraFields.get(type);\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields(true)));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setCentralDirectoryExtra([B)V",
                                    "method_body": "public void setCentralDirectoryExtra(byte[] b) {\ntry {\nZipExtraField[] central =\nExtraFieldUtils.parse(b, false,\nExtraFieldUtils.UnparseableExtraField.READ);\nmergeExtraFields(central, false);\n} catch (ZipException e) {\nthrow new RuntimeException(e.getMessage(), e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "protected void setName(String name) {\nif (name != null && getPlatform() == PLATFORM_FAT\n&& name.indexOf(\"/\") == -1) {\nname = name.replace('\\\\', '/');\n}\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nif (size < 0) {\nthrow new IllegalArgumentException(\"invalid entry size\");\n}\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;[B)V",
                                    "method_body": "protected void setName(String name, byte[] rawName) {\nsetName(name);\nthis.rawName = rawName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setGeneralPurposeBit(Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;)V",
                                    "method_body": "public void setGeneralPurposeBit(GeneralPurposeBit b) {\ngpb = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:mergeExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;Z)V",
                                    "method_body": "private void mergeExtraFields(ZipExtraField[] f, boolean local)\nthrows ZipException {\nif (extraFields == null) {\nsetExtraFields(f);\n} else {\nfor (ZipExtraField element : f) {\nZipExtraField existing;\nif (element instanceof UnparseableExtraFieldData) {\nexisting = unparseableExtra;\n} else {\nexisting = getExtraField(element.getHeaderId());\n}\nif (existing == null) {\naddExtraField(element);\n} else {\nif (local) {\nbyte[] b = element.getLocalFileDataData();\nexisting.parseFromLocalFileData(b, 0, b.length);\n} else {\nbyte[] b = element.getCentralDirectoryData();\nexisting.parseFromCentralDirectoryData(b, 0, b.length);\n}\n}\n}\nsetExtra();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:<init>()V",
                                    "method_body": "public GeneralPurposeBit() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesUTF8ForNames()Z",
                                    "method_body": "public boolean usesUTF8ForNames() {\nreturn languageEncodingFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useUTF8ForNames(Z)V",
                                    "method_body": "public void useUTF8ForNames(boolean b) {\nlanguageEncodingFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useDataDescriptor(Z)V",
                                    "method_body": "public void useDataDescriptor(boolean b) {\ndataDescriptorFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useEncryption(Z)V",
                                    "method_body": "public void useEncryption(boolean b) {\nencryptionFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useStrongEncryption(Z)V",
                                    "method_body": "public void useStrongEncryption(boolean b) {\nstrongEncryptionFlag = b;\nif (b) {\nuseEncryption(true);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:parse([BI)Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "public static GeneralPurposeBit parse(final byte[] data, final int offset) {\nfinal int generalPurposeFlag = ZipShort.getValue(data, offset);\nGeneralPurposeBit b = new GeneralPurposeBit();\nb.useDataDescriptor((generalPurposeFlag & DATA_DESCRIPTOR_FLAG) != 0);\nb.useUTF8ForNames((generalPurposeFlag & UFT8_NAMES_FLAG) != 0);\nb.useStrongEncryption((generalPurposeFlag & STRONG_ENCRYPTION_FLAG)\n!= 0);\nb.useEncryption((generalPurposeFlag & ENCRYPTION_FLAG) != 0);\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "public static final int EFS_FLAG = GeneralPurposeBit.UFT8_NAMES_FLAG;\n\nprivate static final byte[] EMPTY = new byte[0];\n\n/**\n* Current entry.\n*/\nprivate CurrentEntry entry;\n\n/**\n* The file comment.\n*/\nprivate String comment = \"\";\n\n/**\n* Compression level for next entry.\n*/\nprivate int level = DEFAULT_COMPRESSION;\n\n/**\n* Has the compression level changed when compared to the last\n* entry?\n*/\nprivate boolean hasCompressionLevelChanged = false;\n\n/**\n* Default compression method for next entry.\n*/\nprivate int method = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* List of ZipArchiveEntries written so far.\n*/\nprivate final List<ZipArchiveEntry> entries =\nnew LinkedList<ZipArchiveEntry>();\n\n/**\n* CRC instance to avoid parsing DEFLATED data twice.\n*/\nprivate final CRC32 crc = new CRC32();\n\n/**\n* Count the bytes written to out.\n*/\nprivate long written = 0;\n\n/**\n* Start of central directory.\n*/\nprivate long cdOffset = 0;\n\n/**\n* Length of central directory.\n*/\nprivate long cdLength = 0;\n\n/**\n* Helper, a 0 as ZipShort.\n*/\nprivate static final byte[] ZERO = {0, 0};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>([BI)V",
                                    "method_body": "public ZipLong (byte[] bytes, int offset) {\nvalue = ZipLong.getValue(bytes, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\n//private static final int BYTE_BIT_SIZE = 8;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Data Descriptor signature.\n*\n* <p>Actually, PKWARE uses this as marker for split/spanned\n* archives and other archivers have started to use it as Data\n* Descriptor signature (as well).</p>\n* @since 1.1\n*/\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\n\n/**\n* Value stored in size and similar fields if ZIP64 extensions are\n* used.\n* @since 1.3\n*/\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\n\n/**\n* Marks ZIP archives that were supposed to be split or spanned\n* but only needed a single segment in then end (so are actually\n* neither split nor spanned).\n*\n* <p>This is the \"PK00\" prefix found in some archives.</p>\n* @since 1.5\n*/\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\nnew ZipLong(0X30304B50L);\n\n/**\n* Archive extra data record signature.</p>\n* @since 1.5\n*/\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n\nstatic {\nMap<String, SimpleEncodingHolder> se =\nnew HashMap<String, SimpleEncodingHolder>();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for utf-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h = simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String encoding) {\nif (encoding == null) {\n// check platform's default encoding\nencoding = System.getProperty(\"file.encoding\");\n}\nreturn UTF8.equalsIgnoreCase(encoding)\n|| UTF_DASH_8.equalsIgnoreCase(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charset == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data);\n} else {\nreturn new String(data,this.charset);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\n\n/** No-arg constructor */\npublic JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>([BI)V",
                                    "method_body": "public ZipShort (byte[] bytes, int offset) {\nvalue = ZipShort.getValue(bytes, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([BI)I",
                                    "method_body": "public static int getValue(byte[] bytes, int offset) {\nint value = (bytes[offset + 1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object o) {\nif (o == null || !(o instanceof ZipShort)) {\nreturn false;\n}\nreturn value == ((ZipShort) o).getValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n\n/**\n* Static registry of known extra fields.\n*/\nprivate static final Map<ZipShort, Class<?>> implementations;\n\nstatic {\nimplementations = new ConcurrentHashMap<ZipShort, Class<?>>();\nregister(AsiExtraField.class);\nregister(X5455_ExtendedTimestamp.class);\nregister(X7875_NewUnix.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\nregister(Zip64ExtendedInformationExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class<?> c) {\ntry {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n} catch (ClassCastException cc) {\nthrow new RuntimeException(c + \" doesn\\'t implement ZipExtraField\");\n} catch (InstantiationException ie) {\nthrow new RuntimeException(c + \" is not a concrete class\");\n} catch (IllegalAccessException ie) {\nthrow new RuntimeException(c + \"\\'s no-arg constructor is not public\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:createExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField createExtraField(ZipShort headerId)\nthrows InstantiationException, IllegalAccessException {\nClass<?> c = implementations.get(headerId);\nif (c != null) {\nreturn (ZipExtraField) c.newInstance();\n}\nUnrecognizedExtraField u = new UnrecognizedExtraField();\nu.setHeaderId(headerId);\nreturn u;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:parse([BZLorg/apache/commons/compress/archivers/zip/ExtraFieldUtils$UnparseableExtraField;)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField[] parse(byte[] data, boolean local,\nUnparseableExtraField onUnparseableData)\nthrows ZipException {\nList<ZipExtraField> v = new ArrayList<ZipExtraField>();\nint start = 0;\nLOOP:\nwhile (start <= data.length - WORD) {\nZipShort headerId = new ZipShort(data, start);\nint length = (new ZipShort(data, start + 2)).getValue();\nif (start + WORD + length > data.length) {\nswitch(onUnparseableData.getKey()) {\ncase UnparseableExtraField.THROW_KEY:\nthrow new ZipException(\"bad extra field starting at \"\n+ start + \".  Block length of \"\n+ length + \" bytes exceeds remaining\"\n+ \" data of \"\n+ (data.length - start - WORD)\n+ \" bytes.\");\ncase UnparseableExtraField.READ_KEY:\nUnparseableExtraFieldData field =\nnew UnparseableExtraFieldData();\nif (local) {\nfield.parseFromLocalFileData(data, start,\ndata.length - start);\n} else {\nfield.parseFromCentralDirectoryData(data, start,\ndata.length - start);\n}\nv.add(field);\n//$FALL-THROUGH$\ncase UnparseableExtraField.SKIP_KEY:\n// since we cannot parse the data we must assume\n// the extra field consumes the whole rest of the\n// available data\nbreak LOOP;\ndefault:\nthrow new ZipException(\"unknown UnparseableExtraField key: \"\n+ onUnparseableData.getKey());\n}\n}\ntry {\nZipExtraField ze = createExtraField(headerId);\nif (local) {\nze.parseFromLocalFileData(data, start + WORD, length);\n} else {\nze.parseFromCentralDirectoryData(data, start + WORD,\nlength);\n}\nv.add(ze);\n} catch (InstantiationException ie) {\nthrow new ZipException(ie.getMessage());\n} catch (IllegalAccessException iae) {\nthrow new ZipException(iae.getMessage());\n}\nstart += (length + WORD);\n}\n\nZipExtraField[] result = new ZipExtraField[v.size()];\nreturn v.toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nfinal boolean lastIsUnparseableHolder = data.length > 0\n&& data[data.length - 1] instanceof UnparseableExtraFieldData;\nint regularExtraFieldCount =\nlastIsUnparseableHolder ? data.length - 1 : data.length;\n\nint sum = WORD * regularExtraFieldCount;\nfor (ZipExtraField element : data) {\nsum += element.getLocalFileDataLength().getValue();\n}\n\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n0, result, start + 2, 2);\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += (local.length + WORD);\n}\nif (lastIsUnparseableHolder) {\nbyte[] local = data[data.length - 1].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start, local.length);\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate static final int      WORD = 4;\n/**\n* Standard Unix stat(2) file mode.\n*/\nprivate int mode = 0;\n/**\n* User ID.\n*/\nprivate int uid = 0;\n/**\n* Group ID.\n*/\nprivate int gid = 0;\n/**\n* File this entry points to, if it is a symbolic link.\n*\n* <p>empty string - if entry is not a symbolic link.</p>\n*/\nprivate String link = \"\";\n/**\n* Is this an entry for a directory?\n*/\nprivate boolean dirFlag = false;\n\n/**\n* Instance used to calculate checksums.\n*/\nprivate CRC32 crc = new CRC32();\n\n/** Constructor for AsiExtraField. */\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<init>()V",
                                    "method_body": "public X5455_ExtendedTimestamp() {}\npublic X5455_ExtendedTimestamp() {}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x5455);\nprivate static final long serialVersionUID = 1L;\n\nstatic final byte MODIFY_TIME_BIT = 1;\nstatic final byte ACCESS_TIME_BIT = 2;\nstatic final byte CREATE_TIME_BIT = 4;\n\n// The 3 boolean fields (below) come from this flags byte.  The remaining 5 bits\n// are ignored according to the current version of the spec (December 2012).\nprivate byte flags;\n\n// Note: even if bit1 and bit2 are set, the Central data will still not contain\n// access/create fields:  only local data ever holds those!  This causes\n// some of our implementation to look a little odd, with seemingly spurious\n// != null and length checks.\nprivate boolean bit0_modifyTimePresent;\nprivate boolean bit1_accessTimePresent;\nprivate boolean bit2_createTimePresent;\n\nprivate ZipLong modifyTime;\nprivate ZipLong accessTime;\nprivate ZipLong createTime;\n\n/**\n* Constructor for X5455_ExtendedTimestamp.\n*/\npublic X5455_ExtendedTimestamp() {}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<init>()V",
                                    "method_body": "public X7875_NewUnix() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x7875);\nprivate static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);\nprivate static final long serialVersionUID = 1L;\n\nprivate int version = 1; // always '1' according to current info-zip spec.\n\n// BigInteger helps us with little-endian / big-endian conversions.\n// (thanks to BigInteger.toByteArray() and a reverse() method we created).\n// Also, the spec theoretically allows UID/GID up to 255 bytes long!\n//\n// NOTE:  equals() and hashCode() currently assume these can never be null.\nprivate BigInteger uid;\nprivate BigInteger gid;\n\n/**\n* Constructor for X7875_NewUnix.\n*/\npublic X7875_NewUnix() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:reset()V",
                                    "method_body": "private void reset() {\n// Typical UID/GID of the first non-root user created on a unix system.\nuid = ONE_THOUSAND;\ngid = ONE_THOUSAND;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\n\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\n\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<init>()V",
                                    "method_body": "public Zip64ExtendedInformationExtraField() { }\npublic Zip64ExtendedInformationExtraField() { }"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<clinit>()V",
                                    "method_body": "static final ZipShort HEADER_ID = new ZipShort(0x0001);\n\nprivate static final String LFH_MUST_HAVE_BOTH_SIZES_MSG =\n\"Zip64 extended information must contain\"\n+ \" both size values in the local file header.\";\nprivate static final byte[] EMPTY = new byte[0];\n\nprivate ZipEightByteInteger size, compressedSize, relativeHeaderOffset;\nprivate ZipLong diskStart;\n\n/**\n* Stored in {@link #parseFromCentralDirectoryData\n* parseFromCentralDirectoryData} so it can be reused when ZipFile"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn new ZipShort(size != null ? 2 * DWORD : 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nif (size != null || compressedSize != null) {\nif (size == null || compressedSize == null) {\nthrow new IllegalArgumentException(LFH_MUST_HAVE_BOTH_SIZES_MSG);\n}\nbyte[] data = new byte[2 * DWORD];\naddSizes(data);\nreturn data;\n}\nreturn EMPTY;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:parseFromLocalFileData([BII)V",
                                    "method_body": "public void parseFromLocalFileData(byte[] buffer, int offset, int length)\nthrows ZipException {\nif (length == 0) {\n// no local file data at all, may happen if an archive\n// only holds a ZIP64 extended information extra field\n// inside the central directory but not inside the local\n// file header\nreturn;\n}\nif (length < 2 * DWORD) {\nthrow new ZipException(LFH_MUST_HAVE_BOTH_SIZES_MSG);\n}\nsize = new ZipEightByteInteger(buffer, offset);\noffset += DWORD;\ncompressedSize = new ZipEightByteInteger(buffer, offset);\noffset += DWORD;\nint remaining = length - 2 * DWORD;\nif (remaining >= DWORD) {\nrelativeHeaderOffset = new ZipEightByteInteger(buffer, offset);\noffset += DWORD;\nremaining -= DWORD;\n}\nif (remaining >= WORD) {\ndiskStart = new ZipLong(buffer, offset);\noffset += WORD;\nremaining -= WORD;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:parseFromCentralDirectoryData([BII)V",
                                    "method_body": "public void parseFromCentralDirectoryData(byte[] buffer, int offset,\nint length)\nthrows ZipException {\n// store for processing in reparseCentralDirectoryData\nrawCentralDirectoryData = new byte[length];\nSystem.arraycopy(buffer, offset, rawCentralDirectoryData, 0, length);\n\n// if there is no size information in here, we are screwed and\n// can only hope things will get resolved by LFH data later\n// But there are some cases that can be detected\n// * all data is there\n// * length == 24 -> both sizes and offset\n// * length % 8 == 4 -> at least we can identify the diskStart field\nif (length >= 3 * DWORD + WORD) {\nparseFromLocalFileData(buffer, offset, length);\n} else if (length == 3 * DWORD) {\nsize = new ZipEightByteInteger(buffer, offset);\noffset += DWORD;\ncompressedSize = new ZipEightByteInteger(buffer, offset);\noffset += DWORD;\nrelativeHeaderOffset = new ZipEightByteInteger(buffer, offset);\n} else if (length % DWORD == WORD) {\ndiskStart = new ZipLong(buffer, offset + length - WORD);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:reparseCentralDirectoryData(ZZZZ)V",
                                    "method_body": "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\nboolean hasCompressedSize,\nboolean hasRelativeHeaderOffset,\nboolean hasDiskStart)\nthrows ZipException {\nif (rawCentralDirectoryData != null) {\nint expectedLength = (hasUncompressedSize ? DWORD : 0)\n+ (hasCompressedSize ? DWORD : 0)\n+ (hasRelativeHeaderOffset ? DWORD : 0)\n+ (hasDiskStart ? WORD : 0);\nif (rawCentralDirectoryData.length != expectedLength) {\nthrow new ZipException(\"central directory zip64 extended\"\n+ \" information extra field's length\"\n+ \" doesn't match central directory\"\n+ \" data.  Expected length \"\n+ expectedLength + \" but is \"\n+ rawCentralDirectoryData.length);\n}\nint offset = 0;\nif (hasUncompressedSize) {\nsize = new ZipEightByteInteger(rawCentralDirectoryData, offset);\noffset += DWORD;\n}\nif (hasCompressedSize) {\ncompressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\noffset);\noffset += DWORD;\n}\nif (hasRelativeHeaderOffset) {\nrelativeHeaderOffset =\nnew ZipEightByteInteger(rawCentralDirectoryData, offset);\noffset += DWORD;\n}\nif (hasDiskStart) {\ndiskStart = new ZipLong(rawCentralDirectoryData, offset);\noffset += WORD;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:addSizes([B)I",
                                    "method_body": "private int addSizes(byte[] data) {\nint off = 0;\nif (size != null) {\nSystem.arraycopy(size.getBytes(), 0, data, 0, DWORD);\noff += DWORD;\n}\nif (compressedSize != null) {\nSystem.arraycopy(compressedSize.getBytes(), 0, data, off, DWORD);\noff += DWORD;\n}\nreturn off;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n\n/**\n* Convert a Date object to a DOS date/time field.\n* @param time the <code>Date</code> to convert\n* @return the date as a <code>ZipLong</code>\n*/\npublic static ZipLong toDosTime(Date time) {\nreturn new ZipLong(toDosTime(time.getTime()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:dosToJavaTime(J)J",
                                    "method_body": "public static long dosToJavaTime(long dosTime) {\nCalendar cal = Calendar.getInstance();\n// CheckStyle:MagicNumberCheck OFF - no point\ncal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\ncal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\ncal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);\ncal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);\ncal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);\ncal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);\n// CheckStyle:MagicNumberCheck ON\nreturn cal.getTime().getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:copy([B)[B",
                                    "method_body": "static byte[] copy(byte[] from) {\nif (from != null) {\nbyte[] to = new byte[from.length];\nSystem.arraycopy(from, 0, to, 0, to.length);\nreturn to;\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<init>(I)V",
                                    "method_body": "private UnparseableExtraField(int k) {\nkey = k;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<clinit>()V",
                                    "method_body": "public static final int THROW_KEY = 0;\n/**\n* Key for \"skip\" action.\n*/\npublic static final int SKIP_KEY = 1;\n/**\n* Key for \"read\" action.\n*/\npublic static final int READ_KEY = 2;\n\n/**\n* Throw an exception if field cannot be parsed.\n*/\npublic static final UnparseableExtraField THROW\n= new UnparseableExtraField(THROW_KEY);\n\n/**\n* Skip the extra field entirely and don't make its data\n* available - effectively removing the extra field data.\n*/\npublic static final UnparseableExtraField SKIP\n= new UnparseableExtraField(SKIP_KEY);\n\n/**\n* Read the extra field data into an instance of {@link\n* UnparseableExtraFieldData UnparseableExtraFieldData}."
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipFile(File f) throws IOException {\nthis(f, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;)V",
                                    "method_body": "public ZipFile(File f, String encoding) throws IOException {\nthis(f, encoding, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\nthrows IOException {\nthis.archiveName = f.getAbsolutePath();\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = new RandomAccessFile(f, \"r\");\nboolean success = false;\ntry {\nMap<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag =\npopulateFromCentralDirectory();\nresolveLocalFileHeaderData(entriesWithoutUTF8Flag);\nsuccess = true;\n} finally {\nif (!success) {\ntry {\nclosed = true;\narchive.close();\n} catch (IOException e2) { // NOPMD\n// swallow, throw the original exception instead\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<clinit>()V",
                                    "method_body": "private static final int CFH_LEN =\n/* version made by                 */ SHORT\n/* version needed to extract       */ + SHORT\n/* general purpose bit flag        */ + SHORT\n/* compression method              */ + SHORT\n/* last mod file time              */ + SHORT\n/* last mod file date              */ + SHORT\n/* crc-32                          */ + WORD\n/* compressed size                 */ + WORD\n/* uncompressed size               */ + WORD\n/* filename length                 */ + SHORT\n/* extra field length              */ + SHORT\n/* file comment length             */ + SHORT\n/* disk number start               */ + SHORT\n/* internal file attributes        */ + SHORT\n/* external file attributes        */ + WORD\n/* relative offset of local header */ + WORD;\n\nprivate static final long CFH_SIG =\nZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n\n/**\n* Reads the central directory of the given archive and populates\n* the internal tables with ZipArchiveEntry instances.\n*\n* <p>The ZipArchiveEntrys will know all data that can be obtained from\n* the central directory alone, but not the data that requires the\n* local file header or additional data to be read.</p>\n*\n* @return a map of zipentries that didn't have the language\n* encoding flag set when read.\n*/\nprivate Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory()\nthrows IOException {\nHashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\nnew HashMap<ZipArchiveEntry, NameAndComment>();\n\npositionAtCentralDirectory();\n\narchive.readFully(WORD_BUF);\nlong sig = ZipLong.getValue(WORD_BUF);\n\nif (sig != CFH_SIG && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n+ \" corrupt archive.\");\n}\n\nwhile (sig == CFH_SIG) {\nreadCentralDirectoryEntry(noUTF8Flag);\narchive.readFully(WORD_BUF);\nsig = ZipLong.getValue(WORD_BUF);\n}\nreturn noUTF8Flag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:closeQuietly(Lorg/apache/commons/compress/archivers/zip/ZipFile;)V",
                                    "method_body": "public static void closeQuietly(ZipFile zipfile) {\nif (zipfile != null) {\ntry {\nzipfile.close();\n} catch (IOException e) { // NOPMD\n//ignore, that's why the method is called \"quietly\"\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory()\nthrows IOException {\nHashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\nnew HashMap<ZipArchiveEntry, NameAndComment>();\n\npositionAtCentralDirectory();\n\narchive.readFully(WORD_BUF);\nlong sig = ZipLong.getValue(WORD_BUF);\n\nif (sig != CFH_SIG && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n+ \" corrupt archive.\");\n}\n\nwhile (sig == CFH_SIG) {\nreadCentralDirectoryEntry(noUTF8Flag);\narchive.readFully(WORD_BUF);\nsig = ZipLong.getValue(WORD_BUF);\n}\nreturn noUTF8Flag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:readCentralDirectoryEntry(Ljava/util/Map;)V",
                                    "method_body": "private void\nreadCentralDirectoryEntry(Map<ZipArchiveEntry, NameAndComment> noUTF8Flag)\nthrows IOException {\narchive.readFully(CFH_BUF);\nint off = 0;\nOffsetEntry offset = new OffsetEntry();\nEntry ze = new Entry(offset);\n\nint versionMadeBy = ZipShort.getValue(CFH_BUF, off);\noff += SHORT;\nze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\noff += SHORT; // skip version info\n\nfinal GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(CFH_BUF, off);\nfinal boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\nfinal ZipEncoding entryEncoding =\nhasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\nze.setGeneralPurposeBit(gpFlag);\n\noff += SHORT;\n\nze.setMethod(ZipShort.getValue(CFH_BUF, off));\noff += SHORT;\n\nlong time = ZipUtil.dosToJavaTime(ZipLong.getValue(CFH_BUF, off));\nze.setTime(time);\noff += WORD;\n\nze.setCrc(ZipLong.getValue(CFH_BUF, off));\noff += WORD;\n\nze.setCompressedSize(ZipLong.getValue(CFH_BUF, off));\noff += WORD;\n\nze.setSize(ZipLong.getValue(CFH_BUF, off));\noff += WORD;\n\nint fileNameLen = ZipShort.getValue(CFH_BUF, off);\noff += SHORT;\n\nint extraLen = ZipShort.getValue(CFH_BUF, off);\noff += SHORT;\n\nint commentLen = ZipShort.getValue(CFH_BUF, off);\noff += SHORT;\n\nint diskStart = ZipShort.getValue(CFH_BUF, off);\noff += SHORT;\n\nze.setInternalAttributes(ZipShort.getValue(CFH_BUF, off));\noff += SHORT;\n\nze.setExternalAttributes(ZipLong.getValue(CFH_BUF, off));\noff += WORD;\n\nbyte[] fileName = new byte[fileNameLen];\narchive.readFully(fileName);\nze.setName(entryEncoding.decode(fileName), fileName);\n\n// LFH offset,\noffset.headerOffset = ZipLong.getValue(CFH_BUF, off);\n// data offset will be filled later\nentries.add(ze);\n\nbyte[] cdExtraData = new byte[extraLen];\narchive.readFully(cdExtraData);\nze.setCentralDirectoryExtra(cdExtraData);\n\nsetSizesAndOffsetFromZip64Extra(ze, offset, diskStart);\n\nbyte[] comment = new byte[commentLen];\narchive.readFully(comment);\nze.setComment(entryEncoding.decode(comment));\n\nif (!hasUTF8Flag && useUnicodeExtraFields) {\nnoUTF8Flag.put(ze, new NameAndComment(fileName, comment));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:setSizesAndOffsetFromZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Lorg/apache/commons/compress/archivers/zip/ZipFile$OffsetEntry;I)V",
                                    "method_body": "private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze,\nOffsetEntry offset,\nint diskStart)\nthrows IOException {\nZip64ExtendedInformationExtraField z64 =\n(Zip64ExtendedInformationExtraField)\nze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\nif (z64 != null) {\nboolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\nboolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\nboolean hasRelativeHeaderOffset =\noffset.headerOffset == ZIP64_MAGIC;\nz64.reparseCentralDirectoryData(hasUncompressedSize,\nhasCompressedSize,\nhasRelativeHeaderOffset,\ndiskStart == ZIP64_MAGIC_SHORT);\n\nif (hasUncompressedSize) {\nze.setSize(z64.getSize().getLongValue());\n} else if (hasCompressedSize) {\nz64.setSize(new ZipEightByteInteger(ze.getSize()));\n}\n\nif (hasCompressedSize) {\nze.setCompressedSize(z64.getCompressedSize().getLongValue());\n} else if (hasUncompressedSize) {\nz64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));\n}\n\nif (hasRelativeHeaderOffset) {\noffset.headerOffset =\nz64.getRelativeHeaderOffset().getLongValue();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nthrows IOException {\npositionAtEndOfCentralDirectoryRecord();\nboolean found = false;\nboolean searchedForZip64EOCD =\narchive.getFilePointer() > ZIP64_EOCDL_LENGTH;\nif (searchedForZip64EOCD) {\narchive.seek(archive.getFilePointer() - ZIP64_EOCDL_LENGTH);\narchive.readFully(WORD_BUF);\nfound = Arrays.equals(ZipArchiveOutputStream.ZIP64_EOCD_LOC_SIG,\nWORD_BUF);\n}\nif (!found) {\n// not a ZIP64 archive\nif (searchedForZip64EOCD) {\nskipBytes(ZIP64_EOCDL_LENGTH - WORD);\n}\npositionAtCentralDirectory32();\n} else {\npositionAtCentralDirectory64();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory64()V",
                                    "method_body": "private void positionAtCentralDirectory64()\nthrows IOException {\nskipBytes(ZIP64_EOCDL_LOCATOR_OFFSET\n- WORD /* signature has already been read */);\narchive.readFully(DWORD_BUF);\narchive.seek(ZipEightByteInteger.getLongValue(DWORD_BUF));\narchive.readFully(WORD_BUF);\nif (!Arrays.equals(WORD_BUF, ZipArchiveOutputStream.ZIP64_EOCD_SIG)) {\nthrow new ZipException(\"archive's ZIP64 end of central \"\n+ \"directory locator is corrupt.\");\n}\nskipBytes(ZIP64_EOCD_CFD_LOCATOR_OFFSET\n- WORD /* signature has already been read */);\narchive.readFully(DWORD_BUF);\narchive.seek(ZipEightByteInteger.getLongValue(DWORD_BUF));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtEndOfCentralDirectoryRecord()V",
                                    "method_body": "private void positionAtEndOfCentralDirectoryRecord()\nthrows IOException {\nboolean found = tryToLocateSignature(MIN_EOCD_SIZE, MAX_EOCD_SIZE,\nZipArchiveOutputStream.EOCD_SIG);\nif (!found) {\nthrow new ZipException(\"archive is not a ZIP archive\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:tryToLocateSignature(JJ[B)Z",
                                    "method_body": "private boolean tryToLocateSignature(long minDistanceFromEnd,\nlong maxDistanceFromEnd,\nbyte[] sig) throws IOException {\nboolean found = false;\nlong off = archive.length() - minDistanceFromEnd;\nfinal long stopSearching =\nMath.max(0L, archive.length() - maxDistanceFromEnd);\nif (off >= 0) {\nfor (; off >= stopSearching; off--) {\narchive.seek(off);\nint curr = archive.read();\nif (curr == -1) {\nbreak;\n}\nif (curr == sig[POS_0]) {\ncurr = archive.read();\nif (curr == sig[POS_1]) {\ncurr = archive.read();\nif (curr == sig[POS_2]) {\ncurr = archive.read();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\n}\n}\n}\n}\n}\n}\nif (found) {\narchive.seek(off);\n}\nreturn found;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:skipBytes(I)V",
                                    "method_body": "private void skipBytes(final int count) throws IOException {\nint totalSkipped = 0;\nwhile (totalSkipped < count) {\nint skippedNow = archive.skipBytes(count - totalSkipped);\nif (skippedNow <= 0) {\nthrow new EOFException();\n}\ntotalSkipped += skippedNow;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$OffsetEntry:access$002(Lorg/apache/commons/compress/archivers/zip/ZipFile$OffsetEntry;J)J",
                                    "method_body": "private static final int HASH_SIZE = 509;\nstatic final int NIBLET_MASK = 0x0f;\nstatic final int BYTE_SHIFT = 8;\nprivate static final int POS_0 = 0;\nprivate static final int POS_1 = 1;\nprivate static final int POS_2 = 2;\nprivate static final int POS_3 = 3;\n\n/**\n* List of entries in the order they appear inside the central\n* directory.\n*/\nprivate final List<ZipArchiveEntry> entries =\nnew LinkedList<ZipArchiveEntry>();\n\n/**\n* Maps String to list of ZipArchiveEntrys, name -> actual entries.\n*/\nprivate final Map<String, Deque<ZipArchiveEntry>> nameMap =\nnew HashMap<String, Deque<ZipArchiveEntry>>(HASH_SIZE);\n\nprivate static final class OffsetEntry {\nprivate long headerOffset = -1;\nprivate long dataOffset = -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$Entry:<init>(Lorg/apache/commons/compress/archivers/zip/ZipFile$OffsetEntry;)V",
                                    "method_body": "Entry(OffsetEntry offset) {\nthis.offsetEntry = offset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setHeaderId(Lorg/apache/commons/compress/archivers/zip/ZipShort;)V",
                                    "method_body": "public void setHeaderId(ZipShort headerId) {\nthis.headerId = headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setLocalFileDataData([B)V",
                                    "method_body": "public void setLocalFileDataData(byte[] data) {\nlocalData = ZipUtil.copy(data);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn new ZipShort(localData.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn ZipUtil.copy(localData);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setCentralDirectoryData([B)V",
                                    "method_body": "public void setCentralDirectoryData(byte[] data) {\ncentralData = ZipUtil.copy(data);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:parseFromCentralDirectoryData([BII)V",
                                    "method_body": "public void parseFromCentralDirectoryData(byte[] data, int offset,\nint length) {\nbyte[] tmp = new byte[length];\nSystem.arraycopy(data, offset, tmp, 0, length);\nsetCentralDirectoryData(tmp);\nif (localData == null) {\nsetLocalFileDataData(tmp);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<init>(J)V",
                                    "method_body": "public ZipEightByteInteger(long value) {\nthis(BigInteger.valueOf(value));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<init>(Ljava/math/BigInteger;)V",
                                    "method_body": "public ZipEightByteInteger(BigInteger value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<init>([BI)V",
                                    "method_body": "public ZipEightByteInteger (byte[] bytes, int offset) {\nvalue = ZipEightByteInteger.getValue(bytes, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate static final int BYTE_4 = 4;\nprivate static final long BYTE_4_MASK = 0xFF00000000L;\nprivate static final int BYTE_4_SHIFT = 32;\n\nprivate static final int BYTE_5 = 5;\nprivate static final long BYTE_5_MASK = 0xFF0000000000L;\nprivate static final int BYTE_5_SHIFT = 40;\n\nprivate static final int BYTE_6 = 6;\nprivate static final long BYTE_6_MASK = 0xFF000000000000L;\nprivate static final int BYTE_6_SHIFT = 48;\n\nprivate static final int BYTE_7 = 7;\nprivate static final long BYTE_7_MASK = 0x7F00000000000000L;\nprivate static final int BYTE_7_SHIFT = 56;\n\nprivate static final int LEFTMOST_BIT_SHIFT = 63;\nprivate static final byte LEFTMOST_BIT = (byte) 0x80;\n\nprivate final BigInteger value;\n\npublic static final ZipEightByteInteger ZERO = new ZipEightByteInteger(0);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipEightByteInteger\n*/\npublic ZipEightByteInteger(long value) {\nthis(BigInteger.valueOf(value));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipEightByteInteger.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:getBytes(Ljava/math/BigInteger;)[B",
                                    "method_body": "public static byte[] getBytes(BigInteger value) {\nbyte[] result = new byte[8];\nlong val = value.longValue();\nresult[0] = (byte) ((val & BYTE_MASK));\nresult[BYTE_1] = (byte) ((val & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((val & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((val & BYTE_3_MASK) >> BYTE_3_SHIFT);\nresult[BYTE_4] = (byte) ((val & BYTE_4_MASK) >> BYTE_4_SHIFT);\nresult[BYTE_5] = (byte) ((val & BYTE_5_MASK) >> BYTE_5_SHIFT);\nresult[BYTE_6] = (byte) ((val & BYTE_6_MASK) >> BYTE_6_SHIFT);\nresult[BYTE_7] = (byte) ((val & BYTE_7_MASK) >> BYTE_7_SHIFT);\nif (value.testBit(LEFTMOST_BIT_SHIFT)) {\nresult[BYTE_7] |= LEFTMOST_BIT;\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:getLongValue([BI)J",
                                    "method_body": "public static long getLongValue(byte[] bytes, int offset) {\nreturn getValue(bytes, offset).longValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:getValue([BI)Ljava/math/BigInteger;",
                                    "method_body": "public static BigInteger getValue(byte[] bytes, int offset) {\nlong value = ((long) bytes[offset + BYTE_7] << BYTE_7_SHIFT) & BYTE_7_MASK;\nvalue += ((long) bytes[offset + BYTE_6] << BYTE_6_SHIFT) & BYTE_6_MASK;\nvalue += ((long) bytes[offset + BYTE_5] << BYTE_5_SHIFT) & BYTE_5_MASK;\nvalue += ((long) bytes[offset + BYTE_4] << BYTE_4_SHIFT) & BYTE_4_MASK;\nvalue += ((long) bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += ((long) bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += ((long) bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += ((long) bytes[offset] & BYTE_MASK);\nBigInteger val = BigInteger.valueOf(value);\nreturn (bytes[offset + BYTE_7] & LEFTMOST_BIT) == LEFTMOST_BIT\n? val.setBit(LEFTMOST_BIT_SHIFT) : val;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:getLongValue([B)J",
                                    "method_body": "public static long getLongValue(byte[] bytes) {\nreturn getLongValue(bytes, 0);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 20,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStreamTest.testCpioUnarchiveCreatedByRedlineRpm",
                            "test_body": "49: public void testCpioUnarchiveCreatedByRedlineRpm() throws Exception {\n50: CpioArchiveInputStream in =\n51: new CpioArchiveInputStream(new FileInputStream(getFile(\"redline.cpio\")));\n52: CpioArchiveEntry entry= null;\n53: 54: int count = 0;\n55: while ((entry = (CpioArchiveEntry) in.getNextEntry()) != null) {\n56: count++;\n57: }\n58: in.close();\n59: 60: assertEquals(count, 1);\n61: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:<init>(S)V",
                                    "method_body": "public CpioArchiveEntry(final short format) {\nswitch (format) {\ncase FORMAT_NEW:\nthis.headerSize = 110;\nthis.alignmentBoundary = 4;\nbreak;\ncase FORMAT_NEW_CRC:\nthis.headerSize = 110;\nthis.alignmentBoundary = 4;\nbreak;\ncase FORMAT_OLD_ASCII:\nthis.headerSize = 76;\nthis.alignmentBoundary = 0;\nbreak;\ncase FORMAT_OLD_BINARY:\nthis.headerSize = 26;\nthis.alignmentBoundary = 2;\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"Unknown header type\");\n}\nthis.fileFormat = format;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:checkNewFormat()V",
                                    "method_body": "private void checkNewFormat() {\nif ((this.fileFormat & FORMAT_NEW_MASK) == 0) {\nthrow new UnsupportedOperationException();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn this.filesize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getFormat()S",
                                    "method_body": "public short getFormat() {\nreturn this.fileFormat;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getHeaderPadCount()I",
                                    "method_body": "public int getHeaderPadCount(){\nif (this.alignmentBoundary == 0) { return 0; }\nint size = this.headerSize+this.name.length()+1; // Name has terminating null\nint remain = size % this.alignmentBoundary;\nif (remain > 0){\nreturn this.alignmentBoundary - remain;\n}\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getDataPadCount()I",
                                    "method_body": "public int getDataPadCount(){\nif (this.alignmentBoundary == 0) { return 0; }\nlong size = this.filesize;\nint remain = (int) (size % this.alignmentBoundary);\nif (remain > 0){\nreturn this.alignmentBoundary - remain;\n}\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn this.name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setChksum(J)V",
                                    "method_body": "public void setChksum(final long chksum) {\ncheckNewFormat();\nthis.chksum = chksum;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setDeviceMaj(J)V",
                                    "method_body": "public void setDeviceMaj(final long maj) {\ncheckNewFormat();\nthis.maj = maj;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setDeviceMin(J)V",
                                    "method_body": "public void setDeviceMin(final long min) {\ncheckNewFormat();\nthis.min = min;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(final long size) {\nif (size < 0 || size > 0xFFFFFFFFL) {\nthrow new IllegalArgumentException(\"invalid entry size <\" + size\n+ \">\");\n}\nthis.filesize = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setGID(J)V",
                                    "method_body": "public void setGID(final long gid) {\nthis.gid = gid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setInode(J)V",
                                    "method_body": "public void setInode(final long inode) {\nthis.inode = inode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setMode(J)V",
                                    "method_body": "public void setMode(final long mode) {\nfinal long maskedMode = mode & S_IFMT;\nswitch ((int) maskedMode) {\ncase C_ISDIR:\ncase C_ISLNK:\ncase C_ISREG:\ncase C_ISFIFO:\ncase C_ISCHR:\ncase C_ISBLK:\ncase C_ISSOCK:\ncase C_ISNWK:\nbreak;\ndefault:\nthrow new IllegalArgumentException(\n\"Unknown mode. \"\n+ \"Full: \" + Long.toHexString(mode)\n+ \" Masked: \" + Long.toHexString(maskedMode));\n}\n\nthis.mode = mode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "public void setName(final String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setNumberOfLinks(J)V",
                                    "method_body": "public void setNumberOfLinks(final long nlink) {\nthis.nlink = nlink;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setRemoteDeviceMaj(J)V",
                                    "method_body": "public void setRemoteDeviceMaj(final long rmaj) {\ncheckNewFormat();\nthis.rmaj = rmaj;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setRemoteDeviceMin(J)V",
                                    "method_body": "public void setRemoteDeviceMin(final long rmin) {\ncheckNewFormat();\nthis.rmin = rmin;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setTime(J)V",
                                    "method_body": "public void setTime(final long time) {\nthis.mtime = time;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry:setUID(J)V",
                                    "method_body": "public void setUID(final long uid) {\nthis.uid = uid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:toAsciiString([B)Ljava/lang/String;",
                                    "method_body": "public static String toAsciiString(final byte[] inputBytes){\ntry {\nreturn new String(inputBytes, \"ASCII\");\n} catch (UnsupportedEncodingException e) {\nthrow new RuntimeException(e); // Should never happen\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioUtil:byteArray2long([BZ)J",
                                    "method_body": "static long byteArray2long(final byte[] number, final boolean swapHalfWord) {\nif (number.length % 2 != 0) {\nthrow new UnsupportedOperationException();\n}\n\nlong ret = 0;\nint pos = 0;\nbyte tmp_number[] = new byte[number.length];\nSystem.arraycopy(number, 0, tmp_number, 0, number.length);\n\nif (!swapHalfWord) {\nbyte tmp = 0;\nfor (pos = 0; pos < tmp_number.length; pos++) {\ntmp = tmp_number[pos];\ntmp_number[pos++] = tmp_number[pos];\ntmp_number[pos] = tmp;\n}\n}\n\nret = tmp_number[0] & 0xFF;\nfor (pos = 1; pos < tmp_number.length; pos++) {\nret <<= 8;\nret |= tmp_number[pos] & 0xFF;\n}\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public CpioArchiveInputStream(final InputStream in) {\nthis(in, BLOCK_SIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:<init>(Ljava/io/InputStream;I)V",
                                    "method_body": "public CpioArchiveInputStream(final InputStream in, int blockSize) {\nthis.in = in;\nthis.blockSize = blockSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:closeEntry()V",
                                    "method_body": "private void closeEntry() throws IOException {\nensureOpen();\nwhile (read(this.tmpbuf, 0, this.tmpbuf.length) != -1) { // NOPMD\n// do nothing\n}\n\nthis.entryEOF = true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:ensureOpen()V",
                                    "method_body": "private void ensureOpen() throws IOException {\nif (this.closed) {\nthrow new IOException(\"Stream closed\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:getNextCPIOEntry()Lorg/apache/commons/compress/archivers/cpio/CpioArchiveEntry;",
                                    "method_body": "public CpioArchiveEntry getNextCPIOEntry() throws IOException {\nensureOpen();\nif (this.entry != null) {\ncloseEntry();\n}\nreadFully(TWO_BYTES_BUF, 0, TWO_BYTES_BUF.length);\nif (CpioUtil.byteArray2long(TWO_BYTES_BUF, false) == MAGIC_OLD_BINARY) {\nthis.entry = readOldBinaryEntry(false);\n} else if (CpioUtil.byteArray2long(TWO_BYTES_BUF, true)\n== MAGIC_OLD_BINARY) {\nthis.entry = readOldBinaryEntry(true);\n} else {\nSystem.arraycopy(TWO_BYTES_BUF, 0, SIX_BYTES_BUF, 0,\nTWO_BYTES_BUF.length);\nreadFully(SIX_BYTES_BUF, TWO_BYTES_BUF.length,\nFOUR_BYTES_BUF.length);\nString magicString = ArchiveUtils.toAsciiString(SIX_BYTES_BUF);\nif (magicString.equals(MAGIC_NEW)) {\nthis.entry = readNewEntry(false);\n} else if (magicString.equals(MAGIC_NEW_CRC)) {\nthis.entry = readNewEntry(true);\n} else if (magicString.equals(MAGIC_OLD_ASCII)) {\nthis.entry = readOldAsciiEntry();\n} else {\nthrow new IOException(\"Unknown magic [\" + magicString + \"]. Occured at byte: \" + getBytesRead());\n}\n}\n\nthis.entryBytesRead = 0;\nthis.entryEOF = false;\nthis.crc = 0;\n\nif (this.entry.getName().equals(CPIO_TRAILER)) {\nthis.entryEOF = true;\nskipRemainderOfLastBlock();\nreturn null;\n}\nreturn this.entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:skip(I)V",
                                    "method_body": "private void skip(int bytes) throws IOException{\n// bytes cannot be more than 3 bytes\nif (bytes > 0) {\nreadFully(FOUR_BYTES_BUF, 0, bytes);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:read([BII)I",
                                    "method_body": "public int read(final byte[] b, final int off, final int len)\nthrows IOException {\nensureOpen();\nif (off < 0 || len < 0 || off > b.length - len) {\nthrow new IndexOutOfBoundsException();\n} else if (len == 0) {\nreturn 0;\n}\n\nif (this.entry == null || this.entryEOF) {\nreturn -1;\n}\nif (this.entryBytesRead == this.entry.getSize()) {\nskip(entry.getDataPadCount());\nthis.entryEOF = true;\nif (this.entry.getFormat() == FORMAT_NEW_CRC\n&& this.crc != this.entry.getChksum()) {\nthrow new IOException(\"CRC Error. Occured at byte: \"\n+ getBytesRead());\n}\nreturn -1; // EOF for this entry\n}\nint tmplength = (int) Math.min(len, this.entry.getSize()\n- this.entryBytesRead);\nif (tmplength < 0) {\nreturn -1;\n}\n\nint tmpread = readFully(b, off, tmplength);\nif (this.entry.getFormat() == FORMAT_NEW_CRC) {\nfor (int pos = 0; pos < tmpread; pos++) {\nthis.crc += b[pos] & 0xFF;\n}\n}\nthis.entryBytesRead += tmpread;\n\nreturn tmpread;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:readFully([BII)I",
                                    "method_body": "private final int readFully(final byte[] b, final int off, final int len)\nthrows IOException {\nif (len < 0) {\nthrow new IndexOutOfBoundsException();\n}\nint n = 0;\nwhile (n < len) {\nint count = this.in.read(b, off + n, len - n);\ncount(count);\nif (count < 0) {\nthrow new EOFException();\n}\nn += count;\n}\nreturn n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:readAsciiLong(II)J",
                                    "method_body": "private long readAsciiLong(final int length, final int radix)\nthrows IOException {\nbyte tmpBuffer[] = new byte[length];\nreadFully(tmpBuffer, 0, tmpBuffer.length);\nreturn Long.parseLong(ArchiveUtils.toAsciiString(tmpBuffer), radix);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:readNewEntry(Z)Lorg/apache/commons/compress/archivers/cpio/CpioArchiveEntry;",
                                    "method_body": "private CpioArchiveEntry readNewEntry(final boolean hasCrc)\nthrows IOException {\nCpioArchiveEntry ret;\nif (hasCrc) {\nret = new CpioArchiveEntry(FORMAT_NEW_CRC);\n} else {\nret = new CpioArchiveEntry(FORMAT_NEW);\n}\n\nret.setInode(readAsciiLong(8, 16));\nlong mode = readAsciiLong(8, 16);\nif (mode != 0){\nret.setMode(mode);\n}\nret.setUID(readAsciiLong(8, 16));\nret.setGID(readAsciiLong(8, 16));\nret.setNumberOfLinks(readAsciiLong(8, 16));\nret.setTime(readAsciiLong(8, 16));\nret.setSize(readAsciiLong(8, 16));\nret.setDeviceMaj(readAsciiLong(8, 16));\nret.setDeviceMin(readAsciiLong(8, 16));\nret.setRemoteDeviceMaj(readAsciiLong(8, 16));\nret.setRemoteDeviceMin(readAsciiLong(8, 16));\nlong namesize = readAsciiLong(8, 16);\nret.setChksum(readAsciiLong(8, 16));\nString name = readCString((int) namesize);\nret.setName(name);\nif (mode == 0 && !name.equals(CPIO_TRAILER)){\nthrow new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \"+name + \" Occured at byte: \" + getBytesRead());\n}\nskip(ret.getHeaderPadCount());\n\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:readCString(I)Ljava/lang/String;",
                                    "method_body": "private String readCString(final int length) throws IOException {\nbyte tmpBuffer[] = new byte[length];\nreadFully(tmpBuffer, 0, tmpBuffer.length);\nreturn new String(tmpBuffer, 0, tmpBuffer.length - 1); // TODO default charset?\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:getNextEntry()Lorg/apache/commons/compress/archivers/cpio/CpioArchiveEntry;",
                                    "method_body": "public CpioArchiveEntry getNextEntry() throws IOException {\nreturn getNextCPIOEntry();\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 21,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest.testSixFilesSomeNotEmpty",
                            "test_body": "178: public void testSixFilesSomeNotEmpty() throws Exception {\n179: testCompress252(6, 2);\n180: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;[B)V",
                                    "method_body": "public SevenZFile(final File filename, final byte[] password) throws IOException {\nboolean succeeded = false;\nthis.file = new RandomAccessFile(filename, \"r\");\ntry {\narchive = readHeaders(password);\nif (password != null) {\nthis.password = new byte[password.length];\nSystem.arraycopy(password, 0, this.password, 0, password.length);\n} else {\nthis.password = null;\n}\nsucceeded = true;\n} finally {\nif (!succeeded) {\nthis.file.close();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZFile(final File filename) throws IOException {\nthis(filename, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<clinit>()V",
                                    "method_body": "static final int SIGNATURE_HEADER_SIZE = 32;\n\nprivate static final int DRAIN_BUF_SIZE = 64 * 1024;\n\nprivate RandomAccessFile file;\nprivate final Archive archive;\nprivate int currentEntryIndex = -1;\nprivate int currentFolderIndex = -1;\nprivate InputStream currentFolderInputStream = null;\nprivate InputStream currentEntryInputStream = null;\nprivate byte[] password;\n\nstatic final byte[] sevenZSignature = {\n(byte)'7', (byte)'z', (byte)0xBC, (byte)0xAF, (byte)0x27, (byte)0x1C\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeaders([B)Lorg/apache/commons/compress/archivers/sevenz/Archive;",
                                    "method_body": "private Archive readHeaders(byte[] password) throws IOException {\nfinal byte[] signature = new byte[6];\nfile.readFully(signature);\nif (!Arrays.equals(signature, sevenZSignature)) {\nthrow new IOException(\"Bad 7z signature\");\n}\n// 7zFormat.txt has it wrong - it's first major then minor\nfinal byte archiveVersionMajor = file.readByte();\nfinal byte archiveVersionMinor = file.readByte();\nif (archiveVersionMajor != 0) {\nthrow new IOException(String.format(\"Unsupported 7z version (%d,%d)\",\narchiveVersionMajor, archiveVersionMinor));\n}\n\nfinal long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\nfinal StartHeader startHeader = readStartHeader(startHeaderCrc);\n\nfinal int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\nif (nextHeaderSizeInt != startHeader.nextHeaderSize) {\nthrow new IOException(\"cannot handle nextHeaderSize \" + startHeader.nextHeaderSize);\n}\nfile.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\nfinal byte[] nextHeader = new byte[nextHeaderSizeInt];\nfile.readFully(nextHeader);\nfinal CRC32 crc = new CRC32();\ncrc.update(nextHeader);\nif (startHeader.nextHeaderCrc != crc.getValue()) {\nthrow new IOException(\"NextHeader CRC mismatch\");\n}\n\nfinal ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\nDataInputStream nextHeaderInputStream = new DataInputStream(\nbyteStream);\nArchive archive = new Archive();\nint nid = nextHeaderInputStream.readUnsignedByte();\nif (nid == NID.kEncodedHeader) {\nnextHeaderInputStream =\nreadEncodedHeader(nextHeaderInputStream, archive, password);\n// Archive gets rebuilt with the new header\narchive = new Archive();\nnid = nextHeaderInputStream.readUnsignedByte();\n}\nif (nid == NID.kHeader) {\nreadHeader(nextHeaderInputStream, archive);\nnextHeaderInputStream.close();\n} else {\nthrow new IOException(\"Broken or unsupported archive: no Header\");\n}\nreturn archive;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStartHeader(J)Lorg/apache/commons/compress/archivers/sevenz/StartHeader;",
                                    "method_body": "private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\nfinal StartHeader startHeader = new StartHeader();\nDataInputStream dataInputStream = null;\ntry {\ndataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\nnew BoundedRandomAccessFileInputStream(file, 20), 20, startHeaderCrc));\nstartHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\nreturn startHeader;\n} finally {\nif (dataInputStream != null) {\ndataInputStream.close();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeader(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readHeader(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\n\nif (nid == NID.kArchiveProperties) {\nreadArchiveProperties(header);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kAdditionalStreamsInfo) {\nthrow new IOException(\"Additional streams unsupported\");\n//nid = header.readUnsignedByte();\n}\n\nif (nid == NID.kMainStreamsInfo) {\nreadStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kFilesInfo) {\nreadFilesInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated header\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\n\nif (nid == NID.kPackInfo) {\nreadPackInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kUnpackInfo) {\nreadUnpackInfo(header, archive);\nnid = header.readUnsignedByte();\n} else {\n// archive without unpack/coders info\narchive.folders = new Folder[0];\n}\n\nif (nid == NID.kSubStreamsInfo) {\nreadSubStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated StreamsInfo\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readSubStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nfor (final Folder folder : archive.folders) {\nfolder.numUnpackSubStreams = 1;\n}\nint totalUnpackStreams = archive.folders.length;\n\nint nid = header.readUnsignedByte();\nif (nid == NID.kNumUnpackStream) {\ntotalUnpackStreams = 0;\nfor (final Folder folder : archive.folders) {\nfinal long numStreams = readUint64(header);\nfolder.numUnpackSubStreams = (int)numStreams;\ntotalUnpackStreams += numStreams;\n}\nnid = header.readUnsignedByte();\n}\n\nfinal SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\nsubStreamsInfo.unpackSizes = new long[totalUnpackStreams];\nsubStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\nsubStreamsInfo.crcs = new long[totalUnpackStreams];\n\nint nextUnpackStream = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams == 0) {\ncontinue;\n}\nlong sum = 0;\nif (nid == NID.kSize) {\nfor (int i = 0; i < (folder.numUnpackSubStreams - 1); i++) {\nfinal long size = readUint64(header);\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = size;\nsum += size;\n}\n}\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;\n}\nif (nid == NID.kSize) {\nnid = header.readUnsignedByte();\n}\n\nint numDigests = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {\nnumDigests += folder.numUnpackSubStreams;\n}\n}\n\nif (nid == NID.kCRC) {\nfinal BitSet hasMissingCrc = readAllOrBits(header, numDigests);\nfinal long[] missingCrcs = new long[numDigests];\nfor (int i = 0; i < numDigests; i++) {\nif (hasMissingCrc.get(i)) {\nmissingCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n}\n}\nint nextCrc = 0;\nint nextMissingCrc = 0;\nfor (final Folder folder: archive.folders) {\nif (folder.numUnpackSubStreams == 1 && folder.hasCrc) {\nsubStreamsInfo.hasCrc.set(nextCrc, true);\nsubStreamsInfo.crcs[nextCrc] = folder.crc;\n++nextCrc;\n} else {\nfor (int i = 0; i < folder.numUnpackSubStreams; i++) {\nsubStreamsInfo.hasCrc.set(nextCrc, hasMissingCrc.get(nextMissingCrc));\nsubStreamsInfo.crcs[nextCrc] = missingCrcs[nextMissingCrc];\n++nextCrc;\n++nextMissingCrc;\n}\n}\n}\n\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated SubStreamsInfo\");\n}\n\narchive.subStreamsInfo = subStreamsInfo;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readBits(final DataInput header, final int size) throws IOException {\nfinal BitSet bits = new BitSet(size);\nint mask = 0;\nint cache = 0;\nfor (int i = 0; i < size; i++) {\nif (mask == 0) {\nmask = 0x80;\ncache = header.readUnsignedByte();\n}\nbits.set(i, (cache & mask) != 0);\nmask >>>= 1;\n}\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFilesInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readFilesInfo(final DataInput header, final Archive archive) throws IOException {\nfinal long numFiles = readUint64(header);\nfinal SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\nfor (int i = 0; i < files.length; i++) {\nfiles[i] = new SevenZArchiveEntry();\n}\nBitSet isEmptyStream = null;\nBitSet isEmptyFile = null;\nBitSet isAnti = null;\nwhile (true) {\nfinal int propertyType = header.readUnsignedByte();\nif (propertyType == 0) {\nbreak;\n}\nlong size = readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream: {\nisEmptyStream = readBits(header, files.length);\nbreak;\n}\ncase NID.kEmptyFile: {\nif (isEmptyStream == null) { // protect against NPE\nthrow new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n}\nisEmptyFile = readBits(header, isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kAnti: {\nif (isEmptyStream == null) { // protect against NPE\nthrow new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n}\nisAnti = readBits(header, isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kName: {\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Not implemented\");\n} else {\nif (((size - 1) & 1) != 0) {\nthrow new IOException(\"File names length invalid\");\n}\nfinal byte[] names = new byte[(int)(size - 1)];\nheader.readFully(names);\nint nextFile = 0;\nint nextName = 0;\nfor (int i = 0; i < names.length; i += 2) {\nif (names[i] == 0 && names[i+1] == 0) {\nfiles[nextFile++].setName(new String(names, nextName, i-nextName, CharsetNames.UTF_16LE));\nnextName = i + 2;\n}\n}\nif (nextName != names.length || nextFile != files.length) {\nthrow new IOException(\"Error parsing file names\");\n}\n}\nbreak;\n}\ncase NID.kCTime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasCreationDate(timesDefined.get(i));\nif (files[i].getHasCreationDate()) {\nfiles[i].setCreationDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kATime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasAccessDate(timesDefined.get(i));\nif (files[i].getHasAccessDate()) {\nfiles[i].setAccessDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kMTime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasLastModifiedDate(timesDefined.get(i));\nif (files[i].getHasLastModifiedDate()) {\nfiles[i].setLastModifiedDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kWinAttributes: {\nfinal BitSet attributesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasWindowsAttributes(attributesDefined.get(i));\nif (files[i].getHasWindowsAttributes()) {\nfiles[i].setWindowsAttributes(Integer.reverseBytes(header.readInt()));\n}\n}\n}\nbreak;\n}\ncase NID.kStartPos: {\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy: {\nthrow new IOException(\"kDummy is unsupported, please report\");\n}\n\ndefault: {\nthrow new IOException(\"Unknown property \" + propertyType);\n// FIXME: Should actually:\n//header.skipBytes((int)size);\n}\n}\n}\nint nonEmptyFileCounter = 0;\nint emptyFileCounter = 0;\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasStream((isEmptyStream == null) ? true : !isEmptyStream.get(i));\nif (files[i].hasStream()) {\nfiles[i].setDirectory(false);\nfiles[i].setAntiItem(false);\nfiles[i].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nfiles[i].setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nfiles[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n} else {\nfiles[i].setDirectory((isEmptyFile == null) ? true : !isEmptyFile.get(emptyFileCounter));\nfiles[i].setAntiItem((isAnti == null) ? false : isAnti.get(emptyFileCounter));\nfiles[i].setHasCrc(false);\nfiles[i].setSize(0);\n++emptyFileCounter;\n}\n}\narchive.files = files;\ncalculateStreamMap(archive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUint64(Ljava/io/DataInput;)J",
                                    "method_body": "private static long readUint64(final DataInput in) throws IOException {\n// long rather than int as it might get shifted beyond the range of an int\nlong firstByte = in.readUnsignedByte();\nint mask = 0x80;\nlong value = 0;\nfor (int i = 0; i < 8; i++) {\nif ((firstByte & mask) == 0) {\nreturn value | ((firstByte & (mask - 1)) << (8 * i));\n}\nlong nextByte = in.readUnsignedByte();\nvalue |= (nextByte << (8 * i));\nmask >>>= 1;\n}\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;JJ)V",
                                    "method_body": "public ChecksumVerifyingInputStream(final Checksum checksum, final InputStream in,\nfinal long size, final long expectedChecksum) {\nthis.checksum = checksum;\nthis.in = in;\nthis.expectedChecksum = expectedChecksum;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining <= 0) {\nreturn -1;\n}\nint ret = in.read();\nif (ret >= 0) {\nchecksum.update(ret);\n--bytesRemaining;\n}\nif (bytesRemaining == 0 && expectedChecksum != checksum.getValue()) {\nthrow new IOException(\"Checksum verification failed\");\n}\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nint ret = in.read(b, off, len);\nif (ret >= 0) {\nchecksum.update(b, off, ret);\nbytesRemaining -= ret;\n}\nif (bytesRemaining <= 0 && expectedChecksum != checksum.getValue()) {\nthrow new IOException(\"Checksum verification failed\");\n}\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nin.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CRC32VerifyingInputStream:<init>(Ljava/io/InputStream;JJ)V",
                                    "method_body": "public CRC32VerifyingInputStream(final InputStream in, final long size, final long expectedCrc32) {\nsuper(new CRC32(), in, size, expectedCrc32);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:<init>(Ljava/io/RandomAccessFile;J)V",
                                    "method_body": "public BoundedRandomAccessFileInputStream(final RandomAccessFile file,\nfinal long size) {\nthis.file = file;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining > 0) {\n--bytesRemaining;\nreturn file.read();\n} else {\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif (bytesRemaining == 0) {\nreturn -1;\n}\nint bytesToRead = len;\nif (bytesToRead > bytesRemaining) {\nbytesToRead = (int) bytesRemaining;\n}\nfinal int bytesRead = file.read(b, off, bytesToRead);\nif (bytesRead >= 0) {\nbytesRemaining -= bytesRead;\n}\nreturn bytesRead;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:close()V",
                                    "method_body": "public void close() {\n// the nested RandomAccessFile is controlled externally\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:<init>(Ljava/lang/String;I[B)V",
                                    "method_body": "private SevenZMethod(byte[] id) {\nthis.id = id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:<init>()V",
                                    "method_body": "public SevenZArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "public void setName(String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:hasStream()Z",
                                    "method_body": "public boolean hasStream() {\nreturn hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasStream(Z)V",
                                    "method_body": "public void setHasStream(boolean hasStream) {\nthis.hasStream = hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nreturn isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setDirectory(Z)V",
                                    "method_body": "public void setDirectory(boolean isDirectory) {\nthis.isDirectory = isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isAntiItem()Z",
                                    "method_body": "public boolean isAntiItem() {\nreturn isAntiItem;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasCreationDate()Z",
                                    "method_body": "public boolean getHasCreationDate() {\nreturn hasCreationDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasLastModifiedDate()Z",
                                    "method_body": "public boolean getHasLastModifiedDate() {\nreturn hasLastModifiedDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getLastModifiedDate()Ljava/util/Date;",
                                    "method_body": "public Date getLastModifiedDate() {\nif (hasLastModifiedDate) {\nreturn ntfsTimeToJavaTime(lastModifiedDate);\n} else {\nthrow new UnsupportedOperationException(\n\"The entry doesn't have this timestamp\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setLastModifiedDate(Ljava/util/Date;)V",
                                    "method_body": "public void setLastModifiedDate(Date lastModifiedDate) {\nhasLastModifiedDate = lastModifiedDate != null;\nif (hasLastModifiedDate) {\nthis.lastModifiedDate = javaTimeToNtfsTime(lastModifiedDate);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasAccessDate()Z",
                                    "method_body": "public boolean getHasAccessDate() {\nreturn hasAccessDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasWindowsAttributes()Z",
                                    "method_body": "public boolean getHasWindowsAttributes() {\nreturn hasWindowsAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasCrc(Z)V",
                                    "method_body": "public void setHasCrc(boolean hasCrc) {\nthis.hasCrc = hasCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCompressedSize(J)V",
                                    "method_body": "void setCompressedSize(long size) {\nthis.compressedSize = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:ntfsTimeToJavaTime(J)Ljava/util/Date;",
                                    "method_body": "public static Date ntfsTimeToJavaTime(final long ntfsTime) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nfinal long realTime = ntfsEpoch.getTimeInMillis() + (ntfsTime / (10*1000));\nreturn new Date(realTime);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:javaTimeToNtfsTime(Ljava/util/Date;)J",
                                    "method_body": "public static long javaTimeToNtfsTime(final Date date) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nreturn ((date.getTime() - ntfsEpoch.getTimeInMillis())* 1000 * 10);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZOutputFile(final File filename) throws IOException {\nfile = new RandomAccessFile(filename, \"rw\");\nfile.seek(SevenZFile.SIGNATURE_HEADER_SIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!finished) {\nfinish();\n}\nfile.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:createArchiveEntry(Ljava/io/File;Ljava/lang/String;)Lorg/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry;",
                                    "method_body": "public SevenZArchiveEntry createArchiveEntry(final File inputFile,\nfinal String entryName) throws IOException {\nfinal SevenZArchiveEntry entry = new SevenZArchiveEntry();\nentry.setDirectory(inputFile.isDirectory());\nentry.setName(entryName);\nentry.setLastModifiedDate(new Date(inputFile.lastModified()));\nreturn entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\nfinal SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;\nfiles.add(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (currentOutputStream != null) {\ncurrentOutputStream.flush();\ncurrentOutputStream.close();\n}\n\nfinal SevenZArchiveEntry entry = files.get(files.size() - 1);\nif (fileBytesWritten > 0) {\nentry.setHasStream(true);\n++numNonEmptyStreams;\nentry.setSize(currentOutputStream.getBytesWritten());\nentry.setCompressedSize(fileBytesWritten);\nentry.setCrcValue(crc32.getValue());\nentry.setCompressedCrcValue(compressedCrc32.getValue());\nentry.setHasCrc(true);\n} else {\nentry.setHasStream(false);\nentry.setSize(0);\nentry.setCompressedSize(0);\nentry.setHasCrc(false);\n}\ncurrentOutputStream = null;\ncrc32.reset();\ncompressedCrc32.reset();\nfileBytesWritten = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([B)V",
                                    "method_body": "public void write(final byte[] b) throws IOException {\nwrite(b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int off, final int len) throws IOException {\nif (len > 0) {\ngetCurrentOutputStream().write(b, off, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif (finished) {\nthrow new IOException(\"This archive has already been finished\");\n}\nfinished = true;\n\nfinal long headerPosition = file.getFilePointer();\n\nfinal ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();\nfinal DataOutputStream header = new DataOutputStream(headerBaos);\n\nwriteHeader(header);\nheader.flush();\nfinal byte[] headerBytes = headerBaos.toByteArray();\nfile.write(headerBytes);\n\nfinal CRC32 crc32 = new CRC32();\n\n// signature header\nfile.seek(0);\nfile.write(SevenZFile.sevenZSignature);\n// version\nfile.write(0);\nfile.write(2);\n\n// start header\nfinal ByteArrayOutputStream startHeaderBaos = new ByteArrayOutputStream();\nfinal DataOutputStream startHeaderStream = new DataOutputStream(startHeaderBaos);\nstartHeaderStream.writeLong(Long.reverseBytes(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE));\nstartHeaderStream.writeLong(Long.reverseBytes(0xffffFFFFL & headerBytes.length));\ncrc32.reset();\ncrc32.update(headerBytes);\nstartHeaderStream.writeInt(Integer.reverseBytes((int)crc32.getValue()));\nstartHeaderStream.flush();\nfinal byte[] startHeaderBytes = startHeaderBaos.toByteArray();\ncrc32.reset();\ncrc32.update(startHeaderBytes);\nfile.writeInt(Integer.reverseBytes((int) crc32.getValue()));\nfile.write(startHeaderBytes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeHeader(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeHeader(final DataOutput header) throws IOException {\nheader.write(NID.kHeader);\n\nheader.write(NID.kMainStreamsInfo);\nwriteStreamsInfo(header);\nwriteFilesInfo(header);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeStreamsInfo(final DataOutput header) throws IOException {\nif (numNonEmptyStreams > 0) {\nwritePackInfo(header);\nwriteUnpackInfo(header);\n}\n\nwriteSubStreamsInfo(header);\n\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeSubStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeSubStreamsInfo(final DataOutput header) throws IOException {\nheader.write(NID.kSubStreamsInfo);\n//\n//        header.write(NID.kCRC);\n//        header.write(1);\n//        for (final SevenZArchiveEntry entry : files) {\n//            if (entry.getHasCrc()) {\n//                header.writeInt(Integer.reverseBytes(entry.getCrc()));\n//            }\n//        }\n//\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFilesInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFilesInfo(final DataOutput header) throws IOException {\nheader.write(NID.kFilesInfo);\n\nwriteUint64(header, files.size());\n\nwriteFileEmptyStreams(header);\nwriteFileEmptyFiles(header);\nwriteFileAntiItems(header);\nwriteFileNames(header);\nwriteFileCTimes(header);\nwriteFileATimes(header);\nwriteFileMTimes(header);\nwriteFileWindowsAttributes(header);\nheader.write(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyStreams(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyStreams(final DataOutput header) throws IOException {\nboolean hasEmptyStreams = false;\nfor (final SevenZArchiveEntry entry : files) {\nif (!entry.hasStream()) {\nhasEmptyStreams = true;\nbreak;\n}\n}\nif (hasEmptyStreams) {\nheader.write(NID.kEmptyStream);\nfinal BitSet emptyStreams = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nemptyStreams.set(i, !files.get(i).hasStream());\n}\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyStreams, files.size());\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyFiles(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyFiles(final DataOutput header) throws IOException {\nboolean hasEmptyFiles = false;\nint emptyStreamCounter = 0;\nfinal BitSet emptyFiles = new BitSet(0);\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isDir = files.get(i).isDirectory();\nemptyFiles.set(emptyStreamCounter++, !isDir);\nhasEmptyFiles |= !isDir;\n}\n}\nif (hasEmptyFiles) {\nheader.write(NID.kEmptyFile);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyFiles, emptyStreamCounter);\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileAntiItems(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileAntiItems(final DataOutput header) throws IOException {\nboolean hasAntiItems = false;\nfinal BitSet antiItems = new BitSet(0);\nint antiItemCounter = 0;\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isAnti = files.get(i).isAntiItem();\nantiItems.set(antiItemCounter++, isAnti);\nhasAntiItems |= isAnti;\n}\n}\nif (hasAntiItems) {\nheader.write(NID.kAnti);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, antiItems, antiItemCounter);\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileNames(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileNames(final DataOutput header) throws IOException {\nheader.write(NID.kName);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nout.write(entry.getName().getBytes(\"UTF-16LE\"));\nout.writeShort(0);\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileCTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileCTimes(final DataOutput header) throws IOException {\nint numCreationDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasCreationDate()) {\n++numCreationDates;\n}\n}\nif (numCreationDates > 0) {\nheader.write(NID.kCTime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numCreationDates != files.size()) {\nout.write(0);\nfinal BitSet cTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\ncTimes.set(i, files.get(i).getHasCreationDate());\n}\nwriteBits(out, cTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasCreationDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getCreationDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileATimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileATimes(final DataOutput header) throws IOException {\nint numAccessDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasAccessDate()) {\n++numAccessDates;\n}\n}\nif (numAccessDates > 0) {\nheader.write(NID.kATime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numAccessDates != files.size()) {\nout.write(0);\nfinal BitSet aTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\naTimes.set(i, files.get(i).getHasAccessDate());\n}\nwriteBits(out, aTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasAccessDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getAccessDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileMTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileMTimes(final DataOutput header) throws IOException {\nint numLastModifiedDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\n++numLastModifiedDates;\n}\n}\nif (numLastModifiedDates > 0) {\nheader.write(NID.kMTime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numLastModifiedDates != files.size()) {\nout.write(0);\nfinal BitSet mTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nmTimes.set(i, files.get(i).getHasLastModifiedDate());\n}\nwriteBits(out, mTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getLastModifiedDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileWindowsAttributes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileWindowsAttributes(final DataOutput header) throws IOException {\nint numWindowsAttributes = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasWindowsAttributes()) {\n++numWindowsAttributes;\n}\n}\nif (numWindowsAttributes > 0) {\nheader.write(NID.kWinAttributes);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numWindowsAttributes != files.size()) {\nout.write(0);\nfinal BitSet attributes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nattributes.set(i, files.get(i).getHasWindowsAttributes());\n}\nwriteBits(out, attributes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasWindowsAttributes()) {\nout.writeInt(Integer.reverseBytes(entry.getWindowsAttributes()));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeUint64(Ljava/io/DataOutput;J)V",
                                    "method_body": "private void writeUint64(final DataOutput header, long value) throws IOException {\nint firstByte = 0;\nint mask = 0x80;\nint i;\nfor (i = 0; i < 8; i++) {\nif (value < ((1L << ( 7  * (i + 1))))) {\nfirstByte |= (value >>> (8 * i));\nbreak;\n}\nfirstByte |= mask;\nmask >>>= 1;\n}\nheader.write(firstByte);\nfor (; i > 0; i--) {\nheader.write((int) (0xff & value));\nvalue >>>= 8;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeBits(Ljava/io/DataOutput;Ljava/util/BitSet;I)V",
                                    "method_body": "private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\nint cache = 0;\nint shift = 7;\nfor (int i = 0; i < length; i++) {\ncache |= ((bits.get(i) ? 1 : 0) << shift);\n--shift;\nif (shift == 0) {\nheader.write(cache);\nshift = 7;\ncache = 0;\n}\n}\nif (length > 0 && shift > 0) {\nheader.write(cache);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public CountingOutputStream(final OutputStream out) {\nsuper(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int off, int len) throws IOException {\nout.write(b, off, len);\ncount(len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:count(J)V",
                                    "method_body": "protected void count(long written) {\nif (written != -1) {\nbytesWritten += written;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:getBytesWritten()J",
                                    "method_body": "public long getBytesWritten() {\nreturn bytesWritten;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readPackInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readPackInfo(final DataInput header, final Archive archive) throws IOException {\narchive.packPos = readUint64(header);\nfinal long numPackStreams = readUint64(header);\nint nid = header.readUnsignedByte();\nif (nid == NID.kSize) {\narchive.packSizes = new long[(int)numPackStreams];\nfor (int i = 0; i < archive.packSizes.length; i++) {\narchive.packSizes[i] = readUint64(header);\n}\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kCRC) {\narchive.packCrcsDefined = readAllOrBits(header, (int)numPackStreams);\narchive.packCrcs = new long[(int)numPackStreams];\nfor (int i = 0; i < (int)numPackStreams; i++) {\nif (archive.packCrcsDefined.get(i)) {\narchive.packCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n}\n}\n\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated PackInfo (\" + nid + \")\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUnpackInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readUnpackInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\nif (nid != NID.kFolder) {\nthrow new IOException(\"Expected kFolder, got \" + nid);\n}\nfinal long numFolders = readUint64(header);\nfinal Folder[] folders = new Folder[(int)numFolders];\narchive.folders = folders;\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"External unsupported\");\n} else {\nfor (int i = 0; i < (int)numFolders; i++) {\nfolders[i] = readFolder(header);\n}\n}\n\nnid = header.readUnsignedByte();\nif (nid != NID.kCodersUnpackSize) {\nthrow new IOException(\"Expected kCodersUnpackSize, got \" + nid);\n}\nfor (final Folder folder : folders) {\nfolder.unpackSizes = new long[(int)folder.totalOutputStreams];\nfor (int i = 0; i < folder.totalOutputStreams; i++) {\nfolder.unpackSizes[i] = readUint64(header);\n}\n}\n\nnid = header.readUnsignedByte();\nif (nid == NID.kCRC) {\nfinal BitSet crcsDefined = readAllOrBits(header, (int)numFolders);\nfor (int i = 0; i < (int)numFolders; i++) {\nif (crcsDefined.get(i)) {\nfolders[i].hasCrc = true;\nfolders[i].crc = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n} else {\nfolders[i].hasCrc = false;\n}\n}\n\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated UnpackInfo\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFolder(Ljava/io/DataInput;)Lorg/apache/commons/compress/archivers/sevenz/Folder;",
                                    "method_body": "private Folder readFolder(final DataInput header) throws IOException {\nfinal Folder folder = new Folder();\n\nfinal long numCoders = readUint64(header);\nfinal Coder[] coders = new Coder[(int)numCoders];\nlong totalInStreams = 0;\nlong totalOutStreams = 0;\nfor (int i = 0; i < coders.length; i++) {\ncoders[i] = new Coder();\nint bits = header.readUnsignedByte();\nfinal int idSize = bits & 0xf;\nfinal boolean isSimple = ((bits & 0x10) == 0);\nfinal boolean hasAttributes = ((bits & 0x20) != 0);\nfinal boolean moreAlternativeMethods = ((bits & 0x80) != 0);\n\ncoders[i].decompressionMethodId = new byte[idSize];\nheader.readFully(coders[i].decompressionMethodId);\nif (isSimple) {\ncoders[i].numInStreams = 1;\ncoders[i].numOutStreams = 1;\n} else {\ncoders[i].numInStreams = readUint64(header);\ncoders[i].numOutStreams = readUint64(header);\n}\ntotalInStreams += coders[i].numInStreams;\ntotalOutStreams += coders[i].numOutStreams;\nif (hasAttributes) {\nfinal long propertiesSize = readUint64(header);\ncoders[i].properties = new byte[(int)propertiesSize];\nheader.readFully(coders[i].properties);\n}\n// would need to keep looping as above:\nwhile (moreAlternativeMethods) {\nthrow new IOException(\"Alternative methods are unsupported, please report. \" +\n\"The reference implementation doesn't support them either.\");\n}\n}\nfolder.coders = coders;\nfolder.totalInputStreams = totalInStreams;\nfolder.totalOutputStreams = totalOutStreams;\n\nif (totalOutStreams == 0) {\nthrow new IOException(\"Total output streams can't be 0\");\n}\nfinal long numBindPairs = totalOutStreams - 1;\nfinal BindPair[] bindPairs = new BindPair[(int)numBindPairs];\nfor (int i = 0; i < bindPairs.length; i++) {\nbindPairs[i] = new BindPair();\nbindPairs[i].inIndex = readUint64(header);\nbindPairs[i].outIndex = readUint64(header);\n}\nfolder.bindPairs = bindPairs;\n\nif (totalInStreams < numBindPairs) {\nthrow new IOException(\"Total input streams can't be less than the number of bind pairs\");\n}\nfinal long numPackedStreams = totalInStreams - numBindPairs;\nfinal long packedStreams[] = new long[(int)numPackedStreams];\nif (numPackedStreams == 1) {\nint i;\nfor (i = 0; i < (int)totalInStreams; i++) {\nif (folder.findBindPairForInStream(i) < 0) {\nbreak;\n}\n}\nif (i == (int)totalInStreams) {\nthrow new IOException(\"Couldn't find stream's bind pair index\");\n}\npackedStreams[0] = i;\n} else {\nfor (int i = 0; i < (int)numPackedStreams; i++) {\npackedStreams[i] = readUint64(header);\n}\n}\nfolder.packedStreams = packedStreams;\n\nreturn folder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readAllOrBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readAllOrBits(final DataInput header, final int size) throws IOException {\nfinal int areAllDefined = header.readUnsignedByte();\nfinal BitSet bits;\nif (areAllDefined != 0) {\nbits = new BitSet(size);\nfor (int i = 0; i < size; i++) {\nbits.set(i, true);\n}\n} else {\nbits = readBits(header, size);\n}\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:calculateStreamMap(Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void calculateStreamMap(final Archive archive) throws IOException {\nfinal StreamMap streamMap = new StreamMap();\n\nint nextFolderPackStreamIndex = 0;\nfinal int numFolders = (archive.folders != null) ? archive.folders.length : 0;\nstreamMap.folderFirstPackStreamIndex = new int[numFolders];\nfor (int i = 0; i < numFolders; i++) {\nstreamMap.folderFirstPackStreamIndex[i] = nextFolderPackStreamIndex;\nnextFolderPackStreamIndex += archive.folders[i].packedStreams.length;\n}\n\nlong nextPackStreamOffset = 0;\nfinal int numPackSizes = (archive.packSizes != null) ? archive.packSizes.length : 0;\nstreamMap.packStreamOffsets = new long[numPackSizes];\nfor (int i = 0; i < numPackSizes; i++) {\nstreamMap.packStreamOffsets[i] = nextPackStreamOffset;\nnextPackStreamOffset += archive.packSizes[i];\n}\n\nstreamMap.folderFirstFileIndex = new int[numFolders];\nstreamMap.fileFolderIndex = new int[archive.files.length];\nint nextFolderIndex = 0;\nint nextFolderUnpackStreamIndex = 0;\nfor (int i = 0; i < archive.files.length; i++) {\nif (!archive.files[i].hasStream() && nextFolderUnpackStreamIndex == 0) {\nstreamMap.fileFolderIndex[i] = -1;\ncontinue;\n}\nif (nextFolderUnpackStreamIndex == 0) {\nfor (; nextFolderIndex < archive.folders.length; ++nextFolderIndex) {\nstreamMap.folderFirstFileIndex[nextFolderIndex] = i;\nif (archive.folders[nextFolderIndex].numUnpackSubStreams > 0) {\nbreak;\n}\n}\nif (nextFolderIndex >= archive.folders.length) {\nthrow new IOException(\"Too few folders in archive\");\n}\n}\nstreamMap.fileFolderIndex[i] = nextFolderIndex;\nif (!archive.files[i].hasStream()) {\ncontinue;\n}\n++nextFolderUnpackStreamIndex;\nif (nextFolderUnpackStreamIndex >= archive.folders[nextFolderIndex].numUnpackSubStreams) {\n++nextFolderIndex;\nnextFolderUnpackStreamIndex = 0;\n}\n}\n\narchive.streamMap = streamMap;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:findBindPairForInStream(I)I",
                                    "method_body": "int findBindPairForInStream(final int index) {\nfor (int i = 0; i < bindPairs.length; i++) {\nif (bindPairs[i].inIndex == index) {\nreturn i;\n}\n}\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:findBindPairForOutStream(I)I",
                                    "method_body": "int findBindPairForOutStream(final int index) {\nfor (int i = 0; i < bindPairs.length; i++) {\nif (bindPairs[i].outIndex == index) {\nreturn i;\n}\n}\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:getUnpackSize()J",
                                    "method_body": "long getUnpackSize() {\nif (totalOutputStreams == 0) {\nreturn 0;\n}\nfor (int i = ((int)totalOutputStreams) - 1; i >= 0; i--) {\nif (findBindPairForOutStream(i) < 0) {\nreturn unpackSizes[i];\n}\n}\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders:<clinit>()V",
                                    "method_body": "static CoderId[] coderTable = new CoderId[] {\nnew CoderId(SevenZMethod.COPY, new CopyDecoder()),\nnew CoderId(SevenZMethod.LZMA, new LZMADecoder()),\nnew CoderId(SevenZMethod.LZMA2, new LZMA2Decoder()),\nnew CoderId(SevenZMethod.DEFLATE, new DeflateDecoder()),\nnew CoderId(SevenZMethod.BZIP2, new BZIP2Decoder()),\nnew CoderId(SevenZMethod.AES256SHA256, new AES256SHA256Decoder())\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders:addEncoder(Ljava/io/OutputStream;Lorg/apache/commons/compress/archivers/sevenz/SevenZMethod;[B)Ljava/io/OutputStream;",
                                    "method_body": "static OutputStream addEncoder(final OutputStream out, final SevenZMethod method,\nfinal byte[] password) throws IOException {\nfor (final CoderId coderId : coderTable) {\nif (coderId.method.equals(method)) {\nreturn coderId.coder.encode(out, password);\n}\n}\nthrow new IOException(\"Unsupported compression method \" + method);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$CoderId:<init>(Lorg/apache/commons/compress/archivers/sevenz/SevenZMethod;Lorg/apache/commons/compress/archivers/sevenz/Coders$CoderBase;)V",
                                    "method_body": "CoderId(SevenZMethod method, final CoderBase coder) {\nthis.method = method;\nthis.coder = coder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:getId()[B",
                                    "method_body": "byte[] getId() {\nbyte[] copy = new byte[id.length];\nSystem.arraycopy(id, 0, copy, 0, id.length);\nreturn copy;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod$1:getProperties()[B",
                                    "method_body": "byte[] getProperties() {\nint dictSize = LZMA2Options.DICT_SIZE_DEFAULT;\nint lead = Integer.numberOfLeadingZeros(dictSize);\nint secondBit = (dictSize >>> (30 - lead)) - 2;\nreturn new byte[] {\n(byte) ((19 - lead) * 2 + secondBit)\n};\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$CoderBase:<init>()V",
                                    "method_body": "final SevenZMethod method;\nfinal CoderBase coder;\n}\n\nstatic abstract class CoderBase {\nabstract InputStream decode(final InputStream in, final Coder coder,\nbyte[] password) throws IOException;\nOutputStream encode(final OutputStream out, final byte[] password)\nthrows IOException {\nthrow new UnsupportedOperationException(\"method doesn't support writing\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.LZMA2Decoder:encode(Ljava/io/OutputStream;[B)Ljava/io/OutputStream;",
                                    "method_body": "OutputStream encode(final OutputStream out, final byte[] password)\nthrows IOException {\nLZMA2Options options = new LZMA2Options();\noptions.setDictSize(LZMA2Options.DICT_SIZE_DEFAULT);\nFinishableOutputStream wrapped = new FinishableWrapperOutputStream(out);\nreturn options.getOutputStream(wrapped);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setAntiItem(Z)V",
                                    "method_body": "public void setAntiItem(boolean isAntiItem) {\nthis.isAntiItem = isAntiItem;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getCrcValue()J",
                                    "method_body": "public long getCrcValue() {\nreturn crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCrcValue(J)V",
                                    "method_body": "public void setCrcValue(long crc) {\nthis.crc = crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getCompressedCrcValue()J",
                                    "method_body": "long getCompressedCrcValue() {\nreturn compressedCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCompressedCrcValue(J)V",
                                    "method_body": "void setCompressedCrcValue(long crc) {\nthis.compressedCrc = crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getCompressedSize()J",
                                    "method_body": "long getCompressedSize() {\nreturn compressedSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:getCurrentOutputStream()Ljava/io/OutputStream;",
                                    "method_body": "private OutputStream getCurrentOutputStream() throws IOException {\nif (currentOutputStream == null) {\ncurrentOutputStream = setupFileOutputStream();\n}\nreturn currentOutputStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:setupFileOutputStream()Lorg/apache/commons/compress/utils/CountingOutputStream;",
                                    "method_body": "private CountingOutputStream setupFileOutputStream() throws IOException {\nOutputStream out = new OutputStreamWrapper();\nreturn new CountingOutputStream(Coders\n.addEncoder(out,\ncontentCompression,\nnull)) {\n@Override\npublic void write(final int b) throws IOException {\nsuper.write(b);\ncrc32.update(b);\n}\n\n@Override\npublic void write(final byte[] b) throws IOException {\nsuper.write(b);\ncrc32.update(b);\n}\n\n@Override\npublic void write(final byte[] b, final int off, final int len)\nthrows IOException {\nsuper.write(b, off, len);\ncrc32.update(b, off, len);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writePackInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writePackInfo(final DataOutput header) throws IOException {\nheader.write(NID.kPackInfo);\n\nwriteUint64(header, 0);\nwriteUint64(header, 0xffffFFFFL & numNonEmptyStreams);\n\nheader.write(NID.kSize);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nwriteUint64(header, entry.getCompressedSize());\n}\n}\n\nheader.write(NID.kCRC);\nheader.write(1);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nheader.writeInt(Integer.reverseBytes((int) entry.getCompressedCrcValue()));\n}\n}\n\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeUnpackInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeUnpackInfo(final DataOutput header) throws IOException {\nheader.write(NID.kUnpackInfo);\n\nheader.write(NID.kFolder);\nwriteUint64(header, numNonEmptyStreams);\nheader.write(0);\nfor (int i = 0; i < numNonEmptyStreams; i++) {\nwriteFolder(header);\n}\n\nheader.write(NID.kCodersUnpackSize);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nwriteUint64(header, entry.getSize());\n}\n}\n\nheader.write(NID.kCRC);\nheader.write(1);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nheader.writeInt(Integer.reverseBytes((int) entry.getCrcValue()));\n}\n}\n\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFolder(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFolder(final DataOutput header) throws IOException {\n// one coder\nwriteUint64(header, 1);\nbyte[] id = contentCompression.getId();\nbyte[] properties = contentCompression.getProperties();\n\nint codecFlags = id.length;\nif (properties.length > 0) {\ncodecFlags |= 0x20;\n}\nheader.write(codecFlags);\nheader.write(id);\n\nif (properties.length > 0) {\nheader.write(properties.length);\nheader.write(properties);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:write(I)V",
                                    "method_body": "public void write(final int b) throws IOException {\nfile.write(b);\ncompressedCrc32.update(b);\nfileBytesWritten++;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int off, final int len)\nthrows IOException {\nfile.write(b, off, len);\ncompressedCrc32.update(b, off, len);\nfileBytesWritten += len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:flush()V",
                                    "method_body": "public void flush() throws IOException {\n// no reason to flush a RandomAccessFile\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:close()V",
                                    "method_body": "public void close() throws IOException {\n// the file will be closed by the containing class's close method\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$1:write([BII)V",
                                    "method_body": "private CountingOutputStream setupFileOutputStream() throws IOException {\nOutputStream out = new OutputStreamWrapper();\nreturn new CountingOutputStream(Coders\n.addEncoder(out,\ncontentCompression,\nnull)) {\n@Override\npublic void write(final int b) throws IOException {\nsuper.write(b);\ncrc32.update(b);\n}\n\n@Override\npublic void write(final byte[] b) throws IOException {\nsuper.write(b);\ncrc32.update(b);\n}\n\n@Override\npublic void write(final byte[] b, final int off, final int len)\nthrows IOException {\nsuper.write(b, off, len);\ncrc32.update(b, off, len);\n}\n};\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest.testSevenEmptyFiles",
                            "test_body": "182: public void testSevenEmptyFiles() throws Exception {\n183: testCompress252(7, 0);\n184: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;[B)V",
                                    "method_body": "public SevenZFile(final File filename, final byte[] password) throws IOException {\nboolean succeeded = false;\nthis.file = new RandomAccessFile(filename, \"r\");\ntry {\narchive = readHeaders(password);\nif (password != null) {\nthis.password = new byte[password.length];\nSystem.arraycopy(password, 0, this.password, 0, password.length);\n} else {\nthis.password = null;\n}\nsucceeded = true;\n} finally {\nif (!succeeded) {\nthis.file.close();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZFile(final File filename) throws IOException {\nthis(filename, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<clinit>()V",
                                    "method_body": "static final int SIGNATURE_HEADER_SIZE = 32;\n\nprivate static final int DRAIN_BUF_SIZE = 64 * 1024;\n\nprivate RandomAccessFile file;\nprivate final Archive archive;\nprivate int currentEntryIndex = -1;\nprivate int currentFolderIndex = -1;\nprivate InputStream currentFolderInputStream = null;\nprivate InputStream currentEntryInputStream = null;\nprivate byte[] password;\n\nstatic final byte[] sevenZSignature = {\n(byte)'7', (byte)'z', (byte)0xBC, (byte)0xAF, (byte)0x27, (byte)0x1C\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeaders([B)Lorg/apache/commons/compress/archivers/sevenz/Archive;",
                                    "method_body": "private Archive readHeaders(byte[] password) throws IOException {\nfinal byte[] signature = new byte[6];\nfile.readFully(signature);\nif (!Arrays.equals(signature, sevenZSignature)) {\nthrow new IOException(\"Bad 7z signature\");\n}\n// 7zFormat.txt has it wrong - it's first major then minor\nfinal byte archiveVersionMajor = file.readByte();\nfinal byte archiveVersionMinor = file.readByte();\nif (archiveVersionMajor != 0) {\nthrow new IOException(String.format(\"Unsupported 7z version (%d,%d)\",\narchiveVersionMajor, archiveVersionMinor));\n}\n\nfinal long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\nfinal StartHeader startHeader = readStartHeader(startHeaderCrc);\n\nfinal int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\nif (nextHeaderSizeInt != startHeader.nextHeaderSize) {\nthrow new IOException(\"cannot handle nextHeaderSize \" + startHeader.nextHeaderSize);\n}\nfile.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\nfinal byte[] nextHeader = new byte[nextHeaderSizeInt];\nfile.readFully(nextHeader);\nfinal CRC32 crc = new CRC32();\ncrc.update(nextHeader);\nif (startHeader.nextHeaderCrc != crc.getValue()) {\nthrow new IOException(\"NextHeader CRC mismatch\");\n}\n\nfinal ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\nDataInputStream nextHeaderInputStream = new DataInputStream(\nbyteStream);\nArchive archive = new Archive();\nint nid = nextHeaderInputStream.readUnsignedByte();\nif (nid == NID.kEncodedHeader) {\nnextHeaderInputStream =\nreadEncodedHeader(nextHeaderInputStream, archive, password);\n// Archive gets rebuilt with the new header\narchive = new Archive();\nnid = nextHeaderInputStream.readUnsignedByte();\n}\nif (nid == NID.kHeader) {\nreadHeader(nextHeaderInputStream, archive);\nnextHeaderInputStream.close();\n} else {\nthrow new IOException(\"Broken or unsupported archive: no Header\");\n}\nreturn archive;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStartHeader(J)Lorg/apache/commons/compress/archivers/sevenz/StartHeader;",
                                    "method_body": "private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\nfinal StartHeader startHeader = new StartHeader();\nDataInputStream dataInputStream = null;\ntry {\ndataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\nnew BoundedRandomAccessFileInputStream(file, 20), 20, startHeaderCrc));\nstartHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\nreturn startHeader;\n} finally {\nif (dataInputStream != null) {\ndataInputStream.close();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeader(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readHeader(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\n\nif (nid == NID.kArchiveProperties) {\nreadArchiveProperties(header);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kAdditionalStreamsInfo) {\nthrow new IOException(\"Additional streams unsupported\");\n//nid = header.readUnsignedByte();\n}\n\nif (nid == NID.kMainStreamsInfo) {\nreadStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kFilesInfo) {\nreadFilesInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated header\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\n\nif (nid == NID.kPackInfo) {\nreadPackInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kUnpackInfo) {\nreadUnpackInfo(header, archive);\nnid = header.readUnsignedByte();\n} else {\n// archive without unpack/coders info\narchive.folders = new Folder[0];\n}\n\nif (nid == NID.kSubStreamsInfo) {\nreadSubStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated StreamsInfo\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readSubStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nfor (final Folder folder : archive.folders) {\nfolder.numUnpackSubStreams = 1;\n}\nint totalUnpackStreams = archive.folders.length;\n\nint nid = header.readUnsignedByte();\nif (nid == NID.kNumUnpackStream) {\ntotalUnpackStreams = 0;\nfor (final Folder folder : archive.folders) {\nfinal long numStreams = readUint64(header);\nfolder.numUnpackSubStreams = (int)numStreams;\ntotalUnpackStreams += numStreams;\n}\nnid = header.readUnsignedByte();\n}\n\nfinal SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\nsubStreamsInfo.unpackSizes = new long[totalUnpackStreams];\nsubStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\nsubStreamsInfo.crcs = new long[totalUnpackStreams];\n\nint nextUnpackStream = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams == 0) {\ncontinue;\n}\nlong sum = 0;\nif (nid == NID.kSize) {\nfor (int i = 0; i < (folder.numUnpackSubStreams - 1); i++) {\nfinal long size = readUint64(header);\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = size;\nsum += size;\n}\n}\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;\n}\nif (nid == NID.kSize) {\nnid = header.readUnsignedByte();\n}\n\nint numDigests = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {\nnumDigests += folder.numUnpackSubStreams;\n}\n}\n\nif (nid == NID.kCRC) {\nfinal BitSet hasMissingCrc = readAllOrBits(header, numDigests);\nfinal long[] missingCrcs = new long[numDigests];\nfor (int i = 0; i < numDigests; i++) {\nif (hasMissingCrc.get(i)) {\nmissingCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n}\n}\nint nextCrc = 0;\nint nextMissingCrc = 0;\nfor (final Folder folder: archive.folders) {\nif (folder.numUnpackSubStreams == 1 && folder.hasCrc) {\nsubStreamsInfo.hasCrc.set(nextCrc, true);\nsubStreamsInfo.crcs[nextCrc] = folder.crc;\n++nextCrc;\n} else {\nfor (int i = 0; i < folder.numUnpackSubStreams; i++) {\nsubStreamsInfo.hasCrc.set(nextCrc, hasMissingCrc.get(nextMissingCrc));\nsubStreamsInfo.crcs[nextCrc] = missingCrcs[nextMissingCrc];\n++nextCrc;\n++nextMissingCrc;\n}\n}\n}\n\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated SubStreamsInfo\");\n}\n\narchive.subStreamsInfo = subStreamsInfo;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readBits(final DataInput header, final int size) throws IOException {\nfinal BitSet bits = new BitSet(size);\nint mask = 0;\nint cache = 0;\nfor (int i = 0; i < size; i++) {\nif (mask == 0) {\nmask = 0x80;\ncache = header.readUnsignedByte();\n}\nbits.set(i, (cache & mask) != 0);\nmask >>>= 1;\n}\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFilesInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readFilesInfo(final DataInput header, final Archive archive) throws IOException {\nfinal long numFiles = readUint64(header);\nfinal SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\nfor (int i = 0; i < files.length; i++) {\nfiles[i] = new SevenZArchiveEntry();\n}\nBitSet isEmptyStream = null;\nBitSet isEmptyFile = null;\nBitSet isAnti = null;\nwhile (true) {\nfinal int propertyType = header.readUnsignedByte();\nif (propertyType == 0) {\nbreak;\n}\nlong size = readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream: {\nisEmptyStream = readBits(header, files.length);\nbreak;\n}\ncase NID.kEmptyFile: {\nif (isEmptyStream == null) { // protect against NPE\nthrow new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n}\nisEmptyFile = readBits(header, isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kAnti: {\nif (isEmptyStream == null) { // protect against NPE\nthrow new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n}\nisAnti = readBits(header, isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kName: {\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Not implemented\");\n} else {\nif (((size - 1) & 1) != 0) {\nthrow new IOException(\"File names length invalid\");\n}\nfinal byte[] names = new byte[(int)(size - 1)];\nheader.readFully(names);\nint nextFile = 0;\nint nextName = 0;\nfor (int i = 0; i < names.length; i += 2) {\nif (names[i] == 0 && names[i+1] == 0) {\nfiles[nextFile++].setName(new String(names, nextName, i-nextName, CharsetNames.UTF_16LE));\nnextName = i + 2;\n}\n}\nif (nextName != names.length || nextFile != files.length) {\nthrow new IOException(\"Error parsing file names\");\n}\n}\nbreak;\n}\ncase NID.kCTime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasCreationDate(timesDefined.get(i));\nif (files[i].getHasCreationDate()) {\nfiles[i].setCreationDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kATime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasAccessDate(timesDefined.get(i));\nif (files[i].getHasAccessDate()) {\nfiles[i].setAccessDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kMTime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasLastModifiedDate(timesDefined.get(i));\nif (files[i].getHasLastModifiedDate()) {\nfiles[i].setLastModifiedDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kWinAttributes: {\nfinal BitSet attributesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasWindowsAttributes(attributesDefined.get(i));\nif (files[i].getHasWindowsAttributes()) {\nfiles[i].setWindowsAttributes(Integer.reverseBytes(header.readInt()));\n}\n}\n}\nbreak;\n}\ncase NID.kStartPos: {\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy: {\nthrow new IOException(\"kDummy is unsupported, please report\");\n}\n\ndefault: {\nthrow new IOException(\"Unknown property \" + propertyType);\n// FIXME: Should actually:\n//header.skipBytes((int)size);\n}\n}\n}\nint nonEmptyFileCounter = 0;\nint emptyFileCounter = 0;\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasStream((isEmptyStream == null) ? true : !isEmptyStream.get(i));\nif (files[i].hasStream()) {\nfiles[i].setDirectory(false);\nfiles[i].setAntiItem(false);\nfiles[i].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nfiles[i].setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nfiles[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n} else {\nfiles[i].setDirectory((isEmptyFile == null) ? true : !isEmptyFile.get(emptyFileCounter));\nfiles[i].setAntiItem((isAnti == null) ? false : isAnti.get(emptyFileCounter));\nfiles[i].setHasCrc(false);\nfiles[i].setSize(0);\n++emptyFileCounter;\n}\n}\narchive.files = files;\ncalculateStreamMap(archive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUint64(Ljava/io/DataInput;)J",
                                    "method_body": "private static long readUint64(final DataInput in) throws IOException {\n// long rather than int as it might get shifted beyond the range of an int\nlong firstByte = in.readUnsignedByte();\nint mask = 0x80;\nlong value = 0;\nfor (int i = 0; i < 8; i++) {\nif ((firstByte & mask) == 0) {\nreturn value | ((firstByte & (mask - 1)) << (8 * i));\n}\nlong nextByte = in.readUnsignedByte();\nvalue |= (nextByte << (8 * i));\nmask >>>= 1;\n}\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;JJ)V",
                                    "method_body": "public ChecksumVerifyingInputStream(final Checksum checksum, final InputStream in,\nfinal long size, final long expectedChecksum) {\nthis.checksum = checksum;\nthis.in = in;\nthis.expectedChecksum = expectedChecksum;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining <= 0) {\nreturn -1;\n}\nint ret = in.read();\nif (ret >= 0) {\nchecksum.update(ret);\n--bytesRemaining;\n}\nif (bytesRemaining == 0 && expectedChecksum != checksum.getValue()) {\nthrow new IOException(\"Checksum verification failed\");\n}\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nint ret = in.read(b, off, len);\nif (ret >= 0) {\nchecksum.update(b, off, ret);\nbytesRemaining -= ret;\n}\nif (bytesRemaining <= 0 && expectedChecksum != checksum.getValue()) {\nthrow new IOException(\"Checksum verification failed\");\n}\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nin.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CRC32VerifyingInputStream:<init>(Ljava/io/InputStream;JJ)V",
                                    "method_body": "public CRC32VerifyingInputStream(final InputStream in, final long size, final long expectedCrc32) {\nsuper(new CRC32(), in, size, expectedCrc32);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:<init>(Ljava/io/RandomAccessFile;J)V",
                                    "method_body": "public BoundedRandomAccessFileInputStream(final RandomAccessFile file,\nfinal long size) {\nthis.file = file;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining > 0) {\n--bytesRemaining;\nreturn file.read();\n} else {\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif (bytesRemaining == 0) {\nreturn -1;\n}\nint bytesToRead = len;\nif (bytesToRead > bytesRemaining) {\nbytesToRead = (int) bytesRemaining;\n}\nfinal int bytesRead = file.read(b, off, bytesToRead);\nif (bytesRead >= 0) {\nbytesRemaining -= bytesRead;\n}\nreturn bytesRead;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:close()V",
                                    "method_body": "public void close() {\n// the nested RandomAccessFile is controlled externally\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:<init>(Ljava/lang/String;I[B)V",
                                    "method_body": "private SevenZMethod(byte[] id) {\nthis.id = id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:<init>()V",
                                    "method_body": "public SevenZArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "public void setName(String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:hasStream()Z",
                                    "method_body": "public boolean hasStream() {\nreturn hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasStream(Z)V",
                                    "method_body": "public void setHasStream(boolean hasStream) {\nthis.hasStream = hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nreturn isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setDirectory(Z)V",
                                    "method_body": "public void setDirectory(boolean isDirectory) {\nthis.isDirectory = isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isAntiItem()Z",
                                    "method_body": "public boolean isAntiItem() {\nreturn isAntiItem;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasCreationDate()Z",
                                    "method_body": "public boolean getHasCreationDate() {\nreturn hasCreationDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasLastModifiedDate()Z",
                                    "method_body": "public boolean getHasLastModifiedDate() {\nreturn hasLastModifiedDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getLastModifiedDate()Ljava/util/Date;",
                                    "method_body": "public Date getLastModifiedDate() {\nif (hasLastModifiedDate) {\nreturn ntfsTimeToJavaTime(lastModifiedDate);\n} else {\nthrow new UnsupportedOperationException(\n\"The entry doesn't have this timestamp\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setLastModifiedDate(Ljava/util/Date;)V",
                                    "method_body": "public void setLastModifiedDate(Date lastModifiedDate) {\nhasLastModifiedDate = lastModifiedDate != null;\nif (hasLastModifiedDate) {\nthis.lastModifiedDate = javaTimeToNtfsTime(lastModifiedDate);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasAccessDate()Z",
                                    "method_body": "public boolean getHasAccessDate() {\nreturn hasAccessDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasWindowsAttributes()Z",
                                    "method_body": "public boolean getHasWindowsAttributes() {\nreturn hasWindowsAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasCrc(Z)V",
                                    "method_body": "public void setHasCrc(boolean hasCrc) {\nthis.hasCrc = hasCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCompressedSize(J)V",
                                    "method_body": "void setCompressedSize(long size) {\nthis.compressedSize = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:ntfsTimeToJavaTime(J)Ljava/util/Date;",
                                    "method_body": "public static Date ntfsTimeToJavaTime(final long ntfsTime) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nfinal long realTime = ntfsEpoch.getTimeInMillis() + (ntfsTime / (10*1000));\nreturn new Date(realTime);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:javaTimeToNtfsTime(Ljava/util/Date;)J",
                                    "method_body": "public static long javaTimeToNtfsTime(final Date date) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nreturn ((date.getTime() - ntfsEpoch.getTimeInMillis())* 1000 * 10);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZOutputFile(final File filename) throws IOException {\nfile = new RandomAccessFile(filename, \"rw\");\nfile.seek(SevenZFile.SIGNATURE_HEADER_SIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!finished) {\nfinish();\n}\nfile.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:createArchiveEntry(Ljava/io/File;Ljava/lang/String;)Lorg/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry;",
                                    "method_body": "public SevenZArchiveEntry createArchiveEntry(final File inputFile,\nfinal String entryName) throws IOException {\nfinal SevenZArchiveEntry entry = new SevenZArchiveEntry();\nentry.setDirectory(inputFile.isDirectory());\nentry.setName(entryName);\nentry.setLastModifiedDate(new Date(inputFile.lastModified()));\nreturn entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\nfinal SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;\nfiles.add(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (currentOutputStream != null) {\ncurrentOutputStream.flush();\ncurrentOutputStream.close();\n}\n\nfinal SevenZArchiveEntry entry = files.get(files.size() - 1);\nif (fileBytesWritten > 0) {\nentry.setHasStream(true);\n++numNonEmptyStreams;\nentry.setSize(currentOutputStream.getBytesWritten());\nentry.setCompressedSize(fileBytesWritten);\nentry.setCrcValue(crc32.getValue());\nentry.setCompressedCrcValue(compressedCrc32.getValue());\nentry.setHasCrc(true);\n} else {\nentry.setHasStream(false);\nentry.setSize(0);\nentry.setCompressedSize(0);\nentry.setHasCrc(false);\n}\ncurrentOutputStream = null;\ncrc32.reset();\ncompressedCrc32.reset();\nfileBytesWritten = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([B)V",
                                    "method_body": "public void write(final byte[] b) throws IOException {\nwrite(b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int off, final int len) throws IOException {\nif (len > 0) {\ngetCurrentOutputStream().write(b, off, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif (finished) {\nthrow new IOException(\"This archive has already been finished\");\n}\nfinished = true;\n\nfinal long headerPosition = file.getFilePointer();\n\nfinal ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();\nfinal DataOutputStream header = new DataOutputStream(headerBaos);\n\nwriteHeader(header);\nheader.flush();\nfinal byte[] headerBytes = headerBaos.toByteArray();\nfile.write(headerBytes);\n\nfinal CRC32 crc32 = new CRC32();\n\n// signature header\nfile.seek(0);\nfile.write(SevenZFile.sevenZSignature);\n// version\nfile.write(0);\nfile.write(2);\n\n// start header\nfinal ByteArrayOutputStream startHeaderBaos = new ByteArrayOutputStream();\nfinal DataOutputStream startHeaderStream = new DataOutputStream(startHeaderBaos);\nstartHeaderStream.writeLong(Long.reverseBytes(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE));\nstartHeaderStream.writeLong(Long.reverseBytes(0xffffFFFFL & headerBytes.length));\ncrc32.reset();\ncrc32.update(headerBytes);\nstartHeaderStream.writeInt(Integer.reverseBytes((int)crc32.getValue()));\nstartHeaderStream.flush();\nfinal byte[] startHeaderBytes = startHeaderBaos.toByteArray();\ncrc32.reset();\ncrc32.update(startHeaderBytes);\nfile.writeInt(Integer.reverseBytes((int) crc32.getValue()));\nfile.write(startHeaderBytes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeHeader(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeHeader(final DataOutput header) throws IOException {\nheader.write(NID.kHeader);\n\nheader.write(NID.kMainStreamsInfo);\nwriteStreamsInfo(header);\nwriteFilesInfo(header);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeStreamsInfo(final DataOutput header) throws IOException {\nif (numNonEmptyStreams > 0) {\nwritePackInfo(header);\nwriteUnpackInfo(header);\n}\n\nwriteSubStreamsInfo(header);\n\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeSubStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeSubStreamsInfo(final DataOutput header) throws IOException {\nheader.write(NID.kSubStreamsInfo);\n//\n//        header.write(NID.kCRC);\n//        header.write(1);\n//        for (final SevenZArchiveEntry entry : files) {\n//            if (entry.getHasCrc()) {\n//                header.writeInt(Integer.reverseBytes(entry.getCrc()));\n//            }\n//        }\n//\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFilesInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFilesInfo(final DataOutput header) throws IOException {\nheader.write(NID.kFilesInfo);\n\nwriteUint64(header, files.size());\n\nwriteFileEmptyStreams(header);\nwriteFileEmptyFiles(header);\nwriteFileAntiItems(header);\nwriteFileNames(header);\nwriteFileCTimes(header);\nwriteFileATimes(header);\nwriteFileMTimes(header);\nwriteFileWindowsAttributes(header);\nheader.write(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyStreams(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyStreams(final DataOutput header) throws IOException {\nboolean hasEmptyStreams = false;\nfor (final SevenZArchiveEntry entry : files) {\nif (!entry.hasStream()) {\nhasEmptyStreams = true;\nbreak;\n}\n}\nif (hasEmptyStreams) {\nheader.write(NID.kEmptyStream);\nfinal BitSet emptyStreams = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nemptyStreams.set(i, !files.get(i).hasStream());\n}\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyStreams, files.size());\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyFiles(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyFiles(final DataOutput header) throws IOException {\nboolean hasEmptyFiles = false;\nint emptyStreamCounter = 0;\nfinal BitSet emptyFiles = new BitSet(0);\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isDir = files.get(i).isDirectory();\nemptyFiles.set(emptyStreamCounter++, !isDir);\nhasEmptyFiles |= !isDir;\n}\n}\nif (hasEmptyFiles) {\nheader.write(NID.kEmptyFile);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyFiles, emptyStreamCounter);\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileAntiItems(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileAntiItems(final DataOutput header) throws IOException {\nboolean hasAntiItems = false;\nfinal BitSet antiItems = new BitSet(0);\nint antiItemCounter = 0;\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isAnti = files.get(i).isAntiItem();\nantiItems.set(antiItemCounter++, isAnti);\nhasAntiItems |= isAnti;\n}\n}\nif (hasAntiItems) {\nheader.write(NID.kAnti);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, antiItems, antiItemCounter);\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileNames(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileNames(final DataOutput header) throws IOException {\nheader.write(NID.kName);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nout.write(entry.getName().getBytes(\"UTF-16LE\"));\nout.writeShort(0);\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileCTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileCTimes(final DataOutput header) throws IOException {\nint numCreationDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasCreationDate()) {\n++numCreationDates;\n}\n}\nif (numCreationDates > 0) {\nheader.write(NID.kCTime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numCreationDates != files.size()) {\nout.write(0);\nfinal BitSet cTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\ncTimes.set(i, files.get(i).getHasCreationDate());\n}\nwriteBits(out, cTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasCreationDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getCreationDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileATimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileATimes(final DataOutput header) throws IOException {\nint numAccessDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasAccessDate()) {\n++numAccessDates;\n}\n}\nif (numAccessDates > 0) {\nheader.write(NID.kATime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numAccessDates != files.size()) {\nout.write(0);\nfinal BitSet aTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\naTimes.set(i, files.get(i).getHasAccessDate());\n}\nwriteBits(out, aTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasAccessDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getAccessDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileMTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileMTimes(final DataOutput header) throws IOException {\nint numLastModifiedDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\n++numLastModifiedDates;\n}\n}\nif (numLastModifiedDates > 0) {\nheader.write(NID.kMTime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numLastModifiedDates != files.size()) {\nout.write(0);\nfinal BitSet mTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nmTimes.set(i, files.get(i).getHasLastModifiedDate());\n}\nwriteBits(out, mTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getLastModifiedDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileWindowsAttributes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileWindowsAttributes(final DataOutput header) throws IOException {\nint numWindowsAttributes = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasWindowsAttributes()) {\n++numWindowsAttributes;\n}\n}\nif (numWindowsAttributes > 0) {\nheader.write(NID.kWinAttributes);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numWindowsAttributes != files.size()) {\nout.write(0);\nfinal BitSet attributes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nattributes.set(i, files.get(i).getHasWindowsAttributes());\n}\nwriteBits(out, attributes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasWindowsAttributes()) {\nout.writeInt(Integer.reverseBytes(entry.getWindowsAttributes()));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeUint64(Ljava/io/DataOutput;J)V",
                                    "method_body": "private void writeUint64(final DataOutput header, long value) throws IOException {\nint firstByte = 0;\nint mask = 0x80;\nint i;\nfor (i = 0; i < 8; i++) {\nif (value < ((1L << ( 7  * (i + 1))))) {\nfirstByte |= (value >>> (8 * i));\nbreak;\n}\nfirstByte |= mask;\nmask >>>= 1;\n}\nheader.write(firstByte);\nfor (; i > 0; i--) {\nheader.write((int) (0xff & value));\nvalue >>>= 8;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeBits(Ljava/io/DataOutput;Ljava/util/BitSet;I)V",
                                    "method_body": "private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\nint cache = 0;\nint shift = 7;\nfor (int i = 0; i < length; i++) {\ncache |= ((bits.get(i) ? 1 : 0) << shift);\n--shift;\nif (shift == 0) {\nheader.write(cache);\nshift = 7;\ncache = 0;\n}\n}\nif (length > 0 && shift > 0) {\nheader.write(cache);\n}\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest.testNineEmptyFiles",
                            "test_body": "198: public void testNineEmptyFiles() throws Exception {\n199: testCompress252(9, 0);\n200: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;[B)V",
                                    "method_body": "public SevenZFile(final File filename, final byte[] password) throws IOException {\nboolean succeeded = false;\nthis.file = new RandomAccessFile(filename, \"r\");\ntry {\narchive = readHeaders(password);\nif (password != null) {\nthis.password = new byte[password.length];\nSystem.arraycopy(password, 0, this.password, 0, password.length);\n} else {\nthis.password = null;\n}\nsucceeded = true;\n} finally {\nif (!succeeded) {\nthis.file.close();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZFile(final File filename) throws IOException {\nthis(filename, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<clinit>()V",
                                    "method_body": "static final int SIGNATURE_HEADER_SIZE = 32;\n\nprivate static final int DRAIN_BUF_SIZE = 64 * 1024;\n\nprivate RandomAccessFile file;\nprivate final Archive archive;\nprivate int currentEntryIndex = -1;\nprivate int currentFolderIndex = -1;\nprivate InputStream currentFolderInputStream = null;\nprivate InputStream currentEntryInputStream = null;\nprivate byte[] password;\n\nstatic final byte[] sevenZSignature = {\n(byte)'7', (byte)'z', (byte)0xBC, (byte)0xAF, (byte)0x27, (byte)0x1C\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeaders([B)Lorg/apache/commons/compress/archivers/sevenz/Archive;",
                                    "method_body": "private Archive readHeaders(byte[] password) throws IOException {\nfinal byte[] signature = new byte[6];\nfile.readFully(signature);\nif (!Arrays.equals(signature, sevenZSignature)) {\nthrow new IOException(\"Bad 7z signature\");\n}\n// 7zFormat.txt has it wrong - it's first major then minor\nfinal byte archiveVersionMajor = file.readByte();\nfinal byte archiveVersionMinor = file.readByte();\nif (archiveVersionMajor != 0) {\nthrow new IOException(String.format(\"Unsupported 7z version (%d,%d)\",\narchiveVersionMajor, archiveVersionMinor));\n}\n\nfinal long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\nfinal StartHeader startHeader = readStartHeader(startHeaderCrc);\n\nfinal int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\nif (nextHeaderSizeInt != startHeader.nextHeaderSize) {\nthrow new IOException(\"cannot handle nextHeaderSize \" + startHeader.nextHeaderSize);\n}\nfile.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\nfinal byte[] nextHeader = new byte[nextHeaderSizeInt];\nfile.readFully(nextHeader);\nfinal CRC32 crc = new CRC32();\ncrc.update(nextHeader);\nif (startHeader.nextHeaderCrc != crc.getValue()) {\nthrow new IOException(\"NextHeader CRC mismatch\");\n}\n\nfinal ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\nDataInputStream nextHeaderInputStream = new DataInputStream(\nbyteStream);\nArchive archive = new Archive();\nint nid = nextHeaderInputStream.readUnsignedByte();\nif (nid == NID.kEncodedHeader) {\nnextHeaderInputStream =\nreadEncodedHeader(nextHeaderInputStream, archive, password);\n// Archive gets rebuilt with the new header\narchive = new Archive();\nnid = nextHeaderInputStream.readUnsignedByte();\n}\nif (nid == NID.kHeader) {\nreadHeader(nextHeaderInputStream, archive);\nnextHeaderInputStream.close();\n} else {\nthrow new IOException(\"Broken or unsupported archive: no Header\");\n}\nreturn archive;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStartHeader(J)Lorg/apache/commons/compress/archivers/sevenz/StartHeader;",
                                    "method_body": "private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\nfinal StartHeader startHeader = new StartHeader();\nDataInputStream dataInputStream = null;\ntry {\ndataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\nnew BoundedRandomAccessFileInputStream(file, 20), 20, startHeaderCrc));\nstartHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\nreturn startHeader;\n} finally {\nif (dataInputStream != null) {\ndataInputStream.close();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeader(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readHeader(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\n\nif (nid == NID.kArchiveProperties) {\nreadArchiveProperties(header);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kAdditionalStreamsInfo) {\nthrow new IOException(\"Additional streams unsupported\");\n//nid = header.readUnsignedByte();\n}\n\nif (nid == NID.kMainStreamsInfo) {\nreadStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kFilesInfo) {\nreadFilesInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated header\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\n\nif (nid == NID.kPackInfo) {\nreadPackInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kUnpackInfo) {\nreadUnpackInfo(header, archive);\nnid = header.readUnsignedByte();\n} else {\n// archive without unpack/coders info\narchive.folders = new Folder[0];\n}\n\nif (nid == NID.kSubStreamsInfo) {\nreadSubStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated StreamsInfo\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readSubStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nfor (final Folder folder : archive.folders) {\nfolder.numUnpackSubStreams = 1;\n}\nint totalUnpackStreams = archive.folders.length;\n\nint nid = header.readUnsignedByte();\nif (nid == NID.kNumUnpackStream) {\ntotalUnpackStreams = 0;\nfor (final Folder folder : archive.folders) {\nfinal long numStreams = readUint64(header);\nfolder.numUnpackSubStreams = (int)numStreams;\ntotalUnpackStreams += numStreams;\n}\nnid = header.readUnsignedByte();\n}\n\nfinal SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\nsubStreamsInfo.unpackSizes = new long[totalUnpackStreams];\nsubStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\nsubStreamsInfo.crcs = new long[totalUnpackStreams];\n\nint nextUnpackStream = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams == 0) {\ncontinue;\n}\nlong sum = 0;\nif (nid == NID.kSize) {\nfor (int i = 0; i < (folder.numUnpackSubStreams - 1); i++) {\nfinal long size = readUint64(header);\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = size;\nsum += size;\n}\n}\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;\n}\nif (nid == NID.kSize) {\nnid = header.readUnsignedByte();\n}\n\nint numDigests = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {\nnumDigests += folder.numUnpackSubStreams;\n}\n}\n\nif (nid == NID.kCRC) {\nfinal BitSet hasMissingCrc = readAllOrBits(header, numDigests);\nfinal long[] missingCrcs = new long[numDigests];\nfor (int i = 0; i < numDigests; i++) {\nif (hasMissingCrc.get(i)) {\nmissingCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n}\n}\nint nextCrc = 0;\nint nextMissingCrc = 0;\nfor (final Folder folder: archive.folders) {\nif (folder.numUnpackSubStreams == 1 && folder.hasCrc) {\nsubStreamsInfo.hasCrc.set(nextCrc, true);\nsubStreamsInfo.crcs[nextCrc] = folder.crc;\n++nextCrc;\n} else {\nfor (int i = 0; i < folder.numUnpackSubStreams; i++) {\nsubStreamsInfo.hasCrc.set(nextCrc, hasMissingCrc.get(nextMissingCrc));\nsubStreamsInfo.crcs[nextCrc] = missingCrcs[nextMissingCrc];\n++nextCrc;\n++nextMissingCrc;\n}\n}\n}\n\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated SubStreamsInfo\");\n}\n\narchive.subStreamsInfo = subStreamsInfo;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readBits(final DataInput header, final int size) throws IOException {\nfinal BitSet bits = new BitSet(size);\nint mask = 0;\nint cache = 0;\nfor (int i = 0; i < size; i++) {\nif (mask == 0) {\nmask = 0x80;\ncache = header.readUnsignedByte();\n}\nbits.set(i, (cache & mask) != 0);\nmask >>>= 1;\n}\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFilesInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readFilesInfo(final DataInput header, final Archive archive) throws IOException {\nfinal long numFiles = readUint64(header);\nfinal SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\nfor (int i = 0; i < files.length; i++) {\nfiles[i] = new SevenZArchiveEntry();\n}\nBitSet isEmptyStream = null;\nBitSet isEmptyFile = null;\nBitSet isAnti = null;\nwhile (true) {\nfinal int propertyType = header.readUnsignedByte();\nif (propertyType == 0) {\nbreak;\n}\nlong size = readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream: {\nisEmptyStream = readBits(header, files.length);\nbreak;\n}\ncase NID.kEmptyFile: {\nif (isEmptyStream == null) { // protect against NPE\nthrow new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n}\nisEmptyFile = readBits(header, isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kAnti: {\nif (isEmptyStream == null) { // protect against NPE\nthrow new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n}\nisAnti = readBits(header, isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kName: {\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Not implemented\");\n} else {\nif (((size - 1) & 1) != 0) {\nthrow new IOException(\"File names length invalid\");\n}\nfinal byte[] names = new byte[(int)(size - 1)];\nheader.readFully(names);\nint nextFile = 0;\nint nextName = 0;\nfor (int i = 0; i < names.length; i += 2) {\nif (names[i] == 0 && names[i+1] == 0) {\nfiles[nextFile++].setName(new String(names, nextName, i-nextName, CharsetNames.UTF_16LE));\nnextName = i + 2;\n}\n}\nif (nextName != names.length || nextFile != files.length) {\nthrow new IOException(\"Error parsing file names\");\n}\n}\nbreak;\n}\ncase NID.kCTime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasCreationDate(timesDefined.get(i));\nif (files[i].getHasCreationDate()) {\nfiles[i].setCreationDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kATime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasAccessDate(timesDefined.get(i));\nif (files[i].getHasAccessDate()) {\nfiles[i].setAccessDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kMTime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasLastModifiedDate(timesDefined.get(i));\nif (files[i].getHasLastModifiedDate()) {\nfiles[i].setLastModifiedDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kWinAttributes: {\nfinal BitSet attributesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasWindowsAttributes(attributesDefined.get(i));\nif (files[i].getHasWindowsAttributes()) {\nfiles[i].setWindowsAttributes(Integer.reverseBytes(header.readInt()));\n}\n}\n}\nbreak;\n}\ncase NID.kStartPos: {\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy: {\nthrow new IOException(\"kDummy is unsupported, please report\");\n}\n\ndefault: {\nthrow new IOException(\"Unknown property \" + propertyType);\n// FIXME: Should actually:\n//header.skipBytes((int)size);\n}\n}\n}\nint nonEmptyFileCounter = 0;\nint emptyFileCounter = 0;\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasStream((isEmptyStream == null) ? true : !isEmptyStream.get(i));\nif (files[i].hasStream()) {\nfiles[i].setDirectory(false);\nfiles[i].setAntiItem(false);\nfiles[i].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nfiles[i].setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nfiles[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n} else {\nfiles[i].setDirectory((isEmptyFile == null) ? true : !isEmptyFile.get(emptyFileCounter));\nfiles[i].setAntiItem((isAnti == null) ? false : isAnti.get(emptyFileCounter));\nfiles[i].setHasCrc(false);\nfiles[i].setSize(0);\n++emptyFileCounter;\n}\n}\narchive.files = files;\ncalculateStreamMap(archive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUint64(Ljava/io/DataInput;)J",
                                    "method_body": "private static long readUint64(final DataInput in) throws IOException {\n// long rather than int as it might get shifted beyond the range of an int\nlong firstByte = in.readUnsignedByte();\nint mask = 0x80;\nlong value = 0;\nfor (int i = 0; i < 8; i++) {\nif ((firstByte & mask) == 0) {\nreturn value | ((firstByte & (mask - 1)) << (8 * i));\n}\nlong nextByte = in.readUnsignedByte();\nvalue |= (nextByte << (8 * i));\nmask >>>= 1;\n}\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;JJ)V",
                                    "method_body": "public ChecksumVerifyingInputStream(final Checksum checksum, final InputStream in,\nfinal long size, final long expectedChecksum) {\nthis.checksum = checksum;\nthis.in = in;\nthis.expectedChecksum = expectedChecksum;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining <= 0) {\nreturn -1;\n}\nint ret = in.read();\nif (ret >= 0) {\nchecksum.update(ret);\n--bytesRemaining;\n}\nif (bytesRemaining == 0 && expectedChecksum != checksum.getValue()) {\nthrow new IOException(\"Checksum verification failed\");\n}\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nint ret = in.read(b, off, len);\nif (ret >= 0) {\nchecksum.update(b, off, ret);\nbytesRemaining -= ret;\n}\nif (bytesRemaining <= 0 && expectedChecksum != checksum.getValue()) {\nthrow new IOException(\"Checksum verification failed\");\n}\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nin.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CRC32VerifyingInputStream:<init>(Ljava/io/InputStream;JJ)V",
                                    "method_body": "public CRC32VerifyingInputStream(final InputStream in, final long size, final long expectedCrc32) {\nsuper(new CRC32(), in, size, expectedCrc32);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:<init>(Ljava/io/RandomAccessFile;J)V",
                                    "method_body": "public BoundedRandomAccessFileInputStream(final RandomAccessFile file,\nfinal long size) {\nthis.file = file;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining > 0) {\n--bytesRemaining;\nreturn file.read();\n} else {\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif (bytesRemaining == 0) {\nreturn -1;\n}\nint bytesToRead = len;\nif (bytesToRead > bytesRemaining) {\nbytesToRead = (int) bytesRemaining;\n}\nfinal int bytesRead = file.read(b, off, bytesToRead);\nif (bytesRead >= 0) {\nbytesRemaining -= bytesRead;\n}\nreturn bytesRead;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:close()V",
                                    "method_body": "public void close() {\n// the nested RandomAccessFile is controlled externally\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:<init>(Ljava/lang/String;I[B)V",
                                    "method_body": "private SevenZMethod(byte[] id) {\nthis.id = id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:<init>()V",
                                    "method_body": "public SevenZArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "public void setName(String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:hasStream()Z",
                                    "method_body": "public boolean hasStream() {\nreturn hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasStream(Z)V",
                                    "method_body": "public void setHasStream(boolean hasStream) {\nthis.hasStream = hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nreturn isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setDirectory(Z)V",
                                    "method_body": "public void setDirectory(boolean isDirectory) {\nthis.isDirectory = isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isAntiItem()Z",
                                    "method_body": "public boolean isAntiItem() {\nreturn isAntiItem;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasCreationDate()Z",
                                    "method_body": "public boolean getHasCreationDate() {\nreturn hasCreationDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasLastModifiedDate()Z",
                                    "method_body": "public boolean getHasLastModifiedDate() {\nreturn hasLastModifiedDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getLastModifiedDate()Ljava/util/Date;",
                                    "method_body": "public Date getLastModifiedDate() {\nif (hasLastModifiedDate) {\nreturn ntfsTimeToJavaTime(lastModifiedDate);\n} else {\nthrow new UnsupportedOperationException(\n\"The entry doesn't have this timestamp\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setLastModifiedDate(Ljava/util/Date;)V",
                                    "method_body": "public void setLastModifiedDate(Date lastModifiedDate) {\nhasLastModifiedDate = lastModifiedDate != null;\nif (hasLastModifiedDate) {\nthis.lastModifiedDate = javaTimeToNtfsTime(lastModifiedDate);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasAccessDate()Z",
                                    "method_body": "public boolean getHasAccessDate() {\nreturn hasAccessDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasWindowsAttributes()Z",
                                    "method_body": "public boolean getHasWindowsAttributes() {\nreturn hasWindowsAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasCrc(Z)V",
                                    "method_body": "public void setHasCrc(boolean hasCrc) {\nthis.hasCrc = hasCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCompressedSize(J)V",
                                    "method_body": "void setCompressedSize(long size) {\nthis.compressedSize = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:ntfsTimeToJavaTime(J)Ljava/util/Date;",
                                    "method_body": "public static Date ntfsTimeToJavaTime(final long ntfsTime) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nfinal long realTime = ntfsEpoch.getTimeInMillis() + (ntfsTime / (10*1000));\nreturn new Date(realTime);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:javaTimeToNtfsTime(Ljava/util/Date;)J",
                                    "method_body": "public static long javaTimeToNtfsTime(final Date date) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nreturn ((date.getTime() - ntfsEpoch.getTimeInMillis())* 1000 * 10);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZOutputFile(final File filename) throws IOException {\nfile = new RandomAccessFile(filename, \"rw\");\nfile.seek(SevenZFile.SIGNATURE_HEADER_SIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!finished) {\nfinish();\n}\nfile.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:createArchiveEntry(Ljava/io/File;Ljava/lang/String;)Lorg/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry;",
                                    "method_body": "public SevenZArchiveEntry createArchiveEntry(final File inputFile,\nfinal String entryName) throws IOException {\nfinal SevenZArchiveEntry entry = new SevenZArchiveEntry();\nentry.setDirectory(inputFile.isDirectory());\nentry.setName(entryName);\nentry.setLastModifiedDate(new Date(inputFile.lastModified()));\nreturn entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\nfinal SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;\nfiles.add(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (currentOutputStream != null) {\ncurrentOutputStream.flush();\ncurrentOutputStream.close();\n}\n\nfinal SevenZArchiveEntry entry = files.get(files.size() - 1);\nif (fileBytesWritten > 0) {\nentry.setHasStream(true);\n++numNonEmptyStreams;\nentry.setSize(currentOutputStream.getBytesWritten());\nentry.setCompressedSize(fileBytesWritten);\nentry.setCrcValue(crc32.getValue());\nentry.setCompressedCrcValue(compressedCrc32.getValue());\nentry.setHasCrc(true);\n} else {\nentry.setHasStream(false);\nentry.setSize(0);\nentry.setCompressedSize(0);\nentry.setHasCrc(false);\n}\ncurrentOutputStream = null;\ncrc32.reset();\ncompressedCrc32.reset();\nfileBytesWritten = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([B)V",
                                    "method_body": "public void write(final byte[] b) throws IOException {\nwrite(b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int off, final int len) throws IOException {\nif (len > 0) {\ngetCurrentOutputStream().write(b, off, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif (finished) {\nthrow new IOException(\"This archive has already been finished\");\n}\nfinished = true;\n\nfinal long headerPosition = file.getFilePointer();\n\nfinal ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();\nfinal DataOutputStream header = new DataOutputStream(headerBaos);\n\nwriteHeader(header);\nheader.flush();\nfinal byte[] headerBytes = headerBaos.toByteArray();\nfile.write(headerBytes);\n\nfinal CRC32 crc32 = new CRC32();\n\n// signature header\nfile.seek(0);\nfile.write(SevenZFile.sevenZSignature);\n// version\nfile.write(0);\nfile.write(2);\n\n// start header\nfinal ByteArrayOutputStream startHeaderBaos = new ByteArrayOutputStream();\nfinal DataOutputStream startHeaderStream = new DataOutputStream(startHeaderBaos);\nstartHeaderStream.writeLong(Long.reverseBytes(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE));\nstartHeaderStream.writeLong(Long.reverseBytes(0xffffFFFFL & headerBytes.length));\ncrc32.reset();\ncrc32.update(headerBytes);\nstartHeaderStream.writeInt(Integer.reverseBytes((int)crc32.getValue()));\nstartHeaderStream.flush();\nfinal byte[] startHeaderBytes = startHeaderBaos.toByteArray();\ncrc32.reset();\ncrc32.update(startHeaderBytes);\nfile.writeInt(Integer.reverseBytes((int) crc32.getValue()));\nfile.write(startHeaderBytes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeHeader(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeHeader(final DataOutput header) throws IOException {\nheader.write(NID.kHeader);\n\nheader.write(NID.kMainStreamsInfo);\nwriteStreamsInfo(header);\nwriteFilesInfo(header);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeStreamsInfo(final DataOutput header) throws IOException {\nif (numNonEmptyStreams > 0) {\nwritePackInfo(header);\nwriteUnpackInfo(header);\n}\n\nwriteSubStreamsInfo(header);\n\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeSubStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeSubStreamsInfo(final DataOutput header) throws IOException {\nheader.write(NID.kSubStreamsInfo);\n//\n//        header.write(NID.kCRC);\n//        header.write(1);\n//        for (final SevenZArchiveEntry entry : files) {\n//            if (entry.getHasCrc()) {\n//                header.writeInt(Integer.reverseBytes(entry.getCrc()));\n//            }\n//        }\n//\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFilesInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFilesInfo(final DataOutput header) throws IOException {\nheader.write(NID.kFilesInfo);\n\nwriteUint64(header, files.size());\n\nwriteFileEmptyStreams(header);\nwriteFileEmptyFiles(header);\nwriteFileAntiItems(header);\nwriteFileNames(header);\nwriteFileCTimes(header);\nwriteFileATimes(header);\nwriteFileMTimes(header);\nwriteFileWindowsAttributes(header);\nheader.write(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyStreams(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyStreams(final DataOutput header) throws IOException {\nboolean hasEmptyStreams = false;\nfor (final SevenZArchiveEntry entry : files) {\nif (!entry.hasStream()) {\nhasEmptyStreams = true;\nbreak;\n}\n}\nif (hasEmptyStreams) {\nheader.write(NID.kEmptyStream);\nfinal BitSet emptyStreams = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nemptyStreams.set(i, !files.get(i).hasStream());\n}\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyStreams, files.size());\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyFiles(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyFiles(final DataOutput header) throws IOException {\nboolean hasEmptyFiles = false;\nint emptyStreamCounter = 0;\nfinal BitSet emptyFiles = new BitSet(0);\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isDir = files.get(i).isDirectory();\nemptyFiles.set(emptyStreamCounter++, !isDir);\nhasEmptyFiles |= !isDir;\n}\n}\nif (hasEmptyFiles) {\nheader.write(NID.kEmptyFile);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyFiles, emptyStreamCounter);\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileAntiItems(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileAntiItems(final DataOutput header) throws IOException {\nboolean hasAntiItems = false;\nfinal BitSet antiItems = new BitSet(0);\nint antiItemCounter = 0;\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isAnti = files.get(i).isAntiItem();\nantiItems.set(antiItemCounter++, isAnti);\nhasAntiItems |= isAnti;\n}\n}\nif (hasAntiItems) {\nheader.write(NID.kAnti);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, antiItems, antiItemCounter);\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileNames(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileNames(final DataOutput header) throws IOException {\nheader.write(NID.kName);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nout.write(entry.getName().getBytes(\"UTF-16LE\"));\nout.writeShort(0);\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileCTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileCTimes(final DataOutput header) throws IOException {\nint numCreationDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasCreationDate()) {\n++numCreationDates;\n}\n}\nif (numCreationDates > 0) {\nheader.write(NID.kCTime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numCreationDates != files.size()) {\nout.write(0);\nfinal BitSet cTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\ncTimes.set(i, files.get(i).getHasCreationDate());\n}\nwriteBits(out, cTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasCreationDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getCreationDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileATimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileATimes(final DataOutput header) throws IOException {\nint numAccessDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasAccessDate()) {\n++numAccessDates;\n}\n}\nif (numAccessDates > 0) {\nheader.write(NID.kATime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numAccessDates != files.size()) {\nout.write(0);\nfinal BitSet aTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\naTimes.set(i, files.get(i).getHasAccessDate());\n}\nwriteBits(out, aTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasAccessDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getAccessDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileMTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileMTimes(final DataOutput header) throws IOException {\nint numLastModifiedDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\n++numLastModifiedDates;\n}\n}\nif (numLastModifiedDates > 0) {\nheader.write(NID.kMTime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numLastModifiedDates != files.size()) {\nout.write(0);\nfinal BitSet mTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nmTimes.set(i, files.get(i).getHasLastModifiedDate());\n}\nwriteBits(out, mTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getLastModifiedDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileWindowsAttributes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileWindowsAttributes(final DataOutput header) throws IOException {\nint numWindowsAttributes = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasWindowsAttributes()) {\n++numWindowsAttributes;\n}\n}\nif (numWindowsAttributes > 0) {\nheader.write(NID.kWinAttributes);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numWindowsAttributes != files.size()) {\nout.write(0);\nfinal BitSet attributes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nattributes.set(i, files.get(i).getHasWindowsAttributes());\n}\nwriteBits(out, attributes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasWindowsAttributes()) {\nout.writeInt(Integer.reverseBytes(entry.getWindowsAttributes()));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeUint64(Ljava/io/DataOutput;J)V",
                                    "method_body": "private void writeUint64(final DataOutput header, long value) throws IOException {\nint firstByte = 0;\nint mask = 0x80;\nint i;\nfor (i = 0; i < 8; i++) {\nif (value < ((1L << ( 7  * (i + 1))))) {\nfirstByte |= (value >>> (8 * i));\nbreak;\n}\nfirstByte |= mask;\nmask >>>= 1;\n}\nheader.write(firstByte);\nfor (; i > 0; i--) {\nheader.write((int) (0xff & value));\nvalue >>>= 8;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeBits(Ljava/io/DataOutput;Ljava/util/BitSet;I)V",
                                    "method_body": "private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\nint cache = 0;\nint shift = 7;\nfor (int i = 0; i < length; i++) {\ncache |= ((bits.get(i) ? 1 : 0) << shift);\n--shift;\nif (shift == 0) {\nheader.write(cache);\nshift = 7;\ncache = 0;\n}\n}\nif (length > 0 && shift > 0) {\nheader.write(cache);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readAllOrBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readAllOrBits(final DataInput header, final int size) throws IOException {\nfinal int areAllDefined = header.readUnsignedByte();\nfinal BitSet bits;\nif (areAllDefined != 0) {\nbits = new BitSet(size);\nfor (int i = 0; i < size; i++) {\nbits.set(i, true);\n}\n} else {\nbits = readBits(header, size);\n}\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setAntiItem(Z)V",
                                    "method_body": "public void setAntiItem(boolean isAntiItem) {\nthis.isAntiItem = isAntiItem;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasLastModifiedDate(Z)V",
                                    "method_body": "public void setHasLastModifiedDate(boolean hasLastModifiedDate) {\nthis.hasLastModifiedDate = hasLastModifiedDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setLastModifiedDate(J)V",
                                    "method_body": "public void setLastModifiedDate(long ntfsLastModifiedDate) {\nthis.lastModifiedDate = ntfsLastModifiedDate;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest.testEightEmptyFiles",
                            "test_body": "190: public void testEightEmptyFiles() throws Exception {\n191: testCompress252(8, 0);\n192: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;[B)V",
                                    "method_body": "public SevenZFile(final File filename, final byte[] password) throws IOException {\nboolean succeeded = false;\nthis.file = new RandomAccessFile(filename, \"r\");\ntry {\narchive = readHeaders(password);\nif (password != null) {\nthis.password = new byte[password.length];\nSystem.arraycopy(password, 0, this.password, 0, password.length);\n} else {\nthis.password = null;\n}\nsucceeded = true;\n} finally {\nif (!succeeded) {\nthis.file.close();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZFile(final File filename) throws IOException {\nthis(filename, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<clinit>()V",
                                    "method_body": "static final int SIGNATURE_HEADER_SIZE = 32;\n\nprivate static final int DRAIN_BUF_SIZE = 64 * 1024;\n\nprivate RandomAccessFile file;\nprivate final Archive archive;\nprivate int currentEntryIndex = -1;\nprivate int currentFolderIndex = -1;\nprivate InputStream currentFolderInputStream = null;\nprivate InputStream currentEntryInputStream = null;\nprivate byte[] password;\n\nstatic final byte[] sevenZSignature = {\n(byte)'7', (byte)'z', (byte)0xBC, (byte)0xAF, (byte)0x27, (byte)0x1C\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeaders([B)Lorg/apache/commons/compress/archivers/sevenz/Archive;",
                                    "method_body": "private Archive readHeaders(byte[] password) throws IOException {\nfinal byte[] signature = new byte[6];\nfile.readFully(signature);\nif (!Arrays.equals(signature, sevenZSignature)) {\nthrow new IOException(\"Bad 7z signature\");\n}\n// 7zFormat.txt has it wrong - it's first major then minor\nfinal byte archiveVersionMajor = file.readByte();\nfinal byte archiveVersionMinor = file.readByte();\nif (archiveVersionMajor != 0) {\nthrow new IOException(String.format(\"Unsupported 7z version (%d,%d)\",\narchiveVersionMajor, archiveVersionMinor));\n}\n\nfinal long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\nfinal StartHeader startHeader = readStartHeader(startHeaderCrc);\n\nfinal int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\nif (nextHeaderSizeInt != startHeader.nextHeaderSize) {\nthrow new IOException(\"cannot handle nextHeaderSize \" + startHeader.nextHeaderSize);\n}\nfile.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\nfinal byte[] nextHeader = new byte[nextHeaderSizeInt];\nfile.readFully(nextHeader);\nfinal CRC32 crc = new CRC32();\ncrc.update(nextHeader);\nif (startHeader.nextHeaderCrc != crc.getValue()) {\nthrow new IOException(\"NextHeader CRC mismatch\");\n}\n\nfinal ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\nDataInputStream nextHeaderInputStream = new DataInputStream(\nbyteStream);\nArchive archive = new Archive();\nint nid = nextHeaderInputStream.readUnsignedByte();\nif (nid == NID.kEncodedHeader) {\nnextHeaderInputStream =\nreadEncodedHeader(nextHeaderInputStream, archive, password);\n// Archive gets rebuilt with the new header\narchive = new Archive();\nnid = nextHeaderInputStream.readUnsignedByte();\n}\nif (nid == NID.kHeader) {\nreadHeader(nextHeaderInputStream, archive);\nnextHeaderInputStream.close();\n} else {\nthrow new IOException(\"Broken or unsupported archive: no Header\");\n}\nreturn archive;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStartHeader(J)Lorg/apache/commons/compress/archivers/sevenz/StartHeader;",
                                    "method_body": "private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\nfinal StartHeader startHeader = new StartHeader();\nDataInputStream dataInputStream = null;\ntry {\ndataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\nnew BoundedRandomAccessFileInputStream(file, 20), 20, startHeaderCrc));\nstartHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\nreturn startHeader;\n} finally {\nif (dataInputStream != null) {\ndataInputStream.close();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeader(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readHeader(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\n\nif (nid == NID.kArchiveProperties) {\nreadArchiveProperties(header);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kAdditionalStreamsInfo) {\nthrow new IOException(\"Additional streams unsupported\");\n//nid = header.readUnsignedByte();\n}\n\nif (nid == NID.kMainStreamsInfo) {\nreadStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kFilesInfo) {\nreadFilesInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated header\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\n\nif (nid == NID.kPackInfo) {\nreadPackInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kUnpackInfo) {\nreadUnpackInfo(header, archive);\nnid = header.readUnsignedByte();\n} else {\n// archive without unpack/coders info\narchive.folders = new Folder[0];\n}\n\nif (nid == NID.kSubStreamsInfo) {\nreadSubStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated StreamsInfo\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readSubStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nfor (final Folder folder : archive.folders) {\nfolder.numUnpackSubStreams = 1;\n}\nint totalUnpackStreams = archive.folders.length;\n\nint nid = header.readUnsignedByte();\nif (nid == NID.kNumUnpackStream) {\ntotalUnpackStreams = 0;\nfor (final Folder folder : archive.folders) {\nfinal long numStreams = readUint64(header);\nfolder.numUnpackSubStreams = (int)numStreams;\ntotalUnpackStreams += numStreams;\n}\nnid = header.readUnsignedByte();\n}\n\nfinal SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\nsubStreamsInfo.unpackSizes = new long[totalUnpackStreams];\nsubStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\nsubStreamsInfo.crcs = new long[totalUnpackStreams];\n\nint nextUnpackStream = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams == 0) {\ncontinue;\n}\nlong sum = 0;\nif (nid == NID.kSize) {\nfor (int i = 0; i < (folder.numUnpackSubStreams - 1); i++) {\nfinal long size = readUint64(header);\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = size;\nsum += size;\n}\n}\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;\n}\nif (nid == NID.kSize) {\nnid = header.readUnsignedByte();\n}\n\nint numDigests = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {\nnumDigests += folder.numUnpackSubStreams;\n}\n}\n\nif (nid == NID.kCRC) {\nfinal BitSet hasMissingCrc = readAllOrBits(header, numDigests);\nfinal long[] missingCrcs = new long[numDigests];\nfor (int i = 0; i < numDigests; i++) {\nif (hasMissingCrc.get(i)) {\nmissingCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n}\n}\nint nextCrc = 0;\nint nextMissingCrc = 0;\nfor (final Folder folder: archive.folders) {\nif (folder.numUnpackSubStreams == 1 && folder.hasCrc) {\nsubStreamsInfo.hasCrc.set(nextCrc, true);\nsubStreamsInfo.crcs[nextCrc] = folder.crc;\n++nextCrc;\n} else {\nfor (int i = 0; i < folder.numUnpackSubStreams; i++) {\nsubStreamsInfo.hasCrc.set(nextCrc, hasMissingCrc.get(nextMissingCrc));\nsubStreamsInfo.crcs[nextCrc] = missingCrcs[nextMissingCrc];\n++nextCrc;\n++nextMissingCrc;\n}\n}\n}\n\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated SubStreamsInfo\");\n}\n\narchive.subStreamsInfo = subStreamsInfo;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readBits(final DataInput header, final int size) throws IOException {\nfinal BitSet bits = new BitSet(size);\nint mask = 0;\nint cache = 0;\nfor (int i = 0; i < size; i++) {\nif (mask == 0) {\nmask = 0x80;\ncache = header.readUnsignedByte();\n}\nbits.set(i, (cache & mask) != 0);\nmask >>>= 1;\n}\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFilesInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readFilesInfo(final DataInput header, final Archive archive) throws IOException {\nfinal long numFiles = readUint64(header);\nfinal SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\nfor (int i = 0; i < files.length; i++) {\nfiles[i] = new SevenZArchiveEntry();\n}\nBitSet isEmptyStream = null;\nBitSet isEmptyFile = null;\nBitSet isAnti = null;\nwhile (true) {\nfinal int propertyType = header.readUnsignedByte();\nif (propertyType == 0) {\nbreak;\n}\nlong size = readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream: {\nisEmptyStream = readBits(header, files.length);\nbreak;\n}\ncase NID.kEmptyFile: {\nif (isEmptyStream == null) { // protect against NPE\nthrow new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n}\nisEmptyFile = readBits(header, isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kAnti: {\nif (isEmptyStream == null) { // protect against NPE\nthrow new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n}\nisAnti = readBits(header, isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kName: {\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Not implemented\");\n} else {\nif (((size - 1) & 1) != 0) {\nthrow new IOException(\"File names length invalid\");\n}\nfinal byte[] names = new byte[(int)(size - 1)];\nheader.readFully(names);\nint nextFile = 0;\nint nextName = 0;\nfor (int i = 0; i < names.length; i += 2) {\nif (names[i] == 0 && names[i+1] == 0) {\nfiles[nextFile++].setName(new String(names, nextName, i-nextName, CharsetNames.UTF_16LE));\nnextName = i + 2;\n}\n}\nif (nextName != names.length || nextFile != files.length) {\nthrow new IOException(\"Error parsing file names\");\n}\n}\nbreak;\n}\ncase NID.kCTime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasCreationDate(timesDefined.get(i));\nif (files[i].getHasCreationDate()) {\nfiles[i].setCreationDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kATime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasAccessDate(timesDefined.get(i));\nif (files[i].getHasAccessDate()) {\nfiles[i].setAccessDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kMTime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasLastModifiedDate(timesDefined.get(i));\nif (files[i].getHasLastModifiedDate()) {\nfiles[i].setLastModifiedDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kWinAttributes: {\nfinal BitSet attributesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasWindowsAttributes(attributesDefined.get(i));\nif (files[i].getHasWindowsAttributes()) {\nfiles[i].setWindowsAttributes(Integer.reverseBytes(header.readInt()));\n}\n}\n}\nbreak;\n}\ncase NID.kStartPos: {\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy: {\nthrow new IOException(\"kDummy is unsupported, please report\");\n}\n\ndefault: {\nthrow new IOException(\"Unknown property \" + propertyType);\n// FIXME: Should actually:\n//header.skipBytes((int)size);\n}\n}\n}\nint nonEmptyFileCounter = 0;\nint emptyFileCounter = 0;\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasStream((isEmptyStream == null) ? true : !isEmptyStream.get(i));\nif (files[i].hasStream()) {\nfiles[i].setDirectory(false);\nfiles[i].setAntiItem(false);\nfiles[i].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nfiles[i].setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nfiles[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n} else {\nfiles[i].setDirectory((isEmptyFile == null) ? true : !isEmptyFile.get(emptyFileCounter));\nfiles[i].setAntiItem((isAnti == null) ? false : isAnti.get(emptyFileCounter));\nfiles[i].setHasCrc(false);\nfiles[i].setSize(0);\n++emptyFileCounter;\n}\n}\narchive.files = files;\ncalculateStreamMap(archive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUint64(Ljava/io/DataInput;)J",
                                    "method_body": "private static long readUint64(final DataInput in) throws IOException {\n// long rather than int as it might get shifted beyond the range of an int\nlong firstByte = in.readUnsignedByte();\nint mask = 0x80;\nlong value = 0;\nfor (int i = 0; i < 8; i++) {\nif ((firstByte & mask) == 0) {\nreturn value | ((firstByte & (mask - 1)) << (8 * i));\n}\nlong nextByte = in.readUnsignedByte();\nvalue |= (nextByte << (8 * i));\nmask >>>= 1;\n}\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;JJ)V",
                                    "method_body": "public ChecksumVerifyingInputStream(final Checksum checksum, final InputStream in,\nfinal long size, final long expectedChecksum) {\nthis.checksum = checksum;\nthis.in = in;\nthis.expectedChecksum = expectedChecksum;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining <= 0) {\nreturn -1;\n}\nint ret = in.read();\nif (ret >= 0) {\nchecksum.update(ret);\n--bytesRemaining;\n}\nif (bytesRemaining == 0 && expectedChecksum != checksum.getValue()) {\nthrow new IOException(\"Checksum verification failed\");\n}\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nint ret = in.read(b, off, len);\nif (ret >= 0) {\nchecksum.update(b, off, ret);\nbytesRemaining -= ret;\n}\nif (bytesRemaining <= 0 && expectedChecksum != checksum.getValue()) {\nthrow new IOException(\"Checksum verification failed\");\n}\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nin.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CRC32VerifyingInputStream:<init>(Ljava/io/InputStream;JJ)V",
                                    "method_body": "public CRC32VerifyingInputStream(final InputStream in, final long size, final long expectedCrc32) {\nsuper(new CRC32(), in, size, expectedCrc32);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:<init>(Ljava/io/RandomAccessFile;J)V",
                                    "method_body": "public BoundedRandomAccessFileInputStream(final RandomAccessFile file,\nfinal long size) {\nthis.file = file;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining > 0) {\n--bytesRemaining;\nreturn file.read();\n} else {\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif (bytesRemaining == 0) {\nreturn -1;\n}\nint bytesToRead = len;\nif (bytesToRead > bytesRemaining) {\nbytesToRead = (int) bytesRemaining;\n}\nfinal int bytesRead = file.read(b, off, bytesToRead);\nif (bytesRead >= 0) {\nbytesRemaining -= bytesRead;\n}\nreturn bytesRead;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:close()V",
                                    "method_body": "public void close() {\n// the nested RandomAccessFile is controlled externally\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:<init>(Ljava/lang/String;I[B)V",
                                    "method_body": "private SevenZMethod(byte[] id) {\nthis.id = id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:<init>()V",
                                    "method_body": "public SevenZArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "public void setName(String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:hasStream()Z",
                                    "method_body": "public boolean hasStream() {\nreturn hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasStream(Z)V",
                                    "method_body": "public void setHasStream(boolean hasStream) {\nthis.hasStream = hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nreturn isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setDirectory(Z)V",
                                    "method_body": "public void setDirectory(boolean isDirectory) {\nthis.isDirectory = isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isAntiItem()Z",
                                    "method_body": "public boolean isAntiItem() {\nreturn isAntiItem;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasCreationDate()Z",
                                    "method_body": "public boolean getHasCreationDate() {\nreturn hasCreationDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasLastModifiedDate()Z",
                                    "method_body": "public boolean getHasLastModifiedDate() {\nreturn hasLastModifiedDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getLastModifiedDate()Ljava/util/Date;",
                                    "method_body": "public Date getLastModifiedDate() {\nif (hasLastModifiedDate) {\nreturn ntfsTimeToJavaTime(lastModifiedDate);\n} else {\nthrow new UnsupportedOperationException(\n\"The entry doesn't have this timestamp\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setLastModifiedDate(Ljava/util/Date;)V",
                                    "method_body": "public void setLastModifiedDate(Date lastModifiedDate) {\nhasLastModifiedDate = lastModifiedDate != null;\nif (hasLastModifiedDate) {\nthis.lastModifiedDate = javaTimeToNtfsTime(lastModifiedDate);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasAccessDate()Z",
                                    "method_body": "public boolean getHasAccessDate() {\nreturn hasAccessDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasWindowsAttributes()Z",
                                    "method_body": "public boolean getHasWindowsAttributes() {\nreturn hasWindowsAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasCrc(Z)V",
                                    "method_body": "public void setHasCrc(boolean hasCrc) {\nthis.hasCrc = hasCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCompressedSize(J)V",
                                    "method_body": "void setCompressedSize(long size) {\nthis.compressedSize = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:ntfsTimeToJavaTime(J)Ljava/util/Date;",
                                    "method_body": "public static Date ntfsTimeToJavaTime(final long ntfsTime) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nfinal long realTime = ntfsEpoch.getTimeInMillis() + (ntfsTime / (10*1000));\nreturn new Date(realTime);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:javaTimeToNtfsTime(Ljava/util/Date;)J",
                                    "method_body": "public static long javaTimeToNtfsTime(final Date date) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nreturn ((date.getTime() - ntfsEpoch.getTimeInMillis())* 1000 * 10);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZOutputFile(final File filename) throws IOException {\nfile = new RandomAccessFile(filename, \"rw\");\nfile.seek(SevenZFile.SIGNATURE_HEADER_SIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!finished) {\nfinish();\n}\nfile.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:createArchiveEntry(Ljava/io/File;Ljava/lang/String;)Lorg/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry;",
                                    "method_body": "public SevenZArchiveEntry createArchiveEntry(final File inputFile,\nfinal String entryName) throws IOException {\nfinal SevenZArchiveEntry entry = new SevenZArchiveEntry();\nentry.setDirectory(inputFile.isDirectory());\nentry.setName(entryName);\nentry.setLastModifiedDate(new Date(inputFile.lastModified()));\nreturn entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\nfinal SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;\nfiles.add(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (currentOutputStream != null) {\ncurrentOutputStream.flush();\ncurrentOutputStream.close();\n}\n\nfinal SevenZArchiveEntry entry = files.get(files.size() - 1);\nif (fileBytesWritten > 0) {\nentry.setHasStream(true);\n++numNonEmptyStreams;\nentry.setSize(currentOutputStream.getBytesWritten());\nentry.setCompressedSize(fileBytesWritten);\nentry.setCrcValue(crc32.getValue());\nentry.setCompressedCrcValue(compressedCrc32.getValue());\nentry.setHasCrc(true);\n} else {\nentry.setHasStream(false);\nentry.setSize(0);\nentry.setCompressedSize(0);\nentry.setHasCrc(false);\n}\ncurrentOutputStream = null;\ncrc32.reset();\ncompressedCrc32.reset();\nfileBytesWritten = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([B)V",
                                    "method_body": "public void write(final byte[] b) throws IOException {\nwrite(b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int off, final int len) throws IOException {\nif (len > 0) {\ngetCurrentOutputStream().write(b, off, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif (finished) {\nthrow new IOException(\"This archive has already been finished\");\n}\nfinished = true;\n\nfinal long headerPosition = file.getFilePointer();\n\nfinal ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();\nfinal DataOutputStream header = new DataOutputStream(headerBaos);\n\nwriteHeader(header);\nheader.flush();\nfinal byte[] headerBytes = headerBaos.toByteArray();\nfile.write(headerBytes);\n\nfinal CRC32 crc32 = new CRC32();\n\n// signature header\nfile.seek(0);\nfile.write(SevenZFile.sevenZSignature);\n// version\nfile.write(0);\nfile.write(2);\n\n// start header\nfinal ByteArrayOutputStream startHeaderBaos = new ByteArrayOutputStream();\nfinal DataOutputStream startHeaderStream = new DataOutputStream(startHeaderBaos);\nstartHeaderStream.writeLong(Long.reverseBytes(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE));\nstartHeaderStream.writeLong(Long.reverseBytes(0xffffFFFFL & headerBytes.length));\ncrc32.reset();\ncrc32.update(headerBytes);\nstartHeaderStream.writeInt(Integer.reverseBytes((int)crc32.getValue()));\nstartHeaderStream.flush();\nfinal byte[] startHeaderBytes = startHeaderBaos.toByteArray();\ncrc32.reset();\ncrc32.update(startHeaderBytes);\nfile.writeInt(Integer.reverseBytes((int) crc32.getValue()));\nfile.write(startHeaderBytes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeHeader(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeHeader(final DataOutput header) throws IOException {\nheader.write(NID.kHeader);\n\nheader.write(NID.kMainStreamsInfo);\nwriteStreamsInfo(header);\nwriteFilesInfo(header);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeStreamsInfo(final DataOutput header) throws IOException {\nif (numNonEmptyStreams > 0) {\nwritePackInfo(header);\nwriteUnpackInfo(header);\n}\n\nwriteSubStreamsInfo(header);\n\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeSubStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeSubStreamsInfo(final DataOutput header) throws IOException {\nheader.write(NID.kSubStreamsInfo);\n//\n//        header.write(NID.kCRC);\n//        header.write(1);\n//        for (final SevenZArchiveEntry entry : files) {\n//            if (entry.getHasCrc()) {\n//                header.writeInt(Integer.reverseBytes(entry.getCrc()));\n//            }\n//        }\n//\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFilesInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFilesInfo(final DataOutput header) throws IOException {\nheader.write(NID.kFilesInfo);\n\nwriteUint64(header, files.size());\n\nwriteFileEmptyStreams(header);\nwriteFileEmptyFiles(header);\nwriteFileAntiItems(header);\nwriteFileNames(header);\nwriteFileCTimes(header);\nwriteFileATimes(header);\nwriteFileMTimes(header);\nwriteFileWindowsAttributes(header);\nheader.write(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyStreams(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyStreams(final DataOutput header) throws IOException {\nboolean hasEmptyStreams = false;\nfor (final SevenZArchiveEntry entry : files) {\nif (!entry.hasStream()) {\nhasEmptyStreams = true;\nbreak;\n}\n}\nif (hasEmptyStreams) {\nheader.write(NID.kEmptyStream);\nfinal BitSet emptyStreams = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nemptyStreams.set(i, !files.get(i).hasStream());\n}\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyStreams, files.size());\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyFiles(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyFiles(final DataOutput header) throws IOException {\nboolean hasEmptyFiles = false;\nint emptyStreamCounter = 0;\nfinal BitSet emptyFiles = new BitSet(0);\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isDir = files.get(i).isDirectory();\nemptyFiles.set(emptyStreamCounter++, !isDir);\nhasEmptyFiles |= !isDir;\n}\n}\nif (hasEmptyFiles) {\nheader.write(NID.kEmptyFile);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyFiles, emptyStreamCounter);\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileAntiItems(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileAntiItems(final DataOutput header) throws IOException {\nboolean hasAntiItems = false;\nfinal BitSet antiItems = new BitSet(0);\nint antiItemCounter = 0;\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isAnti = files.get(i).isAntiItem();\nantiItems.set(antiItemCounter++, isAnti);\nhasAntiItems |= isAnti;\n}\n}\nif (hasAntiItems) {\nheader.write(NID.kAnti);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, antiItems, antiItemCounter);\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileNames(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileNames(final DataOutput header) throws IOException {\nheader.write(NID.kName);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nout.write(entry.getName().getBytes(\"UTF-16LE\"));\nout.writeShort(0);\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileCTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileCTimes(final DataOutput header) throws IOException {\nint numCreationDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasCreationDate()) {\n++numCreationDates;\n}\n}\nif (numCreationDates > 0) {\nheader.write(NID.kCTime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numCreationDates != files.size()) {\nout.write(0);\nfinal BitSet cTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\ncTimes.set(i, files.get(i).getHasCreationDate());\n}\nwriteBits(out, cTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasCreationDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getCreationDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileATimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileATimes(final DataOutput header) throws IOException {\nint numAccessDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasAccessDate()) {\n++numAccessDates;\n}\n}\nif (numAccessDates > 0) {\nheader.write(NID.kATime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numAccessDates != files.size()) {\nout.write(0);\nfinal BitSet aTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\naTimes.set(i, files.get(i).getHasAccessDate());\n}\nwriteBits(out, aTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasAccessDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getAccessDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileMTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileMTimes(final DataOutput header) throws IOException {\nint numLastModifiedDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\n++numLastModifiedDates;\n}\n}\nif (numLastModifiedDates > 0) {\nheader.write(NID.kMTime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numLastModifiedDates != files.size()) {\nout.write(0);\nfinal BitSet mTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nmTimes.set(i, files.get(i).getHasLastModifiedDate());\n}\nwriteBits(out, mTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getLastModifiedDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileWindowsAttributes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileWindowsAttributes(final DataOutput header) throws IOException {\nint numWindowsAttributes = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasWindowsAttributes()) {\n++numWindowsAttributes;\n}\n}\nif (numWindowsAttributes > 0) {\nheader.write(NID.kWinAttributes);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numWindowsAttributes != files.size()) {\nout.write(0);\nfinal BitSet attributes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nattributes.set(i, files.get(i).getHasWindowsAttributes());\n}\nwriteBits(out, attributes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasWindowsAttributes()) {\nout.writeInt(Integer.reverseBytes(entry.getWindowsAttributes()));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeUint64(Ljava/io/DataOutput;J)V",
                                    "method_body": "private void writeUint64(final DataOutput header, long value) throws IOException {\nint firstByte = 0;\nint mask = 0x80;\nint i;\nfor (i = 0; i < 8; i++) {\nif (value < ((1L << ( 7  * (i + 1))))) {\nfirstByte |= (value >>> (8 * i));\nbreak;\n}\nfirstByte |= mask;\nmask >>>= 1;\n}\nheader.write(firstByte);\nfor (; i > 0; i--) {\nheader.write((int) (0xff & value));\nvalue >>>= 8;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeBits(Ljava/io/DataOutput;Ljava/util/BitSet;I)V",
                                    "method_body": "private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\nint cache = 0;\nint shift = 7;\nfor (int i = 0; i < length; i++) {\ncache |= ((bits.get(i) ? 1 : 0) << shift);\n--shift;\nif (shift == 0) {\nheader.write(cache);\nshift = 7;\ncache = 0;\n}\n}\nif (length > 0 && shift > 0) {\nheader.write(cache);\n}\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest.testSevenFilesSomeNotEmpty",
                            "test_body": "186: public void testSevenFilesSomeNotEmpty() throws Exception {\n187: testCompress252(7, 2);\n188: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;[B)V",
                                    "method_body": "public SevenZFile(final File filename, final byte[] password) throws IOException {\nboolean succeeded = false;\nthis.file = new RandomAccessFile(filename, \"r\");\ntry {\narchive = readHeaders(password);\nif (password != null) {\nthis.password = new byte[password.length];\nSystem.arraycopy(password, 0, this.password, 0, password.length);\n} else {\nthis.password = null;\n}\nsucceeded = true;\n} finally {\nif (!succeeded) {\nthis.file.close();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZFile(final File filename) throws IOException {\nthis(filename, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<clinit>()V",
                                    "method_body": "static final int SIGNATURE_HEADER_SIZE = 32;\n\nprivate static final int DRAIN_BUF_SIZE = 64 * 1024;\n\nprivate RandomAccessFile file;\nprivate final Archive archive;\nprivate int currentEntryIndex = -1;\nprivate int currentFolderIndex = -1;\nprivate InputStream currentFolderInputStream = null;\nprivate InputStream currentEntryInputStream = null;\nprivate byte[] password;\n\nstatic final byte[] sevenZSignature = {\n(byte)'7', (byte)'z', (byte)0xBC, (byte)0xAF, (byte)0x27, (byte)0x1C\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeaders([B)Lorg/apache/commons/compress/archivers/sevenz/Archive;",
                                    "method_body": "private Archive readHeaders(byte[] password) throws IOException {\nfinal byte[] signature = new byte[6];\nfile.readFully(signature);\nif (!Arrays.equals(signature, sevenZSignature)) {\nthrow new IOException(\"Bad 7z signature\");\n}\n// 7zFormat.txt has it wrong - it's first major then minor\nfinal byte archiveVersionMajor = file.readByte();\nfinal byte archiveVersionMinor = file.readByte();\nif (archiveVersionMajor != 0) {\nthrow new IOException(String.format(\"Unsupported 7z version (%d,%d)\",\narchiveVersionMajor, archiveVersionMinor));\n}\n\nfinal long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\nfinal StartHeader startHeader = readStartHeader(startHeaderCrc);\n\nfinal int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\nif (nextHeaderSizeInt != startHeader.nextHeaderSize) {\nthrow new IOException(\"cannot handle nextHeaderSize \" + startHeader.nextHeaderSize);\n}\nfile.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\nfinal byte[] nextHeader = new byte[nextHeaderSizeInt];\nfile.readFully(nextHeader);\nfinal CRC32 crc = new CRC32();\ncrc.update(nextHeader);\nif (startHeader.nextHeaderCrc != crc.getValue()) {\nthrow new IOException(\"NextHeader CRC mismatch\");\n}\n\nfinal ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\nDataInputStream nextHeaderInputStream = new DataInputStream(\nbyteStream);\nArchive archive = new Archive();\nint nid = nextHeaderInputStream.readUnsignedByte();\nif (nid == NID.kEncodedHeader) {\nnextHeaderInputStream =\nreadEncodedHeader(nextHeaderInputStream, archive, password);\n// Archive gets rebuilt with the new header\narchive = new Archive();\nnid = nextHeaderInputStream.readUnsignedByte();\n}\nif (nid == NID.kHeader) {\nreadHeader(nextHeaderInputStream, archive);\nnextHeaderInputStream.close();\n} else {\nthrow new IOException(\"Broken or unsupported archive: no Header\");\n}\nreturn archive;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStartHeader(J)Lorg/apache/commons/compress/archivers/sevenz/StartHeader;",
                                    "method_body": "private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\nfinal StartHeader startHeader = new StartHeader();\nDataInputStream dataInputStream = null;\ntry {\ndataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\nnew BoundedRandomAccessFileInputStream(file, 20), 20, startHeaderCrc));\nstartHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\nreturn startHeader;\n} finally {\nif (dataInputStream != null) {\ndataInputStream.close();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeader(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readHeader(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\n\nif (nid == NID.kArchiveProperties) {\nreadArchiveProperties(header);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kAdditionalStreamsInfo) {\nthrow new IOException(\"Additional streams unsupported\");\n//nid = header.readUnsignedByte();\n}\n\nif (nid == NID.kMainStreamsInfo) {\nreadStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kFilesInfo) {\nreadFilesInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated header\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\n\nif (nid == NID.kPackInfo) {\nreadPackInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kUnpackInfo) {\nreadUnpackInfo(header, archive);\nnid = header.readUnsignedByte();\n} else {\n// archive without unpack/coders info\narchive.folders = new Folder[0];\n}\n\nif (nid == NID.kSubStreamsInfo) {\nreadSubStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated StreamsInfo\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readSubStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nfor (final Folder folder : archive.folders) {\nfolder.numUnpackSubStreams = 1;\n}\nint totalUnpackStreams = archive.folders.length;\n\nint nid = header.readUnsignedByte();\nif (nid == NID.kNumUnpackStream) {\ntotalUnpackStreams = 0;\nfor (final Folder folder : archive.folders) {\nfinal long numStreams = readUint64(header);\nfolder.numUnpackSubStreams = (int)numStreams;\ntotalUnpackStreams += numStreams;\n}\nnid = header.readUnsignedByte();\n}\n\nfinal SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\nsubStreamsInfo.unpackSizes = new long[totalUnpackStreams];\nsubStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\nsubStreamsInfo.crcs = new long[totalUnpackStreams];\n\nint nextUnpackStream = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams == 0) {\ncontinue;\n}\nlong sum = 0;\nif (nid == NID.kSize) {\nfor (int i = 0; i < (folder.numUnpackSubStreams - 1); i++) {\nfinal long size = readUint64(header);\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = size;\nsum += size;\n}\n}\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;\n}\nif (nid == NID.kSize) {\nnid = header.readUnsignedByte();\n}\n\nint numDigests = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {\nnumDigests += folder.numUnpackSubStreams;\n}\n}\n\nif (nid == NID.kCRC) {\nfinal BitSet hasMissingCrc = readAllOrBits(header, numDigests);\nfinal long[] missingCrcs = new long[numDigests];\nfor (int i = 0; i < numDigests; i++) {\nif (hasMissingCrc.get(i)) {\nmissingCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n}\n}\nint nextCrc = 0;\nint nextMissingCrc = 0;\nfor (final Folder folder: archive.folders) {\nif (folder.numUnpackSubStreams == 1 && folder.hasCrc) {\nsubStreamsInfo.hasCrc.set(nextCrc, true);\nsubStreamsInfo.crcs[nextCrc] = folder.crc;\n++nextCrc;\n} else {\nfor (int i = 0; i < folder.numUnpackSubStreams; i++) {\nsubStreamsInfo.hasCrc.set(nextCrc, hasMissingCrc.get(nextMissingCrc));\nsubStreamsInfo.crcs[nextCrc] = missingCrcs[nextMissingCrc];\n++nextCrc;\n++nextMissingCrc;\n}\n}\n}\n\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated SubStreamsInfo\");\n}\n\narchive.subStreamsInfo = subStreamsInfo;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readBits(final DataInput header, final int size) throws IOException {\nfinal BitSet bits = new BitSet(size);\nint mask = 0;\nint cache = 0;\nfor (int i = 0; i < size; i++) {\nif (mask == 0) {\nmask = 0x80;\ncache = header.readUnsignedByte();\n}\nbits.set(i, (cache & mask) != 0);\nmask >>>= 1;\n}\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFilesInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readFilesInfo(final DataInput header, final Archive archive) throws IOException {\nfinal long numFiles = readUint64(header);\nfinal SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\nfor (int i = 0; i < files.length; i++) {\nfiles[i] = new SevenZArchiveEntry();\n}\nBitSet isEmptyStream = null;\nBitSet isEmptyFile = null;\nBitSet isAnti = null;\nwhile (true) {\nfinal int propertyType = header.readUnsignedByte();\nif (propertyType == 0) {\nbreak;\n}\nlong size = readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream: {\nisEmptyStream = readBits(header, files.length);\nbreak;\n}\ncase NID.kEmptyFile: {\nif (isEmptyStream == null) { // protect against NPE\nthrow new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n}\nisEmptyFile = readBits(header, isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kAnti: {\nif (isEmptyStream == null) { // protect against NPE\nthrow new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n}\nisAnti = readBits(header, isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kName: {\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Not implemented\");\n} else {\nif (((size - 1) & 1) != 0) {\nthrow new IOException(\"File names length invalid\");\n}\nfinal byte[] names = new byte[(int)(size - 1)];\nheader.readFully(names);\nint nextFile = 0;\nint nextName = 0;\nfor (int i = 0; i < names.length; i += 2) {\nif (names[i] == 0 && names[i+1] == 0) {\nfiles[nextFile++].setName(new String(names, nextName, i-nextName, CharsetNames.UTF_16LE));\nnextName = i + 2;\n}\n}\nif (nextName != names.length || nextFile != files.length) {\nthrow new IOException(\"Error parsing file names\");\n}\n}\nbreak;\n}\ncase NID.kCTime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasCreationDate(timesDefined.get(i));\nif (files[i].getHasCreationDate()) {\nfiles[i].setCreationDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kATime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasAccessDate(timesDefined.get(i));\nif (files[i].getHasAccessDate()) {\nfiles[i].setAccessDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kMTime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasLastModifiedDate(timesDefined.get(i));\nif (files[i].getHasLastModifiedDate()) {\nfiles[i].setLastModifiedDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kWinAttributes: {\nfinal BitSet attributesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasWindowsAttributes(attributesDefined.get(i));\nif (files[i].getHasWindowsAttributes()) {\nfiles[i].setWindowsAttributes(Integer.reverseBytes(header.readInt()));\n}\n}\n}\nbreak;\n}\ncase NID.kStartPos: {\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy: {\nthrow new IOException(\"kDummy is unsupported, please report\");\n}\n\ndefault: {\nthrow new IOException(\"Unknown property \" + propertyType);\n// FIXME: Should actually:\n//header.skipBytes((int)size);\n}\n}\n}\nint nonEmptyFileCounter = 0;\nint emptyFileCounter = 0;\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasStream((isEmptyStream == null) ? true : !isEmptyStream.get(i));\nif (files[i].hasStream()) {\nfiles[i].setDirectory(false);\nfiles[i].setAntiItem(false);\nfiles[i].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nfiles[i].setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nfiles[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n} else {\nfiles[i].setDirectory((isEmptyFile == null) ? true : !isEmptyFile.get(emptyFileCounter));\nfiles[i].setAntiItem((isAnti == null) ? false : isAnti.get(emptyFileCounter));\nfiles[i].setHasCrc(false);\nfiles[i].setSize(0);\n++emptyFileCounter;\n}\n}\narchive.files = files;\ncalculateStreamMap(archive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUint64(Ljava/io/DataInput;)J",
                                    "method_body": "private static long readUint64(final DataInput in) throws IOException {\n// long rather than int as it might get shifted beyond the range of an int\nlong firstByte = in.readUnsignedByte();\nint mask = 0x80;\nlong value = 0;\nfor (int i = 0; i < 8; i++) {\nif ((firstByte & mask) == 0) {\nreturn value | ((firstByte & (mask - 1)) << (8 * i));\n}\nlong nextByte = in.readUnsignedByte();\nvalue |= (nextByte << (8 * i));\nmask >>>= 1;\n}\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;JJ)V",
                                    "method_body": "public ChecksumVerifyingInputStream(final Checksum checksum, final InputStream in,\nfinal long size, final long expectedChecksum) {\nthis.checksum = checksum;\nthis.in = in;\nthis.expectedChecksum = expectedChecksum;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining <= 0) {\nreturn -1;\n}\nint ret = in.read();\nif (ret >= 0) {\nchecksum.update(ret);\n--bytesRemaining;\n}\nif (bytesRemaining == 0 && expectedChecksum != checksum.getValue()) {\nthrow new IOException(\"Checksum verification failed\");\n}\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nint ret = in.read(b, off, len);\nif (ret >= 0) {\nchecksum.update(b, off, ret);\nbytesRemaining -= ret;\n}\nif (bytesRemaining <= 0 && expectedChecksum != checksum.getValue()) {\nthrow new IOException(\"Checksum verification failed\");\n}\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nin.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CRC32VerifyingInputStream:<init>(Ljava/io/InputStream;JJ)V",
                                    "method_body": "public CRC32VerifyingInputStream(final InputStream in, final long size, final long expectedCrc32) {\nsuper(new CRC32(), in, size, expectedCrc32);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:<init>(Ljava/io/RandomAccessFile;J)V",
                                    "method_body": "public BoundedRandomAccessFileInputStream(final RandomAccessFile file,\nfinal long size) {\nthis.file = file;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining > 0) {\n--bytesRemaining;\nreturn file.read();\n} else {\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif (bytesRemaining == 0) {\nreturn -1;\n}\nint bytesToRead = len;\nif (bytesToRead > bytesRemaining) {\nbytesToRead = (int) bytesRemaining;\n}\nfinal int bytesRead = file.read(b, off, bytesToRead);\nif (bytesRead >= 0) {\nbytesRemaining -= bytesRead;\n}\nreturn bytesRead;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:close()V",
                                    "method_body": "public void close() {\n// the nested RandomAccessFile is controlled externally\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:<init>(Ljava/lang/String;I[B)V",
                                    "method_body": "private SevenZMethod(byte[] id) {\nthis.id = id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:<init>()V",
                                    "method_body": "public SevenZArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "public void setName(String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:hasStream()Z",
                                    "method_body": "public boolean hasStream() {\nreturn hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasStream(Z)V",
                                    "method_body": "public void setHasStream(boolean hasStream) {\nthis.hasStream = hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nreturn isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setDirectory(Z)V",
                                    "method_body": "public void setDirectory(boolean isDirectory) {\nthis.isDirectory = isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isAntiItem()Z",
                                    "method_body": "public boolean isAntiItem() {\nreturn isAntiItem;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasCreationDate()Z",
                                    "method_body": "public boolean getHasCreationDate() {\nreturn hasCreationDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasLastModifiedDate()Z",
                                    "method_body": "public boolean getHasLastModifiedDate() {\nreturn hasLastModifiedDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getLastModifiedDate()Ljava/util/Date;",
                                    "method_body": "public Date getLastModifiedDate() {\nif (hasLastModifiedDate) {\nreturn ntfsTimeToJavaTime(lastModifiedDate);\n} else {\nthrow new UnsupportedOperationException(\n\"The entry doesn't have this timestamp\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setLastModifiedDate(Ljava/util/Date;)V",
                                    "method_body": "public void setLastModifiedDate(Date lastModifiedDate) {\nhasLastModifiedDate = lastModifiedDate != null;\nif (hasLastModifiedDate) {\nthis.lastModifiedDate = javaTimeToNtfsTime(lastModifiedDate);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasAccessDate()Z",
                                    "method_body": "public boolean getHasAccessDate() {\nreturn hasAccessDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasWindowsAttributes()Z",
                                    "method_body": "public boolean getHasWindowsAttributes() {\nreturn hasWindowsAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasCrc(Z)V",
                                    "method_body": "public void setHasCrc(boolean hasCrc) {\nthis.hasCrc = hasCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCompressedSize(J)V",
                                    "method_body": "void setCompressedSize(long size) {\nthis.compressedSize = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:ntfsTimeToJavaTime(J)Ljava/util/Date;",
                                    "method_body": "public static Date ntfsTimeToJavaTime(final long ntfsTime) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nfinal long realTime = ntfsEpoch.getTimeInMillis() + (ntfsTime / (10*1000));\nreturn new Date(realTime);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:javaTimeToNtfsTime(Ljava/util/Date;)J",
                                    "method_body": "public static long javaTimeToNtfsTime(final Date date) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nreturn ((date.getTime() - ntfsEpoch.getTimeInMillis())* 1000 * 10);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZOutputFile(final File filename) throws IOException {\nfile = new RandomAccessFile(filename, \"rw\");\nfile.seek(SevenZFile.SIGNATURE_HEADER_SIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!finished) {\nfinish();\n}\nfile.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:createArchiveEntry(Ljava/io/File;Ljava/lang/String;)Lorg/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry;",
                                    "method_body": "public SevenZArchiveEntry createArchiveEntry(final File inputFile,\nfinal String entryName) throws IOException {\nfinal SevenZArchiveEntry entry = new SevenZArchiveEntry();\nentry.setDirectory(inputFile.isDirectory());\nentry.setName(entryName);\nentry.setLastModifiedDate(new Date(inputFile.lastModified()));\nreturn entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\nfinal SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;\nfiles.add(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (currentOutputStream != null) {\ncurrentOutputStream.flush();\ncurrentOutputStream.close();\n}\n\nfinal SevenZArchiveEntry entry = files.get(files.size() - 1);\nif (fileBytesWritten > 0) {\nentry.setHasStream(true);\n++numNonEmptyStreams;\nentry.setSize(currentOutputStream.getBytesWritten());\nentry.setCompressedSize(fileBytesWritten);\nentry.setCrcValue(crc32.getValue());\nentry.setCompressedCrcValue(compressedCrc32.getValue());\nentry.setHasCrc(true);\n} else {\nentry.setHasStream(false);\nentry.setSize(0);\nentry.setCompressedSize(0);\nentry.setHasCrc(false);\n}\ncurrentOutputStream = null;\ncrc32.reset();\ncompressedCrc32.reset();\nfileBytesWritten = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([B)V",
                                    "method_body": "public void write(final byte[] b) throws IOException {\nwrite(b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int off, final int len) throws IOException {\nif (len > 0) {\ngetCurrentOutputStream().write(b, off, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif (finished) {\nthrow new IOException(\"This archive has already been finished\");\n}\nfinished = true;\n\nfinal long headerPosition = file.getFilePointer();\n\nfinal ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();\nfinal DataOutputStream header = new DataOutputStream(headerBaos);\n\nwriteHeader(header);\nheader.flush();\nfinal byte[] headerBytes = headerBaos.toByteArray();\nfile.write(headerBytes);\n\nfinal CRC32 crc32 = new CRC32();\n\n// signature header\nfile.seek(0);\nfile.write(SevenZFile.sevenZSignature);\n// version\nfile.write(0);\nfile.write(2);\n\n// start header\nfinal ByteArrayOutputStream startHeaderBaos = new ByteArrayOutputStream();\nfinal DataOutputStream startHeaderStream = new DataOutputStream(startHeaderBaos);\nstartHeaderStream.writeLong(Long.reverseBytes(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE));\nstartHeaderStream.writeLong(Long.reverseBytes(0xffffFFFFL & headerBytes.length));\ncrc32.reset();\ncrc32.update(headerBytes);\nstartHeaderStream.writeInt(Integer.reverseBytes((int)crc32.getValue()));\nstartHeaderStream.flush();\nfinal byte[] startHeaderBytes = startHeaderBaos.toByteArray();\ncrc32.reset();\ncrc32.update(startHeaderBytes);\nfile.writeInt(Integer.reverseBytes((int) crc32.getValue()));\nfile.write(startHeaderBytes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeHeader(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeHeader(final DataOutput header) throws IOException {\nheader.write(NID.kHeader);\n\nheader.write(NID.kMainStreamsInfo);\nwriteStreamsInfo(header);\nwriteFilesInfo(header);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeStreamsInfo(final DataOutput header) throws IOException {\nif (numNonEmptyStreams > 0) {\nwritePackInfo(header);\nwriteUnpackInfo(header);\n}\n\nwriteSubStreamsInfo(header);\n\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeSubStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeSubStreamsInfo(final DataOutput header) throws IOException {\nheader.write(NID.kSubStreamsInfo);\n//\n//        header.write(NID.kCRC);\n//        header.write(1);\n//        for (final SevenZArchiveEntry entry : files) {\n//            if (entry.getHasCrc()) {\n//                header.writeInt(Integer.reverseBytes(entry.getCrc()));\n//            }\n//        }\n//\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFilesInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFilesInfo(final DataOutput header) throws IOException {\nheader.write(NID.kFilesInfo);\n\nwriteUint64(header, files.size());\n\nwriteFileEmptyStreams(header);\nwriteFileEmptyFiles(header);\nwriteFileAntiItems(header);\nwriteFileNames(header);\nwriteFileCTimes(header);\nwriteFileATimes(header);\nwriteFileMTimes(header);\nwriteFileWindowsAttributes(header);\nheader.write(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyStreams(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyStreams(final DataOutput header) throws IOException {\nboolean hasEmptyStreams = false;\nfor (final SevenZArchiveEntry entry : files) {\nif (!entry.hasStream()) {\nhasEmptyStreams = true;\nbreak;\n}\n}\nif (hasEmptyStreams) {\nheader.write(NID.kEmptyStream);\nfinal BitSet emptyStreams = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nemptyStreams.set(i, !files.get(i).hasStream());\n}\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyStreams, files.size());\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyFiles(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyFiles(final DataOutput header) throws IOException {\nboolean hasEmptyFiles = false;\nint emptyStreamCounter = 0;\nfinal BitSet emptyFiles = new BitSet(0);\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isDir = files.get(i).isDirectory();\nemptyFiles.set(emptyStreamCounter++, !isDir);\nhasEmptyFiles |= !isDir;\n}\n}\nif (hasEmptyFiles) {\nheader.write(NID.kEmptyFile);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyFiles, emptyStreamCounter);\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileAntiItems(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileAntiItems(final DataOutput header) throws IOException {\nboolean hasAntiItems = false;\nfinal BitSet antiItems = new BitSet(0);\nint antiItemCounter = 0;\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isAnti = files.get(i).isAntiItem();\nantiItems.set(antiItemCounter++, isAnti);\nhasAntiItems |= isAnti;\n}\n}\nif (hasAntiItems) {\nheader.write(NID.kAnti);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, antiItems, antiItemCounter);\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileNames(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileNames(final DataOutput header) throws IOException {\nheader.write(NID.kName);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nout.write(entry.getName().getBytes(\"UTF-16LE\"));\nout.writeShort(0);\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileCTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileCTimes(final DataOutput header) throws IOException {\nint numCreationDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasCreationDate()) {\n++numCreationDates;\n}\n}\nif (numCreationDates > 0) {\nheader.write(NID.kCTime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numCreationDates != files.size()) {\nout.write(0);\nfinal BitSet cTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\ncTimes.set(i, files.get(i).getHasCreationDate());\n}\nwriteBits(out, cTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasCreationDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getCreationDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileATimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileATimes(final DataOutput header) throws IOException {\nint numAccessDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasAccessDate()) {\n++numAccessDates;\n}\n}\nif (numAccessDates > 0) {\nheader.write(NID.kATime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numAccessDates != files.size()) {\nout.write(0);\nfinal BitSet aTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\naTimes.set(i, files.get(i).getHasAccessDate());\n}\nwriteBits(out, aTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasAccessDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getAccessDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileMTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileMTimes(final DataOutput header) throws IOException {\nint numLastModifiedDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\n++numLastModifiedDates;\n}\n}\nif (numLastModifiedDates > 0) {\nheader.write(NID.kMTime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numLastModifiedDates != files.size()) {\nout.write(0);\nfinal BitSet mTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nmTimes.set(i, files.get(i).getHasLastModifiedDate());\n}\nwriteBits(out, mTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getLastModifiedDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileWindowsAttributes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileWindowsAttributes(final DataOutput header) throws IOException {\nint numWindowsAttributes = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasWindowsAttributes()) {\n++numWindowsAttributes;\n}\n}\nif (numWindowsAttributes > 0) {\nheader.write(NID.kWinAttributes);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numWindowsAttributes != files.size()) {\nout.write(0);\nfinal BitSet attributes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nattributes.set(i, files.get(i).getHasWindowsAttributes());\n}\nwriteBits(out, attributes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasWindowsAttributes()) {\nout.writeInt(Integer.reverseBytes(entry.getWindowsAttributes()));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeUint64(Ljava/io/DataOutput;J)V",
                                    "method_body": "private void writeUint64(final DataOutput header, long value) throws IOException {\nint firstByte = 0;\nint mask = 0x80;\nint i;\nfor (i = 0; i < 8; i++) {\nif (value < ((1L << ( 7  * (i + 1))))) {\nfirstByte |= (value >>> (8 * i));\nbreak;\n}\nfirstByte |= mask;\nmask >>>= 1;\n}\nheader.write(firstByte);\nfor (; i > 0; i--) {\nheader.write((int) (0xff & value));\nvalue >>>= 8;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeBits(Ljava/io/DataOutput;Ljava/util/BitSet;I)V",
                                    "method_body": "private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\nint cache = 0;\nint shift = 7;\nfor (int i = 0; i < length; i++) {\ncache |= ((bits.get(i) ? 1 : 0) << shift);\n--shift;\nif (shift == 0) {\nheader.write(cache);\nshift = 7;\ncache = 0;\n}\n}\nif (length > 0 && shift > 0) {\nheader.write(cache);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public CountingOutputStream(final OutputStream out) {\nsuper(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int off, int len) throws IOException {\nout.write(b, off, len);\ncount(len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:count(J)V",
                                    "method_body": "protected void count(long written) {\nif (written != -1) {\nbytesWritten += written;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:getBytesWritten()J",
                                    "method_body": "public long getBytesWritten() {\nreturn bytesWritten;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readPackInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readPackInfo(final DataInput header, final Archive archive) throws IOException {\narchive.packPos = readUint64(header);\nfinal long numPackStreams = readUint64(header);\nint nid = header.readUnsignedByte();\nif (nid == NID.kSize) {\narchive.packSizes = new long[(int)numPackStreams];\nfor (int i = 0; i < archive.packSizes.length; i++) {\narchive.packSizes[i] = readUint64(header);\n}\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kCRC) {\narchive.packCrcsDefined = readAllOrBits(header, (int)numPackStreams);\narchive.packCrcs = new long[(int)numPackStreams];\nfor (int i = 0; i < (int)numPackStreams; i++) {\nif (archive.packCrcsDefined.get(i)) {\narchive.packCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n}\n}\n\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated PackInfo (\" + nid + \")\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUnpackInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readUnpackInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\nif (nid != NID.kFolder) {\nthrow new IOException(\"Expected kFolder, got \" + nid);\n}\nfinal long numFolders = readUint64(header);\nfinal Folder[] folders = new Folder[(int)numFolders];\narchive.folders = folders;\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"External unsupported\");\n} else {\nfor (int i = 0; i < (int)numFolders; i++) {\nfolders[i] = readFolder(header);\n}\n}\n\nnid = header.readUnsignedByte();\nif (nid != NID.kCodersUnpackSize) {\nthrow new IOException(\"Expected kCodersUnpackSize, got \" + nid);\n}\nfor (final Folder folder : folders) {\nfolder.unpackSizes = new long[(int)folder.totalOutputStreams];\nfor (int i = 0; i < folder.totalOutputStreams; i++) {\nfolder.unpackSizes[i] = readUint64(header);\n}\n}\n\nnid = header.readUnsignedByte();\nif (nid == NID.kCRC) {\nfinal BitSet crcsDefined = readAllOrBits(header, (int)numFolders);\nfor (int i = 0; i < (int)numFolders; i++) {\nif (crcsDefined.get(i)) {\nfolders[i].hasCrc = true;\nfolders[i].crc = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n} else {\nfolders[i].hasCrc = false;\n}\n}\n\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated UnpackInfo\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFolder(Ljava/io/DataInput;)Lorg/apache/commons/compress/archivers/sevenz/Folder;",
                                    "method_body": "private Folder readFolder(final DataInput header) throws IOException {\nfinal Folder folder = new Folder();\n\nfinal long numCoders = readUint64(header);\nfinal Coder[] coders = new Coder[(int)numCoders];\nlong totalInStreams = 0;\nlong totalOutStreams = 0;\nfor (int i = 0; i < coders.length; i++) {\ncoders[i] = new Coder();\nint bits = header.readUnsignedByte();\nfinal int idSize = bits & 0xf;\nfinal boolean isSimple = ((bits & 0x10) == 0);\nfinal boolean hasAttributes = ((bits & 0x20) != 0);\nfinal boolean moreAlternativeMethods = ((bits & 0x80) != 0);\n\ncoders[i].decompressionMethodId = new byte[idSize];\nheader.readFully(coders[i].decompressionMethodId);\nif (isSimple) {\ncoders[i].numInStreams = 1;\ncoders[i].numOutStreams = 1;\n} else {\ncoders[i].numInStreams = readUint64(header);\ncoders[i].numOutStreams = readUint64(header);\n}\ntotalInStreams += coders[i].numInStreams;\ntotalOutStreams += coders[i].numOutStreams;\nif (hasAttributes) {\nfinal long propertiesSize = readUint64(header);\ncoders[i].properties = new byte[(int)propertiesSize];\nheader.readFully(coders[i].properties);\n}\n// would need to keep looping as above:\nwhile (moreAlternativeMethods) {\nthrow new IOException(\"Alternative methods are unsupported, please report. \" +\n\"The reference implementation doesn't support them either.\");\n}\n}\nfolder.coders = coders;\nfolder.totalInputStreams = totalInStreams;\nfolder.totalOutputStreams = totalOutStreams;\n\nif (totalOutStreams == 0) {\nthrow new IOException(\"Total output streams can't be 0\");\n}\nfinal long numBindPairs = totalOutStreams - 1;\nfinal BindPair[] bindPairs = new BindPair[(int)numBindPairs];\nfor (int i = 0; i < bindPairs.length; i++) {\nbindPairs[i] = new BindPair();\nbindPairs[i].inIndex = readUint64(header);\nbindPairs[i].outIndex = readUint64(header);\n}\nfolder.bindPairs = bindPairs;\n\nif (totalInStreams < numBindPairs) {\nthrow new IOException(\"Total input streams can't be less than the number of bind pairs\");\n}\nfinal long numPackedStreams = totalInStreams - numBindPairs;\nfinal long packedStreams[] = new long[(int)numPackedStreams];\nif (numPackedStreams == 1) {\nint i;\nfor (i = 0; i < (int)totalInStreams; i++) {\nif (folder.findBindPairForInStream(i) < 0) {\nbreak;\n}\n}\nif (i == (int)totalInStreams) {\nthrow new IOException(\"Couldn't find stream's bind pair index\");\n}\npackedStreams[0] = i;\n} else {\nfor (int i = 0; i < (int)numPackedStreams; i++) {\npackedStreams[i] = readUint64(header);\n}\n}\nfolder.packedStreams = packedStreams;\n\nreturn folder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readAllOrBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readAllOrBits(final DataInput header, final int size) throws IOException {\nfinal int areAllDefined = header.readUnsignedByte();\nfinal BitSet bits;\nif (areAllDefined != 0) {\nbits = new BitSet(size);\nfor (int i = 0; i < size; i++) {\nbits.set(i, true);\n}\n} else {\nbits = readBits(header, size);\n}\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:findBindPairForInStream(I)I",
                                    "method_body": "int findBindPairForInStream(final int index) {\nfor (int i = 0; i < bindPairs.length; i++) {\nif (bindPairs[i].inIndex == index) {\nreturn i;\n}\n}\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:findBindPairForOutStream(I)I",
                                    "method_body": "int findBindPairForOutStream(final int index) {\nfor (int i = 0; i < bindPairs.length; i++) {\nif (bindPairs[i].outIndex == index) {\nreturn i;\n}\n}\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:getUnpackSize()J",
                                    "method_body": "long getUnpackSize() {\nif (totalOutputStreams == 0) {\nreturn 0;\n}\nfor (int i = ((int)totalOutputStreams) - 1; i >= 0; i--) {\nif (findBindPairForOutStream(i) < 0) {\nreturn unpackSizes[i];\n}\n}\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders:<clinit>()V",
                                    "method_body": "static CoderId[] coderTable = new CoderId[] {\nnew CoderId(SevenZMethod.COPY, new CopyDecoder()),\nnew CoderId(SevenZMethod.LZMA, new LZMADecoder()),\nnew CoderId(SevenZMethod.LZMA2, new LZMA2Decoder()),\nnew CoderId(SevenZMethod.DEFLATE, new DeflateDecoder()),\nnew CoderId(SevenZMethod.BZIP2, new BZIP2Decoder()),\nnew CoderId(SevenZMethod.AES256SHA256, new AES256SHA256Decoder())\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders:addEncoder(Ljava/io/OutputStream;Lorg/apache/commons/compress/archivers/sevenz/SevenZMethod;[B)Ljava/io/OutputStream;",
                                    "method_body": "static OutputStream addEncoder(final OutputStream out, final SevenZMethod method,\nfinal byte[] password) throws IOException {\nfor (final CoderId coderId : coderTable) {\nif (coderId.method.equals(method)) {\nreturn coderId.coder.encode(out, password);\n}\n}\nthrow new IOException(\"Unsupported compression method \" + method);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$CoderId:<init>(Lorg/apache/commons/compress/archivers/sevenz/SevenZMethod;Lorg/apache/commons/compress/archivers/sevenz/Coders$CoderBase;)V",
                                    "method_body": "CoderId(SevenZMethod method, final CoderBase coder) {\nthis.method = method;\nthis.coder = coder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:getId()[B",
                                    "method_body": "byte[] getId() {\nbyte[] copy = new byte[id.length];\nSystem.arraycopy(id, 0, copy, 0, id.length);\nreturn copy;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod$1:getProperties()[B",
                                    "method_body": "byte[] getProperties() {\nint dictSize = LZMA2Options.DICT_SIZE_DEFAULT;\nint lead = Integer.numberOfLeadingZeros(dictSize);\nint secondBit = (dictSize >>> (30 - lead)) - 2;\nreturn new byte[] {\n(byte) ((19 - lead) * 2 + secondBit)\n};\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$CoderBase:<init>()V",
                                    "method_body": "final SevenZMethod method;\nfinal CoderBase coder;\n}\n\nstatic abstract class CoderBase {\nabstract InputStream decode(final InputStream in, final Coder coder,\nbyte[] password) throws IOException;\nOutputStream encode(final OutputStream out, final byte[] password)\nthrows IOException {\nthrow new UnsupportedOperationException(\"method doesn't support writing\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.LZMA2Decoder:encode(Ljava/io/OutputStream;[B)Ljava/io/OutputStream;",
                                    "method_body": "OutputStream encode(final OutputStream out, final byte[] password)\nthrows IOException {\nLZMA2Options options = new LZMA2Options();\noptions.setDictSize(LZMA2Options.DICT_SIZE_DEFAULT);\nFinishableOutputStream wrapped = new FinishableWrapperOutputStream(out);\nreturn options.getOutputStream(wrapped);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getCrcValue()J",
                                    "method_body": "public long getCrcValue() {\nreturn crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCrcValue(J)V",
                                    "method_body": "public void setCrcValue(long crc) {\nthis.crc = crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getCompressedCrcValue()J",
                                    "method_body": "long getCompressedCrcValue() {\nreturn compressedCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCompressedCrcValue(J)V",
                                    "method_body": "void setCompressedCrcValue(long crc) {\nthis.compressedCrc = crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getCompressedSize()J",
                                    "method_body": "long getCompressedSize() {\nreturn compressedSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:getCurrentOutputStream()Ljava/io/OutputStream;",
                                    "method_body": "private OutputStream getCurrentOutputStream() throws IOException {\nif (currentOutputStream == null) {\ncurrentOutputStream = setupFileOutputStream();\n}\nreturn currentOutputStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:setupFileOutputStream()Lorg/apache/commons/compress/utils/CountingOutputStream;",
                                    "method_body": "private CountingOutputStream setupFileOutputStream() throws IOException {\nOutputStream out = new OutputStreamWrapper();\nreturn new CountingOutputStream(Coders\n.addEncoder(out,\ncontentCompression,\nnull)) {\n@Override\npublic void write(final int b) throws IOException {\nsuper.write(b);\ncrc32.update(b);\n}\n\n@Override\npublic void write(final byte[] b) throws IOException {\nsuper.write(b);\ncrc32.update(b);\n}\n\n@Override\npublic void write(final byte[] b, final int off, final int len)\nthrows IOException {\nsuper.write(b, off, len);\ncrc32.update(b, off, len);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writePackInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writePackInfo(final DataOutput header) throws IOException {\nheader.write(NID.kPackInfo);\n\nwriteUint64(header, 0);\nwriteUint64(header, 0xffffFFFFL & numNonEmptyStreams);\n\nheader.write(NID.kSize);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nwriteUint64(header, entry.getCompressedSize());\n}\n}\n\nheader.write(NID.kCRC);\nheader.write(1);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nheader.writeInt(Integer.reverseBytes((int) entry.getCompressedCrcValue()));\n}\n}\n\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeUnpackInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeUnpackInfo(final DataOutput header) throws IOException {\nheader.write(NID.kUnpackInfo);\n\nheader.write(NID.kFolder);\nwriteUint64(header, numNonEmptyStreams);\nheader.write(0);\nfor (int i = 0; i < numNonEmptyStreams; i++) {\nwriteFolder(header);\n}\n\nheader.write(NID.kCodersUnpackSize);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nwriteUint64(header, entry.getSize());\n}\n}\n\nheader.write(NID.kCRC);\nheader.write(1);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nheader.writeInt(Integer.reverseBytes((int) entry.getCrcValue()));\n}\n}\n\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFolder(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFolder(final DataOutput header) throws IOException {\n// one coder\nwriteUint64(header, 1);\nbyte[] id = contentCompression.getId();\nbyte[] properties = contentCompression.getProperties();\n\nint codecFlags = id.length;\nif (properties.length > 0) {\ncodecFlags |= 0x20;\n}\nheader.write(codecFlags);\nheader.write(id);\n\nif (properties.length > 0) {\nheader.write(properties.length);\nheader.write(properties);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:write(I)V",
                                    "method_body": "public void write(final int b) throws IOException {\nfile.write(b);\ncompressedCrc32.update(b);\nfileBytesWritten++;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int off, final int len)\nthrows IOException {\nfile.write(b, off, len);\ncompressedCrc32.update(b, off, len);\nfileBytesWritten += len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:flush()V",
                                    "method_body": "public void flush() throws IOException {\n// no reason to flush a RandomAccessFile\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:close()V",
                                    "method_body": "public void close() throws IOException {\n// the file will be closed by the containing class's close method\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$1:write([BII)V",
                                    "method_body": "private CountingOutputStream setupFileOutputStream() throws IOException {\nOutputStream out = new OutputStreamWrapper();\nreturn new CountingOutputStream(Coders\n.addEncoder(out,\ncontentCompression,\nnull)) {\n@Override\npublic void write(final int b) throws IOException {\nsuper.write(b);\ncrc32.update(b);\n}\n\n@Override\npublic void write(final byte[] b) throws IOException {\nsuper.write(b);\ncrc32.update(b);\n}\n\n@Override\npublic void write(final byte[] b, final int off, final int len)\nthrows IOException {\nsuper.write(b, off, len);\ncrc32.update(b, off, len);\n}\n};\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest.testSixEmptyFiles",
                            "test_body": "174: public void testSixEmptyFiles() throws Exception {\n175: testCompress252(6, 0);\n176: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;[B)V",
                                    "method_body": "public SevenZFile(final File filename, final byte[] password) throws IOException {\nboolean succeeded = false;\nthis.file = new RandomAccessFile(filename, \"r\");\ntry {\narchive = readHeaders(password);\nif (password != null) {\nthis.password = new byte[password.length];\nSystem.arraycopy(password, 0, this.password, 0, password.length);\n} else {\nthis.password = null;\n}\nsucceeded = true;\n} finally {\nif (!succeeded) {\nthis.file.close();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZFile(final File filename) throws IOException {\nthis(filename, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<clinit>()V",
                                    "method_body": "static final int SIGNATURE_HEADER_SIZE = 32;\n\nprivate static final int DRAIN_BUF_SIZE = 64 * 1024;\n\nprivate RandomAccessFile file;\nprivate final Archive archive;\nprivate int currentEntryIndex = -1;\nprivate int currentFolderIndex = -1;\nprivate InputStream currentFolderInputStream = null;\nprivate InputStream currentEntryInputStream = null;\nprivate byte[] password;\n\nstatic final byte[] sevenZSignature = {\n(byte)'7', (byte)'z', (byte)0xBC, (byte)0xAF, (byte)0x27, (byte)0x1C\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeaders([B)Lorg/apache/commons/compress/archivers/sevenz/Archive;",
                                    "method_body": "private Archive readHeaders(byte[] password) throws IOException {\nfinal byte[] signature = new byte[6];\nfile.readFully(signature);\nif (!Arrays.equals(signature, sevenZSignature)) {\nthrow new IOException(\"Bad 7z signature\");\n}\n// 7zFormat.txt has it wrong - it's first major then minor\nfinal byte archiveVersionMajor = file.readByte();\nfinal byte archiveVersionMinor = file.readByte();\nif (archiveVersionMajor != 0) {\nthrow new IOException(String.format(\"Unsupported 7z version (%d,%d)\",\narchiveVersionMajor, archiveVersionMinor));\n}\n\nfinal long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\nfinal StartHeader startHeader = readStartHeader(startHeaderCrc);\n\nfinal int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\nif (nextHeaderSizeInt != startHeader.nextHeaderSize) {\nthrow new IOException(\"cannot handle nextHeaderSize \" + startHeader.nextHeaderSize);\n}\nfile.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\nfinal byte[] nextHeader = new byte[nextHeaderSizeInt];\nfile.readFully(nextHeader);\nfinal CRC32 crc = new CRC32();\ncrc.update(nextHeader);\nif (startHeader.nextHeaderCrc != crc.getValue()) {\nthrow new IOException(\"NextHeader CRC mismatch\");\n}\n\nfinal ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\nDataInputStream nextHeaderInputStream = new DataInputStream(\nbyteStream);\nArchive archive = new Archive();\nint nid = nextHeaderInputStream.readUnsignedByte();\nif (nid == NID.kEncodedHeader) {\nnextHeaderInputStream =\nreadEncodedHeader(nextHeaderInputStream, archive, password);\n// Archive gets rebuilt with the new header\narchive = new Archive();\nnid = nextHeaderInputStream.readUnsignedByte();\n}\nif (nid == NID.kHeader) {\nreadHeader(nextHeaderInputStream, archive);\nnextHeaderInputStream.close();\n} else {\nthrow new IOException(\"Broken or unsupported archive: no Header\");\n}\nreturn archive;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStartHeader(J)Lorg/apache/commons/compress/archivers/sevenz/StartHeader;",
                                    "method_body": "private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\nfinal StartHeader startHeader = new StartHeader();\nDataInputStream dataInputStream = null;\ntry {\ndataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\nnew BoundedRandomAccessFileInputStream(file, 20), 20, startHeaderCrc));\nstartHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\nreturn startHeader;\n} finally {\nif (dataInputStream != null) {\ndataInputStream.close();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeader(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readHeader(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\n\nif (nid == NID.kArchiveProperties) {\nreadArchiveProperties(header);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kAdditionalStreamsInfo) {\nthrow new IOException(\"Additional streams unsupported\");\n//nid = header.readUnsignedByte();\n}\n\nif (nid == NID.kMainStreamsInfo) {\nreadStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kFilesInfo) {\nreadFilesInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated header\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\n\nif (nid == NID.kPackInfo) {\nreadPackInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kUnpackInfo) {\nreadUnpackInfo(header, archive);\nnid = header.readUnsignedByte();\n} else {\n// archive without unpack/coders info\narchive.folders = new Folder[0];\n}\n\nif (nid == NID.kSubStreamsInfo) {\nreadSubStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated StreamsInfo\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readSubStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nfor (final Folder folder : archive.folders) {\nfolder.numUnpackSubStreams = 1;\n}\nint totalUnpackStreams = archive.folders.length;\n\nint nid = header.readUnsignedByte();\nif (nid == NID.kNumUnpackStream) {\ntotalUnpackStreams = 0;\nfor (final Folder folder : archive.folders) {\nfinal long numStreams = readUint64(header);\nfolder.numUnpackSubStreams = (int)numStreams;\ntotalUnpackStreams += numStreams;\n}\nnid = header.readUnsignedByte();\n}\n\nfinal SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\nsubStreamsInfo.unpackSizes = new long[totalUnpackStreams];\nsubStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\nsubStreamsInfo.crcs = new long[totalUnpackStreams];\n\nint nextUnpackStream = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams == 0) {\ncontinue;\n}\nlong sum = 0;\nif (nid == NID.kSize) {\nfor (int i = 0; i < (folder.numUnpackSubStreams - 1); i++) {\nfinal long size = readUint64(header);\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = size;\nsum += size;\n}\n}\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;\n}\nif (nid == NID.kSize) {\nnid = header.readUnsignedByte();\n}\n\nint numDigests = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {\nnumDigests += folder.numUnpackSubStreams;\n}\n}\n\nif (nid == NID.kCRC) {\nfinal BitSet hasMissingCrc = readAllOrBits(header, numDigests);\nfinal long[] missingCrcs = new long[numDigests];\nfor (int i = 0; i < numDigests; i++) {\nif (hasMissingCrc.get(i)) {\nmissingCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n}\n}\nint nextCrc = 0;\nint nextMissingCrc = 0;\nfor (final Folder folder: archive.folders) {\nif (folder.numUnpackSubStreams == 1 && folder.hasCrc) {\nsubStreamsInfo.hasCrc.set(nextCrc, true);\nsubStreamsInfo.crcs[nextCrc] = folder.crc;\n++nextCrc;\n} else {\nfor (int i = 0; i < folder.numUnpackSubStreams; i++) {\nsubStreamsInfo.hasCrc.set(nextCrc, hasMissingCrc.get(nextMissingCrc));\nsubStreamsInfo.crcs[nextCrc] = missingCrcs[nextMissingCrc];\n++nextCrc;\n++nextMissingCrc;\n}\n}\n}\n\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated SubStreamsInfo\");\n}\n\narchive.subStreamsInfo = subStreamsInfo;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readBits(final DataInput header, final int size) throws IOException {\nfinal BitSet bits = new BitSet(size);\nint mask = 0;\nint cache = 0;\nfor (int i = 0; i < size; i++) {\nif (mask == 0) {\nmask = 0x80;\ncache = header.readUnsignedByte();\n}\nbits.set(i, (cache & mask) != 0);\nmask >>>= 1;\n}\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFilesInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readFilesInfo(final DataInput header, final Archive archive) throws IOException {\nfinal long numFiles = readUint64(header);\nfinal SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\nfor (int i = 0; i < files.length; i++) {\nfiles[i] = new SevenZArchiveEntry();\n}\nBitSet isEmptyStream = null;\nBitSet isEmptyFile = null;\nBitSet isAnti = null;\nwhile (true) {\nfinal int propertyType = header.readUnsignedByte();\nif (propertyType == 0) {\nbreak;\n}\nlong size = readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream: {\nisEmptyStream = readBits(header, files.length);\nbreak;\n}\ncase NID.kEmptyFile: {\nif (isEmptyStream == null) { // protect against NPE\nthrow new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n}\nisEmptyFile = readBits(header, isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kAnti: {\nif (isEmptyStream == null) { // protect against NPE\nthrow new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n}\nisAnti = readBits(header, isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kName: {\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Not implemented\");\n} else {\nif (((size - 1) & 1) != 0) {\nthrow new IOException(\"File names length invalid\");\n}\nfinal byte[] names = new byte[(int)(size - 1)];\nheader.readFully(names);\nint nextFile = 0;\nint nextName = 0;\nfor (int i = 0; i < names.length; i += 2) {\nif (names[i] == 0 && names[i+1] == 0) {\nfiles[nextFile++].setName(new String(names, nextName, i-nextName, CharsetNames.UTF_16LE));\nnextName = i + 2;\n}\n}\nif (nextName != names.length || nextFile != files.length) {\nthrow new IOException(\"Error parsing file names\");\n}\n}\nbreak;\n}\ncase NID.kCTime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasCreationDate(timesDefined.get(i));\nif (files[i].getHasCreationDate()) {\nfiles[i].setCreationDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kATime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasAccessDate(timesDefined.get(i));\nif (files[i].getHasAccessDate()) {\nfiles[i].setAccessDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kMTime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasLastModifiedDate(timesDefined.get(i));\nif (files[i].getHasLastModifiedDate()) {\nfiles[i].setLastModifiedDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kWinAttributes: {\nfinal BitSet attributesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasWindowsAttributes(attributesDefined.get(i));\nif (files[i].getHasWindowsAttributes()) {\nfiles[i].setWindowsAttributes(Integer.reverseBytes(header.readInt()));\n}\n}\n}\nbreak;\n}\ncase NID.kStartPos: {\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy: {\nthrow new IOException(\"kDummy is unsupported, please report\");\n}\n\ndefault: {\nthrow new IOException(\"Unknown property \" + propertyType);\n// FIXME: Should actually:\n//header.skipBytes((int)size);\n}\n}\n}\nint nonEmptyFileCounter = 0;\nint emptyFileCounter = 0;\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasStream((isEmptyStream == null) ? true : !isEmptyStream.get(i));\nif (files[i].hasStream()) {\nfiles[i].setDirectory(false);\nfiles[i].setAntiItem(false);\nfiles[i].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nfiles[i].setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nfiles[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n} else {\nfiles[i].setDirectory((isEmptyFile == null) ? true : !isEmptyFile.get(emptyFileCounter));\nfiles[i].setAntiItem((isAnti == null) ? false : isAnti.get(emptyFileCounter));\nfiles[i].setHasCrc(false);\nfiles[i].setSize(0);\n++emptyFileCounter;\n}\n}\narchive.files = files;\ncalculateStreamMap(archive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUint64(Ljava/io/DataInput;)J",
                                    "method_body": "private static long readUint64(final DataInput in) throws IOException {\n// long rather than int as it might get shifted beyond the range of an int\nlong firstByte = in.readUnsignedByte();\nint mask = 0x80;\nlong value = 0;\nfor (int i = 0; i < 8; i++) {\nif ((firstByte & mask) == 0) {\nreturn value | ((firstByte & (mask - 1)) << (8 * i));\n}\nlong nextByte = in.readUnsignedByte();\nvalue |= (nextByte << (8 * i));\nmask >>>= 1;\n}\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;JJ)V",
                                    "method_body": "public ChecksumVerifyingInputStream(final Checksum checksum, final InputStream in,\nfinal long size, final long expectedChecksum) {\nthis.checksum = checksum;\nthis.in = in;\nthis.expectedChecksum = expectedChecksum;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining <= 0) {\nreturn -1;\n}\nint ret = in.read();\nif (ret >= 0) {\nchecksum.update(ret);\n--bytesRemaining;\n}\nif (bytesRemaining == 0 && expectedChecksum != checksum.getValue()) {\nthrow new IOException(\"Checksum verification failed\");\n}\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nint ret = in.read(b, off, len);\nif (ret >= 0) {\nchecksum.update(b, off, ret);\nbytesRemaining -= ret;\n}\nif (bytesRemaining <= 0 && expectedChecksum != checksum.getValue()) {\nthrow new IOException(\"Checksum verification failed\");\n}\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nin.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CRC32VerifyingInputStream:<init>(Ljava/io/InputStream;JJ)V",
                                    "method_body": "public CRC32VerifyingInputStream(final InputStream in, final long size, final long expectedCrc32) {\nsuper(new CRC32(), in, size, expectedCrc32);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:<init>(Ljava/io/RandomAccessFile;J)V",
                                    "method_body": "public BoundedRandomAccessFileInputStream(final RandomAccessFile file,\nfinal long size) {\nthis.file = file;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining > 0) {\n--bytesRemaining;\nreturn file.read();\n} else {\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif (bytesRemaining == 0) {\nreturn -1;\n}\nint bytesToRead = len;\nif (bytesToRead > bytesRemaining) {\nbytesToRead = (int) bytesRemaining;\n}\nfinal int bytesRead = file.read(b, off, bytesToRead);\nif (bytesRead >= 0) {\nbytesRemaining -= bytesRead;\n}\nreturn bytesRead;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:close()V",
                                    "method_body": "public void close() {\n// the nested RandomAccessFile is controlled externally\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:<init>(Ljava/lang/String;I[B)V",
                                    "method_body": "private SevenZMethod(byte[] id) {\nthis.id = id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:<init>()V",
                                    "method_body": "public SevenZArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "public void setName(String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:hasStream()Z",
                                    "method_body": "public boolean hasStream() {\nreturn hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasStream(Z)V",
                                    "method_body": "public void setHasStream(boolean hasStream) {\nthis.hasStream = hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nreturn isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setDirectory(Z)V",
                                    "method_body": "public void setDirectory(boolean isDirectory) {\nthis.isDirectory = isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isAntiItem()Z",
                                    "method_body": "public boolean isAntiItem() {\nreturn isAntiItem;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasCreationDate()Z",
                                    "method_body": "public boolean getHasCreationDate() {\nreturn hasCreationDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasLastModifiedDate()Z",
                                    "method_body": "public boolean getHasLastModifiedDate() {\nreturn hasLastModifiedDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getLastModifiedDate()Ljava/util/Date;",
                                    "method_body": "public Date getLastModifiedDate() {\nif (hasLastModifiedDate) {\nreturn ntfsTimeToJavaTime(lastModifiedDate);\n} else {\nthrow new UnsupportedOperationException(\n\"The entry doesn't have this timestamp\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setLastModifiedDate(Ljava/util/Date;)V",
                                    "method_body": "public void setLastModifiedDate(Date lastModifiedDate) {\nhasLastModifiedDate = lastModifiedDate != null;\nif (hasLastModifiedDate) {\nthis.lastModifiedDate = javaTimeToNtfsTime(lastModifiedDate);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasAccessDate()Z",
                                    "method_body": "public boolean getHasAccessDate() {\nreturn hasAccessDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasWindowsAttributes()Z",
                                    "method_body": "public boolean getHasWindowsAttributes() {\nreturn hasWindowsAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasCrc(Z)V",
                                    "method_body": "public void setHasCrc(boolean hasCrc) {\nthis.hasCrc = hasCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCompressedSize(J)V",
                                    "method_body": "void setCompressedSize(long size) {\nthis.compressedSize = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:ntfsTimeToJavaTime(J)Ljava/util/Date;",
                                    "method_body": "public static Date ntfsTimeToJavaTime(final long ntfsTime) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nfinal long realTime = ntfsEpoch.getTimeInMillis() + (ntfsTime / (10*1000));\nreturn new Date(realTime);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:javaTimeToNtfsTime(Ljava/util/Date;)J",
                                    "method_body": "public static long javaTimeToNtfsTime(final Date date) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nreturn ((date.getTime() - ntfsEpoch.getTimeInMillis())* 1000 * 10);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZOutputFile(final File filename) throws IOException {\nfile = new RandomAccessFile(filename, \"rw\");\nfile.seek(SevenZFile.SIGNATURE_HEADER_SIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!finished) {\nfinish();\n}\nfile.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:createArchiveEntry(Ljava/io/File;Ljava/lang/String;)Lorg/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry;",
                                    "method_body": "public SevenZArchiveEntry createArchiveEntry(final File inputFile,\nfinal String entryName) throws IOException {\nfinal SevenZArchiveEntry entry = new SevenZArchiveEntry();\nentry.setDirectory(inputFile.isDirectory());\nentry.setName(entryName);\nentry.setLastModifiedDate(new Date(inputFile.lastModified()));\nreturn entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\nfinal SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;\nfiles.add(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (currentOutputStream != null) {\ncurrentOutputStream.flush();\ncurrentOutputStream.close();\n}\n\nfinal SevenZArchiveEntry entry = files.get(files.size() - 1);\nif (fileBytesWritten > 0) {\nentry.setHasStream(true);\n++numNonEmptyStreams;\nentry.setSize(currentOutputStream.getBytesWritten());\nentry.setCompressedSize(fileBytesWritten);\nentry.setCrcValue(crc32.getValue());\nentry.setCompressedCrcValue(compressedCrc32.getValue());\nentry.setHasCrc(true);\n} else {\nentry.setHasStream(false);\nentry.setSize(0);\nentry.setCompressedSize(0);\nentry.setHasCrc(false);\n}\ncurrentOutputStream = null;\ncrc32.reset();\ncompressedCrc32.reset();\nfileBytesWritten = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([B)V",
                                    "method_body": "public void write(final byte[] b) throws IOException {\nwrite(b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int off, final int len) throws IOException {\nif (len > 0) {\ngetCurrentOutputStream().write(b, off, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif (finished) {\nthrow new IOException(\"This archive has already been finished\");\n}\nfinished = true;\n\nfinal long headerPosition = file.getFilePointer();\n\nfinal ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();\nfinal DataOutputStream header = new DataOutputStream(headerBaos);\n\nwriteHeader(header);\nheader.flush();\nfinal byte[] headerBytes = headerBaos.toByteArray();\nfile.write(headerBytes);\n\nfinal CRC32 crc32 = new CRC32();\n\n// signature header\nfile.seek(0);\nfile.write(SevenZFile.sevenZSignature);\n// version\nfile.write(0);\nfile.write(2);\n\n// start header\nfinal ByteArrayOutputStream startHeaderBaos = new ByteArrayOutputStream();\nfinal DataOutputStream startHeaderStream = new DataOutputStream(startHeaderBaos);\nstartHeaderStream.writeLong(Long.reverseBytes(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE));\nstartHeaderStream.writeLong(Long.reverseBytes(0xffffFFFFL & headerBytes.length));\ncrc32.reset();\ncrc32.update(headerBytes);\nstartHeaderStream.writeInt(Integer.reverseBytes((int)crc32.getValue()));\nstartHeaderStream.flush();\nfinal byte[] startHeaderBytes = startHeaderBaos.toByteArray();\ncrc32.reset();\ncrc32.update(startHeaderBytes);\nfile.writeInt(Integer.reverseBytes((int) crc32.getValue()));\nfile.write(startHeaderBytes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeHeader(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeHeader(final DataOutput header) throws IOException {\nheader.write(NID.kHeader);\n\nheader.write(NID.kMainStreamsInfo);\nwriteStreamsInfo(header);\nwriteFilesInfo(header);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeStreamsInfo(final DataOutput header) throws IOException {\nif (numNonEmptyStreams > 0) {\nwritePackInfo(header);\nwriteUnpackInfo(header);\n}\n\nwriteSubStreamsInfo(header);\n\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeSubStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeSubStreamsInfo(final DataOutput header) throws IOException {\nheader.write(NID.kSubStreamsInfo);\n//\n//        header.write(NID.kCRC);\n//        header.write(1);\n//        for (final SevenZArchiveEntry entry : files) {\n//            if (entry.getHasCrc()) {\n//                header.writeInt(Integer.reverseBytes(entry.getCrc()));\n//            }\n//        }\n//\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFilesInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFilesInfo(final DataOutput header) throws IOException {\nheader.write(NID.kFilesInfo);\n\nwriteUint64(header, files.size());\n\nwriteFileEmptyStreams(header);\nwriteFileEmptyFiles(header);\nwriteFileAntiItems(header);\nwriteFileNames(header);\nwriteFileCTimes(header);\nwriteFileATimes(header);\nwriteFileMTimes(header);\nwriteFileWindowsAttributes(header);\nheader.write(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyStreams(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyStreams(final DataOutput header) throws IOException {\nboolean hasEmptyStreams = false;\nfor (final SevenZArchiveEntry entry : files) {\nif (!entry.hasStream()) {\nhasEmptyStreams = true;\nbreak;\n}\n}\nif (hasEmptyStreams) {\nheader.write(NID.kEmptyStream);\nfinal BitSet emptyStreams = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nemptyStreams.set(i, !files.get(i).hasStream());\n}\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyStreams, files.size());\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyFiles(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyFiles(final DataOutput header) throws IOException {\nboolean hasEmptyFiles = false;\nint emptyStreamCounter = 0;\nfinal BitSet emptyFiles = new BitSet(0);\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isDir = files.get(i).isDirectory();\nemptyFiles.set(emptyStreamCounter++, !isDir);\nhasEmptyFiles |= !isDir;\n}\n}\nif (hasEmptyFiles) {\nheader.write(NID.kEmptyFile);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyFiles, emptyStreamCounter);\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileAntiItems(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileAntiItems(final DataOutput header) throws IOException {\nboolean hasAntiItems = false;\nfinal BitSet antiItems = new BitSet(0);\nint antiItemCounter = 0;\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isAnti = files.get(i).isAntiItem();\nantiItems.set(antiItemCounter++, isAnti);\nhasAntiItems |= isAnti;\n}\n}\nif (hasAntiItems) {\nheader.write(NID.kAnti);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, antiItems, antiItemCounter);\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileNames(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileNames(final DataOutput header) throws IOException {\nheader.write(NID.kName);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nout.write(entry.getName().getBytes(\"UTF-16LE\"));\nout.writeShort(0);\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileCTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileCTimes(final DataOutput header) throws IOException {\nint numCreationDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasCreationDate()) {\n++numCreationDates;\n}\n}\nif (numCreationDates > 0) {\nheader.write(NID.kCTime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numCreationDates != files.size()) {\nout.write(0);\nfinal BitSet cTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\ncTimes.set(i, files.get(i).getHasCreationDate());\n}\nwriteBits(out, cTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasCreationDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getCreationDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileATimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileATimes(final DataOutput header) throws IOException {\nint numAccessDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasAccessDate()) {\n++numAccessDates;\n}\n}\nif (numAccessDates > 0) {\nheader.write(NID.kATime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numAccessDates != files.size()) {\nout.write(0);\nfinal BitSet aTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\naTimes.set(i, files.get(i).getHasAccessDate());\n}\nwriteBits(out, aTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasAccessDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getAccessDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileMTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileMTimes(final DataOutput header) throws IOException {\nint numLastModifiedDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\n++numLastModifiedDates;\n}\n}\nif (numLastModifiedDates > 0) {\nheader.write(NID.kMTime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numLastModifiedDates != files.size()) {\nout.write(0);\nfinal BitSet mTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nmTimes.set(i, files.get(i).getHasLastModifiedDate());\n}\nwriteBits(out, mTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getLastModifiedDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileWindowsAttributes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileWindowsAttributes(final DataOutput header) throws IOException {\nint numWindowsAttributes = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasWindowsAttributes()) {\n++numWindowsAttributes;\n}\n}\nif (numWindowsAttributes > 0) {\nheader.write(NID.kWinAttributes);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numWindowsAttributes != files.size()) {\nout.write(0);\nfinal BitSet attributes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nattributes.set(i, files.get(i).getHasWindowsAttributes());\n}\nwriteBits(out, attributes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasWindowsAttributes()) {\nout.writeInt(Integer.reverseBytes(entry.getWindowsAttributes()));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeUint64(Ljava/io/DataOutput;J)V",
                                    "method_body": "private void writeUint64(final DataOutput header, long value) throws IOException {\nint firstByte = 0;\nint mask = 0x80;\nint i;\nfor (i = 0; i < 8; i++) {\nif (value < ((1L << ( 7  * (i + 1))))) {\nfirstByte |= (value >>> (8 * i));\nbreak;\n}\nfirstByte |= mask;\nmask >>>= 1;\n}\nheader.write(firstByte);\nfor (; i > 0; i--) {\nheader.write((int) (0xff & value));\nvalue >>>= 8;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeBits(Ljava/io/DataOutput;Ljava/util/BitSet;I)V",
                                    "method_body": "private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\nint cache = 0;\nint shift = 7;\nfor (int i = 0; i < length; i++) {\ncache |= ((bits.get(i) ? 1 : 0) << shift);\n--shift;\nif (shift == 0) {\nheader.write(cache);\nshift = 7;\ncache = 0;\n}\n}\nif (length > 0 && shift > 0) {\nheader.write(cache);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:calculateStreamMap(Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void calculateStreamMap(final Archive archive) throws IOException {\nfinal StreamMap streamMap = new StreamMap();\n\nint nextFolderPackStreamIndex = 0;\nfinal int numFolders = (archive.folders != null) ? archive.folders.length : 0;\nstreamMap.folderFirstPackStreamIndex = new int[numFolders];\nfor (int i = 0; i < numFolders; i++) {\nstreamMap.folderFirstPackStreamIndex[i] = nextFolderPackStreamIndex;\nnextFolderPackStreamIndex += archive.folders[i].packedStreams.length;\n}\n\nlong nextPackStreamOffset = 0;\nfinal int numPackSizes = (archive.packSizes != null) ? archive.packSizes.length : 0;\nstreamMap.packStreamOffsets = new long[numPackSizes];\nfor (int i = 0; i < numPackSizes; i++) {\nstreamMap.packStreamOffsets[i] = nextPackStreamOffset;\nnextPackStreamOffset += archive.packSizes[i];\n}\n\nstreamMap.folderFirstFileIndex = new int[numFolders];\nstreamMap.fileFolderIndex = new int[archive.files.length];\nint nextFolderIndex = 0;\nint nextFolderUnpackStreamIndex = 0;\nfor (int i = 0; i < archive.files.length; i++) {\nif (!archive.files[i].hasStream() && nextFolderUnpackStreamIndex == 0) {\nstreamMap.fileFolderIndex[i] = -1;\ncontinue;\n}\nif (nextFolderUnpackStreamIndex == 0) {\nfor (; nextFolderIndex < archive.folders.length; ++nextFolderIndex) {\nstreamMap.folderFirstFileIndex[nextFolderIndex] = i;\nif (archive.folders[nextFolderIndex].numUnpackSubStreams > 0) {\nbreak;\n}\n}\nif (nextFolderIndex >= archive.folders.length) {\nthrow new IOException(\"Too few folders in archive\");\n}\n}\nstreamMap.fileFolderIndex[i] = nextFolderIndex;\nif (!archive.files[i].hasStream()) {\ncontinue;\n}\n++nextFolderUnpackStreamIndex;\nif (nextFolderUnpackStreamIndex >= archive.folders[nextFolderIndex].numUnpackSubStreams) {\n++nextFolderIndex;\nnextFolderUnpackStreamIndex = 0;\n}\n}\n\narchive.streamMap = streamMap;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setAntiItem(Z)V",
                                    "method_body": "public void setAntiItem(boolean isAntiItem) {\nthis.isAntiItem = isAntiItem;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest.testNineFilesSomeNotEmpty",
                            "test_body": "202: public void testNineFilesSomeNotEmpty() throws Exception {\n203: testCompress252(9, 2);\n204: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;[B)V",
                                    "method_body": "public SevenZFile(final File filename, final byte[] password) throws IOException {\nboolean succeeded = false;\nthis.file = new RandomAccessFile(filename, \"r\");\ntry {\narchive = readHeaders(password);\nif (password != null) {\nthis.password = new byte[password.length];\nSystem.arraycopy(password, 0, this.password, 0, password.length);\n} else {\nthis.password = null;\n}\nsucceeded = true;\n} finally {\nif (!succeeded) {\nthis.file.close();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZFile(final File filename) throws IOException {\nthis(filename, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<clinit>()V",
                                    "method_body": "static final int SIGNATURE_HEADER_SIZE = 32;\n\nprivate static final int DRAIN_BUF_SIZE = 64 * 1024;\n\nprivate RandomAccessFile file;\nprivate final Archive archive;\nprivate int currentEntryIndex = -1;\nprivate int currentFolderIndex = -1;\nprivate InputStream currentFolderInputStream = null;\nprivate InputStream currentEntryInputStream = null;\nprivate byte[] password;\n\nstatic final byte[] sevenZSignature = {\n(byte)'7', (byte)'z', (byte)0xBC, (byte)0xAF, (byte)0x27, (byte)0x1C\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeaders([B)Lorg/apache/commons/compress/archivers/sevenz/Archive;",
                                    "method_body": "private Archive readHeaders(byte[] password) throws IOException {\nfinal byte[] signature = new byte[6];\nfile.readFully(signature);\nif (!Arrays.equals(signature, sevenZSignature)) {\nthrow new IOException(\"Bad 7z signature\");\n}\n// 7zFormat.txt has it wrong - it's first major then minor\nfinal byte archiveVersionMajor = file.readByte();\nfinal byte archiveVersionMinor = file.readByte();\nif (archiveVersionMajor != 0) {\nthrow new IOException(String.format(\"Unsupported 7z version (%d,%d)\",\narchiveVersionMajor, archiveVersionMinor));\n}\n\nfinal long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\nfinal StartHeader startHeader = readStartHeader(startHeaderCrc);\n\nfinal int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\nif (nextHeaderSizeInt != startHeader.nextHeaderSize) {\nthrow new IOException(\"cannot handle nextHeaderSize \" + startHeader.nextHeaderSize);\n}\nfile.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\nfinal byte[] nextHeader = new byte[nextHeaderSizeInt];\nfile.readFully(nextHeader);\nfinal CRC32 crc = new CRC32();\ncrc.update(nextHeader);\nif (startHeader.nextHeaderCrc != crc.getValue()) {\nthrow new IOException(\"NextHeader CRC mismatch\");\n}\n\nfinal ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\nDataInputStream nextHeaderInputStream = new DataInputStream(\nbyteStream);\nArchive archive = new Archive();\nint nid = nextHeaderInputStream.readUnsignedByte();\nif (nid == NID.kEncodedHeader) {\nnextHeaderInputStream =\nreadEncodedHeader(nextHeaderInputStream, archive, password);\n// Archive gets rebuilt with the new header\narchive = new Archive();\nnid = nextHeaderInputStream.readUnsignedByte();\n}\nif (nid == NID.kHeader) {\nreadHeader(nextHeaderInputStream, archive);\nnextHeaderInputStream.close();\n} else {\nthrow new IOException(\"Broken or unsupported archive: no Header\");\n}\nreturn archive;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStartHeader(J)Lorg/apache/commons/compress/archivers/sevenz/StartHeader;",
                                    "method_body": "private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\nfinal StartHeader startHeader = new StartHeader();\nDataInputStream dataInputStream = null;\ntry {\ndataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\nnew BoundedRandomAccessFileInputStream(file, 20), 20, startHeaderCrc));\nstartHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\nreturn startHeader;\n} finally {\nif (dataInputStream != null) {\ndataInputStream.close();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeader(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readHeader(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\n\nif (nid == NID.kArchiveProperties) {\nreadArchiveProperties(header);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kAdditionalStreamsInfo) {\nthrow new IOException(\"Additional streams unsupported\");\n//nid = header.readUnsignedByte();\n}\n\nif (nid == NID.kMainStreamsInfo) {\nreadStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kFilesInfo) {\nreadFilesInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated header\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\n\nif (nid == NID.kPackInfo) {\nreadPackInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kUnpackInfo) {\nreadUnpackInfo(header, archive);\nnid = header.readUnsignedByte();\n} else {\n// archive without unpack/coders info\narchive.folders = new Folder[0];\n}\n\nif (nid == NID.kSubStreamsInfo) {\nreadSubStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated StreamsInfo\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readSubStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nfor (final Folder folder : archive.folders) {\nfolder.numUnpackSubStreams = 1;\n}\nint totalUnpackStreams = archive.folders.length;\n\nint nid = header.readUnsignedByte();\nif (nid == NID.kNumUnpackStream) {\ntotalUnpackStreams = 0;\nfor (final Folder folder : archive.folders) {\nfinal long numStreams = readUint64(header);\nfolder.numUnpackSubStreams = (int)numStreams;\ntotalUnpackStreams += numStreams;\n}\nnid = header.readUnsignedByte();\n}\n\nfinal SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\nsubStreamsInfo.unpackSizes = new long[totalUnpackStreams];\nsubStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\nsubStreamsInfo.crcs = new long[totalUnpackStreams];\n\nint nextUnpackStream = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams == 0) {\ncontinue;\n}\nlong sum = 0;\nif (nid == NID.kSize) {\nfor (int i = 0; i < (folder.numUnpackSubStreams - 1); i++) {\nfinal long size = readUint64(header);\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = size;\nsum += size;\n}\n}\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;\n}\nif (nid == NID.kSize) {\nnid = header.readUnsignedByte();\n}\n\nint numDigests = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {\nnumDigests += folder.numUnpackSubStreams;\n}\n}\n\nif (nid == NID.kCRC) {\nfinal BitSet hasMissingCrc = readAllOrBits(header, numDigests);\nfinal long[] missingCrcs = new long[numDigests];\nfor (int i = 0; i < numDigests; i++) {\nif (hasMissingCrc.get(i)) {\nmissingCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n}\n}\nint nextCrc = 0;\nint nextMissingCrc = 0;\nfor (final Folder folder: archive.folders) {\nif (folder.numUnpackSubStreams == 1 && folder.hasCrc) {\nsubStreamsInfo.hasCrc.set(nextCrc, true);\nsubStreamsInfo.crcs[nextCrc] = folder.crc;\n++nextCrc;\n} else {\nfor (int i = 0; i < folder.numUnpackSubStreams; i++) {\nsubStreamsInfo.hasCrc.set(nextCrc, hasMissingCrc.get(nextMissingCrc));\nsubStreamsInfo.crcs[nextCrc] = missingCrcs[nextMissingCrc];\n++nextCrc;\n++nextMissingCrc;\n}\n}\n}\n\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated SubStreamsInfo\");\n}\n\narchive.subStreamsInfo = subStreamsInfo;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readBits(final DataInput header, final int size) throws IOException {\nfinal BitSet bits = new BitSet(size);\nint mask = 0;\nint cache = 0;\nfor (int i = 0; i < size; i++) {\nif (mask == 0) {\nmask = 0x80;\ncache = header.readUnsignedByte();\n}\nbits.set(i, (cache & mask) != 0);\nmask >>>= 1;\n}\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFilesInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readFilesInfo(final DataInput header, final Archive archive) throws IOException {\nfinal long numFiles = readUint64(header);\nfinal SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\nfor (int i = 0; i < files.length; i++) {\nfiles[i] = new SevenZArchiveEntry();\n}\nBitSet isEmptyStream = null;\nBitSet isEmptyFile = null;\nBitSet isAnti = null;\nwhile (true) {\nfinal int propertyType = header.readUnsignedByte();\nif (propertyType == 0) {\nbreak;\n}\nlong size = readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream: {\nisEmptyStream = readBits(header, files.length);\nbreak;\n}\ncase NID.kEmptyFile: {\nif (isEmptyStream == null) { // protect against NPE\nthrow new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n}\nisEmptyFile = readBits(header, isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kAnti: {\nif (isEmptyStream == null) { // protect against NPE\nthrow new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n}\nisAnti = readBits(header, isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kName: {\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Not implemented\");\n} else {\nif (((size - 1) & 1) != 0) {\nthrow new IOException(\"File names length invalid\");\n}\nfinal byte[] names = new byte[(int)(size - 1)];\nheader.readFully(names);\nint nextFile = 0;\nint nextName = 0;\nfor (int i = 0; i < names.length; i += 2) {\nif (names[i] == 0 && names[i+1] == 0) {\nfiles[nextFile++].setName(new String(names, nextName, i-nextName, CharsetNames.UTF_16LE));\nnextName = i + 2;\n}\n}\nif (nextName != names.length || nextFile != files.length) {\nthrow new IOException(\"Error parsing file names\");\n}\n}\nbreak;\n}\ncase NID.kCTime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasCreationDate(timesDefined.get(i));\nif (files[i].getHasCreationDate()) {\nfiles[i].setCreationDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kATime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasAccessDate(timesDefined.get(i));\nif (files[i].getHasAccessDate()) {\nfiles[i].setAccessDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kMTime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasLastModifiedDate(timesDefined.get(i));\nif (files[i].getHasLastModifiedDate()) {\nfiles[i].setLastModifiedDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kWinAttributes: {\nfinal BitSet attributesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasWindowsAttributes(attributesDefined.get(i));\nif (files[i].getHasWindowsAttributes()) {\nfiles[i].setWindowsAttributes(Integer.reverseBytes(header.readInt()));\n}\n}\n}\nbreak;\n}\ncase NID.kStartPos: {\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy: {\nthrow new IOException(\"kDummy is unsupported, please report\");\n}\n\ndefault: {\nthrow new IOException(\"Unknown property \" + propertyType);\n// FIXME: Should actually:\n//header.skipBytes((int)size);\n}\n}\n}\nint nonEmptyFileCounter = 0;\nint emptyFileCounter = 0;\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasStream((isEmptyStream == null) ? true : !isEmptyStream.get(i));\nif (files[i].hasStream()) {\nfiles[i].setDirectory(false);\nfiles[i].setAntiItem(false);\nfiles[i].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nfiles[i].setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nfiles[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n} else {\nfiles[i].setDirectory((isEmptyFile == null) ? true : !isEmptyFile.get(emptyFileCounter));\nfiles[i].setAntiItem((isAnti == null) ? false : isAnti.get(emptyFileCounter));\nfiles[i].setHasCrc(false);\nfiles[i].setSize(0);\n++emptyFileCounter;\n}\n}\narchive.files = files;\ncalculateStreamMap(archive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUint64(Ljava/io/DataInput;)J",
                                    "method_body": "private static long readUint64(final DataInput in) throws IOException {\n// long rather than int as it might get shifted beyond the range of an int\nlong firstByte = in.readUnsignedByte();\nint mask = 0x80;\nlong value = 0;\nfor (int i = 0; i < 8; i++) {\nif ((firstByte & mask) == 0) {\nreturn value | ((firstByte & (mask - 1)) << (8 * i));\n}\nlong nextByte = in.readUnsignedByte();\nvalue |= (nextByte << (8 * i));\nmask >>>= 1;\n}\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;JJ)V",
                                    "method_body": "public ChecksumVerifyingInputStream(final Checksum checksum, final InputStream in,\nfinal long size, final long expectedChecksum) {\nthis.checksum = checksum;\nthis.in = in;\nthis.expectedChecksum = expectedChecksum;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining <= 0) {\nreturn -1;\n}\nint ret = in.read();\nif (ret >= 0) {\nchecksum.update(ret);\n--bytesRemaining;\n}\nif (bytesRemaining == 0 && expectedChecksum != checksum.getValue()) {\nthrow new IOException(\"Checksum verification failed\");\n}\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nint ret = in.read(b, off, len);\nif (ret >= 0) {\nchecksum.update(b, off, ret);\nbytesRemaining -= ret;\n}\nif (bytesRemaining <= 0 && expectedChecksum != checksum.getValue()) {\nthrow new IOException(\"Checksum verification failed\");\n}\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nin.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CRC32VerifyingInputStream:<init>(Ljava/io/InputStream;JJ)V",
                                    "method_body": "public CRC32VerifyingInputStream(final InputStream in, final long size, final long expectedCrc32) {\nsuper(new CRC32(), in, size, expectedCrc32);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:<init>(Ljava/io/RandomAccessFile;J)V",
                                    "method_body": "public BoundedRandomAccessFileInputStream(final RandomAccessFile file,\nfinal long size) {\nthis.file = file;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining > 0) {\n--bytesRemaining;\nreturn file.read();\n} else {\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif (bytesRemaining == 0) {\nreturn -1;\n}\nint bytesToRead = len;\nif (bytesToRead > bytesRemaining) {\nbytesToRead = (int) bytesRemaining;\n}\nfinal int bytesRead = file.read(b, off, bytesToRead);\nif (bytesRead >= 0) {\nbytesRemaining -= bytesRead;\n}\nreturn bytesRead;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:close()V",
                                    "method_body": "public void close() {\n// the nested RandomAccessFile is controlled externally\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:<init>(Ljava/lang/String;I[B)V",
                                    "method_body": "private SevenZMethod(byte[] id) {\nthis.id = id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:<init>()V",
                                    "method_body": "public SevenZArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "public void setName(String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:hasStream()Z",
                                    "method_body": "public boolean hasStream() {\nreturn hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasStream(Z)V",
                                    "method_body": "public void setHasStream(boolean hasStream) {\nthis.hasStream = hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nreturn isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setDirectory(Z)V",
                                    "method_body": "public void setDirectory(boolean isDirectory) {\nthis.isDirectory = isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isAntiItem()Z",
                                    "method_body": "public boolean isAntiItem() {\nreturn isAntiItem;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasCreationDate()Z",
                                    "method_body": "public boolean getHasCreationDate() {\nreturn hasCreationDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasLastModifiedDate()Z",
                                    "method_body": "public boolean getHasLastModifiedDate() {\nreturn hasLastModifiedDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getLastModifiedDate()Ljava/util/Date;",
                                    "method_body": "public Date getLastModifiedDate() {\nif (hasLastModifiedDate) {\nreturn ntfsTimeToJavaTime(lastModifiedDate);\n} else {\nthrow new UnsupportedOperationException(\n\"The entry doesn't have this timestamp\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setLastModifiedDate(Ljava/util/Date;)V",
                                    "method_body": "public void setLastModifiedDate(Date lastModifiedDate) {\nhasLastModifiedDate = lastModifiedDate != null;\nif (hasLastModifiedDate) {\nthis.lastModifiedDate = javaTimeToNtfsTime(lastModifiedDate);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasAccessDate()Z",
                                    "method_body": "public boolean getHasAccessDate() {\nreturn hasAccessDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasWindowsAttributes()Z",
                                    "method_body": "public boolean getHasWindowsAttributes() {\nreturn hasWindowsAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasCrc(Z)V",
                                    "method_body": "public void setHasCrc(boolean hasCrc) {\nthis.hasCrc = hasCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCompressedSize(J)V",
                                    "method_body": "void setCompressedSize(long size) {\nthis.compressedSize = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:ntfsTimeToJavaTime(J)Ljava/util/Date;",
                                    "method_body": "public static Date ntfsTimeToJavaTime(final long ntfsTime) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nfinal long realTime = ntfsEpoch.getTimeInMillis() + (ntfsTime / (10*1000));\nreturn new Date(realTime);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:javaTimeToNtfsTime(Ljava/util/Date;)J",
                                    "method_body": "public static long javaTimeToNtfsTime(final Date date) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nreturn ((date.getTime() - ntfsEpoch.getTimeInMillis())* 1000 * 10);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZOutputFile(final File filename) throws IOException {\nfile = new RandomAccessFile(filename, \"rw\");\nfile.seek(SevenZFile.SIGNATURE_HEADER_SIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!finished) {\nfinish();\n}\nfile.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:createArchiveEntry(Ljava/io/File;Ljava/lang/String;)Lorg/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry;",
                                    "method_body": "public SevenZArchiveEntry createArchiveEntry(final File inputFile,\nfinal String entryName) throws IOException {\nfinal SevenZArchiveEntry entry = new SevenZArchiveEntry();\nentry.setDirectory(inputFile.isDirectory());\nentry.setName(entryName);\nentry.setLastModifiedDate(new Date(inputFile.lastModified()));\nreturn entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\nfinal SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;\nfiles.add(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (currentOutputStream != null) {\ncurrentOutputStream.flush();\ncurrentOutputStream.close();\n}\n\nfinal SevenZArchiveEntry entry = files.get(files.size() - 1);\nif (fileBytesWritten > 0) {\nentry.setHasStream(true);\n++numNonEmptyStreams;\nentry.setSize(currentOutputStream.getBytesWritten());\nentry.setCompressedSize(fileBytesWritten);\nentry.setCrcValue(crc32.getValue());\nentry.setCompressedCrcValue(compressedCrc32.getValue());\nentry.setHasCrc(true);\n} else {\nentry.setHasStream(false);\nentry.setSize(0);\nentry.setCompressedSize(0);\nentry.setHasCrc(false);\n}\ncurrentOutputStream = null;\ncrc32.reset();\ncompressedCrc32.reset();\nfileBytesWritten = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([B)V",
                                    "method_body": "public void write(final byte[] b) throws IOException {\nwrite(b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int off, final int len) throws IOException {\nif (len > 0) {\ngetCurrentOutputStream().write(b, off, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif (finished) {\nthrow new IOException(\"This archive has already been finished\");\n}\nfinished = true;\n\nfinal long headerPosition = file.getFilePointer();\n\nfinal ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();\nfinal DataOutputStream header = new DataOutputStream(headerBaos);\n\nwriteHeader(header);\nheader.flush();\nfinal byte[] headerBytes = headerBaos.toByteArray();\nfile.write(headerBytes);\n\nfinal CRC32 crc32 = new CRC32();\n\n// signature header\nfile.seek(0);\nfile.write(SevenZFile.sevenZSignature);\n// version\nfile.write(0);\nfile.write(2);\n\n// start header\nfinal ByteArrayOutputStream startHeaderBaos = new ByteArrayOutputStream();\nfinal DataOutputStream startHeaderStream = new DataOutputStream(startHeaderBaos);\nstartHeaderStream.writeLong(Long.reverseBytes(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE));\nstartHeaderStream.writeLong(Long.reverseBytes(0xffffFFFFL & headerBytes.length));\ncrc32.reset();\ncrc32.update(headerBytes);\nstartHeaderStream.writeInt(Integer.reverseBytes((int)crc32.getValue()));\nstartHeaderStream.flush();\nfinal byte[] startHeaderBytes = startHeaderBaos.toByteArray();\ncrc32.reset();\ncrc32.update(startHeaderBytes);\nfile.writeInt(Integer.reverseBytes((int) crc32.getValue()));\nfile.write(startHeaderBytes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeHeader(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeHeader(final DataOutput header) throws IOException {\nheader.write(NID.kHeader);\n\nheader.write(NID.kMainStreamsInfo);\nwriteStreamsInfo(header);\nwriteFilesInfo(header);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeStreamsInfo(final DataOutput header) throws IOException {\nif (numNonEmptyStreams > 0) {\nwritePackInfo(header);\nwriteUnpackInfo(header);\n}\n\nwriteSubStreamsInfo(header);\n\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeSubStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeSubStreamsInfo(final DataOutput header) throws IOException {\nheader.write(NID.kSubStreamsInfo);\n//\n//        header.write(NID.kCRC);\n//        header.write(1);\n//        for (final SevenZArchiveEntry entry : files) {\n//            if (entry.getHasCrc()) {\n//                header.writeInt(Integer.reverseBytes(entry.getCrc()));\n//            }\n//        }\n//\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFilesInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFilesInfo(final DataOutput header) throws IOException {\nheader.write(NID.kFilesInfo);\n\nwriteUint64(header, files.size());\n\nwriteFileEmptyStreams(header);\nwriteFileEmptyFiles(header);\nwriteFileAntiItems(header);\nwriteFileNames(header);\nwriteFileCTimes(header);\nwriteFileATimes(header);\nwriteFileMTimes(header);\nwriteFileWindowsAttributes(header);\nheader.write(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyStreams(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyStreams(final DataOutput header) throws IOException {\nboolean hasEmptyStreams = false;\nfor (final SevenZArchiveEntry entry : files) {\nif (!entry.hasStream()) {\nhasEmptyStreams = true;\nbreak;\n}\n}\nif (hasEmptyStreams) {\nheader.write(NID.kEmptyStream);\nfinal BitSet emptyStreams = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nemptyStreams.set(i, !files.get(i).hasStream());\n}\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyStreams, files.size());\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyFiles(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyFiles(final DataOutput header) throws IOException {\nboolean hasEmptyFiles = false;\nint emptyStreamCounter = 0;\nfinal BitSet emptyFiles = new BitSet(0);\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isDir = files.get(i).isDirectory();\nemptyFiles.set(emptyStreamCounter++, !isDir);\nhasEmptyFiles |= !isDir;\n}\n}\nif (hasEmptyFiles) {\nheader.write(NID.kEmptyFile);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyFiles, emptyStreamCounter);\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileAntiItems(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileAntiItems(final DataOutput header) throws IOException {\nboolean hasAntiItems = false;\nfinal BitSet antiItems = new BitSet(0);\nint antiItemCounter = 0;\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isAnti = files.get(i).isAntiItem();\nantiItems.set(antiItemCounter++, isAnti);\nhasAntiItems |= isAnti;\n}\n}\nif (hasAntiItems) {\nheader.write(NID.kAnti);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, antiItems, antiItemCounter);\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileNames(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileNames(final DataOutput header) throws IOException {\nheader.write(NID.kName);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nout.write(entry.getName().getBytes(\"UTF-16LE\"));\nout.writeShort(0);\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileCTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileCTimes(final DataOutput header) throws IOException {\nint numCreationDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasCreationDate()) {\n++numCreationDates;\n}\n}\nif (numCreationDates > 0) {\nheader.write(NID.kCTime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numCreationDates != files.size()) {\nout.write(0);\nfinal BitSet cTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\ncTimes.set(i, files.get(i).getHasCreationDate());\n}\nwriteBits(out, cTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasCreationDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getCreationDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileATimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileATimes(final DataOutput header) throws IOException {\nint numAccessDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasAccessDate()) {\n++numAccessDates;\n}\n}\nif (numAccessDates > 0) {\nheader.write(NID.kATime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numAccessDates != files.size()) {\nout.write(0);\nfinal BitSet aTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\naTimes.set(i, files.get(i).getHasAccessDate());\n}\nwriteBits(out, aTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasAccessDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getAccessDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileMTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileMTimes(final DataOutput header) throws IOException {\nint numLastModifiedDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\n++numLastModifiedDates;\n}\n}\nif (numLastModifiedDates > 0) {\nheader.write(NID.kMTime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numLastModifiedDates != files.size()) {\nout.write(0);\nfinal BitSet mTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nmTimes.set(i, files.get(i).getHasLastModifiedDate());\n}\nwriteBits(out, mTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getLastModifiedDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileWindowsAttributes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileWindowsAttributes(final DataOutput header) throws IOException {\nint numWindowsAttributes = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasWindowsAttributes()) {\n++numWindowsAttributes;\n}\n}\nif (numWindowsAttributes > 0) {\nheader.write(NID.kWinAttributes);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numWindowsAttributes != files.size()) {\nout.write(0);\nfinal BitSet attributes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nattributes.set(i, files.get(i).getHasWindowsAttributes());\n}\nwriteBits(out, attributes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasWindowsAttributes()) {\nout.writeInt(Integer.reverseBytes(entry.getWindowsAttributes()));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeUint64(Ljava/io/DataOutput;J)V",
                                    "method_body": "private void writeUint64(final DataOutput header, long value) throws IOException {\nint firstByte = 0;\nint mask = 0x80;\nint i;\nfor (i = 0; i < 8; i++) {\nif (value < ((1L << ( 7  * (i + 1))))) {\nfirstByte |= (value >>> (8 * i));\nbreak;\n}\nfirstByte |= mask;\nmask >>>= 1;\n}\nheader.write(firstByte);\nfor (; i > 0; i--) {\nheader.write((int) (0xff & value));\nvalue >>>= 8;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeBits(Ljava/io/DataOutput;Ljava/util/BitSet;I)V",
                                    "method_body": "private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\nint cache = 0;\nint shift = 7;\nfor (int i = 0; i < length; i++) {\ncache |= ((bits.get(i) ? 1 : 0) << shift);\n--shift;\nif (shift == 0) {\nheader.write(cache);\nshift = 7;\ncache = 0;\n}\n}\nif (length > 0 && shift > 0) {\nheader.write(cache);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public CountingOutputStream(final OutputStream out) {\nsuper(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int off, int len) throws IOException {\nout.write(b, off, len);\ncount(len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:count(J)V",
                                    "method_body": "protected void count(long written) {\nif (written != -1) {\nbytesWritten += written;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:getBytesWritten()J",
                                    "method_body": "public long getBytesWritten() {\nreturn bytesWritten;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readPackInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readPackInfo(final DataInput header, final Archive archive) throws IOException {\narchive.packPos = readUint64(header);\nfinal long numPackStreams = readUint64(header);\nint nid = header.readUnsignedByte();\nif (nid == NID.kSize) {\narchive.packSizes = new long[(int)numPackStreams];\nfor (int i = 0; i < archive.packSizes.length; i++) {\narchive.packSizes[i] = readUint64(header);\n}\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kCRC) {\narchive.packCrcsDefined = readAllOrBits(header, (int)numPackStreams);\narchive.packCrcs = new long[(int)numPackStreams];\nfor (int i = 0; i < (int)numPackStreams; i++) {\nif (archive.packCrcsDefined.get(i)) {\narchive.packCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n}\n}\n\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated PackInfo (\" + nid + \")\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUnpackInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readUnpackInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\nif (nid != NID.kFolder) {\nthrow new IOException(\"Expected kFolder, got \" + nid);\n}\nfinal long numFolders = readUint64(header);\nfinal Folder[] folders = new Folder[(int)numFolders];\narchive.folders = folders;\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"External unsupported\");\n} else {\nfor (int i = 0; i < (int)numFolders; i++) {\nfolders[i] = readFolder(header);\n}\n}\n\nnid = header.readUnsignedByte();\nif (nid != NID.kCodersUnpackSize) {\nthrow new IOException(\"Expected kCodersUnpackSize, got \" + nid);\n}\nfor (final Folder folder : folders) {\nfolder.unpackSizes = new long[(int)folder.totalOutputStreams];\nfor (int i = 0; i < folder.totalOutputStreams; i++) {\nfolder.unpackSizes[i] = readUint64(header);\n}\n}\n\nnid = header.readUnsignedByte();\nif (nid == NID.kCRC) {\nfinal BitSet crcsDefined = readAllOrBits(header, (int)numFolders);\nfor (int i = 0; i < (int)numFolders; i++) {\nif (crcsDefined.get(i)) {\nfolders[i].hasCrc = true;\nfolders[i].crc = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n} else {\nfolders[i].hasCrc = false;\n}\n}\n\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated UnpackInfo\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFolder(Ljava/io/DataInput;)Lorg/apache/commons/compress/archivers/sevenz/Folder;",
                                    "method_body": "private Folder readFolder(final DataInput header) throws IOException {\nfinal Folder folder = new Folder();\n\nfinal long numCoders = readUint64(header);\nfinal Coder[] coders = new Coder[(int)numCoders];\nlong totalInStreams = 0;\nlong totalOutStreams = 0;\nfor (int i = 0; i < coders.length; i++) {\ncoders[i] = new Coder();\nint bits = header.readUnsignedByte();\nfinal int idSize = bits & 0xf;\nfinal boolean isSimple = ((bits & 0x10) == 0);\nfinal boolean hasAttributes = ((bits & 0x20) != 0);\nfinal boolean moreAlternativeMethods = ((bits & 0x80) != 0);\n\ncoders[i].decompressionMethodId = new byte[idSize];\nheader.readFully(coders[i].decompressionMethodId);\nif (isSimple) {\ncoders[i].numInStreams = 1;\ncoders[i].numOutStreams = 1;\n} else {\ncoders[i].numInStreams = readUint64(header);\ncoders[i].numOutStreams = readUint64(header);\n}\ntotalInStreams += coders[i].numInStreams;\ntotalOutStreams += coders[i].numOutStreams;\nif (hasAttributes) {\nfinal long propertiesSize = readUint64(header);\ncoders[i].properties = new byte[(int)propertiesSize];\nheader.readFully(coders[i].properties);\n}\n// would need to keep looping as above:\nwhile (moreAlternativeMethods) {\nthrow new IOException(\"Alternative methods are unsupported, please report. \" +\n\"The reference implementation doesn't support them either.\");\n}\n}\nfolder.coders = coders;\nfolder.totalInputStreams = totalInStreams;\nfolder.totalOutputStreams = totalOutStreams;\n\nif (totalOutStreams == 0) {\nthrow new IOException(\"Total output streams can't be 0\");\n}\nfinal long numBindPairs = totalOutStreams - 1;\nfinal BindPair[] bindPairs = new BindPair[(int)numBindPairs];\nfor (int i = 0; i < bindPairs.length; i++) {\nbindPairs[i] = new BindPair();\nbindPairs[i].inIndex = readUint64(header);\nbindPairs[i].outIndex = readUint64(header);\n}\nfolder.bindPairs = bindPairs;\n\nif (totalInStreams < numBindPairs) {\nthrow new IOException(\"Total input streams can't be less than the number of bind pairs\");\n}\nfinal long numPackedStreams = totalInStreams - numBindPairs;\nfinal long packedStreams[] = new long[(int)numPackedStreams];\nif (numPackedStreams == 1) {\nint i;\nfor (i = 0; i < (int)totalInStreams; i++) {\nif (folder.findBindPairForInStream(i) < 0) {\nbreak;\n}\n}\nif (i == (int)totalInStreams) {\nthrow new IOException(\"Couldn't find stream's bind pair index\");\n}\npackedStreams[0] = i;\n} else {\nfor (int i = 0; i < (int)numPackedStreams; i++) {\npackedStreams[i] = readUint64(header);\n}\n}\nfolder.packedStreams = packedStreams;\n\nreturn folder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readAllOrBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readAllOrBits(final DataInput header, final int size) throws IOException {\nfinal int areAllDefined = header.readUnsignedByte();\nfinal BitSet bits;\nif (areAllDefined != 0) {\nbits = new BitSet(size);\nfor (int i = 0; i < size; i++) {\nbits.set(i, true);\n}\n} else {\nbits = readBits(header, size);\n}\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:findBindPairForInStream(I)I",
                                    "method_body": "int findBindPairForInStream(final int index) {\nfor (int i = 0; i < bindPairs.length; i++) {\nif (bindPairs[i].inIndex == index) {\nreturn i;\n}\n}\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:findBindPairForOutStream(I)I",
                                    "method_body": "int findBindPairForOutStream(final int index) {\nfor (int i = 0; i < bindPairs.length; i++) {\nif (bindPairs[i].outIndex == index) {\nreturn i;\n}\n}\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:getUnpackSize()J",
                                    "method_body": "long getUnpackSize() {\nif (totalOutputStreams == 0) {\nreturn 0;\n}\nfor (int i = ((int)totalOutputStreams) - 1; i >= 0; i--) {\nif (findBindPairForOutStream(i) < 0) {\nreturn unpackSizes[i];\n}\n}\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders:<clinit>()V",
                                    "method_body": "static CoderId[] coderTable = new CoderId[] {\nnew CoderId(SevenZMethod.COPY, new CopyDecoder()),\nnew CoderId(SevenZMethod.LZMA, new LZMADecoder()),\nnew CoderId(SevenZMethod.LZMA2, new LZMA2Decoder()),\nnew CoderId(SevenZMethod.DEFLATE, new DeflateDecoder()),\nnew CoderId(SevenZMethod.BZIP2, new BZIP2Decoder()),\nnew CoderId(SevenZMethod.AES256SHA256, new AES256SHA256Decoder())\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders:addEncoder(Ljava/io/OutputStream;Lorg/apache/commons/compress/archivers/sevenz/SevenZMethod;[B)Ljava/io/OutputStream;",
                                    "method_body": "static OutputStream addEncoder(final OutputStream out, final SevenZMethod method,\nfinal byte[] password) throws IOException {\nfor (final CoderId coderId : coderTable) {\nif (coderId.method.equals(method)) {\nreturn coderId.coder.encode(out, password);\n}\n}\nthrow new IOException(\"Unsupported compression method \" + method);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$CoderId:<init>(Lorg/apache/commons/compress/archivers/sevenz/SevenZMethod;Lorg/apache/commons/compress/archivers/sevenz/Coders$CoderBase;)V",
                                    "method_body": "CoderId(SevenZMethod method, final CoderBase coder) {\nthis.method = method;\nthis.coder = coder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:getId()[B",
                                    "method_body": "byte[] getId() {\nbyte[] copy = new byte[id.length];\nSystem.arraycopy(id, 0, copy, 0, id.length);\nreturn copy;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod$1:getProperties()[B",
                                    "method_body": "byte[] getProperties() {\nint dictSize = LZMA2Options.DICT_SIZE_DEFAULT;\nint lead = Integer.numberOfLeadingZeros(dictSize);\nint secondBit = (dictSize >>> (30 - lead)) - 2;\nreturn new byte[] {\n(byte) ((19 - lead) * 2 + secondBit)\n};\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$CoderBase:<init>()V",
                                    "method_body": "final SevenZMethod method;\nfinal CoderBase coder;\n}\n\nstatic abstract class CoderBase {\nabstract InputStream decode(final InputStream in, final Coder coder,\nbyte[] password) throws IOException;\nOutputStream encode(final OutputStream out, final byte[] password)\nthrows IOException {\nthrow new UnsupportedOperationException(\"method doesn't support writing\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.LZMA2Decoder:encode(Ljava/io/OutputStream;[B)Ljava/io/OutputStream;",
                                    "method_body": "OutputStream encode(final OutputStream out, final byte[] password)\nthrows IOException {\nLZMA2Options options = new LZMA2Options();\noptions.setDictSize(LZMA2Options.DICT_SIZE_DEFAULT);\nFinishableOutputStream wrapped = new FinishableWrapperOutputStream(out);\nreturn options.getOutputStream(wrapped);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getCrcValue()J",
                                    "method_body": "public long getCrcValue() {\nreturn crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCrcValue(J)V",
                                    "method_body": "public void setCrcValue(long crc) {\nthis.crc = crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getCompressedCrcValue()J",
                                    "method_body": "long getCompressedCrcValue() {\nreturn compressedCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCompressedCrcValue(J)V",
                                    "method_body": "void setCompressedCrcValue(long crc) {\nthis.compressedCrc = crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getCompressedSize()J",
                                    "method_body": "long getCompressedSize() {\nreturn compressedSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:getCurrentOutputStream()Ljava/io/OutputStream;",
                                    "method_body": "private OutputStream getCurrentOutputStream() throws IOException {\nif (currentOutputStream == null) {\ncurrentOutputStream = setupFileOutputStream();\n}\nreturn currentOutputStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:setupFileOutputStream()Lorg/apache/commons/compress/utils/CountingOutputStream;",
                                    "method_body": "private CountingOutputStream setupFileOutputStream() throws IOException {\nOutputStream out = new OutputStreamWrapper();\nreturn new CountingOutputStream(Coders\n.addEncoder(out,\ncontentCompression,\nnull)) {\n@Override\npublic void write(final int b) throws IOException {\nsuper.write(b);\ncrc32.update(b);\n}\n\n@Override\npublic void write(final byte[] b) throws IOException {\nsuper.write(b);\ncrc32.update(b);\n}\n\n@Override\npublic void write(final byte[] b, final int off, final int len)\nthrows IOException {\nsuper.write(b, off, len);\ncrc32.update(b, off, len);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writePackInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writePackInfo(final DataOutput header) throws IOException {\nheader.write(NID.kPackInfo);\n\nwriteUint64(header, 0);\nwriteUint64(header, 0xffffFFFFL & numNonEmptyStreams);\n\nheader.write(NID.kSize);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nwriteUint64(header, entry.getCompressedSize());\n}\n}\n\nheader.write(NID.kCRC);\nheader.write(1);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nheader.writeInt(Integer.reverseBytes((int) entry.getCompressedCrcValue()));\n}\n}\n\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeUnpackInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeUnpackInfo(final DataOutput header) throws IOException {\nheader.write(NID.kUnpackInfo);\n\nheader.write(NID.kFolder);\nwriteUint64(header, numNonEmptyStreams);\nheader.write(0);\nfor (int i = 0; i < numNonEmptyStreams; i++) {\nwriteFolder(header);\n}\n\nheader.write(NID.kCodersUnpackSize);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nwriteUint64(header, entry.getSize());\n}\n}\n\nheader.write(NID.kCRC);\nheader.write(1);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nheader.writeInt(Integer.reverseBytes((int) entry.getCrcValue()));\n}\n}\n\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFolder(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFolder(final DataOutput header) throws IOException {\n// one coder\nwriteUint64(header, 1);\nbyte[] id = contentCompression.getId();\nbyte[] properties = contentCompression.getProperties();\n\nint codecFlags = id.length;\nif (properties.length > 0) {\ncodecFlags |= 0x20;\n}\nheader.write(codecFlags);\nheader.write(id);\n\nif (properties.length > 0) {\nheader.write(properties.length);\nheader.write(properties);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:write(I)V",
                                    "method_body": "public void write(final int b) throws IOException {\nfile.write(b);\ncompressedCrc32.update(b);\nfileBytesWritten++;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int off, final int len)\nthrows IOException {\nfile.write(b, off, len);\ncompressedCrc32.update(b, off, len);\nfileBytesWritten += len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:flush()V",
                                    "method_body": "public void flush() throws IOException {\n// no reason to flush a RandomAccessFile\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:close()V",
                                    "method_body": "public void close() throws IOException {\n// the file will be closed by the containing class's close method\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$1:write([BII)V",
                                    "method_body": "private CountingOutputStream setupFileOutputStream() throws IOException {\nOutputStream out = new OutputStreamWrapper();\nreturn new CountingOutputStream(Coders\n.addEncoder(out,\ncontentCompression,\nnull)) {\n@Override\npublic void write(final int b) throws IOException {\nsuper.write(b);\ncrc32.update(b);\n}\n\n@Override\npublic void write(final byte[] b) throws IOException {\nsuper.write(b);\ncrc32.update(b);\n}\n\n@Override\npublic void write(final byte[] b, final int off, final int len)\nthrows IOException {\nsuper.write(b, off, len);\ncrc32.update(b, off, len);\n}\n};\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest.testEightFilesSomeNotEmpty",
                            "test_body": "194: public void testEightFilesSomeNotEmpty() throws Exception {\n195: testCompress252(8, 2);\n196: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;[B)V",
                                    "method_body": "public SevenZFile(final File filename, final byte[] password) throws IOException {\nboolean succeeded = false;\nthis.file = new RandomAccessFile(filename, \"r\");\ntry {\narchive = readHeaders(password);\nif (password != null) {\nthis.password = new byte[password.length];\nSystem.arraycopy(password, 0, this.password, 0, password.length);\n} else {\nthis.password = null;\n}\nsucceeded = true;\n} finally {\nif (!succeeded) {\nthis.file.close();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZFile(final File filename) throws IOException {\nthis(filename, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<clinit>()V",
                                    "method_body": "static final int SIGNATURE_HEADER_SIZE = 32;\n\nprivate static final int DRAIN_BUF_SIZE = 64 * 1024;\n\nprivate RandomAccessFile file;\nprivate final Archive archive;\nprivate int currentEntryIndex = -1;\nprivate int currentFolderIndex = -1;\nprivate InputStream currentFolderInputStream = null;\nprivate InputStream currentEntryInputStream = null;\nprivate byte[] password;\n\nstatic final byte[] sevenZSignature = {\n(byte)'7', (byte)'z', (byte)0xBC, (byte)0xAF, (byte)0x27, (byte)0x1C\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeaders([B)Lorg/apache/commons/compress/archivers/sevenz/Archive;",
                                    "method_body": "private Archive readHeaders(byte[] password) throws IOException {\nfinal byte[] signature = new byte[6];\nfile.readFully(signature);\nif (!Arrays.equals(signature, sevenZSignature)) {\nthrow new IOException(\"Bad 7z signature\");\n}\n// 7zFormat.txt has it wrong - it's first major then minor\nfinal byte archiveVersionMajor = file.readByte();\nfinal byte archiveVersionMinor = file.readByte();\nif (archiveVersionMajor != 0) {\nthrow new IOException(String.format(\"Unsupported 7z version (%d,%d)\",\narchiveVersionMajor, archiveVersionMinor));\n}\n\nfinal long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\nfinal StartHeader startHeader = readStartHeader(startHeaderCrc);\n\nfinal int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\nif (nextHeaderSizeInt != startHeader.nextHeaderSize) {\nthrow new IOException(\"cannot handle nextHeaderSize \" + startHeader.nextHeaderSize);\n}\nfile.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\nfinal byte[] nextHeader = new byte[nextHeaderSizeInt];\nfile.readFully(nextHeader);\nfinal CRC32 crc = new CRC32();\ncrc.update(nextHeader);\nif (startHeader.nextHeaderCrc != crc.getValue()) {\nthrow new IOException(\"NextHeader CRC mismatch\");\n}\n\nfinal ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\nDataInputStream nextHeaderInputStream = new DataInputStream(\nbyteStream);\nArchive archive = new Archive();\nint nid = nextHeaderInputStream.readUnsignedByte();\nif (nid == NID.kEncodedHeader) {\nnextHeaderInputStream =\nreadEncodedHeader(nextHeaderInputStream, archive, password);\n// Archive gets rebuilt with the new header\narchive = new Archive();\nnid = nextHeaderInputStream.readUnsignedByte();\n}\nif (nid == NID.kHeader) {\nreadHeader(nextHeaderInputStream, archive);\nnextHeaderInputStream.close();\n} else {\nthrow new IOException(\"Broken or unsupported archive: no Header\");\n}\nreturn archive;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStartHeader(J)Lorg/apache/commons/compress/archivers/sevenz/StartHeader;",
                                    "method_body": "private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\nfinal StartHeader startHeader = new StartHeader();\nDataInputStream dataInputStream = null;\ntry {\ndataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\nnew BoundedRandomAccessFileInputStream(file, 20), 20, startHeaderCrc));\nstartHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\nreturn startHeader;\n} finally {\nif (dataInputStream != null) {\ndataInputStream.close();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeader(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readHeader(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\n\nif (nid == NID.kArchiveProperties) {\nreadArchiveProperties(header);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kAdditionalStreamsInfo) {\nthrow new IOException(\"Additional streams unsupported\");\n//nid = header.readUnsignedByte();\n}\n\nif (nid == NID.kMainStreamsInfo) {\nreadStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kFilesInfo) {\nreadFilesInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated header\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\n\nif (nid == NID.kPackInfo) {\nreadPackInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kUnpackInfo) {\nreadUnpackInfo(header, archive);\nnid = header.readUnsignedByte();\n} else {\n// archive without unpack/coders info\narchive.folders = new Folder[0];\n}\n\nif (nid == NID.kSubStreamsInfo) {\nreadSubStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated StreamsInfo\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readSubStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nfor (final Folder folder : archive.folders) {\nfolder.numUnpackSubStreams = 1;\n}\nint totalUnpackStreams = archive.folders.length;\n\nint nid = header.readUnsignedByte();\nif (nid == NID.kNumUnpackStream) {\ntotalUnpackStreams = 0;\nfor (final Folder folder : archive.folders) {\nfinal long numStreams = readUint64(header);\nfolder.numUnpackSubStreams = (int)numStreams;\ntotalUnpackStreams += numStreams;\n}\nnid = header.readUnsignedByte();\n}\n\nfinal SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\nsubStreamsInfo.unpackSizes = new long[totalUnpackStreams];\nsubStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\nsubStreamsInfo.crcs = new long[totalUnpackStreams];\n\nint nextUnpackStream = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams == 0) {\ncontinue;\n}\nlong sum = 0;\nif (nid == NID.kSize) {\nfor (int i = 0; i < (folder.numUnpackSubStreams - 1); i++) {\nfinal long size = readUint64(header);\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = size;\nsum += size;\n}\n}\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;\n}\nif (nid == NID.kSize) {\nnid = header.readUnsignedByte();\n}\n\nint numDigests = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {\nnumDigests += folder.numUnpackSubStreams;\n}\n}\n\nif (nid == NID.kCRC) {\nfinal BitSet hasMissingCrc = readAllOrBits(header, numDigests);\nfinal long[] missingCrcs = new long[numDigests];\nfor (int i = 0; i < numDigests; i++) {\nif (hasMissingCrc.get(i)) {\nmissingCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n}\n}\nint nextCrc = 0;\nint nextMissingCrc = 0;\nfor (final Folder folder: archive.folders) {\nif (folder.numUnpackSubStreams == 1 && folder.hasCrc) {\nsubStreamsInfo.hasCrc.set(nextCrc, true);\nsubStreamsInfo.crcs[nextCrc] = folder.crc;\n++nextCrc;\n} else {\nfor (int i = 0; i < folder.numUnpackSubStreams; i++) {\nsubStreamsInfo.hasCrc.set(nextCrc, hasMissingCrc.get(nextMissingCrc));\nsubStreamsInfo.crcs[nextCrc] = missingCrcs[nextMissingCrc];\n++nextCrc;\n++nextMissingCrc;\n}\n}\n}\n\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated SubStreamsInfo\");\n}\n\narchive.subStreamsInfo = subStreamsInfo;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readBits(final DataInput header, final int size) throws IOException {\nfinal BitSet bits = new BitSet(size);\nint mask = 0;\nint cache = 0;\nfor (int i = 0; i < size; i++) {\nif (mask == 0) {\nmask = 0x80;\ncache = header.readUnsignedByte();\n}\nbits.set(i, (cache & mask) != 0);\nmask >>>= 1;\n}\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFilesInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readFilesInfo(final DataInput header, final Archive archive) throws IOException {\nfinal long numFiles = readUint64(header);\nfinal SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\nfor (int i = 0; i < files.length; i++) {\nfiles[i] = new SevenZArchiveEntry();\n}\nBitSet isEmptyStream = null;\nBitSet isEmptyFile = null;\nBitSet isAnti = null;\nwhile (true) {\nfinal int propertyType = header.readUnsignedByte();\nif (propertyType == 0) {\nbreak;\n}\nlong size = readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream: {\nisEmptyStream = readBits(header, files.length);\nbreak;\n}\ncase NID.kEmptyFile: {\nif (isEmptyStream == null) { // protect against NPE\nthrow new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n}\nisEmptyFile = readBits(header, isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kAnti: {\nif (isEmptyStream == null) { // protect against NPE\nthrow new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n}\nisAnti = readBits(header, isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kName: {\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Not implemented\");\n} else {\nif (((size - 1) & 1) != 0) {\nthrow new IOException(\"File names length invalid\");\n}\nfinal byte[] names = new byte[(int)(size - 1)];\nheader.readFully(names);\nint nextFile = 0;\nint nextName = 0;\nfor (int i = 0; i < names.length; i += 2) {\nif (names[i] == 0 && names[i+1] == 0) {\nfiles[nextFile++].setName(new String(names, nextName, i-nextName, CharsetNames.UTF_16LE));\nnextName = i + 2;\n}\n}\nif (nextName != names.length || nextFile != files.length) {\nthrow new IOException(\"Error parsing file names\");\n}\n}\nbreak;\n}\ncase NID.kCTime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasCreationDate(timesDefined.get(i));\nif (files[i].getHasCreationDate()) {\nfiles[i].setCreationDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kATime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasAccessDate(timesDefined.get(i));\nif (files[i].getHasAccessDate()) {\nfiles[i].setAccessDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kMTime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasLastModifiedDate(timesDefined.get(i));\nif (files[i].getHasLastModifiedDate()) {\nfiles[i].setLastModifiedDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kWinAttributes: {\nfinal BitSet attributesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasWindowsAttributes(attributesDefined.get(i));\nif (files[i].getHasWindowsAttributes()) {\nfiles[i].setWindowsAttributes(Integer.reverseBytes(header.readInt()));\n}\n}\n}\nbreak;\n}\ncase NID.kStartPos: {\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy: {\nthrow new IOException(\"kDummy is unsupported, please report\");\n}\n\ndefault: {\nthrow new IOException(\"Unknown property \" + propertyType);\n// FIXME: Should actually:\n//header.skipBytes((int)size);\n}\n}\n}\nint nonEmptyFileCounter = 0;\nint emptyFileCounter = 0;\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasStream((isEmptyStream == null) ? true : !isEmptyStream.get(i));\nif (files[i].hasStream()) {\nfiles[i].setDirectory(false);\nfiles[i].setAntiItem(false);\nfiles[i].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nfiles[i].setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nfiles[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n} else {\nfiles[i].setDirectory((isEmptyFile == null) ? true : !isEmptyFile.get(emptyFileCounter));\nfiles[i].setAntiItem((isAnti == null) ? false : isAnti.get(emptyFileCounter));\nfiles[i].setHasCrc(false);\nfiles[i].setSize(0);\n++emptyFileCounter;\n}\n}\narchive.files = files;\ncalculateStreamMap(archive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUint64(Ljava/io/DataInput;)J",
                                    "method_body": "private static long readUint64(final DataInput in) throws IOException {\n// long rather than int as it might get shifted beyond the range of an int\nlong firstByte = in.readUnsignedByte();\nint mask = 0x80;\nlong value = 0;\nfor (int i = 0; i < 8; i++) {\nif ((firstByte & mask) == 0) {\nreturn value | ((firstByte & (mask - 1)) << (8 * i));\n}\nlong nextByte = in.readUnsignedByte();\nvalue |= (nextByte << (8 * i));\nmask >>>= 1;\n}\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;JJ)V",
                                    "method_body": "public ChecksumVerifyingInputStream(final Checksum checksum, final InputStream in,\nfinal long size, final long expectedChecksum) {\nthis.checksum = checksum;\nthis.in = in;\nthis.expectedChecksum = expectedChecksum;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining <= 0) {\nreturn -1;\n}\nint ret = in.read();\nif (ret >= 0) {\nchecksum.update(ret);\n--bytesRemaining;\n}\nif (bytesRemaining == 0 && expectedChecksum != checksum.getValue()) {\nthrow new IOException(\"Checksum verification failed\");\n}\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nint ret = in.read(b, off, len);\nif (ret >= 0) {\nchecksum.update(b, off, ret);\nbytesRemaining -= ret;\n}\nif (bytesRemaining <= 0 && expectedChecksum != checksum.getValue()) {\nthrow new IOException(\"Checksum verification failed\");\n}\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nin.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CRC32VerifyingInputStream:<init>(Ljava/io/InputStream;JJ)V",
                                    "method_body": "public CRC32VerifyingInputStream(final InputStream in, final long size, final long expectedCrc32) {\nsuper(new CRC32(), in, size, expectedCrc32);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:<init>(Ljava/io/RandomAccessFile;J)V",
                                    "method_body": "public BoundedRandomAccessFileInputStream(final RandomAccessFile file,\nfinal long size) {\nthis.file = file;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining > 0) {\n--bytesRemaining;\nreturn file.read();\n} else {\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif (bytesRemaining == 0) {\nreturn -1;\n}\nint bytesToRead = len;\nif (bytesToRead > bytesRemaining) {\nbytesToRead = (int) bytesRemaining;\n}\nfinal int bytesRead = file.read(b, off, bytesToRead);\nif (bytesRead >= 0) {\nbytesRemaining -= bytesRead;\n}\nreturn bytesRead;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:close()V",
                                    "method_body": "public void close() {\n// the nested RandomAccessFile is controlled externally\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:<init>(Ljava/lang/String;I[B)V",
                                    "method_body": "private SevenZMethod(byte[] id) {\nthis.id = id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:<init>()V",
                                    "method_body": "public SevenZArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "public void setName(String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:hasStream()Z",
                                    "method_body": "public boolean hasStream() {\nreturn hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasStream(Z)V",
                                    "method_body": "public void setHasStream(boolean hasStream) {\nthis.hasStream = hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nreturn isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setDirectory(Z)V",
                                    "method_body": "public void setDirectory(boolean isDirectory) {\nthis.isDirectory = isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isAntiItem()Z",
                                    "method_body": "public boolean isAntiItem() {\nreturn isAntiItem;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasCreationDate()Z",
                                    "method_body": "public boolean getHasCreationDate() {\nreturn hasCreationDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasLastModifiedDate()Z",
                                    "method_body": "public boolean getHasLastModifiedDate() {\nreturn hasLastModifiedDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getLastModifiedDate()Ljava/util/Date;",
                                    "method_body": "public Date getLastModifiedDate() {\nif (hasLastModifiedDate) {\nreturn ntfsTimeToJavaTime(lastModifiedDate);\n} else {\nthrow new UnsupportedOperationException(\n\"The entry doesn't have this timestamp\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setLastModifiedDate(Ljava/util/Date;)V",
                                    "method_body": "public void setLastModifiedDate(Date lastModifiedDate) {\nhasLastModifiedDate = lastModifiedDate != null;\nif (hasLastModifiedDate) {\nthis.lastModifiedDate = javaTimeToNtfsTime(lastModifiedDate);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasAccessDate()Z",
                                    "method_body": "public boolean getHasAccessDate() {\nreturn hasAccessDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasWindowsAttributes()Z",
                                    "method_body": "public boolean getHasWindowsAttributes() {\nreturn hasWindowsAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasCrc(Z)V",
                                    "method_body": "public void setHasCrc(boolean hasCrc) {\nthis.hasCrc = hasCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCompressedSize(J)V",
                                    "method_body": "void setCompressedSize(long size) {\nthis.compressedSize = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:ntfsTimeToJavaTime(J)Ljava/util/Date;",
                                    "method_body": "public static Date ntfsTimeToJavaTime(final long ntfsTime) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nfinal long realTime = ntfsEpoch.getTimeInMillis() + (ntfsTime / (10*1000));\nreturn new Date(realTime);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:javaTimeToNtfsTime(Ljava/util/Date;)J",
                                    "method_body": "public static long javaTimeToNtfsTime(final Date date) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nreturn ((date.getTime() - ntfsEpoch.getTimeInMillis())* 1000 * 10);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZOutputFile(final File filename) throws IOException {\nfile = new RandomAccessFile(filename, \"rw\");\nfile.seek(SevenZFile.SIGNATURE_HEADER_SIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!finished) {\nfinish();\n}\nfile.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:createArchiveEntry(Ljava/io/File;Ljava/lang/String;)Lorg/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry;",
                                    "method_body": "public SevenZArchiveEntry createArchiveEntry(final File inputFile,\nfinal String entryName) throws IOException {\nfinal SevenZArchiveEntry entry = new SevenZArchiveEntry();\nentry.setDirectory(inputFile.isDirectory());\nentry.setName(entryName);\nentry.setLastModifiedDate(new Date(inputFile.lastModified()));\nreturn entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\nfinal SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;\nfiles.add(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (currentOutputStream != null) {\ncurrentOutputStream.flush();\ncurrentOutputStream.close();\n}\n\nfinal SevenZArchiveEntry entry = files.get(files.size() - 1);\nif (fileBytesWritten > 0) {\nentry.setHasStream(true);\n++numNonEmptyStreams;\nentry.setSize(currentOutputStream.getBytesWritten());\nentry.setCompressedSize(fileBytesWritten);\nentry.setCrcValue(crc32.getValue());\nentry.setCompressedCrcValue(compressedCrc32.getValue());\nentry.setHasCrc(true);\n} else {\nentry.setHasStream(false);\nentry.setSize(0);\nentry.setCompressedSize(0);\nentry.setHasCrc(false);\n}\ncurrentOutputStream = null;\ncrc32.reset();\ncompressedCrc32.reset();\nfileBytesWritten = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([B)V",
                                    "method_body": "public void write(final byte[] b) throws IOException {\nwrite(b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int off, final int len) throws IOException {\nif (len > 0) {\ngetCurrentOutputStream().write(b, off, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif (finished) {\nthrow new IOException(\"This archive has already been finished\");\n}\nfinished = true;\n\nfinal long headerPosition = file.getFilePointer();\n\nfinal ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();\nfinal DataOutputStream header = new DataOutputStream(headerBaos);\n\nwriteHeader(header);\nheader.flush();\nfinal byte[] headerBytes = headerBaos.toByteArray();\nfile.write(headerBytes);\n\nfinal CRC32 crc32 = new CRC32();\n\n// signature header\nfile.seek(0);\nfile.write(SevenZFile.sevenZSignature);\n// version\nfile.write(0);\nfile.write(2);\n\n// start header\nfinal ByteArrayOutputStream startHeaderBaos = new ByteArrayOutputStream();\nfinal DataOutputStream startHeaderStream = new DataOutputStream(startHeaderBaos);\nstartHeaderStream.writeLong(Long.reverseBytes(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE));\nstartHeaderStream.writeLong(Long.reverseBytes(0xffffFFFFL & headerBytes.length));\ncrc32.reset();\ncrc32.update(headerBytes);\nstartHeaderStream.writeInt(Integer.reverseBytes((int)crc32.getValue()));\nstartHeaderStream.flush();\nfinal byte[] startHeaderBytes = startHeaderBaos.toByteArray();\ncrc32.reset();\ncrc32.update(startHeaderBytes);\nfile.writeInt(Integer.reverseBytes((int) crc32.getValue()));\nfile.write(startHeaderBytes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeHeader(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeHeader(final DataOutput header) throws IOException {\nheader.write(NID.kHeader);\n\nheader.write(NID.kMainStreamsInfo);\nwriteStreamsInfo(header);\nwriteFilesInfo(header);\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeStreamsInfo(final DataOutput header) throws IOException {\nif (numNonEmptyStreams > 0) {\nwritePackInfo(header);\nwriteUnpackInfo(header);\n}\n\nwriteSubStreamsInfo(header);\n\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeSubStreamsInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeSubStreamsInfo(final DataOutput header) throws IOException {\nheader.write(NID.kSubStreamsInfo);\n//\n//        header.write(NID.kCRC);\n//        header.write(1);\n//        for (final SevenZArchiveEntry entry : files) {\n//            if (entry.getHasCrc()) {\n//                header.writeInt(Integer.reverseBytes(entry.getCrc()));\n//            }\n//        }\n//\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFilesInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFilesInfo(final DataOutput header) throws IOException {\nheader.write(NID.kFilesInfo);\n\nwriteUint64(header, files.size());\n\nwriteFileEmptyStreams(header);\nwriteFileEmptyFiles(header);\nwriteFileAntiItems(header);\nwriteFileNames(header);\nwriteFileCTimes(header);\nwriteFileATimes(header);\nwriteFileMTimes(header);\nwriteFileWindowsAttributes(header);\nheader.write(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyStreams(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyStreams(final DataOutput header) throws IOException {\nboolean hasEmptyStreams = false;\nfor (final SevenZArchiveEntry entry : files) {\nif (!entry.hasStream()) {\nhasEmptyStreams = true;\nbreak;\n}\n}\nif (hasEmptyStreams) {\nheader.write(NID.kEmptyStream);\nfinal BitSet emptyStreams = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nemptyStreams.set(i, !files.get(i).hasStream());\n}\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyStreams, files.size());\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyFiles(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileEmptyFiles(final DataOutput header) throws IOException {\nboolean hasEmptyFiles = false;\nint emptyStreamCounter = 0;\nfinal BitSet emptyFiles = new BitSet(0);\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isDir = files.get(i).isDirectory();\nemptyFiles.set(emptyStreamCounter++, !isDir);\nhasEmptyFiles |= !isDir;\n}\n}\nif (hasEmptyFiles) {\nheader.write(NID.kEmptyFile);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyFiles, emptyStreamCounter);\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileAntiItems(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileAntiItems(final DataOutput header) throws IOException {\nboolean hasAntiItems = false;\nfinal BitSet antiItems = new BitSet(0);\nint antiItemCounter = 0;\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isAnti = files.get(i).isAntiItem();\nantiItems.set(antiItemCounter++, isAnti);\nhasAntiItems |= isAnti;\n}\n}\nif (hasAntiItems) {\nheader.write(NID.kAnti);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, antiItems, antiItemCounter);\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileNames(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileNames(final DataOutput header) throws IOException {\nheader.write(NID.kName);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nout.write(entry.getName().getBytes(\"UTF-16LE\"));\nout.writeShort(0);\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileCTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileCTimes(final DataOutput header) throws IOException {\nint numCreationDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasCreationDate()) {\n++numCreationDates;\n}\n}\nif (numCreationDates > 0) {\nheader.write(NID.kCTime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numCreationDates != files.size()) {\nout.write(0);\nfinal BitSet cTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\ncTimes.set(i, files.get(i).getHasCreationDate());\n}\nwriteBits(out, cTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasCreationDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getCreationDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileATimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileATimes(final DataOutput header) throws IOException {\nint numAccessDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasAccessDate()) {\n++numAccessDates;\n}\n}\nif (numAccessDates > 0) {\nheader.write(NID.kATime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numAccessDates != files.size()) {\nout.write(0);\nfinal BitSet aTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\naTimes.set(i, files.get(i).getHasAccessDate());\n}\nwriteBits(out, aTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasAccessDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getAccessDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileMTimes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileMTimes(final DataOutput header) throws IOException {\nint numLastModifiedDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\n++numLastModifiedDates;\n}\n}\nif (numLastModifiedDates > 0) {\nheader.write(NID.kMTime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numLastModifiedDates != files.size()) {\nout.write(0);\nfinal BitSet mTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nmTimes.set(i, files.get(i).getHasLastModifiedDate());\n}\nwriteBits(out, mTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getLastModifiedDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileWindowsAttributes(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFileWindowsAttributes(final DataOutput header) throws IOException {\nint numWindowsAttributes = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasWindowsAttributes()) {\n++numWindowsAttributes;\n}\n}\nif (numWindowsAttributes > 0) {\nheader.write(NID.kWinAttributes);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numWindowsAttributes != files.size()) {\nout.write(0);\nfinal BitSet attributes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nattributes.set(i, files.get(i).getHasWindowsAttributes());\n}\nwriteBits(out, attributes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasWindowsAttributes()) {\nout.writeInt(Integer.reverseBytes(entry.getWindowsAttributes()));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeUint64(Ljava/io/DataOutput;J)V",
                                    "method_body": "private void writeUint64(final DataOutput header, long value) throws IOException {\nint firstByte = 0;\nint mask = 0x80;\nint i;\nfor (i = 0; i < 8; i++) {\nif (value < ((1L << ( 7  * (i + 1))))) {\nfirstByte |= (value >>> (8 * i));\nbreak;\n}\nfirstByte |= mask;\nmask >>>= 1;\n}\nheader.write(firstByte);\nfor (; i > 0; i--) {\nheader.write((int) (0xff & value));\nvalue >>>= 8;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeBits(Ljava/io/DataOutput;Ljava/util/BitSet;I)V",
                                    "method_body": "private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\nint cache = 0;\nint shift = 7;\nfor (int i = 0; i < length; i++) {\ncache |= ((bits.get(i) ? 1 : 0) << shift);\n--shift;\nif (shift == 0) {\nheader.write(cache);\nshift = 7;\ncache = 0;\n}\n}\nif (length > 0 && shift > 0) {\nheader.write(cache);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public CountingOutputStream(final OutputStream out) {\nsuper(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int off, int len) throws IOException {\nout.write(b, off, len);\ncount(len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:count(J)V",
                                    "method_body": "protected void count(long written) {\nif (written != -1) {\nbytesWritten += written;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:getBytesWritten()J",
                                    "method_body": "public long getBytesWritten() {\nreturn bytesWritten;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readPackInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readPackInfo(final DataInput header, final Archive archive) throws IOException {\narchive.packPos = readUint64(header);\nfinal long numPackStreams = readUint64(header);\nint nid = header.readUnsignedByte();\nif (nid == NID.kSize) {\narchive.packSizes = new long[(int)numPackStreams];\nfor (int i = 0; i < archive.packSizes.length; i++) {\narchive.packSizes[i] = readUint64(header);\n}\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kCRC) {\narchive.packCrcsDefined = readAllOrBits(header, (int)numPackStreams);\narchive.packCrcs = new long[(int)numPackStreams];\nfor (int i = 0; i < (int)numPackStreams; i++) {\nif (archive.packCrcsDefined.get(i)) {\narchive.packCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n}\n}\n\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated PackInfo (\" + nid + \")\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUnpackInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readUnpackInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\nif (nid != NID.kFolder) {\nthrow new IOException(\"Expected kFolder, got \" + nid);\n}\nfinal long numFolders = readUint64(header);\nfinal Folder[] folders = new Folder[(int)numFolders];\narchive.folders = folders;\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"External unsupported\");\n} else {\nfor (int i = 0; i < (int)numFolders; i++) {\nfolders[i] = readFolder(header);\n}\n}\n\nnid = header.readUnsignedByte();\nif (nid != NID.kCodersUnpackSize) {\nthrow new IOException(\"Expected kCodersUnpackSize, got \" + nid);\n}\nfor (final Folder folder : folders) {\nfolder.unpackSizes = new long[(int)folder.totalOutputStreams];\nfor (int i = 0; i < folder.totalOutputStreams; i++) {\nfolder.unpackSizes[i] = readUint64(header);\n}\n}\n\nnid = header.readUnsignedByte();\nif (nid == NID.kCRC) {\nfinal BitSet crcsDefined = readAllOrBits(header, (int)numFolders);\nfor (int i = 0; i < (int)numFolders; i++) {\nif (crcsDefined.get(i)) {\nfolders[i].hasCrc = true;\nfolders[i].crc = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n} else {\nfolders[i].hasCrc = false;\n}\n}\n\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated UnpackInfo\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFolder(Ljava/io/DataInput;)Lorg/apache/commons/compress/archivers/sevenz/Folder;",
                                    "method_body": "private Folder readFolder(final DataInput header) throws IOException {\nfinal Folder folder = new Folder();\n\nfinal long numCoders = readUint64(header);\nfinal Coder[] coders = new Coder[(int)numCoders];\nlong totalInStreams = 0;\nlong totalOutStreams = 0;\nfor (int i = 0; i < coders.length; i++) {\ncoders[i] = new Coder();\nint bits = header.readUnsignedByte();\nfinal int idSize = bits & 0xf;\nfinal boolean isSimple = ((bits & 0x10) == 0);\nfinal boolean hasAttributes = ((bits & 0x20) != 0);\nfinal boolean moreAlternativeMethods = ((bits & 0x80) != 0);\n\ncoders[i].decompressionMethodId = new byte[idSize];\nheader.readFully(coders[i].decompressionMethodId);\nif (isSimple) {\ncoders[i].numInStreams = 1;\ncoders[i].numOutStreams = 1;\n} else {\ncoders[i].numInStreams = readUint64(header);\ncoders[i].numOutStreams = readUint64(header);\n}\ntotalInStreams += coders[i].numInStreams;\ntotalOutStreams += coders[i].numOutStreams;\nif (hasAttributes) {\nfinal long propertiesSize = readUint64(header);\ncoders[i].properties = new byte[(int)propertiesSize];\nheader.readFully(coders[i].properties);\n}\n// would need to keep looping as above:\nwhile (moreAlternativeMethods) {\nthrow new IOException(\"Alternative methods are unsupported, please report. \" +\n\"The reference implementation doesn't support them either.\");\n}\n}\nfolder.coders = coders;\nfolder.totalInputStreams = totalInStreams;\nfolder.totalOutputStreams = totalOutStreams;\n\nif (totalOutStreams == 0) {\nthrow new IOException(\"Total output streams can't be 0\");\n}\nfinal long numBindPairs = totalOutStreams - 1;\nfinal BindPair[] bindPairs = new BindPair[(int)numBindPairs];\nfor (int i = 0; i < bindPairs.length; i++) {\nbindPairs[i] = new BindPair();\nbindPairs[i].inIndex = readUint64(header);\nbindPairs[i].outIndex = readUint64(header);\n}\nfolder.bindPairs = bindPairs;\n\nif (totalInStreams < numBindPairs) {\nthrow new IOException(\"Total input streams can't be less than the number of bind pairs\");\n}\nfinal long numPackedStreams = totalInStreams - numBindPairs;\nfinal long packedStreams[] = new long[(int)numPackedStreams];\nif (numPackedStreams == 1) {\nint i;\nfor (i = 0; i < (int)totalInStreams; i++) {\nif (folder.findBindPairForInStream(i) < 0) {\nbreak;\n}\n}\nif (i == (int)totalInStreams) {\nthrow new IOException(\"Couldn't find stream's bind pair index\");\n}\npackedStreams[0] = i;\n} else {\nfor (int i = 0; i < (int)numPackedStreams; i++) {\npackedStreams[i] = readUint64(header);\n}\n}\nfolder.packedStreams = packedStreams;\n\nreturn folder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readAllOrBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readAllOrBits(final DataInput header, final int size) throws IOException {\nfinal int areAllDefined = header.readUnsignedByte();\nfinal BitSet bits;\nif (areAllDefined != 0) {\nbits = new BitSet(size);\nfor (int i = 0; i < size; i++) {\nbits.set(i, true);\n}\n} else {\nbits = readBits(header, size);\n}\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:calculateStreamMap(Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void calculateStreamMap(final Archive archive) throws IOException {\nfinal StreamMap streamMap = new StreamMap();\n\nint nextFolderPackStreamIndex = 0;\nfinal int numFolders = (archive.folders != null) ? archive.folders.length : 0;\nstreamMap.folderFirstPackStreamIndex = new int[numFolders];\nfor (int i = 0; i < numFolders; i++) {\nstreamMap.folderFirstPackStreamIndex[i] = nextFolderPackStreamIndex;\nnextFolderPackStreamIndex += archive.folders[i].packedStreams.length;\n}\n\nlong nextPackStreamOffset = 0;\nfinal int numPackSizes = (archive.packSizes != null) ? archive.packSizes.length : 0;\nstreamMap.packStreamOffsets = new long[numPackSizes];\nfor (int i = 0; i < numPackSizes; i++) {\nstreamMap.packStreamOffsets[i] = nextPackStreamOffset;\nnextPackStreamOffset += archive.packSizes[i];\n}\n\nstreamMap.folderFirstFileIndex = new int[numFolders];\nstreamMap.fileFolderIndex = new int[archive.files.length];\nint nextFolderIndex = 0;\nint nextFolderUnpackStreamIndex = 0;\nfor (int i = 0; i < archive.files.length; i++) {\nif (!archive.files[i].hasStream() && nextFolderUnpackStreamIndex == 0) {\nstreamMap.fileFolderIndex[i] = -1;\ncontinue;\n}\nif (nextFolderUnpackStreamIndex == 0) {\nfor (; nextFolderIndex < archive.folders.length; ++nextFolderIndex) {\nstreamMap.folderFirstFileIndex[nextFolderIndex] = i;\nif (archive.folders[nextFolderIndex].numUnpackSubStreams > 0) {\nbreak;\n}\n}\nif (nextFolderIndex >= archive.folders.length) {\nthrow new IOException(\"Too few folders in archive\");\n}\n}\nstreamMap.fileFolderIndex[i] = nextFolderIndex;\nif (!archive.files[i].hasStream()) {\ncontinue;\n}\n++nextFolderUnpackStreamIndex;\nif (nextFolderUnpackStreamIndex >= archive.folders[nextFolderIndex].numUnpackSubStreams) {\n++nextFolderIndex;\nnextFolderUnpackStreamIndex = 0;\n}\n}\n\narchive.streamMap = streamMap;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:findBindPairForInStream(I)I",
                                    "method_body": "int findBindPairForInStream(final int index) {\nfor (int i = 0; i < bindPairs.length; i++) {\nif (bindPairs[i].inIndex == index) {\nreturn i;\n}\n}\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:findBindPairForOutStream(I)I",
                                    "method_body": "int findBindPairForOutStream(final int index) {\nfor (int i = 0; i < bindPairs.length; i++) {\nif (bindPairs[i].outIndex == index) {\nreturn i;\n}\n}\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:getUnpackSize()J",
                                    "method_body": "long getUnpackSize() {\nif (totalOutputStreams == 0) {\nreturn 0;\n}\nfor (int i = ((int)totalOutputStreams) - 1; i >= 0; i--) {\nif (findBindPairForOutStream(i) < 0) {\nreturn unpackSizes[i];\n}\n}\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders:<clinit>()V",
                                    "method_body": "static CoderId[] coderTable = new CoderId[] {\nnew CoderId(SevenZMethod.COPY, new CopyDecoder()),\nnew CoderId(SevenZMethod.LZMA, new LZMADecoder()),\nnew CoderId(SevenZMethod.LZMA2, new LZMA2Decoder()),\nnew CoderId(SevenZMethod.DEFLATE, new DeflateDecoder()),\nnew CoderId(SevenZMethod.BZIP2, new BZIP2Decoder()),\nnew CoderId(SevenZMethod.AES256SHA256, new AES256SHA256Decoder())\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders:addEncoder(Ljava/io/OutputStream;Lorg/apache/commons/compress/archivers/sevenz/SevenZMethod;[B)Ljava/io/OutputStream;",
                                    "method_body": "static OutputStream addEncoder(final OutputStream out, final SevenZMethod method,\nfinal byte[] password) throws IOException {\nfor (final CoderId coderId : coderTable) {\nif (coderId.method.equals(method)) {\nreturn coderId.coder.encode(out, password);\n}\n}\nthrow new IOException(\"Unsupported compression method \" + method);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$CoderId:<init>(Lorg/apache/commons/compress/archivers/sevenz/SevenZMethod;Lorg/apache/commons/compress/archivers/sevenz/Coders$CoderBase;)V",
                                    "method_body": "CoderId(SevenZMethod method, final CoderBase coder) {\nthis.method = method;\nthis.coder = coder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:getId()[B",
                                    "method_body": "byte[] getId() {\nbyte[] copy = new byte[id.length];\nSystem.arraycopy(id, 0, copy, 0, id.length);\nreturn copy;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod$1:getProperties()[B",
                                    "method_body": "byte[] getProperties() {\nint dictSize = LZMA2Options.DICT_SIZE_DEFAULT;\nint lead = Integer.numberOfLeadingZeros(dictSize);\nint secondBit = (dictSize >>> (30 - lead)) - 2;\nreturn new byte[] {\n(byte) ((19 - lead) * 2 + secondBit)\n};\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$CoderBase:<init>()V",
                                    "method_body": "final SevenZMethod method;\nfinal CoderBase coder;\n}\n\nstatic abstract class CoderBase {\nabstract InputStream decode(final InputStream in, final Coder coder,\nbyte[] password) throws IOException;\nOutputStream encode(final OutputStream out, final byte[] password)\nthrows IOException {\nthrow new UnsupportedOperationException(\"method doesn't support writing\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.LZMA2Decoder:encode(Ljava/io/OutputStream;[B)Ljava/io/OutputStream;",
                                    "method_body": "OutputStream encode(final OutputStream out, final byte[] password)\nthrows IOException {\nLZMA2Options options = new LZMA2Options();\noptions.setDictSize(LZMA2Options.DICT_SIZE_DEFAULT);\nFinishableOutputStream wrapped = new FinishableWrapperOutputStream(out);\nreturn options.getOutputStream(wrapped);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setAntiItem(Z)V",
                                    "method_body": "public void setAntiItem(boolean isAntiItem) {\nthis.isAntiItem = isAntiItem;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getCrcValue()J",
                                    "method_body": "public long getCrcValue() {\nreturn crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCrcValue(J)V",
                                    "method_body": "public void setCrcValue(long crc) {\nthis.crc = crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getCompressedCrcValue()J",
                                    "method_body": "long getCompressedCrcValue() {\nreturn compressedCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCompressedCrcValue(J)V",
                                    "method_body": "void setCompressedCrcValue(long crc) {\nthis.compressedCrc = crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getCompressedSize()J",
                                    "method_body": "long getCompressedSize() {\nreturn compressedSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:getCurrentOutputStream()Ljava/io/OutputStream;",
                                    "method_body": "private OutputStream getCurrentOutputStream() throws IOException {\nif (currentOutputStream == null) {\ncurrentOutputStream = setupFileOutputStream();\n}\nreturn currentOutputStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:setupFileOutputStream()Lorg/apache/commons/compress/utils/CountingOutputStream;",
                                    "method_body": "private CountingOutputStream setupFileOutputStream() throws IOException {\nOutputStream out = new OutputStreamWrapper();\nreturn new CountingOutputStream(Coders\n.addEncoder(out,\ncontentCompression,\nnull)) {\n@Override\npublic void write(final int b) throws IOException {\nsuper.write(b);\ncrc32.update(b);\n}\n\n@Override\npublic void write(final byte[] b) throws IOException {\nsuper.write(b);\ncrc32.update(b);\n}\n\n@Override\npublic void write(final byte[] b, final int off, final int len)\nthrows IOException {\nsuper.write(b, off, len);\ncrc32.update(b, off, len);\n}\n};\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writePackInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writePackInfo(final DataOutput header) throws IOException {\nheader.write(NID.kPackInfo);\n\nwriteUint64(header, 0);\nwriteUint64(header, 0xffffFFFFL & numNonEmptyStreams);\n\nheader.write(NID.kSize);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nwriteUint64(header, entry.getCompressedSize());\n}\n}\n\nheader.write(NID.kCRC);\nheader.write(1);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nheader.writeInt(Integer.reverseBytes((int) entry.getCompressedCrcValue()));\n}\n}\n\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeUnpackInfo(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeUnpackInfo(final DataOutput header) throws IOException {\nheader.write(NID.kUnpackInfo);\n\nheader.write(NID.kFolder);\nwriteUint64(header, numNonEmptyStreams);\nheader.write(0);\nfor (int i = 0; i < numNonEmptyStreams; i++) {\nwriteFolder(header);\n}\n\nheader.write(NID.kCodersUnpackSize);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nwriteUint64(header, entry.getSize());\n}\n}\n\nheader.write(NID.kCRC);\nheader.write(1);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.hasStream()) {\nheader.writeInt(Integer.reverseBytes((int) entry.getCrcValue()));\n}\n}\n\nheader.write(NID.kEnd);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFolder(Ljava/io/DataOutput;)V",
                                    "method_body": "private void writeFolder(final DataOutput header) throws IOException {\n// one coder\nwriteUint64(header, 1);\nbyte[] id = contentCompression.getId();\nbyte[] properties = contentCompression.getProperties();\n\nint codecFlags = id.length;\nif (properties.length > 0) {\ncodecFlags |= 0x20;\n}\nheader.write(codecFlags);\nheader.write(id);\n\nif (properties.length > 0) {\nheader.write(properties.length);\nheader.write(properties);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:write(I)V",
                                    "method_body": "public void write(final int b) throws IOException {\nfile.write(b);\ncompressedCrc32.update(b);\nfileBytesWritten++;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int off, final int len)\nthrows IOException {\nfile.write(b, off, len);\ncompressedCrc32.update(b, off, len);\nfileBytesWritten += len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:flush()V",
                                    "method_body": "public void flush() throws IOException {\n// no reason to flush a RandomAccessFile\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$OutputStreamWrapper:close()V",
                                    "method_body": "public void close() throws IOException {\n// the file will be closed by the containing class's close method\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile$1:write([BII)V",
                                    "method_body": "private CountingOutputStream setupFileOutputStream() throws IOException {\nOutputStream out = new OutputStreamWrapper();\nreturn new CountingOutputStream(Coders\n.addEncoder(out,\ncontentCompression,\nnull)) {\n@Override\npublic void write(final int b) throws IOException {\nsuper.write(b);\ncrc32.update(b);\n}\n\n@Override\npublic void write(final byte[] b) throws IOException {\nsuper.write(b);\ncrc32.update(b);\n}\n\n@Override\npublic void write(final byte[] b, final int off, final int len)\nthrows IOException {\nsuper.write(b, off, len);\ncrc32.update(b, off, len);\n}\n};\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 22,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.compressors.bzip2.PythonTruncatedBzip2Test.testPartialReadTruncatedData",
                            "test_body": "85: public void testPartialReadTruncatedData() throws IOException {\n86: //with BZ2File(self.filename) as f:\n87: //    self.assertEqual(f.read(len(self.TEXT)), self.TEXT)\n88: //    self.assertRaises(EOFError, f.read, 1)\n89: 90: final int length = TEXT.length();\n91: ByteBuffer buffer = ByteBuffer.allocate(length);\n92: bz2Channel.read(buffer);\n93: 94: assertArrayEquals(Arrays.copyOfRange(TEXT.getBytes(), 0, length),\n95: buffer.array());\n96: 97: // subsequent read should throw\n98: buffer = ByteBuffer.allocate(1);\n99: try {\n100: bz2Channel.read(buffer);\n101: Assert.fail(\"The read should have thrown.\");\n102: } catch (IOException e) {\n103: // pass\n104: }\n105: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.CompressorInputStream:count(I)V",
                                    "method_body": "protected void count(int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.CompressorInputStream:count(J)V",
                                    "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:<init>(Ljava/io/InputStream;Z)V",
                                    "method_body": "public BZip2CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException {\nthis.in = in;\nthis.decompressConcatenated = decompressConcatenated;\n\ninit(true);\ninitBlock();\nsetupBlock();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:read([BII)I",
                                    "method_body": "public int read(final byte[] dest, final int offs, final int len)\nthrows IOException {\nif (offs < 0) {\nthrow new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\");\n}\nif (len < 0) {\nthrow new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\");\n}\nif (offs + len > dest.length) {\nthrow new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\"\n+ len + \") > dest.length(\" + dest.length + \").\");\n}\nif (this.in == null) {\nthrow new IOException(\"stream closed\");\n}\n\nfinal int hi = offs + len;\nint destOffs = offs;\nint b;\nwhile (destOffs < hi && ((b = read0()) >= 0)) {\ndest[destOffs++] = (byte) b;\ncount(1);\n}\n\nint c = (destOffs == offs) ? -1 : (destOffs - offs);\nreturn c;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:makeMaps()V",
                                    "method_body": "private void makeMaps() {\nfinal boolean[] inUse = this.data.inUse;\nfinal byte[] seqToUnseq = this.data.seqToUnseq;\n\nint nInUseShadow = 0;\n\nfor (int i = 0; i < 256; i++) {\nif (inUse[i]) {\nseqToUnseq[nInUseShadow++] = (byte) i;\n}\n}\n\nthis.nInUse = nInUseShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:read0()I",
                                    "method_body": "private int read0() throws IOException {\nfinal int retChar = this.currentChar;\nswitch (currentState) {\ncase EOF:\nreturn -1;\n\ncase START_BLOCK_STATE:\nthrow new IllegalStateException();\n\ncase RAND_PART_A_STATE:\nthrow new IllegalStateException();\n\ncase RAND_PART_B_STATE:\nsetupRandPartB();\nbreak;\n\ncase RAND_PART_C_STATE:\nsetupRandPartC();\nbreak;\n\ncase NO_RAND_PART_A_STATE:\nthrow new IllegalStateException();\n\ncase NO_RAND_PART_B_STATE:\nsetupNoRandPartB();\nbreak;\n\ncase NO_RAND_PART_C_STATE:\nsetupNoRandPartC();\nbreak;\n\ndefault:\nthrow new IllegalStateException();\n}\nreturn retChar;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:init(Z)Z",
                                    "method_body": "private boolean init(boolean isFirstStream) throws IOException {\nif (null == in) {\nthrow new IOException(\"No InputStream\");\n}\n\nint magic0 = this.in.read();\nif (magic0 == -1 && !isFirstStream) {\nreturn false;\n}\nint magic1 = this.in.read();\nint magic2 = this.in.read();\n\nif (magic0 != 'B' || magic1 != 'Z' || magic2 != 'h') {\nthrow new IOException(isFirstStream\n? \"Stream is not in the BZip2 format\"\n: \"Garbage after a valid BZip2 stream\");\n}\n\nint blockSize = this.in.read();\nif ((blockSize < '1') || (blockSize > '9')) {\nthrow new IOException(\"BZip2 block size is invalid\");\n}\n\nthis.blockSize100k = blockSize - '0';\n\nthis.bsLive = 0;\nthis.computedCombinedCRC = 0;\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:initBlock()V",
                                    "method_body": "private void initBlock() throws IOException {\nchar magic0;\nchar magic1;\nchar magic2;\nchar magic3;\nchar magic4;\nchar magic5;\n\nwhile (true) {\n// Get the block magic bytes.\nmagic0 = bsGetUByte();\nmagic1 = bsGetUByte();\nmagic2 = bsGetUByte();\nmagic3 = bsGetUByte();\nmagic4 = bsGetUByte();\nmagic5 = bsGetUByte();\n\n// If isn't end of stream magic, break out of the loop.\nif (magic0 != 0x17 || magic1 != 0x72 || magic2 != 0x45\n|| magic3 != 0x38 || magic4 != 0x50 || magic5 != 0x90) {\nbreak;\n}\n\n// End of stream was reached. Check the combined CRC and\n// advance to the next .bz2 stream if decoding concatenated\n// streams.\nif (complete()) {\nreturn;\n}\n}\n\nif (magic0 != 0x31 || // '1'\nmagic1 != 0x41 || // ')'\nmagic2 != 0x59 || // 'Y'\nmagic3 != 0x26 || // '&'\nmagic4 != 0x53 || // 'S'\nmagic5 != 0x59 // 'Y'\n) {\nthis.currentState = EOF;\nthrow new IOException(\"bad block header\");\n} else {\nthis.storedBlockCRC = bsGetInt();\nthis.blockRandomised = bsR(1) == 1;\n\n/**\n* Allocate data here instead in constructor, so we do not allocate\n* it if the input file is empty.\n*/\nif (this.data == null) {\nthis.data = new Data(this.blockSize100k);\n}\n\n// currBlockNo++;\ngetAndMoveToFrontDecode();\n\nthis.crc.initialiseCRC();\nthis.currentState = START_BLOCK_STATE;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:endBlock()V",
                                    "method_body": "private void endBlock() throws IOException {\nthis.computedBlockCRC = this.crc.getFinalCRC();\n\n// A bad CRC is considered a fatal error.\nif (this.storedBlockCRC != this.computedBlockCRC) {\n// make next blocks readable without error\n// (repair feature, not yet documented, not tested)\nthis.computedCombinedCRC = (this.storedCombinedCRC << 1)\n| (this.storedCombinedCRC >>> 31);\nthis.computedCombinedCRC ^= this.storedBlockCRC;\n\nthrow new IOException(\"BZip2 CRC error\");\n}\n\nthis.computedCombinedCRC = (this.computedCombinedCRC << 1)\n| (this.computedCombinedCRC >>> 31);\nthis.computedCombinedCRC ^= this.computedBlockCRC;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nInputStream inShadow = this.in;\nif (inShadow != null) {\ntry {\nif (inShadow != System.in) {\ninShadow.close();\n}\n} finally {\nthis.data = null;\nthis.in = null;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsR(I)I",
                                    "method_body": "private int bsR(final int n) throws IOException {\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nif (bsLiveShadow < n) {\nfinal InputStream inShadow = this.in;\ndo {\nint thech = inShadow.read();\n\nif (thech < 0) {\nthrow new IOException(\"unexpected end of stream\");\n}\n\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\n} while (bsLiveShadow < n);\n\nthis.bsBuff = bsBuffShadow;\n}\n\nthis.bsLive = bsLiveShadow - n;\nreturn (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsGetBit()Z",
                                    "method_body": "private boolean bsGetBit() throws IOException {\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nif (bsLiveShadow < 1) {\nint thech = this.in.read();\n\nif (thech < 0) {\nthrow new IOException(\"unexpected end of stream\");\n}\n\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\nthis.bsBuff = bsBuffShadow;\n}\n\nthis.bsLive = bsLiveShadow - 1;\nreturn ((bsBuffShadow >> (bsLiveShadow - 1)) & 1) != 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsGetUByte()C",
                                    "method_body": "private char bsGetUByte() throws IOException {\nreturn (char) bsR(8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsGetInt()I",
                                    "method_body": "private int bsGetInt() throws IOException {\nreturn (((((bsR(8) << 8) | bsR(8)) << 8) | bsR(8)) << 8) | bsR(8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:hbCreateDecodeTables([I[I[I[CIII)V",
                                    "method_body": "private static void hbCreateDecodeTables(final int[] limit,\nfinal int[] base, final int[] perm, final char[] length,\nfinal int minLen, final int maxLen, final int alphaSize) {\nfor (int i = minLen, pp = 0; i <= maxLen; i++) {\nfor (int j = 0; j < alphaSize; j++) {\nif (length[j] == i) {\nperm[pp++] = j;\n}\n}\n}\n\nfor (int i = MAX_CODE_LEN; --i > 0;) {\nbase[i] = 0;\nlimit[i] = 0;\n}\n\nfor (int i = 0; i < alphaSize; i++) {\nbase[length[i] + 1]++;\n}\n\nfor (int i = 1, b = base[0]; i < MAX_CODE_LEN; i++) {\nb += base[i];\nbase[i] = b;\n}\n\nfor (int i = minLen, vec = 0, b = base[i]; i <= maxLen; i++) {\nfinal int nb = base[i + 1];\nvec += nb - b;\nb = nb;\nlimit[i] = vec - 1;\nvec <<= 1;\n}\n\nfor (int i = minLen + 1; i <= maxLen; i++) {\nbase[i] = ((limit[i - 1] + 1) << 1) - base[i];\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:recvDecodingTables()V",
                                    "method_body": "private void recvDecodingTables() throws IOException {\nfinal Data dataShadow = this.data;\nfinal boolean[] inUse = dataShadow.inUse;\nfinal byte[] pos = dataShadow.recvDecodingTables_pos;\nfinal byte[] selector = dataShadow.selector;\nfinal byte[] selectorMtf = dataShadow.selectorMtf;\n\nint inUse16 = 0;\n\n/* Receive the mapping table */\nfor (int i = 0; i < 16; i++) {\nif (bsGetBit()) {\ninUse16 |= 1 << i;\n}\n}\n\nfor (int i = 256; --i >= 0;) {\ninUse[i] = false;\n}\n\nfor (int i = 0; i < 16; i++) {\nif ((inUse16 & (1 << i)) != 0) {\nfinal int i16 = i << 4;\nfor (int j = 0; j < 16; j++) {\nif (bsGetBit()) {\ninUse[i16 + j] = true;\n}\n}\n}\n}\n\nmakeMaps();\nfinal int alphaSize = this.nInUse + 2;\n\n/* Now the selectors */\nfinal int nGroups = bsR(3);\nfinal int nSelectors = bsR(15);\n\nfor (int i = 0; i < nSelectors; i++) {\nint j = 0;\nwhile (bsGetBit()) {\nj++;\n}\nselectorMtf[i] = (byte) j;\n}\n\n/* Undo the MTF values for the selectors. */\nfor (int v = nGroups; --v >= 0;) {\npos[v] = (byte) v;\n}\n\nfor (int i = 0; i < nSelectors; i++) {\nint v = selectorMtf[i] & 0xff;\nfinal byte tmp = pos[v];\nwhile (v > 0) {\n// nearly all times v is zero, 4 in most other cases\npos[v] = pos[v - 1];\nv--;\n}\npos[0] = tmp;\nselector[i] = tmp;\n}\n\nfinal char[][] len = dataShadow.temp_charArray2d;\n\n/* Now the coding tables */\nfor (int t = 0; t < nGroups; t++) {\nint curr = bsR(5);\nfinal char[] len_t = len[t];\nfor (int i = 0; i < alphaSize; i++) {\nwhile (bsGetBit()) {\ncurr += bsGetBit() ? -1 : 1;\n}\nlen_t[i] = (char) curr;\n}\n}\n\n// finally create the Huffman tables\ncreateHuffmanDecodingTables(alphaSize, nGroups);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:createHuffmanDecodingTables(II)V",
                                    "method_body": "private void createHuffmanDecodingTables(final int alphaSize,\nfinal int nGroups) {\nfinal Data dataShadow = this.data;\nfinal char[][] len = dataShadow.temp_charArray2d;\nfinal int[] minLens = dataShadow.minLens;\nfinal int[][] limit = dataShadow.limit;\nfinal int[][] base = dataShadow.base;\nfinal int[][] perm = dataShadow.perm;\n\nfor (int t = 0; t < nGroups; t++) {\nint minLen = 32;\nint maxLen = 0;\nfinal char[] len_t = len[t];\nfor (int i = alphaSize; --i >= 0;) {\nfinal char lent = len_t[i];\nif (lent > maxLen) {\nmaxLen = lent;\n}\nif (lent < minLen) {\nminLen = lent;\n}\n}\nhbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen,\nmaxLen, alphaSize);\nminLens[t] = minLen;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:getAndMoveToFrontDecode()V",
                                    "method_body": "private void getAndMoveToFrontDecode() throws IOException {\nthis.origPtr = bsR(24);\nrecvDecodingTables();\n\nfinal InputStream inShadow = this.in;\nfinal Data dataShadow = this.data;\nfinal byte[] ll8 = dataShadow.ll8;\nfinal int[] unzftab = dataShadow.unzftab;\nfinal byte[] selector = dataShadow.selector;\nfinal byte[] seqToUnseq = dataShadow.seqToUnseq;\nfinal char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\nfinal int[] minLens = dataShadow.minLens;\nfinal int[][] limit = dataShadow.limit;\nfinal int[][] base = dataShadow.base;\nfinal int[][] perm = dataShadow.perm;\nfinal int limitLast = this.blockSize100k * 100000;\n\n/*\n* Setting up the unzftab entries here is not strictly necessary, but it\n* does save having to do it later in a separate pass, and so saves a\n* block's worth of cache misses.\n*/\nfor (int i = 256; --i >= 0;) {\nyy[i] = (char) i;\nunzftab[i] = 0;\n}\n\nint groupNo = 0;\nint groupPos = G_SIZE - 1;\nfinal int eob = this.nInUse + 1;\nint nextSym = getAndMoveToFrontDecode0(0);\nint bsBuffShadow = this.bsBuff;\nint bsLiveShadow = this.bsLive;\nint lastShadow = -1;\nint zt = selector[groupNo] & 0xff;\nint[] base_zt = base[zt];\nint[] limit_zt = limit[zt];\nint[] perm_zt = perm[zt];\nint minLens_zt = minLens[zt];\n\nwhile (nextSym != eob) {\nif ((nextSym == RUNA) || (nextSym == RUNB)) {\nint s = -1;\n\nfor (int n = 1; true; n <<= 1) {\nif (nextSym == RUNA) {\ns += n;\n} else if (nextSym == RUNB) {\ns += n << 1;\n} else {\nbreak;\n}\n\nif (groupPos == 0) {\ngroupPos = G_SIZE - 1;\nzt = selector[++groupNo] & 0xff;\nbase_zt = base[zt];\nlimit_zt = limit[zt];\nperm_zt = perm[zt];\nminLens_zt = minLens[zt];\n} else {\ngroupPos--;\n}\n\nint zn = minLens_zt;\n\n// Inlined:\n// int zvec = bsR(zn);\nwhile (bsLiveShadow < zn) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\n} else {\nthrow new IOException(\"unexpected end of stream\");\n}\n}\nint zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n& ((1 << zn) - 1);\nbsLiveShadow -= zn;\n\nwhile (zvec > limit_zt[zn]) {\nzn++;\nwhile (bsLiveShadow < 1) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\n} else {\nthrow new IOException(\n\"unexpected end of stream\");\n}\n}\nbsLiveShadow--;\nzvec = (zvec << 1)\n| ((bsBuffShadow >> bsLiveShadow) & 1);\n}\nnextSym = perm_zt[zvec - base_zt[zn]];\n}\n\nfinal byte ch = seqToUnseq[yy[0]];\nunzftab[ch & 0xff] += s + 1;\n\nwhile (s-- >= 0) {\nll8[++lastShadow] = ch;\n}\n\nif (lastShadow >= limitLast) {\nthrow new IOException(\"block overrun\");\n}\n} else {\nif (++lastShadow >= limitLast) {\nthrow new IOException(\"block overrun\");\n}\n\nfinal char tmp = yy[nextSym - 1];\nunzftab[seqToUnseq[tmp] & 0xff]++;\nll8[lastShadow] = seqToUnseq[tmp];\n\n/*\n* This loop is hammered during decompression, hence avoid\n* native method call overhead of System.arraycopy for very\n* small ranges to copy.\n*/\nif (nextSym <= 16) {\nfor (int j = nextSym - 1; j > 0;) {\nyy[j] = yy[--j];\n}\n} else {\nSystem.arraycopy(yy, 0, yy, 1, nextSym - 1);\n}\n\nyy[0] = tmp;\n\nif (groupPos == 0) {\ngroupPos = G_SIZE - 1;\nzt = selector[++groupNo] & 0xff;\nbase_zt = base[zt];\nlimit_zt = limit[zt];\nperm_zt = perm[zt];\nminLens_zt = minLens[zt];\n} else {\ngroupPos--;\n}\n\nint zn = minLens_zt;\n\n// Inlined:\n// int zvec = bsR(zn);\nwhile (bsLiveShadow < zn) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\n} else {\nthrow new IOException(\"unexpected end of stream\");\n}\n}\nint zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n& ((1 << zn) - 1);\nbsLiveShadow -= zn;\n\nwhile (zvec > limit_zt[zn]) {\nzn++;\nwhile (bsLiveShadow < 1) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\n} else {\nthrow new IOException(\"unexpected end of stream\");\n}\n}\nbsLiveShadow--;\nzvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n}\nnextSym = perm_zt[zvec - base_zt[zn]];\n}\n}\n\nthis.last = lastShadow;\nthis.bsLive = bsLiveShadow;\nthis.bsBuff = bsBuffShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:getAndMoveToFrontDecode0(I)I",
                                    "method_body": "private int getAndMoveToFrontDecode0(final int groupNo) throws IOException {\nfinal InputStream inShadow = this.in;\nfinal Data dataShadow = this.data;\nfinal int zt = dataShadow.selector[groupNo] & 0xff;\nfinal int[] limit_zt = dataShadow.limit[zt];\nint zn = dataShadow.minLens[zt];\nint zvec = bsR(zn);\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nwhile (zvec > limit_zt[zn]) {\nzn++;\nwhile (bsLiveShadow < 1) {\nfinal int thech = inShadow.read();\n\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\n} else {\nthrow new IOException(\"unexpected end of stream\");\n}\n}\nbsLiveShadow--;\nzvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n}\n\nthis.bsLive = bsLiveShadow;\nthis.bsBuff = bsBuffShadow;\n\nreturn dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:setupBlock()I",
                                    "method_body": "private int setupBlock() throws IOException {\nif (currentState == EOF || this.data == null) {\nreturn -1;\n}\n\nfinal int[] cftab = this.data.cftab;\nfinal int[] tt = this.data.initTT(this.last + 1);\nfinal byte[] ll8 = this.data.ll8;\ncftab[0] = 0;\nSystem.arraycopy(this.data.unzftab, 0, cftab, 1, 256);\n\nfor (int i = 1, c = cftab[0]; i <= 256; i++) {\nc += cftab[i];\ncftab[i] = c;\n}\n\nfor (int i = 0, lastShadow = this.last; i <= lastShadow; i++) {\ntt[cftab[ll8[i] & 0xff]++] = i;\n}\n\nif ((this.origPtr < 0) || (this.origPtr >= tt.length)) {\nthrow new IOException(\"stream corrupted\");\n}\n\nthis.su_tPos = tt[this.origPtr];\nthis.su_count = 0;\nthis.su_i2 = 0;\nthis.su_ch2 = 256; /* not a char and not EOF */\n\nif (this.blockRandomised) {\nthis.su_rNToGo = 0;\nthis.su_rTPos = 0;\nreturn setupRandPartA();\n}\nreturn setupNoRandPartA();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:setupNoRandPartA()I",
                                    "method_body": "private int setupNoRandPartA() throws IOException {\nif (this.su_i2 <= this.last) {\nthis.su_chPrev = this.su_ch2;\nint su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;\nthis.su_ch2 = su_ch2Shadow;\nthis.su_tPos = this.data.tt[this.su_tPos];\nthis.su_i2++;\nthis.currentChar = su_ch2Shadow;\nthis.currentState = NO_RAND_PART_B_STATE;\nthis.crc.updateCRC(su_ch2Shadow);\nreturn su_ch2Shadow;\n} else {\nthis.currentState = NO_RAND_PART_A_STATE;\nendBlock();\ninitBlock();\nreturn setupBlock();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:setupNoRandPartB()I",
                                    "method_body": "private int setupNoRandPartB() throws IOException {\nif (this.su_ch2 != this.su_chPrev) {\nthis.su_count = 1;\nreturn setupNoRandPartA();\n} else if (++this.su_count >= 4) {\nthis.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff);\nthis.su_tPos = this.data.tt[this.su_tPos];\nthis.su_j2 = 0;\nreturn setupNoRandPartC();\n} else {\nreturn setupNoRandPartA();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:<init>()V",
                                    "method_body": "CRC() {\ninitialiseCRC();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:<clinit>()V",
                                    "method_body": "private static final int crc32Table[] = {\n0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,\n0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,\n0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,\n0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,\n0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,\n0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,\n0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,\n0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,\n0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,\n0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,\n0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,\n0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,\n0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,\n0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,\n0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,\n0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,\n0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,\n0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,\n0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,\n0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,\n0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,\n0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,\n0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,\n0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,\n0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,\n0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,\n0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,\n0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,\n0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,\n0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,\n0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,\n0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,\n0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,\n0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,\n0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,\n0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,\n0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,\n0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,\n0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,\n0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,\n0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,\n0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,\n0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,\n0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,\n0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,\n0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,\n0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,\n0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,\n0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,\n0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,\n0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,\n0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,\n0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,\n0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,\n0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,\n0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,\n0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,\n0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,\n0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,\n0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,\n0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,\n0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,\n0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,\n0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:initialiseCRC()V",
                                    "method_body": "void initialiseCRC() {\nglobalCrc = 0xffffffff;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:getFinalCRC()I",
                                    "method_body": "int getFinalCRC() {\nreturn ~globalCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:updateCRC(I)V",
                                    "method_body": "void updateCRC(int inCh) {\nint temp = (globalCrc >> 24) ^ inCh;\nif (temp < 0) {\ntemp = 256 + temp;\n}\nglobalCrc = (globalCrc << 8) ^ CRC.crc32Table[temp];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:updateCRC(II)V",
                                    "method_body": "void updateCRC(int inCh, int repeat) {\nint globalCrcShadow = this.globalCrc;\nwhile (repeat-- > 0) {\nint temp = (globalCrcShadow >> 24) ^ inCh;\nglobalCrcShadow = (globalCrcShadow << 8) ^ crc32Table[(temp >= 0)\n? temp\n: (temp + 256)];\n}\nthis.globalCrc = globalCrcShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream$Data:<init>(I)V",
                                    "method_body": "Data(int blockSize100k) {\nthis.ll8 = new byte[blockSize100k * BZip2Constants.BASEBLOCKSIZE];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream$Data:initTT(I)[I",
                                    "method_body": "int[] initTT(int length) {\nint[] ttShadow = this.tt;\n\n// tt.length should always be >= length, but theoretically\n// it can happen, if the compressor mixed small and large\n// blocks. Normally only the last block will be smaller\n// than others.\nif ((ttShadow == null) || (ttShadow.length < length)) {\nthis.tt = ttShadow = new int[length];\n}\n\nreturn ttShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public BZip2CompressorOutputStream(final OutputStream out)\nthrows IOException {\nthis(out, MAX_BLOCKSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:<init>(Ljava/io/OutputStream;I)V",
                                    "method_body": "public BZip2CompressorOutputStream(final OutputStream out, final int blockSize) throws IOException {\nif (blockSize < 1) {\nthrow new IllegalArgumentException(\"blockSize(\" + blockSize + \") < 1\");\n}\nif (blockSize > 9) {\nthrow new IllegalArgumentException(\"blockSize(\" + blockSize + \") > 9\");\n}\n\nthis.blockSize100k = blockSize;\nthis.out = out;\n\n/* 20 is just a paranoia constant */\nthis.allowableBlockSize = (this.blockSize100k * BZip2Constants.BASEBLOCKSIZE) - 20;\ninit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:hbMakeCodeLengths([B[ILorg/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream$Data;II)V",
                                    "method_body": "private static void hbMakeCodeLengths(final byte[] len, final int[] freq,\nfinal Data dat, final int alphaSize,\nfinal int maxLen) {\n/*\n* Nodes and heap entries run from 1. Entry 0 for both the heap and\n* nodes is a sentinel.\n*/\nfinal int[] heap = dat.heap;\nfinal int[] weight = dat.weight;\nfinal int[] parent = dat.parent;\n\nfor (int i = alphaSize; --i >= 0;) {\nweight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;\n}\n\nfor (boolean tooLong = true; tooLong;) {\ntooLong = false;\n\nint nNodes = alphaSize;\nint nHeap = 0;\nheap[0] = 0;\nweight[0] = 0;\nparent[0] = -2;\n\nfor (int i = 1; i <= alphaSize; i++) {\nparent[i] = -1;\nnHeap++;\nheap[nHeap] = i;\n\nint zz = nHeap;\nint tmp = heap[zz];\nwhile (weight[tmp] < weight[heap[zz >> 1]]) {\nheap[zz] = heap[zz >> 1];\nzz >>= 1;\n}\nheap[zz] = tmp;\n}\n\nwhile (nHeap > 1) {\nint n1 = heap[1];\nheap[1] = heap[nHeap];\nnHeap--;\n\nint yy = 0;\nint zz = 1;\nint tmp = heap[1];\n\nwhile (true) {\nyy = zz << 1;\n\nif (yy > nHeap) {\nbreak;\n}\n\nif ((yy < nHeap)\n&& (weight[heap[yy + 1]] < weight[heap[yy]])) {\nyy++;\n}\n\nif (weight[tmp] < weight[heap[yy]]) {\nbreak;\n}\n\nheap[zz] = heap[yy];\nzz = yy;\n}\n\nheap[zz] = tmp;\n\nint n2 = heap[1];\nheap[1] = heap[nHeap];\nnHeap--;\n\nyy = 0;\nzz = 1;\ntmp = heap[1];\n\nwhile (true) {\nyy = zz << 1;\n\nif (yy > nHeap) {\nbreak;\n}\n\nif ((yy < nHeap)\n&& (weight[heap[yy + 1]] < weight[heap[yy]])) {\nyy++;\n}\n\nif (weight[tmp] < weight[heap[yy]]) {\nbreak;\n}\n\nheap[zz] = heap[yy];\nzz = yy;\n}\n\nheap[zz] = tmp;\nnNodes++;\nparent[n1] = parent[n2] = nNodes;\n\nfinal int weight_n1 = weight[n1];\nfinal int weight_n2 = weight[n2];\nweight[nNodes] = ((weight_n1 & 0xffffff00)\n+ (weight_n2 & 0xffffff00))\n| (1 + (((weight_n1 & 0x000000ff)\n> (weight_n2 & 0x000000ff))\n? (weight_n1 & 0x000000ff)\n: (weight_n2 & 0x000000ff)));\n\nparent[nNodes] = -1;\nnHeap++;\nheap[nHeap] = nNodes;\n\ntmp = 0;\nzz = nHeap;\ntmp = heap[zz];\nfinal int weight_tmp = weight[tmp];\nwhile (weight_tmp < weight[heap[zz >> 1]]) {\nheap[zz] = heap[zz >> 1];\nzz >>= 1;\n}\nheap[zz] = tmp;\n\n}\n\nfor (int i = 1; i <= alphaSize; i++) {\nint j = 0;\nint k = i;\n\nfor (int parent_k; (parent_k = parent[k]) >= 0;) {\nk = parent_k;\nj++;\n}\n\nlen[i - 1] = (byte) j;\nif (j > maxLen) {\ntooLong = true;\n}\n}\n\nif (tooLong) {\nfor (int i = 1; i < alphaSize; i++) {\nint j = weight[i] >> 8;\nj = 1 + (j >> 1);\nweight[i] = j << 8;\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:writeRun()V",
                                    "method_body": "private void writeRun() throws IOException {\nfinal int lastShadow = this.last;\n\nif (lastShadow < this.allowableBlockSize) {\nfinal int currentCharShadow = this.currentChar;\nfinal Data dataShadow = this.data;\ndataShadow.inUse[currentCharShadow] = true;\nfinal byte ch = (byte) currentCharShadow;\n\nint runLengthShadow = this.runLength;\nthis.crc.updateCRC(currentCharShadow, runLengthShadow);\n\nswitch (runLengthShadow) {\ncase 1:\ndataShadow.block[lastShadow + 2] = ch;\nthis.last = lastShadow + 1;\nbreak;\n\ncase 2:\ndataShadow.block[lastShadow + 2] = ch;\ndataShadow.block[lastShadow + 3] = ch;\nthis.last = lastShadow + 2;\nbreak;\n\ncase 3: {\nfinal byte[] block = dataShadow.block;\nblock[lastShadow + 2] = ch;\nblock[lastShadow + 3] = ch;\nblock[lastShadow + 4] = ch;\nthis.last = lastShadow + 3;\n}\nbreak;\n\ndefault: {\nrunLengthShadow -= 4;\ndataShadow.inUse[runLengthShadow] = true;\nfinal byte[] block = dataShadow.block;\nblock[lastShadow + 2] = ch;\nblock[lastShadow + 3] = ch;\nblock[lastShadow + 4] = ch;\nblock[lastShadow + 5] = ch;\nblock[lastShadow + 6] = (byte) runLengthShadow;\nthis.last = lastShadow + 5;\n}\nbreak;\n\n}\n} else {\nendBlock();\ninitBlock();\nwriteRun();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif (out != null) {\ntry {\nif (this.runLength > 0) {\nwriteRun();\n}\nthis.currentChar = -1;\nendBlock();\nendCompression();\n} finally {\nthis.out = null;\nthis.data = null;\nthis.blockSorter = null;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif (out != null) {\nOutputStream outShadow = this.out;\nfinish();\noutShadow.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:init()V",
                                    "method_body": "private void init() throws IOException {\nbsPutUByte('B');\nbsPutUByte('Z');\n\nthis.data = new Data(this.blockSize100k);\nthis.blockSorter = new BlockSort(this.data);\n\n// huffmanised magic bytes\nbsPutUByte('h');\nbsPutUByte('0' + this.blockSize100k);\n\nthis.combinedCRC = 0;\ninitBlock();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:initBlock()V",
                                    "method_body": "private void initBlock() {\n// blockNo++;\nthis.crc.initialiseCRC();\nthis.last = -1;\n// ch = 0;\n\nboolean[] inUse = this.data.inUse;\nfor (int i = 256; --i >= 0;) {\ninUse[i] = false;\n}\n\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:endBlock()V",
                                    "method_body": "private void endBlock() throws IOException {\nthis.blockCRC = this.crc.getFinalCRC();\nthis.combinedCRC = (this.combinedCRC << 1) | (this.combinedCRC >>> 31);\nthis.combinedCRC ^= this.blockCRC;\n\n// empty block at end of file\nif (this.last == -1) {\nreturn;\n}\n\n/* sort the block and establish posn of original string */\nblockSort();\n\n/*\n* A 6-byte block header, the value chosen arbitrarily as 0x314159265359\n* :-). A 32 bit value does not really give a strong enough guarantee\n* that the value will not appear by chance in the compressed\n* datastream. Worst-case probability of this event, for a 900k block,\n* is about 2.0e-3 for 32 bits, 1.0e-5 for 40 bits and 4.0e-8 for 48\n* bits. For a compressed file of size 100Gb -- about 100000 blocks --\n* only a 48-bit marker will do. NB: normal compression/ decompression\n* donot rely on these statistical properties. They are only important\n* when trying to recover blocks from damaged files.\n*/\nbsPutUByte(0x31);\nbsPutUByte(0x41);\nbsPutUByte(0x59);\nbsPutUByte(0x26);\nbsPutUByte(0x53);\nbsPutUByte(0x59);\n\n/* Now the block's CRC, so it is in a known place. */\nbsPutInt(this.blockCRC);\n\n/* Now a single bit indicating no randomisation. */\nbsW(1, 0);\n\n/* Finally, block's contents proper. */\nmoveToFrontCodeAndSend();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:endCompression()V",
                                    "method_body": "private void endCompression() throws IOException {\n/*\n* Now another magic 48-bit number, 0x177245385090, to indicate the end\n* of the last block. (sqrt(pi), if you want to know. I did want to use\n* e, but it contains too much repetition -- 27 18 28 18 28 46 -- for me\n* to feel statistically comfortable. Call me paranoid.)\n*/\nbsPutUByte(0x17);\nbsPutUByte(0x72);\nbsPutUByte(0x45);\nbsPutUByte(0x38);\nbsPutUByte(0x50);\nbsPutUByte(0x90);\n\nbsPutInt(this.combinedCRC);\nbsFinishedWithStream();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:write([BII)V",
                                    "method_body": "public void write(final byte[] buf, int offs, final int len)\nthrows IOException {\nif (offs < 0) {\nthrow new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\");\n}\nif (len < 0) {\nthrow new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\");\n}\nif (offs + len > buf.length) {\nthrow new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\"\n+ len + \") > buf.length(\"\n+ buf.length + \").\");\n}\nif (this.out == null) {\nthrow new IOException(\"stream closed\");\n}\n\nfor (int hi = offs + len; offs < hi;) {\nwrite0(buf[offs++]);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:write0(I)V",
                                    "method_body": "private void write0(int b) throws IOException {\nif (this.currentChar != -1) {\nb &= 0xff;\nif (this.currentChar == b) {\nif (++this.runLength > 254) {\nwriteRun();\nthis.currentChar = -1;\nthis.runLength = 0;\n}\n// else nothing to do\n} else {\nwriteRun();\nthis.runLength = 1;\nthis.currentChar = b;\n}\n} else {\nthis.currentChar = b & 0xff;\nthis.runLength++;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:hbAssignCodes([I[BIII)V",
                                    "method_body": "private static void hbAssignCodes(final int[] code, final byte[] length,\nfinal int minLen, final int maxLen,\nfinal int alphaSize) {\nint vec = 0;\nfor (int n = minLen; n <= maxLen; n++) {\nfor (int i = 0; i < alphaSize; i++) {\nif ((length[i] & 0xff) == n) {\ncode[i] = vec;\nvec++;\n}\n}\nvec <<= 1;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:bsFinishedWithStream()V",
                                    "method_body": "private void bsFinishedWithStream() throws IOException {\nwhile (this.bsLive > 0) {\nint ch = this.bsBuff >> 24;\nthis.out.write(ch); // write 8-bit\nthis.bsBuff <<= 8;\nthis.bsLive -= 8;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:bsW(II)V",
                                    "method_body": "private void bsW(final int n, final int v) throws IOException {\nfinal OutputStream outShadow = this.out;\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\n\nthis.bsBuff = bsBuffShadow | (v << (32 - bsLiveShadow - n));\nthis.bsLive = bsLiveShadow + n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:bsPutUByte(I)V",
                                    "method_body": "private void bsPutUByte(final int c) throws IOException {\nbsW(8, c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:bsPutInt(I)V",
                                    "method_body": "private void bsPutInt(final int u) throws IOException {\nbsW(8, (u >> 24) & 0xff);\nbsW(8, (u >> 16) & 0xff);\nbsW(8, (u >> 8) & 0xff);\nbsW(8, u & 0xff);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues()V",
                                    "method_body": "private void sendMTFValues() throws IOException {\nfinal byte[][] len = this.data.sendMTFValues_len;\nfinal int alphaSize = this.nInUse + 2;\n\nfor (int t = N_GROUPS; --t >= 0;) {\nbyte[] len_t = len[t];\nfor (int v = alphaSize; --v >= 0;) {\nlen_t[v] = GREATER_ICOST;\n}\n}\n\n/* Decide how many coding tables to use */\n// assert (this.nMTF > 0) : this.nMTF;\nfinal int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3\n: (this.nMTF < 1200) ? 4 : (this.nMTF < 2400) ? 5 : 6;\n\n/* Generate an initial set of coding tables */\nsendMTFValues0(nGroups, alphaSize);\n\n/*\n* Iterate up to N_ITERS times to improve the tables.\n*/\nfinal int nSelectors = sendMTFValues1(nGroups, alphaSize);\n\n/* Compute MTF values for the selectors. */\nsendMTFValues2(nGroups, nSelectors);\n\n/* Assign actual codes for the tables. */\nsendMTFValues3(nGroups, alphaSize);\n\n/* Transmit the mapping table. */\nsendMTFValues4();\n\n/* Now the selectors. */\nsendMTFValues5(nGroups, nSelectors);\n\n/* Now the coding tables. */\nsendMTFValues6(nGroups, alphaSize);\n\n/* And finally, the block data proper */\nsendMTFValues7();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues0(II)V",
                                    "method_body": "private void sendMTFValues0(final int nGroups, final int alphaSize) {\nfinal byte[][] len = this.data.sendMTFValues_len;\nfinal int[] mtfFreq = this.data.mtfFreq;\n\nint remF = this.nMTF;\nint gs = 0;\n\nfor (int nPart = nGroups; nPart > 0; nPart--) {\nfinal int tFreq = remF / nPart;\nint ge = gs - 1;\nint aFreq = 0;\n\nfor (final int a = alphaSize - 1; (aFreq < tFreq) && (ge < a);) {\naFreq += mtfFreq[++ge];\n}\n\nif ((ge > gs) && (nPart != nGroups) && (nPart != 1)\n&& (((nGroups - nPart) & 1) != 0)) {\naFreq -= mtfFreq[ge--];\n}\n\nfinal byte[] len_np = len[nPart - 1];\nfor (int v = alphaSize; --v >= 0;) {\nif ((v >= gs) && (v <= ge)) {\nlen_np[v] = LESSER_ICOST;\n} else {\nlen_np[v] = GREATER_ICOST;\n}\n}\n\ngs = ge + 1;\nremF -= aFreq;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues1(II)I",
                                    "method_body": "private int sendMTFValues1(final int nGroups, final int alphaSize) {\nfinal Data dataShadow = this.data;\nfinal int[][] rfreq = dataShadow.sendMTFValues_rfreq;\nfinal int[] fave = dataShadow.sendMTFValues_fave;\nfinal short[] cost = dataShadow.sendMTFValues_cost;\nfinal char[] sfmap = dataShadow.sfmap;\nfinal byte[] selector = dataShadow.selector;\nfinal byte[][] len = dataShadow.sendMTFValues_len;\nfinal byte[] len_0 = len[0];\nfinal byte[] len_1 = len[1];\nfinal byte[] len_2 = len[2];\nfinal byte[] len_3 = len[3];\nfinal byte[] len_4 = len[4];\nfinal byte[] len_5 = len[5];\nfinal int nMTFShadow = this.nMTF;\n\nint nSelectors = 0;\n\nfor (int iter = 0; iter < N_ITERS; iter++) {\nfor (int t = nGroups; --t >= 0;) {\nfave[t] = 0;\nint[] rfreqt = rfreq[t];\nfor (int i = alphaSize; --i >= 0;) {\nrfreqt[i] = 0;\n}\n}\n\nnSelectors = 0;\n\nfor (int gs = 0; gs < this.nMTF;) {\n/* Set group start & end marks. */\n\n/*\n* Calculate the cost of this group as coded by each of the\n* coding tables.\n*/\n\nfinal int ge = Math.min(gs + G_SIZE - 1, nMTFShadow - 1);\n\nif (nGroups == N_GROUPS) {\n// unrolled version of the else-block\n\nshort cost0 = 0;\nshort cost1 = 0;\nshort cost2 = 0;\nshort cost3 = 0;\nshort cost4 = 0;\nshort cost5 = 0;\n\nfor (int i = gs; i <= ge; i++) {\nfinal int icv = sfmap[i];\ncost0 += len_0[icv] & 0xff;\ncost1 += len_1[icv] & 0xff;\ncost2 += len_2[icv] & 0xff;\ncost3 += len_3[icv] & 0xff;\ncost4 += len_4[icv] & 0xff;\ncost5 += len_5[icv] & 0xff;\n}\n\ncost[0] = cost0;\ncost[1] = cost1;\ncost[2] = cost2;\ncost[3] = cost3;\ncost[4] = cost4;\ncost[5] = cost5;\n\n} else {\nfor (int t = nGroups; --t >= 0;) {\ncost[t] = 0;\n}\n\nfor (int i = gs; i <= ge; i++) {\nfinal int icv = sfmap[i];\nfor (int t = nGroups; --t >= 0;) {\ncost[t] += len[t][icv] & 0xff;\n}\n}\n}\n\n/*\n* Find the coding table which is best for this group, and\n* record its identity in the selector table.\n*/\nint bt = -1;\nfor (int t = nGroups, bc = 999999999; --t >= 0;) {\nfinal int cost_t = cost[t];\nif (cost_t < bc) {\nbc = cost_t;\nbt = t;\n}\n}\n\nfave[bt]++;\nselector[nSelectors] = (byte) bt;\nnSelectors++;\n\n/*\n* Increment the symbol frequencies for the selected table.\n*/\nfinal int[] rfreq_bt = rfreq[bt];\nfor (int i = gs; i <= ge; i++) {\nrfreq_bt[sfmap[i]]++;\n}\n\ngs = ge + 1;\n}\n\n/*\n* Recompute the tables based on the accumulated frequencies.\n*/\nfor (int t = 0; t < nGroups; t++) {\nhbMakeCodeLengths(len[t], rfreq[t], this.data, alphaSize, 20);\n}\n}\n\nreturn nSelectors;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues2(II)V",
                                    "method_body": "private void sendMTFValues2(final int nGroups, final int nSelectors) {\n// assert (nGroups < 8) : nGroups;\n\nfinal Data dataShadow = this.data;\nbyte[] pos = dataShadow.sendMTFValues2_pos;\n\nfor (int i = nGroups; --i >= 0;) {\npos[i] = (byte) i;\n}\n\nfor (int i = 0; i < nSelectors; i++) {\nfinal byte ll_i = dataShadow.selector[i];\nbyte tmp = pos[0];\nint j = 0;\n\nwhile (ll_i != tmp) {\nj++;\nbyte tmp2 = tmp;\ntmp = pos[j];\npos[j] = tmp2;\n}\n\npos[0] = tmp;\ndataShadow.selectorMtf[i] = (byte) j;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues3(II)V",
                                    "method_body": "private void sendMTFValues3(final int nGroups, final int alphaSize) {\nint[][] code = this.data.sendMTFValues_code;\nbyte[][] len = this.data.sendMTFValues_len;\n\nfor (int t = 0; t < nGroups; t++) {\nint minLen = 32;\nint maxLen = 0;\nfinal byte[] len_t = len[t];\nfor (int i = alphaSize; --i >= 0;) {\nfinal int l = len_t[i] & 0xff;\nif (l > maxLen) {\nmaxLen = l;\n}\nif (l < minLen) {\nminLen = l;\n}\n}\n\n// assert (maxLen <= 20) : maxLen;\n// assert (minLen >= 1) : minLen;\n\nhbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues4()V",
                                    "method_body": "private void sendMTFValues4() throws IOException {\nfinal boolean[] inUse = this.data.inUse;\nfinal boolean[] inUse16 = this.data.sentMTFValues4_inUse16;\n\nfor (int i = 16; --i >= 0;) {\ninUse16[i] = false;\nfinal int i16 = i * 16;\nfor (int j = 16; --j >= 0;) {\nif (inUse[i16 + j]) {\ninUse16[i] = true;\n}\n}\n}\n\nfor (int i = 0; i < 16; i++) {\nbsW(1, inUse16[i] ? 1 : 0);\n}\n\nfinal OutputStream outShadow = this.out;\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nfor (int i = 0; i < 16; i++) {\nif (inUse16[i]) {\nfinal int i16 = i * 16;\nfor (int j = 0; j < 16; j++) {\n// inlined: bsW(1, inUse[i16 + j] ? 1 : 0);\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\nif (inUse[i16 + j]) {\nbsBuffShadow |= 1 << (32 - bsLiveShadow - 1);\n}\nbsLiveShadow++;\n}\n}\n}\n\nthis.bsBuff = bsBuffShadow;\nthis.bsLive = bsLiveShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues5(II)V",
                                    "method_body": "private void sendMTFValues5(final int nGroups, final int nSelectors)\nthrows IOException {\nbsW(3, nGroups);\nbsW(15, nSelectors);\n\nfinal OutputStream outShadow = this.out;\nfinal byte[] selectorMtf = this.data.selectorMtf;\n\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nfor (int i = 0; i < nSelectors; i++) {\nfor (int j = 0, hj = selectorMtf[i] & 0xff; j < hj; j++) {\n// inlined: bsW(1, 1);\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24);\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\nbsBuffShadow |= 1 << (32 - bsLiveShadow - 1);\nbsLiveShadow++;\n}\n\n// inlined: bsW(1, 0);\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24);\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\n// bsBuffShadow |= 0 << (32 - bsLiveShadow - 1);\nbsLiveShadow++;\n}\n\nthis.bsBuff = bsBuffShadow;\nthis.bsLive = bsLiveShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues6(II)V",
                                    "method_body": "private void sendMTFValues6(final int nGroups, final int alphaSize)\nthrows IOException {\nfinal byte[][] len = this.data.sendMTFValues_len;\nfinal OutputStream outShadow = this.out;\n\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nfor (int t = 0; t < nGroups; t++) {\nbyte[] len_t = len[t];\nint curr = len_t[0] & 0xff;\n\n// inlined: bsW(5, curr);\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\nbsBuffShadow |= curr << (32 - bsLiveShadow - 5);\nbsLiveShadow += 5;\n\nfor (int i = 0; i < alphaSize; i++) {\nint lti = len_t[i] & 0xff;\nwhile (curr < lti) {\n// inlined: bsW(2, 2);\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\nbsBuffShadow |= 2 << (32 - bsLiveShadow - 2);\nbsLiveShadow += 2;\n\ncurr++; /* 10 */\n}\n\nwhile (curr > lti) {\n// inlined: bsW(2, 3);\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\nbsBuffShadow |= 3 << (32 - bsLiveShadow - 2);\nbsLiveShadow += 2;\n\ncurr--; /* 11 */\n}\n\n// inlined: bsW(1, 0);\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\n// bsBuffShadow |= 0 << (32 - bsLiveShadow - 1);\nbsLiveShadow++;\n}\n}\n\nthis.bsBuff = bsBuffShadow;\nthis.bsLive = bsLiveShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues7()V",
                                    "method_body": "private void sendMTFValues7() throws IOException {\nfinal Data dataShadow = this.data;\nfinal byte[][] len = dataShadow.sendMTFValues_len;\nfinal int[][] code = dataShadow.sendMTFValues_code;\nfinal OutputStream outShadow = this.out;\nfinal byte[] selector = dataShadow.selector;\nfinal char[] sfmap = dataShadow.sfmap;\nfinal int nMTFShadow = this.nMTF;\n\nint selCtr = 0;\n\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nfor (int gs = 0; gs < nMTFShadow;) {\nfinal int ge = Math.min(gs + G_SIZE - 1, nMTFShadow - 1);\nfinal int selector_selCtr = selector[selCtr] & 0xff;\nfinal int[] code_selCtr = code[selector_selCtr];\nfinal byte[] len_selCtr = len[selector_selCtr];\n\nwhile (gs <= ge) {\nfinal int sfmap_i = sfmap[gs];\n\n//\n// inlined: bsW(len_selCtr[sfmap_i] & 0xff,\n// code_selCtr[sfmap_i]);\n//\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24);\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\nfinal int n = len_selCtr[sfmap_i] & 0xFF;\nbsBuffShadow |= code_selCtr[sfmap_i] << (32 - bsLiveShadow - n);\nbsLiveShadow += n;\n\ngs++;\n}\n\ngs = ge + 1;\nselCtr++;\n}\n\nthis.bsBuff = bsBuffShadow;\nthis.bsLive = bsLiveShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:moveToFrontCodeAndSend()V",
                                    "method_body": "private void moveToFrontCodeAndSend() throws IOException {\nbsW(24, this.data.origPtr);\ngenerateMTFValues();\nsendMTFValues();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:blockSort()V",
                                    "method_body": "private void blockSort() {\nblockSorter.blockSort(data, last);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:generateMTFValues()V",
                                    "method_body": "private void generateMTFValues() {\nfinal int lastShadow = this.last;\nfinal Data dataShadow = this.data;\nfinal boolean[] inUse = dataShadow.inUse;\nfinal byte[] block = dataShadow.block;\nfinal int[] fmap = dataShadow.fmap;\nfinal char[] sfmap = dataShadow.sfmap;\nfinal int[] mtfFreq = dataShadow.mtfFreq;\nfinal byte[] unseqToSeq = dataShadow.unseqToSeq;\nfinal byte[] yy = dataShadow.generateMTFValues_yy;\n\n// make maps\nint nInUseShadow = 0;\nfor (int i = 0; i < 256; i++) {\nif (inUse[i]) {\nunseqToSeq[i] = (byte) nInUseShadow;\nnInUseShadow++;\n}\n}\nthis.nInUse = nInUseShadow;\n\nfinal int eob = nInUseShadow + 1;\n\nfor (int i = eob; i >= 0; i--) {\nmtfFreq[i] = 0;\n}\n\nfor (int i = nInUseShadow; --i >= 0;) {\nyy[i] = (byte) i;\n}\n\nint wr = 0;\nint zPend = 0;\n\nfor (int i = 0; i <= lastShadow; i++) {\nfinal byte ll_i = unseqToSeq[block[fmap[i]] & 0xff];\nbyte tmp = yy[0];\nint j = 0;\n\nwhile (ll_i != tmp) {\nj++;\nbyte tmp2 = tmp;\ntmp = yy[j];\nyy[j] = tmp2;\n}\nyy[0] = tmp;\n\nif (j == 0) {\nzPend++;\n} else {\nif (zPend > 0) {\nzPend--;\nwhile (true) {\nif ((zPend & 1) == 0) {\nsfmap[wr] = RUNA;\nwr++;\nmtfFreq[RUNA]++;\n} else {\nsfmap[wr] = RUNB;\nwr++;\nmtfFreq[RUNB]++;\n}\n\nif (zPend >= 2) {\nzPend = (zPend - 2) >> 1;\n} else {\nbreak;\n}\n}\nzPend = 0;\n}\nsfmap[wr] = (char) (j + 1);\nwr++;\nmtfFreq[j + 1]++;\n}\n}\n\nif (zPend > 0) {\nzPend--;\nwhile (true) {\nif ((zPend & 1) == 0) {\nsfmap[wr] = RUNA;\nwr++;\nmtfFreq[RUNA]++;\n} else {\nsfmap[wr] = RUNB;\nwr++;\nmtfFreq[RUNB]++;\n}\n\nif (zPend >= 2) {\nzPend = (zPend - 2) >> 1;\n} else {\nbreak;\n}\n}\n}\n\nsfmap[wr] = (char) eob;\nmtfFreq[eob]++;\nthis.nMTF = wr + 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream$Data:<init>(I)V",
                                    "method_body": "Data(int blockSize100k) {\nfinal int n = blockSize100k * BZip2Constants.BASEBLOCKSIZE;\nthis.block = new byte[(n + 1 + NUM_OVERSHOOT_BYTES)];\nthis.fmap = new int[n];\nthis.sfmap = new char[2 * n];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:<init>(Lorg/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream$Data;)V",
                                    "method_body": "BlockSort(final BZip2CompressorOutputStream.Data data) {\nthis.quadrant = data.sfmap;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:<clinit>()V",
                                    "method_body": "private static final int[] INCS = { 1, 4, 13, 40, 121, 364, 1093, 3280,\n9841, 29524, 88573, 265720, 797161,\n2391484 };"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:blockSort(Lorg/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream$Data;I)V",
                                    "method_body": "void blockSort(final BZip2CompressorOutputStream.Data data, final int last) {\nthis.workLimit = WORK_FACTOR * last;\nthis.workDone = 0;\nthis.firstAttempt = true;\n\nif (last + 1 < 10000) {\nfallbackSort(data, last);\n} else {\nmainSort(data, last);\n\nif (this.firstAttempt && (this.workDone > this.workLimit)) {\nfallbackSort(data, last);\n}\n}\n\nfinal int[] fmap = data.fmap;\ndata.origPtr = -1;\nfor (int i = 0; i <= last; i++) {\nif (fmap[i] == 0) {\ndata.origPtr = i;\nbreak;\n}\n}\n\n// assert (data.origPtr != -1) : data.origPtr;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fallbackSort(Lorg/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream$Data;I)V",
                                    "method_body": "final void fallbackSort(final BZip2CompressorOutputStream.Data data,\nfinal int last) {\ndata.block[0] = data.block[last + 1];\nfallbackSort(data.fmap, data.block, last + 1);\nfor (int i = 0; i < last + 1; i++) {\n--data.fmap[i];\n}\nfor (int i = 0; i < last + 1; i++) {\nif (data.fmap[i] == -1) {\ndata.fmap[i] = last;\nbreak;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fallbackSimpleSort([I[III)V",
                                    "method_body": "private void fallbackSimpleSort(int[] fmap,\nint[] eclass,\nint lo,\nint hi) {\nif (lo == hi) {\nreturn;\n}\n\nint j;\nif (hi - lo > 3) {\nfor (int i = hi - 4; i >= lo; i--) {\nint tmp = fmap[i];\nint ec_tmp = eclass[tmp];\nfor (j = i + 4; j <= hi && ec_tmp > eclass[fmap[j]];\nj += 4) {\nfmap[j - 4] = fmap[j];\n}\nfmap[j - 4] = tmp;\n}\n}\n\nfor (int i = hi - 1; i >= lo; i--) {\nint tmp = fmap[i];\nint ec_tmp = eclass[tmp];\nfor (j = i + 1; j <= hi && ec_tmp > eclass[fmap[j]]; j++) {\nfmap[j - 1] = fmap[j];\n}\nfmap[j-1] = tmp;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fswap([III)V",
                                    "method_body": "private void fswap(int[] fmap, int zz1, int zz2) {\nint zztmp = fmap[zz1];\nfmap[zz1] = fmap[zz2];\nfmap[zz2] = zztmp;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fvswap([IIII)V",
                                    "method_body": "private void fvswap(int[] fmap, int yyp1, int yyp2, int yyn) {\nwhile (yyn > 0) {\nfswap(fmap, yyp1, yyp2);\nyyp1++; yyp2++; yyn--;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fmin(II)I",
                                    "method_body": "private int fmin(int a, int b) {\nreturn a < b ? a : b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fpush(III)V",
                                    "method_body": "private void fpush(int sp, int lz, int hz) {\nstack_ll[sp] = lz;\nstack_hh[sp] = hz;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fpop(I)[I",
                                    "method_body": "private int[] fpop(int sp) {\nreturn new int[] { stack_ll[sp], stack_hh[sp] };\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fallbackQSort3([I[III)V",
                                    "method_body": "private void fallbackQSort3(int[] fmap,\nint[] eclass,\nint loSt,\nint hiSt) {\nint lo, unLo, ltLo, hi, unHi, gtHi, n;\n\nlong r = 0;\nint sp = 0;\nfpush(sp++, loSt, hiSt);\n\nwhile (sp > 0) {\nint[] s = fpop(--sp);\nlo = s[0]; hi = s[1];\n\nif (hi - lo < FALLBACK_QSORT_SMALL_THRESH) {\nfallbackSimpleSort(fmap, eclass, lo, hi);\ncontinue;\n}\n\n/* LBZ2: Random partitioning.  Median of 3 sometimes fails to\navoid bad cases.  Median of 9 seems to help but\nlooks rather expensive.  This too seems to work but\nis cheaper.  Guidance for the magic constants\n7621 and 32768 is taken from Sedgewick's algorithms\nbook, chapter 35.\n*/\nr = ((r * 7621) + 1) % 32768;\nlong r3 = r % 3, med;\nif (r3 == 0) {\nmed = eclass[fmap[lo]];\n} else if (r3 == 1) {\nmed = eclass[fmap[(lo + hi) >>> 1]];\n} else {\nmed = eclass[fmap[hi]];\n}\n\nunLo = ltLo = lo;\nunHi = gtHi = hi;\n\n// looks like the ternary partition attributed to Wegner\n// in the cited Sedgewick paper\nwhile (true) {\nwhile (true) {\nif (unLo > unHi) {\nbreak;\n}\nn = eclass[fmap[unLo]] - (int) med;\nif (n == 0) {\nfswap(fmap, unLo, ltLo);\nltLo++; unLo++;\ncontinue;\n}\nif (n > 0) {\nbreak;\n}\nunLo++;\n}\nwhile (true) {\nif (unLo > unHi) {\nbreak;\n}\nn = eclass[fmap[unHi]] - (int) med;\nif (n == 0) {\nfswap(fmap, unHi, gtHi);\ngtHi--; unHi--;\ncontinue;\n}\nif (n < 0) {\nbreak;\n}\nunHi--;\n}\nif (unLo > unHi) {\nbreak;\n}\nfswap(fmap, unLo, unHi); unLo++; unHi--;\n}\n\nif (gtHi < ltLo) {\ncontinue;\n}\n\nn = fmin(ltLo - lo, unLo - ltLo);\nfvswap(fmap, lo, unLo - n, n);\nint m = fmin(hi - gtHi, gtHi - unHi);\nfvswap(fmap, unHi + 1, hi - m + 1, m);\n\nn = lo + unLo - ltLo - 1;\nm = hi - (gtHi - unHi) + 1;\n\nif (n - lo > hi - m) {\nfpush(sp++, lo, n);\nfpush(sp++, m, hi);\n} else {\nfpush(sp++, m, hi);\nfpush(sp++, lo, n);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:getEclass()[I",
                                    "method_body": "private int[] getEclass() {\nreturn eclass == null\n? (eclass = new int[quadrant.length / 2]) : eclass;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fallbackSort([I[BI)V",
                                    "method_body": "final void fallbackSort(int[] fmap, byte[] block, int nblock) {\nfinal int[] ftab = new int[257];\nint H, i, j, k, l, r, cc, cc1;\nint nNotDone;\nint nBhtab;\nfinal int[] eclass = getEclass();\n\nfor (i = 0; i < nblock; i++) {\neclass[i] = 0;\n}\n/*--\nLBZ2: Initial 1-char radix sort to generate\ninitial fmap and initial BH bits.\n--*/\nfor (i = 0; i < nblock; i++) {\nftab[block[i] & 0xff]++;\n}\nfor (i = 1; i < 257;    i++) {\nftab[i] += ftab[i - 1];\n}\n\nfor (i = 0; i < nblock; i++) {\nj = block[i] & 0xff;\nk = ftab[j] - 1;\nftab[j] = k;\nfmap[k] = i;\n}\n\nnBhtab = 64 + nblock;\nBitSet bhtab = new BitSet(nBhtab);\nfor (i = 0; i < 256; i++) {\nbhtab.set(ftab[i]);\n}\n\n/*--\nLBZ2: Inductively refine the buckets.  Kind-of an\n\"exponential radix sort\" (!), inspired by the\nManber-Myers suffix array construction algorithm.\n--*/\n\n/*-- LBZ2: set sentinel bits for block-end detection --*/\nfor (i = 0; i < 32; i++) {\nbhtab.set(nblock + 2 * i);\nbhtab.clear(nblock + 2 * i + 1);\n}\n\n/*-- LBZ2: the log(N) loop --*/\nH = 1;\nwhile (true) {\n\nj = 0;\nfor (i = 0; i < nblock; i++) {\nif (bhtab.get(i)) {\nj = i;\n}\nk = fmap[i] - H;\nif (k < 0) {\nk += nblock;\n}\neclass[k] = j;\n}\n\nnNotDone = 0;\nr = -1;\nwhile (true) {\n\n/*-- LBZ2: find the next non-singleton bucket --*/\nk = r + 1;\nk = bhtab.nextClearBit(k);\nl = k - 1;\nif (l >= nblock) {\nbreak;\n}\nk = bhtab.nextSetBit(k + 1);\nr = k - 1;\nif (r >= nblock) {\nbreak;\n}\n\n/*-- LBZ2: now [l, r] bracket current bucket --*/\nif (r > l) {\nnNotDone += (r - l + 1);\nfallbackQSort3(fmap, eclass, l, r);\n\n/*-- LBZ2: scan bucket and generate header bits-- */\ncc = -1;\nfor (i = l; i <= r; i++) {\ncc1 = eclass[fmap[i]];\nif (cc != cc1) {\nbhtab.set(i);\ncc = cc1;\n}\n}\n}\n}\n\nH *= 2;\nif (H > nblock || nNotDone == 0) {\nbreak;\n}\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 23,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.sevenz.SevenZFileTest.testCompressedHeaderWithNonDefaultDictionarySize",
                            "test_body": "78: public void testCompressedHeaderWithNonDefaultDictionarySize() throws Exception {\n79: SevenZFile sevenZFile = new SevenZFile(getFile(\"COMPRESS-256.7z\"));\n80: try {\n81: int count = 0;\n82: while (sevenZFile.getNextEntry() != null) {\n83: count++;\n84: }\n85: assertEquals(446, count);\n86: } finally {\n87: sevenZFile.close();\n88: }\n89: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:finalize()V",
                                    "method_body": "protected void finalize() throws Throwable {\ntry {\nif (!closed) {\nSystem.err.println(\"Cleaning up unclosed ZipFile for archive \"\n+ archiveName);\nclose();\n}\n} finally {\nsuper.finalize();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;[B)V",
                                    "method_body": "public SevenZFile(final File filename, final byte[] password) throws IOException {\nboolean succeeded = false;\nthis.file = new RandomAccessFile(filename, \"r\");\ntry {\narchive = readHeaders(password);\nif (password != null) {\nthis.password = new byte[password.length];\nSystem.arraycopy(password, 0, this.password, 0, password.length);\n} else {\nthis.password = null;\n}\nsucceeded = true;\n} finally {\nif (!succeeded) {\nthis.file.close();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZFile(final File filename) throws IOException {\nthis(filename, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<clinit>()V",
                                    "method_body": "static final int SIGNATURE_HEADER_SIZE = 32;\n\nprivate RandomAccessFile file;\nprivate final Archive archive;\nprivate int currentEntryIndex = -1;\nprivate int currentFolderIndex = -1;\nprivate InputStream currentFolderInputStream = null;\nprivate InputStream currentEntryInputStream = null;\nprivate byte[] password;\n\nstatic final byte[] sevenZSignature = {\n(byte)'7', (byte)'z', (byte)0xBC, (byte)0xAF, (byte)0x27, (byte)0x1C\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeaders([B)Lorg/apache/commons/compress/archivers/sevenz/Archive;",
                                    "method_body": "private Archive readHeaders(byte[] password) throws IOException {\nfinal byte[] signature = new byte[6];\nfile.readFully(signature);\nif (!Arrays.equals(signature, sevenZSignature)) {\nthrow new IOException(\"Bad 7z signature\");\n}\n// 7zFormat.txt has it wrong - it's first major then minor\nfinal byte archiveVersionMajor = file.readByte();\nfinal byte archiveVersionMinor = file.readByte();\nif (archiveVersionMajor != 0) {\nthrow new IOException(String.format(\"Unsupported 7z version (%d,%d)\",\nByte.valueOf(archiveVersionMajor), Byte.valueOf(archiveVersionMinor)));\n}\n\nfinal long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\nfinal StartHeader startHeader = readStartHeader(startHeaderCrc);\n\nfinal int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\nif (nextHeaderSizeInt != startHeader.nextHeaderSize) {\nthrow new IOException(\"cannot handle nextHeaderSize \" + startHeader.nextHeaderSize);\n}\nfile.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\nfinal byte[] nextHeader = new byte[nextHeaderSizeInt];\nfile.readFully(nextHeader);\nfinal CRC32 crc = new CRC32();\ncrc.update(nextHeader);\nif (startHeader.nextHeaderCrc != crc.getValue()) {\nthrow new IOException(\"NextHeader CRC mismatch\");\n}\n\nfinal ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\nDataInputStream nextHeaderInputStream = new DataInputStream(\nbyteStream);\nArchive archive = new Archive();\nint nid = nextHeaderInputStream.readUnsignedByte();\nif (nid == NID.kEncodedHeader) {\nnextHeaderInputStream =\nreadEncodedHeader(nextHeaderInputStream, archive, password);\n// Archive gets rebuilt with the new header\narchive = new Archive();\nnid = nextHeaderInputStream.readUnsignedByte();\n}\nif (nid == NID.kHeader) {\nreadHeader(nextHeaderInputStream, archive);\nnextHeaderInputStream.close();\n} else {\nthrow new IOException(\"Broken or unsupported archive: no Header\");\n}\nreturn archive;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStartHeader(J)Lorg/apache/commons/compress/archivers/sevenz/StartHeader;",
                                    "method_body": "private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\nfinal StartHeader startHeader = new StartHeader();\nDataInputStream dataInputStream = null;\ntry {\ndataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\nnew BoundedRandomAccessFileInputStream(file, 20), 20, startHeaderCrc));\nstartHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\nreturn startHeader;\n} finally {\nif (dataInputStream != null) {\ndataInputStream.close();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readEncodedHeader(Ljava/io/DataInputStream;Lorg/apache/commons/compress/archivers/sevenz/Archive;[B)Ljava/io/DataInputStream;",
                                    "method_body": "private DataInputStream readEncodedHeader(final DataInputStream header, final Archive archive,\nbyte[] password) throws IOException {\nreadStreamsInfo(header, archive);\n\n// FIXME: merge with buildDecodingStream()/buildDecoderStack() at some stage?\nfinal Folder folder = archive.folders[0];\nfinal int firstPackStreamIndex = 0;\nfinal long folderOffset = SIGNATURE_HEADER_SIZE + archive.packPos +\n0;\n\nfile.seek(folderOffset);\nInputStream inputStreamStack = new BoundedRandomAccessFileInputStream(file,\narchive.packSizes[firstPackStreamIndex]);\nfor (final Coder coder : folder.coders) {\nif (coder.numInStreams != 1 || coder.numOutStreams != 1) {\nthrow new IOException(\"Multi input/output stream coders are not yet supported\");\n}\ninputStreamStack = Coders.addDecoder(inputStreamStack, coder, password);\n}\nif (folder.hasCrc) {\ninputStreamStack = new CRC32VerifyingInputStream(inputStreamStack,\nfolder.getUnpackSize(), folder.crc);\n}\nfinal byte[] nextHeader = new byte[(int)folder.getUnpackSize()];\nfinal DataInputStream nextHeaderInputStream = new DataInputStream(inputStreamStack);\ntry {\nnextHeaderInputStream.readFully(nextHeader);\n} finally {\nnextHeaderInputStream.close();\n}\nreturn new DataInputStream(new ByteArrayInputStream(nextHeader));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\n\nif (nid == NID.kPackInfo) {\nreadPackInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kUnpackInfo) {\nreadUnpackInfo(header, archive);\nnid = header.readUnsignedByte();\n} else {\n// archive without unpack/coders info\narchive.folders = new Folder[0];\n}\n\nif (nid == NID.kSubStreamsInfo) {\nreadSubStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated StreamsInfo\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readPackInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readPackInfo(final DataInput header, final Archive archive) throws IOException {\narchive.packPos = readUint64(header);\nfinal long numPackStreams = readUint64(header);\nint nid = header.readUnsignedByte();\nif (nid == NID.kSize) {\narchive.packSizes = new long[(int)numPackStreams];\nfor (int i = 0; i < archive.packSizes.length; i++) {\narchive.packSizes[i] = readUint64(header);\n}\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kCRC) {\narchive.packCrcsDefined = readAllOrBits(header, (int)numPackStreams);\narchive.packCrcs = new long[(int)numPackStreams];\nfor (int i = 0; i < (int)numPackStreams; i++) {\nif (archive.packCrcsDefined.get(i)) {\narchive.packCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n}\n}\n\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated PackInfo (\" + nid + \")\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUnpackInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readUnpackInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\nif (nid != NID.kFolder) {\nthrow new IOException(\"Expected kFolder, got \" + nid);\n}\nfinal long numFolders = readUint64(header);\nfinal Folder[] folders = new Folder[(int)numFolders];\narchive.folders = folders;\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"External unsupported\");\n} else {\nfor (int i = 0; i < (int)numFolders; i++) {\nfolders[i] = readFolder(header);\n}\n}\n\nnid = header.readUnsignedByte();\nif (nid != NID.kCodersUnpackSize) {\nthrow new IOException(\"Expected kCodersUnpackSize, got \" + nid);\n}\nfor (final Folder folder : folders) {\nfolder.unpackSizes = new long[(int)folder.totalOutputStreams];\nfor (int i = 0; i < folder.totalOutputStreams; i++) {\nfolder.unpackSizes[i] = readUint64(header);\n}\n}\n\nnid = header.readUnsignedByte();\nif (nid == NID.kCRC) {\nfinal BitSet crcsDefined = readAllOrBits(header, (int)numFolders);\nfor (int i = 0; i < (int)numFolders; i++) {\nif (crcsDefined.get(i)) {\nfolders[i].hasCrc = true;\nfolders[i].crc = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n} else {\nfolders[i].hasCrc = false;\n}\n}\n\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated UnpackInfo\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFolder(Ljava/io/DataInput;)Lorg/apache/commons/compress/archivers/sevenz/Folder;",
                                    "method_body": "private Folder readFolder(final DataInput header) throws IOException {\nfinal Folder folder = new Folder();\n\nfinal long numCoders = readUint64(header);\nfinal Coder[] coders = new Coder[(int)numCoders];\nlong totalInStreams = 0;\nlong totalOutStreams = 0;\nfor (int i = 0; i < coders.length; i++) {\ncoders[i] = new Coder();\nint bits = header.readUnsignedByte();\nfinal int idSize = bits & 0xf;\nfinal boolean isSimple = (bits & 0x10) == 0;\nfinal boolean hasAttributes = (bits & 0x20) != 0;\nfinal boolean moreAlternativeMethods = (bits & 0x80) != 0;\n\ncoders[i].decompressionMethodId = new byte[idSize];\nheader.readFully(coders[i].decompressionMethodId);\nif (isSimple) {\ncoders[i].numInStreams = 1;\ncoders[i].numOutStreams = 1;\n} else {\ncoders[i].numInStreams = readUint64(header);\ncoders[i].numOutStreams = readUint64(header);\n}\ntotalInStreams += coders[i].numInStreams;\ntotalOutStreams += coders[i].numOutStreams;\nif (hasAttributes) {\nfinal long propertiesSize = readUint64(header);\ncoders[i].properties = new byte[(int)propertiesSize];\nheader.readFully(coders[i].properties);\n}\n// would need to keep looping as above:\nwhile (moreAlternativeMethods) {\nthrow new IOException(\"Alternative methods are unsupported, please report. \" +\n\"The reference implementation doesn't support them either.\");\n}\n}\nfolder.coders = coders;\nfolder.totalInputStreams = totalInStreams;\nfolder.totalOutputStreams = totalOutStreams;\n\nif (totalOutStreams == 0) {\nthrow new IOException(\"Total output streams can't be 0\");\n}\nfinal long numBindPairs = totalOutStreams - 1;\nfinal BindPair[] bindPairs = new BindPair[(int)numBindPairs];\nfor (int i = 0; i < bindPairs.length; i++) {\nbindPairs[i] = new BindPair();\nbindPairs[i].inIndex = readUint64(header);\nbindPairs[i].outIndex = readUint64(header);\n}\nfolder.bindPairs = bindPairs;\n\nif (totalInStreams < numBindPairs) {\nthrow new IOException(\"Total input streams can't be less than the number of bind pairs\");\n}\nfinal long numPackedStreams = totalInStreams - numBindPairs;\nfinal long packedStreams[] = new long[(int)numPackedStreams];\nif (numPackedStreams == 1) {\nint i;\nfor (i = 0; i < (int)totalInStreams; i++) {\nif (folder.findBindPairForInStream(i) < 0) {\nbreak;\n}\n}\nif (i == (int)totalInStreams) {\nthrow new IOException(\"Couldn't find stream's bind pair index\");\n}\npackedStreams[0] = i;\n} else {\nfor (int i = 0; i < (int)numPackedStreams; i++) {\npackedStreams[i] = readUint64(header);\n}\n}\nfolder.packedStreams = packedStreams;\n\nreturn folder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readAllOrBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readAllOrBits(final DataInput header, final int size) throws IOException {\nfinal int areAllDefined = header.readUnsignedByte();\nfinal BitSet bits;\nif (areAllDefined != 0) {\nbits = new BitSet(size);\nfor (int i = 0; i < size; i++) {\nbits.set(i, true);\n}\n} else {\nbits = readBits(header, size);\n}\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUint64(Ljava/io/DataInput;)J",
                                    "method_body": "private static long readUint64(final DataInput in) throws IOException {\n// long rather than int as it might get shifted beyond the range of an int\nlong firstByte = in.readUnsignedByte();\nint mask = 0x80;\nlong value = 0;\nfor (int i = 0; i < 8; i++) {\nif ((firstByte & mask) == 0) {\nreturn value | ((firstByte & (mask - 1)) << (8 * i));\n}\nlong nextByte = in.readUnsignedByte();\nvalue |= nextByte << (8 * i);\nmask >>>= 1;\n}\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;JJ)V",
                                    "method_body": "public ChecksumVerifyingInputStream(final Checksum checksum, final InputStream in,\nfinal long size, final long expectedChecksum) {\nthis.checksum = checksum;\nthis.in = in;\nthis.expectedChecksum = expectedChecksum;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining <= 0) {\nreturn -1;\n}\nint ret = in.read();\nif (ret >= 0) {\nchecksum.update(ret);\n--bytesRemaining;\n}\nif (bytesRemaining == 0 && expectedChecksum != checksum.getValue()) {\nthrow new IOException(\"Checksum verification failed\");\n}\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nint ret = in.read(b, off, len);\nif (ret >= 0) {\nchecksum.update(b, off, ret);\nbytesRemaining -= ret;\n}\nif (bytesRemaining <= 0 && expectedChecksum != checksum.getValue()) {\nthrow new IOException(\"Checksum verification failed\");\n}\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nin.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CRC32VerifyingInputStream:<init>(Ljava/io/InputStream;JJ)V",
                                    "method_body": "public CRC32VerifyingInputStream(final InputStream in, final long size, final long expectedCrc32) {\nsuper(new CRC32(), in, size, expectedCrc32);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:<init>(Ljava/io/RandomAccessFile;J)V",
                                    "method_body": "public BoundedRandomAccessFileInputStream(final RandomAccessFile file,\nfinal long size) {\nthis.file = file;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining > 0) {\n--bytesRemaining;\nreturn file.read();\n} else {\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif (bytesRemaining == 0) {\nreturn -1;\n}\nint bytesToRead = len;\nif (bytesToRead > bytesRemaining) {\nbytesToRead = (int) bytesRemaining;\n}\nfinal int bytesRead = file.read(b, off, bytesToRead);\nif (bytesRead >= 0) {\nbytesRemaining -= bytesRead;\n}\nreturn bytesRead;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:close()V",
                                    "method_body": "public void close() {\n// the nested RandomAccessFile is controlled externally\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:findBindPairForInStream(I)I",
                                    "method_body": "int findBindPairForInStream(final int index) {\nfor (int i = 0; i < bindPairs.length; i++) {\nif (bindPairs[i].inIndex == index) {\nreturn i;\n}\n}\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders:<clinit>()V",
                                    "method_body": "static CoderId[] coderTable = new CoderId[] {\nnew CoderId(SevenZMethod.COPY, new CopyDecoder()),\nnew CoderId(SevenZMethod.LZMA, new LZMADecoder()),\nnew CoderId(SevenZMethod.LZMA2, new LZMA2Decoder()),\nnew CoderId(SevenZMethod.DEFLATE, new DeflateDecoder()),\nnew CoderId(SevenZMethod.BZIP2, new BZIP2Decoder()),\nnew CoderId(SevenZMethod.AES256SHA256, new AES256SHA256Decoder())\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders:addDecoder(Ljava/io/InputStream;Lorg/apache/commons/compress/archivers/sevenz/Coder;[B)Ljava/io/InputStream;",
                                    "method_body": "static InputStream addDecoder(final InputStream is,\nfinal Coder coder, final byte[] password) throws IOException {\nfor (final CoderId coderId : coderTable) {\nif (Arrays.equals(coderId.method.getId(), coder.decompressionMethodId)) {\nreturn coderId.coder.decode(is, coder, password);\n}\n}\nthrow new IOException(\"Unsupported compression method \" +\nArrays.toString(coder.decompressionMethodId));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$CoderId:<init>(Lorg/apache/commons/compress/archivers/sevenz/SevenZMethod;Lorg/apache/commons/compress/archivers/sevenz/Coders$CoderBase;)V",
                                    "method_body": "CoderId(SevenZMethod method, final CoderBase coder) {\nthis.method = method;\nthis.coder = coder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:<init>(Ljava/lang/String;I[B)V",
                                    "method_body": "private SevenZMethod(byte[] id) {\nthis.id = id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:getId()[B",
                                    "method_body": "byte[] getId() {\nbyte[] copy = new byte[id.length];\nSystem.arraycopy(id, 0, copy, 0, id.length);\nreturn copy;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$CoderBase:<init>()V",
                                    "method_body": "final SevenZMethod method;\nfinal CoderBase coder;\n}\n\nstatic abstract class CoderBase {\nabstract InputStream decode(final InputStream in, final Coder coder,\nbyte[] password) throws IOException;\nOutputStream encode(final OutputStream out, final byte[] password)\nthrows IOException {\nthrow new UnsupportedOperationException(\"method doesn't support writing\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$LZMADecoder:decode(Ljava/io/InputStream;Lorg/apache/commons/compress/archivers/sevenz/Coder;[B)Ljava/io/InputStream;",
                                    "method_body": "InputStream decode(final InputStream in, final Coder coder,\nbyte[] password) throws IOException {\nbyte propsByte = coder.properties[0];\nlong dictSize = coder.properties[1];\nfor (int i = 1; i < 4; i++) {\ndictSize |= (coder.properties[i + 1] << (8 * i));\n}\nif (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\nthrow new IOException(\"Dictionary larger than 4GiB maximum size\");\n}\nreturn new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 24,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarUtilsTest.testParseOctal",
                            "test_body": "46: public void testParseOctal() throws Exception{\n47: long value; \n48: byte [] buffer;\n49: final long MAX_OCTAL  = 077777777777L; // Allowed 11 digits\n50: final long MAX_OCTAL_OVERFLOW  = 0777777777777L; // in fact 12 for some implementations\n51: final String maxOctal = \"777777777777\"; // Maximum valid octal\n52: buffer = maxOctal.getBytes(CharsetNames.UTF_8);\n53: value = TarUtils.parseOctal(buffer,0, buffer.length);\n54: assertEquals(MAX_OCTAL_OVERFLOW, value);\n55: buffer[buffer.length - 1] = ' ';\n56: value = TarUtils.parseOctal(buffer,0, buffer.length);\n57: assertEquals(MAX_OCTAL, value);\n58: buffer[buffer.length-1]=0;\n59: value = TarUtils.parseOctal(buffer,0, buffer.length);\n60: assertEquals(MAX_OCTAL, value);\n61: buffer=new byte[]{0,0};\n62: value = TarUtils.parseOctal(buffer,0, buffer.length);\n63: assertEquals(0, value);\n64: buffer=new byte[]{0,' '};\n65: value = TarUtils.parseOctal(buffer,0, buffer.length);\n66: assertEquals(0, value);\n67: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n\nstatic {\nMap<String, SimpleEncodingHolder> se =\nnew HashMap<String, SimpleEncodingHolder>();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for UTF-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h = simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\n// check platform's default encoding\ncharsetName = System.getProperty(\"file.encoding\");\n}\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}\nfor (String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\n\n/**\n* <p>\n* Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\n* (either order accepted on input, big-endian used on output)\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, big-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, little-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\n\n/**\n* <p>\n* Eight-bit Unicode Transformation Format.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:<clinit>()V",
                                    "method_body": "private static final int BYTE_MASK = 255;\n\nstatic final ZipEncoding DEFAULT_ENCODING =\nZipEncodingHelper.getZipEncoding(null);\n\n/**\n* Encapsulates the algorithms used up to Commons Compress 1.3 as\n* ZipEncoding.\n*/\nstatic final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\npublic boolean canEncode(String name) { return true; }\n\npublic ByteBuffer encode(String name) {\nfinal int length = name.length();\nbyte[] buf = new byte[length];\n\n// copy until end of input or output is reached.\nfor (int i = 0; i < length; ++i) {\nbuf[i] = (byte) name.charAt(i);\n}\nreturn ByteBuffer.wrap(buf);\n}\n\npublic String decode(byte[] buffer) {\nfinal int length = buffer.length;\nStringBuilder result = new StringBuilder(length);\n\nfor (int i = 0; i < length; ++i) {\nbyte b = buffer[i];\nif (b == 0) { // Trailing null\nbreak;\n}\nresult.append((char) (b & 0xFF)); // Allow for sign-extension\n}\n\nreturn result.toString();\n}\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\n\nif (length < 2){\nthrow new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n}\n\nif (buffer[start] == 0) {\nreturn 0L;\n}\n\n// Skip leading spaces\nwhile (start < end){\nif (buffer[start] == ' '){\nstart++;\n} else {\nbreak;\n}\n}\n\n// Trim all trailing NULs and spaces.\n// The ustar and POSIX tar specs require a trailing NUL or\n// space but some implementations use the extra digit for big\n// sizes/uids/gids ...\nbyte trailer = buffer[end - 1];\nif (trailer == 0 || trailer == ' '){\nend--;\n} else {\nthrow new IllegalArgumentException(\nexceptionMessage(buffer, offset, length, end-1, trailer));\n}\ntrailer = buffer[end - 1];\nwhile (start < end - 1 && (trailer == 0 || trailer == ' ')) {\nend--;\ntrailer = buffer[end - 1];\n}\n\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\n// CheckStyle:MagicNumber OFF\nif (currentByte < '0' || currentByte > '7'){\nthrow new IllegalArgumentException(\nexceptionMessage(buffer, offset, length, start, currentByte));\n}\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\n// CheckStyle:MagicNumber ON\n}\n\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:exceptionMessage([BIIIB)Ljava/lang/String;",
                                    "method_body": "private static String exceptionMessage(byte[] buffer, final int offset,\nfinal int length, int current, final byte currentByte) {\n// default charset is good enough for an exception message,\n//\n// the alternative was to modify parseOctal and\n// parseOctalOrBinary to receive the ZipEncoding of the\n// archive (deprecating the existing public methods, of\n// course) and dealing with the fact that ZipEncoding#decode\n// can throw an IOException which parseOctal* doesn't declare\nString string = new String(buffer, offset, length);\n\nstring=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed\nfinal String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;\nreturn s;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 25,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest.testReadingOfFirstStoredEntry",
                            "test_body": "160: public void testReadingOfFirstStoredEntry() throws Exception {\n161: ZipArchiveInputStream in = new ZipArchiveInputStream(new FileInputStream(getFile(\"COMPRESS-264.zip\")));\n162: 163: try {\n164: ZipArchiveEntry ze = in.getNextZipEntry();\n165: assertEquals(5, ze.getSize());\n166: assertArrayEquals(new byte[] {'d', 'a', 't', 'a', '\\n'},\n167: IOUtils.toByteArray(in));\n168: } finally {\n169: in.close();\n170: }\n171: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:copy(Ljava/io/InputStream;Ljava/io/OutputStream;)J",
                                    "method_body": "public static long copy(final InputStream input, final OutputStream output) throws IOException {\nreturn copy(input, output, 8024);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:copy(Ljava/io/InputStream;Ljava/io/OutputStream;I)J",
                                    "method_body": "public static long copy(final InputStream input, final OutputStream output, int buffersize) throws IOException {\nfinal byte[] buffer = new byte[buffersize];\nint n = 0;\nlong count=0;\nwhile (-1 != (n = input.read(buffer))) {\noutput.write(buffer, 0, n);\ncount += n;\n}\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[B)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b) throws IOException {\nreturn readFully(input, b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b, int offset, int len)\nthrows IOException {\nif (len < 0 || offset < 0 || len + offset > b.length) {\nthrow new IndexOutOfBoundsException();\n}\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\nbreak;\n}\ncount += x;\n}\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:toByteArray(Ljava/io/InputStream;)[B",
                                    "method_body": "public static byte[] toByteArray(final InputStream input) throws IOException {\nfinal ByteArrayOutputStream output = new ByteArrayOutputStream();\ncopy(input, output);\nreturn output.toByteArray();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "protected ZipArchiveEntry() {\nthis(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<clinit>()V",
                                    "method_body": "public static final int PLATFORM_UNIX = 3;\npublic static final int PLATFORM_FAT  = 0;\nprivate static final int SHORT_MASK = 0xFFFF;\nprivate static final int SHORT_SHIFT = 16;\nprivate static final byte[] EMPTY = new byte[0];\n\n/**\n* The {@link java.util.zip.ZipEntry} base class only supports"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getMethod()I",
                                    "method_body": "public int getMethod() {\nreturn method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setMethod(I)V",
                                    "method_body": "public void setMethod(int method) {\nif (method < 0) {\nthrow new IllegalArgumentException(\n\"ZIP compression method can not be negative: \" + method);\n}\nthis.method = method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setPlatform(I)V",
                                    "method_body": "protected void setPlatform(int platform) {\nthis.platform = platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void setExtraFields(ZipExtraField[] fields) {\nextraFields = new LinkedHashMap<ZipShort, ZipExtraField>();\nfor (ZipExtraField field : fields) {\nif (field instanceof UnparseableExtraFieldData) {\nunparseableExtra = (UnparseableExtraFieldData) field;\n} else {\nextraFields.put(field.getHeaderId(), field);\n}\n}\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields(Z)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField[] getExtraFields(boolean includeUnparseable) {\nif (extraFields == null) {\nreturn !includeUnparseable || unparseableExtra == null\n? new ZipExtraField[0]\n: new ZipExtraField[] { unparseableExtra };\n}\nList<ZipExtraField> result =\nnew ArrayList<ZipExtraField>(extraFields.values());\nif (includeUnparseable && unparseableExtra != null) {\nresult.add(unparseableExtra);\n}\nreturn result.toArray(new ZipExtraField[0]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField getExtraField(ZipShort type) {\nif (extraFields != null) {\nreturn extraFields.get(type);\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra([B)V",
                                    "method_body": "public void setExtra(byte[] extra) throws RuntimeException {\ntry {\nZipExtraField[] local =\nExtraFieldUtils.parse(extra, true,\nExtraFieldUtils.UnparseableExtraField.READ);\nmergeExtraFields(local, true);\n} catch (ZipException e) {\n// actually this is not possible as of Commons Compress 1.1\nthrow new RuntimeException(\"Error parsing extra fields for entry: \"\n+ getName() + \" - \" + e.getMessage(), e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields(true)));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "protected void setName(String name) {\nif (name != null && getPlatform() == PLATFORM_FAT\n&& name.indexOf(\"/\") == -1) {\nname = name.replace('\\\\', '/');\n}\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nif (size < 0) {\nthrow new IllegalArgumentException(\"invalid entry size\");\n}\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;[B)V",
                                    "method_body": "protected void setName(String name, byte[] rawName) {\nsetName(name);\nthis.rawName = rawName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getGeneralPurposeBit()Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "public GeneralPurposeBit getGeneralPurposeBit() {\nreturn gpb;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setGeneralPurposeBit(Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;)V",
                                    "method_body": "public void setGeneralPurposeBit(GeneralPurposeBit b) {\ngpb = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:mergeExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;Z)V",
                                    "method_body": "private void mergeExtraFields(ZipExtraField[] f, boolean local)\nthrows ZipException {\nif (extraFields == null) {\nsetExtraFields(f);\n} else {\nfor (ZipExtraField element : f) {\nZipExtraField existing;\nif (element instanceof UnparseableExtraFieldData) {\nexisting = unparseableExtra;\n} else {\nexisting = getExtraField(element.getHeaderId());\n}\nif (existing == null) {\naddExtraField(element);\n} else {\nif (local) {\nbyte[] b = element.getLocalFileDataData();\nexisting.parseFromLocalFileData(b, 0, b.length);\n} else {\nbyte[] b = element.getCentralDirectoryData();\nexisting.parseFromCentralDirectoryData(b, 0, b.length);\n}\n}\n}\nsetExtra();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:<init>()V",
                                    "method_body": "public GeneralPurposeBit() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesUTF8ForNames()Z",
                                    "method_body": "public boolean usesUTF8ForNames() {\nreturn languageEncodingFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useUTF8ForNames(Z)V",
                                    "method_body": "public void useUTF8ForNames(boolean b) {\nlanguageEncodingFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesDataDescriptor()Z",
                                    "method_body": "public boolean usesDataDescriptor() {\nreturn dataDescriptorFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useDataDescriptor(Z)V",
                                    "method_body": "public void useDataDescriptor(boolean b) {\ndataDescriptorFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesEncryption()Z",
                                    "method_body": "public boolean usesEncryption() {\nreturn encryptionFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useEncryption(Z)V",
                                    "method_body": "public void useEncryption(boolean b) {\nencryptionFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useStrongEncryption(Z)V",
                                    "method_body": "public void useStrongEncryption(boolean b) {\nstrongEncryptionFlag = b;\nif (b) {\nuseEncryption(true);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:parse([BI)Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "public static GeneralPurposeBit parse(final byte[] data, final int offset) {\nfinal int generalPurposeFlag = ZipShort.getValue(data, offset);\nGeneralPurposeBit b = new GeneralPurposeBit();\nb.useDataDescriptor((generalPurposeFlag & DATA_DESCRIPTOR_FLAG) != 0);\nb.useUTF8ForNames((generalPurposeFlag & UFT8_NAMES_FLAG) != 0);\nb.useStrongEncryption((generalPurposeFlag & STRONG_ENCRYPTION_FLAG) != 0);\nb.useEncryption((generalPurposeFlag & ENCRYPTION_FLAG) != 0);\nb.slidingDictionarySize = (generalPurposeFlag & SLIDING_DICTIONARY_SIZE_FLAG) != 0 ? 8192 : 4096;\nb.numberOfShannonFanoTrees = (generalPurposeFlag & NUMBER_OF_SHANNON_FANO_TREES_FLAG) != 0 ? 3 : 2;\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>([B)V",
                                    "method_body": "public ZipLong (byte[] bytes) {\nthis(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>([BI)V",
                                    "method_body": "public ZipLong (byte[] bytes, int offset) {\nvalue = ZipLong.getValue(bytes, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\n//private static final int BYTE_BIT_SIZE = 8;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Data Descriptor signature.\n*\n* <p>Actually, PKWARE uses this as marker for split/spanned\n* archives and other archivers have started to use it as Data\n* Descriptor signature (as well).</p>\n* @since 1.1\n*/\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\n\n/**\n* Value stored in size and similar fields if ZIP64 extensions are\n* used.\n* @since 1.3\n*/\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\n\n/**\n* Marks ZIP archives that were supposed to be split or spanned\n* but only needed a single segment in then end (so are actually\n* neither split nor spanned).\n*\n* <p>This is the \"PK00\" prefix found in some archives.</p>\n* @since 1.5\n*/\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\nnew ZipLong(0X30304B50L);\n\n/**\n* Archive extra data record signature.\n* @since 1.5\n*/\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue()J",
                                    "method_body": "public long getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object o) {\nif (o == null || !(o instanceof ZipLong)) {\nreturn false;\n}\nreturn value == ((ZipLong) o).getValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n\nstatic {\nMap<String, SimpleEncodingHolder> se =\nnew HashMap<String, SimpleEncodingHolder>();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for UTF-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h = simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\n// check platform's default encoding\ncharsetName = System.getProperty(\"file.encoding\");\n}\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}\nfor (String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data);\n} else {\nreturn new String(data,this.charsetName);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\n\n/**\n* <p>\n* Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\n* (either order accepted on input, big-endian used on output)\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, big-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, little-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\n\n/**\n* <p>\n* Eight-bit Unicode Transformation Format.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\n\n/** No-arg constructor */\npublic JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>([BI)V",
                                    "method_body": "public ZipShort (byte[] bytes, int offset) {\nvalue = ZipShort.getValue(bytes, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([BI)I",
                                    "method_body": "public static int getValue(byte[] bytes, int offset) {\nint value = (bytes[offset + 1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object o) {\nif (o == null || !(o instanceof ZipShort)) {\nreturn false;\n}\nreturn value == ((ZipShort) o).getValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n\n/**\n* Static registry of known extra fields.\n*/\nprivate static final Map<ZipShort, Class<?>> implementations;\n\nstatic {\nimplementations = new ConcurrentHashMap<ZipShort, Class<?>>();\nregister(AsiExtraField.class);\nregister(X5455_ExtendedTimestamp.class);\nregister(X7875_NewUnix.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\nregister(Zip64ExtendedInformationExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(Class<?> c) {\ntry {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n} catch (ClassCastException cc) {\nthrow new RuntimeException(c + \" doesn\\'t implement ZipExtraField\");\n} catch (InstantiationException ie) {\nthrow new RuntimeException(c + \" is not a concrete class\");\n} catch (IllegalAccessException ie) {\nthrow new RuntimeException(c + \"\\'s no-arg constructor is not public\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:createExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField createExtraField(ZipShort headerId)\nthrows InstantiationException, IllegalAccessException {\nClass<?> c = implementations.get(headerId);\nif (c != null) {\nreturn (ZipExtraField) c.newInstance();\n}\nUnrecognizedExtraField u = new UnrecognizedExtraField();\nu.setHeaderId(headerId);\nreturn u;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:parse([BZLorg/apache/commons/compress/archivers/zip/ExtraFieldUtils$UnparseableExtraField;)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField[] parse(byte[] data, boolean local,\nUnparseableExtraField onUnparseableData)\nthrows ZipException {\nList<ZipExtraField> v = new ArrayList<ZipExtraField>();\nint start = 0;\nLOOP:\nwhile (start <= data.length - WORD) {\nZipShort headerId = new ZipShort(data, start);\nint length = new ZipShort(data, start + 2).getValue();\nif (start + WORD + length > data.length) {\nswitch(onUnparseableData.getKey()) {\ncase UnparseableExtraField.THROW_KEY:\nthrow new ZipException(\"bad extra field starting at \"\n+ start + \".  Block length of \"\n+ length + \" bytes exceeds remaining\"\n+ \" data of \"\n+ (data.length - start - WORD)\n+ \" bytes.\");\ncase UnparseableExtraField.READ_KEY:\nUnparseableExtraFieldData field =\nnew UnparseableExtraFieldData();\nif (local) {\nfield.parseFromLocalFileData(data, start,\ndata.length - start);\n} else {\nfield.parseFromCentralDirectoryData(data, start,\ndata.length - start);\n}\nv.add(field);\n//$FALL-THROUGH$\ncase UnparseableExtraField.SKIP_KEY:\n// since we cannot parse the data we must assume\n// the extra field consumes the whole rest of the\n// available data\nbreak LOOP;\ndefault:\nthrow new ZipException(\"unknown UnparseableExtraField key: \"\n+ onUnparseableData.getKey());\n}\n}\ntry {\nZipExtraField ze = createExtraField(headerId);\nif (local) {\nze.parseFromLocalFileData(data, start + WORD, length);\n} else {\nze.parseFromCentralDirectoryData(data, start + WORD,\nlength);\n}\nv.add(ze);\n} catch (InstantiationException ie) {\nthrow (ZipException) new ZipException(ie.getMessage()).initCause(ie);\n} catch (IllegalAccessException iae) {\nthrow (ZipException) new ZipException(iae.getMessage()).initCause(iae);\n}\nstart += length + WORD;\n}\n\nZipExtraField[] result = new ZipExtraField[v.size()];\nreturn v.toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nfinal boolean lastIsUnparseableHolder = data.length > 0\n&& data[data.length - 1] instanceof UnparseableExtraFieldData;\nint regularExtraFieldCount =\nlastIsUnparseableHolder ? data.length - 1 : data.length;\n\nint sum = WORD * regularExtraFieldCount;\nfor (ZipExtraField element : data) {\nsum += element.getLocalFileDataLength().getValue();\n}\n\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n0, result, start + 2, 2);\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += local.length + WORD;\n}\nif (lastIsUnparseableHolder) {\nbyte[] local = data[data.length - 1].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start, local.length);\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate static final int      WORD = 4;\n/**\n* Standard Unix stat(2) file mode.\n*/\nprivate int mode = 0;\n/**\n* User ID.\n*/\nprivate int uid = 0;\n/**\n* Group ID.\n*/\nprivate int gid = 0;\n/**\n* File this entry points to, if it is a symbolic link.\n*\n* <p>empty string - if entry is not a symbolic link.</p>\n*/\nprivate String link = \"\";\n/**\n* Is this an entry for a directory?\n*/\nprivate boolean dirFlag = false;\n\n/**\n* Instance used to calculate checksums.\n*/\nprivate CRC32 crc = new CRC32();\n\n/** Constructor for AsiExtraField. */\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<init>()V",
                                    "method_body": "public X5455_ExtendedTimestamp() {}\npublic X5455_ExtendedTimestamp() {}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x5455);\nprivate static final long serialVersionUID = 1L;\n\n/**\n* The bit set inside the flags by when the last modification time\n* is present in this extra field.\n*/\npublic static final byte MODIFY_TIME_BIT = 1;\n/**\n* The bit set inside the flags by when the lasr access time is\n* present in this extra field.\n*/\npublic static final byte ACCESS_TIME_BIT = 2;\n/**\n* The bit set inside the flags by when the original creation time\n* is present in this extra field.\n*/\npublic static final byte CREATE_TIME_BIT = 4;\n\n// The 3 boolean fields (below) come from this flags byte.  The remaining 5 bits\n// are ignored according to the current version of the spec (December 2012).\nprivate byte flags;\n\n// Note: even if bit1 and bit2 are set, the Central data will still not contain\n// access/create fields:  only local data ever holds those!  This causes\n// some of our implementation to look a little odd, with seemingly spurious\n// != null and length checks.\nprivate boolean bit0_modifyTimePresent;\nprivate boolean bit1_accessTimePresent;\nprivate boolean bit2_createTimePresent;\n\nprivate ZipLong modifyTime;\nprivate ZipLong accessTime;\nprivate ZipLong createTime;\n\n/**\n* Constructor for X5455_ExtendedTimestamp.\n*/\npublic X5455_ExtendedTimestamp() {}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn new ZipShort(1 +\n(bit0_modifyTimePresent ? 4 : 0) +\n(bit1_accessTimePresent && accessTime != null ? 4 : 0) +\n(bit2_createTimePresent && createTime != null ? 4 : 0)\n);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nbyte[] data = new byte[getLocalFileDataLength().getValue()];\nint pos = 0;\ndata[pos++] = 0;\nif (bit0_modifyTimePresent) {\ndata[0] |= MODIFY_TIME_BIT;\nSystem.arraycopy(modifyTime.getBytes(), 0, data, pos, 4);\npos += 4;\n}\nif (bit1_accessTimePresent && accessTime != null) {\ndata[0] |= ACCESS_TIME_BIT;\nSystem.arraycopy(accessTime.getBytes(), 0, data, pos, 4);\npos += 4;\n}\nif (bit2_createTimePresent && createTime != null) {\ndata[0] |= CREATE_TIME_BIT;\nSystem.arraycopy(createTime.getBytes(), 0, data, pos, 4);\npos += 4;\n}\nreturn data;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:parseFromLocalFileData([BII)V",
                                    "method_body": "public void parseFromLocalFileData(\nbyte[] data, int offset, int length\n) throws ZipException {\nreset();\nfinal int len = offset + length;\nsetFlags(data[offset++]);\nif (bit0_modifyTimePresent) {\nmodifyTime = new ZipLong(data, offset);\noffset += 4;\n}\n\n// Notice the extra length check in case we are parsing the shorter\n// central data field (for both access and create timestamps).\nif (bit1_accessTimePresent && offset + 4 <= len) {\naccessTime = new ZipLong(data, offset);\noffset += 4;\n}\nif (bit2_createTimePresent && offset + 4 <= len) {\ncreateTime = new ZipLong(data, offset);\noffset += 4;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:reset()V",
                                    "method_body": "private void reset() {\nsetFlags((byte) 0);\nthis.modifyTime = null;\nthis.accessTime = null;\nthis.createTime = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:setFlags(B)V",
                                    "method_body": "public void setFlags(byte flags) {\nthis.flags = flags;\nthis.bit0_modifyTimePresent = (flags & MODIFY_TIME_BIT) == MODIFY_TIME_BIT;\nthis.bit1_accessTimePresent = (flags & ACCESS_TIME_BIT) == ACCESS_TIME_BIT;\nthis.bit2_createTimePresent = (flags & CREATE_TIME_BIT) == CREATE_TIME_BIT;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<init>()V",
                                    "method_body": "public X7875_NewUnix() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x7875);\nprivate static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);\nprivate static final long serialVersionUID = 1L;\n\nprivate int version = 1; // always '1' according to current info-zip spec.\n\n// BigInteger helps us with little-endian / big-endian conversions.\n// (thanks to BigInteger.toByteArray() and a reverse() method we created).\n// Also, the spec theoretically allows UID/GID up to 255 bytes long!\n//\n// NOTE:  equals() and hashCode() currently assume these can never be null.\nprivate BigInteger uid;\nprivate BigInteger gid;\n\n/**\n* Constructor for X7875_NewUnix.\n*/\npublic X7875_NewUnix() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nint uidSize = trimLeadingZeroesForceMinLength(uid.toByteArray()).length;\nint gidSize = trimLeadingZeroesForceMinLength(gid.toByteArray()).length;\n\n// The 3 comes from:  version=1 + uidsize=1 + gidsize=1\nreturn new ZipShort(3 + uidSize + gidSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nbyte[] uidBytes = uid.toByteArray();\nbyte[] gidBytes = gid.toByteArray();\n\n// BigInteger might prepend a leading-zero to force a positive representation\n// (e.g., so that the sign-bit is set to zero).  We need to remove that\n// before sending the number over the wire.\nuidBytes = trimLeadingZeroesForceMinLength(uidBytes);\ngidBytes = trimLeadingZeroesForceMinLength(gidBytes);\n\n// Couldn't bring myself to just call getLocalFileDataLength() when we've\n// already got the arrays right here.  Yeah, yeah, I know, premature\n// optimization is the root of all...\n//\n// The 3 comes from:  version=1 + uidsize=1 + gidsize=1\nbyte[] data = new byte[3 + uidBytes.length + gidBytes.length];\n\n// reverse() switches byte array from big-endian to little-endian.\nreverse(uidBytes);\nreverse(gidBytes);\n\nint pos = 0;\ndata[pos++] = unsignedIntToSignedByte(version);\ndata[pos++] = unsignedIntToSignedByte(uidBytes.length);\nSystem.arraycopy(uidBytes, 0, data, pos, uidBytes.length);\npos += uidBytes.length;\ndata[pos++] = unsignedIntToSignedByte(gidBytes.length);\nSystem.arraycopy(gidBytes, 0, data, pos, gidBytes.length);\nreturn data;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:parseFromLocalFileData([BII)V",
                                    "method_body": "public void parseFromLocalFileData(\nbyte[] data, int offset, int length\n) throws ZipException {\nreset();\nthis.version = signedByteToUnsignedInt(data[offset++]);\nint uidSize = signedByteToUnsignedInt(data[offset++]);\nbyte[] uidBytes = new byte[uidSize];\nSystem.arraycopy(data, offset, uidBytes, 0, uidSize);\noffset += uidSize;\nthis.uid = new BigInteger(1, reverse(uidBytes)); // sign-bit forced positive\n\nint gidSize = signedByteToUnsignedInt(data[offset++]);\nbyte[] gidBytes = new byte[gidSize];\nSystem.arraycopy(data, offset, gidBytes, 0, gidSize);\nthis.gid = new BigInteger(1, reverse(gidBytes)); // sign-bit forced positive\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:reset()V",
                                    "method_body": "private void reset() {\n// Typical UID/GID of the first non-root user created on a unix system.\nuid = ONE_THOUSAND;\ngid = ONE_THOUSAND;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:trimLeadingZeroesForceMinLength([B)[B",
                                    "method_body": "static byte[] trimLeadingZeroesForceMinLength(byte[] array) {\nif (array == null) {\nreturn array;\n}\n\nint pos = 0;\nfor (byte b : array) {\nif (b == 0) {\npos++;\n} else {\nbreak;\n}\n}\n\n/*\n\nI agonized over my choice of MIN_LENGTH=1.  Here's the situation:\nInfoZip (the tool I am using to test interop) always sets these\nto length=4.  And so a UID of 0 (typically root) for example is\nencoded as {4,0,0,0,0} (len=4, 32 bits of zero), when it could just\nas easily be encoded as {1,0} (len=1, 8 bits of zero) according to\nthe spec.\n\nIn the end I decided on MIN_LENGTH=1 for four reasons:\n\n1.)  We are adhering to the spec as far as I can tell, and so\na consumer that cannot parse this is broken.\n\n2.)  Fundamentally, zip files are about shrinking things, so\nlet's save a few bytes per entry while we can.\n\n3.)  Of all the people creating zip files using commons-\ncompress, how many care about UNIX UID/GID attributes\nof the files they store?   (e.g., I am probably thinking\nway too hard about this and no one cares!)\n\n4.)  InfoZip's tool, even though it carefully stores every UID/GID\nfor every file zipped on a unix machine (by default) currently\nappears unable to ever restore UID/GID.\nunzip -X has no effect on my machine, even when run as root!!!!\n\nAnd thus it is decided:  MIN_LENGTH=1.\n\nIf anyone runs into interop problems from this, feel free to set\nit to MIN_LENGTH=4 at some future time, and then we will behave\nexactly like InfoZip (requires changes to unit tests, though).\n\nAnd I am sorry that the time you spent reading this comment is now\ngone and you can never have it back.\n\n*/\nfinal int MIN_LENGTH = 1;\n\nbyte[] trimmedArray = new byte[Math.max(MIN_LENGTH, array.length - pos)];\nint startPos = trimmedArray.length - (array.length - pos);\nSystem.arraycopy(array, pos, trimmedArray, startPos, trimmedArray.length - startPos);\nreturn trimmedArray;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\n\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\n\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<init>()V",
                                    "method_body": "public Zip64ExtendedInformationExtraField() { }\npublic Zip64ExtendedInformationExtraField() { }"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<clinit>()V",
                                    "method_body": "static final ZipShort HEADER_ID = new ZipShort(0x0001);\n\nprivate static final String LFH_MUST_HAVE_BOTH_SIZES_MSG =\n\"Zip64 extended information must contain\"\n+ \" both size values in the local file header.\";\nprivate static final byte[] EMPTY = new byte[0];\n\nprivate ZipEightByteInteger size, compressedSize, relativeHeaderOffset;\nprivate ZipLong diskStart;\n\n/**\n* Stored in {@link #parseFromCentralDirectoryData\n* parseFromCentralDirectoryData} so it can be reused when ZipFile"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n\n/**\n* Convert a Date object to a DOS date/time field.\n* @param time the <code>Date</code> to convert\n* @return the date as a <code>ZipLong</code>\n*/\npublic static ZipLong toDosTime(Date time) {\nreturn new ZipLong(toDosTime(time.getTime()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:reverse([B)[B",
                                    "method_body": "public static byte[] reverse(final byte[] array) {\nfinal int z = array.length - 1; // position of last element\nfor (int i = 0; i < array.length / 2; i++) {\nbyte x = array[i];\narray[i] = array[z - i];\narray[z - i] = x;\n}\nreturn array;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:signedByteToUnsignedInt(B)I",
                                    "method_body": "public static int signedByteToUnsignedInt(byte b) {\nif (b >= 0) {\nreturn b;\n} else {\nreturn 256 + b;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:unsignedIntToSignedByte(I)B",
                                    "method_body": "public static byte unsignedIntToSignedByte(int i) {\nif (i > 255 || i < 0) {\nthrow new IllegalArgumentException(\"Can only convert non-negative integers between [0,255] to byte: [\" + i + \"]\");\n}\nif (i < 128) {\nreturn (byte) i;\n} else {\nreturn (byte) (i - 256);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:dosToJavaTime(J)J",
                                    "method_body": "public static long dosToJavaTime(long dosTime) {\nCalendar cal = Calendar.getInstance();\n// CheckStyle:MagicNumberCheck OFF - no point\ncal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\ncal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\ncal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);\ncal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);\ncal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);\ncal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);\ncal.set(Calendar.MILLISECOND, 0);\n// CheckStyle:MagicNumberCheck ON\nreturn cal.getTime().getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:setNameAndCommentFromExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;[B[B)V",
                                    "method_body": "static void setNameAndCommentFromExtraFields(ZipArchiveEntry ze,\nbyte[] originalNameBytes,\nbyte[] commentBytes) {\nUnicodePathExtraField name = (UnicodePathExtraField)\nze.getExtraField(UnicodePathExtraField.UPATH_ID);\nString originalName = ze.getName();\nString newName = getUnicodeStringIfOriginalMatches(name,\noriginalNameBytes);\nif (newName != null && !originalName.equals(newName)) {\nze.setName(newName);\n}\n\nif (commentBytes != null && commentBytes.length > 0) {\nUnicodeCommentExtraField cmt = (UnicodeCommentExtraField)\nze.getExtraField(UnicodeCommentExtraField.UCOM_ID);\nString newComment =\ngetUnicodeStringIfOriginalMatches(cmt, commentBytes);\nif (newComment != null) {\nze.setComment(newComment);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:getUnicodeStringIfOriginalMatches(Lorg/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField;[B)Ljava/lang/String;",
                                    "method_body": "String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f,\nbyte[] orig) {\nif (f != null) {\nCRC32 crc32 = new CRC32();\ncrc32.update(orig);\nlong origCRC32 = crc32.getValue();\n\nif (origCRC32 == f.getNameCRC32()) {\ntry {\nreturn ZipEncodingHelper\n.UTF8_ZIP_ENCODING.decode(f.getUnicodeName());\n} catch (IOException ex) {\n// UTF-8 unsupported?  should be impossible the\n// Unicode*ExtraField must contain some bad bytes\n\n// TODO log this anywhere?\nreturn null;\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:supportsEncryptionOf(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private static boolean supportsEncryptionOf(ZipArchiveEntry entry) {\nreturn !entry.getGeneralPurposeBit().usesEncryption();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:supportsMethodOf(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private static boolean supportsMethodOf(ZipArchiveEntry entry) {\nreturn entry.getMethod() == ZipEntry.STORED\n|| entry.getMethod() == ZipMethod.UNSHRINKING.getCode()\n|| entry.getMethod() == ZipMethod.IMPLODING.getCode()\n|| entry.getMethod() == ZipEntry.DEFLATED;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:checkRequestedFeatures(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "static void checkRequestedFeatures(ZipArchiveEntry ze)\nthrows UnsupportedZipFeatureException {\nif (!supportsEncryptionOf(ze)) {\nthrow\nnew UnsupportedZipFeatureException(UnsupportedZipFeatureException\n.Feature.ENCRYPTION, ze);\n}\nif (!supportsMethodOf(ze)) {\nZipMethod m = ZipMethod.getMethodByCode(ze.getMethod());\nif (m == null) {\nthrow\nnew UnsupportedZipFeatureException(UnsupportedZipFeatureException\n.Feature.METHOD, ze);\n} else {\nthrow new UnsupportedZipFeatureException(m, ze);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:<init>(Ljava/lang/String;II)V",
                                    "method_body": "ZipMethod(int code) {\nthis.code = code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:getCode()I",
                                    "method_body": "public int getCode() {\nreturn code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream) {\nthis(inputStream, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream, String encoding) {\nthis(inputStream, encoding, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields) {\nthis(inputStream, encoding, useUnicodeExtraFields, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;ZZ)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream,\nString encoding,\nboolean useUnicodeExtraFields,\nboolean allowStoredEntriesWithDataDescriptor) {\nzipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\nin = new PushbackInputStream(inputStream, buf.capacity());\nthis.allowStoredEntriesWithDataDescriptor =\nallowStoredEntriesWithDataDescriptor;\n// haven't read anything so far\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<clinit>()V",
                                    "method_body": "private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\nprivate static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\nprivate static final byte[] DD = ZipLong.DD_SIG.getBytes();\n\n/**\n* Checks whether the current buffer contains the signature of a\n* &quot;data decsriptor&quot;, &quot;local file header&quot; or\n* &quot;central directory entry&quot;.\n*\n* <p>If it contains such a signature, reads the data descriptor\n* and positions the stream right after the data descriptor.</p>\n*/\nprivate boolean bufferContainsSignature(ByteArrayOutputStream bos, int offset, int lastRead, int expectedDDLen)\nthrows IOException {\n\nboolean done = false;\nint readTooMuch = 0;\nfor (int i = 0; !done && i < lastRead - 4; i++) {\nif (buf.array()[i] == LFH[0] && buf.array()[i + 1] == LFH[1]) {\nif ((buf.array()[i + 2] == LFH[2] && buf.array()[i + 3] == LFH[3])\n|| (buf.array()[i] == CFH[2] && buf.array()[i + 3] == CFH[3])) {\n// found a LFH or CFH:\nreadTooMuch = offset + lastRead - i - expectedDDLen;\ndone = true;\n}\nelse if (buf.array()[i + 2] == DD[2] && buf.array()[i + 3] == DD[3]) {\n// found DD:\nreadTooMuch = offset + lastRead - i;\ndone = true;\n}\nif (done) {\n// * push back bytes read in excess as well as the data\n//   descriptor\n// * copy the remaining bytes to cache\n// * read data descriptor\npushback(buf.array(), offset + lastRead - readTooMuch, readTooMuch);\nbos.write(buf.array(), 0, i);\nreadDataDescriptor();\n}\n}\n}\nreturn done;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:getNextZipEntry()Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;",
                                    "method_body": "public ZipArchiveEntry getNextZipEntry() throws IOException {\nboolean firstEntry = true;\nif (closed || hitCentralDirectory) {\nreturn null;\n}\nif (current != null) {\ncloseEntry();\nfirstEntry = false;\n}\n\ntry {\nif (firstEntry) {\n// split archives have a special signature before the\n// first local file header - look for it and fail with\n// the appropriate error message if this is a split\n// archive.\nreadFirstLocalFileHeader(LFH_BUF);\n} else {\nreadFully(LFH_BUF);\n}\n} catch (EOFException e) {\nreturn null;\n}\n\nZipLong sig = new ZipLong(LFH_BUF);\nif (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\nhitCentralDirectory = true;\nskipRemainderOfArchive();\n}\nif (!sig.equals(ZipLong.LFH_SIG)) {\nreturn null;\n}\n\nint off = WORD;\ncurrent = new CurrentEntry();\n\nint versionMadeBy = ZipShort.getValue(LFH_BUF, off);\noff += SHORT;\ncurrent.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n\nfinal GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\nfinal boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\nfinal ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\ncurrent.hasDataDescriptor = gpFlag.usesDataDescriptor();\ncurrent.entry.setGeneralPurposeBit(gpFlag);\n\noff += SHORT;\n\ncurrent.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\noff += SHORT;\n\nlong time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\ncurrent.entry.setTime(time);\noff += WORD;\n\nZipLong size = null, cSize = null;\nif (!current.hasDataDescriptor) {\ncurrent.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\noff += WORD;\n\ncSize = new ZipLong(LFH_BUF, off);\noff += WORD;\n\nsize = new ZipLong(LFH_BUF, off);\noff += WORD;\n} else {\noff += 3 * WORD;\n}\n\nint fileNameLen = ZipShort.getValue(LFH_BUF, off);\n\noff += SHORT;\n\nint extraLen = ZipShort.getValue(LFH_BUF, off);\noff += SHORT;\n\nbyte[] fileName = new byte[fileNameLen];\nreadFully(fileName);\ncurrent.entry.setName(entryEncoding.decode(fileName), fileName);\n\nbyte[] extraData = new byte[extraLen];\nreadFully(extraData);\ncurrent.entry.setExtra(extraData);\n\nif (!hasUTF8Flag && useUnicodeExtraFields) {\nZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n}\n\nprocessZip64Extra(size, cSize);\n\nif (current.entry.getCompressedSize() != -1) {\nif (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\ncurrent.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n} else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\ncurrent.in = new ExplodingInputStream(\ncurrent.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\ncurrent.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\nnew BoundedInputStream(in, current.entry.getCompressedSize()));\n}\n}\n\nentriesRead++;\nreturn current.entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readFirstLocalFileHeader([B)V",
                                    "method_body": "private void readFirstLocalFileHeader(byte[] lfh) throws IOException {\nreadFully(lfh);\nZipLong sig = new ZipLong(lfh);\nif (sig.equals(ZipLong.DD_SIG)) {\nthrow new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.SPLITTING);\n}\n\nif (sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER)) {\n// The archive is not really split as only one segment was\n// needed in the end.  Just skip over the marker.\nbyte[] missedLfhBytes = new byte[4];\nreadFully(missedLfhBytes);\nSystem.arraycopy(lfh, 4, lfh, 0, LFH_LEN - 4);\nSystem.arraycopy(missedLfhBytes, 0, lfh, LFH_LEN - 4, 4);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:processZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipLong;Lorg/apache/commons/compress/archivers/zip/ZipLong;)V",
                                    "method_body": "private void processZip64Extra(ZipLong size, ZipLong cSize) {\nZip64ExtendedInformationExtraField z64 =\n(Zip64ExtendedInformationExtraField)\ncurrent.entry.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\ncurrent.usesZip64 = z64 != null;\nif (!current.hasDataDescriptor) {\nif (z64 != null // same as current.usesZip64 but avoids NPE warning\n&& (cSize.equals(ZipLong.ZIP64_MAGIC) || size.equals(ZipLong.ZIP64_MAGIC)) ) {\ncurrent.entry.setCompressedSize(z64.getCompressedSize().getLongValue());\ncurrent.entry.setSize(z64.getSize().getLongValue());\n} else {\ncurrent.entry.setCompressedSize(cSize.getValue());\ncurrent.entry.setSize(size.getValue());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] buffer, int offset, int length) throws IOException {\nif (closed) {\nthrow new IOException(\"The stream is closed\");\n}\n\nif (current == null) {\nreturn -1;\n}\n\n// avoid int overflow, check null buffer\nif (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\nthrow new ArrayIndexOutOfBoundsException();\n}\n\nZipUtil.checkRequestedFeatures(current.entry);\nif (!supportsDataDescriptorFor(current.entry)) {\nthrow new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR,\ncurrent.entry);\n}\n\nint read;\nif (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\nread = readStored(buffer, offset, length);\n} else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\nread = readDeflated(buffer, offset, length);\n} else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()\n|| current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\nread = current.in.read(buffer, offset, length);\n} else {\nthrow new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()),\ncurrent.entry);\n}\n\nif (read >= 0) {\ncurrent.crc.update(buffer, offset, read);\n}\n\nreturn read;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readStored([BII)I",
                                    "method_body": "private int readStored(byte[] buffer, int offset, int length) throws IOException {\n\nif (current.hasDataDescriptor) {\nif (lastStoredEntry == null) {\nreadStoredEntry();\n}\nreturn lastStoredEntry.read(buffer, offset, length);\n}\n\nlong csize = current.entry.getSize();\nif (current.bytesRead >= csize) {\nreturn -1;\n}\n\nif (buf.position() >= buf.limit()) {\nbuf.position(0);\nint l = in.read(buf.array());\nif (l == -1) {\nreturn -1;\n}\nbuf.limit(l);\n\ncount(buf.limit());\ncurrent.bytesReadFromStream += buf.limit();\n}\n\nint toRead = Math.min(buf.remaining(), length);\nif ((csize - current.bytesRead) < toRead) {\n// if it is smaller than toRead then it fits into an int\ntoRead = (int) (csize - current.bytesRead);\n}\nbuf.get(buffer, offset, toRead);\ncurrent.bytesRead += toRead;\nreturn toRead;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!closed) {\nclosed = true;\nin.close();\ninf.end();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readFully([B)V",
                                    "method_body": "private void readFully(byte[] b) throws IOException {\nint count = IOUtils.readFully(in, b);\ncount(count);\nif (count < b.length) {\nthrow new EOFException();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:supportsDataDescriptorFor(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private boolean supportsDataDescriptorFor(ZipArchiveEntry entry) {\nreturn !entry.getGeneralPurposeBit().usesDataDescriptor()\n\n|| (allowStoredEntriesWithDataDescriptor && entry.getMethod() == ZipEntry.STORED)\n|| entry.getMethod() == ZipEntry.DEFLATED;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<init>(I)V",
                                    "method_body": "private UnparseableExtraField(int k) {\nkey = k;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<clinit>()V",
                                    "method_body": "public static final int THROW_KEY = 0;\n/**\n* Key for \"skip\" action.\n*/\npublic static final int SKIP_KEY = 1;\n/**\n* Key for \"read\" action.\n*/\npublic static final int READ_KEY = 2;\n\n/**\n* Throw an exception if field cannot be parsed.\n*/\npublic static final UnparseableExtraField THROW\n= new UnparseableExtraField(THROW_KEY);\n\n/**\n* Skip the extra field entirely and don't make its data\n* available - effectively removing the extra field data.\n*/\npublic static final UnparseableExtraField SKIP\n= new UnparseableExtraField(SKIP_KEY);\n\n/**\n* Read the extra field data into an instance of {@link\n* UnparseableExtraFieldData UnparseableExtraFieldData}."
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 26,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.utils.IOUtilsTest.skipUsingSkipAndRead",
                            "test_body": "57: public void skipUsingSkipAndRead() throws Exception {\n58: skip(new StreamWrapper() {\n59: public InputStream wrap(final InputStream toWrap) {\n60: return new FilterInputStream(toWrap) {\n61: boolean skipped;\n62: public long skip(long s) throws IOException {\n63: if (!skipped) {\n64: toWrap.skip(5);\n65: skipped = true;\n66: return 5;\n67: }\n68: return 0;\n69: }\n70: };\n71: }\n72: });\n73: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:skip(Ljava/io/InputStream;J)J",
                                    "method_body": "public static long skip(InputStream input, long numToSkip) throws IOException {\nlong available = numToSkip;\nwhile (numToSkip > 0) {\nlong skipped = input.skip(numToSkip);\nif (skipped == 0) {\nbreak;\n}\nnumToSkip -= skipped;\n}\n\nreturn available - numToSkip;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.utils.IOUtilsTest.skipUsingRead",
                            "test_body": "44: public void skipUsingRead() throws Exception {\n45: skip(new StreamWrapper() {\n46: public InputStream wrap(InputStream toWrap) {\n47: return new FilterInputStream(toWrap) {\n48: public long skip(long s) {\n49: return 0;\n50: }\n51: };\n52: }\n53: });\n54: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:skip(Ljava/io/InputStream;J)J",
                                    "method_body": "public static long skip(InputStream input, long numToSkip) throws IOException {\nlong available = numToSkip;\nwhile (numToSkip > 0) {\nlong skipped = input.skip(numToSkip);\nif (skipped == 0) {\nbreak;\n}\nnumToSkip -= skipped;\n}\n\nreturn available - numToSkip;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 27,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarUtilsTest.testParseOctal",
                            "test_body": "46: public void testParseOctal() throws Exception{\n47: long value; \n48: byte [] buffer;\n49: final long MAX_OCTAL  = 077777777777L; // Allowed 11 digits\n50: final long MAX_OCTAL_OVERFLOW  = 0777777777777L; // in fact 12 for some implementations\n51: final String maxOctal = \"777777777777\"; // Maximum valid octal\n52: buffer = maxOctal.getBytes(CharsetNames.UTF_8);\n53: value = TarUtils.parseOctal(buffer,0, buffer.length);\n54: assertEquals(MAX_OCTAL_OVERFLOW, value);\n55: buffer[buffer.length - 1] = ' ';\n56: value = TarUtils.parseOctal(buffer,0, buffer.length);\n57: assertEquals(MAX_OCTAL, value);\n58: buffer[buffer.length-1]=0;\n59: value = TarUtils.parseOctal(buffer,0, buffer.length);\n60: assertEquals(MAX_OCTAL, value);\n61: buffer=new byte[]{0,0};\n62: value = TarUtils.parseOctal(buffer,0, buffer.length);\n63: assertEquals(0, value);\n64: buffer=new byte[]{0,' '};\n65: value = TarUtils.parseOctal(buffer,0, buffer.length);\n66: assertEquals(0, value);\n67: buffer=new byte[]{' ',0};\n68: value = TarUtils.parseOctal(buffer,0, buffer.length);\n69: assertEquals(0, value);\n70: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n\nstatic {\nMap<String, SimpleEncodingHolder> se =\nnew HashMap<String, SimpleEncodingHolder>();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for UTF-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h = simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\n// check platform's default encoding\ncharsetName = System.getProperty(\"file.encoding\");\n}\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}\nfor (String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\n\n/**\n* <p>\n* Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\n* (either order accepted on input, big-endian used on output)\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, big-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, little-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\n\n/**\n* <p>\n* Eight-bit Unicode Transformation Format.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:<clinit>()V",
                                    "method_body": "private static final int BYTE_MASK = 255;\n\nstatic final ZipEncoding DEFAULT_ENCODING =\nZipEncodingHelper.getZipEncoding(null);\n\n/**\n* Encapsulates the algorithms used up to Commons Compress 1.3 as\n* ZipEncoding.\n*/\nstatic final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\npublic boolean canEncode(String name) { return true; }\n\npublic ByteBuffer encode(String name) {\nfinal int length = name.length();\nbyte[] buf = new byte[length];\n\n// copy until end of input or output is reached.\nfor (int i = 0; i < length; ++i) {\nbuf[i] = (byte) name.charAt(i);\n}\nreturn ByteBuffer.wrap(buf);\n}\n\npublic String decode(byte[] buffer) {\nfinal int length = buffer.length;\nStringBuilder result = new StringBuilder(length);\n\nfor (int i = 0; i < length; ++i) {\nbyte b = buffer[i];\nif (b == 0) { // Trailing null\nbreak;\n}\nresult.append((char) (b & 0xFF)); // Allow for sign-extension\n}\n\nreturn result.toString();\n}\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\n\nif (length < 2){\nthrow new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n}\n\nif (buffer[start] == 0) {\nreturn 0L;\n}\n\n// Skip leading spaces\nwhile (start < end){\nif (buffer[start] == ' '){\nstart++;\n} else {\nbreak;\n}\n}\n\n// Trim all trailing NULs and spaces.\n// The ustar and POSIX tar specs require a trailing NUL or\n// space but some implementations use the extra digit for big\n// sizes/uids/gids ...\nbyte trailer = buffer[end - 1];\nwhile (start < end && (trailer == 0 || trailer == ' ')) {\nend--;\ntrailer = buffer[end - 1];\n}\nif (start == end) {\nthrow new IllegalArgumentException(\nexceptionMessage(buffer, offset, length, start, trailer));\n}\n\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\n// CheckStyle:MagicNumber OFF\nif (currentByte < '0' || currentByte > '7'){\nthrow new IllegalArgumentException(\nexceptionMessage(buffer, offset, length, start, currentByte));\n}\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\n// CheckStyle:MagicNumber ON\n}\n\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:exceptionMessage([BIIIB)Ljava/lang/String;",
                                    "method_body": "private static String exceptionMessage(byte[] buffer, final int offset,\nfinal int length, int current, final byte currentByte) {\n// default charset is good enough for an exception message,\n//\n// the alternative was to modify parseOctal and\n// parseOctalOrBinary to receive the ZipEncoding of the\n// archive (deprecating the existing public methods, of\n// course) and dealing with the fact that ZipEncoding#decode\n// can throw an IOException which parseOctal* doesn't declare\nString string = new String(buffer, offset, length);\n\nstring=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed\nfinal String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;\nreturn s;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 28,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest.shouldThrowAnExceptionOnTruncatedEntries",
                            "test_body": "213: public void shouldThrowAnExceptionOnTruncatedEntries() throws Exception {\n214: File dir = mkdir(\"COMPRESS-279\");\n215: TarArchiveInputStream is = getTestStream(\"/COMPRESS-279.tar\");\n216: FileOutputStream out = null;\n217: try {\n218: TarArchiveEntry entry = is.getNextTarEntry();\n219: int count = 0;\n220: while (entry != null) {\n221: out = new FileOutputStream(new File(dir, String.valueOf(count)));\n222: IOUtils.copy(is, out);\n223: out.close();\n224: out = null;\n225: count++;\n226: entry = is.getNextTarEntry();\n227: }\n228: } finally {\n229: is.close();\n230: if (out != null) {\n231: out.close();\n232: }\n233: }\n234: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final int SKIP_BUF_SIZE = 4096;\n\n// This buffer does not need to be synchronised because it is write only; the contents are ignored\n// Does not affect Immutability\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n\n/** Private constructor to prevent instantiation of this utility class. */\nprivate IOUtils(){\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:copy(Ljava/io/InputStream;Ljava/io/OutputStream;)J",
                                    "method_body": "public static long copy(final InputStream input, final OutputStream output) throws IOException {\nreturn copy(input, output, COPY_BUF_SIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:copy(Ljava/io/InputStream;Ljava/io/OutputStream;I)J",
                                    "method_body": "public static long copy(final InputStream input, final OutputStream output, int buffersize) throws IOException {\nfinal byte[] buffer = new byte[buffersize];\nint n = 0;\nlong count=0;\nwhile (-1 != (n = input.read(buffer))) {\noutput.write(buffer, 0, n);\ncount += n;\n}\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:skip(Ljava/io/InputStream;J)J",
                                    "method_body": "public static long skip(InputStream input, long numToSkip) throws IOException {\nlong available = numToSkip;\nwhile (numToSkip > 0) {\nlong skipped = input.skip(numToSkip);\nif (skipped == 0) {\nbreak;\n}\nnumToSkip -= skipped;\n}\n\nwhile (numToSkip > 0) {\nint read = readFully(input, SKIP_BUF, 0,\n(int) Math.min(numToSkip, SKIP_BUF_SIZE));\nif (read < 1) {\nbreak;\n}\nnumToSkip -= read;\n}\nreturn available - numToSkip;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[B)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b) throws IOException {\nreturn readFully(input, b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b, int offset, int len)\nthrows IOException {\nif (len < 0 || offset < 0 || len + offset > b.length) {\nthrow new IndexOutOfBoundsException();\n}\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\nbreak;\n}\ncount += x;\n}\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n\nstatic {\nMap<String, SimpleEncodingHolder> se =\nnew HashMap<String, SimpleEncodingHolder>();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for UTF-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h = simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\n// check platform's default encoding\ncharsetName = System.getProperty(\"file.encoding\");\n}\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}\nfor (String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data);\n} else {\nreturn new String(data,this.charsetName);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\n\n/**\n* <p>\n* Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\n* (either order accepted on input, big-endian used on output)\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, big-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, little-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\n\n/**\n* <p>\n* Eight-bit Unicode Transformation Format.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry() {\nString user = System.getProperty(\"user.name\", \"\");\n\nif (user.length() > MAX_NAMELEN) {\nuser = user.substring(0, MAX_NAMELEN);\n}\n\nthis.userName = user;\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public TarArchiveEntry(byte[] headerBuf, ZipEncoding encoding)\nthrows IOException {\nthis();\nparseTarHeader(headerBuf, encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNUSparse()Z",
                                    "method_body": "public boolean isGNUSparse() {\nreturn linkFlag == LF_GNUTYPE_SPARSE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongLinkEntry()Z",
                                    "method_body": "public boolean isGNULongLinkEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGLINK\n&& name.equals(GNU_LONGLINK);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongNameEntry()Z",
                                    "method_body": "public boolean isGNULongNameEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGNAME\n&& name.equals(GNU_LONGLINK);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isPaxHeader()Z",
                                    "method_body": "public boolean isPaxHeader(){\nreturn linkFlag == LF_PAX_EXTENDED_HEADER_LC\n|| linkFlag == LF_PAX_EXTENDED_HEADER_UC;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public void parseTarHeader(byte[] header, ZipEncoding encoding)\nthrows IOException {\nparseTarHeader(header, encoding, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;Z)V",
                                    "method_body": "private void parseTarHeader(byte[] header, ZipEncoding encoding,\nfinal boolean oldStyle)\nthrows IOException {\nint offset = 0;\n\nname = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n: TarUtils.parseName(header, offset, NAMELEN, encoding);\noffset += NAMELEN;\nmode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN);\noffset += MODELEN;\nuserId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\noffset += UIDLEN;\ngroupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\noffset += GIDLEN;\nsize = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\noffset += SIZELEN;\nmodTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN);\noffset += MODTIMELEN;\ncheckSumOK = TarUtils.verifyCheckSum(header);\noffset += CHKSUMLEN;\nlinkFlag = header[offset++];\nlinkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n: TarUtils.parseName(header, offset, NAMELEN, encoding);\noffset += NAMELEN;\nmagic = TarUtils.parseName(header, offset, MAGICLEN);\noffset += MAGICLEN;\nversion = TarUtils.parseName(header, offset, VERSIONLEN);\noffset += VERSIONLEN;\nuserName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)\n: TarUtils.parseName(header, offset, UNAMELEN, encoding);\noffset += UNAMELEN;\ngroupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN)\n: TarUtils.parseName(header, offset, GNAMELEN, encoding);\noffset += GNAMELEN;\ndevMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\ndevMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\n\nint type = evaluateType(header);\nswitch (type) {\ncase FORMAT_OLDGNU: {\noffset += ATIMELEN_GNU;\noffset += CTIMELEN_GNU;\noffset += OFFSETLEN_GNU;\noffset += LONGNAMESLEN_GNU;\noffset += PAD2LEN_GNU;\noffset += SPARSELEN_GNU;\nisExtended = TarUtils.parseBoolean(header, offset);\noffset += ISEXTENDEDLEN_GNU;\nrealSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU);\noffset += REALSIZELEN_GNU;\nbreak;\n}\ncase FORMAT_POSIX:\ndefault: {\nString prefix = oldStyle\n? TarUtils.parseName(header, offset, PREFIXLEN)\n: TarUtils.parseName(header, offset, PREFIXLEN, encoding);\n// SunOS tar -E does not add / to directory names, so fix\n// up to be consistent\nif (isDirectory() && !name.endsWith(\"/\")){\nname = name + \"/\";\n}\nif (prefix.length() > 0){\nname = prefix + \"/\" + name;\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:evaluateType([B)I",
                                    "method_body": "private int evaluateType(byte[] header) {\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_GNU, header, MAGIC_OFFSET, MAGICLEN)) {\nreturn FORMAT_OLDGNU;\n}\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_POSIX, header, MAGIC_OFFSET, MAGICLEN)) {\nreturn FORMAT_POSIX;\n}\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:<clinit>()V",
                                    "method_body": "private static final int BYTE_MASK = 255;\n\nstatic final ZipEncoding DEFAULT_ENCODING =\nZipEncodingHelper.getZipEncoding(null);\n\n/**\n* Encapsulates the algorithms used up to Commons Compress 1.3 as\n* ZipEncoding.\n*/\nstatic final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\npublic boolean canEncode(String name) { return true; }\n\npublic ByteBuffer encode(String name) {\nfinal int length = name.length();\nbyte[] buf = new byte[length];\n\n// copy until end of input or output is reached.\nfor (int i = 0; i < length; ++i) {\nbuf[i] = (byte) name.charAt(i);\n}\nreturn ByteBuffer.wrap(buf);\n}\n\npublic String decode(byte[] buffer) {\nfinal int length = buffer.length;\nStringBuilder result = new StringBuilder(length);\n\nfor (int i = 0; i < length; ++i) {\nbyte b = buffer[i];\nif (b == 0) { // Trailing null\nbreak;\n}\nresult.append((char) (b & 0xFF)); // Allow for sign-extension\n}\n\nreturn result.toString();\n}\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\n\nif (length < 2){\nthrow new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n}\n\nif (buffer[start] == 0) {\nreturn 0L;\n}\n\n// Skip leading spaces\nwhile (start < end){\nif (buffer[start] == ' '){\nstart++;\n} else {\nbreak;\n}\n}\n\n// Trim all trailing NULs and spaces.\n// The ustar and POSIX tar specs require a trailing NUL or\n// space but some implementations use the extra digit for big\n// sizes/uids/gids ...\nbyte trailer = buffer[end - 1];\nwhile (start < end && (trailer == 0 || trailer == ' ')) {\nend--;\ntrailer = buffer[end - 1];\n}\n\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\n// CheckStyle:MagicNumber OFF\nif (currentByte < '0' || currentByte > '7'){\nthrow new IllegalArgumentException(\nexceptionMessage(buffer, offset, length, start, currentByte));\n}\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\n// CheckStyle:MagicNumber ON\n}\n\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctalOrBinary([BII)J",
                                    "method_body": "public static long parseOctalOrBinary(final byte[] buffer, final int offset,\nfinal int length) {\n\nif ((buffer[offset] & 0x80) == 0) {\nreturn parseOctal(buffer, offset, length);\n}\nfinal boolean negative = buffer[offset] == (byte) 0xff;\nif (length < 9) {\nreturn parseBinaryLong(buffer, offset, length, negative);\n}\nreturn parseBinaryBigInteger(buffer, offset, length, negative);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseBoolean([BI)Z",
                                    "method_body": "public static boolean parseBoolean(final byte[] buffer, final int offset) {\nreturn buffer[offset] == 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BII)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset, final int length) {\ntry {\nreturn parseName(buffer, offset, length, DEFAULT_ENCODING);\n} catch (IOException ex) {\ntry {\nreturn parseName(buffer, offset, length, FALLBACK_ENCODING);\n} catch (IOException ex2) {\n// impossible\nthrow new RuntimeException(ex2);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BIILorg/apache/commons/compress/archivers/zip/ZipEncoding;)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset,\nfinal int length,\nfinal ZipEncoding encoding)\nthrows IOException {\n\nint len = length;\nfor (; len > 0; len--) {\nif (buffer[offset + len - 1] != 0) {\nbreak;\n}\n}\nif (len > 0) {\nbyte[] b = new byte[len];\nSystem.arraycopy(buffer, offset, b, 0, len);\nreturn encoding.decode(b);\n}\nreturn \"\";\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:verifyCheckSum([B)Z",
                                    "method_body": "public static boolean verifyCheckSum(byte[] header) {\nlong storedSum = 0;\nlong unsignedSum = 0;\nlong signedSum = 0;\n\nint digits = 0;\nfor (int i = 0; i < header.length; i++) {\nbyte b = header[i];\nif (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\nif ('0' <= b && b <= '7' && digits++ < 6) {\nstoredSum = storedSum * 8 + b - '0';\n} else if (digits > 0) {\ndigits = 6; // only look at the first octal digit sequence\n}\nb = ' ';\n}\nunsignedSum += 0xff & b;\nsignedSum += b;\n}\n\nreturn storedSum == unsignedSum || storedSum == signedSum\n|| storedSum > unsignedSum; // COMPRESS-177\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:matchAsciiBuffer(Ljava/lang/String;[BII)Z",
                                    "method_body": "public static boolean matchAsciiBuffer(\nString expected, byte[] buffer, int offset, int length){\nbyte[] buffer1;\ntry {\nbuffer1 = expected.getBytes(CharsetNames.US_ASCII);\n} catch (UnsupportedEncodingException e) {\nthrow new RuntimeException(e); // Should not happen\n}\nreturn isEqual(buffer1, 0, buffer1.length, buffer, offset, length, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isEqual([BII[BIIZ)Z",
                                    "method_body": "public static boolean isEqual(\nfinal byte[] buffer1, final int offset1, final int length1,\nfinal byte[] buffer2, final int offset2, final int length2,\nboolean ignoreTrailingNulls){\nint minLen=length1 < length2 ? length1 : length2;\nfor (int i=0; i < minLen; i++){\nif (buffer1[offset1+i] != buffer2[offset2+i]){\nreturn false;\n}\n}\nif (length1 == length2){\nreturn true;\n}\nif (ignoreTrailingNulls){\nif (length1 > length2){\nfor(int i = length2; i < length1; i++){\nif (buffer1[offset1+i] != 0){\nreturn false;\n}\n}\n} else {\nfor(int i = length1; i < length2; i++){\nif (buffer2[offset2+i] != 0){\nreturn false;\n}\n}\n}\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isArrayZero([BI)Z",
                                    "method_body": "public static boolean isArrayZero(byte[] a, int size) {\nfor (int i = 0; i < size; i++) {\nif (a[i] != 0) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is) {\nthis(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\nthis(is, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;IILjava/lang/String;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize,\nString encoding) {\nthis.is = is;\nthis.hasHitEOF = false;\nthis.encoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.recordSize = recordSize;\nthis.blockSize = blockSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nis.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:available()I",
                                    "method_body": "public int available() throws IOException {\nif (entrySize - entryOffset > Integer.MAX_VALUE) {\nreturn Integer.MAX_VALUE;\n}\nreturn (int) (entrySize - entryOffset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:skip(J)J",
                                    "method_body": "public long skip(long numToSkip) throws IOException {\n\nlong available = entrySize - entryOffset;\nnumToSkip = Math.min(numToSkip, available);\n\nlong skipped = IOUtils.skip(is, numToSkip);\ncount(skipped);\nentryOffset += skipped;\nreturn skipped;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextTarEntry()Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;",
                                    "method_body": "public TarArchiveEntry getNextTarEntry() throws IOException {\nif (hasHitEOF) {\nreturn null;\n}\n\nif (currEntry != null) {\n/* Skip will only go to the end of the current entry */\nskip(Long.MAX_VALUE);\n\n/* skip to the end of the last record */\nskipRecordPadding();\n}\n\nbyte[] headerBuf = getRecord();\n\nif (headerBuf == null) {\n/* hit EOF */\ncurrEntry = null;\nreturn null;\n}\n\ntry {\ncurrEntry = new TarArchiveEntry(headerBuf, encoding);\n} catch (IllegalArgumentException e) {\nIOException ioe = new IOException(\"Error detected parsing the header\");\nioe.initCause(e);\nthrow ioe;\n}\n\nentryOffset = 0;\nentrySize = currEntry.getSize();\n\nif (currEntry.isGNULongLinkEntry()) {\nbyte[] longLinkData = getLongNameData();\nif (longLinkData == null) {\n// Bugzilla: 40334\n// Malformed tar file - long link entry name not followed by\n// entry\nreturn null;\n}\ncurrEntry.setLinkName(encoding.decode(longLinkData));\n}\n\nif (currEntry.isGNULongNameEntry()) {\nbyte[] longNameData = getLongNameData();\nif (longNameData == null) {\n// Bugzilla: 40334\n// Malformed tar file - long entry name not followed by\n// entry\nreturn null;\n}\ncurrEntry.setName(encoding.decode(longNameData));\n}\n\nif (currEntry.isPaxHeader()){ // Process Pax headers\npaxHeaders();\n}\n\nif (currEntry.isGNUSparse()){ // Process sparse files\nreadGNUSparse();\n}\n\n// If the size of the next element in the archive has changed\n// due to a new size being reported in the posix header\n// information, we update entrySize here so that it contains\n// the correct value.\nentrySize = currEntry.getSize();\n\nreturn currEntry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:skipRecordPadding()V",
                                    "method_body": "private void skipRecordPadding() throws IOException {\nif (this.entrySize > 0 && this.entrySize % this.recordSize != 0) {\nlong numRecords = (this.entrySize / this.recordSize) + 1;\nlong padding = (numRecords * this.recordSize) - this.entrySize;\nlong skipped = IOUtils.skip(is, padding);\ncount(skipped);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getRecord()[B",
                                    "method_body": "private byte[] getRecord() throws IOException {\nbyte[] headerBuf = readRecord();\nhasHitEOF = isEOFRecord(headerBuf);\nif (hasHitEOF && headerBuf != null) {\ntryToConsumeSecondEOFRecord();\nconsumeRemainderOfLastBlock();\nheaderBuf = null;\n}\nreturn headerBuf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:isEOFRecord([B)Z",
                                    "method_body": "protected boolean isEOFRecord(byte[] record) {\nreturn record == null || ArchiveUtils.isArrayZero(record, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:readRecord()[B",
                                    "method_body": "protected byte[] readRecord() throws IOException {\n\nbyte[] record = new byte[recordSize];\n\nint readNow = IOUtils.readFully(is, record);\ncount(readNow);\nif (readNow != recordSize) {\nreturn null;\n}\n\nreturn record;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] buf, int offset, int numToRead) throws IOException {\nint totalRead = 0;\n\nif (hasHitEOF || entryOffset >= entrySize) {\nreturn -1;\n}\n\nif (currEntry == null) {\nthrow new IllegalStateException(\"No current tar entry\");\n}\n\nnumToRead = Math.min(numToRead, available());\n\ntotalRead = is.read(buf, offset, numToRead);\ncount(totalRead);\n\nif (totalRead == -1) {\nhasHitEOF = true;\n} else {\nentryOffset += totalRead;\n}\n\nreturn totalRead;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 29,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest.testEncodingInputStream",
                            "test_body": "307: public void testEncodingInputStream() throws Exception {\n308: int failed = 0;\n309: for(int i = 1; i <= TESTS.length; i++) {\n310: TestData test = TESTS[i-1];\n311: ArchiveInputStream ais = getInputStreamFor(test.type, test.testFile, test.fac);\n312: final String field = getField(ais,test.fieldName);\n313: if (!eq(test.expectedEncoding,field)) {\n314: System.out.println(\"Failed test \" + i + \". expected: \" + test.expectedEncoding + \" actual: \" + field + \" type: \" + test.type);\n315: failed++;\n316: }\n317: }\n318: if (failed > 0) {\n319: fail(\"Tests failed: \" + failed);\n320: }\n321: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>()V",
                                    "method_body": "public ArchiveStreamFactory() {\nthis(null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ArchiveStreamFactory(String encoding) {\nsuper();\nthis.encoding = encoding;\n// Also set the original field so can continue to use it.\nthis.entryEncoding = encoding;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:setEntryEncoding(Ljava/lang/String;)V",
                                    "method_body": "public void setEntryEncoding(String entryEncoding) {\n// Note: this does not detect new ArchiveStreamFactory(null) but that does not set the encoding anyway\nif (encoding != null) {\nthrow new IllegalStateException(\"Cannot overide encoding set by the constructor\");\n}\nthis.entryEncoding = entryEncoding;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveInputStream(Ljava/lang/String;Ljava/io/InputStream;)Lorg/apache/commons/compress/archivers/ArchiveInputStream;",
                                    "method_body": "public ArchiveInputStream createArchiveInputStream(\nfinal String archiverName, final InputStream in)\nthrows ArchiveException {\n\nif (archiverName == null) {\nthrow new IllegalArgumentException(\"Archivername must not be null.\");\n}\n\nif (in == null) {\nthrow new IllegalArgumentException(\"InputStream must not be null.\");\n}\n\nif (AR.equalsIgnoreCase(archiverName)) {\nreturn new ArArchiveInputStream(in);\n}\nif (ARJ.equalsIgnoreCase(archiverName)) {\nif (entryEncoding != null) {\nreturn new ArjArchiveInputStream(in, entryEncoding);\n} else {\nreturn new ArjArchiveInputStream(in);\n}\n}\nif (ZIP.equalsIgnoreCase(archiverName)) {\nif (entryEncoding != null) {\nreturn new ZipArchiveInputStream(in, entryEncoding);\n} else {\nreturn new ZipArchiveInputStream(in);\n}\n}\nif (TAR.equalsIgnoreCase(archiverName)) {\nif (entryEncoding != null) {\nreturn new TarArchiveInputStream(in, entryEncoding);\n} else {\nreturn new TarArchiveInputStream(in);\n}\n}\nif (JAR.equalsIgnoreCase(archiverName)) {\nif (entryEncoding != null) {\nreturn new JarArchiveInputStream(in, entryEncoding);\n} else {\nreturn new JarArchiveInputStream(in);\n}\n}\nif (CPIO.equalsIgnoreCase(archiverName)) {\nif (entryEncoding != null) {\nreturn new CpioArchiveInputStream(in, entryEncoding);\n} else {\nreturn new CpioArchiveInputStream(in);\n}\n}\nif (DUMP.equalsIgnoreCase(archiverName)) {\nif (entryEncoding != null) {\nreturn new DumpArchiveInputStream(in, entryEncoding);\n} else {\nreturn new DumpArchiveInputStream(in);\n}\n}\nif (SEVEN_Z.equalsIgnoreCase(archiverName)) {\nthrow new StreamingNotSupportedException(SEVEN_Z);\n}\n\nthrow new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\n//private static final int BYTE_BIT_SIZE = 8;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Data Descriptor signature.\n*\n* <p>Actually, PKWARE uses this as marker for split/spanned\n* archives and other archivers have started to use it as Data\n* Descriptor signature (as well).</p>\n* @since 1.1\n*/\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\n\n/**\n* Value stored in size and similar fields if ZIP64 extensions are\n* used.\n* @since 1.3\n*/\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\n\n/**\n* Marks ZIP archives that were supposed to be split or spanned\n* but only needed a single segment in then end (so are actually\n* neither split nor spanned).\n*\n* <p>This is the \"PK00\" prefix found in some archives.</p>\n* @since 1.5\n*/\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\nnew ZipLong(0X30304B50L);\n\n/**\n* Archive extra data record signature.\n* @since 1.5\n*/\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nputLong(value, result, 0);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:putLong(J[BI)V",
                                    "method_body": "public static void putLong(long value, byte[] buf, int offset) {\nbuf[offset++] = (byte) ((value & BYTE_MASK));\nbuf[offset++] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nbuf[offset++] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nbuf[offset] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n\nstatic {\nMap<String, SimpleEncodingHolder> se =\nnew HashMap<String, SimpleEncodingHolder>();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for UTF-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h = simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\n// check platform's default encoding\ncharsetName = System.getProperty(\"file.encoding\");\n}\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}\nfor (String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data);\n} else {\nreturn new String(data,this.charsetName);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\n\n/**\n* <p>\n* Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\n* (either order accepted on input, big-endian used on output)\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, big-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, little-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\n\n/**\n* <p>\n* Eight-bit Unicode Transformation Format.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:<init>(Ljava/nio/charset/Charset;)V",
                                    "method_body": "public NioZipEncoding(Charset charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nreturn this.charset.newDecoder()\n.onMalformedInput(CodingErrorAction.REPORT)\n.onUnmappableCharacter(CodingErrorAction.REPORT)\n.decode(ByteBuffer.wrap(data)).toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final int SKIP_BUF_SIZE = 4096;\n\n// This buffer does not need to be synchronised because it is write only; the contents are ignored\n// Does not affect Immutability\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n\n/** Private constructor to prevent instantiation of this utility class. */\nprivate IOUtils(){\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b, int offset, int len)\nthrows IOException {\nif (len < 0 || offset < 0 || len + offset > b.length) {\nthrow new IndexOutOfBoundsException();\n}\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\nbreak;\n}\ncount += x;\n}\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:pushedBackBytes(J)V",
                                    "method_body": "protected void pushedBackBytes(long pushedBack) {\nbytesRead -= pushedBack;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public CpioArchiveInputStream(final InputStream in) {\nthis(in, BLOCK_SIZE, CharsetNames.US_ASCII);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public CpioArchiveInputStream(final InputStream in, String encoding) {\nthis(in, BLOCK_SIZE, encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:<init>(Ljava/io/InputStream;ILjava/lang/String;)V",
                                    "method_body": "public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\nthis.in = in;\nthis.blockSize = blockSize;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream) {\nthis(inputStream, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream, String encoding) {\nthis(inputStream, encoding, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields) {\nthis(inputStream, encoding, useUnicodeExtraFields, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;ZZ)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream,\nString encoding,\nboolean useUnicodeExtraFields,\nboolean allowStoredEntriesWithDataDescriptor) {\nzipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\nin = new PushbackInputStream(inputStream, buf.capacity());\nthis.allowStoredEntriesWithDataDescriptor =\nallowStoredEntriesWithDataDescriptor;\n// haven't read anything so far\nbuf.limit(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<clinit>()V",
                                    "method_body": "private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\nprivate static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\nprivate static final byte[] DD = ZipLong.DD_SIG.getBytes();\n\n/**\n* Checks whether the current buffer contains the signature of a\n* &quot;data descriptor&quot;, &quot;local file header&quot; or\n* &quot;central directory entry&quot;.\n*\n* <p>If it contains such a signature, reads the data descriptor\n* and positions the stream right after the data descriptor.</p>\n*/\nprivate boolean bufferContainsSignature(ByteArrayOutputStream bos, int offset, int lastRead, int expectedDDLen)\nthrows IOException {\n\nboolean done = false;\nint readTooMuch = 0;\nfor (int i = 0; !done && i < lastRead - 4; i++) {\nif (buf.array()[i] == LFH[0] && buf.array()[i + 1] == LFH[1]) {\nif ((buf.array()[i + 2] == LFH[2] && buf.array()[i + 3] == LFH[3])\n|| (buf.array()[i] == CFH[2] && buf.array()[i + 3] == CFH[3])) {\n// found a LFH or CFH:\nreadTooMuch = offset + lastRead - i - expectedDDLen;\ndone = true;\n}\nelse if (buf.array()[i + 2] == DD[2] && buf.array()[i + 3] == DD[3]) {\n// found DD:\nreadTooMuch = offset + lastRead - i;\ndone = true;\n}\nif (done) {\n// * push back bytes read in excess as well as the data\n//   descriptor\n// * copy the remaining bytes to cache\n// * read data descriptor\npushback(buf.array(), offset + lastRead - readTooMuch, readTooMuch);\nbos.write(buf.array(), 0, i);\nreadDataDescriptor();\n}\n}\n}\nreturn done;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public JarArchiveInputStream( final InputStream inputStream ) {\nsuper(inputStream);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public JarArchiveInputStream( final InputStream inputStream, final String encoding ) {\nsuper(inputStream, encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is) {\nthis(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, String encoding) {\nthis(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE,\nencoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\nthis(is, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;IILjava/lang/String;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize,\nString encoding) {\nthis.is = is;\nthis.hasHitEOF = false;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.recordSize = recordSize;\nthis.blockSize = blockSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public ArjArchiveInputStream(final InputStream inputStream,\nfinal String charsetName) throws ArchiveException {\nin = new DataInputStream(inputStream);\nthis.charsetName = charsetName;\ntry {\nmainHeader = readMainHeader();\nif ((mainHeader.arjFlags & MainHeader.Flags.GARBLED) != 0) {\nthrow new ArchiveException(\"Encrypted ARJ files are unsupported\");\n}\nif ((mainHeader.arjFlags & MainHeader.Flags.VOLUME) != 0) {\nthrow new ArchiveException(\"Multi-volume ARJ files are unsupported\");\n}\n} catch (IOException ioException) {\nthrow new ArchiveException(ioException.getMessage(), ioException);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public ArjArchiveInputStream(final InputStream inputStream)\nthrows ArchiveException {\nthis(inputStream, \"CP437\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:read8(Ljava/io/DataInputStream;)I",
                                    "method_body": "private int read8(final DataInputStream dataIn) throws IOException {\nint value = dataIn.readUnsignedByte();\ncount(1);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:read16(Ljava/io/DataInputStream;)I",
                                    "method_body": "private int read16(final DataInputStream dataIn) throws IOException {\nfinal int value = dataIn.readUnsignedShort();\ncount(2);\nreturn Integer.reverseBytes(value) >>> 16;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:read32(Ljava/io/DataInputStream;)I",
                                    "method_body": "private int read32(final DataInputStream dataIn) throws IOException {\nfinal int value = dataIn.readInt();\ncount(4);\nreturn Integer.reverseBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:readString(Ljava/io/DataInputStream;)Ljava/lang/String;",
                                    "method_body": "private String readString(final DataInputStream dataIn) throws IOException {\nfinal ByteArrayOutputStream buffer = new ByteArrayOutputStream();\nint nextByte;\nwhile ((nextByte = dataIn.readUnsignedByte()) != 0) {\nbuffer.write(nextByte);\n}\nif (charsetName != null) {\nreturn new String(buffer.toByteArray(), charsetName);\n} else {\n// intentionally using the default encoding as that's the contract for a null charsetName\nreturn new String(buffer.toByteArray());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:readFully(Ljava/io/DataInputStream;[B)V",
                                    "method_body": "private void readFully(final DataInputStream dataIn, byte[] b)\nthrows IOException {\ndataIn.readFully(b);\ncount(b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:readHeader()[B",
                                    "method_body": "private byte[] readHeader() throws IOException {\nboolean found = false;\nbyte[] basicHeaderBytes = null;\ndo {\nint first = 0;\nint second = read8(in);\ndo {\nfirst = second;\nsecond = read8(in);\n} while (first != ARJ_MAGIC_1 && second != ARJ_MAGIC_2);\nfinal int basicHeaderSize = read16(in);\nif (basicHeaderSize == 0) {\n// end of archive\nreturn null;\n}\nif (basicHeaderSize <= 2600) {\nbasicHeaderBytes = new byte[basicHeaderSize];\nreadFully(in, basicHeaderBytes);\nfinal long basicHeaderCrc32 = read32(in) & 0xFFFFFFFFL;\nfinal CRC32 crc32 = new CRC32();\ncrc32.update(basicHeaderBytes);\nif (basicHeaderCrc32 == crc32.getValue()) {\nfound = true;\n}\n}\n} while (!found);\nreturn basicHeaderBytes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:readMainHeader()Lorg/apache/commons/compress/archivers/arj/MainHeader;",
                                    "method_body": "private MainHeader readMainHeader() throws IOException {\nfinal byte[] basicHeaderBytes = readHeader();\nif (basicHeaderBytes == null) {\nthrow new IOException(\"Archive ends without any headers\");\n}\nfinal DataInputStream basicHeader = new DataInputStream(\nnew ByteArrayInputStream(basicHeaderBytes));\n\nfinal int firstHeaderSize = basicHeader.readUnsignedByte();\nfinal byte[] firstHeaderBytes = new byte[firstHeaderSize - 1];\nbasicHeader.readFully(firstHeaderBytes);\nfinal DataInputStream firstHeader = new DataInputStream(\nnew ByteArrayInputStream(firstHeaderBytes));\n\nfinal MainHeader hdr = new MainHeader();\nhdr.archiverVersionNumber = firstHeader.readUnsignedByte();\nhdr.minVersionToExtract = firstHeader.readUnsignedByte();\nhdr.hostOS = firstHeader.readUnsignedByte();\nhdr.arjFlags = firstHeader.readUnsignedByte();\nhdr.securityVersion = firstHeader.readUnsignedByte();\nhdr.fileType = firstHeader.readUnsignedByte();\nhdr.reserved = firstHeader.readUnsignedByte();\nhdr.dateTimeCreated = read32(firstHeader);\nhdr.dateTimeModified = read32(firstHeader);\nhdr.archiveSize = 0xffffFFFFL & read32(firstHeader);\nhdr.securityEnvelopeFilePosition = read32(firstHeader);\nhdr.fileSpecPosition = read16(firstHeader);\nhdr.securityEnvelopeLength = read16(firstHeader);\npushedBackBytes(20); // count has already counted them via readFully\nhdr.encryptionVersion = firstHeader.readUnsignedByte();\nhdr.lastChapter = firstHeader.readUnsignedByte();\n\nif (firstHeaderSize >= 33) {\nhdr.arjProtectionFactor = firstHeader.readUnsignedByte();\nhdr.arjFlags2 = firstHeader.readUnsignedByte();\nfirstHeader.readUnsignedByte();\nfirstHeader.readUnsignedByte();\n}\n\nhdr.name = readString(basicHeader);\nhdr.comment = readString(basicHeader);\n\nfinal  int extendedHeaderSize = read16(in);\nif (extendedHeaderSize > 0) {\nhdr.extendedHeaderBytes = new byte[extendedHeaderSize];\nreadFully(in, hdr.extendedHeaderBytes);\nfinal long extendedHeaderCrc32 = 0xffffFFFFL & read32(in);\nfinal CRC32 crc32 = new CRC32();\ncrc32.update(hdr.extendedHeaderBytes);\nif (extendedHeaderCrc32 != crc32.getValue()) {\nthrow new IOException(\"Extended header CRC32 verification failure\");\n}\n}\n\nreturn hdr;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public DumpArchiveInputStream(InputStream is) throws ArchiveException {\nthis(is, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public DumpArchiveInputStream(InputStream is, String encoding)\nthrows ArchiveException {\nthis.raw = new TapeInputStream(is);\nthis.hasHitEOF = false;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n\ntry {\n// read header, verify it's a dump archive.\nbyte[] headerBytes = raw.readRecord();\n\nif (!DumpArchiveUtil.verify(headerBytes)) {\nthrow new UnrecognizedFormatException();\n}\n\n// get summary information\nsummary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n\n// reset buffer with actual block size.\nraw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n\n// allocate our read buffer.\nblockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n\n// skip past CLRI and BITS segments since we don't handle them yet.\nreadCLRI();\nreadBITS();\n} catch (IOException ex) {\nthrow new ArchiveException(ex.getMessage(), ex);\n}\n\n// put in a dummy record for the root node.\nDirent root = new Dirent(2, 2, 4, \".\");\nnames.put(2, root);\n\n// use priority based on queue to ensure parent directories are\n// released first.\nqueue = new PriorityQueue<DumpArchiveEntry>(10,\nnew Comparator<DumpArchiveEntry>() {\npublic int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\nif (p.getOriginalName() == null || q.getOriginalName() == null) {\nreturn Integer.MAX_VALUE;\n}\n\nreturn p.getOriginalName().compareTo(q.getOriginalName());\n}\n});\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:readCLRI()V",
                                    "method_body": "private void readCLRI() throws IOException {\nbyte[] buffer = raw.readRecord();\n\nif (!DumpArchiveUtil.verify(buffer)) {\nthrow new InvalidFormatException();\n}\n\nactive = DumpArchiveEntry.parse(buffer);\n\nif (DumpArchiveConstants.SEGMENT_TYPE.CLRI != active.getHeaderType()) {\nthrow new InvalidFormatException();\n}\n\n// we don't do anything with this yet.\nif (raw.skip(DumpArchiveConstants.TP_SIZE * active.getHeaderCount())\n== -1) {\nthrow new EOFException();\n}\nreadIdx = active.getHeaderCount();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:readBITS()V",
                                    "method_body": "private void readBITS() throws IOException {\nbyte[] buffer = raw.readRecord();\n\nif (!DumpArchiveUtil.verify(buffer)) {\nthrow new InvalidFormatException();\n}\n\nactive = DumpArchiveEntry.parse(buffer);\n\nif (DumpArchiveConstants.SEGMENT_TYPE.BITS != active.getHeaderType()) {\nthrow new InvalidFormatException();\n}\n\n// we don't do anything with this yet.\nif (raw.skip(DumpArchiveConstants.TP_SIZE * active.getHeaderCount())\n== -1) {\nthrow new EOFException();\n}\nreadIdx = active.getHeaderCount();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:calculateChecksum([B)I",
                                    "method_body": "public static int calculateChecksum(byte[] buffer) {\nint calc = 0;\n\nfor (int i = 0; i < 256; i++) {\ncalc += DumpArchiveUtil.convert32(buffer, 4 * i);\n}\n\nreturn DumpArchiveConstants.CHECKSUM -\n(calc - DumpArchiveUtil.convert32(buffer, 28));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:verify([B)Z",
                                    "method_body": "public static final boolean verify(byte[] buffer) {\n// verify magic. for now only accept NFS_MAGIC.\nint magic = convert32(buffer, 24);\n\nif (magic != DumpArchiveConstants.NFS_MAGIC) {\nreturn false;\n}\n\n//verify checksum...\nint checksum = convert32(buffer, 28);\n\nif (checksum != calculateChecksum(buffer)) {\nreturn false;\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert64([BI)J",
                                    "method_body": "public static final long convert64(byte[] buffer, int offset) {\nlong i = 0;\ni += (((long) buffer[offset + 7]) << 56);\ni += (((long) buffer[offset + 6] << 48) & 0x00FF000000000000L);\ni += (((long) buffer[offset + 5] << 40) & 0x0000FF0000000000L);\ni += (((long) buffer[offset + 4] << 32) & 0x000000FF00000000L);\ni += (((long) buffer[offset + 3] << 24) & 0x00000000FF000000L);\ni += (((long) buffer[offset + 2] << 16) & 0x0000000000FF0000L);\ni += (((long) buffer[offset + 1] << 8) & 0x000000000000FF00L);\ni += (buffer[offset] & 0x00000000000000FFL);\n\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert32([BI)I",
                                    "method_body": "public static final int convert32(byte[] buffer, int offset) {\nint i = 0;\ni = buffer[offset + 3] << 24;\ni += (buffer[offset + 2] << 16) & 0x00FF0000;\ni += (buffer[offset + 1] << 8) & 0x0000FF00;\ni += buffer[offset] & 0x000000FF;\n\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert16([BI)I",
                                    "method_body": "public static final int convert16(byte[] buffer, int offset) {\nint i = 0;\ni += (buffer[offset + 1] << 8) & 0x0000FF00;\ni += buffer[offset] & 0x000000FF;\n\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:decode(Lorg/apache/commons/compress/archivers/zip/ZipEncoding;[BII)Ljava/lang/String;",
                                    "method_body": "static String decode(ZipEncoding encoding, byte[] b, int offset, int len)\nthrows IOException {\nbyte[] copy = new byte[len];\nSystem.arraycopy(b, offset, copy, 0, len);\nreturn encoding.decode(copy);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TapeInputStream(InputStream in) {\nsuper(in);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:resetBlockSize(IZ)V",
                                    "method_body": "public void resetBlockSize(int recsPerBlock, boolean isCompressed)\nthrows IOException {\nthis.isCompressed = isCompressed;\n\nblockSize = recordSize * recsPerBlock;\n\n// save first block in case we need it again\nbyte[] oldBuffer = blockBuffer;\n\n// read rest of new block\nblockBuffer = new byte[blockSize];\nSystem.arraycopy(oldBuffer, 0, blockBuffer, 0, recordSize);\nreadFully(blockBuffer, recordSize, blockSize - recordSize);\n\nthis.currBlkIdx = 0;\nthis.readOffset = recordSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif ((len % recordSize) != 0) {\nthrow new IllegalArgumentException(\n\"all reads must be multiple of record size (\" + recordSize +\n\" bytes.\");\n}\n\nint bytes = 0;\n\nwhile (bytes < len) {\n// we need to read from the underlying stream.\n// this will reset readOffset value.\n// return -1 if there's a problem.\nif ((readOffset == blockSize) && !readBlock(true)) {\nreturn -1;\n}\n\nint n = 0;\n\nif ((readOffset + (len - bytes)) <= blockSize) {\n// we can read entirely from the buffer.\nn = len - bytes;\n} else {\n// copy what we can from the buffer.\nn = blockSize - readOffset;\n}\n\n// copy data, increment counters.\nSystem.arraycopy(blockBuffer, readOffset, b, off, n);\nreadOffset += n;\nbytes += n;\noff += n;\n}\n\nreturn bytes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:skip(J)J",
                                    "method_body": "public long skip(long len) throws IOException {\nif ((len % recordSize) != 0) {\nthrow new IllegalArgumentException(\n\"all reads must be multiple of record size (\" + recordSize +\n\" bytes.\");\n}\n\nlong bytes = 0;\n\nwhile (bytes < len) {\n// we need to read from the underlying stream.\n// this will reset readOffset value. We do not perform\n// any decompression if we won't eventually read the data.\n// return -1 if there's a problem.\nif ((readOffset == blockSize) &&\n!readBlock((len - bytes) < blockSize)) {\nreturn -1;\n}\n\nlong n = 0;\n\nif ((readOffset + (len - bytes)) <= blockSize) {\n// we can read entirely from the buffer.\nn = len - bytes;\n} else {\n// copy what we can from the buffer.\nn = blockSize - readOffset;\n}\n\n// do not copy data but still increment counters.\nreadOffset += n;\nbytes += n;\n}\n\nreturn bytes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:readRecord()[B",
                                    "method_body": "public byte[] readRecord() throws IOException {\nbyte[] result = new byte[recordSize];\n\n// the read implementation will loop internally as long as\n// input is available\nif (-1 == read(result, 0, result.length)) {\nthrow new ShortFileException();\n}\n\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:readBlock(Z)Z",
                                    "method_body": "private boolean readBlock(boolean decompress) throws IOException {\nboolean success = true;\n\nif (in == null) {\nthrow new IOException(\"input buffer is closed\");\n}\n\nif (!isCompressed || (currBlkIdx == -1)) {\n// file is not compressed\nsuccess = readFully(blockBuffer, 0, blockSize);\nbytesRead += blockSize;\n} else {\nif (!readFully(blockBuffer, 0, 4)) {\nreturn false;\n}\nbytesRead += 4;\n\nint h = DumpArchiveUtil.convert32(blockBuffer, 0);\nboolean compressed = (h & 0x01) == 0x01;\n\nif (!compressed) {\n// file is compressed but this block is not.\nsuccess = readFully(blockBuffer, 0, blockSize);\nbytesRead += blockSize;\n} else {\n// this block is compressed.\nint flags = (h >> 1) & 0x07;\nint length = (h >> 4) & 0x0FFFFFFF;\nbyte[] compBuffer = new byte[length];\nsuccess = readFully(compBuffer, 0, length);\nbytesRead += length;\n\nif (!decompress) {\n// just in case someone reads the data.\nArrays.fill(blockBuffer, (byte) 0);\n} else {\nswitch (DumpArchiveConstants.COMPRESSION_TYPE.find(flags &\n0x03)) {\ncase ZLIB:\n\ntry {\nInflater inflator = new Inflater();\ninflator.setInput(compBuffer, 0, compBuffer.length);\nlength = inflator.inflate(blockBuffer);\n\nif (length != blockSize) {\nthrow new ShortFileException();\n}\n\ninflator.end();\n} catch (DataFormatException e) {\nthrow new DumpArchiveException(\"bad data\", e);\n}\n\nbreak;\n\ncase BZLIB:\nthrow new UnsupportedCompressionAlgorithmException(\n\"BZLIB2\");\n\ncase LZO:\nthrow new UnsupportedCompressionAlgorithmException(\n\"LZO\");\n\ndefault:\nthrow new UnsupportedCompressionAlgorithmException();\n}\n}\n}\n}\n\ncurrBlkIdx++;\nreadOffset = 0;\n\nreturn success;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:readFully([BII)Z",
                                    "method_body": "private boolean readFully(byte[] b, int off, int len)\nthrows IOException {\nint count = IOUtils.readFully(in, b, off, len);\nif (count < len) {\nthrow new ShortFileException();\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveSummary:<init>([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "DumpArchiveSummary(byte[] buffer, ZipEncoding encoding) throws IOException {\ndumpDate = 1000L * DumpArchiveUtil.convert32(buffer, 4);\npreviousDumpDate = 1000L * DumpArchiveUtil.convert32(buffer, 8);\nvolume = DumpArchiveUtil.convert32(buffer, 12);\nlabel = DumpArchiveUtil.decode(encoding, buffer, 676, DumpArchiveConstants.LBLSIZE).trim();\nlevel = DumpArchiveUtil.convert32(buffer, 692);\nfilesys = DumpArchiveUtil.decode(encoding, buffer, 696, DumpArchiveConstants.NAMELEN).trim();\ndevname = DumpArchiveUtil.decode(encoding, buffer, 760, DumpArchiveConstants.NAMELEN).trim();\nhostname = DumpArchiveUtil.decode(encoding, buffer, 824, DumpArchiveConstants.NAMELEN).trim();\nflags = DumpArchiveUtil.convert32(buffer, 888);\nfirstrec = DumpArchiveUtil.convert32(buffer, 892);\nntrec = DumpArchiveUtil.convert32(buffer, 896);\n\n//extAttributes = DumpArchiveUtil.convert32(buffer, 900);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveSummary:getNTRec()I",
                                    "method_body": "public int getNTRec() {\nreturn ntrec;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveSummary:isCompressed()Z",
                                    "method_body": "public boolean isCompressed() {\nreturn (flags & 0x0080) == 0x0080;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:<init>()V",
                                    "method_body": "public DumpArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:getHeaderType()Lorg/apache/commons/compress/archivers/dump/DumpArchiveConstants$SEGMENT_TYPE;",
                                    "method_body": "public DumpArchiveConstants.SEGMENT_TYPE getHeaderType() {\nreturn header.getType();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:getHeaderCount()I",
                                    "method_body": "public int getHeaderCount() {\nreturn header.getCount();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:parse([B)Lorg/apache/commons/compress/archivers/dump/DumpArchiveEntry;",
                                    "method_body": "static DumpArchiveEntry parse(byte[] buffer) {\nDumpArchiveEntry entry = new DumpArchiveEntry();\nTapeSegmentHeader header = entry.header;\n\nheader.type = DumpArchiveConstants.SEGMENT_TYPE.find(DumpArchiveUtil.convert32(\nbuffer, 0));\n\n//header.dumpDate = new Date(1000L * DumpArchiveUtil.convert32(buffer, 4));\n//header.previousDumpDate = new Date(1000L * DumpArchiveUtil.convert32(\n//            buffer, 8));\nheader.volume = DumpArchiveUtil.convert32(buffer, 12);\n//header.tapea = DumpArchiveUtil.convert32(buffer, 16);\nentry.ino = header.ino = DumpArchiveUtil.convert32(buffer, 20);\n\n//header.magic = DumpArchiveUtil.convert32(buffer, 24);\n//header.checksum = DumpArchiveUtil.convert32(buffer, 28);\nint m = DumpArchiveUtil.convert16(buffer, 32);\n\n// determine the type of the file.\nentry.setType(TYPE.find((m >> 12) & 0x0F));\n\n// determine the standard permissions\nentry.setMode(m);\n\nentry.nlink = DumpArchiveUtil.convert16(buffer, 34);\n// inumber, oldids?\nentry.setSize(DumpArchiveUtil.convert64(buffer, 40));\n\nlong t = (1000L * DumpArchiveUtil.convert32(buffer, 48)) +\n(DumpArchiveUtil.convert32(buffer, 52) / 1000);\nentry.setAccessTime(new Date(t));\nt = (1000L * DumpArchiveUtil.convert32(buffer, 56)) +\n(DumpArchiveUtil.convert32(buffer, 60) / 1000);\nentry.setLastModifiedDate(new Date(t));\nt = (1000L * DumpArchiveUtil.convert32(buffer, 64)) +\n(DumpArchiveUtil.convert32(buffer, 68) / 1000);\nentry.ctime = t;\n\n// db: 72-119 - direct blocks\n// id: 120-131 - indirect blocks\n//entry.flags = DumpArchiveUtil.convert32(buffer, 132);\n//entry.blocks = DumpArchiveUtil.convert32(buffer, 136);\nentry.generation = DumpArchiveUtil.convert32(buffer, 140);\nentry.setUserId(DumpArchiveUtil.convert32(buffer, 144));\nentry.setGroupId(DumpArchiveUtil.convert32(buffer, 148));\n// two 32-bit spare values.\nheader.count = DumpArchiveUtil.convert32(buffer, 160);\n\nheader.holes = 0;\n\nfor (int i = 0; (i < 512) && (i < header.count); i++) {\nif (buffer[164 + i] == 0) {\nheader.holes++;\n}\n}\n\nSystem.arraycopy(buffer, 164, header.cdata, 0, 512);\n\nentry.volume = header.getVolume();\n\n//entry.isSummaryOnly = false;\nreturn entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setType(Lorg/apache/commons/compress/archivers/dump/DumpArchiveEntry$TYPE;)V",
                                    "method_body": "public void setType(TYPE type) {\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setMode(I)V",
                                    "method_body": "public void setMode(int mode) {\nthis.mode = mode & 07777;\nthis.permissions = PERMISSION.find(mode);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setLastModifiedDate(Ljava/util/Date;)V",
                                    "method_body": "public void setLastModifiedDate(Date mtime) {\nthis.mtime = mtime.getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setAccessTime(Ljava/util/Date;)V",
                                    "method_body": "public void setAccessTime(Date atime) {\nthis.atime = atime.getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setUserId(I)V",
                                    "method_body": "public void setUserId(int uid) {\nthis.uid = uid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setGroupId(I)V",
                                    "method_body": "public void setGroupId(int gid) {\nthis.gid = gid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TYPE:<init>(Ljava/lang/String;II)V",
                                    "method_body": "private TYPE(int code) {\nthis.code = code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TYPE:find(I)Lorg/apache/commons/compress/archivers/dump/DumpArchiveEntry$TYPE;",
                                    "method_body": "public static TYPE find(int code) {\nTYPE type = UNKNOWN;\n\nfor (TYPE t : TYPE.values()) {\nif (code == t.code) {\ntype = t;\n}\n}\n\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TapeSegmentHeader:getType()Lorg/apache/commons/compress/archivers/dump/DumpArchiveConstants$SEGMENT_TYPE;",
                                    "method_body": "public DumpArchiveConstants.SEGMENT_TYPE getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TapeSegmentHeader:getVolume()I",
                                    "method_body": "public int getVolume() {\nreturn volume;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TapeSegmentHeader:getCount()I",
                                    "method_body": "public int getCount() {\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveConstants$SEGMENT_TYPE:<init>(Ljava/lang/String;II)V",
                                    "method_body": "private SEGMENT_TYPE(int code) {\nthis.code = code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveConstants$SEGMENT_TYPE:find(I)Lorg/apache/commons/compress/archivers/dump/DumpArchiveConstants$SEGMENT_TYPE;",
                                    "method_body": "public static SEGMENT_TYPE find(int code) {\nfor (SEGMENT_TYPE t : values()) {\nif (t.code == code) {\nreturn t;\n}\n}\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$PERMISSION:<init>(Ljava/lang/String;II)V",
                                    "method_body": "private PERMISSION(int code) {\nthis.code = code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$PERMISSION:find(I)Ljava/util/Set;",
                                    "method_body": "public static Set<PERMISSION> find(int code) {\nSet<PERMISSION> set = new HashSet<PERMISSION>();\n\nfor (PERMISSION p : PERMISSION.values()) {\nif ((code & p.code) == p.code) {\nset.add(p);\n}\n}\n\nif (set.isEmpty()) {\nreturn Collections.emptySet();\n}\n\nreturn EnumSet.copyOf(set);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.Dirent:<init>(IIILjava/lang/String;)V",
                                    "method_body": "Dirent(int ino, int parentIno, int type, String name) {\nthis.ino = ino;\nthis.parentIno = parentIno;\nthis.type = type;\nthis.name = name;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest.testEncodingOutputStream",
                            "test_body": "324: public void testEncodingOutputStream() throws Exception {\n325: int failed = 0;\n326: for(int i = 1; i <= TESTS.length; i++) {\n327: TestData test = TESTS[i-1];\n328: if (test.hasOutputStream) {\n329: ArchiveOutputStream ais = getOutputStreamFor(test.type, test.fac);\n330: final String field = getField(ais, test.fieldName);\n331: if (!eq(test.expectedEncoding, field)) {\n332: System.out.println(\"Failed test \" + i + \". expected: \" + test.expectedEncoding + \" actual: \" + field + \" type: \" + test.type);\n333: failed++;\n334: }\n335: }\n336: }\n337: if (failed > 0) {\n338: fail(\"Tests failed: \" + failed);\n339: }\n340: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>()V",
                                    "method_body": "public ArchiveStreamFactory() {\nthis(null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ArchiveStreamFactory(String encoding) {\nsuper();\nthis.encoding = encoding;\n// Also set the original field so can continue to use it.\nthis.entryEncoding = encoding;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:setEntryEncoding(Ljava/lang/String;)V",
                                    "method_body": "public void setEntryEncoding(String entryEncoding) {\n// Note: this does not detect new ArchiveStreamFactory(null) but that does not set the encoding anyway\nif (encoding != null) {\nthrow new IllegalStateException(\"Cannot overide encoding set by the constructor\");\n}\nthis.entryEncoding = entryEncoding;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\n//private static final int BYTE_BIT_SIZE = 8;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Data Descriptor signature.\n*\n* <p>Actually, PKWARE uses this as marker for split/spanned\n* archives and other archivers have started to use it as Data\n* Descriptor signature (as well).</p>\n* @since 1.1\n*/\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\n\n/**\n* Value stored in size and similar fields if ZIP64 extensions are\n* used.\n* @since 1.3\n*/\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\n\n/**\n* Marks ZIP archives that were supposed to be split or spanned\n* but only needed a single segment in then end (so are actually\n* neither split nor spanned).\n*\n* <p>This is the \"PK00\" prefix found in some archives.</p>\n* @since 1.5\n*/\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\nnew ZipLong(0X30304B50L);\n\n/**\n* Archive extra data record signature.\n* @since 1.5\n*/\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nputLong(value, result, 0);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:putLong(J[BI)V",
                                    "method_body": "public static void putLong(long value, byte[] buf, int offset) {\nbuf[offset++] = (byte) ((value & BYTE_MASK));\nbuf[offset++] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nbuf[offset++] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nbuf[offset] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n\nstatic {\nMap<String, SimpleEncodingHolder> se =\nnew HashMap<String, SimpleEncodingHolder>();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for UTF-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h = simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\n// check platform's default encoding\ncharsetName = System.getProperty(\"file.encoding\");\n}\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}\nfor (String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data);\n} else {\nreturn new String(data,this.charsetName);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\n\n/**\n* <p>\n* Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\n* (either order accepted on input, big-endian used on output)\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, big-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, little-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\n\n/**\n* <p>\n* Eight-bit Unicode Transformation Format.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:<init>(Ljava/nio/charset/Charset;)V",
                                    "method_body": "public NioZipEncoding(Charset charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final int SKIP_BUF_SIZE = 4096;\n\n// This buffer does not need to be synchronised because it is write only; the contents are ignored\n// Does not affect Immutability\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n\n/** Private constructor to prevent instantiation of this utility class. */\nprivate IOUtils(){\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b, int offset, int len)\nthrows IOException {\nif (len < 0 || offset < 0 || len + offset > b.length) {\nthrow new IndexOutOfBoundsException();\n}\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\nbreak;\n}\ncount += x;\n}\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:pushedBackBytes(J)V",
                                    "method_body": "protected void pushedBackBytes(long pushedBack) {\nbytesRead -= pushedBack;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public CpioArchiveInputStream(final InputStream in) {\nthis(in, BLOCK_SIZE, CharsetNames.US_ASCII);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:<init>(Ljava/io/InputStream;ILjava/lang/String;)V",
                                    "method_body": "public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\nthis.in = in;\nthis.blockSize = blockSize;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream) {\nthis(inputStream, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream, String encoding) {\nthis(inputStream, encoding, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields) {\nthis(inputStream, encoding, useUnicodeExtraFields, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;ZZ)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream,\nString encoding,\nboolean useUnicodeExtraFields,\nboolean allowStoredEntriesWithDataDescriptor) {\nzipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\nin = new PushbackInputStream(inputStream, buf.capacity());\nthis.allowStoredEntriesWithDataDescriptor =\nallowStoredEntriesWithDataDescriptor;\n// haven't read anything so far\nbuf.limit(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<clinit>()V",
                                    "method_body": "private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\nprivate static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\nprivate static final byte[] DD = ZipLong.DD_SIG.getBytes();\n\n/**\n* Checks whether the current buffer contains the signature of a\n* &quot;data descriptor&quot;, &quot;local file header&quot; or\n* &quot;central directory entry&quot;.\n*\n* <p>If it contains such a signature, reads the data descriptor\n* and positions the stream right after the data descriptor.</p>\n*/\nprivate boolean bufferContainsSignature(ByteArrayOutputStream bos, int offset, int lastRead, int expectedDDLen)\nthrows IOException {\n\nboolean done = false;\nint readTooMuch = 0;\nfor (int i = 0; !done && i < lastRead - 4; i++) {\nif (buf.array()[i] == LFH[0] && buf.array()[i + 1] == LFH[1]) {\nif ((buf.array()[i + 2] == LFH[2] && buf.array()[i + 3] == LFH[3])\n|| (buf.array()[i] == CFH[2] && buf.array()[i + 3] == CFH[3])) {\n// found a LFH or CFH:\nreadTooMuch = offset + lastRead - i - expectedDDLen;\ndone = true;\n}\nelse if (buf.array()[i + 2] == DD[2] && buf.array()[i + 3] == DD[3]) {\n// found DD:\nreadTooMuch = offset + lastRead - i;\ndone = true;\n}\nif (done) {\n// * push back bytes read in excess as well as the data\n//   descriptor\n// * copy the remaining bytes to cache\n// * read data descriptor\npushback(buf.array(), offset + lastRead - readTooMuch, readTooMuch);\nbos.write(buf.array(), 0, i);\nreadDataDescriptor();\n}\n}\n}\nreturn done;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public JarArchiveInputStream( final InputStream inputStream ) {\nsuper(inputStream);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is) {\nthis(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\nthis(is, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;IILjava/lang/String;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize,\nString encoding) {\nthis.is = is;\nthis.hasHitEOF = false;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.recordSize = recordSize;\nthis.blockSize = blockSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public ArjArchiveInputStream(final InputStream inputStream,\nfinal String charsetName) throws ArchiveException {\nin = new DataInputStream(inputStream);\nthis.charsetName = charsetName;\ntry {\nmainHeader = readMainHeader();\nif ((mainHeader.arjFlags & MainHeader.Flags.GARBLED) != 0) {\nthrow new ArchiveException(\"Encrypted ARJ files are unsupported\");\n}\nif ((mainHeader.arjFlags & MainHeader.Flags.VOLUME) != 0) {\nthrow new ArchiveException(\"Multi-volume ARJ files are unsupported\");\n}\n} catch (IOException ioException) {\nthrow new ArchiveException(ioException.getMessage(), ioException);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public ArjArchiveInputStream(final InputStream inputStream)\nthrows ArchiveException {\nthis(inputStream, \"CP437\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:read8(Ljava/io/DataInputStream;)I",
                                    "method_body": "private int read8(final DataInputStream dataIn) throws IOException {\nint value = dataIn.readUnsignedByte();\ncount(1);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:read16(Ljava/io/DataInputStream;)I",
                                    "method_body": "private int read16(final DataInputStream dataIn) throws IOException {\nfinal int value = dataIn.readUnsignedShort();\ncount(2);\nreturn Integer.reverseBytes(value) >>> 16;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:read32(Ljava/io/DataInputStream;)I",
                                    "method_body": "private int read32(final DataInputStream dataIn) throws IOException {\nfinal int value = dataIn.readInt();\ncount(4);\nreturn Integer.reverseBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:readString(Ljava/io/DataInputStream;)Ljava/lang/String;",
                                    "method_body": "private String readString(final DataInputStream dataIn) throws IOException {\nfinal ByteArrayOutputStream buffer = new ByteArrayOutputStream();\nint nextByte;\nwhile ((nextByte = dataIn.readUnsignedByte()) != 0) {\nbuffer.write(nextByte);\n}\nif (charsetName != null) {\nreturn new String(buffer.toByteArray(), charsetName);\n} else {\n// intentionally using the default encoding as that's the contract for a null charsetName\nreturn new String(buffer.toByteArray());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:readFully(Ljava/io/DataInputStream;[B)V",
                                    "method_body": "private void readFully(final DataInputStream dataIn, byte[] b)\nthrows IOException {\ndataIn.readFully(b);\ncount(b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:readHeader()[B",
                                    "method_body": "private byte[] readHeader() throws IOException {\nboolean found = false;\nbyte[] basicHeaderBytes = null;\ndo {\nint first = 0;\nint second = read8(in);\ndo {\nfirst = second;\nsecond = read8(in);\n} while (first != ARJ_MAGIC_1 && second != ARJ_MAGIC_2);\nfinal int basicHeaderSize = read16(in);\nif (basicHeaderSize == 0) {\n// end of archive\nreturn null;\n}\nif (basicHeaderSize <= 2600) {\nbasicHeaderBytes = new byte[basicHeaderSize];\nreadFully(in, basicHeaderBytes);\nfinal long basicHeaderCrc32 = read32(in) & 0xFFFFFFFFL;\nfinal CRC32 crc32 = new CRC32();\ncrc32.update(basicHeaderBytes);\nif (basicHeaderCrc32 == crc32.getValue()) {\nfound = true;\n}\n}\n} while (!found);\nreturn basicHeaderBytes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:readMainHeader()Lorg/apache/commons/compress/archivers/arj/MainHeader;",
                                    "method_body": "private MainHeader readMainHeader() throws IOException {\nfinal byte[] basicHeaderBytes = readHeader();\nif (basicHeaderBytes == null) {\nthrow new IOException(\"Archive ends without any headers\");\n}\nfinal DataInputStream basicHeader = new DataInputStream(\nnew ByteArrayInputStream(basicHeaderBytes));\n\nfinal int firstHeaderSize = basicHeader.readUnsignedByte();\nfinal byte[] firstHeaderBytes = new byte[firstHeaderSize - 1];\nbasicHeader.readFully(firstHeaderBytes);\nfinal DataInputStream firstHeader = new DataInputStream(\nnew ByteArrayInputStream(firstHeaderBytes));\n\nfinal MainHeader hdr = new MainHeader();\nhdr.archiverVersionNumber = firstHeader.readUnsignedByte();\nhdr.minVersionToExtract = firstHeader.readUnsignedByte();\nhdr.hostOS = firstHeader.readUnsignedByte();\nhdr.arjFlags = firstHeader.readUnsignedByte();\nhdr.securityVersion = firstHeader.readUnsignedByte();\nhdr.fileType = firstHeader.readUnsignedByte();\nhdr.reserved = firstHeader.readUnsignedByte();\nhdr.dateTimeCreated = read32(firstHeader);\nhdr.dateTimeModified = read32(firstHeader);\nhdr.archiveSize = 0xffffFFFFL & read32(firstHeader);\nhdr.securityEnvelopeFilePosition = read32(firstHeader);\nhdr.fileSpecPosition = read16(firstHeader);\nhdr.securityEnvelopeLength = read16(firstHeader);\npushedBackBytes(20); // count has already counted them via readFully\nhdr.encryptionVersion = firstHeader.readUnsignedByte();\nhdr.lastChapter = firstHeader.readUnsignedByte();\n\nif (firstHeaderSize >= 33) {\nhdr.arjProtectionFactor = firstHeader.readUnsignedByte();\nhdr.arjFlags2 = firstHeader.readUnsignedByte();\nfirstHeader.readUnsignedByte();\nfirstHeader.readUnsignedByte();\n}\n\nhdr.name = readString(basicHeader);\nhdr.comment = readString(basicHeader);\n\nfinal  int extendedHeaderSize = read16(in);\nif (extendedHeaderSize > 0) {\nhdr.extendedHeaderBytes = new byte[extendedHeaderSize];\nreadFully(in, hdr.extendedHeaderBytes);\nfinal long extendedHeaderCrc32 = 0xffffFFFFL & read32(in);\nfinal CRC32 crc32 = new CRC32();\ncrc32.update(hdr.extendedHeaderBytes);\nif (extendedHeaderCrc32 != crc32.getValue()) {\nthrow new IOException(\"Extended header CRC32 verification failure\");\n}\n}\n\nreturn hdr;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public DumpArchiveInputStream(InputStream is) throws ArchiveException {\nthis(is, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public DumpArchiveInputStream(InputStream is, String encoding)\nthrows ArchiveException {\nthis.raw = new TapeInputStream(is);\nthis.hasHitEOF = false;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n\ntry {\n// read header, verify it's a dump archive.\nbyte[] headerBytes = raw.readRecord();\n\nif (!DumpArchiveUtil.verify(headerBytes)) {\nthrow new UnrecognizedFormatException();\n}\n\n// get summary information\nsummary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n\n// reset buffer with actual block size.\nraw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n\n// allocate our read buffer.\nblockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n\n// skip past CLRI and BITS segments since we don't handle them yet.\nreadCLRI();\nreadBITS();\n} catch (IOException ex) {\nthrow new ArchiveException(ex.getMessage(), ex);\n}\n\n// put in a dummy record for the root node.\nDirent root = new Dirent(2, 2, 4, \".\");\nnames.put(2, root);\n\n// use priority based on queue to ensure parent directories are\n// released first.\nqueue = new PriorityQueue<DumpArchiveEntry>(10,\nnew Comparator<DumpArchiveEntry>() {\npublic int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\nif (p.getOriginalName() == null || q.getOriginalName() == null) {\nreturn Integer.MAX_VALUE;\n}\n\nreturn p.getOriginalName().compareTo(q.getOriginalName());\n}\n});\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:readCLRI()V",
                                    "method_body": "private void readCLRI() throws IOException {\nbyte[] buffer = raw.readRecord();\n\nif (!DumpArchiveUtil.verify(buffer)) {\nthrow new InvalidFormatException();\n}\n\nactive = DumpArchiveEntry.parse(buffer);\n\nif (DumpArchiveConstants.SEGMENT_TYPE.CLRI != active.getHeaderType()) {\nthrow new InvalidFormatException();\n}\n\n// we don't do anything with this yet.\nif (raw.skip(DumpArchiveConstants.TP_SIZE * active.getHeaderCount())\n== -1) {\nthrow new EOFException();\n}\nreadIdx = active.getHeaderCount();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:readBITS()V",
                                    "method_body": "private void readBITS() throws IOException {\nbyte[] buffer = raw.readRecord();\n\nif (!DumpArchiveUtil.verify(buffer)) {\nthrow new InvalidFormatException();\n}\n\nactive = DumpArchiveEntry.parse(buffer);\n\nif (DumpArchiveConstants.SEGMENT_TYPE.BITS != active.getHeaderType()) {\nthrow new InvalidFormatException();\n}\n\n// we don't do anything with this yet.\nif (raw.skip(DumpArchiveConstants.TP_SIZE * active.getHeaderCount())\n== -1) {\nthrow new EOFException();\n}\nreadIdx = active.getHeaderCount();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:calculateChecksum([B)I",
                                    "method_body": "public static int calculateChecksum(byte[] buffer) {\nint calc = 0;\n\nfor (int i = 0; i < 256; i++) {\ncalc += DumpArchiveUtil.convert32(buffer, 4 * i);\n}\n\nreturn DumpArchiveConstants.CHECKSUM -\n(calc - DumpArchiveUtil.convert32(buffer, 28));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:verify([B)Z",
                                    "method_body": "public static final boolean verify(byte[] buffer) {\n// verify magic. for now only accept NFS_MAGIC.\nint magic = convert32(buffer, 24);\n\nif (magic != DumpArchiveConstants.NFS_MAGIC) {\nreturn false;\n}\n\n//verify checksum...\nint checksum = convert32(buffer, 28);\n\nif (checksum != calculateChecksum(buffer)) {\nreturn false;\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert64([BI)J",
                                    "method_body": "public static final long convert64(byte[] buffer, int offset) {\nlong i = 0;\ni += (((long) buffer[offset + 7]) << 56);\ni += (((long) buffer[offset + 6] << 48) & 0x00FF000000000000L);\ni += (((long) buffer[offset + 5] << 40) & 0x0000FF0000000000L);\ni += (((long) buffer[offset + 4] << 32) & 0x000000FF00000000L);\ni += (((long) buffer[offset + 3] << 24) & 0x00000000FF000000L);\ni += (((long) buffer[offset + 2] << 16) & 0x0000000000FF0000L);\ni += (((long) buffer[offset + 1] << 8) & 0x000000000000FF00L);\ni += (buffer[offset] & 0x00000000000000FFL);\n\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert32([BI)I",
                                    "method_body": "public static final int convert32(byte[] buffer, int offset) {\nint i = 0;\ni = buffer[offset + 3] << 24;\ni += (buffer[offset + 2] << 16) & 0x00FF0000;\ni += (buffer[offset + 1] << 8) & 0x0000FF00;\ni += buffer[offset] & 0x000000FF;\n\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert16([BI)I",
                                    "method_body": "public static final int convert16(byte[] buffer, int offset) {\nint i = 0;\ni += (buffer[offset + 1] << 8) & 0x0000FF00;\ni += buffer[offset] & 0x000000FF;\n\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:decode(Lorg/apache/commons/compress/archivers/zip/ZipEncoding;[BII)Ljava/lang/String;",
                                    "method_body": "static String decode(ZipEncoding encoding, byte[] b, int offset, int len)\nthrows IOException {\nbyte[] copy = new byte[len];\nSystem.arraycopy(b, offset, copy, 0, len);\nreturn encoding.decode(copy);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TapeInputStream(InputStream in) {\nsuper(in);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:resetBlockSize(IZ)V",
                                    "method_body": "public void resetBlockSize(int recsPerBlock, boolean isCompressed)\nthrows IOException {\nthis.isCompressed = isCompressed;\n\nblockSize = recordSize * recsPerBlock;\n\n// save first block in case we need it again\nbyte[] oldBuffer = blockBuffer;\n\n// read rest of new block\nblockBuffer = new byte[blockSize];\nSystem.arraycopy(oldBuffer, 0, blockBuffer, 0, recordSize);\nreadFully(blockBuffer, recordSize, blockSize - recordSize);\n\nthis.currBlkIdx = 0;\nthis.readOffset = recordSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif ((len % recordSize) != 0) {\nthrow new IllegalArgumentException(\n\"all reads must be multiple of record size (\" + recordSize +\n\" bytes.\");\n}\n\nint bytes = 0;\n\nwhile (bytes < len) {\n// we need to read from the underlying stream.\n// this will reset readOffset value.\n// return -1 if there's a problem.\nif ((readOffset == blockSize) && !readBlock(true)) {\nreturn -1;\n}\n\nint n = 0;\n\nif ((readOffset + (len - bytes)) <= blockSize) {\n// we can read entirely from the buffer.\nn = len - bytes;\n} else {\n// copy what we can from the buffer.\nn = blockSize - readOffset;\n}\n\n// copy data, increment counters.\nSystem.arraycopy(blockBuffer, readOffset, b, off, n);\nreadOffset += n;\nbytes += n;\noff += n;\n}\n\nreturn bytes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:skip(J)J",
                                    "method_body": "public long skip(long len) throws IOException {\nif ((len % recordSize) != 0) {\nthrow new IllegalArgumentException(\n\"all reads must be multiple of record size (\" + recordSize +\n\" bytes.\");\n}\n\nlong bytes = 0;\n\nwhile (bytes < len) {\n// we need to read from the underlying stream.\n// this will reset readOffset value. We do not perform\n// any decompression if we won't eventually read the data.\n// return -1 if there's a problem.\nif ((readOffset == blockSize) &&\n!readBlock((len - bytes) < blockSize)) {\nreturn -1;\n}\n\nlong n = 0;\n\nif ((readOffset + (len - bytes)) <= blockSize) {\n// we can read entirely from the buffer.\nn = len - bytes;\n} else {\n// copy what we can from the buffer.\nn = blockSize - readOffset;\n}\n\n// do not copy data but still increment counters.\nreadOffset += n;\nbytes += n;\n}\n\nreturn bytes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:readRecord()[B",
                                    "method_body": "public byte[] readRecord() throws IOException {\nbyte[] result = new byte[recordSize];\n\n// the read implementation will loop internally as long as\n// input is available\nif (-1 == read(result, 0, result.length)) {\nthrow new ShortFileException();\n}\n\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:readBlock(Z)Z",
                                    "method_body": "private boolean readBlock(boolean decompress) throws IOException {\nboolean success = true;\n\nif (in == null) {\nthrow new IOException(\"input buffer is closed\");\n}\n\nif (!isCompressed || (currBlkIdx == -1)) {\n// file is not compressed\nsuccess = readFully(blockBuffer, 0, blockSize);\nbytesRead += blockSize;\n} else {\nif (!readFully(blockBuffer, 0, 4)) {\nreturn false;\n}\nbytesRead += 4;\n\nint h = DumpArchiveUtil.convert32(blockBuffer, 0);\nboolean compressed = (h & 0x01) == 0x01;\n\nif (!compressed) {\n// file is compressed but this block is not.\nsuccess = readFully(blockBuffer, 0, blockSize);\nbytesRead += blockSize;\n} else {\n// this block is compressed.\nint flags = (h >> 1) & 0x07;\nint length = (h >> 4) & 0x0FFFFFFF;\nbyte[] compBuffer = new byte[length];\nsuccess = readFully(compBuffer, 0, length);\nbytesRead += length;\n\nif (!decompress) {\n// just in case someone reads the data.\nArrays.fill(blockBuffer, (byte) 0);\n} else {\nswitch (DumpArchiveConstants.COMPRESSION_TYPE.find(flags &\n0x03)) {\ncase ZLIB:\n\ntry {\nInflater inflator = new Inflater();\ninflator.setInput(compBuffer, 0, compBuffer.length);\nlength = inflator.inflate(blockBuffer);\n\nif (length != blockSize) {\nthrow new ShortFileException();\n}\n\ninflator.end();\n} catch (DataFormatException e) {\nthrow new DumpArchiveException(\"bad data\", e);\n}\n\nbreak;\n\ncase BZLIB:\nthrow new UnsupportedCompressionAlgorithmException(\n\"BZLIB2\");\n\ncase LZO:\nthrow new UnsupportedCompressionAlgorithmException(\n\"LZO\");\n\ndefault:\nthrow new UnsupportedCompressionAlgorithmException();\n}\n}\n}\n}\n\ncurrBlkIdx++;\nreadOffset = 0;\n\nreturn success;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:readFully([BII)Z",
                                    "method_body": "private boolean readFully(byte[] b, int off, int len)\nthrows IOException {\nint count = IOUtils.readFully(in, b, off, len);\nif (count < len) {\nthrow new ShortFileException();\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveSummary:<init>([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "DumpArchiveSummary(byte[] buffer, ZipEncoding encoding) throws IOException {\ndumpDate = 1000L * DumpArchiveUtil.convert32(buffer, 4);\npreviousDumpDate = 1000L * DumpArchiveUtil.convert32(buffer, 8);\nvolume = DumpArchiveUtil.convert32(buffer, 12);\nlabel = DumpArchiveUtil.decode(encoding, buffer, 676, DumpArchiveConstants.LBLSIZE).trim();\nlevel = DumpArchiveUtil.convert32(buffer, 692);\nfilesys = DumpArchiveUtil.decode(encoding, buffer, 696, DumpArchiveConstants.NAMELEN).trim();\ndevname = DumpArchiveUtil.decode(encoding, buffer, 760, DumpArchiveConstants.NAMELEN).trim();\nhostname = DumpArchiveUtil.decode(encoding, buffer, 824, DumpArchiveConstants.NAMELEN).trim();\nflags = DumpArchiveUtil.convert32(buffer, 888);\nfirstrec = DumpArchiveUtil.convert32(buffer, 892);\nntrec = DumpArchiveUtil.convert32(buffer, 896);\n\n//extAttributes = DumpArchiveUtil.convert32(buffer, 900);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveSummary:getNTRec()I",
                                    "method_body": "public int getNTRec() {\nreturn ntrec;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveSummary:isCompressed()Z",
                                    "method_body": "public boolean isCompressed() {\nreturn (flags & 0x0080) == 0x0080;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:<init>()V",
                                    "method_body": "public DumpArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:getHeaderType()Lorg/apache/commons/compress/archivers/dump/DumpArchiveConstants$SEGMENT_TYPE;",
                                    "method_body": "public DumpArchiveConstants.SEGMENT_TYPE getHeaderType() {\nreturn header.getType();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:getHeaderCount()I",
                                    "method_body": "public int getHeaderCount() {\nreturn header.getCount();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:parse([B)Lorg/apache/commons/compress/archivers/dump/DumpArchiveEntry;",
                                    "method_body": "static DumpArchiveEntry parse(byte[] buffer) {\nDumpArchiveEntry entry = new DumpArchiveEntry();\nTapeSegmentHeader header = entry.header;\n\nheader.type = DumpArchiveConstants.SEGMENT_TYPE.find(DumpArchiveUtil.convert32(\nbuffer, 0));\n\n//header.dumpDate = new Date(1000L * DumpArchiveUtil.convert32(buffer, 4));\n//header.previousDumpDate = new Date(1000L * DumpArchiveUtil.convert32(\n//            buffer, 8));\nheader.volume = DumpArchiveUtil.convert32(buffer, 12);\n//header.tapea = DumpArchiveUtil.convert32(buffer, 16);\nentry.ino = header.ino = DumpArchiveUtil.convert32(buffer, 20);\n\n//header.magic = DumpArchiveUtil.convert32(buffer, 24);\n//header.checksum = DumpArchiveUtil.convert32(buffer, 28);\nint m = DumpArchiveUtil.convert16(buffer, 32);\n\n// determine the type of the file.\nentry.setType(TYPE.find((m >> 12) & 0x0F));\n\n// determine the standard permissions\nentry.setMode(m);\n\nentry.nlink = DumpArchiveUtil.convert16(buffer, 34);\n// inumber, oldids?\nentry.setSize(DumpArchiveUtil.convert64(buffer, 40));\n\nlong t = (1000L * DumpArchiveUtil.convert32(buffer, 48)) +\n(DumpArchiveUtil.convert32(buffer, 52) / 1000);\nentry.setAccessTime(new Date(t));\nt = (1000L * DumpArchiveUtil.convert32(buffer, 56)) +\n(DumpArchiveUtil.convert32(buffer, 60) / 1000);\nentry.setLastModifiedDate(new Date(t));\nt = (1000L * DumpArchiveUtil.convert32(buffer, 64)) +\n(DumpArchiveUtil.convert32(buffer, 68) / 1000);\nentry.ctime = t;\n\n// db: 72-119 - direct blocks\n// id: 120-131 - indirect blocks\n//entry.flags = DumpArchiveUtil.convert32(buffer, 132);\n//entry.blocks = DumpArchiveUtil.convert32(buffer, 136);\nentry.generation = DumpArchiveUtil.convert32(buffer, 140);\nentry.setUserId(DumpArchiveUtil.convert32(buffer, 144));\nentry.setGroupId(DumpArchiveUtil.convert32(buffer, 148));\n// two 32-bit spare values.\nheader.count = DumpArchiveUtil.convert32(buffer, 160);\n\nheader.holes = 0;\n\nfor (int i = 0; (i < 512) && (i < header.count); i++) {\nif (buffer[164 + i] == 0) {\nheader.holes++;\n}\n}\n\nSystem.arraycopy(buffer, 164, header.cdata, 0, 512);\n\nentry.volume = header.getVolume();\n\n//entry.isSummaryOnly = false;\nreturn entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setType(Lorg/apache/commons/compress/archivers/dump/DumpArchiveEntry$TYPE;)V",
                                    "method_body": "public void setType(TYPE type) {\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setMode(I)V",
                                    "method_body": "public void setMode(int mode) {\nthis.mode = mode & 07777;\nthis.permissions = PERMISSION.find(mode);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setLastModifiedDate(Ljava/util/Date;)V",
                                    "method_body": "public void setLastModifiedDate(Date mtime) {\nthis.mtime = mtime.getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setAccessTime(Ljava/util/Date;)V",
                                    "method_body": "public void setAccessTime(Date atime) {\nthis.atime = atime.getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setUserId(I)V",
                                    "method_body": "public void setUserId(int uid) {\nthis.uid = uid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setGroupId(I)V",
                                    "method_body": "public void setGroupId(int gid) {\nthis.gid = gid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TYPE:<init>(Ljava/lang/String;II)V",
                                    "method_body": "private TYPE(int code) {\nthis.code = code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TYPE:find(I)Lorg/apache/commons/compress/archivers/dump/DumpArchiveEntry$TYPE;",
                                    "method_body": "public static TYPE find(int code) {\nTYPE type = UNKNOWN;\n\nfor (TYPE t : TYPE.values()) {\nif (code == t.code) {\ntype = t;\n}\n}\n\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TapeSegmentHeader:getType()Lorg/apache/commons/compress/archivers/dump/DumpArchiveConstants$SEGMENT_TYPE;",
                                    "method_body": "public DumpArchiveConstants.SEGMENT_TYPE getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TapeSegmentHeader:getVolume()I",
                                    "method_body": "public int getVolume() {\nreturn volume;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TapeSegmentHeader:getCount()I",
                                    "method_body": "public int getCount() {\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveConstants$SEGMENT_TYPE:<init>(Ljava/lang/String;II)V",
                                    "method_body": "private SEGMENT_TYPE(int code) {\nthis.code = code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveConstants$SEGMENT_TYPE:find(I)Lorg/apache/commons/compress/archivers/dump/DumpArchiveConstants$SEGMENT_TYPE;",
                                    "method_body": "public static SEGMENT_TYPE find(int code) {\nfor (SEGMENT_TYPE t : values()) {\nif (t.code == code) {\nreturn t;\n}\n}\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$PERMISSION:<init>(Ljava/lang/String;II)V",
                                    "method_body": "private PERMISSION(int code) {\nthis.code = code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$PERMISSION:find(I)Ljava/util/Set;",
                                    "method_body": "public static Set<PERMISSION> find(int code) {\nSet<PERMISSION> set = new HashSet<PERMISSION>();\n\nfor (PERMISSION p : PERMISSION.values()) {\nif ((code & p.code) == p.code) {\nset.add(p);\n}\n}\n\nif (set.isEmpty()) {\nreturn Collections.emptySet();\n}\n\nreturn EnumSet.copyOf(set);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.Dirent:<init>(IIILjava/lang/String;)V",
                                    "method_body": "Dirent(int ino, int parentIno, int type, String name) {\nthis.ino = ino;\nthis.parentIno = parentIno;\nthis.type = type;\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "public static final int EFS_FLAG = GeneralPurposeBit.UFT8_NAMES_FLAG;\n\nprivate static final byte[] EMPTY = new byte[0];\n\n/**\n* Current entry.\n*/\nprivate CurrentEntry entry;\n\n/**\n* The file comment.\n*/\nprivate String comment = \"\";\n\n/**\n* Compression level for next entry.\n*/\nprivate int level = DEFAULT_COMPRESSION;\n\n/**\n* Has the compression level changed when compared to the last\n* entry?\n*/\nprivate boolean hasCompressionLevelChanged = false;\n\n/**\n* Default compression method for next entry.\n*/\nprivate int method = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* List of ZipArchiveEntries written so far.\n*/\nprivate final List<ZipArchiveEntry> entries =\nnew LinkedList<ZipArchiveEntry>();\n\nprivate final StreamCompressor streamCompressor;\n\n/**\n* Start of central directory.\n*/\nprivate long cdOffset = 0;\n\n/**\n* Length of central directory.\n*/\nprivate long cdLength = 0;\n\n/**\n* Helper, a 0 as ZipShort.\n*/\nprivate static final byte[] ZERO = {0, 0};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveOutputStream(Ljava/lang/String;Ljava/io/OutputStream;)Lorg/apache/commons/compress/archivers/ArchiveOutputStream;",
                                    "method_body": "public ArchiveOutputStream createArchiveOutputStream(\nfinal String archiverName, final OutputStream out)\nthrows ArchiveException {\nif (archiverName == null) {\nthrow new IllegalArgumentException(\"Archivername must not be null.\");\n}\nif (out == null) {\nthrow new IllegalArgumentException(\"OutputStream must not be null.\");\n}\n\nif (AR.equalsIgnoreCase(archiverName)) {\nreturn new ArArchiveOutputStream(out);\n}\nif (ZIP.equalsIgnoreCase(archiverName)) {\nZipArchiveOutputStream zip = new ZipArchiveOutputStream(out);\nif (entryEncoding != null) {\nzip.setEncoding(entryEncoding);\n}\nreturn zip;\n}\nif (TAR.equalsIgnoreCase(archiverName)) {\nif (entryEncoding != null) {\nreturn new TarArchiveOutputStream(out, entryEncoding);\n} else {\nreturn new TarArchiveOutputStream(out);\n}\n}\nif (JAR.equalsIgnoreCase(archiverName)) {\nreturn new JarArchiveOutputStream(out);\n}\nif (CPIO.equalsIgnoreCase(archiverName)) {\nif (entryEncoding != null) {\nreturn new CpioArchiveOutputStream(out, entryEncoding);\n} else {\nreturn new CpioArchiveOutputStream(out);\n}\n}\nif (SEVEN_Z.equalsIgnoreCase(archiverName)) {\nthrow new StreamingNotSupportedException(SEVEN_Z);\n}\nthrow new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public ZipArchiveOutputStream(OutputStream out) {\nthis.out = out;\nthis.raf = null;\ndef = new Deflater(level, true);\nstreamCompressor = StreamCompressor.create(out, def);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setEncoding(Ljava/lang/String;)V",
                                    "method_body": "public void setEncoding(final String encoding) {\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nif (useUTF8Flag && !ZipEncodingHelper.isUTF8(encoding)) {\nuseUTF8Flag = false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public JarArchiveOutputStream(final OutputStream out) {\nsuper(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<init>(Ljava/lang/String;)V",
                                    "method_body": "private UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
                                    "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS = new UnicodeExtraFieldPolicy(\"always\");\n/**\n* Never create Unicode extra fields.\n*/\npublic static final UnicodeExtraFieldPolicy NEVER = new UnicodeExtraFieldPolicy(\"never\");\n/**\n* Create Unicode extra fields for filenames that cannot be\n* encoded using the specified encoding.\n*/\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nnew UnicodeExtraFieldPolicy(\"not encodeable\");\n\nprivate final String name;\nprivate UnicodeExtraFieldPolicy(String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:<init>(Ljava/util/zip/Deflater;)V",
                                    "method_body": "StreamCompressor(Deflater deflater) {\nthis.def = deflater;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:create(Ljava/io/OutputStream;Ljava/util/zip/Deflater;)Lorg/apache/commons/compress/archivers/zip/StreamCompressor;",
                                    "method_body": "static StreamCompressor create(OutputStream os, Deflater deflater) {\nreturn new OutputStreamCompressor(deflater, os);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor$OutputStreamCompressor:<init>(Ljava/util/zip/Deflater;Ljava/io/OutputStream;)V",
                                    "method_body": "public OutputStreamCompressor(Deflater deflater, OutputStream os) {\nsuper(deflater);\nthis.os = os;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public TarArchiveOutputStream(OutputStream os) {\nthis(os, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;Ljava/lang/String;)V",
                                    "method_body": "public TarArchiveOutputStream(OutputStream os, String encoding) {\nthis(os, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE, encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;II)V",
                                    "method_body": "public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) {\nthis(os, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;IILjava/lang/String;)V",
                                    "method_body": "public TarArchiveOutputStream(OutputStream os, int blockSize,\nint recordSize, String encoding) {\nout = new CountingOutputStream(os);\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n\nthis.assemLen = 0;\nthis.assemBuf = new byte[recordSize];\nthis.recordBuf = new byte[recordSize];\nthis.recordSize = recordSize;\nthis.recordsPerBlock = blockSize / recordSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<clinit>()V",
                                    "method_body": "public static final int LONGFILE_ERROR = 0;\n\n/** Long paths will be truncated in the archive. */\npublic static final int LONGFILE_TRUNCATE = 1;\n\n/** GNU tar extensions are used to store long file names in the archive. */\npublic static final int LONGFILE_GNU = 2;\n\n/** POSIX/PAX extensions are used to store long file names in the archive. */\npublic static final int LONGFILE_POSIX = 3;\n\n/** Fail if a big number (e.g. size &gt; 8GiB) is required in the archive. */\npublic static final int BIGNUMBER_ERROR = 0;\n\n/** star/GNU tar/BSD tar extensions are used to store big number in the archive. */\npublic static final int BIGNUMBER_STAR = 1;\n\n/** POSIX/PAX extensions are used to store big numbers in the archive. */\npublic static final int BIGNUMBER_POSIX = 2;\n\nprivate long      currSize;\nprivate String    currName;\nprivate long      currBytes;\nprivate final byte[]    recordBuf;\nprivate int       assemLen;\nprivate final byte[]    assemBuf;\nprivate int       longFileMode = LONGFILE_ERROR;\nprivate int       bigNumberMode = BIGNUMBER_ERROR;\nprivate int recordsWritten;\nprivate final int recordsPerBlock;\nprivate final int recordSize;\n\nprivate boolean closed = false;\n\n/** Indicates if putArchiveEntry has been called without closeArchiveEntry */\nprivate boolean haveUnclosedEntry = false;\n\n/** indicates if this archive is finished */\nprivate boolean finished = false;\n\nprivate final OutputStream out;\n\nprivate final ZipEncoding zipEncoding;\n\n// the provided encoding (for unit tests)\n\nprivate boolean addPaxHeadersForNonAsciiNames = false;\nprivate static final ZipEncoding ASCII =\nZipEncodingHelper.getZipEncoding(\"ASCII\");\n\n/**\n* Constructor for TarInputStream.\n* @param os the output stream to use\n*/\npublic TarArchiveOutputStream(OutputStream os) {\nthis(os, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public CountingOutputStream(final OutputStream out) {\nsuper(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:<init>(Ljava/io/OutputStream;S)V",
                                    "method_body": "public CpioArchiveOutputStream(final OutputStream out, final short format) {\nthis(out, format, BLOCK_SIZE, CharsetNames.US_ASCII);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:<init>(Ljava/io/OutputStream;SILjava/lang/String;)V",
                                    "method_body": "public CpioArchiveOutputStream(final OutputStream out, final short format,\nfinal int blockSize, final String encoding) {\nthis.out = out;\nswitch (format) {\ncase FORMAT_NEW:\ncase FORMAT_NEW_CRC:\ncase FORMAT_OLD_ASCII:\ncase FORMAT_OLD_BINARY:\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"Unknown format: \"+format);\n\n}\nthis.entryFormat = format;\nthis.blockSize = blockSize;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public CpioArchiveOutputStream(final OutputStream out) {\nthis(out, FORMAT_NEW);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream:<init>(Ljava/io/OutputStream;Ljava/lang/String;)V",
                                    "method_body": "public CpioArchiveOutputStream(final OutputStream out, String encoding) {\nthis(out, FORMAT_NEW, BLOCK_SIZE, encoding);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest.testEncodingInputStreamAutodetect",
                            "test_body": "290: public void testEncodingInputStreamAutodetect() throws Exception {\n291: int failed = 0;\n292: for(int i = 1; i <= TESTS.length; i++) {\n293: TestData test = TESTS[i-1];\n294: ArchiveInputStream ais = getInputStreamFor(test.testFile, test.fac);\n295: final String field = getField(ais,test.fieldName);\n296: if (!eq(test.expectedEncoding,field)) {\n297: System.out.println(\"Failed test \" + i + \". expected: \" + test.expectedEncoding + \" actual: \" + field + \" type: \" + test.type);\n298: failed++;\n299: }\n300: }\n301: if (failed > 0) {\n302: fail(\"Tests failed: \" + failed);\n303: }\n304: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>()V",
                                    "method_body": "public ArchiveStreamFactory() {\nthis(null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ArchiveStreamFactory(String encoding) {\nsuper();\nthis.encoding = encoding;\n// Also set the original field so can continue to use it.\nthis.entryEncoding = encoding;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:setEntryEncoding(Ljava/lang/String;)V",
                                    "method_body": "public void setEntryEncoding(String entryEncoding) {\n// Note: this does not detect new ArchiveStreamFactory(null) but that does not set the encoding anyway\nif (encoding != null) {\nthrow new IllegalStateException(\"Cannot overide encoding set by the constructor\");\n}\nthis.entryEncoding = entryEncoding;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\n//private static final int BYTE_BIT_SIZE = 8;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Data Descriptor signature.\n*\n* <p>Actually, PKWARE uses this as marker for split/spanned\n* archives and other archivers have started to use it as Data\n* Descriptor signature (as well).</p>\n* @since 1.1\n*/\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\n\n/**\n* Value stored in size and similar fields if ZIP64 extensions are\n* used.\n* @since 1.3\n*/\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\n\n/**\n* Marks ZIP archives that were supposed to be split or spanned\n* but only needed a single segment in then end (so are actually\n* neither split nor spanned).\n*\n* <p>This is the \"PK00\" prefix found in some archives.</p>\n* @since 1.5\n*/\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\nnew ZipLong(0X30304B50L);\n\n/**\n* Archive extra data record signature.\n* @since 1.5\n*/\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nputLong(value, result, 0);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:putLong(J[BI)V",
                                    "method_body": "public static void putLong(long value, byte[] buf, int offset) {\nbuf[offset++] = (byte) ((value & BYTE_MASK));\nbuf[offset++] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nbuf[offset++] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nbuf[offset] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n\nstatic {\nMap<String, SimpleEncodingHolder> se =\nnew HashMap<String, SimpleEncodingHolder>();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for UTF-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h = simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\n// check platform's default encoding\ncharsetName = System.getProperty(\"file.encoding\");\n}\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}\nfor (String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data);\n} else {\nreturn new String(data,this.charsetName);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\n\n/**\n* <p>\n* Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\n* (either order accepted on input, big-endian used on output)\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, big-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, little-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\n\n/**\n* <p>\n* Eight-bit Unicode Transformation Format.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:<init>(Ljava/nio/charset/Charset;)V",
                                    "method_body": "public NioZipEncoding(Charset charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nreturn this.charset.newDecoder()\n.onMalformedInput(CodingErrorAction.REPORT)\n.onUnmappableCharacter(CodingErrorAction.REPORT)\n.decode(ByteBuffer.wrap(data)).toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final int SKIP_BUF_SIZE = 4096;\n\n// This buffer does not need to be synchronised because it is write only; the contents are ignored\n// Does not affect Immutability\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n\n/** Private constructor to prevent instantiation of this utility class. */\nprivate IOUtils(){\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b, int offset, int len)\nthrows IOException {\nif (len < 0 || offset < 0 || len + offset > b.length) {\nthrow new IndexOutOfBoundsException();\n}\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\nbreak;\n}\ncount += x;\n}\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:pushedBackBytes(J)V",
                                    "method_body": "protected void pushedBackBytes(long pushedBack) {\nbytesRead -= pushedBack;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public CpioArchiveInputStream(final InputStream in) {\nthis(in, BLOCK_SIZE, CharsetNames.US_ASCII);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public CpioArchiveInputStream(final InputStream in, String encoding) {\nthis(in, BLOCK_SIZE, encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:<init>(Ljava/io/InputStream;ILjava/lang/String;)V",
                                    "method_body": "public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\nthis.in = in;\nthis.blockSize = blockSize;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream) {\nthis(inputStream, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream, String encoding) {\nthis(inputStream, encoding, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields) {\nthis(inputStream, encoding, useUnicodeExtraFields, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;ZZ)V",
                                    "method_body": "public ZipArchiveInputStream(InputStream inputStream,\nString encoding,\nboolean useUnicodeExtraFields,\nboolean allowStoredEntriesWithDataDescriptor) {\nzipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\nin = new PushbackInputStream(inputStream, buf.capacity());\nthis.allowStoredEntriesWithDataDescriptor =\nallowStoredEntriesWithDataDescriptor;\n// haven't read anything so far\nbuf.limit(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<clinit>()V",
                                    "method_body": "private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\nprivate static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\nprivate static final byte[] DD = ZipLong.DD_SIG.getBytes();\n\n/**\n* Checks whether the current buffer contains the signature of a\n* &quot;data descriptor&quot;, &quot;local file header&quot; or\n* &quot;central directory entry&quot;.\n*\n* <p>If it contains such a signature, reads the data descriptor\n* and positions the stream right after the data descriptor.</p>\n*/\nprivate boolean bufferContainsSignature(ByteArrayOutputStream bos, int offset, int lastRead, int expectedDDLen)\nthrows IOException {\n\nboolean done = false;\nint readTooMuch = 0;\nfor (int i = 0; !done && i < lastRead - 4; i++) {\nif (buf.array()[i] == LFH[0] && buf.array()[i + 1] == LFH[1]) {\nif ((buf.array()[i + 2] == LFH[2] && buf.array()[i + 3] == LFH[3])\n|| (buf.array()[i] == CFH[2] && buf.array()[i + 3] == CFH[3])) {\n// found a LFH or CFH:\nreadTooMuch = offset + lastRead - i - expectedDDLen;\ndone = true;\n}\nelse if (buf.array()[i + 2] == DD[2] && buf.array()[i + 3] == DD[3]) {\n// found DD:\nreadTooMuch = offset + lastRead - i;\ndone = true;\n}\nif (done) {\n// * push back bytes read in excess as well as the data\n//   descriptor\n// * copy the remaining bytes to cache\n// * read data descriptor\npushback(buf.array(), offset + lastRead - readTooMuch, readTooMuch);\nbos.write(buf.array(), 0, i);\nreadDataDescriptor();\n}\n}\n}\nreturn done;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public JarArchiveInputStream( final InputStream inputStream ) {\nsuper(inputStream);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is) {\nthis(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, String encoding) {\nthis(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE,\nencoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\nthis(is, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;IILjava/lang/String;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize,\nString encoding) {\nthis.is = is;\nthis.hasHitEOF = false;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.recordSize = recordSize;\nthis.blockSize = blockSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public ArjArchiveInputStream(final InputStream inputStream,\nfinal String charsetName) throws ArchiveException {\nin = new DataInputStream(inputStream);\nthis.charsetName = charsetName;\ntry {\nmainHeader = readMainHeader();\nif ((mainHeader.arjFlags & MainHeader.Flags.GARBLED) != 0) {\nthrow new ArchiveException(\"Encrypted ARJ files are unsupported\");\n}\nif ((mainHeader.arjFlags & MainHeader.Flags.VOLUME) != 0) {\nthrow new ArchiveException(\"Multi-volume ARJ files are unsupported\");\n}\n} catch (IOException ioException) {\nthrow new ArchiveException(ioException.getMessage(), ioException);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public ArjArchiveInputStream(final InputStream inputStream)\nthrows ArchiveException {\nthis(inputStream, \"CP437\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:read8(Ljava/io/DataInputStream;)I",
                                    "method_body": "private int read8(final DataInputStream dataIn) throws IOException {\nint value = dataIn.readUnsignedByte();\ncount(1);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:read16(Ljava/io/DataInputStream;)I",
                                    "method_body": "private int read16(final DataInputStream dataIn) throws IOException {\nfinal int value = dataIn.readUnsignedShort();\ncount(2);\nreturn Integer.reverseBytes(value) >>> 16;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:read32(Ljava/io/DataInputStream;)I",
                                    "method_body": "private int read32(final DataInputStream dataIn) throws IOException {\nfinal int value = dataIn.readInt();\ncount(4);\nreturn Integer.reverseBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:readString(Ljava/io/DataInputStream;)Ljava/lang/String;",
                                    "method_body": "private String readString(final DataInputStream dataIn) throws IOException {\nfinal ByteArrayOutputStream buffer = new ByteArrayOutputStream();\nint nextByte;\nwhile ((nextByte = dataIn.readUnsignedByte()) != 0) {\nbuffer.write(nextByte);\n}\nif (charsetName != null) {\nreturn new String(buffer.toByteArray(), charsetName);\n} else {\n// intentionally using the default encoding as that's the contract for a null charsetName\nreturn new String(buffer.toByteArray());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:readFully(Ljava/io/DataInputStream;[B)V",
                                    "method_body": "private void readFully(final DataInputStream dataIn, byte[] b)\nthrows IOException {\ndataIn.readFully(b);\ncount(b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:readHeader()[B",
                                    "method_body": "private byte[] readHeader() throws IOException {\nboolean found = false;\nbyte[] basicHeaderBytes = null;\ndo {\nint first = 0;\nint second = read8(in);\ndo {\nfirst = second;\nsecond = read8(in);\n} while (first != ARJ_MAGIC_1 && second != ARJ_MAGIC_2);\nfinal int basicHeaderSize = read16(in);\nif (basicHeaderSize == 0) {\n// end of archive\nreturn null;\n}\nif (basicHeaderSize <= 2600) {\nbasicHeaderBytes = new byte[basicHeaderSize];\nreadFully(in, basicHeaderBytes);\nfinal long basicHeaderCrc32 = read32(in) & 0xFFFFFFFFL;\nfinal CRC32 crc32 = new CRC32();\ncrc32.update(basicHeaderBytes);\nif (basicHeaderCrc32 == crc32.getValue()) {\nfound = true;\n}\n}\n} while (!found);\nreturn basicHeaderBytes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:readMainHeader()Lorg/apache/commons/compress/archivers/arj/MainHeader;",
                                    "method_body": "private MainHeader readMainHeader() throws IOException {\nfinal byte[] basicHeaderBytes = readHeader();\nif (basicHeaderBytes == null) {\nthrow new IOException(\"Archive ends without any headers\");\n}\nfinal DataInputStream basicHeader = new DataInputStream(\nnew ByteArrayInputStream(basicHeaderBytes));\n\nfinal int firstHeaderSize = basicHeader.readUnsignedByte();\nfinal byte[] firstHeaderBytes = new byte[firstHeaderSize - 1];\nbasicHeader.readFully(firstHeaderBytes);\nfinal DataInputStream firstHeader = new DataInputStream(\nnew ByteArrayInputStream(firstHeaderBytes));\n\nfinal MainHeader hdr = new MainHeader();\nhdr.archiverVersionNumber = firstHeader.readUnsignedByte();\nhdr.minVersionToExtract = firstHeader.readUnsignedByte();\nhdr.hostOS = firstHeader.readUnsignedByte();\nhdr.arjFlags = firstHeader.readUnsignedByte();\nhdr.securityVersion = firstHeader.readUnsignedByte();\nhdr.fileType = firstHeader.readUnsignedByte();\nhdr.reserved = firstHeader.readUnsignedByte();\nhdr.dateTimeCreated = read32(firstHeader);\nhdr.dateTimeModified = read32(firstHeader);\nhdr.archiveSize = 0xffffFFFFL & read32(firstHeader);\nhdr.securityEnvelopeFilePosition = read32(firstHeader);\nhdr.fileSpecPosition = read16(firstHeader);\nhdr.securityEnvelopeLength = read16(firstHeader);\npushedBackBytes(20); // count has already counted them via readFully\nhdr.encryptionVersion = firstHeader.readUnsignedByte();\nhdr.lastChapter = firstHeader.readUnsignedByte();\n\nif (firstHeaderSize >= 33) {\nhdr.arjProtectionFactor = firstHeader.readUnsignedByte();\nhdr.arjFlags2 = firstHeader.readUnsignedByte();\nfirstHeader.readUnsignedByte();\nfirstHeader.readUnsignedByte();\n}\n\nhdr.name = readString(basicHeader);\nhdr.comment = readString(basicHeader);\n\nfinal  int extendedHeaderSize = read16(in);\nif (extendedHeaderSize > 0) {\nhdr.extendedHeaderBytes = new byte[extendedHeaderSize];\nreadFully(in, hdr.extendedHeaderBytes);\nfinal long extendedHeaderCrc32 = 0xffffFFFFL & read32(in);\nfinal CRC32 crc32 = new CRC32();\ncrc32.update(hdr.extendedHeaderBytes);\nif (extendedHeaderCrc32 != crc32.getValue()) {\nthrow new IOException(\"Extended header CRC32 verification failure\");\n}\n}\n\nreturn hdr;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public DumpArchiveInputStream(InputStream is) throws ArchiveException {\nthis(is, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public DumpArchiveInputStream(InputStream is, String encoding)\nthrows ArchiveException {\nthis.raw = new TapeInputStream(is);\nthis.hasHitEOF = false;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n\ntry {\n// read header, verify it's a dump archive.\nbyte[] headerBytes = raw.readRecord();\n\nif (!DumpArchiveUtil.verify(headerBytes)) {\nthrow new UnrecognizedFormatException();\n}\n\n// get summary information\nsummary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n\n// reset buffer with actual block size.\nraw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n\n// allocate our read buffer.\nblockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n\n// skip past CLRI and BITS segments since we don't handle them yet.\nreadCLRI();\nreadBITS();\n} catch (IOException ex) {\nthrow new ArchiveException(ex.getMessage(), ex);\n}\n\n// put in a dummy record for the root node.\nDirent root = new Dirent(2, 2, 4, \".\");\nnames.put(2, root);\n\n// use priority based on queue to ensure parent directories are\n// released first.\nqueue = new PriorityQueue<DumpArchiveEntry>(10,\nnew Comparator<DumpArchiveEntry>() {\npublic int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\nif (p.getOriginalName() == null || q.getOriginalName() == null) {\nreturn Integer.MAX_VALUE;\n}\n\nreturn p.getOriginalName().compareTo(q.getOriginalName());\n}\n});\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:readCLRI()V",
                                    "method_body": "private void readCLRI() throws IOException {\nbyte[] buffer = raw.readRecord();\n\nif (!DumpArchiveUtil.verify(buffer)) {\nthrow new InvalidFormatException();\n}\n\nactive = DumpArchiveEntry.parse(buffer);\n\nif (DumpArchiveConstants.SEGMENT_TYPE.CLRI != active.getHeaderType()) {\nthrow new InvalidFormatException();\n}\n\n// we don't do anything with this yet.\nif (raw.skip(DumpArchiveConstants.TP_SIZE * active.getHeaderCount())\n== -1) {\nthrow new EOFException();\n}\nreadIdx = active.getHeaderCount();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:readBITS()V",
                                    "method_body": "private void readBITS() throws IOException {\nbyte[] buffer = raw.readRecord();\n\nif (!DumpArchiveUtil.verify(buffer)) {\nthrow new InvalidFormatException();\n}\n\nactive = DumpArchiveEntry.parse(buffer);\n\nif (DumpArchiveConstants.SEGMENT_TYPE.BITS != active.getHeaderType()) {\nthrow new InvalidFormatException();\n}\n\n// we don't do anything with this yet.\nif (raw.skip(DumpArchiveConstants.TP_SIZE * active.getHeaderCount())\n== -1) {\nthrow new EOFException();\n}\nreadIdx = active.getHeaderCount();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:calculateChecksum([B)I",
                                    "method_body": "public static int calculateChecksum(byte[] buffer) {\nint calc = 0;\n\nfor (int i = 0; i < 256; i++) {\ncalc += DumpArchiveUtil.convert32(buffer, 4 * i);\n}\n\nreturn DumpArchiveConstants.CHECKSUM -\n(calc - DumpArchiveUtil.convert32(buffer, 28));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:verify([B)Z",
                                    "method_body": "public static final boolean verify(byte[] buffer) {\n// verify magic. for now only accept NFS_MAGIC.\nint magic = convert32(buffer, 24);\n\nif (magic != DumpArchiveConstants.NFS_MAGIC) {\nreturn false;\n}\n\n//verify checksum...\nint checksum = convert32(buffer, 28);\n\nif (checksum != calculateChecksum(buffer)) {\nreturn false;\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert64([BI)J",
                                    "method_body": "public static final long convert64(byte[] buffer, int offset) {\nlong i = 0;\ni += (((long) buffer[offset + 7]) << 56);\ni += (((long) buffer[offset + 6] << 48) & 0x00FF000000000000L);\ni += (((long) buffer[offset + 5] << 40) & 0x0000FF0000000000L);\ni += (((long) buffer[offset + 4] << 32) & 0x000000FF00000000L);\ni += (((long) buffer[offset + 3] << 24) & 0x00000000FF000000L);\ni += (((long) buffer[offset + 2] << 16) & 0x0000000000FF0000L);\ni += (((long) buffer[offset + 1] << 8) & 0x000000000000FF00L);\ni += (buffer[offset] & 0x00000000000000FFL);\n\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert32([BI)I",
                                    "method_body": "public static final int convert32(byte[] buffer, int offset) {\nint i = 0;\ni = buffer[offset + 3] << 24;\ni += (buffer[offset + 2] << 16) & 0x00FF0000;\ni += (buffer[offset + 1] << 8) & 0x0000FF00;\ni += buffer[offset] & 0x000000FF;\n\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert16([BI)I",
                                    "method_body": "public static final int convert16(byte[] buffer, int offset) {\nint i = 0;\ni += (buffer[offset + 1] << 8) & 0x0000FF00;\ni += buffer[offset] & 0x000000FF;\n\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:decode(Lorg/apache/commons/compress/archivers/zip/ZipEncoding;[BII)Ljava/lang/String;",
                                    "method_body": "static String decode(ZipEncoding encoding, byte[] b, int offset, int len)\nthrows IOException {\nbyte[] copy = new byte[len];\nSystem.arraycopy(b, offset, copy, 0, len);\nreturn encoding.decode(copy);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TapeInputStream(InputStream in) {\nsuper(in);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:resetBlockSize(IZ)V",
                                    "method_body": "public void resetBlockSize(int recsPerBlock, boolean isCompressed)\nthrows IOException {\nthis.isCompressed = isCompressed;\n\nblockSize = recordSize * recsPerBlock;\n\n// save first block in case we need it again\nbyte[] oldBuffer = blockBuffer;\n\n// read rest of new block\nblockBuffer = new byte[blockSize];\nSystem.arraycopy(oldBuffer, 0, blockBuffer, 0, recordSize);\nreadFully(blockBuffer, recordSize, blockSize - recordSize);\n\nthis.currBlkIdx = 0;\nthis.readOffset = recordSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif ((len % recordSize) != 0) {\nthrow new IllegalArgumentException(\n\"all reads must be multiple of record size (\" + recordSize +\n\" bytes.\");\n}\n\nint bytes = 0;\n\nwhile (bytes < len) {\n// we need to read from the underlying stream.\n// this will reset readOffset value.\n// return -1 if there's a problem.\nif ((readOffset == blockSize) && !readBlock(true)) {\nreturn -1;\n}\n\nint n = 0;\n\nif ((readOffset + (len - bytes)) <= blockSize) {\n// we can read entirely from the buffer.\nn = len - bytes;\n} else {\n// copy what we can from the buffer.\nn = blockSize - readOffset;\n}\n\n// copy data, increment counters.\nSystem.arraycopy(blockBuffer, readOffset, b, off, n);\nreadOffset += n;\nbytes += n;\noff += n;\n}\n\nreturn bytes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:skip(J)J",
                                    "method_body": "public long skip(long len) throws IOException {\nif ((len % recordSize) != 0) {\nthrow new IllegalArgumentException(\n\"all reads must be multiple of record size (\" + recordSize +\n\" bytes.\");\n}\n\nlong bytes = 0;\n\nwhile (bytes < len) {\n// we need to read from the underlying stream.\n// this will reset readOffset value. We do not perform\n// any decompression if we won't eventually read the data.\n// return -1 if there's a problem.\nif ((readOffset == blockSize) &&\n!readBlock((len - bytes) < blockSize)) {\nreturn -1;\n}\n\nlong n = 0;\n\nif ((readOffset + (len - bytes)) <= blockSize) {\n// we can read entirely from the buffer.\nn = len - bytes;\n} else {\n// copy what we can from the buffer.\nn = blockSize - readOffset;\n}\n\n// do not copy data but still increment counters.\nreadOffset += n;\nbytes += n;\n}\n\nreturn bytes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:readRecord()[B",
                                    "method_body": "public byte[] readRecord() throws IOException {\nbyte[] result = new byte[recordSize];\n\n// the read implementation will loop internally as long as\n// input is available\nif (-1 == read(result, 0, result.length)) {\nthrow new ShortFileException();\n}\n\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:readBlock(Z)Z",
                                    "method_body": "private boolean readBlock(boolean decompress) throws IOException {\nboolean success = true;\n\nif (in == null) {\nthrow new IOException(\"input buffer is closed\");\n}\n\nif (!isCompressed || (currBlkIdx == -1)) {\n// file is not compressed\nsuccess = readFully(blockBuffer, 0, blockSize);\nbytesRead += blockSize;\n} else {\nif (!readFully(blockBuffer, 0, 4)) {\nreturn false;\n}\nbytesRead += 4;\n\nint h = DumpArchiveUtil.convert32(blockBuffer, 0);\nboolean compressed = (h & 0x01) == 0x01;\n\nif (!compressed) {\n// file is compressed but this block is not.\nsuccess = readFully(blockBuffer, 0, blockSize);\nbytesRead += blockSize;\n} else {\n// this block is compressed.\nint flags = (h >> 1) & 0x07;\nint length = (h >> 4) & 0x0FFFFFFF;\nbyte[] compBuffer = new byte[length];\nsuccess = readFully(compBuffer, 0, length);\nbytesRead += length;\n\nif (!decompress) {\n// just in case someone reads the data.\nArrays.fill(blockBuffer, (byte) 0);\n} else {\nswitch (DumpArchiveConstants.COMPRESSION_TYPE.find(flags &\n0x03)) {\ncase ZLIB:\n\ntry {\nInflater inflator = new Inflater();\ninflator.setInput(compBuffer, 0, compBuffer.length);\nlength = inflator.inflate(blockBuffer);\n\nif (length != blockSize) {\nthrow new ShortFileException();\n}\n\ninflator.end();\n} catch (DataFormatException e) {\nthrow new DumpArchiveException(\"bad data\", e);\n}\n\nbreak;\n\ncase BZLIB:\nthrow new UnsupportedCompressionAlgorithmException(\n\"BZLIB2\");\n\ncase LZO:\nthrow new UnsupportedCompressionAlgorithmException(\n\"LZO\");\n\ndefault:\nthrow new UnsupportedCompressionAlgorithmException();\n}\n}\n}\n}\n\ncurrBlkIdx++;\nreadOffset = 0;\n\nreturn success;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.TapeInputStream:readFully([BII)Z",
                                    "method_body": "private boolean readFully(byte[] b, int off, int len)\nthrows IOException {\nint count = IOUtils.readFully(in, b, off, len);\nif (count < len) {\nthrow new ShortFileException();\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveSummary:<init>([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "DumpArchiveSummary(byte[] buffer, ZipEncoding encoding) throws IOException {\ndumpDate = 1000L * DumpArchiveUtil.convert32(buffer, 4);\npreviousDumpDate = 1000L * DumpArchiveUtil.convert32(buffer, 8);\nvolume = DumpArchiveUtil.convert32(buffer, 12);\nlabel = DumpArchiveUtil.decode(encoding, buffer, 676, DumpArchiveConstants.LBLSIZE).trim();\nlevel = DumpArchiveUtil.convert32(buffer, 692);\nfilesys = DumpArchiveUtil.decode(encoding, buffer, 696, DumpArchiveConstants.NAMELEN).trim();\ndevname = DumpArchiveUtil.decode(encoding, buffer, 760, DumpArchiveConstants.NAMELEN).trim();\nhostname = DumpArchiveUtil.decode(encoding, buffer, 824, DumpArchiveConstants.NAMELEN).trim();\nflags = DumpArchiveUtil.convert32(buffer, 888);\nfirstrec = DumpArchiveUtil.convert32(buffer, 892);\nntrec = DumpArchiveUtil.convert32(buffer, 896);\n\n//extAttributes = DumpArchiveUtil.convert32(buffer, 900);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveSummary:getNTRec()I",
                                    "method_body": "public int getNTRec() {\nreturn ntrec;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveSummary:isCompressed()Z",
                                    "method_body": "public boolean isCompressed() {\nreturn (flags & 0x0080) == 0x0080;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:<init>()V",
                                    "method_body": "public DumpArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:getHeaderType()Lorg/apache/commons/compress/archivers/dump/DumpArchiveConstants$SEGMENT_TYPE;",
                                    "method_body": "public DumpArchiveConstants.SEGMENT_TYPE getHeaderType() {\nreturn header.getType();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:getHeaderCount()I",
                                    "method_body": "public int getHeaderCount() {\nreturn header.getCount();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:parse([B)Lorg/apache/commons/compress/archivers/dump/DumpArchiveEntry;",
                                    "method_body": "static DumpArchiveEntry parse(byte[] buffer) {\nDumpArchiveEntry entry = new DumpArchiveEntry();\nTapeSegmentHeader header = entry.header;\n\nheader.type = DumpArchiveConstants.SEGMENT_TYPE.find(DumpArchiveUtil.convert32(\nbuffer, 0));\n\n//header.dumpDate = new Date(1000L * DumpArchiveUtil.convert32(buffer, 4));\n//header.previousDumpDate = new Date(1000L * DumpArchiveUtil.convert32(\n//            buffer, 8));\nheader.volume = DumpArchiveUtil.convert32(buffer, 12);\n//header.tapea = DumpArchiveUtil.convert32(buffer, 16);\nentry.ino = header.ino = DumpArchiveUtil.convert32(buffer, 20);\n\n//header.magic = DumpArchiveUtil.convert32(buffer, 24);\n//header.checksum = DumpArchiveUtil.convert32(buffer, 28);\nint m = DumpArchiveUtil.convert16(buffer, 32);\n\n// determine the type of the file.\nentry.setType(TYPE.find((m >> 12) & 0x0F));\n\n// determine the standard permissions\nentry.setMode(m);\n\nentry.nlink = DumpArchiveUtil.convert16(buffer, 34);\n// inumber, oldids?\nentry.setSize(DumpArchiveUtil.convert64(buffer, 40));\n\nlong t = (1000L * DumpArchiveUtil.convert32(buffer, 48)) +\n(DumpArchiveUtil.convert32(buffer, 52) / 1000);\nentry.setAccessTime(new Date(t));\nt = (1000L * DumpArchiveUtil.convert32(buffer, 56)) +\n(DumpArchiveUtil.convert32(buffer, 60) / 1000);\nentry.setLastModifiedDate(new Date(t));\nt = (1000L * DumpArchiveUtil.convert32(buffer, 64)) +\n(DumpArchiveUtil.convert32(buffer, 68) / 1000);\nentry.ctime = t;\n\n// db: 72-119 - direct blocks\n// id: 120-131 - indirect blocks\n//entry.flags = DumpArchiveUtil.convert32(buffer, 132);\n//entry.blocks = DumpArchiveUtil.convert32(buffer, 136);\nentry.generation = DumpArchiveUtil.convert32(buffer, 140);\nentry.setUserId(DumpArchiveUtil.convert32(buffer, 144));\nentry.setGroupId(DumpArchiveUtil.convert32(buffer, 148));\n// two 32-bit spare values.\nheader.count = DumpArchiveUtil.convert32(buffer, 160);\n\nheader.holes = 0;\n\nfor (int i = 0; (i < 512) && (i < header.count); i++) {\nif (buffer[164 + i] == 0) {\nheader.holes++;\n}\n}\n\nSystem.arraycopy(buffer, 164, header.cdata, 0, 512);\n\nentry.volume = header.getVolume();\n\n//entry.isSummaryOnly = false;\nreturn entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setType(Lorg/apache/commons/compress/archivers/dump/DumpArchiveEntry$TYPE;)V",
                                    "method_body": "public void setType(TYPE type) {\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setMode(I)V",
                                    "method_body": "public void setMode(int mode) {\nthis.mode = mode & 07777;\nthis.permissions = PERMISSION.find(mode);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setLastModifiedDate(Ljava/util/Date;)V",
                                    "method_body": "public void setLastModifiedDate(Date mtime) {\nthis.mtime = mtime.getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setAccessTime(Ljava/util/Date;)V",
                                    "method_body": "public void setAccessTime(Date atime) {\nthis.atime = atime.getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setUserId(I)V",
                                    "method_body": "public void setUserId(int uid) {\nthis.uid = uid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry:setGroupId(I)V",
                                    "method_body": "public void setGroupId(int gid) {\nthis.gid = gid;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TYPE:<init>(Ljava/lang/String;II)V",
                                    "method_body": "private TYPE(int code) {\nthis.code = code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TYPE:find(I)Lorg/apache/commons/compress/archivers/dump/DumpArchiveEntry$TYPE;",
                                    "method_body": "public static TYPE find(int code) {\nTYPE type = UNKNOWN;\n\nfor (TYPE t : TYPE.values()) {\nif (code == t.code) {\ntype = t;\n}\n}\n\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TapeSegmentHeader:getType()Lorg/apache/commons/compress/archivers/dump/DumpArchiveConstants$SEGMENT_TYPE;",
                                    "method_body": "public DumpArchiveConstants.SEGMENT_TYPE getType() {\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TapeSegmentHeader:getVolume()I",
                                    "method_body": "public int getVolume() {\nreturn volume;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$TapeSegmentHeader:getCount()I",
                                    "method_body": "public int getCount() {\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveConstants$SEGMENT_TYPE:<init>(Ljava/lang/String;II)V",
                                    "method_body": "private SEGMENT_TYPE(int code) {\nthis.code = code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveConstants$SEGMENT_TYPE:find(I)Lorg/apache/commons/compress/archivers/dump/DumpArchiveConstants$SEGMENT_TYPE;",
                                    "method_body": "public static SEGMENT_TYPE find(int code) {\nfor (SEGMENT_TYPE t : values()) {\nif (t.code == code) {\nreturn t;\n}\n}\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$PERMISSION:<init>(Ljava/lang/String;II)V",
                                    "method_body": "private PERMISSION(int code) {\nthis.code = code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry$PERMISSION:find(I)Ljava/util/Set;",
                                    "method_body": "public static Set<PERMISSION> find(int code) {\nSet<PERMISSION> set = new HashSet<PERMISSION>();\n\nfor (PERMISSION p : PERMISSION.values()) {\nif ((code & p.code) == p.code) {\nset.add(p);\n}\n}\n\nif (set.isEmpty()) {\nreturn Collections.emptySet();\n}\n\nreturn EnumSet.copyOf(set);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.Dirent:<init>(IIILjava/lang/String;)V",
                                    "method_body": "Dirent(int ino, int parentIno, int type, String name) {\nthis.ino = ino;\nthis.parentIno = parentIno;\nthis.type = type;\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveInputStream(Ljava/io/InputStream;)Lorg/apache/commons/compress/archivers/ArchiveInputStream;",
                                    "method_body": "public ArchiveInputStream createArchiveInputStream(final InputStream in)\nthrows ArchiveException {\nif (in == null) {\nthrow new IllegalArgumentException(\"Stream must not be null.\");\n}\n\nif (!in.markSupported()) {\nthrow new IllegalArgumentException(\"Mark is not supported.\");\n}\n\nfinal byte[] signature = new byte[12];\nin.mark(signature.length);\ntry {\nint signatureLength = IOUtils.readFully(in, signature);\nin.reset();\nif (ZipArchiveInputStream.matches(signature, signatureLength)) {\nif (entryEncoding != null) {\nreturn new ZipArchiveInputStream(in, entryEncoding);\n} else {\nreturn new ZipArchiveInputStream(in);\n}\n} else if (JarArchiveInputStream.matches(signature, signatureLength)) {\nif (entryEncoding != null) {\nreturn new JarArchiveInputStream(in, entryEncoding);\n} else {\nreturn new JarArchiveInputStream(in);\n}\n} else if (ArArchiveInputStream.matches(signature, signatureLength)) {\nreturn new ArArchiveInputStream(in);\n} else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\nif (entryEncoding != null) {\nreturn new CpioArchiveInputStream(in, entryEncoding);\n} else {\nreturn new CpioArchiveInputStream(in);\n}\n} else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\nreturn new ArjArchiveInputStream(in);\n} else if (SevenZFile.matches(signature, signatureLength)) {\nthrow new StreamingNotSupportedException(SEVEN_Z);\n}\n\n// Dump needs a bigger buffer to check the signature;\nfinal byte[] dumpsig = new byte[32];\nin.mark(dumpsig.length);\nsignatureLength = IOUtils.readFully(in, dumpsig);\nin.reset();\nif (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\nreturn new DumpArchiveInputStream(in, entryEncoding);\n}\n\n// Tar needs an even bigger buffer to check the signature; read the first block\nfinal byte[] tarheader = new byte[512];\nin.mark(tarheader.length);\nsignatureLength = IOUtils.readFully(in, tarheader);\nin.reset();\nif (TarArchiveInputStream.matches(tarheader, signatureLength)) {\nreturn new TarArchiveInputStream(in, entryEncoding);\n}\n// COMPRESS-117 - improve auto-recognition\nif (signatureLength >= 512) {\nTarArchiveInputStream tais = null;\ntry {\ntais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n// COMPRESS-191 - verify the header checksum\nif (tais.getNextTarEntry().isCheckSumOK()) {\nreturn new TarArchiveInputStream(in, encoding);\n}\n} catch (Exception e) { // NOPMD\n// can generate IllegalArgumentException as well\n// as IOException\n// autodetection, simply not a TAR\n// ignored\n} finally {\nIOUtils.closeQuietly(tais);\n}\n}\n} catch (IOException e) {\nthrow new ArchiveException(\"Could not use reset and mark operations.\", e);\n}\n\nthrow new ArchiveException(\"No Archiver found for the stream signature\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "public static final int EFS_FLAG = GeneralPurposeBit.UFT8_NAMES_FLAG;\n\nprivate static final byte[] EMPTY = new byte[0];\n\n/**\n* Current entry.\n*/\nprivate CurrentEntry entry;\n\n/**\n* The file comment.\n*/\nprivate String comment = \"\";\n\n/**\n* Compression level for next entry.\n*/\nprivate int level = DEFAULT_COMPRESSION;\n\n/**\n* Has the compression level changed when compared to the last\n* entry?\n*/\nprivate boolean hasCompressionLevelChanged = false;\n\n/**\n* Default compression method for next entry.\n*/\nprivate int method = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* List of ZipArchiveEntries written so far.\n*/\nprivate final List<ZipArchiveEntry> entries =\nnew LinkedList<ZipArchiveEntry>();\n\nprivate final StreamCompressor streamCompressor;\n\n/**\n* Start of central directory.\n*/\nprivate long cdOffset = 0;\n\n/**\n* Length of central directory.\n*/\nprivate long cdLength = 0;\n\n/**\n* Helper, a 0 as ZipShort.\n*/\nprivate static final byte[] ZERO = {0, 0};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:matchAsciiBuffer(Ljava/lang/String;[BII)Z",
                                    "method_body": "public static boolean matchAsciiBuffer(\nString expected, byte[] buffer, int offset, int length){\nbyte[] buffer1;\ntry {\nbuffer1 = expected.getBytes(CharsetNames.US_ASCII);\n} catch (UnsupportedEncodingException e) {\nthrow new RuntimeException(e); // Should not happen\n}\nreturn isEqual(buffer1, 0, buffer1.length, buffer, offset, length, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isEqual([BII[BIIZ)Z",
                                    "method_body": "public static boolean isEqual(\nfinal byte[] buffer1, final int offset1, final int length1,\nfinal byte[] buffer2, final int offset2, final int length2,\nboolean ignoreTrailingNulls){\nint minLen=length1 < length2 ? length1 : length2;\nfor (int i=0; i < minLen; i++){\nif (buffer1[offset1+i] != buffer2[offset2+i]){\nreturn false;\n}\n}\nif (length1 == length2){\nreturn true;\n}\nif (ignoreTrailingNulls){\nif (length1 > length2){\nfor(int i = length2; i < length1; i++){\nif (buffer1[offset1+i] != 0){\nreturn false;\n}\n}\n} else {\nfor(int i = length1; i < length2; i++){\nif (buffer2[offset2+i] != 0){\nreturn false;\n}\n}\n}\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[B)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b) throws IOException {\nreturn readFully(input, b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < 6) {\nreturn false;\n}\n\n// Check binary values\nif (signature[0] == 0x71 && (signature[1] & 0xFF) == 0xc7) {\nreturn true;\n}\nif (signature[1] == 0x71 && (signature[0] & 0xFF) == 0xc7) {\nreturn true;\n}\n\n// Check Ascii (String) values\n// 3037 3037 30nn\nif (signature[0] != 0x30) {\nreturn false;\n}\nif (signature[1] != 0x37) {\nreturn false;\n}\nif (signature[2] != 0x30) {\nreturn false;\n}\nif (signature[3] != 0x37) {\nreturn false;\n}\nif (signature[4] != 0x30) {\nreturn false;\n}\n// Check last byte\nif (signature[5] == 0x31) {\nreturn true;\n}\nif (signature[5] == 0x32) {\nreturn true;\n}\nif (signature[5] == 0x37) {\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < ZipArchiveOutputStream.LFH_SIG.length) {\nreturn false;\n}\n\nreturn checksig(signature, ZipArchiveOutputStream.LFH_SIG) // normal file\n|| checksig(signature, ZipArchiveOutputStream.EOCD_SIG) // empty zip\n|| checksig(signature, ZipArchiveOutputStream.DD_SIG) // split zip\n|| checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:checksig([B[B)Z",
                                    "method_body": "private static boolean checksig(byte[] signature, byte[] expected) {\nfor (int i = 0; i < expected.length; i++) {\nif (signature[i] != expected[i]) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length ) {\nreturn ZipArchiveInputStream.matches(signature, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < TarConstants.VERSION_OFFSET+TarConstants.VERSIONLEN) {\nreturn false;\n}\n\nif (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_POSIX,\nsignature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n&&\nArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_POSIX,\nsignature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n){\nreturn true;\n}\nif (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_GNU,\nsignature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n&&\n(\nArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_SPACE,\nsignature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n||\nArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_ZERO,\nsignature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n)\n){\nreturn true;\n}\n// COMPRESS-107 - recognise Ant tar files\nif (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_ANT,\nsignature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n&&\nArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_ANT,\nsignature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n){\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:<clinit>()V",
                                    "method_body": "static final String BSD_LONGNAME_PREFIX = \"#1/\";\nprivate static final int BSD_LONGNAME_PREFIX_LEN =\nBSD_LONGNAME_PREFIX.length();\nprivate static final String BSD_LONGNAME_PATTERN =\n\"^\" + BSD_LONGNAME_PREFIX + \"\\\\d+\";\n\n/**\n* Does the name look like it is a long name (or a name containing\n* spaces) as encoded by BSD ar?\n*\n* <p>From the FreeBSD ar(5) man page:</p>\n* <pre>\n* BSD   In the BSD variant, names that are shorter than 16\n*       characters and without embedded spaces are stored\n*       directly in this field.  If a name has an embedded\n*       space, or if it is longer than 16 characters, then\n*       the string \"#1/\" followed by the decimal represen-\n*       tation of the length of the file name is placed in\n*       this field. The actual file name is stored immedi-\n*       ately after the archive header.  The content of the\n*       archive member follows the file name.  The ar_size\n*       field of the header (see below) will then hold the\n*       sum of the size of the file name and the size of\n*       the member.\n* </pre>\n*\n* @since 1.3\n*/\nprivate static boolean isBSDLongName(String name) {\nreturn name != null && name.matches(BSD_LONGNAME_PATTERN);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\n// 3c21 7261 6863 0a3e\n\nif (length < 8) {\nreturn false;\n}\nif (signature[0] != 0x21) {\nreturn false;\n}\nif (signature[1] != 0x3c) {\nreturn false;\n}\nif (signature[2] != 0x61) {\nreturn false;\n}\nif (signature[3] != 0x72) {\nreturn false;\n}\nif (signature[4] != 0x63) {\nreturn false;\n}\nif (signature[5] != 0x68) {\nreturn false;\n}\nif (signature[6] != 0x3e) {\nreturn false;\n}\nif (signature[7] != 0x0a) {\nreturn false;\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(final byte[] signature, final int length) {\nreturn length >= 2 &&\n(0xff & signature[0]) == ARJ_MAGIC_1 &&\n(0xff & signature[1]) == ARJ_MAGIC_2;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<clinit>()V",
                                    "method_body": "static final int SIGNATURE_HEADER_SIZE = 32;\n\nprivate final String fileName;\nprivate RandomAccessFile file;\nprivate final Archive archive;\nprivate int currentEntryIndex = -1;\nprivate int currentFolderIndex = -1;\nprivate InputStream currentFolderInputStream = null;\nprivate InputStream currentEntryInputStream = null;\nprivate byte[] password;\n\nstatic final byte[] sevenZSignature = {\n(byte)'7', (byte)'z', (byte)0xBC, (byte)0xAF, (byte)0x27, (byte)0x1C\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < sevenZSignature.length) {\nreturn false;\n}\n\nfor (int i = 0; i < sevenZSignature.length; i++) {\nif (signature[i] != sevenZSignature[i]) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] buffer, int length) {\n// do we have enough of the header?\nif (length < 32) {\nreturn false;\n}\n\n// this is the best test\nif (length >= DumpArchiveConstants.TP_SIZE) {\nreturn DumpArchiveUtil.verify(buffer);\n}\n\n// this will work in a pinch.\nreturn DumpArchiveConstants.NFS_MAGIC == DumpArchiveUtil.convert32(buffer,\n24);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 30,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStreamTest.readOfLength0ShouldReturn0",
                            "test_body": "46: public void readOfLength0ShouldReturn0() throws Exception {\n47: // Create a big random piece of data\n48: byte[] rawData = new byte[1048576];\n49: for (int i=0; i < rawData.length; ++i) {\n50: rawData[i] = (byte) Math.floor(Math.random()*256);\n51: }\n52: 53: // Compress it\n54: ByteArrayOutputStream baos = new ByteArrayOutputStream();\n55: BZip2CompressorOutputStream bzipOut = new BZip2CompressorOutputStream(baos);\n56: bzipOut.write(rawData);\n57: bzipOut.flush();\n58: bzipOut.close();\n59: baos.flush();\n60: baos.close();\n61: 62: // Try to read it back in\n63: ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n64: BZip2CompressorInputStream bzipIn = new BZip2CompressorInputStream(bais);\n65: byte[] buffer = new byte[1024];\n66: Assert.assertEquals(1024, bzipIn.read(buffer, 0, 1024));\n67: Assert.assertEquals(0, bzipIn.read(buffer, 1024, 0));\n68: Assert.assertEquals(1024, bzipIn.read(buffer, 0, 1024));\n69: bzipIn.close();\n70: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public BZip2CompressorOutputStream(final OutputStream out)\nthrows IOException {\nthis(out, MAX_BLOCKSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:<init>(Ljava/io/OutputStream;I)V",
                                    "method_body": "public BZip2CompressorOutputStream(final OutputStream out, final int blockSize) throws IOException {\nif (blockSize < 1) {\nthrow new IllegalArgumentException(\"blockSize(\" + blockSize + \") < 1\");\n}\nif (blockSize > 9) {\nthrow new IllegalArgumentException(\"blockSize(\" + blockSize + \") > 9\");\n}\n\nthis.blockSize100k = blockSize;\nthis.out = out;\n\n/* 20 is just a paranoia constant */\nthis.allowableBlockSize = (this.blockSize100k * BZip2Constants.BASEBLOCKSIZE) - 20;\ninit();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:hbMakeCodeLengths([B[ILorg/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream$Data;II)V",
                                    "method_body": "private static void hbMakeCodeLengths(final byte[] len, final int[] freq,\nfinal Data dat, final int alphaSize,\nfinal int maxLen) {\n/*\n* Nodes and heap entries run from 1. Entry 0 for both the heap and\n* nodes is a sentinel.\n*/\nfinal int[] heap = dat.heap;\nfinal int[] weight = dat.weight;\nfinal int[] parent = dat.parent;\n\nfor (int i = alphaSize; --i >= 0;) {\nweight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;\n}\n\nfor (boolean tooLong = true; tooLong;) {\ntooLong = false;\n\nint nNodes = alphaSize;\nint nHeap = 0;\nheap[0] = 0;\nweight[0] = 0;\nparent[0] = -2;\n\nfor (int i = 1; i <= alphaSize; i++) {\nparent[i] = -1;\nnHeap++;\nheap[nHeap] = i;\n\nint zz = nHeap;\nint tmp = heap[zz];\nwhile (weight[tmp] < weight[heap[zz >> 1]]) {\nheap[zz] = heap[zz >> 1];\nzz >>= 1;\n}\nheap[zz] = tmp;\n}\n\nwhile (nHeap > 1) {\nint n1 = heap[1];\nheap[1] = heap[nHeap];\nnHeap--;\n\nint yy = 0;\nint zz = 1;\nint tmp = heap[1];\n\nwhile (true) {\nyy = zz << 1;\n\nif (yy > nHeap) {\nbreak;\n}\n\nif ((yy < nHeap)\n&& (weight[heap[yy + 1]] < weight[heap[yy]])) {\nyy++;\n}\n\nif (weight[tmp] < weight[heap[yy]]) {\nbreak;\n}\n\nheap[zz] = heap[yy];\nzz = yy;\n}\n\nheap[zz] = tmp;\n\nint n2 = heap[1];\nheap[1] = heap[nHeap];\nnHeap--;\n\nyy = 0;\nzz = 1;\ntmp = heap[1];\n\nwhile (true) {\nyy = zz << 1;\n\nif (yy > nHeap) {\nbreak;\n}\n\nif ((yy < nHeap)\n&& (weight[heap[yy + 1]] < weight[heap[yy]])) {\nyy++;\n}\n\nif (weight[tmp] < weight[heap[yy]]) {\nbreak;\n}\n\nheap[zz] = heap[yy];\nzz = yy;\n}\n\nheap[zz] = tmp;\nnNodes++;\nparent[n1] = parent[n2] = nNodes;\n\nfinal int weight_n1 = weight[n1];\nfinal int weight_n2 = weight[n2];\nweight[nNodes] = ((weight_n1 & 0xffffff00)\n+ (weight_n2 & 0xffffff00))\n| (1 + (((weight_n1 & 0x000000ff)\n> (weight_n2 & 0x000000ff))\n? (weight_n1 & 0x000000ff)\n: (weight_n2 & 0x000000ff)));\n\nparent[nNodes] = -1;\nnHeap++;\nheap[nHeap] = nNodes;\n\ntmp = 0;\nzz = nHeap;\ntmp = heap[zz];\nfinal int weight_tmp = weight[tmp];\nwhile (weight_tmp < weight[heap[zz >> 1]]) {\nheap[zz] = heap[zz >> 1];\nzz >>= 1;\n}\nheap[zz] = tmp;\n\n}\n\nfor (int i = 1; i <= alphaSize; i++) {\nint j = 0;\nint k = i;\n\nfor (int parent_k; (parent_k = parent[k]) >= 0;) {\nk = parent_k;\nj++;\n}\n\nlen[i - 1] = (byte) j;\nif (j > maxLen) {\ntooLong = true;\n}\n}\n\nif (tooLong) {\nfor (int i = 1; i < alphaSize; i++) {\nint j = weight[i] >> 8;\nj = 1 + (j >> 1);\nweight[i] = j << 8;\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:writeRun()V",
                                    "method_body": "private void writeRun() throws IOException {\nfinal int lastShadow = this.last;\n\nif (lastShadow < this.allowableBlockSize) {\nfinal int currentCharShadow = this.currentChar;\nfinal Data dataShadow = this.data;\ndataShadow.inUse[currentCharShadow] = true;\nfinal byte ch = (byte) currentCharShadow;\n\nint runLengthShadow = this.runLength;\nthis.crc.updateCRC(currentCharShadow, runLengthShadow);\n\nswitch (runLengthShadow) {\ncase 1:\ndataShadow.block[lastShadow + 2] = ch;\nthis.last = lastShadow + 1;\nbreak;\n\ncase 2:\ndataShadow.block[lastShadow + 2] = ch;\ndataShadow.block[lastShadow + 3] = ch;\nthis.last = lastShadow + 2;\nbreak;\n\ncase 3: {\nfinal byte[] block = dataShadow.block;\nblock[lastShadow + 2] = ch;\nblock[lastShadow + 3] = ch;\nblock[lastShadow + 4] = ch;\nthis.last = lastShadow + 3;\n}\nbreak;\n\ndefault: {\nrunLengthShadow -= 4;\ndataShadow.inUse[runLengthShadow] = true;\nfinal byte[] block = dataShadow.block;\nblock[lastShadow + 2] = ch;\nblock[lastShadow + 3] = ch;\nblock[lastShadow + 4] = ch;\nblock[lastShadow + 5] = ch;\nblock[lastShadow + 6] = (byte) runLengthShadow;\nthis.last = lastShadow + 5;\n}\nbreak;\n\n}\n} else {\nendBlock();\ninitBlock();\nwriteRun();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif (out != null) {\ntry {\nif (this.runLength > 0) {\nwriteRun();\n}\nthis.currentChar = -1;\nendBlock();\nendCompression();\n} finally {\nthis.out = null;\nthis.data = null;\nthis.blockSorter = null;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif (out != null) {\nOutputStream outShadow = this.out;\nfinish();\noutShadow.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:flush()V",
                                    "method_body": "public void flush() throws IOException {\nOutputStream outShadow = this.out;\nif (outShadow != null) {\noutShadow.flush();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:init()V",
                                    "method_body": "private void init() throws IOException {\nbsPutUByte('B');\nbsPutUByte('Z');\n\nthis.data = new Data(this.blockSize100k);\nthis.blockSorter = new BlockSort(this.data);\n\n// huffmanised magic bytes\nbsPutUByte('h');\nbsPutUByte('0' + this.blockSize100k);\n\nthis.combinedCRC = 0;\ninitBlock();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:initBlock()V",
                                    "method_body": "private void initBlock() {\n// blockNo++;\nthis.crc.initialiseCRC();\nthis.last = -1;\n// ch = 0;\n\nboolean[] inUse = this.data.inUse;\nfor (int i = 256; --i >= 0;) {\ninUse[i] = false;\n}\n\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:endBlock()V",
                                    "method_body": "private void endBlock() throws IOException {\nthis.blockCRC = this.crc.getFinalCRC();\nthis.combinedCRC = (this.combinedCRC << 1) | (this.combinedCRC >>> 31);\nthis.combinedCRC ^= this.blockCRC;\n\n// empty block at end of file\nif (this.last == -1) {\nreturn;\n}\n\n/* sort the block and establish posn of original string */\nblockSort();\n\n/*\n* A 6-byte block header, the value chosen arbitrarily as 0x314159265359\n* :-). A 32 bit value does not really give a strong enough guarantee\n* that the value will not appear by chance in the compressed\n* datastream. Worst-case probability of this event, for a 900k block,\n* is about 2.0e-3 for 32 bits, 1.0e-5 for 40 bits and 4.0e-8 for 48\n* bits. For a compressed file of size 100Gb -- about 100000 blocks --\n* only a 48-bit marker will do. NB: normal compression/ decompression\n* donot rely on these statistical properties. They are only important\n* when trying to recover blocks from damaged files.\n*/\nbsPutUByte(0x31);\nbsPutUByte(0x41);\nbsPutUByte(0x59);\nbsPutUByte(0x26);\nbsPutUByte(0x53);\nbsPutUByte(0x59);\n\n/* Now the block's CRC, so it is in a known place. */\nbsPutInt(this.blockCRC);\n\n/* Now a single bit indicating no randomisation. */\nbsW(1, 0);\n\n/* Finally, block's contents proper. */\nmoveToFrontCodeAndSend();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:endCompression()V",
                                    "method_body": "private void endCompression() throws IOException {\n/*\n* Now another magic 48-bit number, 0x177245385090, to indicate the end\n* of the last block. (sqrt(pi), if you want to know. I did want to use\n* e, but it contains too much repetition -- 27 18 28 18 28 46 -- for me\n* to feel statistically comfortable. Call me paranoid.)\n*/\nbsPutUByte(0x17);\nbsPutUByte(0x72);\nbsPutUByte(0x45);\nbsPutUByte(0x38);\nbsPutUByte(0x50);\nbsPutUByte(0x90);\n\nbsPutInt(this.combinedCRC);\nbsFinishedWithStream();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:write([BII)V",
                                    "method_body": "public void write(final byte[] buf, int offs, final int len)\nthrows IOException {\nif (offs < 0) {\nthrow new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\");\n}\nif (len < 0) {\nthrow new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\");\n}\nif (offs + len > buf.length) {\nthrow new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\"\n+ len + \") > buf.length(\"\n+ buf.length + \").\");\n}\nif (this.out == null) {\nthrow new IOException(\"stream closed\");\n}\n\nfor (int hi = offs + len; offs < hi;) {\nwrite0(buf[offs++]);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:write0(I)V",
                                    "method_body": "private void write0(int b) throws IOException {\nif (this.currentChar != -1) {\nb &= 0xff;\nif (this.currentChar == b) {\nif (++this.runLength > 254) {\nwriteRun();\nthis.currentChar = -1;\nthis.runLength = 0;\n}\n// else nothing to do\n} else {\nwriteRun();\nthis.runLength = 1;\nthis.currentChar = b;\n}\n} else {\nthis.currentChar = b & 0xff;\nthis.runLength++;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:hbAssignCodes([I[BIII)V",
                                    "method_body": "private static void hbAssignCodes(final int[] code, final byte[] length,\nfinal int minLen, final int maxLen,\nfinal int alphaSize) {\nint vec = 0;\nfor (int n = minLen; n <= maxLen; n++) {\nfor (int i = 0; i < alphaSize; i++) {\nif ((length[i] & 0xff) == n) {\ncode[i] = vec;\nvec++;\n}\n}\nvec <<= 1;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:bsFinishedWithStream()V",
                                    "method_body": "private void bsFinishedWithStream() throws IOException {\nwhile (this.bsLive > 0) {\nint ch = this.bsBuff >> 24;\nthis.out.write(ch); // write 8-bit\nthis.bsBuff <<= 8;\nthis.bsLive -= 8;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:bsW(II)V",
                                    "method_body": "private void bsW(final int n, final int v) throws IOException {\nfinal OutputStream outShadow = this.out;\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\n\nthis.bsBuff = bsBuffShadow | (v << (32 - bsLiveShadow - n));\nthis.bsLive = bsLiveShadow + n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:bsPutUByte(I)V",
                                    "method_body": "private void bsPutUByte(final int c) throws IOException {\nbsW(8, c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:bsPutInt(I)V",
                                    "method_body": "private void bsPutInt(final int u) throws IOException {\nbsW(8, (u >> 24) & 0xff);\nbsW(8, (u >> 16) & 0xff);\nbsW(8, (u >> 8) & 0xff);\nbsW(8, u & 0xff);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues()V",
                                    "method_body": "private void sendMTFValues() throws IOException {\nfinal byte[][] len = this.data.sendMTFValues_len;\nfinal int alphaSize = this.nInUse + 2;\n\nfor (int t = N_GROUPS; --t >= 0;) {\nbyte[] len_t = len[t];\nfor (int v = alphaSize; --v >= 0;) {\nlen_t[v] = GREATER_ICOST;\n}\n}\n\n/* Decide how many coding tables to use */\n// assert (this.nMTF > 0) : this.nMTF;\nfinal int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3\n: (this.nMTF < 1200) ? 4 : (this.nMTF < 2400) ? 5 : 6;\n\n/* Generate an initial set of coding tables */\nsendMTFValues0(nGroups, alphaSize);\n\n/*\n* Iterate up to N_ITERS times to improve the tables.\n*/\nfinal int nSelectors = sendMTFValues1(nGroups, alphaSize);\n\n/* Compute MTF values for the selectors. */\nsendMTFValues2(nGroups, nSelectors);\n\n/* Assign actual codes for the tables. */\nsendMTFValues3(nGroups, alphaSize);\n\n/* Transmit the mapping table. */\nsendMTFValues4();\n\n/* Now the selectors. */\nsendMTFValues5(nGroups, nSelectors);\n\n/* Now the coding tables. */\nsendMTFValues6(nGroups, alphaSize);\n\n/* And finally, the block data proper */\nsendMTFValues7();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues0(II)V",
                                    "method_body": "private void sendMTFValues0(final int nGroups, final int alphaSize) {\nfinal byte[][] len = this.data.sendMTFValues_len;\nfinal int[] mtfFreq = this.data.mtfFreq;\n\nint remF = this.nMTF;\nint gs = 0;\n\nfor (int nPart = nGroups; nPart > 0; nPart--) {\nfinal int tFreq = remF / nPart;\nint ge = gs - 1;\nint aFreq = 0;\n\nfor (final int a = alphaSize - 1; (aFreq < tFreq) && (ge < a);) {\naFreq += mtfFreq[++ge];\n}\n\nif ((ge > gs) && (nPart != nGroups) && (nPart != 1)\n&& (((nGroups - nPart) & 1) != 0)) {\naFreq -= mtfFreq[ge--];\n}\n\nfinal byte[] len_np = len[nPart - 1];\nfor (int v = alphaSize; --v >= 0;) {\nif ((v >= gs) && (v <= ge)) {\nlen_np[v] = LESSER_ICOST;\n} else {\nlen_np[v] = GREATER_ICOST;\n}\n}\n\ngs = ge + 1;\nremF -= aFreq;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues1(II)I",
                                    "method_body": "private int sendMTFValues1(final int nGroups, final int alphaSize) {\nfinal Data dataShadow = this.data;\nfinal int[][] rfreq = dataShadow.sendMTFValues_rfreq;\nfinal int[] fave = dataShadow.sendMTFValues_fave;\nfinal short[] cost = dataShadow.sendMTFValues_cost;\nfinal char[] sfmap = dataShadow.sfmap;\nfinal byte[] selector = dataShadow.selector;\nfinal byte[][] len = dataShadow.sendMTFValues_len;\nfinal byte[] len_0 = len[0];\nfinal byte[] len_1 = len[1];\nfinal byte[] len_2 = len[2];\nfinal byte[] len_3 = len[3];\nfinal byte[] len_4 = len[4];\nfinal byte[] len_5 = len[5];\nfinal int nMTFShadow = this.nMTF;\n\nint nSelectors = 0;\n\nfor (int iter = 0; iter < N_ITERS; iter++) {\nfor (int t = nGroups; --t >= 0;) {\nfave[t] = 0;\nint[] rfreqt = rfreq[t];\nfor (int i = alphaSize; --i >= 0;) {\nrfreqt[i] = 0;\n}\n}\n\nnSelectors = 0;\n\nfor (int gs = 0; gs < this.nMTF;) {\n/* Set group start & end marks. */\n\n/*\n* Calculate the cost of this group as coded by each of the\n* coding tables.\n*/\n\nfinal int ge = Math.min(gs + G_SIZE - 1, nMTFShadow - 1);\n\nif (nGroups == N_GROUPS) {\n// unrolled version of the else-block\n\nshort cost0 = 0;\nshort cost1 = 0;\nshort cost2 = 0;\nshort cost3 = 0;\nshort cost4 = 0;\nshort cost5 = 0;\n\nfor (int i = gs; i <= ge; i++) {\nfinal int icv = sfmap[i];\ncost0 += len_0[icv] & 0xff;\ncost1 += len_1[icv] & 0xff;\ncost2 += len_2[icv] & 0xff;\ncost3 += len_3[icv] & 0xff;\ncost4 += len_4[icv] & 0xff;\ncost5 += len_5[icv] & 0xff;\n}\n\ncost[0] = cost0;\ncost[1] = cost1;\ncost[2] = cost2;\ncost[3] = cost3;\ncost[4] = cost4;\ncost[5] = cost5;\n\n} else {\nfor (int t = nGroups; --t >= 0;) {\ncost[t] = 0;\n}\n\nfor (int i = gs; i <= ge; i++) {\nfinal int icv = sfmap[i];\nfor (int t = nGroups; --t >= 0;) {\ncost[t] += len[t][icv] & 0xff;\n}\n}\n}\n\n/*\n* Find the coding table which is best for this group, and\n* record its identity in the selector table.\n*/\nint bt = -1;\nfor (int t = nGroups, bc = 999999999; --t >= 0;) {\nfinal int cost_t = cost[t];\nif (cost_t < bc) {\nbc = cost_t;\nbt = t;\n}\n}\n\nfave[bt]++;\nselector[nSelectors] = (byte) bt;\nnSelectors++;\n\n/*\n* Increment the symbol frequencies for the selected table.\n*/\nfinal int[] rfreq_bt = rfreq[bt];\nfor (int i = gs; i <= ge; i++) {\nrfreq_bt[sfmap[i]]++;\n}\n\ngs = ge + 1;\n}\n\n/*\n* Recompute the tables based on the accumulated frequencies.\n*/\nfor (int t = 0; t < nGroups; t++) {\nhbMakeCodeLengths(len[t], rfreq[t], this.data, alphaSize, 20);\n}\n}\n\nreturn nSelectors;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues2(II)V",
                                    "method_body": "private void sendMTFValues2(final int nGroups, final int nSelectors) {\n// assert (nGroups < 8) : nGroups;\n\nfinal Data dataShadow = this.data;\nbyte[] pos = dataShadow.sendMTFValues2_pos;\n\nfor (int i = nGroups; --i >= 0;) {\npos[i] = (byte) i;\n}\n\nfor (int i = 0; i < nSelectors; i++) {\nfinal byte ll_i = dataShadow.selector[i];\nbyte tmp = pos[0];\nint j = 0;\n\nwhile (ll_i != tmp) {\nj++;\nbyte tmp2 = tmp;\ntmp = pos[j];\npos[j] = tmp2;\n}\n\npos[0] = tmp;\ndataShadow.selectorMtf[i] = (byte) j;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues3(II)V",
                                    "method_body": "private void sendMTFValues3(final int nGroups, final int alphaSize) {\nint[][] code = this.data.sendMTFValues_code;\nbyte[][] len = this.data.sendMTFValues_len;\n\nfor (int t = 0; t < nGroups; t++) {\nint minLen = 32;\nint maxLen = 0;\nfinal byte[] len_t = len[t];\nfor (int i = alphaSize; --i >= 0;) {\nfinal int l = len_t[i] & 0xff;\nif (l > maxLen) {\nmaxLen = l;\n}\nif (l < minLen) {\nminLen = l;\n}\n}\n\n// assert (maxLen <= 20) : maxLen;\n// assert (minLen >= 1) : minLen;\n\nhbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues4()V",
                                    "method_body": "private void sendMTFValues4() throws IOException {\nfinal boolean[] inUse = this.data.inUse;\nfinal boolean[] inUse16 = this.data.sentMTFValues4_inUse16;\n\nfor (int i = 16; --i >= 0;) {\ninUse16[i] = false;\nfinal int i16 = i * 16;\nfor (int j = 16; --j >= 0;) {\nif (inUse[i16 + j]) {\ninUse16[i] = true;\n}\n}\n}\n\nfor (int i = 0; i < 16; i++) {\nbsW(1, inUse16[i] ? 1 : 0);\n}\n\nfinal OutputStream outShadow = this.out;\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nfor (int i = 0; i < 16; i++) {\nif (inUse16[i]) {\nfinal int i16 = i * 16;\nfor (int j = 0; j < 16; j++) {\n// inlined: bsW(1, inUse[i16 + j] ? 1 : 0);\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\nif (inUse[i16 + j]) {\nbsBuffShadow |= 1 << (32 - bsLiveShadow - 1);\n}\nbsLiveShadow++;\n}\n}\n}\n\nthis.bsBuff = bsBuffShadow;\nthis.bsLive = bsLiveShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues5(II)V",
                                    "method_body": "private void sendMTFValues5(final int nGroups, final int nSelectors)\nthrows IOException {\nbsW(3, nGroups);\nbsW(15, nSelectors);\n\nfinal OutputStream outShadow = this.out;\nfinal byte[] selectorMtf = this.data.selectorMtf;\n\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nfor (int i = 0; i < nSelectors; i++) {\nfor (int j = 0, hj = selectorMtf[i] & 0xff; j < hj; j++) {\n// inlined: bsW(1, 1);\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24);\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\nbsBuffShadow |= 1 << (32 - bsLiveShadow - 1);\nbsLiveShadow++;\n}\n\n// inlined: bsW(1, 0);\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24);\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\n// bsBuffShadow |= 0 << (32 - bsLiveShadow - 1);\nbsLiveShadow++;\n}\n\nthis.bsBuff = bsBuffShadow;\nthis.bsLive = bsLiveShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues6(II)V",
                                    "method_body": "private void sendMTFValues6(final int nGroups, final int alphaSize)\nthrows IOException {\nfinal byte[][] len = this.data.sendMTFValues_len;\nfinal OutputStream outShadow = this.out;\n\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nfor (int t = 0; t < nGroups; t++) {\nbyte[] len_t = len[t];\nint curr = len_t[0] & 0xff;\n\n// inlined: bsW(5, curr);\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\nbsBuffShadow |= curr << (32 - bsLiveShadow - 5);\nbsLiveShadow += 5;\n\nfor (int i = 0; i < alphaSize; i++) {\nint lti = len_t[i] & 0xff;\nwhile (curr < lti) {\n// inlined: bsW(2, 2);\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\nbsBuffShadow |= 2 << (32 - bsLiveShadow - 2);\nbsLiveShadow += 2;\n\ncurr++; /* 10 */\n}\n\nwhile (curr > lti) {\n// inlined: bsW(2, 3);\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\nbsBuffShadow |= 3 << (32 - bsLiveShadow - 2);\nbsLiveShadow += 2;\n\ncurr--; /* 11 */\n}\n\n// inlined: bsW(1, 0);\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\n// bsBuffShadow |= 0 << (32 - bsLiveShadow - 1);\nbsLiveShadow++;\n}\n}\n\nthis.bsBuff = bsBuffShadow;\nthis.bsLive = bsLiveShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues7()V",
                                    "method_body": "private void sendMTFValues7() throws IOException {\nfinal Data dataShadow = this.data;\nfinal byte[][] len = dataShadow.sendMTFValues_len;\nfinal int[][] code = dataShadow.sendMTFValues_code;\nfinal OutputStream outShadow = this.out;\nfinal byte[] selector = dataShadow.selector;\nfinal char[] sfmap = dataShadow.sfmap;\nfinal int nMTFShadow = this.nMTF;\n\nint selCtr = 0;\n\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nfor (int gs = 0; gs < nMTFShadow;) {\nfinal int ge = Math.min(gs + G_SIZE - 1, nMTFShadow - 1);\nfinal int selector_selCtr = selector[selCtr] & 0xff;\nfinal int[] code_selCtr = code[selector_selCtr];\nfinal byte[] len_selCtr = len[selector_selCtr];\n\nwhile (gs <= ge) {\nfinal int sfmap_i = sfmap[gs];\n\n//\n// inlined: bsW(len_selCtr[sfmap_i] & 0xff,\n// code_selCtr[sfmap_i]);\n//\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24);\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\nfinal int n = len_selCtr[sfmap_i] & 0xFF;\nbsBuffShadow |= code_selCtr[sfmap_i] << (32 - bsLiveShadow - n);\nbsLiveShadow += n;\n\ngs++;\n}\n\ngs = ge + 1;\nselCtr++;\n}\n\nthis.bsBuff = bsBuffShadow;\nthis.bsLive = bsLiveShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:moveToFrontCodeAndSend()V",
                                    "method_body": "private void moveToFrontCodeAndSend() throws IOException {\nbsW(24, this.data.origPtr);\ngenerateMTFValues();\nsendMTFValues();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:blockSort()V",
                                    "method_body": "private void blockSort() {\nblockSorter.blockSort(data, last);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:generateMTFValues()V",
                                    "method_body": "private void generateMTFValues() {\nfinal int lastShadow = this.last;\nfinal Data dataShadow = this.data;\nfinal boolean[] inUse = dataShadow.inUse;\nfinal byte[] block = dataShadow.block;\nfinal int[] fmap = dataShadow.fmap;\nfinal char[] sfmap = dataShadow.sfmap;\nfinal int[] mtfFreq = dataShadow.mtfFreq;\nfinal byte[] unseqToSeq = dataShadow.unseqToSeq;\nfinal byte[] yy = dataShadow.generateMTFValues_yy;\n\n// make maps\nint nInUseShadow = 0;\nfor (int i = 0; i < 256; i++) {\nif (inUse[i]) {\nunseqToSeq[i] = (byte) nInUseShadow;\nnInUseShadow++;\n}\n}\nthis.nInUse = nInUseShadow;\n\nfinal int eob = nInUseShadow + 1;\n\nfor (int i = eob; i >= 0; i--) {\nmtfFreq[i] = 0;\n}\n\nfor (int i = nInUseShadow; --i >= 0;) {\nyy[i] = (byte) i;\n}\n\nint wr = 0;\nint zPend = 0;\n\nfor (int i = 0; i <= lastShadow; i++) {\nfinal byte ll_i = unseqToSeq[block[fmap[i]] & 0xff];\nbyte tmp = yy[0];\nint j = 0;\n\nwhile (ll_i != tmp) {\nj++;\nbyte tmp2 = tmp;\ntmp = yy[j];\nyy[j] = tmp2;\n}\nyy[0] = tmp;\n\nif (j == 0) {\nzPend++;\n} else {\nif (zPend > 0) {\nzPend--;\nwhile (true) {\nif ((zPend & 1) == 0) {\nsfmap[wr] = RUNA;\nwr++;\nmtfFreq[RUNA]++;\n} else {\nsfmap[wr] = RUNB;\nwr++;\nmtfFreq[RUNB]++;\n}\n\nif (zPend >= 2) {\nzPend = (zPend - 2) >> 1;\n} else {\nbreak;\n}\n}\nzPend = 0;\n}\nsfmap[wr] = (char) (j + 1);\nwr++;\nmtfFreq[j + 1]++;\n}\n}\n\nif (zPend > 0) {\nzPend--;\nwhile (true) {\nif ((zPend & 1) == 0) {\nsfmap[wr] = RUNA;\nwr++;\nmtfFreq[RUNA]++;\n} else {\nsfmap[wr] = RUNB;\nwr++;\nmtfFreq[RUNB]++;\n}\n\nif (zPend >= 2) {\nzPend = (zPend - 2) >> 1;\n} else {\nbreak;\n}\n}\n}\n\nsfmap[wr] = (char) eob;\nmtfFreq[eob]++;\nthis.nMTF = wr + 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:<init>()V",
                                    "method_body": "CRC() {\ninitialiseCRC();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:<clinit>()V",
                                    "method_body": "private static final int crc32Table[] = {\n0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,\n0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,\n0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,\n0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,\n0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,\n0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,\n0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,\n0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,\n0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,\n0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,\n0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,\n0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,\n0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,\n0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,\n0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,\n0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,\n0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,\n0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,\n0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,\n0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,\n0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,\n0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,\n0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,\n0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,\n0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,\n0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,\n0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,\n0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,\n0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,\n0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,\n0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,\n0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,\n0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,\n0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,\n0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,\n0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,\n0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,\n0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,\n0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,\n0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,\n0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,\n0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,\n0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,\n0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,\n0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,\n0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,\n0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,\n0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,\n0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,\n0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,\n0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,\n0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,\n0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,\n0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,\n0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,\n0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,\n0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,\n0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,\n0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,\n0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,\n0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,\n0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,\n0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,\n0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:initialiseCRC()V",
                                    "method_body": "void initialiseCRC() {\nglobalCrc = 0xffffffff;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:getFinalCRC()I",
                                    "method_body": "int getFinalCRC() {\nreturn ~globalCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:updateCRC(I)V",
                                    "method_body": "void updateCRC(int inCh) {\nint temp = (globalCrc >> 24) ^ inCh;\nif (temp < 0) {\ntemp = 256 + temp;\n}\nglobalCrc = (globalCrc << 8) ^ CRC.crc32Table[temp];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:updateCRC(II)V",
                                    "method_body": "void updateCRC(int inCh, int repeat) {\nint globalCrcShadow = this.globalCrc;\nwhile (repeat-- > 0) {\nint temp = (globalCrcShadow >> 24) ^ inCh;\nglobalCrcShadow = (globalCrcShadow << 8) ^ crc32Table[(temp >= 0)\n? temp\n: (temp + 256)];\n}\nthis.globalCrc = globalCrcShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream$Data:<init>(I)V",
                                    "method_body": "Data(int blockSize100k) {\nfinal int n = blockSize100k * BZip2Constants.BASEBLOCKSIZE;\nthis.block = new byte[(n + 1 + NUM_OVERSHOOT_BYTES)];\nthis.fmap = new int[n];\nthis.sfmap = new char[2 * n];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:<init>(Lorg/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream$Data;)V",
                                    "method_body": "BlockSort(final BZip2CompressorOutputStream.Data data) {\nthis.quadrant = data.sfmap;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:<clinit>()V",
                                    "method_body": "private static final int[] INCS = { 1, 4, 13, 40, 121, 364, 1093, 3280,\n9841, 29524, 88573, 265720, 797161,\n2391484 };"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:blockSort(Lorg/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream$Data;I)V",
                                    "method_body": "void blockSort(final BZip2CompressorOutputStream.Data data, final int last) {\nthis.workLimit = WORK_FACTOR * last;\nthis.workDone = 0;\nthis.firstAttempt = true;\n\nif (last + 1 < 10000) {\nfallbackSort(data, last);\n} else {\nmainSort(data, last);\n\nif (this.firstAttempt && (this.workDone > this.workLimit)) {\nfallbackSort(data, last);\n}\n}\n\nfinal int[] fmap = data.fmap;\ndata.origPtr = -1;\nfor (int i = 0; i <= last; i++) {\nif (fmap[i] == 0) {\ndata.origPtr = i;\nbreak;\n}\n}\n\n// assert (data.origPtr != -1) : data.origPtr;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:mainSimpleSort(Lorg/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream$Data;IIII)Z",
                                    "method_body": "private boolean mainSimpleSort(final BZip2CompressorOutputStream.Data dataShadow,\nfinal int lo, final int hi, final int d,\nfinal int lastShadow) {\nfinal int bigN = hi - lo + 1;\nif (bigN < 2) {\nreturn this.firstAttempt && (this.workDone > this.workLimit);\n}\n\nint hp = 0;\nwhile (INCS[hp] < bigN) {\nhp++;\n}\n\nfinal int[] fmap = dataShadow.fmap;\nfinal char[] quadrant = this.quadrant;\nfinal byte[] block = dataShadow.block;\nfinal int lastPlus1 = lastShadow + 1;\nfinal boolean firstAttemptShadow = this.firstAttempt;\nfinal int workLimitShadow = this.workLimit;\nint workDoneShadow = this.workDone;\n\n// Following block contains unrolled code which could be shortened by\n// coding it in additional loops.\n\nHP: while (--hp >= 0) {\nfinal int h = INCS[hp];\nfinal int mj = lo + h - 1;\n\nfor (int i = lo + h; i <= hi;) {\n// copy\nfor (int k = 3; (i <= hi) && (--k >= 0); i++) {\nfinal int v = fmap[i];\nfinal int vd = v + d;\nint j = i;\n\n// for (int a;\n// (j > mj) && mainGtU((a = fmap[j - h]) + d, vd,\n// block, quadrant, lastShadow);\n// j -= h) {\n// fmap[j] = a;\n// }\n//\n// unrolled version:\n\n// start inline mainGTU\nboolean onceRunned = false;\nint a = 0;\n\nHAMMER: while (true) {\nif (onceRunned) {\nfmap[j] = a;\nif ((j -= h) <= mj) {\nbreak HAMMER;\n}\n} else {\nonceRunned = true;\n}\n\na = fmap[j - h];\nint i1 = a + d;\nint i2 = vd;\n\n// following could be done in a loop, but\n// unrolled it for performance:\nif (block[i1 + 1] == block[i2 + 1]) {\nif (block[i1 + 2] == block[i2 + 2]) {\nif (block[i1 + 3] == block[i2 + 3]) {\nif (block[i1 + 4] == block[i2 + 4]) {\nif (block[i1 + 5] == block[i2 + 5]) {\nif (block[(i1 += 6)] == block[(i2 += 6)]) {\nint x = lastShadow;\nX: while (x > 0) {\nx -= 4;\n\nif (block[i1 + 1] == block[i2 + 1]) {\nif (quadrant[i1] == quadrant[i2]) {\nif (block[i1 + 2] == block[i2 + 2]) {\nif (quadrant[i1 + 1] == quadrant[i2 + 1]) {\nif (block[i1 + 3] == block[i2 + 3]) {\nif (quadrant[i1 + 2] == quadrant[i2 + 2]) {\nif (block[i1 + 4] == block[i2 + 4]) {\nif (quadrant[i1 + 3] == quadrant[i2 + 3]) {\nif ((i1 += 4) >= lastPlus1) {\ni1 -= lastPlus1;\n}\nif ((i2 += 4) >= lastPlus1) {\ni2 -= lastPlus1;\n}\nworkDoneShadow++;\ncontinue X;\n} else if ((quadrant[i1 + 3] > quadrant[i2 + 3])) {\ncontinue HAMMER;\n} else {\nbreak HAMMER;\n}\n} else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff)) {\ncontinue HAMMER;\n} else {\nbreak HAMMER;\n}\n} else if ((quadrant[i1 + 2] > quadrant[i2 + 2])) {\ncontinue HAMMER;\n} else {\nbreak HAMMER;\n}\n} else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff)) {\ncontinue HAMMER;\n} else {\nbreak HAMMER;\n}\n} else if ((quadrant[i1 + 1] > quadrant[i2 + 1])) {\ncontinue HAMMER;\n} else {\nbreak HAMMER;\n}\n} else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff)) {\ncontinue HAMMER;\n} else {\nbreak HAMMER;\n}\n} else if ((quadrant[i1] > quadrant[i2])) {\ncontinue HAMMER;\n} else {\nbreak HAMMER;\n}\n} else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff)) {\ncontinue HAMMER;\n} else {\nbreak HAMMER;\n}\n\n}\nbreak HAMMER;\n} // while x > 0\nelse {\nif ((block[i1] & 0xff) > (block[i2] & 0xff)) {\ncontinue HAMMER;\n} else {\nbreak HAMMER;\n}\n}\n} else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff)) {\ncontinue HAMMER;\n} else {\nbreak HAMMER;\n}\n} else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff)) {\ncontinue HAMMER;\n} else {\nbreak HAMMER;\n}\n} else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff)) {\ncontinue HAMMER;\n} else {\nbreak HAMMER;\n}\n} else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff)) {\ncontinue HAMMER;\n} else {\nbreak HAMMER;\n}\n} else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff)) {\ncontinue HAMMER;\n} else {\nbreak HAMMER;\n}\n\n} // HAMMER\n// end inline mainGTU\n\nfmap[j] = v;\n}\n\nif (firstAttemptShadow && (i <= hi)\n&& (workDoneShadow > workLimitShadow)) {\nbreak HP;\n}\n}\n}\n\nthis.workDone = workDoneShadow;\nreturn firstAttemptShadow && (workDoneShadow > workLimitShadow);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:vswap([IIII)V",
                                    "method_body": "private static void vswap(int[] fmap, int p1, int p2, int n) {\nn += p1;\nwhile (p1 < n) {\nint t = fmap[p1];\nfmap[p1++] = fmap[p2];\nfmap[p2++] = t;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:med3(BBB)B",
                                    "method_body": "private static byte med3(byte a, byte b, byte c) {\nreturn (a < b) ? (b < c ? b : a < c ? c : a) : (b > c ? b : a > c ? c\n: a);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:mainQSort3(Lorg/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream$Data;IIII)V",
                                    "method_body": "private void mainQSort3(final BZip2CompressorOutputStream.Data dataShadow,\nfinal int loSt, final int hiSt, final int dSt,\nfinal int last) {\nfinal int[] stack_ll = this.stack_ll;\nfinal int[] stack_hh = this.stack_hh;\nfinal int[] stack_dd = this.stack_dd;\nfinal int[] fmap = dataShadow.fmap;\nfinal byte[] block = dataShadow.block;\n\nstack_ll[0] = loSt;\nstack_hh[0] = hiSt;\nstack_dd[0] = dSt;\n\nfor (int sp = 1; --sp >= 0;) {\nfinal int lo = stack_ll[sp];\nfinal int hi = stack_hh[sp];\nfinal int d = stack_dd[sp];\n\nif ((hi - lo < SMALL_THRESH) || (d > DEPTH_THRESH)) {\nif (mainSimpleSort(dataShadow, lo, hi, d, last)) {\nreturn;\n}\n} else {\nfinal int d1 = d + 1;\nfinal int med = med3(block[fmap[lo] + d1],\nblock[fmap[hi] + d1], block[fmap[(lo + hi) >>> 1] + d1]) & 0xff;\n\nint unLo = lo;\nint unHi = hi;\nint ltLo = lo;\nint gtHi = hi;\n\nwhile (true) {\nwhile (unLo <= unHi) {\nfinal int n = (block[fmap[unLo] + d1] & 0xff)\n- med;\nif (n == 0) {\nfinal int temp = fmap[unLo];\nfmap[unLo++] = fmap[ltLo];\nfmap[ltLo++] = temp;\n} else if (n < 0) {\nunLo++;\n} else {\nbreak;\n}\n}\n\nwhile (unLo <= unHi) {\nfinal int n = (block[fmap[unHi] + d1] & 0xff)\n- med;\nif (n == 0) {\nfinal int temp = fmap[unHi];\nfmap[unHi--] = fmap[gtHi];\nfmap[gtHi--] = temp;\n} else if (n > 0) {\nunHi--;\n} else {\nbreak;\n}\n}\n\nif (unLo <= unHi) {\nfinal int temp = fmap[unLo];\nfmap[unLo++] = fmap[unHi];\nfmap[unHi--] = temp;\n} else {\nbreak;\n}\n}\n\nif (gtHi < ltLo) {\nstack_ll[sp] = lo;\nstack_hh[sp] = hi;\nstack_dd[sp] = d1;\nsp++;\n} else {\nint n = ((ltLo - lo) < (unLo - ltLo)) ? (ltLo - lo)\n: (unLo - ltLo);\nvswap(fmap, lo, unLo - n, n);\nint m = ((hi - gtHi) < (gtHi - unHi)) ? (hi - gtHi)\n: (gtHi - unHi);\nvswap(fmap, unLo, hi - m + 1, m);\n\nn = lo + unLo - ltLo - 1;\nm = hi - (gtHi - unHi) + 1;\n\nstack_ll[sp] = lo;\nstack_hh[sp] = n;\nstack_dd[sp] = d;\nsp++;\n\nstack_ll[sp] = n + 1;\nstack_hh[sp] = m - 1;\nstack_dd[sp] = d1;\nsp++;\n\nstack_ll[sp] = m;\nstack_hh[sp] = hi;\nstack_dd[sp] = d;\nsp++;\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:mainSort(Lorg/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream$Data;I)V",
                                    "method_body": "final void mainSort(final BZip2CompressorOutputStream.Data dataShadow,\nfinal int lastShadow) {\nfinal int[] runningOrder = this.mainSort_runningOrder;\nfinal int[] copy = this.mainSort_copy;\nfinal boolean[] bigDone = this.mainSort_bigDone;\nfinal int[] ftab = this.ftab;\nfinal byte[] block = dataShadow.block;\nfinal int[] fmap = dataShadow.fmap;\nfinal char[] quadrant = this.quadrant;\nfinal int workLimitShadow = this.workLimit;\nfinal boolean firstAttemptShadow = this.firstAttempt;\n\n// LBZ2: Set up the 2-byte frequency table\nfor (int i = 65537; --i >= 0;) {\nftab[i] = 0;\n}\n\n/*\n* In the various block-sized structures, live data runs from 0 to\n* last+NUM_OVERSHOOT_BYTES inclusive. First, set up the overshoot area\n* for block.\n*/\nfor (int i = 0; i < BZip2Constants.NUM_OVERSHOOT_BYTES; i++) {\nblock[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];\n}\nfor (int i = lastShadow + BZip2Constants.NUM_OVERSHOOT_BYTES +1; --i >= 0;) {\nquadrant[i] = 0;\n}\nblock[0] = block[lastShadow + 1];\n\n// LBZ2: Complete the initial radix sort:\n\nint c1 = block[0] & 0xff;\nfor (int i = 0; i <= lastShadow; i++) {\nfinal int c2 = block[i + 1] & 0xff;\nftab[(c1 << 8) + c2]++;\nc1 = c2;\n}\n\nfor (int i = 1; i <= 65536; i++) {\nftab[i] += ftab[i - 1];\n}\n\nc1 = block[1] & 0xff;\nfor (int i = 0; i < lastShadow; i++) {\nfinal int c2 = block[i + 2] & 0xff;\nfmap[--ftab[(c1 << 8) + c2]] = i;\nc1 = c2;\n}\n\nfmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;\n\n/*\n* LBZ2: Now ftab contains the first loc of every small bucket. Calculate the\n* running order, from smallest to largest big bucket.\n*/\nfor (int i = 256; --i >= 0;) {\nbigDone[i] = false;\nrunningOrder[i] = i;\n}\n\nfor (int h = 364; h != 1;) {\nh /= 3;\nfor (int i = h; i <= 255; i++) {\nfinal int vv = runningOrder[i];\nfinal int a = ftab[(vv + 1) << 8] - ftab[vv << 8];\nfinal int b = h - 1;\nint j = i;\nfor (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j\n- h]) {\nrunningOrder[j] = ro;\nj -= h;\nif (j <= b) {\nbreak;\n}\n}\nrunningOrder[j] = vv;\n}\n}\n\n/*\n* LBZ2: The main sorting loop.\n*/\nfor (int i = 0; i <= 255; i++) {\n/*\n* LBZ2: Process big buckets, starting with the least full.\n*/\nfinal int ss = runningOrder[i];\n\n// Step 1:\n/*\n* LBZ2: Complete the big bucket [ss] by quicksorting any unsorted small\n* buckets [ss, j]. Hopefully previous pointer-scanning phases have\n* already completed many of the small buckets [ss, j], so we don't\n* have to sort them at all.\n*/\nfor (int j = 0; j <= 255; j++) {\nfinal int sb = (ss << 8) + j;\nfinal int ftab_sb = ftab[sb];\nif ((ftab_sb & SETMASK) != SETMASK) {\nfinal int lo = ftab_sb & CLEARMASK;\nfinal int hi = (ftab[sb + 1] & CLEARMASK) - 1;\nif (hi > lo) {\nmainQSort3(dataShadow, lo, hi, 2, lastShadow);\nif (firstAttemptShadow\n&& (this.workDone > workLimitShadow)) {\nreturn;\n}\n}\nftab[sb] = ftab_sb | SETMASK;\n}\n}\n\n// Step 2:\n// LBZ2: Now scan this big bucket so as to synthesise the\n// sorted order for small buckets [t, ss] for all t != ss.\n\nfor (int j = 0; j <= 255; j++) {\ncopy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n}\n\nfor (int j = ftab[ss << 8] & CLEARMASK, hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++) {\nfinal int fmap_j = fmap[j];\nc1 = block[fmap_j] & 0xff;\nif (!bigDone[c1]) {\nfmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);\ncopy[c1]++;\n}\n}\n\nfor (int j = 256; --j >= 0;) {\nftab[(j << 8) + ss] |= SETMASK;\n}\n\n// Step 3:\n/*\n* LBZ2: The ss big bucket is now done. Record this fact, and update the\n* quadrant descriptors. Remember to update quadrants in the\n* overshoot area too, if necessary. The \"if (i < 255)\" test merely\n* skips this updating for the last bucket processed, since updating\n* for the last bucket is pointless.\n*/\nbigDone[ss] = true;\n\nif (i < 255) {\nfinal int bbStart = ftab[ss << 8] & CLEARMASK;\nfinal int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\nint shifts = 0;\n\nwhile ((bbSize >> shifts) > 65534) {\nshifts++;\n}\n\nfor (int j = 0; j < bbSize; j++) {\nfinal int a2update = fmap[bbStart + j];\nfinal char qVal = (char) (j >> shifts);\nquadrant[a2update] = qVal;\nif (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {\nquadrant[a2update + lastShadow + 1] = qVal;\n}\n}\n}\n\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.CompressorInputStream:count(I)V",
                                    "method_body": "protected void count(int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.CompressorInputStream:count(J)V",
                                    "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public BZip2CompressorInputStream(final InputStream in) throws IOException {\nthis(in, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:<init>(Ljava/io/InputStream;Z)V",
                                    "method_body": "public BZip2CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException {\nthis.in = in;\nthis.decompressConcatenated = decompressConcatenated;\n\ninit(true);\ninitBlock();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:read([BII)I",
                                    "method_body": "public int read(final byte[] dest, final int offs, final int len)\nthrows IOException {\nif (offs < 0) {\nthrow new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\");\n}\nif (len < 0) {\nthrow new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\");\n}\nif (offs + len > dest.length) {\nthrow new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\"\n+ len + \") > dest.length(\" + dest.length + \").\");\n}\nif (this.in == null) {\nthrow new IOException(\"stream closed\");\n}\n\nfinal int hi = offs + len;\nint destOffs = offs;\nint b;\nwhile (destOffs < hi && ((b = read0()) >= 0)) {\ndest[destOffs++] = (byte) b;\ncount(1);\n}\n\nint c = (destOffs == offs) ? -1 : (destOffs - offs);\nreturn c;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:makeMaps()V",
                                    "method_body": "private void makeMaps() {\nfinal boolean[] inUse = this.data.inUse;\nfinal byte[] seqToUnseq = this.data.seqToUnseq;\n\nint nInUseShadow = 0;\n\nfor (int i = 0; i < 256; i++) {\nif (inUse[i]) {\nseqToUnseq[nInUseShadow++] = (byte) i;\n}\n}\n\nthis.nInUse = nInUseShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:read0()I",
                                    "method_body": "private int read0() throws IOException {\nswitch (currentState) {\ncase EOF:\nreturn -1;\n\ncase START_BLOCK_STATE:\nreturn setupBlock();\n\ncase RAND_PART_A_STATE:\nthrow new IllegalStateException();\n\ncase RAND_PART_B_STATE:\nreturn setupRandPartB();\n\ncase RAND_PART_C_STATE:\nreturn setupRandPartC();\n\ncase NO_RAND_PART_A_STATE:\nthrow new IllegalStateException();\n\ncase NO_RAND_PART_B_STATE:\nreturn setupNoRandPartB();\n\ncase NO_RAND_PART_C_STATE:\nreturn setupNoRandPartC();\n\ndefault:\nthrow new IllegalStateException();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:init(Z)Z",
                                    "method_body": "private boolean init(boolean isFirstStream) throws IOException {\nif (null == in) {\nthrow new IOException(\"No InputStream\");\n}\n\nint magic0 = this.in.read();\nif (magic0 == -1 && !isFirstStream) {\nreturn false;\n}\nint magic1 = this.in.read();\nint magic2 = this.in.read();\n\nif (magic0 != 'B' || magic1 != 'Z' || magic2 != 'h') {\nthrow new IOException(isFirstStream\n? \"Stream is not in the BZip2 format\"\n: \"Garbage after a valid BZip2 stream\");\n}\n\nint blockSize = this.in.read();\nif ((blockSize < '1') || (blockSize > '9')) {\nthrow new IOException(\"BZip2 block size is invalid\");\n}\n\nthis.blockSize100k = blockSize - '0';\n\nthis.bsLive = 0;\nthis.computedCombinedCRC = 0;\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:initBlock()V",
                                    "method_body": "private void initBlock() throws IOException {\nchar magic0;\nchar magic1;\nchar magic2;\nchar magic3;\nchar magic4;\nchar magic5;\n\nwhile (true) {\n// Get the block magic bytes.\nmagic0 = bsGetUByte();\nmagic1 = bsGetUByte();\nmagic2 = bsGetUByte();\nmagic3 = bsGetUByte();\nmagic4 = bsGetUByte();\nmagic5 = bsGetUByte();\n\n// If isn't end of stream magic, break out of the loop.\nif (magic0 != 0x17 || magic1 != 0x72 || magic2 != 0x45\n|| magic3 != 0x38 || magic4 != 0x50 || magic5 != 0x90) {\nbreak;\n}\n\n// End of stream was reached. Check the combined CRC and\n// advance to the next .bz2 stream if decoding concatenated\n// streams.\nif (complete()) {\nreturn;\n}\n}\n\nif (magic0 != 0x31 || // '1'\nmagic1 != 0x41 || // ')'\nmagic2 != 0x59 || // 'Y'\nmagic3 != 0x26 || // '&'\nmagic4 != 0x53 || // 'S'\nmagic5 != 0x59 // 'Y'\n) {\nthis.currentState = EOF;\nthrow new IOException(\"bad block header\");\n} else {\nthis.storedBlockCRC = bsGetInt();\nthis.blockRandomised = bsR(1) == 1;\n\n/**\n* Allocate data here instead in constructor, so we do not allocate\n* it if the input file is empty.\n*/\nif (this.data == null) {\nthis.data = new Data(this.blockSize100k);\n}\n\n// currBlockNo++;\ngetAndMoveToFrontDecode();\n\nthis.crc.initialiseCRC();\nthis.currentState = START_BLOCK_STATE;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsR(I)I",
                                    "method_body": "private int bsR(final int n) throws IOException {\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nif (bsLiveShadow < n) {\nfinal InputStream inShadow = this.in;\ndo {\nint thech = inShadow.read();\n\nif (thech < 0) {\nthrow new IOException(\"unexpected end of stream\");\n}\n\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\n} while (bsLiveShadow < n);\n\nthis.bsBuff = bsBuffShadow;\n}\n\nthis.bsLive = bsLiveShadow - n;\nreturn (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsGetBit()Z",
                                    "method_body": "private boolean bsGetBit() throws IOException {\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nif (bsLiveShadow < 1) {\nint thech = this.in.read();\n\nif (thech < 0) {\nthrow new IOException(\"unexpected end of stream\");\n}\n\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\nthis.bsBuff = bsBuffShadow;\n}\n\nthis.bsLive = bsLiveShadow - 1;\nreturn ((bsBuffShadow >> (bsLiveShadow - 1)) & 1) != 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsGetUByte()C",
                                    "method_body": "private char bsGetUByte() throws IOException {\nreturn (char) bsR(8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsGetInt()I",
                                    "method_body": "private int bsGetInt() throws IOException {\nreturn (((((bsR(8) << 8) | bsR(8)) << 8) | bsR(8)) << 8) | bsR(8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:hbCreateDecodeTables([I[I[I[CIII)V",
                                    "method_body": "private static void hbCreateDecodeTables(final int[] limit,\nfinal int[] base, final int[] perm, final char[] length,\nfinal int minLen, final int maxLen, final int alphaSize) {\nfor (int i = minLen, pp = 0; i <= maxLen; i++) {\nfor (int j = 0; j < alphaSize; j++) {\nif (length[j] == i) {\nperm[pp++] = j;\n}\n}\n}\n\nfor (int i = MAX_CODE_LEN; --i > 0;) {\nbase[i] = 0;\nlimit[i] = 0;\n}\n\nfor (int i = 0; i < alphaSize; i++) {\nbase[length[i] + 1]++;\n}\n\nfor (int i = 1, b = base[0]; i < MAX_CODE_LEN; i++) {\nb += base[i];\nbase[i] = b;\n}\n\nfor (int i = minLen, vec = 0, b = base[i]; i <= maxLen; i++) {\nfinal int nb = base[i + 1];\nvec += nb - b;\nb = nb;\nlimit[i] = vec - 1;\nvec <<= 1;\n}\n\nfor (int i = minLen + 1; i <= maxLen; i++) {\nbase[i] = ((limit[i - 1] + 1) << 1) - base[i];\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:recvDecodingTables()V",
                                    "method_body": "private void recvDecodingTables() throws IOException {\nfinal Data dataShadow = this.data;\nfinal boolean[] inUse = dataShadow.inUse;\nfinal byte[] pos = dataShadow.recvDecodingTables_pos;\nfinal byte[] selector = dataShadow.selector;\nfinal byte[] selectorMtf = dataShadow.selectorMtf;\n\nint inUse16 = 0;\n\n/* Receive the mapping table */\nfor (int i = 0; i < 16; i++) {\nif (bsGetBit()) {\ninUse16 |= 1 << i;\n}\n}\n\nfor (int i = 256; --i >= 0;) {\ninUse[i] = false;\n}\n\nfor (int i = 0; i < 16; i++) {\nif ((inUse16 & (1 << i)) != 0) {\nfinal int i16 = i << 4;\nfor (int j = 0; j < 16; j++) {\nif (bsGetBit()) {\ninUse[i16 + j] = true;\n}\n}\n}\n}\n\nmakeMaps();\nfinal int alphaSize = this.nInUse + 2;\n\n/* Now the selectors */\nfinal int nGroups = bsR(3);\nfinal int nSelectors = bsR(15);\n\nfor (int i = 0; i < nSelectors; i++) {\nint j = 0;\nwhile (bsGetBit()) {\nj++;\n}\nselectorMtf[i] = (byte) j;\n}\n\n/* Undo the MTF values for the selectors. */\nfor (int v = nGroups; --v >= 0;) {\npos[v] = (byte) v;\n}\n\nfor (int i = 0; i < nSelectors; i++) {\nint v = selectorMtf[i] & 0xff;\nfinal byte tmp = pos[v];\nwhile (v > 0) {\n// nearly all times v is zero, 4 in most other cases\npos[v] = pos[v - 1];\nv--;\n}\npos[0] = tmp;\nselector[i] = tmp;\n}\n\nfinal char[][] len = dataShadow.temp_charArray2d;\n\n/* Now the coding tables */\nfor (int t = 0; t < nGroups; t++) {\nint curr = bsR(5);\nfinal char[] len_t = len[t];\nfor (int i = 0; i < alphaSize; i++) {\nwhile (bsGetBit()) {\ncurr += bsGetBit() ? -1 : 1;\n}\nlen_t[i] = (char) curr;\n}\n}\n\n// finally create the Huffman tables\ncreateHuffmanDecodingTables(alphaSize, nGroups);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:createHuffmanDecodingTables(II)V",
                                    "method_body": "private void createHuffmanDecodingTables(final int alphaSize,\nfinal int nGroups) {\nfinal Data dataShadow = this.data;\nfinal char[][] len = dataShadow.temp_charArray2d;\nfinal int[] minLens = dataShadow.minLens;\nfinal int[][] limit = dataShadow.limit;\nfinal int[][] base = dataShadow.base;\nfinal int[][] perm = dataShadow.perm;\n\nfor (int t = 0; t < nGroups; t++) {\nint minLen = 32;\nint maxLen = 0;\nfinal char[] len_t = len[t];\nfor (int i = alphaSize; --i >= 0;) {\nfinal char lent = len_t[i];\nif (lent > maxLen) {\nmaxLen = lent;\n}\nif (lent < minLen) {\nminLen = lent;\n}\n}\nhbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen,\nmaxLen, alphaSize);\nminLens[t] = minLen;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:getAndMoveToFrontDecode()V",
                                    "method_body": "private void getAndMoveToFrontDecode() throws IOException {\nthis.origPtr = bsR(24);\nrecvDecodingTables();\n\nfinal InputStream inShadow = this.in;\nfinal Data dataShadow = this.data;\nfinal byte[] ll8 = dataShadow.ll8;\nfinal int[] unzftab = dataShadow.unzftab;\nfinal byte[] selector = dataShadow.selector;\nfinal byte[] seqToUnseq = dataShadow.seqToUnseq;\nfinal char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\nfinal int[] minLens = dataShadow.minLens;\nfinal int[][] limit = dataShadow.limit;\nfinal int[][] base = dataShadow.base;\nfinal int[][] perm = dataShadow.perm;\nfinal int limitLast = this.blockSize100k * 100000;\n\n/*\n* Setting up the unzftab entries here is not strictly necessary, but it\n* does save having to do it later in a separate pass, and so saves a\n* block's worth of cache misses.\n*/\nfor (int i = 256; --i >= 0;) {\nyy[i] = (char) i;\nunzftab[i] = 0;\n}\n\nint groupNo = 0;\nint groupPos = G_SIZE - 1;\nfinal int eob = this.nInUse + 1;\nint nextSym = getAndMoveToFrontDecode0(0);\nint bsBuffShadow = this.bsBuff;\nint bsLiveShadow = this.bsLive;\nint lastShadow = -1;\nint zt = selector[groupNo] & 0xff;\nint[] base_zt = base[zt];\nint[] limit_zt = limit[zt];\nint[] perm_zt = perm[zt];\nint minLens_zt = minLens[zt];\n\nwhile (nextSym != eob) {\nif ((nextSym == RUNA) || (nextSym == RUNB)) {\nint s = -1;\n\nfor (int n = 1; true; n <<= 1) {\nif (nextSym == RUNA) {\ns += n;\n} else if (nextSym == RUNB) {\ns += n << 1;\n} else {\nbreak;\n}\n\nif (groupPos == 0) {\ngroupPos = G_SIZE - 1;\nzt = selector[++groupNo] & 0xff;\nbase_zt = base[zt];\nlimit_zt = limit[zt];\nperm_zt = perm[zt];\nminLens_zt = minLens[zt];\n} else {\ngroupPos--;\n}\n\nint zn = minLens_zt;\n\n// Inlined:\n// int zvec = bsR(zn);\nwhile (bsLiveShadow < zn) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\n} else {\nthrow new IOException(\"unexpected end of stream\");\n}\n}\nint zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n& ((1 << zn) - 1);\nbsLiveShadow -= zn;\n\nwhile (zvec > limit_zt[zn]) {\nzn++;\nwhile (bsLiveShadow < 1) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\n} else {\nthrow new IOException(\n\"unexpected end of stream\");\n}\n}\nbsLiveShadow--;\nzvec = (zvec << 1)\n| ((bsBuffShadow >> bsLiveShadow) & 1);\n}\nnextSym = perm_zt[zvec - base_zt[zn]];\n}\n\nfinal byte ch = seqToUnseq[yy[0]];\nunzftab[ch & 0xff] += s + 1;\n\nwhile (s-- >= 0) {\nll8[++lastShadow] = ch;\n}\n\nif (lastShadow >= limitLast) {\nthrow new IOException(\"block overrun\");\n}\n} else {\nif (++lastShadow >= limitLast) {\nthrow new IOException(\"block overrun\");\n}\n\nfinal char tmp = yy[nextSym - 1];\nunzftab[seqToUnseq[tmp] & 0xff]++;\nll8[lastShadow] = seqToUnseq[tmp];\n\n/*\n* This loop is hammered during decompression, hence avoid\n* native method call overhead of System.arraycopy for very\n* small ranges to copy.\n*/\nif (nextSym <= 16) {\nfor (int j = nextSym - 1; j > 0;) {\nyy[j] = yy[--j];\n}\n} else {\nSystem.arraycopy(yy, 0, yy, 1, nextSym - 1);\n}\n\nyy[0] = tmp;\n\nif (groupPos == 0) {\ngroupPos = G_SIZE - 1;\nzt = selector[++groupNo] & 0xff;\nbase_zt = base[zt];\nlimit_zt = limit[zt];\nperm_zt = perm[zt];\nminLens_zt = minLens[zt];\n} else {\ngroupPos--;\n}\n\nint zn = minLens_zt;\n\n// Inlined:\n// int zvec = bsR(zn);\nwhile (bsLiveShadow < zn) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\n} else {\nthrow new IOException(\"unexpected end of stream\");\n}\n}\nint zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n& ((1 << zn) - 1);\nbsLiveShadow -= zn;\n\nwhile (zvec > limit_zt[zn]) {\nzn++;\nwhile (bsLiveShadow < 1) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\n} else {\nthrow new IOException(\"unexpected end of stream\");\n}\n}\nbsLiveShadow--;\nzvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n}\nnextSym = perm_zt[zvec - base_zt[zn]];\n}\n}\n\nthis.last = lastShadow;\nthis.bsLive = bsLiveShadow;\nthis.bsBuff = bsBuffShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:getAndMoveToFrontDecode0(I)I",
                                    "method_body": "private int getAndMoveToFrontDecode0(final int groupNo) throws IOException {\nfinal InputStream inShadow = this.in;\nfinal Data dataShadow = this.data;\nfinal int zt = dataShadow.selector[groupNo] & 0xff;\nfinal int[] limit_zt = dataShadow.limit[zt];\nint zn = dataShadow.minLens[zt];\nint zvec = bsR(zn);\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nwhile (zvec > limit_zt[zn]) {\nzn++;\nwhile (bsLiveShadow < 1) {\nfinal int thech = inShadow.read();\n\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\n} else {\nthrow new IOException(\"unexpected end of stream\");\n}\n}\nbsLiveShadow--;\nzvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n}\n\nthis.bsLive = bsLiveShadow;\nthis.bsBuff = bsBuffShadow;\n\nreturn dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:setupBlock()I",
                                    "method_body": "private int setupBlock() throws IOException {\nif (currentState == EOF || this.data == null) {\nreturn -1;\n}\n\nfinal int[] cftab = this.data.cftab;\nfinal int[] tt = this.data.initTT(this.last + 1);\nfinal byte[] ll8 = this.data.ll8;\ncftab[0] = 0;\nSystem.arraycopy(this.data.unzftab, 0, cftab, 1, 256);\n\nfor (int i = 1, c = cftab[0]; i <= 256; i++) {\nc += cftab[i];\ncftab[i] = c;\n}\n\nfor (int i = 0, lastShadow = this.last; i <= lastShadow; i++) {\ntt[cftab[ll8[i] & 0xff]++] = i;\n}\n\nif ((this.origPtr < 0) || (this.origPtr >= tt.length)) {\nthrow new IOException(\"stream corrupted\");\n}\n\nthis.su_tPos = tt[this.origPtr];\nthis.su_count = 0;\nthis.su_i2 = 0;\nthis.su_ch2 = 256; /* not a char and not EOF */\n\nif (this.blockRandomised) {\nthis.su_rNToGo = 0;\nthis.su_rTPos = 0;\nreturn setupRandPartA();\n}\nreturn setupNoRandPartA();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:setupNoRandPartA()I",
                                    "method_body": "private int setupNoRandPartA() throws IOException {\nif (this.su_i2 <= this.last) {\nthis.su_chPrev = this.su_ch2;\nint su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;\nthis.su_ch2 = su_ch2Shadow;\nthis.su_tPos = this.data.tt[this.su_tPos];\nthis.su_i2++;\nthis.currentState = NO_RAND_PART_B_STATE;\nthis.crc.updateCRC(su_ch2Shadow);\nreturn su_ch2Shadow;\n} else {\nthis.currentState = NO_RAND_PART_A_STATE;\nendBlock();\ninitBlock();\nreturn setupBlock();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:setupNoRandPartB()I",
                                    "method_body": "private int setupNoRandPartB() throws IOException {\nif (this.su_ch2 != this.su_chPrev) {\nthis.su_count = 1;\nreturn setupNoRandPartA();\n} else if (++this.su_count >= 4) {\nthis.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff);\nthis.su_tPos = this.data.tt[this.su_tPos];\nthis.su_j2 = 0;\nreturn setupNoRandPartC();\n} else {\nreturn setupNoRandPartA();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream$Data:<init>(I)V",
                                    "method_body": "Data(int blockSize100k) {\nthis.ll8 = new byte[blockSize100k * BZip2Constants.BASEBLOCKSIZE];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream$Data:initTT(I)[I",
                                    "method_body": "int[] initTT(int length) {\nint[] ttShadow = this.tt;\n\n// tt.length should always be >= length, but theoretically\n// it can happen, if the compressor mixed small and large\n// blocks. Normally only the last block will be smaller\n// than others.\nif ((ttShadow == null) || (ttShadow.length < length)) {\nthis.tt = ttShadow = new int[length];\n}\n\nreturn ttShadow;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 31,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.TarTestCase.testCOMPRESS178",
                            "test_body": "319: public void testCOMPRESS178() throws Exception {\n320: final File input = getFile(\"COMPRESS-178.tar\");\n321: final InputStream is = new FileInputStream(input);\n322: final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"tar\", is);\n323: try {\n324: in.getNextEntry();\n325: fail(\"Expected IOException\");\n326: } catch (IOException e) {\n327: Throwable t = e.getCause();\n328: assertTrue(\"Expected cause = IllegalArgumentException\", t instanceof IllegalArgumentException);\n329: }\n330: in.close();\n331: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>()V",
                                    "method_body": "public ArchiveStreamFactory() {\nthis(null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ArchiveStreamFactory(String encoding) {\nsuper();\nthis.encoding = encoding;\n// Also set the original field so can continue to use it.\nthis.entryEncoding = encoding;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveInputStream(Ljava/lang/String;Ljava/io/InputStream;)Lorg/apache/commons/compress/archivers/ArchiveInputStream;",
                                    "method_body": "public ArchiveInputStream createArchiveInputStream(\nfinal String archiverName, final InputStream in)\nthrows ArchiveException {\n\nif (archiverName == null) {\nthrow new IllegalArgumentException(\"Archivername must not be null.\");\n}\n\nif (in == null) {\nthrow new IllegalArgumentException(\"InputStream must not be null.\");\n}\n\nif (AR.equalsIgnoreCase(archiverName)) {\nreturn new ArArchiveInputStream(in);\n}\nif (ARJ.equalsIgnoreCase(archiverName)) {\nif (entryEncoding != null) {\nreturn new ArjArchiveInputStream(in, entryEncoding);\n} else {\nreturn new ArjArchiveInputStream(in);\n}\n}\nif (ZIP.equalsIgnoreCase(archiverName)) {\nif (entryEncoding != null) {\nreturn new ZipArchiveInputStream(in, entryEncoding);\n} else {\nreturn new ZipArchiveInputStream(in);\n}\n}\nif (TAR.equalsIgnoreCase(archiverName)) {\nif (entryEncoding != null) {\nreturn new TarArchiveInputStream(in, entryEncoding);\n} else {\nreturn new TarArchiveInputStream(in);\n}\n}\nif (JAR.equalsIgnoreCase(archiverName)) {\nif (entryEncoding != null) {\nreturn new JarArchiveInputStream(in, entryEncoding);\n} else {\nreturn new JarArchiveInputStream(in);\n}\n}\nif (CPIO.equalsIgnoreCase(archiverName)) {\nif (entryEncoding != null) {\nreturn new CpioArchiveInputStream(in, entryEncoding);\n} else {\nreturn new CpioArchiveInputStream(in);\n}\n}\nif (DUMP.equalsIgnoreCase(archiverName)) {\nif (entryEncoding != null) {\nreturn new DumpArchiveInputStream(in, entryEncoding);\n} else {\nreturn new DumpArchiveInputStream(in);\n}\n}\nif (SEVEN_Z.equalsIgnoreCase(archiverName)) {\nthrow new StreamingNotSupportedException(SEVEN_Z);\n}\n\nthrow new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n\nstatic {\nMap<String, SimpleEncodingHolder> se =\nnew HashMap<String, SimpleEncodingHolder>();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for UTF-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h = simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\n// check platform's default encoding\ncharsetName = System.getProperty(\"file.encoding\");\n}\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}\nfor (String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data);\n} else {\nreturn new String(data,this.charsetName);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\n\n/**\n* <p>\n* Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\n* (either order accepted on input, big-endian used on output)\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, big-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, little-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\n\n/**\n* <p>\n* Eight-bit Unicode Transformation Format.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry() {\nString user = System.getProperty(\"user.name\", \"\");\n\nif (user.length() > MAX_NAMELEN) {\nuser = user.substring(0, MAX_NAMELEN);\n}\n\nthis.userName = user;\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public TarArchiveEntry(byte[] headerBuf, ZipEncoding encoding)\nthrows IOException {\nthis();\nparseTarHeader(headerBuf, encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNUSparse()Z",
                                    "method_body": "public boolean isGNUSparse() {\nreturn linkFlag == LF_GNUTYPE_SPARSE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongLinkEntry()Z",
                                    "method_body": "public boolean isGNULongLinkEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGLINK\n&& name.equals(GNU_LONGLINK);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongNameEntry()Z",
                                    "method_body": "public boolean isGNULongNameEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGNAME\n&& name.equals(GNU_LONGLINK);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isPaxHeader()Z",
                                    "method_body": "public boolean isPaxHeader(){\nreturn linkFlag == LF_PAX_EXTENDED_HEADER_LC\n|| linkFlag == LF_PAX_EXTENDED_HEADER_UC;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public void parseTarHeader(byte[] header, ZipEncoding encoding)\nthrows IOException {\nparseTarHeader(header, encoding, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;Z)V",
                                    "method_body": "private void parseTarHeader(byte[] header, ZipEncoding encoding,\nfinal boolean oldStyle)\nthrows IOException {\nint offset = 0;\n\nname = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n: TarUtils.parseName(header, offset, NAMELEN, encoding);\noffset += NAMELEN;\nmode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN);\noffset += MODELEN;\nuserId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\noffset += UIDLEN;\ngroupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\noffset += GIDLEN;\nsize = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\noffset += SIZELEN;\nmodTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN);\noffset += MODTIMELEN;\ncheckSumOK = TarUtils.verifyCheckSum(header);\noffset += CHKSUMLEN;\nlinkFlag = header[offset++];\nlinkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n: TarUtils.parseName(header, offset, NAMELEN, encoding);\noffset += NAMELEN;\nmagic = TarUtils.parseName(header, offset, MAGICLEN);\noffset += MAGICLEN;\nversion = TarUtils.parseName(header, offset, VERSIONLEN);\noffset += VERSIONLEN;\nuserName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)\n: TarUtils.parseName(header, offset, UNAMELEN, encoding);\noffset += UNAMELEN;\ngroupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN)\n: TarUtils.parseName(header, offset, GNAMELEN, encoding);\noffset += GNAMELEN;\ndevMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\ndevMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\n\nint type = evaluateType(header);\nswitch (type) {\ncase FORMAT_OLDGNU: {\noffset += ATIMELEN_GNU;\noffset += CTIMELEN_GNU;\noffset += OFFSETLEN_GNU;\noffset += LONGNAMESLEN_GNU;\noffset += PAD2LEN_GNU;\noffset += SPARSELEN_GNU;\nisExtended = TarUtils.parseBoolean(header, offset);\noffset += ISEXTENDEDLEN_GNU;\nrealSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU);\noffset += REALSIZELEN_GNU;\nbreak;\n}\ncase FORMAT_POSIX:\ndefault: {\nString prefix = oldStyle\n? TarUtils.parseName(header, offset, PREFIXLEN)\n: TarUtils.parseName(header, offset, PREFIXLEN, encoding);\n// SunOS tar -E does not add / to directory names, so fix\n// up to be consistent\nif (isDirectory() && !name.endsWith(\"/\")){\nname = name + \"/\";\n}\nif (prefix.length() > 0){\nname = prefix + \"/\" + name;\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:evaluateType([B)I",
                                    "method_body": "private int evaluateType(byte[] header) {\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_GNU, header, MAGIC_OFFSET, MAGICLEN)) {\nreturn FORMAT_OLDGNU;\n}\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_POSIX, header, MAGIC_OFFSET, MAGICLEN)) {\nreturn FORMAT_POSIX;\n}\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:<clinit>()V",
                                    "method_body": "private static final int BYTE_MASK = 255;\n\nstatic final ZipEncoding DEFAULT_ENCODING =\nZipEncodingHelper.getZipEncoding(null);\n\n/**\n* Encapsulates the algorithms used up to Commons Compress 1.3 as\n* ZipEncoding.\n*/\nstatic final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\npublic boolean canEncode(String name) { return true; }\n\npublic ByteBuffer encode(String name) {\nfinal int length = name.length();\nbyte[] buf = new byte[length];\n\n// copy until end of input or output is reached.\nfor (int i = 0; i < length; ++i) {\nbuf[i] = (byte) name.charAt(i);\n}\nreturn ByteBuffer.wrap(buf);\n}\n\npublic String decode(byte[] buffer) {\nfinal int length = buffer.length;\nStringBuilder result = new StringBuilder(length);\n\nfor (byte b : buffer) {\nif (b == 0) { // Trailing null\nbreak;\n}\nresult.append((char) (b & 0xFF)); // Allow for sign-extension\n}\n\nreturn result.toString();\n}\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\n\nif (length < 2){\nthrow new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n}\n\nif (buffer[start] == 0) {\nreturn 0L;\n}\n\n// Skip leading spaces\nwhile (start < end){\nif (buffer[start] == ' '){\nstart++;\n} else {\nbreak;\n}\n}\n\n// Trim all trailing NULs and spaces.\n// The ustar and POSIX tar specs require a trailing NUL or\n// space but some implementations use the extra digit for big\n// sizes/uids/gids ...\nbyte trailer = buffer[end - 1];\nwhile (start < end && (trailer == 0 || trailer == ' ')) {\nend--;\ntrailer = buffer[end - 1];\n}\n\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\nif (currentByte == 0) {\nbreak;\n}\n// CheckStyle:MagicNumber OFF\nif (currentByte < '0' || currentByte > '7'){\nthrow new IllegalArgumentException(\nexceptionMessage(buffer, offset, length, start, currentByte));\n}\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\n// CheckStyle:MagicNumber ON\n}\n\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctalOrBinary([BII)J",
                                    "method_body": "public static long parseOctalOrBinary(final byte[] buffer, final int offset,\nfinal int length) {\n\nif ((buffer[offset] & 0x80) == 0) {\nreturn parseOctal(buffer, offset, length);\n}\nfinal boolean negative = buffer[offset] == (byte) 0xff;\nif (length < 9) {\nreturn parseBinaryLong(buffer, offset, length, negative);\n}\nreturn parseBinaryBigInteger(buffer, offset, length, negative);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseBoolean([BI)Z",
                                    "method_body": "public static boolean parseBoolean(final byte[] buffer, final int offset) {\nreturn buffer[offset] == 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BII)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset, final int length) {\ntry {\nreturn parseName(buffer, offset, length, DEFAULT_ENCODING);\n} catch (IOException ex) {\ntry {\nreturn parseName(buffer, offset, length, FALLBACK_ENCODING);\n} catch (IOException ex2) {\n// impossible\nthrow new RuntimeException(ex2);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BIILorg/apache/commons/compress/archivers/zip/ZipEncoding;)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset,\nfinal int length,\nfinal ZipEncoding encoding)\nthrows IOException {\n\nint len = length;\nfor (; len > 0; len--) {\nif (buffer[offset + len - 1] != 0) {\nbreak;\n}\n}\nif (len > 0) {\nbyte[] b = new byte[len];\nSystem.arraycopy(buffer, offset, b, 0, len);\nreturn encoding.decode(b);\n}\nreturn \"\";\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:verifyCheckSum([B)Z",
                                    "method_body": "public static boolean verifyCheckSum(byte[] header) {\nlong storedSum = 0;\nlong unsignedSum = 0;\nlong signedSum = 0;\n\nint digits = 0;\nfor (int i = 0; i < header.length; i++) {\nbyte b = header[i];\nif (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\nif ('0' <= b && b <= '7' && digits++ < 6) {\nstoredSum = storedSum * 8 + b - '0';\n} else if (digits > 0) {\ndigits = 6; // only look at the first octal digit sequence\n}\nb = ' ';\n}\nunsignedSum += 0xff & b;\nsignedSum += b;\n}\n\nreturn storedSum == unsignedSum || storedSum == signedSum\n|| storedSum > unsignedSum; // COMPRESS-177\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:matchAsciiBuffer(Ljava/lang/String;[BII)Z",
                                    "method_body": "public static boolean matchAsciiBuffer(\nString expected, byte[] buffer, int offset, int length){\nbyte[] buffer1;\ntry {\nbuffer1 = expected.getBytes(CharsetNames.US_ASCII);\n} catch (UnsupportedEncodingException e) {\nthrow new RuntimeException(e); // Should not happen\n}\nreturn isEqual(buffer1, 0, buffer1.length, buffer, offset, length, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isEqual([BII[BIIZ)Z",
                                    "method_body": "public static boolean isEqual(\nfinal byte[] buffer1, final int offset1, final int length1,\nfinal byte[] buffer2, final int offset2, final int length2,\nboolean ignoreTrailingNulls){\nint minLen=length1 < length2 ? length1 : length2;\nfor (int i=0; i < minLen; i++){\nif (buffer1[offset1+i] != buffer2[offset2+i]){\nreturn false;\n}\n}\nif (length1 == length2){\nreturn true;\n}\nif (ignoreTrailingNulls){\nif (length1 > length2){\nfor(int i = length2; i < length1; i++){\nif (buffer1[offset1+i] != 0){\nreturn false;\n}\n}\n} else {\nfor(int i = length1; i < length2; i++){\nif (buffer2[offset2+i] != 0){\nreturn false;\n}\n}\n}\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isArrayZero([BI)Z",
                                    "method_body": "public static boolean isArrayZero(byte[] a, int size) {\nfor (int i = 0; i < size; i++) {\nif (a[i] != 0) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final int SKIP_BUF_SIZE = 4096;\n\n// This buffer does not need to be synchronised because it is write only; the contents are ignored\n// Does not affect Immutability\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n\n/** Private constructor to prevent instantiation of this utility class. */\nprivate IOUtils(){\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[B)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b) throws IOException {\nreturn readFully(input, b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b, int offset, int len)\nthrows IOException {\nif (len < 0 || offset < 0 || len + offset > b.length) {\nthrow new IndexOutOfBoundsException();\n}\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\nbreak;\n}\ncount += x;\n}\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is) {\nthis(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\nthis(is, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;IILjava/lang/String;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize,\nString encoding) {\nthis.is = is;\nthis.hasHitEOF = false;\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.recordSize = recordSize;\nthis.blockSize = blockSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextTarEntry()Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;",
                                    "method_body": "public TarArchiveEntry getNextTarEntry() throws IOException {\nif (hasHitEOF) {\nreturn null;\n}\n\nif (currEntry != null) {\n/* Skip will only go to the end of the current entry */\nIOUtils.skip(this, Long.MAX_VALUE);\n\n/* skip to the end of the last record */\nskipRecordPadding();\n}\n\nbyte[] headerBuf = getRecord();\n\nif (headerBuf == null) {\n/* hit EOF */\ncurrEntry = null;\nreturn null;\n}\n\ntry {\ncurrEntry = new TarArchiveEntry(headerBuf, zipEncoding);\n} catch (IllegalArgumentException e) {\nIOException ioe = new IOException(\"Error detected parsing the header\");\nioe.initCause(e);\nthrow ioe;\n}\n\nentryOffset = 0;\nentrySize = currEntry.getSize();\n\nif (currEntry.isGNULongLinkEntry()) {\nbyte[] longLinkData = getLongNameData();\nif (longLinkData == null) {\n// Bugzilla: 40334\n// Malformed tar file - long link entry name not followed by\n// entry\nreturn null;\n}\ncurrEntry.setLinkName(zipEncoding.decode(longLinkData));\n}\n\nif (currEntry.isGNULongNameEntry()) {\nbyte[] longNameData = getLongNameData();\nif (longNameData == null) {\n// Bugzilla: 40334\n// Malformed tar file - long entry name not followed by\n// entry\nreturn null;\n}\ncurrEntry.setName(zipEncoding.decode(longNameData));\n}\n\nif (currEntry.isPaxHeader()){ // Process Pax headers\npaxHeaders();\n}\n\nif (currEntry.isGNUSparse()){ // Process sparse files\nreadGNUSparse();\n}\n\n// If the size of the next element in the archive has changed\n// due to a new size being reported in the posix header\n// information, we update entrySize here so that it contains\n// the correct value.\nentrySize = currEntry.getSize();\n\nreturn currEntry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getRecord()[B",
                                    "method_body": "private byte[] getRecord() throws IOException {\nbyte[] headerBuf = readRecord();\nhasHitEOF = isEOFRecord(headerBuf);\nif (hasHitEOF && headerBuf != null) {\ntryToConsumeSecondEOFRecord();\nconsumeRemainderOfLastBlock();\nheaderBuf = null;\n}\nreturn headerBuf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:isEOFRecord([B)Z",
                                    "method_body": "protected boolean isEOFRecord(byte[] record) {\nreturn record == null || ArchiveUtils.isArrayZero(record, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:readRecord()[B",
                                    "method_body": "protected byte[] readRecord() throws IOException {\n\nbyte[] record = new byte[recordSize];\n\nint readNow = IOUtils.readFully(is, record);\ncount(readNow);\nif (readNow != recordSize) {\nreturn null;\n}\n\nreturn record;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextEntry()Lorg/apache/commons/compress/archivers/ArchiveEntry;",
                                    "method_body": "public ArchiveEntry getNextEntry() throws IOException {\nreturn getNextTarEntry();\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarUtilsTest.testParseOctalInvalid",
                            "test_body": "79: public void testParseOctalInvalid() throws Exception{\n80: byte [] buffer;\n81: buffer=new byte[0]; // empty byte array\n82: try {\n83: TarUtils.parseOctal(buffer,0, buffer.length);\n84: fail(\"Expected IllegalArgumentException - should be at least 2 bytes long\");\n85: } catch (IllegalArgumentException expected) {\n86: }\n87: buffer=new byte[]{0}; // 1-byte array\n88: try {\n89: TarUtils.parseOctal(buffer,0, buffer.length);\n90: fail(\"Expected IllegalArgumentException - should be at least 2 bytes long\");\n91: } catch (IllegalArgumentException expected) {\n92: }\n93: buffer = \"abcdef \".getBytes(CharsetNames.UTF_8); // Invalid input\n94: try {\n95: TarUtils.parseOctal(buffer,0, buffer.length);\n96: fail(\"Expected IllegalArgumentException\");\n97: } catch (IllegalArgumentException expected) {\n98: }\n99: buffer = \" 0 07 \".getBytes(CharsetNames.UTF_8); // Invalid - embedded space\n100: try {\n101: TarUtils.parseOctal(buffer,0, buffer.length);\n102: fail(\"Expected IllegalArgumentException - embedded space\");\n103: } catch (IllegalArgumentException expected) {\n104: }\n105: buffer = \" 0\\00007 \".getBytes(CharsetNames.UTF_8); // Invalid - embedded NUL\n106: try {\n107: TarUtils.parseOctal(buffer,0, buffer.length);\n108: fail(\"Expected IllegalArgumentException - embedded NUL\");\n109: } catch (IllegalArgumentException expected) {\n110: }\n111: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n\nstatic {\nMap<String, SimpleEncodingHolder> se =\nnew HashMap<String, SimpleEncodingHolder>();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for UTF-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h = simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\n// check platform's default encoding\ncharsetName = System.getProperty(\"file.encoding\");\n}\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}\nfor (String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\n\n/**\n* <p>\n* Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\n* (either order accepted on input, big-endian used on output)\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, big-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, little-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\n\n/**\n* <p>\n* Eight-bit Unicode Transformation Format.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:<clinit>()V",
                                    "method_body": "private static final int BYTE_MASK = 255;\n\nstatic final ZipEncoding DEFAULT_ENCODING =\nZipEncodingHelper.getZipEncoding(null);\n\n/**\n* Encapsulates the algorithms used up to Commons Compress 1.3 as\n* ZipEncoding.\n*/\nstatic final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\npublic boolean canEncode(String name) { return true; }\n\npublic ByteBuffer encode(String name) {\nfinal int length = name.length();\nbyte[] buf = new byte[length];\n\n// copy until end of input or output is reached.\nfor (int i = 0; i < length; ++i) {\nbuf[i] = (byte) name.charAt(i);\n}\nreturn ByteBuffer.wrap(buf);\n}\n\npublic String decode(byte[] buffer) {\nfinal int length = buffer.length;\nStringBuilder result = new StringBuilder(length);\n\nfor (byte b : buffer) {\nif (b == 0) { // Trailing null\nbreak;\n}\nresult.append((char) (b & 0xFF)); // Allow for sign-extension\n}\n\nreturn result.toString();\n}\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\n\nif (length < 2){\nthrow new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n}\n\nif (buffer[start] == 0) {\nreturn 0L;\n}\n\n// Skip leading spaces\nwhile (start < end){\nif (buffer[start] == ' '){\nstart++;\n} else {\nbreak;\n}\n}\n\n// Trim all trailing NULs and spaces.\n// The ustar and POSIX tar specs require a trailing NUL or\n// space but some implementations use the extra digit for big\n// sizes/uids/gids ...\nbyte trailer = buffer[end - 1];\nwhile (start < end && (trailer == 0 || trailer == ' ')) {\nend--;\ntrailer = buffer[end - 1];\n}\n\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\nif (currentByte == 0) {\nbreak;\n}\n// CheckStyle:MagicNumber OFF\nif (currentByte < '0' || currentByte > '7'){\nthrow new IllegalArgumentException(\nexceptionMessage(buffer, offset, length, start, currentByte));\n}\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\n// CheckStyle:MagicNumber ON\n}\n\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:exceptionMessage([BIIIB)Ljava/lang/String;",
                                    "method_body": "private static String exceptionMessage(byte[] buffer, final int offset,\nfinal int length, int current, final byte currentByte) {\n// default charset is good enough for an exception message,\n//\n// the alternative was to modify parseOctal and\n// parseOctalOrBinary to receive the ZipEncoding of the\n// archive (deprecating the existing public methods, of\n// course) and dealing with the fact that ZipEncoding#decode\n// can throw an IOException which parseOctal* doesn't declare\nString string = new String(buffer, offset, length);\n\nstring=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed\nfinal String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;\nreturn s;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 32,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest.shouldReadBigGid",
                            "test_body": "239: public void shouldReadBigGid() throws Exception {\n240: ByteArrayOutputStream bos = new ByteArrayOutputStream();\n241: TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n242: tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX);\n243: TarArchiveEntry t = new TarArchiveEntry(\"name\");\n244: t.setGroupId(4294967294l);\n245: t.setSize(1);\n246: tos.putArchiveEntry(t);\n247: tos.write(30);\n248: tos.closeArchiveEntry();\n249: tos.close();\n250: byte[] data = bos.toByteArray();\n251: ByteArrayInputStream bis = new ByteArrayInputStream(data);\n252: TarArchiveInputStream tis =\n253: new TarArchiveInputStream(bis);\n254: t = tis.getNextTarEntry();\n255: assertEquals(4294967294l, t.getLongGroupId());\n256: tis.close();\n257: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveOutputStream:write(I)V",
                                    "method_body": "public void write(int b) throws IOException {\noneByte[0] = (byte) (b & BYTE_MASK);\nwrite(oneByte, 0, 1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n\nstatic {\nMap<String, SimpleEncodingHolder> se =\nnew HashMap<String, SimpleEncodingHolder>();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for UTF-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h = simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\n// check platform's default encoding\ncharsetName = Charset.defaultCharset().name();\n}\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}\nfor (String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(String name) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn ByteBuffer.wrap(name.getBytes());\n} else {\nreturn ByteBuffer.wrap(name.getBytes(this.charsetName));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data);\n} else {\nreturn new String(data,this.charsetName);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\n\n/**\n* <p>\n* Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\n* (either order accepted on input, big-endian used on output)\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, big-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, little-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\n\n/**\n* <p>\n* Eight-bit Unicode Transformation Format.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry() {\nString user = System.getProperty(\"user.name\", \"\");\n\nif (user.length() > MAX_NAMELEN) {\nuser = user.substring(0, MAX_NAMELEN);\n}\n\nthis.userName = user;\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public TarArchiveEntry(String name) {\nthis(name, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/lang/String;Z)V",
                                    "method_body": "public TarArchiveEntry(String name, boolean preserveLeadingSlashes) {\nthis();\n\nname = normalizeFileName(name, preserveLeadingSlashes);\nboolean isDir = name.endsWith(\"/\");\n\nthis.name = name;\nthis.mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE;\nthis.linkFlag = isDir ? LF_DIR : LF_NORMAL;\nthis.modTime = new Date().getTime() / MILLIS_PER_SECOND;\nthis.userName = \"\";\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/lang/String;B)V",
                                    "method_body": "public TarArchiveEntry(String name, byte linkFlag) {\nthis(name, linkFlag, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/lang/String;BZ)V",
                                    "method_body": "public TarArchiveEntry(String name, byte linkFlag, boolean preserveLeadingSlashes) {\nthis(name, preserveLeadingSlashes);\nthis.linkFlag = linkFlag;\nif (linkFlag == LF_GNUTYPE_LONGNAME) {\nmagic = MAGIC_GNU;\nversion = VERSION_GNU_SPACE;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public TarArchiveEntry(byte[] headerBuf, ZipEncoding encoding)\nthrows IOException {\nthis();\nparseTarHeader(headerBuf, encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getLinkName()Ljava/lang/String;",
                                    "method_body": "public String getLinkName() {\nreturn linkName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getLongUserId()J",
                                    "method_body": "public long getLongUserId() {\nreturn userId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getLongGroupId()J",
                                    "method_body": "public long getLongGroupId() {\nreturn groupId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:setGroupId(J)V",
                                    "method_body": "public void setGroupId(long groupId) {\nthis.groupId = groupId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:setModTime(Ljava/util/Date;)V",
                                    "method_body": "public void setModTime(Date time) {\nmodTime = time.getTime() / MILLIS_PER_SECOND;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getModTime()Ljava/util/Date;",
                                    "method_body": "public Date getModTime() {\nreturn new Date(modTime * MILLIS_PER_SECOND);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getMode()I",
                                    "method_body": "public int getMode() {\nreturn mode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(long size) {\nif (size < 0){\nthrow new IllegalArgumentException(\"Size is out of range: \"+size);\n}\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getDevMajor()I",
                                    "method_body": "public int getDevMajor() {\nreturn devMajor;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getDevMinor()I",
                                    "method_body": "public int getDevMinor() {\nreturn devMinor;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNUSparse()Z",
                                    "method_body": "public boolean isGNUSparse() {\nreturn linkFlag == LF_GNUTYPE_SPARSE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongLinkEntry()Z",
                                    "method_body": "public boolean isGNULongLinkEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGLINK\n&& name.equals(GNU_LONGLINK);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongNameEntry()Z",
                                    "method_body": "public boolean isGNULongNameEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGNAME\n&& name.equals(GNU_LONGLINK);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isPaxHeader()Z",
                                    "method_body": "public boolean isPaxHeader(){\nreturn linkFlag == LF_PAX_EXTENDED_HEADER_LC\n|| linkFlag == LF_PAX_EXTENDED_HEADER_UC;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nif (file != null) {\nreturn file.isDirectory();\n}\n\nif (linkFlag == LF_DIR) {\nreturn true;\n}\n\nif (getName().endsWith(\"/\")) {\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:writeEntryHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;Z)V",
                                    "method_body": "public void writeEntryHeader(byte[] outbuf, ZipEncoding encoding,\nboolean starMode) throws IOException {\nint offset = 0;\n\noffset = TarUtils.formatNameBytes(name, outbuf, offset, NAMELEN,\nencoding);\noffset = writeEntryHeaderField(mode, outbuf, offset, MODELEN, starMode);\noffset = writeEntryHeaderField(userId, outbuf, offset, UIDLEN,\nstarMode);\noffset = writeEntryHeaderField(groupId, outbuf, offset, GIDLEN,\nstarMode);\noffset = writeEntryHeaderField(size, outbuf, offset, SIZELEN, starMode);\noffset = writeEntryHeaderField(modTime, outbuf, offset, MODTIMELEN,\nstarMode);\n\nint csOffset = offset;\n\nfor (int c = 0; c < CHKSUMLEN; ++c) {\noutbuf[offset++] = (byte) ' ';\n}\n\noutbuf[offset++] = linkFlag;\noffset = TarUtils.formatNameBytes(linkName, outbuf, offset, NAMELEN,\nencoding);\noffset = TarUtils.formatNameBytes(magic, outbuf, offset, MAGICLEN);\noffset = TarUtils.formatNameBytes(version, outbuf, offset, VERSIONLEN);\noffset = TarUtils.formatNameBytes(userName, outbuf, offset, UNAMELEN,\nencoding);\noffset = TarUtils.formatNameBytes(groupName, outbuf, offset, GNAMELEN,\nencoding);\noffset = writeEntryHeaderField(devMajor, outbuf, offset, DEVLEN,\nstarMode);\noffset = writeEntryHeaderField(devMinor, outbuf, offset, DEVLEN,\nstarMode);\n\nwhile (offset < outbuf.length) {\noutbuf[offset++] = 0;\n}\n\nlong chk = TarUtils.computeCheckSum(outbuf);\n\nTarUtils.formatCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:writeEntryHeaderField(J[BIIZ)I",
                                    "method_body": "private int writeEntryHeaderField(long value, byte[] outbuf, int offset,\nint length, boolean starMode) {\nif (!starMode && (value < 0\n|| value >= 1l << 3 * (length - 1))) {\n// value doesn't fit into field when written as octal\n// number, will be written to PAX header or causes an\n// error\nreturn TarUtils.formatLongOctalBytes(0, outbuf, offset, length);\n}\nreturn TarUtils.formatLongOctalOrBinaryBytes(value, outbuf, offset,\nlength);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public void parseTarHeader(byte[] header, ZipEncoding encoding)\nthrows IOException {\nparseTarHeader(header, encoding, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;Z)V",
                                    "method_body": "private void parseTarHeader(byte[] header, ZipEncoding encoding,\nfinal boolean oldStyle)\nthrows IOException {\nint offset = 0;\n\nname = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n: TarUtils.parseName(header, offset, NAMELEN, encoding);\noffset += NAMELEN;\nmode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN);\noffset += MODELEN;\nuserId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\noffset += UIDLEN;\ngroupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\noffset += GIDLEN;\nsize = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\noffset += SIZELEN;\nmodTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN);\noffset += MODTIMELEN;\ncheckSumOK = TarUtils.verifyCheckSum(header);\noffset += CHKSUMLEN;\nlinkFlag = header[offset++];\nlinkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n: TarUtils.parseName(header, offset, NAMELEN, encoding);\noffset += NAMELEN;\nmagic = TarUtils.parseName(header, offset, MAGICLEN);\noffset += MAGICLEN;\nversion = TarUtils.parseName(header, offset, VERSIONLEN);\noffset += VERSIONLEN;\nuserName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)\n: TarUtils.parseName(header, offset, UNAMELEN, encoding);\noffset += UNAMELEN;\ngroupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN)\n: TarUtils.parseName(header, offset, GNAMELEN, encoding);\noffset += GNAMELEN;\ndevMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\ndevMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\n\nint type = evaluateType(header);\nswitch (type) {\ncase FORMAT_OLDGNU: {\noffset += ATIMELEN_GNU;\noffset += CTIMELEN_GNU;\noffset += OFFSETLEN_GNU;\noffset += LONGNAMESLEN_GNU;\noffset += PAD2LEN_GNU;\noffset += SPARSELEN_GNU;\nisExtended = TarUtils.parseBoolean(header, offset);\noffset += ISEXTENDEDLEN_GNU;\nrealSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU);\noffset += REALSIZELEN_GNU;\nbreak;\n}\ncase FORMAT_POSIX:\ndefault: {\nString prefix = oldStyle\n? TarUtils.parseName(header, offset, PREFIXLEN)\n: TarUtils.parseName(header, offset, PREFIXLEN, encoding);\n// SunOS tar -E does not add / to directory names, so fix\n// up to be consistent\nif (isDirectory() && !name.endsWith(\"/\")){\nname = name + \"/\";\n}\nif (prefix.length() > 0){\nname = prefix + \"/\" + name;\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:normalizeFileName(Ljava/lang/String;Z)Ljava/lang/String;",
                                    "method_body": "private static String normalizeFileName(String fileName,\nboolean preserveLeadingSlashes) {\nString osname = System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH);\n\nif (osname != null) {\n\n// Strip off drive letters!\n// REVIEW Would a better check be \"(File.separator == '\\')\"?\n\nif (osname.startsWith(\"windows\")) {\nif (fileName.length() > 2) {\nchar ch1 = fileName.charAt(0);\nchar ch2 = fileName.charAt(1);\n\nif (ch2 == ':'\n&& (ch1 >= 'a' && ch1 <= 'z'\n|| ch1 >= 'A' && ch1 <= 'Z')) {\nfileName = fileName.substring(2);\n}\n}\n} else if (osname.contains(\"netware\")) {\nint colon = fileName.indexOf(':');\nif (colon != -1) {\nfileName = fileName.substring(colon + 1);\n}\n}\n}\n\nfileName = fileName.replace(File.separatorChar, '/');\n\n// No absolute pathnames\n// Windows (and Posix?) paths can start with \"\\\\NetworkDrive\\\",\n// so we loop on starting /'s.\nwhile (!preserveLeadingSlashes && fileName.startsWith(\"/\")) {\nfileName = fileName.substring(1);\n}\nreturn fileName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:evaluateType([B)I",
                                    "method_body": "private int evaluateType(byte[] header) {\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_GNU, header, MAGIC_OFFSET, MAGICLEN)) {\nreturn FORMAT_OLDGNU;\n}\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_POSIX, header, MAGIC_OFFSET, MAGICLEN)) {\nreturn FORMAT_POSIX;\n}\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public TarArchiveOutputStream(OutputStream os) {\nthis(os, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;II)V",
                                    "method_body": "public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) {\nthis(os, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;IILjava/lang/String;)V",
                                    "method_body": "public TarArchiveOutputStream(OutputStream os, int blockSize,\nint recordSize, String encoding) {\nout = new CountingOutputStream(os);\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n\nthis.assemLen = 0;\nthis.assemBuf = new byte[recordSize];\nthis.recordBuf = new byte[recordSize];\nthis.recordSize = recordSize;\nthis.recordsPerBlock = blockSize / recordSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<clinit>()V",
                                    "method_body": "public static final int LONGFILE_ERROR = 0;\n\n/** Long paths will be truncated in the archive. */\npublic static final int LONGFILE_TRUNCATE = 1;\n\n/** GNU tar extensions are used to store long file names in the archive. */\npublic static final int LONGFILE_GNU = 2;\n\n/** POSIX/PAX extensions are used to store long file names in the archive. */\npublic static final int LONGFILE_POSIX = 3;\n\n/** Fail if a big number (e.g. size &gt; 8GiB) is required in the archive. */\npublic static final int BIGNUMBER_ERROR = 0;\n\n/** star/GNU tar/BSD tar extensions are used to store big number in the archive. */\npublic static final int BIGNUMBER_STAR = 1;\n\n/** POSIX/PAX extensions are used to store big numbers in the archive. */\npublic static final int BIGNUMBER_POSIX = 2;\n\nprivate long      currSize;\nprivate String    currName;\nprivate long      currBytes;\nprivate final byte[]    recordBuf;\nprivate int       assemLen;\nprivate final byte[]    assemBuf;\nprivate int       longFileMode = LONGFILE_ERROR;\nprivate int       bigNumberMode = BIGNUMBER_ERROR;\nprivate int recordsWritten;\nprivate final int recordsPerBlock;\nprivate final int recordSize;\n\nprivate boolean closed = false;\n\n/** Indicates if putArchiveEntry has been called without closeArchiveEntry */\nprivate boolean haveUnclosedEntry = false;\n\n/** indicates if this archive is finished */\nprivate boolean finished = false;\n\nprivate final OutputStream out;\n\nprivate final ZipEncoding zipEncoding;\n\n// the provided encoding (for unit tests)\nfinal String encoding;\n\nprivate boolean addPaxHeadersForNonAsciiNames = false;\nprivate static final ZipEncoding ASCII =\nZipEncodingHelper.getZipEncoding(\"ASCII\");\n\n/**\n* Constructor for TarInputStream.\n* @param os the output stream to use\n*/\npublic TarArchiveOutputStream(OutputStream os) {\nthis(os, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:setBigNumberMode(I)V",
                                    "method_body": "public void setBigNumberMode(int bigNumberMode) {\nthis.bigNumberMode = bigNumberMode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif (finished) {\nthrow new IOException(\"This archive has already been finished\");\n}\n\nif (haveUnclosedEntry) {\nthrow new IOException(\"This archives contains unclosed entries.\");\n}\nwriteEOFRecord();\nwriteEOFRecord();\npadAsNeeded();\nout.flush();\nfinished = true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!finished) {\nfinish();\n}\n\nif (!closed) {\nout.close();\nclosed = true;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\nif (finished) {\nthrow new IOException(\"Stream has already been finished\");\n}\nTarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\nMap<String, String> paxHeaders = new HashMap<String, String>();\nfinal String entryName = entry.getName();\nboolean paxHeaderContainsPath = handleLongName(entry, entryName, paxHeaders, \"path\",\nTarConstants.LF_GNUTYPE_LONGNAME, \"file name\");\n\nfinal String linkName = entry.getLinkName();\nboolean paxHeaderContainsLinkPath = linkName != null && linkName.length() > 0\n&& handleLongName(entry, linkName, paxHeaders, \"linkpath\",\nTarConstants.LF_GNUTYPE_LONGLINK, \"link name\");\n\nif (bigNumberMode == BIGNUMBER_POSIX) {\naddPaxHeadersForBigNumbers(paxHeaders, entry);\n} else if (bigNumberMode != BIGNUMBER_STAR) {\nfailForBigNumbers(entry);\n}\n\nif (addPaxHeadersForNonAsciiNames && !paxHeaderContainsPath\n&& !ASCII.canEncode(entryName)) {\npaxHeaders.put(\"path\", entryName);\n}\n\nif (addPaxHeadersForNonAsciiNames && !paxHeaderContainsLinkPath\n&& (entry.isLink() || entry.isSymbolicLink())\n&& !ASCII.canEncode(linkName)) {\npaxHeaders.put(\"linkpath\", linkName);\n}\n\nif (paxHeaders.size() > 0) {\nwritePaxHeaders(entry, entryName, paxHeaders);\n}\n\nentry.writeEntryHeader(recordBuf, zipEncoding,\nbigNumberMode == BIGNUMBER_STAR);\nwriteRecord(recordBuf);\n\ncurrBytes = 0;\n\nif (entry.isDirectory()) {\ncurrSize = 0;\n} else {\ncurrSize = entry.getSize();\n}\ncurrName = entryName;\nhaveUnclosedEntry = true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\nif (finished) {\nthrow new IOException(\"Stream has already been finished\");\n}\nif (!haveUnclosedEntry){\nthrow new IOException(\"No current entry to close\");\n}\nif (assemLen > 0) {\nfor (int i = assemLen; i < assemBuf.length; ++i) {\nassemBuf[i] = 0;\n}\n\nwriteRecord(assemBuf);\n\ncurrBytes += assemLen;\nassemLen = 0;\n}\n\nif (currBytes < currSize) {\nthrow new IOException(\"entry '\" + currName + \"' closed at '\"\n+ currBytes\n+ \"' before the '\" + currSize\n+ \"' bytes specified in the header were written\");\n}\nhaveUnclosedEntry = false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\nif (!haveUnclosedEntry) {\nthrow new IllegalStateException(\"No current tar entry\");\n}\nif (currBytes + numToWrite > currSize) {\nthrow new IOException(\"request to write '\" + numToWrite\n+ \"' bytes exceeds size in header of '\"\n+ currSize + \"' bytes for entry '\"\n+ currName + \"'\");\n\n//\n// We have to deal with assembly!!!\n// The programmer can be writing little 32 byte chunks for all\n// we know, and we must assemble complete records for writing.\n// REVIEW Maybe this should be in TarBuffer? Could that help to\n// eliminate some of the buffer copying.\n//\n}\n\nif (assemLen > 0) {\nif (assemLen + numToWrite >= recordBuf.length) {\nint aLen = recordBuf.length - assemLen;\n\nSystem.arraycopy(assemBuf, 0, recordBuf, 0,\nassemLen);\nSystem.arraycopy(wBuf, wOffset, recordBuf,\nassemLen, aLen);\nwriteRecord(recordBuf);\n\ncurrBytes += recordBuf.length;\nwOffset += aLen;\nnumToWrite -= aLen;\nassemLen = 0;\n} else {\nSystem.arraycopy(wBuf, wOffset, assemBuf, assemLen,\nnumToWrite);\n\nwOffset += numToWrite;\nassemLen += numToWrite;\nnumToWrite = 0;\n}\n}\n\n//\n// When we get here we have EITHER:\n// o An empty \"assemble\" buffer.\n// o No bytes to write (numToWrite == 0)\n//\nwhile (numToWrite > 0) {\nif (numToWrite < recordBuf.length) {\nSystem.arraycopy(wBuf, wOffset, assemBuf, assemLen,\nnumToWrite);\n\nassemLen += numToWrite;\n\nbreak;\n}\n\nwriteRecord(wBuf, wOffset);\n\nint num = recordBuf.length;\n\ncurrBytes += num;\nnumToWrite -= num;\nwOffset += num;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:writePaxHeaders(Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;Ljava/lang/String;Ljava/util/Map;)V",
                                    "method_body": "void writePaxHeaders(TarArchiveEntry entry,\nString entryName,\nMap<String, String> headers) throws IOException {\nString name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\nif (name.length() >= TarConstants.NAMELEN) {\nname = name.substring(0, TarConstants.NAMELEN - 1);\n}\nTarArchiveEntry pex = new TarArchiveEntry(name,\nTarConstants.LF_PAX_EXTENDED_HEADER_LC);\ntransferModTime(entry, pex);\n\nStringWriter w = new StringWriter();\nfor (Map.Entry<String, String> h : headers.entrySet()) {\nString key = h.getKey();\nString value = h.getValue();\nint len = key.length() + value.length()\n+ 3 /* blank, equals and newline */\n+ 2 /* guess 9 < actual length < 100 */;\nString line = len + \" \" + key + \"=\" + value + \"\\n\";\nint actualLength = line.getBytes(CharsetNames.UTF_8).length;\nwhile (len != actualLength) {\n// Adjust for cases where length < 10 or > 100\n// or where UTF-8 encoding isn't a single octet\n// per character.\n// Must be in loop as size may go from 99 to 100 in\n// first pass so we'd need a second.\nlen = actualLength;\nline = len + \" \" + key + \"=\" + value + \"\\n\";\nactualLength = line.getBytes(CharsetNames.UTF_8).length;\n}\nw.write(line);\n}\nbyte[] data = w.toString().getBytes(CharsetNames.UTF_8);\npex.setSize(data.length);\nputArchiveEntry(pex);\nwrite(data);\ncloseArchiveEntry();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:stripTo7Bits(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private String stripTo7Bits(String name) {\nfinal int length = name.length();\nStringBuilder result = new StringBuilder(length);\nfor (int i = 0; i < length; i++) {\nchar stripped = (char) (name.charAt(i) & 0x7F);\nif (shouldBeReplaced(stripped)) {\nresult.append(\"_\");\n} else {\nresult.append(stripped);\n}\n}\nreturn result.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:shouldBeReplaced(C)Z",
                                    "method_body": "private boolean shouldBeReplaced(char c) {\nreturn c == 0 // would be read as Trailing null\n|| c == '/' // when used as last character TAE will consider the PAX header a directory\n|| c == '\\\\'; // same as '/' as slashes get \"normalized\" on Windows\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:writeEOFRecord()V",
                                    "method_body": "private void writeEOFRecord() throws IOException {\nArrays.fill(recordBuf, (byte) 0);\nwriteRecord(recordBuf);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:writeRecord([B)V",
                                    "method_body": "private void writeRecord(byte[] record) throws IOException {\nif (record.length != recordSize) {\nthrow new IOException(\"record to write has length '\"\n+ record.length\n+ \"' which is not the record size of '\"\n+ recordSize + \"'\");\n}\n\nout.write(record);\nrecordsWritten++;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:padAsNeeded()V",
                                    "method_body": "private void padAsNeeded() throws IOException {\nint start = recordsWritten % recordsPerBlock;\nif (start != 0) {\nfor (int i = start; i < recordsPerBlock; i++) {\nwriteEOFRecord();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:addPaxHeadersForBigNumbers(Ljava/util/Map;Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;)V",
                                    "method_body": "private void addPaxHeadersForBigNumbers(Map<String, String> paxHeaders,\nTarArchiveEntry entry) {\naddPaxHeaderForBigNumber(paxHeaders, \"size\", entry.getSize(),\nTarConstants.MAXSIZE);\naddPaxHeaderForBigNumber(paxHeaders, \"gid\", entry.getLongGroupId(),\nTarConstants.MAXID);\naddPaxHeaderForBigNumber(paxHeaders, \"mtime\",\nentry.getModTime().getTime() / 1000,\nTarConstants.MAXSIZE);\naddPaxHeaderForBigNumber(paxHeaders, \"uid\", entry.getLongUserId(),\nTarConstants.MAXID);\n// star extensions by J\\u00f6rg Schilling\naddPaxHeaderForBigNumber(paxHeaders, \"SCHILY.devmajor\",\nentry.getDevMajor(), TarConstants.MAXID);\naddPaxHeaderForBigNumber(paxHeaders, \"SCHILY.devminor\",\nentry.getDevMinor(), TarConstants.MAXID);\n// there is no PAX header for file mode\nfailForBigNumber(\"mode\", entry.getMode(), TarConstants.MAXID);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:addPaxHeaderForBigNumber(Ljava/util/Map;Ljava/lang/String;JJ)V",
                                    "method_body": "private void addPaxHeaderForBigNumber(Map<String, String> paxHeaders,\nString header, long value,\nlong maxValue) {\nif (value < 0 || value > maxValue) {\npaxHeaders.put(header, String.valueOf(value));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:failForBigNumber(Ljava/lang/String;JJ)V",
                                    "method_body": "private void failForBigNumber(String field, long value, long maxValue) {\nfailForBigNumber(field, value, maxValue, \"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:failForBigNumber(Ljava/lang/String;JJLjava/lang/String;)V",
                                    "method_body": "private void failForBigNumber(String field, long value, long maxValue, String additionalMsg) {\nif (value < 0 || value > maxValue) {\nthrow new RuntimeException(field + \" '\" + value\n+ \"' is too big ( > \"\n+ maxValue + \" ).\" + additionalMsg);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:handleLongName(Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;Ljava/lang/String;Ljava/util/Map;Ljava/lang/String;BLjava/lang/String;)Z",
                                    "method_body": "private boolean handleLongName(TarArchiveEntry entry , String name,\nMap<String, String> paxHeaders,\nString paxHeaderName, byte linkType, String fieldName)\nthrows IOException {\nfinal ByteBuffer encodedName = zipEncoding.encode(name);\nfinal int len = encodedName.limit() - encodedName.position();\nif (len >= TarConstants.NAMELEN) {\n\nif (longFileMode == LONGFILE_POSIX) {\npaxHeaders.put(paxHeaderName, name);\nreturn true;\n} else if (longFileMode == LONGFILE_GNU) {\n// create a TarEntry for the LongLink, the contents\n// of which are the link's name\nTarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK, linkType);\n\nlongLinkEntry.setSize(len + 1); // +1 for NUL\ntransferModTime(entry, longLinkEntry);\nputArchiveEntry(longLinkEntry);\nwrite(encodedName.array(), encodedName.arrayOffset(), len);\nwrite(0); // NUL terminator\ncloseArchiveEntry();\n} else if (longFileMode != LONGFILE_TRUNCATE) {\nthrow new RuntimeException(fieldName + \" '\" + name\n+ \"' is too long ( > \"\n+ TarConstants.NAMELEN + \" bytes)\");\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:transferModTime(Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;)V",
                                    "method_body": "private void transferModTime(TarArchiveEntry from, TarArchiveEntry to) {\nDate fromModTime = from.getModTime();\nlong fromModTimeSeconds = fromModTime.getTime() / 1000;\nif (fromModTimeSeconds < 0 || fromModTimeSeconds > TarConstants.MAXSIZE) {\nfromModTime = new Date(0);\n}\nto.setModTime(fromModTime);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:<init>(Ljava/nio/charset/Charset;)V",
                                    "method_body": "public NioZipEncoding(Charset charset) {\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public CountingOutputStream(final OutputStream out) {\nsuper(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:write([B)V",
                                    "method_body": "public void write(byte[] b) throws IOException {\nwrite(b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:write([BII)V",
                                    "method_body": "public void write(byte[] b, int off, int len) throws IOException {\nout.write(b, off, len);\ncount(len);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:count(J)V",
                                    "method_body": "protected void count(long written) {\nif (written != -1) {\nbytesWritten += written;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:<clinit>()V",
                                    "method_body": "private static final int BYTE_MASK = 255;\n\nstatic final ZipEncoding DEFAULT_ENCODING =\nZipEncodingHelper.getZipEncoding(null);\n\n/**\n* Encapsulates the algorithms used up to Commons Compress 1.3 as\n* ZipEncoding.\n*/\nstatic final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\npublic boolean canEncode(String name) { return true; }\n\npublic ByteBuffer encode(String name) {\nfinal int length = name.length();\nbyte[] buf = new byte[length];\n\n// copy until end of input or output is reached.\nfor (int i = 0; i < length; ++i) {\nbuf[i] = (byte) name.charAt(i);\n}\nreturn ByteBuffer.wrap(buf);\n}\n\npublic String decode(byte[] buffer) {\nfinal int length = buffer.length;\nStringBuilder result = new StringBuilder(length);\n\nfor (byte b : buffer) {\nif (b == 0) { // Trailing null\nbreak;\n}\nresult.append((char) (b & 0xFF)); // Allow for sign-extension\n}\n\nreturn result.toString();\n}\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\n\nif (length < 2){\nthrow new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n}\n\nif (buffer[start] == 0) {\nreturn 0L;\n}\n\n// Skip leading spaces\nwhile (start < end){\nif (buffer[start] == ' '){\nstart++;\n} else {\nbreak;\n}\n}\n\n// Trim all trailing NULs and spaces.\n// The ustar and POSIX tar specs require a trailing NUL or\n// space but some implementations use the extra digit for big\n// sizes/uids/gids ...\nbyte trailer = buffer[end - 1];\nwhile (start < end && (trailer == 0 || trailer == ' ')) {\nend--;\ntrailer = buffer[end - 1];\n}\n\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\n// CheckStyle:MagicNumber OFF\nif (currentByte < '0' || currentByte > '7'){\nthrow new IllegalArgumentException(\nexceptionMessage(buffer, offset, length, start, currentByte));\n}\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\n// CheckStyle:MagicNumber ON\n}\n\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctalOrBinary([BII)J",
                                    "method_body": "public static long parseOctalOrBinary(final byte[] buffer, final int offset,\nfinal int length) {\n\nif ((buffer[offset] & 0x80) == 0) {\nreturn parseOctal(buffer, offset, length);\n}\nfinal boolean negative = buffer[offset] == (byte) 0xff;\nif (length < 9) {\nreturn parseBinaryLong(buffer, offset, length, negative);\n}\nreturn parseBinaryBigInteger(buffer, offset, length, negative);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BII)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset, final int length) {\ntry {\nreturn parseName(buffer, offset, length, DEFAULT_ENCODING);\n} catch (IOException ex) {\ntry {\nreturn parseName(buffer, offset, length, FALLBACK_ENCODING);\n} catch (IOException ex2) {\n// impossible\nthrow new RuntimeException(ex2);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BIILorg/apache/commons/compress/archivers/zip/ZipEncoding;)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset,\nfinal int length,\nfinal ZipEncoding encoding)\nthrows IOException {\n\nint len = length;\nfor (; len > 0; len--) {\nif (buffer[offset + len - 1] != 0) {\nbreak;\n}\n}\nif (len > 0) {\nbyte[] b = new byte[len];\nSystem.arraycopy(buffer, offset, b, 0, len);\nreturn encoding.decode(b);\n}\nreturn \"\";\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatNameBytes(Ljava/lang/String;[BII)I",
                                    "method_body": "public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {\ntry {\nreturn formatNameBytes(name, buf, offset, length, DEFAULT_ENCODING);\n} catch (IOException ex) {\ntry {\nreturn formatNameBytes(name, buf, offset, length,\nFALLBACK_ENCODING);\n} catch (IOException ex2) {\n// impossible\nthrow new RuntimeException(ex2);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatNameBytes(Ljava/lang/String;[BIILorg/apache/commons/compress/archivers/zip/ZipEncoding;)I",
                                    "method_body": "public static int formatNameBytes(String name, byte[] buf, final int offset,\nfinal int length,\nfinal ZipEncoding encoding)\nthrows IOException {\nint len = name.length();\nByteBuffer b = encoding.encode(name);\nwhile (b.limit() > length && len > 0) {\nb = encoding.encode(name.substring(0, --len));\n}\nfinal int limit = b.limit() - b.position();\nSystem.arraycopy(b.array(), b.arrayOffset(), buf, offset, limit);\n\n// Pad any remaining output bytes with NUL\nfor (int i = limit; i < length; ++i) {\nbuf[offset + i] = 0;\n}\n\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatUnsignedOctalString(J[BII)V",
                                    "method_body": "public static void formatUnsignedOctalString(final long value, byte[] buffer,\nfinal int offset, final int length) {\nint remaining = length;\nremaining--;\nif (value == 0) {\nbuffer[offset + remaining--] = (byte) '0';\n} else {\nlong val = value;\nfor (; remaining >= 0 && val != 0; --remaining) {\n// CheckStyle:MagicNumber OFF\nbuffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));\nval = val >>> 3;\n// CheckStyle:MagicNumber ON\n}\nif (val != 0){\nthrow new IllegalArgumentException\n(value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length);\n}\n}\n\nfor (; remaining >= 0; --remaining) { // leading zeros\nbuffer[offset + remaining] = (byte) '0';\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatLongOctalBytes(J[BII)I",
                                    "method_body": "public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\nint idx=length-1; // For space\n\nformatUnsignedOctalString(value, buf, offset, idx);\nbuf[offset + idx] = (byte) ' '; // Trailing space\n\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatLongOctalOrBinaryBytes(J[BII)I",
                                    "method_body": "public static int formatLongOctalOrBinaryBytes(\nfinal long value, byte[] buf, final int offset, final int length) {\n\n// Check whether we are dealing with UID/GID or SIZE field\nfinal long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\nfinal boolean negative = value < 0;\nif (!negative && value <= maxAsOctalChar) { // OK to store as octal chars\nreturn formatLongOctalBytes(value, buf, offset, length);\n}\n\nif (length < 9) {\nformatLongBinary(value, buf, offset, length, negative);\n}\nformatBigIntegerBinary(value, buf, offset, length, negative);\n\nbuf[offset] = (byte) (negative ? 0xff : 0x80);\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatCheckSumOctalBytes(J[BII)I",
                                    "method_body": "public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\nint idx=length-2; // for NUL and space\nformatUnsignedOctalString(value, buf, offset, idx);\n\nbuf[offset + idx++]   = 0; // Trailing null\nbuf[offset + idx]     = (byte) ' '; // Trailing space\n\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:computeCheckSum([B)J",
                                    "method_body": "public static long computeCheckSum(final byte[] buf) {\nlong sum = 0;\n\nfor (byte element : buf) {\nsum += BYTE_MASK & element;\n}\n\nreturn sum;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:verifyCheckSum([B)Z",
                                    "method_body": "public static boolean verifyCheckSum(byte[] header) {\nlong storedSum = 0;\nlong unsignedSum = 0;\nlong signedSum = 0;\n\nint digits = 0;\nfor (int i = 0; i < header.length; i++) {\nbyte b = header[i];\nif (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\nif ('0' <= b && b <= '7' && digits++ < 6) {\nstoredSum = storedSum * 8 + b - '0';\n} else if (digits > 0) {\ndigits = 6; // only look at the first octal digit sequence\n}\nb = ' ';\n}\nunsignedSum += 0xff & b;\nsignedSum += b;\n}\n\nreturn storedSum == unsignedSum || storedSum == signedSum\n|| storedSum > unsignedSum; // COMPRESS-177\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:matchAsciiBuffer(Ljava/lang/String;[BII)Z",
                                    "method_body": "public static boolean matchAsciiBuffer(\nString expected, byte[] buffer, int offset, int length){\nbyte[] buffer1;\ntry {\nbuffer1 = expected.getBytes(CharsetNames.US_ASCII);\n} catch (UnsupportedEncodingException e) {\nthrow new RuntimeException(e); // Should not happen\n}\nreturn isEqual(buffer1, 0, buffer1.length, buffer, offset, length, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isEqual([BII[BIIZ)Z",
                                    "method_body": "public static boolean isEqual(\nfinal byte[] buffer1, final int offset1, final int length1,\nfinal byte[] buffer2, final int offset2, final int length2,\nboolean ignoreTrailingNulls){\nint minLen=length1 < length2 ? length1 : length2;\nfor (int i=0; i < minLen; i++){\nif (buffer1[offset1+i] != buffer2[offset2+i]){\nreturn false;\n}\n}\nif (length1 == length2){\nreturn true;\n}\nif (ignoreTrailingNulls){\nif (length1 > length2){\nfor(int i = length2; i < length1; i++){\nif (buffer1[offset1+i] != 0){\nreturn false;\n}\n}\n} else {\nfor(int i = length1; i < length2; i++){\nif (buffer2[offset2+i] != 0){\nreturn false;\n}\n}\n}\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isArrayZero([BI)Z",
                                    "method_body": "public static boolean isArrayZero(byte[] a, int size) {\nfor (int i = 0; i < size; i++) {\nif (a[i] != 0) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final int SKIP_BUF_SIZE = 4096;\n\n// This buffer does not need to be synchronised because it is write only; the contents are ignored\n// Does not affect Immutability\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n\n/** Private constructor to prevent instantiation of this utility class. */\nprivate IOUtils(){\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:skip(Ljava/io/InputStream;J)J",
                                    "method_body": "public static long skip(InputStream input, long numToSkip) throws IOException {\nlong available = numToSkip;\nwhile (numToSkip > 0) {\nlong skipped = input.skip(numToSkip);\nif (skipped == 0) {\nbreak;\n}\nnumToSkip -= skipped;\n}\n\nwhile (numToSkip > 0) {\nint read = readFully(input, SKIP_BUF, 0,\n(int) Math.min(numToSkip, SKIP_BUF_SIZE));\nif (read < 1) {\nbreak;\n}\nnumToSkip -= read;\n}\nreturn available - numToSkip;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[B)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b) throws IOException {\nreturn readFully(input, b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b, int offset, int len)\nthrows IOException {\nif (len < 0 || offset < 0 || len + offset > b.length) {\nthrow new IndexOutOfBoundsException();\n}\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\nbreak;\n}\ncount += x;\n}\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nint num = read(SINGLE, 0, 1);\nreturn num == -1 ? -1 : SINGLE[0] & BYTE_MASK;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is) {\nthis(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\nthis(is, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;IILjava/lang/String;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize,\nString encoding) {\nthis.is = is;\nthis.hasHitEOF = false;\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.recordSize = recordSize;\nthis.blockSize = blockSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:available()I",
                                    "method_body": "public int available() throws IOException {\nif (entrySize - entryOffset > Integer.MAX_VALUE) {\nreturn Integer.MAX_VALUE;\n}\nreturn (int) (entrySize - entryOffset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:skip(J)J",
                                    "method_body": "public long skip(final long n) throws IOException {\nif (n <= 0) {\nreturn 0;\n}\n\nfinal long available = entrySize - entryOffset;\nfinal long skipped = is.skip(Math.min(n, available));\ncount(skipped);\nentryOffset += skipped;\nreturn skipped;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextTarEntry()Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;",
                                    "method_body": "public TarArchiveEntry getNextTarEntry() throws IOException {\nif (hasHitEOF) {\nreturn null;\n}\n\nif (currEntry != null) {\n/* Skip will only go to the end of the current entry */\nIOUtils.skip(this, Long.MAX_VALUE);\n\n/* skip to the end of the last record */\nskipRecordPadding();\n}\n\nbyte[] headerBuf = getRecord();\n\nif (headerBuf == null) {\n/* hit EOF */\ncurrEntry = null;\nreturn null;\n}\n\ntry {\ncurrEntry = new TarArchiveEntry(headerBuf, zipEncoding);\n} catch (IllegalArgumentException e) {\nIOException ioe = new IOException(\"Error detected parsing the header\");\nioe.initCause(e);\nthrow ioe;\n}\n\nentryOffset = 0;\nentrySize = currEntry.getSize();\n\nif (currEntry.isGNULongLinkEntry()) {\nbyte[] longLinkData = getLongNameData();\nif (longLinkData == null) {\n// Bugzilla: 40334\n// Malformed tar file - long link entry name not followed by\n// entry\nreturn null;\n}\ncurrEntry.setLinkName(zipEncoding.decode(longLinkData));\n}\n\nif (currEntry.isGNULongNameEntry()) {\nbyte[] longNameData = getLongNameData();\nif (longNameData == null) {\n// Bugzilla: 40334\n// Malformed tar file - long entry name not followed by\n// entry\nreturn null;\n}\ncurrEntry.setName(zipEncoding.decode(longNameData));\n}\n\nif (currEntry.isPaxHeader()){ // Process Pax headers\npaxHeaders();\n}\n\nif (currEntry.isGNUSparse()){ // Process sparse files\nreadGNUSparse();\n}\n\n// If the size of the next element in the archive has changed\n// due to a new size being reported in the posix header\n// information, we update entrySize here so that it contains\n// the correct value.\nentrySize = currEntry.getSize();\n\nreturn currEntry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:skipRecordPadding()V",
                                    "method_body": "private void skipRecordPadding() throws IOException {\nif (this.entrySize > 0 && this.entrySize % this.recordSize != 0) {\nlong numRecords = (this.entrySize / this.recordSize) + 1;\nlong padding = (numRecords * this.recordSize) - this.entrySize;\nlong skipped = IOUtils.skip(is, padding);\ncount(skipped);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getRecord()[B",
                                    "method_body": "private byte[] getRecord() throws IOException {\nbyte[] headerBuf = readRecord();\nhasHitEOF = isEOFRecord(headerBuf);\nif (hasHitEOF && headerBuf != null) {\ntryToConsumeSecondEOFRecord();\nconsumeRemainderOfLastBlock();\nheaderBuf = null;\n}\nreturn headerBuf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:isEOFRecord([B)Z",
                                    "method_body": "protected boolean isEOFRecord(byte[] record) {\nreturn record == null || ArchiveUtils.isArrayZero(record, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:readRecord()[B",
                                    "method_body": "protected byte[] readRecord() throws IOException {\n\nbyte[] record = new byte[recordSize];\n\nint readNow = IOUtils.readFully(is, record);\ncount(readNow);\nif (readNow != recordSize) {\nreturn null;\n}\n\nreturn record;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:paxHeaders()V",
                                    "method_body": "private void paxHeaders() throws IOException{\nMap<String, String> headers = parsePaxHeaders(this);\ngetNextEntry(); // Get the actual file entry\napplyPaxHeadersToCurrentEntry(headers);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:parsePaxHeaders(Ljava/io/InputStream;)Ljava/util/Map;",
                                    "method_body": "Map<String, String> parsePaxHeaders(InputStream i) throws IOException {\nMap<String, String> headers = new HashMap<String, String>();\n// Format is \"length keyword=value\\n\";\nwhile(true){ // get length\nint ch;\nint len = 0;\nint read = 0;\nwhile((ch = i.read()) != -1) {\nread++;\nif (ch == ' '){ // End of length string\n// Get keyword\nByteArrayOutputStream coll = new ByteArrayOutputStream();\nwhile((ch = i.read()) != -1) {\nread++;\nif (ch == '='){ // end of keyword\nString keyword = coll.toString(CharsetNames.UTF_8);\n// Get rest of entry\nfinal int restLen = len - read;\nbyte[] rest = new byte[restLen];\nint got = IOUtils.readFully(i, rest);\nif (got != restLen) {\nthrow new IOException(\"Failed to read \"\n+ \"Paxheader. Expected \"\n+ restLen\n+ \" bytes, read \"\n+ got);\n}\n// Drop trailing NL\nString value = new String(rest, 0,\nrestLen - 1, CharsetNames.UTF_8);\nheaders.put(keyword, value);\nbreak;\n}\ncoll.write((byte) ch);\n}\nbreak; // Processed single header\n}\nlen *= 10;\nlen += ch - '0';\n}\nif (ch == -1){ // EOF\nbreak;\n}\n}\nreturn headers;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:applyPaxHeadersToCurrentEntry(Ljava/util/Map;)V",
                                    "method_body": "private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n/*\n* The following headers are defined for Pax.\n* atime, ctime, charset: cannot use these without changing TarArchiveEntry fields\n* mtime\n* comment\n* gid, gname\n* linkpath\n* size\n* uid,uname\n* SCHILY.devminor, SCHILY.devmajor: don't have setters/getters for those\n*/\nfor (Entry<String, String> ent : headers.entrySet()){\nString key = ent.getKey();\nString val = ent.getValue();\nif (\"path\".equals(key)){\ncurrEntry.setName(val);\n} else if (\"linkpath\".equals(key)){\ncurrEntry.setLinkName(val);\n} else if (\"gid\".equals(key)){\ncurrEntry.setGroupId(Integer.parseInt(val));\n} else if (\"gname\".equals(key)){\ncurrEntry.setGroupName(val);\n} else if (\"uid\".equals(key)){\ncurrEntry.setUserId(Integer.parseInt(val));\n} else if (\"uname\".equals(key)){\ncurrEntry.setUserName(val);\n} else if (\"size\".equals(key)){\ncurrEntry.setSize(Long.parseLong(val));\n} else if (\"mtime\".equals(key)){\ncurrEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n} else if (\"SCHILY.devminor\".equals(key)){\ncurrEntry.setDevMinor(Integer.parseInt(val));\n} else if (\"SCHILY.devmajor\".equals(key)){\ncurrEntry.setDevMajor(Integer.parseInt(val));\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextEntry()Lorg/apache/commons/compress/archivers/ArchiveEntry;",
                                    "method_body": "public ArchiveEntry getNextEntry() throws IOException {\nreturn getNextTarEntry();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:read([BII)I",
                                    "method_body": "public int read(byte[] buf, int offset, int numToRead) throws IOException {\nint totalRead = 0;\n\nif (hasHitEOF || entryOffset >= entrySize) {\nreturn -1;\n}\n\nif (currEntry == null) {\nthrow new IllegalStateException(\"No current tar entry\");\n}\n\nnumToRead = Math.min(numToRead, available());\n\ntotalRead = is.read(buf, offset, numToRead);\n\nif (totalRead == -1) {\nif (numToRead > 0) {\nthrow new IOException(\"Truncated TAR archive\");\n}\nhasHitEOF = true;\n} else {\ncount(totalRead);\nentryOffset += totalRead;\n}\n\nreturn totalRead;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 33,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.compressors.DetectCompressorTestCase.testDetection",
                            "test_body": "91: public void testDetection() throws Exception {\n92: CompressorInputStream bzip2 = getStreamFor(\"bla.txt.bz2\"); \n93: assertNotNull(bzip2);\n94: assertTrue(bzip2 instanceof BZip2CompressorInputStream);\n95: 96: CompressorInputStream gzip = getStreamFor(\"bla.tgz\");\n97: assertNotNull(gzip);\n98: assertTrue(gzip instanceof GzipCompressorInputStream);\n99: 100: CompressorInputStream pack200 = getStreamFor(\"bla.pack\");\n101: assertNotNull(pack200);\n102: assertTrue(pack200 instanceof Pack200CompressorInputStream);\n103: 104: CompressorInputStream xz = getStreamFor(\"bla.tar.xz\");\n105: assertNotNull(xz);\n106: assertTrue(xz instanceof XZCompressorInputStream);\n107: 108: CompressorInputStream zlib = getStreamFor(\"bla.tar.deflatez\");\n109: assertNotNull(zlib);\n110: assertTrue(zlib instanceof DeflateCompressorInputStream);\n111: 112: try {\n113: factory.createCompressorInputStream(new ByteArrayInputStream(new byte[0]));\n114: fail(\"No exception thrown for an empty input stream\");\n115: } catch (CompressorException e) {\n116: // expected\n117: }\n118: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final int SKIP_BUF_SIZE = 4096;\n\n// This buffer does not need to be synchronised because it is write only; the contents are ignored\n// Does not affect Immutability\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n\n/** Private constructor to prevent instantiation of this utility class. */\nprivate IOUtils(){\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[B)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b) throws IOException {\nreturn readFully(input, b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b, int offset, int len)\nthrows IOException {\nif (len < 0 || offset < 0 || len + offset > b.length) {\nthrow new IndexOutOfBoundsException();\n}\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\nbreak;\n}\ncount += x;\n}\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:<init>()V",
                                    "method_body": "CRC() {\ninitialiseCRC();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:<clinit>()V",
                                    "method_body": "private static final int crc32Table[] = {\n0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,\n0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,\n0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,\n0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,\n0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,\n0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,\n0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,\n0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,\n0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,\n0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,\n0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,\n0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,\n0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,\n0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,\n0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,\n0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,\n0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,\n0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,\n0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,\n0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,\n0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,\n0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,\n0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,\n0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,\n0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,\n0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,\n0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,\n0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,\n0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,\n0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,\n0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,\n0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,\n0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,\n0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,\n0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,\n0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,\n0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,\n0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,\n0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,\n0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,\n0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,\n0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,\n0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,\n0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,\n0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,\n0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,\n0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,\n0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,\n0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,\n0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,\n0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,\n0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,\n0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,\n0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,\n0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,\n0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,\n0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,\n0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,\n0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,\n0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,\n0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,\n0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,\n0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,\n0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:initialiseCRC()V",
                                    "method_body": "void initialiseCRC() {\nglobalCrc = 0xffffffff;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:<init>(Ljava/io/InputStream;Z)V",
                                    "method_body": "public BZip2CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException {\nthis.in = in;\nthis.decompressConcatenated = decompressConcatenated;\n\ninit(true);\ninitBlock();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:makeMaps()V",
                                    "method_body": "private void makeMaps() {\nfinal boolean[] inUse = this.data.inUse;\nfinal byte[] seqToUnseq = this.data.seqToUnseq;\n\nint nInUseShadow = 0;\n\nfor (int i = 0; i < 256; i++) {\nif (inUse[i]) {\nseqToUnseq[nInUseShadow++] = (byte) i;\n}\n}\n\nthis.nInUse = nInUseShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:init(Z)Z",
                                    "method_body": "private boolean init(boolean isFirstStream) throws IOException {\nif (null == in) {\nthrow new IOException(\"No InputStream\");\n}\n\nint magic0 = this.in.read();\nif (magic0 == -1 && !isFirstStream) {\nreturn false;\n}\nint magic1 = this.in.read();\nint magic2 = this.in.read();\n\nif (magic0 != 'B' || magic1 != 'Z' || magic2 != 'h') {\nthrow new IOException(isFirstStream\n? \"Stream is not in the BZip2 format\"\n: \"Garbage after a valid BZip2 stream\");\n}\n\nint blockSize = this.in.read();\nif ((blockSize < '1') || (blockSize > '9')) {\nthrow new IOException(\"BZip2 block size is invalid\");\n}\n\nthis.blockSize100k = blockSize - '0';\n\nthis.bsLive = 0;\nthis.computedCombinedCRC = 0;\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:initBlock()V",
                                    "method_body": "private void initBlock() throws IOException {\nchar magic0;\nchar magic1;\nchar magic2;\nchar magic3;\nchar magic4;\nchar magic5;\n\nwhile (true) {\n// Get the block magic bytes.\nmagic0 = bsGetUByte();\nmagic1 = bsGetUByte();\nmagic2 = bsGetUByte();\nmagic3 = bsGetUByte();\nmagic4 = bsGetUByte();\nmagic5 = bsGetUByte();\n\n// If isn't end of stream magic, break out of the loop.\nif (magic0 != 0x17 || magic1 != 0x72 || magic2 != 0x45\n|| magic3 != 0x38 || magic4 != 0x50 || magic5 != 0x90) {\nbreak;\n}\n\n// End of stream was reached. Check the combined CRC and\n// advance to the next .bz2 stream if decoding concatenated\n// streams.\nif (complete()) {\nreturn;\n}\n}\n\nif (magic0 != 0x31 || // '1'\nmagic1 != 0x41 || // ')'\nmagic2 != 0x59 || // 'Y'\nmagic3 != 0x26 || // '&'\nmagic4 != 0x53 || // 'S'\nmagic5 != 0x59 // 'Y'\n) {\nthis.currentState = EOF;\nthrow new IOException(\"bad block header\");\n} else {\nthis.storedBlockCRC = bsGetInt();\nthis.blockRandomised = bsR(1) == 1;\n\n/**\n* Allocate data here instead in constructor, so we do not allocate\n* it if the input file is empty.\n*/\nif (this.data == null) {\nthis.data = new Data(this.blockSize100k);\n}\n\n// currBlockNo++;\ngetAndMoveToFrontDecode();\n\nthis.crc.initialiseCRC();\nthis.currentState = START_BLOCK_STATE;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsR(I)I",
                                    "method_body": "private int bsR(final int n) throws IOException {\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nif (bsLiveShadow < n) {\nfinal InputStream inShadow = this.in;\ndo {\nint thech = inShadow.read();\n\nif (thech < 0) {\nthrow new IOException(\"unexpected end of stream\");\n}\n\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\n} while (bsLiveShadow < n);\n\nthis.bsBuff = bsBuffShadow;\n}\n\nthis.bsLive = bsLiveShadow - n;\nreturn (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsGetBit()Z",
                                    "method_body": "private boolean bsGetBit() throws IOException {\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nif (bsLiveShadow < 1) {\nint thech = this.in.read();\n\nif (thech < 0) {\nthrow new IOException(\"unexpected end of stream\");\n}\n\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\nthis.bsBuff = bsBuffShadow;\n}\n\nthis.bsLive = bsLiveShadow - 1;\nreturn ((bsBuffShadow >> (bsLiveShadow - 1)) & 1) != 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsGetUByte()C",
                                    "method_body": "private char bsGetUByte() throws IOException {\nreturn (char) bsR(8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsGetInt()I",
                                    "method_body": "private int bsGetInt() throws IOException {\nreturn (((((bsR(8) << 8) | bsR(8)) << 8) | bsR(8)) << 8) | bsR(8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:hbCreateDecodeTables([I[I[I[CIII)V",
                                    "method_body": "private static void hbCreateDecodeTables(final int[] limit,\nfinal int[] base, final int[] perm, final char[] length,\nfinal int minLen, final int maxLen, final int alphaSize) {\nfor (int i = minLen, pp = 0; i <= maxLen; i++) {\nfor (int j = 0; j < alphaSize; j++) {\nif (length[j] == i) {\nperm[pp++] = j;\n}\n}\n}\n\nfor (int i = MAX_CODE_LEN; --i > 0;) {\nbase[i] = 0;\nlimit[i] = 0;\n}\n\nfor (int i = 0; i < alphaSize; i++) {\nbase[length[i] + 1]++;\n}\n\nfor (int i = 1, b = base[0]; i < MAX_CODE_LEN; i++) {\nb += base[i];\nbase[i] = b;\n}\n\nfor (int i = minLen, vec = 0, b = base[i]; i <= maxLen; i++) {\nfinal int nb = base[i + 1];\nvec += nb - b;\nb = nb;\nlimit[i] = vec - 1;\nvec <<= 1;\n}\n\nfor (int i = minLen + 1; i <= maxLen; i++) {\nbase[i] = ((limit[i - 1] + 1) << 1) - base[i];\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:recvDecodingTables()V",
                                    "method_body": "private void recvDecodingTables() throws IOException {\nfinal Data dataShadow = this.data;\nfinal boolean[] inUse = dataShadow.inUse;\nfinal byte[] pos = dataShadow.recvDecodingTables_pos;\nfinal byte[] selector = dataShadow.selector;\nfinal byte[] selectorMtf = dataShadow.selectorMtf;\n\nint inUse16 = 0;\n\n/* Receive the mapping table */\nfor (int i = 0; i < 16; i++) {\nif (bsGetBit()) {\ninUse16 |= 1 << i;\n}\n}\n\nfor (int i = 256; --i >= 0;) {\ninUse[i] = false;\n}\n\nfor (int i = 0; i < 16; i++) {\nif ((inUse16 & (1 << i)) != 0) {\nfinal int i16 = i << 4;\nfor (int j = 0; j < 16; j++) {\nif (bsGetBit()) {\ninUse[i16 + j] = true;\n}\n}\n}\n}\n\nmakeMaps();\nfinal int alphaSize = this.nInUse + 2;\n\n/* Now the selectors */\nfinal int nGroups = bsR(3);\nfinal int nSelectors = bsR(15);\n\nfor (int i = 0; i < nSelectors; i++) {\nint j = 0;\nwhile (bsGetBit()) {\nj++;\n}\nselectorMtf[i] = (byte) j;\n}\n\n/* Undo the MTF values for the selectors. */\nfor (int v = nGroups; --v >= 0;) {\npos[v] = (byte) v;\n}\n\nfor (int i = 0; i < nSelectors; i++) {\nint v = selectorMtf[i] & 0xff;\nfinal byte tmp = pos[v];\nwhile (v > 0) {\n// nearly all times v is zero, 4 in most other cases\npos[v] = pos[v - 1];\nv--;\n}\npos[0] = tmp;\nselector[i] = tmp;\n}\n\nfinal char[][] len = dataShadow.temp_charArray2d;\n\n/* Now the coding tables */\nfor (int t = 0; t < nGroups; t++) {\nint curr = bsR(5);\nfinal char[] len_t = len[t];\nfor (int i = 0; i < alphaSize; i++) {\nwhile (bsGetBit()) {\ncurr += bsGetBit() ? -1 : 1;\n}\nlen_t[i] = (char) curr;\n}\n}\n\n// finally create the Huffman tables\ncreateHuffmanDecodingTables(alphaSize, nGroups);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:createHuffmanDecodingTables(II)V",
                                    "method_body": "private void createHuffmanDecodingTables(final int alphaSize,\nfinal int nGroups) {\nfinal Data dataShadow = this.data;\nfinal char[][] len = dataShadow.temp_charArray2d;\nfinal int[] minLens = dataShadow.minLens;\nfinal int[][] limit = dataShadow.limit;\nfinal int[][] base = dataShadow.base;\nfinal int[][] perm = dataShadow.perm;\n\nfor (int t = 0; t < nGroups; t++) {\nint minLen = 32;\nint maxLen = 0;\nfinal char[] len_t = len[t];\nfor (int i = alphaSize; --i >= 0;) {\nfinal char lent = len_t[i];\nif (lent > maxLen) {\nmaxLen = lent;\n}\nif (lent < minLen) {\nminLen = lent;\n}\n}\nhbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen,\nmaxLen, alphaSize);\nminLens[t] = minLen;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:getAndMoveToFrontDecode()V",
                                    "method_body": "private void getAndMoveToFrontDecode() throws IOException {\nthis.origPtr = bsR(24);\nrecvDecodingTables();\n\nfinal InputStream inShadow = this.in;\nfinal Data dataShadow = this.data;\nfinal byte[] ll8 = dataShadow.ll8;\nfinal int[] unzftab = dataShadow.unzftab;\nfinal byte[] selector = dataShadow.selector;\nfinal byte[] seqToUnseq = dataShadow.seqToUnseq;\nfinal char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\nfinal int[] minLens = dataShadow.minLens;\nfinal int[][] limit = dataShadow.limit;\nfinal int[][] base = dataShadow.base;\nfinal int[][] perm = dataShadow.perm;\nfinal int limitLast = this.blockSize100k * 100000;\n\n/*\n* Setting up the unzftab entries here is not strictly necessary, but it\n* does save having to do it later in a separate pass, and so saves a\n* block's worth of cache misses.\n*/\nfor (int i = 256; --i >= 0;) {\nyy[i] = (char) i;\nunzftab[i] = 0;\n}\n\nint groupNo = 0;\nint groupPos = G_SIZE - 1;\nfinal int eob = this.nInUse + 1;\nint nextSym = getAndMoveToFrontDecode0(0);\nint bsBuffShadow = this.bsBuff;\nint bsLiveShadow = this.bsLive;\nint lastShadow = -1;\nint zt = selector[groupNo] & 0xff;\nint[] base_zt = base[zt];\nint[] limit_zt = limit[zt];\nint[] perm_zt = perm[zt];\nint minLens_zt = minLens[zt];\n\nwhile (nextSym != eob) {\nif ((nextSym == RUNA) || (nextSym == RUNB)) {\nint s = -1;\n\nfor (int n = 1; true; n <<= 1) {\nif (nextSym == RUNA) {\ns += n;\n} else if (nextSym == RUNB) {\ns += n << 1;\n} else {\nbreak;\n}\n\nif (groupPos == 0) {\ngroupPos = G_SIZE - 1;\nzt = selector[++groupNo] & 0xff;\nbase_zt = base[zt];\nlimit_zt = limit[zt];\nperm_zt = perm[zt];\nminLens_zt = minLens[zt];\n} else {\ngroupPos--;\n}\n\nint zn = minLens_zt;\n\n// Inlined:\n// int zvec = bsR(zn);\nwhile (bsLiveShadow < zn) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\n} else {\nthrow new IOException(\"unexpected end of stream\");\n}\n}\nint zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n& ((1 << zn) - 1);\nbsLiveShadow -= zn;\n\nwhile (zvec > limit_zt[zn]) {\nzn++;\nwhile (bsLiveShadow < 1) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\n} else {\nthrow new IOException(\n\"unexpected end of stream\");\n}\n}\nbsLiveShadow--;\nzvec = (zvec << 1)\n| ((bsBuffShadow >> bsLiveShadow) & 1);\n}\nnextSym = perm_zt[zvec - base_zt[zn]];\n}\n\nfinal byte ch = seqToUnseq[yy[0]];\nunzftab[ch & 0xff] += s + 1;\n\nwhile (s-- >= 0) {\nll8[++lastShadow] = ch;\n}\n\nif (lastShadow >= limitLast) {\nthrow new IOException(\"block overrun\");\n}\n} else {\nif (++lastShadow >= limitLast) {\nthrow new IOException(\"block overrun\");\n}\n\nfinal char tmp = yy[nextSym - 1];\nunzftab[seqToUnseq[tmp] & 0xff]++;\nll8[lastShadow] = seqToUnseq[tmp];\n\n/*\n* This loop is hammered during decompression, hence avoid\n* native method call overhead of System.arraycopy for very\n* small ranges to copy.\n*/\nif (nextSym <= 16) {\nfor (int j = nextSym - 1; j > 0;) {\nyy[j] = yy[--j];\n}\n} else {\nSystem.arraycopy(yy, 0, yy, 1, nextSym - 1);\n}\n\nyy[0] = tmp;\n\nif (groupPos == 0) {\ngroupPos = G_SIZE - 1;\nzt = selector[++groupNo] & 0xff;\nbase_zt = base[zt];\nlimit_zt = limit[zt];\nperm_zt = perm[zt];\nminLens_zt = minLens[zt];\n} else {\ngroupPos--;\n}\n\nint zn = minLens_zt;\n\n// Inlined:\n// int zvec = bsR(zn);\nwhile (bsLiveShadow < zn) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\n} else {\nthrow new IOException(\"unexpected end of stream\");\n}\n}\nint zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n& ((1 << zn) - 1);\nbsLiveShadow -= zn;\n\nwhile (zvec > limit_zt[zn]) {\nzn++;\nwhile (bsLiveShadow < 1) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\n} else {\nthrow new IOException(\"unexpected end of stream\");\n}\n}\nbsLiveShadow--;\nzvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n}\nnextSym = perm_zt[zvec - base_zt[zn]];\n}\n}\n\nthis.last = lastShadow;\nthis.bsLive = bsLiveShadow;\nthis.bsBuff = bsBuffShadow;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:getAndMoveToFrontDecode0(I)I",
                                    "method_body": "private int getAndMoveToFrontDecode0(final int groupNo) throws IOException {\nfinal InputStream inShadow = this.in;\nfinal Data dataShadow = this.data;\nfinal int zt = dataShadow.selector[groupNo] & 0xff;\nfinal int[] limit_zt = dataShadow.limit[zt];\nint zn = dataShadow.minLens[zt];\nint zvec = bsR(zn);\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nwhile (zvec > limit_zt[zn]) {\nzn++;\nwhile (bsLiveShadow < 1) {\nfinal int thech = inShadow.read();\n\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\n} else {\nthrow new IOException(\"unexpected end of stream\");\n}\n}\nbsLiveShadow--;\nzvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n}\n\nthis.bsLive = bsLiveShadow;\nthis.bsBuff = bsBuffShadow;\n\nreturn dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\n\nif (length < 3) {\nreturn false;\n}\n\nif (signature[0] != 'B') {\nreturn false;\n}\n\nif (signature[1] != 'Z') {\nreturn false;\n}\n\nif (signature[2] != 'h') {\nreturn false;\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream$Data:<init>(I)V",
                                    "method_body": "Data(int blockSize100k) {\nthis.ll8 = new byte[blockSize100k * BZip2Constants.BASEBLOCKSIZE];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream:<init>(Ljava/io/InputStream;Z)V",
                                    "method_body": "public GzipCompressorInputStream(InputStream inputStream,\nboolean decompressConcatenated)\nthrows IOException {\n// Mark support is strictly needed for concatenated files only,\n// but it's simpler if it is always available.\nif (inputStream.markSupported()) {\nin = inputStream;\n} else {\nin = new BufferedInputStream(inputStream);\n}\n\nthis.decompressConcatenated = decompressConcatenated;\ninit(true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream:init(Z)Z",
                                    "method_body": "private boolean init(boolean isFirstMember) throws IOException {\nassert isFirstMember || decompressConcatenated;\n\n// Check the magic bytes without a possibility of EOFException.\nint magic0 = in.read();\nint magic1 = in.read();\n\n// If end of input was reached after decompressing at least\n// one .gz member, we have reached the end of the file successfully.\nif (magic0 == -1 && !isFirstMember) {\nreturn false;\n}\n\nif (magic0 != 31 || magic1 != 139) {\nthrow new IOException(isFirstMember\n? \"Input is not in the .gz format\"\n: \"Garbage after a valid .gz stream\");\n}\n\n// Parsing the rest of the header may throw EOFException.\nDataInputStream inData = new DataInputStream(in);\nint method = inData.readUnsignedByte();\nif (method != Deflater.DEFLATED) {\nthrow new IOException(\"Unsupported compression method \"\n+ method + \" in the .gz header\");\n}\n\nint flg = inData.readUnsignedByte();\nif ((flg & FRESERVED) != 0) {\nthrow new IOException(\n\"Reserved flags are set in the .gz header\");\n}\n\nparameters.setModificationTime(readLittleEndianInt(inData) * 1000);\nswitch (inData.readUnsignedByte()) { // extra flags\ncase 2:\nparameters.setCompressionLevel(Deflater.BEST_COMPRESSION);\nbreak;\ncase 4:\nparameters.setCompressionLevel(Deflater.BEST_SPEED);\nbreak;\ndefault:\n// ignored for now\nbreak;\n}\nparameters.setOperatingSystem(inData.readUnsignedByte());\n\n// Extra field, ignored\nif ((flg & FEXTRA) != 0) {\nint xlen = inData.readUnsignedByte();\nxlen |= inData.readUnsignedByte() << 8;\n\n// This isn't as efficient as calling in.skip would be,\n// but it's lazier to handle unexpected end of input this way.\n// Most files don't have an extra field anyway.\nwhile (xlen-- > 0) {\ninData.readUnsignedByte();\n}\n}\n\n// Original file name\nif ((flg & FNAME) != 0) {\nparameters.setFilename(new String(readToNull(inData),\nCharsetNames.ISO_8859_1));\n}\n\n// Comment\nif ((flg & FCOMMENT) != 0) {\nparameters.setComment(new String(readToNull(inData),\nCharsetNames.ISO_8859_1));\n}\n\n// Header \"CRC16\" which is actually a truncated CRC32 (which isn't\n// as good as real CRC16). I don't know if any encoder implementation\n// sets this, so it's not worth trying to verify it. GNU gzip 1.4\n// doesn't support this field, but zlib seems to be able to at least\n// skip over it.\nif ((flg & FHCRC) != 0) {\ninData.readShort();\n}\n\n// Reset\ninf.reset();\ncrc.reset();\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream:readLittleEndianInt(Ljava/io/DataInputStream;)J",
                                    "method_body": "private long readLittleEndianInt(DataInputStream inData) throws IOException {\nreturn inData.readUnsignedByte()\n| (inData.readUnsignedByte() << 8)\n| (inData.readUnsignedByte() << 16)\n| (((long) inData.readUnsignedByte()) << 24);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\n\nif (length < 2) {\nreturn false;\n}\n\nif (signature[0] != 31) {\nreturn false;\n}\n\nif (signature[1] != -117) {\nreturn false;\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.gzip.GzipParameters:setModificationTime(J)V",
                                    "method_body": "public void setModificationTime(long modificationTime) {\nthis.modificationTime = modificationTime;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.gzip.GzipParameters:setOperatingSystem(I)V",
                                    "method_body": "public void setOperatingSystem(int operatingSystem) {\nthis.operatingSystem = operatingSystem;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.CompressorStreamFactory:<init>()V",
                                    "method_body": "public CompressorStreamFactory() {\nthis.decompressUntilEOF = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.CompressorStreamFactory:<init>(Z)V",
                                    "method_body": "public CompressorStreamFactory(boolean decompressUntilEOF) {\nthis.decompressUntilEOF = Boolean.valueOf(decompressUntilEOF);\n// Also copy to existing variable so can continue to use that as the current value\nthis.decompressConcatenated = decompressUntilEOF;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.CompressorStreamFactory:setDecompressConcatenated(Z)V",
                                    "method_body": "public void setDecompressConcatenated(boolean decompressConcatenated) {\nif (this.decompressUntilEOF != null) {\nthrow new IllegalStateException(\"Cannot override the setting defined by the constructor\");\n}\nthis.decompressConcatenated = decompressConcatenated;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.CompressorStreamFactory:createCompressorInputStream(Ljava/io/InputStream;)Lorg/apache/commons/compress/compressors/CompressorInputStream;",
                                    "method_body": "public CompressorInputStream createCompressorInputStream(final InputStream in)\nthrows CompressorException {\nif (in == null) {\nthrow new IllegalArgumentException(\"Stream must not be null.\");\n}\n\nif (!in.markSupported()) {\nthrow new IllegalArgumentException(\"Mark is not supported.\");\n}\n\nfinal byte[] signature = new byte[12];\nin.mark(signature.length);\ntry {\nint signatureLength = IOUtils.readFully(in, signature);\nin.reset();\n\nif (BZip2CompressorInputStream.matches(signature, signatureLength)) {\nreturn new BZip2CompressorInputStream(in, decompressConcatenated);\n}\n\nif (GzipCompressorInputStream.matches(signature, signatureLength)) {\nreturn new GzipCompressorInputStream(in, decompressConcatenated);\n}\n\nif (Pack200CompressorInputStream.matches(signature, signatureLength)) {\nreturn new Pack200CompressorInputStream(in);\n}\n\nif (FramedSnappyCompressorInputStream.matches(signature, signatureLength)) {\nreturn new FramedSnappyCompressorInputStream(in);\n}\n\nif (ZCompressorInputStream.matches(signature, signatureLength)) {\nreturn new ZCompressorInputStream(in);\n}\n\n\nif (XZUtils.matches(signature, signatureLength) &&\nXZUtils.isXZCompressionAvailable()) {\nreturn new XZCompressorInputStream(in, decompressConcatenated);\n}\n\nif (LZMAUtils.matches(signature, signatureLength) &&\nLZMAUtils.isLZMACompressionAvailable()) {\nreturn new LZMACompressorInputStream(in);\n}\n\n} catch (IOException e) {\nthrow new CompressorException(\"Failed to detect Compressor from InputStream.\", e);\n}\n\nthrow new CompressorException(\"No Compressor found for the stream signature.\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.pack200.Pack200CompressorInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public Pack200CompressorInputStream(final InputStream in)\nthrows IOException {\nthis(in, Pack200Strategy.IN_MEMORY);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.pack200.Pack200CompressorInputStream:<init>(Ljava/io/InputStream;Lorg/apache/commons/compress/compressors/pack200/Pack200Strategy;)V",
                                    "method_body": "public Pack200CompressorInputStream(final InputStream in,\nfinal Pack200Strategy mode)\nthrows IOException {\nthis(in, null, mode, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.pack200.Pack200CompressorInputStream:<init>(Ljava/io/InputStream;Ljava/io/File;Lorg/apache/commons/compress/compressors/pack200/Pack200Strategy;Ljava/util/Map;)V",
                                    "method_body": "private Pack200CompressorInputStream(final InputStream in, final File f,\nfinal Pack200Strategy mode,\nfinal Map<String, String> props)\nthrows IOException {\noriginalInput = in;\nstreamBridge = mode.newStreamBridge();\nJarOutputStream jarOut = new JarOutputStream(streamBridge);\nPack200.Unpacker u = Pack200.newUnpacker();\nif (props != null) {\nu.properties().putAll(props);\n}\nif (f == null) {\nu.unpack(new FilterInputStream(in) {\n@Override\npublic void close() {\n// unpack would close this stream but we\n// want to give the user code more control\n}\n},\njarOut);\n} else {\nu.unpack(f, jarOut);\n}\njarOut.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.pack200.Pack200CompressorInputStream:<clinit>()V",
                                    "method_body": "private static final byte[] CAFE_DOOD = new byte[] {\n(byte) 0xCA, (byte) 0xFE, (byte) 0xD0, (byte) 0x0D\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.pack200.Pack200CompressorInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < SIG_LENGTH) {\nreturn false;\n}\n\nfor (int i = 0; i < SIG_LENGTH; i++) {\nif (signature[i] != CAFE_DOOD[i]) {\nreturn false;\n}\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.pack200.Pack200Strategy$1:newStreamBridge()Lorg/apache/commons/compress/compressors/pack200/StreamBridge;",
                                    "method_body": "StreamBridge newStreamBridge() {\nreturn new InMemoryCachingStreamBridge();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.pack200.StreamBridge:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "protected StreamBridge(OutputStream out) {\nsuper(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.pack200.InMemoryCachingStreamBridge:<init>()V",
                                    "method_body": "InMemoryCachingStreamBridge() {\nsuper(new ByteArrayOutputStream());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.pack200.Pack200CompressorInputStream$1:close()V",
                                    "method_body": "public void close() {\n// unpack would close this stream but we\n// want to give the user code more control\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.snappy.FramedSnappyCompressorInputStream:<clinit>()V",
                                    "method_body": "static final long MASK_OFFSET = 0xa282ead8L;\n\nprivate static final int STREAM_IDENTIFIER_TYPE = 0xff;\nprivate static final int COMPRESSED_CHUNK_TYPE = 0;\nprivate static final int UNCOMPRESSED_CHUNK_TYPE = 1;\nprivate static final int PADDING_CHUNK_TYPE = 0xfe;\nprivate static final int MIN_UNSKIPPABLE_TYPE = 2;\nprivate static final int MAX_UNSKIPPABLE_TYPE = 0x7f;\nprivate static final int MAX_SKIPPABLE_TYPE = 0xfd;\n\nprivate static final byte[] SZ_SIGNATURE = new byte[] {\n(byte) STREAM_IDENTIFIER_TYPE, // tag\n6, 0, 0, // length\n's', 'N', 'a', 'P', 'p', 'Y'\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.snappy.FramedSnappyCompressorInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\n\nif (length < SZ_SIGNATURE.length) {\nreturn false;\n}\n\nbyte[] shortenedSig = signature;\nif (signature.length > SZ_SIGNATURE.length) {\nshortenedSig = new byte[SZ_SIGNATURE.length];\nSystem.arraycopy(signature, 0, shortenedSig, 0, SZ_SIGNATURE.length);\n}\n\nreturn Arrays.equals(shortenedSig, SZ_SIGNATURE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.z.ZCompressorInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nreturn length > 3 && signature[0] == MAGIC_1 && signature[1] == (byte) MAGIC_2;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.xz.XZUtils:<clinit>()V",
                                    "method_body": "private static final byte[] HEADER_MAGIC = {\n(byte) 0xFD, '7', 'z', 'X', 'Z', '\\0'\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.xz.XZUtils:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < HEADER_MAGIC.length) {\nreturn false;\n}\n\nfor (int i = 0; i < HEADER_MAGIC.length; ++i) {\nif (signature[i] != HEADER_MAGIC[i]) {\nreturn false;\n}\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.xz.XZUtils:isXZCompressionAvailable()Z",
                                    "method_body": "public static boolean isXZCompressionAvailable() {\nfinal CachedAvailability cachedResult = cachedXZAvailability;\nif (cachedResult != CachedAvailability.DONT_CACHE) {\nreturn cachedResult == CachedAvailability.CACHED_AVAILABLE;\n}\nreturn internalIsXZCompressionAvailable();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.xz.XZUtils:internalIsXZCompressionAvailable()Z",
                                    "method_body": "private static boolean internalIsXZCompressionAvailable() {\ntry {\nXZCompressorInputStream.matches(null, 0);\nreturn true;\n} catch (NoClassDefFoundError error) {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.xz.XZUtils:setCacheXZAvailablity(Z)V",
                                    "method_body": "public static void setCacheXZAvailablity(boolean doCache) {\nif (!doCache) {\ncachedXZAvailability = CachedAvailability.DONT_CACHE;\n} else if (cachedXZAvailability == CachedAvailability.DONT_CACHE) {\nfinal boolean hasXz = internalIsXZCompressionAvailable();\ncachedXZAvailability = hasXz ? CachedAvailability.CACHED_AVAILABLE\n: CachedAvailability.CACHED_UNAVAILABLE;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.FileNameUtil:<init>(Ljava/util/Map;Ljava/lang/String;)V",
                                    "method_body": "public FileNameUtil(Map<String, String> uncompressSuffix,\nString defaultExtension) {\nthis.uncompressSuffix = Collections.unmodifiableMap(uncompressSuffix);\nint lc = Integer.MIN_VALUE, sc = Integer.MAX_VALUE;\nint lu = Integer.MIN_VALUE, su = Integer.MAX_VALUE;\nfor (Map.Entry<String, String> ent : uncompressSuffix.entrySet()) {\nint cl = ent.getKey().length();\nif (cl > lc) {\nlc = cl;\n}\nif (cl < sc) {\nsc = cl;\n}\n\nString u = ent.getValue();\nint ul = u.length();\nif (ul > 0) {\nif (!compressSuffix.containsKey(u)) {\ncompressSuffix.put(u, ent.getKey());\n}\nif (ul > lu) {\nlu = ul;\n}\nif (ul < su) {\nsu = ul;\n}\n}\n}\nlongestCompressedSuffix = lc;\nlongestUncompressedSuffix = lu;\nshortestCompressedSuffix = sc;\nshortestUncompressedSuffix = su;\nthis.defaultExtension = defaultExtension;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.xz.XZCompressorInputStream:<init>(Ljava/io/InputStream;Z)V",
                                    "method_body": "public XZCompressorInputStream(InputStream inputStream,\nboolean decompressConcatenated)\nthrows IOException {\nif (decompressConcatenated) {\nin = new XZInputStream(inputStream);\n} else {\nin = new SingleXZInputStream(inputStream);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.xz.XZCompressorInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < XZ.HEADER_MAGIC.length) {\nreturn false;\n}\n\nfor (int i = 0; i < XZ.HEADER_MAGIC.length; ++i) {\nif (signature[i] != XZ.HEADER_MAGIC[i]) {\nreturn false;\n}\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.lzma.LZMAUtils:<clinit>()V",
                                    "method_body": "private static final FileNameUtil fileNameUtil;\n\n/**\n* LZMA Header Magic Bytes begin a LZMA file.\n*/\nprivate static final byte[] HEADER_MAGIC = {\n(byte) 0x5D, 0, 0\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.lzma.LZMAUtils:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < HEADER_MAGIC.length) {\nreturn false;\n}\n\nfor (int i = 0; i < HEADER_MAGIC.length; ++i) {\nif (signature[i] != HEADER_MAGIC[i]) {\nreturn false;\n}\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.lzma.LZMAUtils:internalIsLZMACompressionAvailable()Z",
                                    "method_body": "private static boolean internalIsLZMACompressionAvailable() {\ntry {\nLZMACompressorInputStream.matches(null, 0);\nreturn true;\n} catch (NoClassDefFoundError error) {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.lzma.LZMAUtils:setCacheLZMAAvailablity(Z)V",
                                    "method_body": "public static void setCacheLZMAAvailablity(boolean doCache) {\nif (!doCache) {\ncachedLZMAAvailability = CachedAvailability.DONT_CACHE;\n} else if (cachedLZMAAvailability == CachedAvailability.DONT_CACHE) {\nfinal boolean hasLzma = internalIsLZMACompressionAvailable();\ncachedLZMAAvailability = hasLzma ? CachedAvailability.CACHED_AVAILABLE\n: CachedAvailability.CACHED_UNAVAILABLE;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.lzma.LZMACompressorInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\n\nif (signature == null || length < 3) {\nreturn false;\n}\n\nif (signature[0] != 0x5d) {\nreturn false;\n}\n\nif (signature[1] != 0) {\nreturn false;\n}\n\nif (signature[2] != 0) {\nreturn false;\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.CompressorException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public CompressorException(String message) {\nsuper(message);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 34,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.X7875_NewUnixTest.testParseReparse",
                            "test_body": "139: public void testParseReparse() throws ZipException {\n140: 141: // Version=1, Len=0, Len=0.\n142: final byte[] ZERO_LEN = {1, 0, 0};\n143: 144: // Version=1, Len=1, zero, Len=1, zero.\n145: final byte[] ZERO_UID_GID = {1, 1, 0, 1, 0};\n146: 147: // Version=1, Len=1, one, Len=1, one\n148: final byte[] ONE_UID_GID = {1, 1, 1, 1, 1};\n149: 150: // Version=1, Len=2, one thousand, Len=2, one thousand\n151: final byte[] ONE_THOUSAND_UID_GID = {1, 2, -24, 3, 2, -24, 3};\n152: 153: // (2^32 - 2).   I guess they avoid (2^32 - 1) since it's identical to -1 in\n154: // two's complement, and -1 often has a special meaning.\n155: final byte[] UNIX_MAX_UID_GID = {1, 4, -2, -1, -1, -1, 4, -2, -1, -1, -1};\n156: 157: // Version=1, Len=5, 2^32, Len=5, 2^32 + 1\n158: // Esoteric test:  can we handle 40 bit numbers?\n159: final byte[] LENGTH_5 = {1, 5, 0, 0, 0, 0, 1, 5, 1, 0, 0, 0, 1};\n160: 161: // Version=1, Len=8, 2^63 - 2, Len=8, 2^63 - 1\n162: // Esoteric test:  can we handle 64 bit numbers?\n163: final byte[] LENGTH_8 = {1, 8, -2, -1, -1, -1, -1, -1, -1, 127, 8, -1, -1, -1, -1, -1, -1, -1, 127};\n164: 165: final long TWO_TO_32 = 0x100000000L;\n166: final long MAX = TWO_TO_32 - 2;\n167: 168: parseReparse(0, 0, ZERO_LEN, 0, 0);\n169: parseReparse(0, 0, ZERO_UID_GID, 0, 0);\n170: parseReparse(1, 1, ONE_UID_GID, 1, 1);\n171: parseReparse(1000, 1000, ONE_THOUSAND_UID_GID, 1000, 1000);\n172: parseReparse(MAX, MAX, UNIX_MAX_UID_GID, MAX, MAX);\n173: parseReparse(-2, -2, UNIX_MAX_UID_GID, MAX, MAX);\n174: parseReparse(TWO_TO_32, TWO_TO_32 + 1, LENGTH_5, TWO_TO_32, TWO_TO_32 + 1);\n175: parseReparse(Long.MAX_VALUE - 1, Long.MAX_VALUE, LENGTH_8, Long.MAX_VALUE - 1, Long.MAX_VALUE);\n176: 177: // We never emit this, but we should be able to parse it:\n178: final byte[] SPURIOUS_ZEROES_1 = {1, 4, -1, 0, 0, 0, 4, -128, 0, 0, 0};\n179: final byte[] EXPECTED_1 = {1, 1, -1, 1, -128};\n180: xf.parseFromLocalFileData(SPURIOUS_ZEROES_1, 0, SPURIOUS_ZEROES_1.length);\n181: 182: assertEquals(255, xf.getUID());\n183: assertEquals(128, xf.getGID());\n184: assertTrue(Arrays.equals(EXPECTED_1, xf.getLocalFileDataData()));\n185: 186: final byte[] SPURIOUS_ZEROES_2 = {1, 4, -1, -1, 0, 0, 4, 1, 2, 0, 0};\n187: final byte[] EXPECTED_2 = {1, 2, -1, -1, 2, 1, 2};\n188: xf.parseFromLocalFileData(SPURIOUS_ZEROES_2, 0, SPURIOUS_ZEROES_2.length);\n189: 190: assertEquals(65535, xf.getUID());\n191: assertEquals(513, xf.getGID());\n192: assertTrue(Arrays.equals(EXPECTED_2, xf.getLocalFileDataData()));\n193: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\n//private static final int BYTE_BIT_SIZE = 8;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Data Descriptor signature.\n*\n* <p>Actually, PKWARE uses this as marker for split/spanned\n* archives and other archivers have started to use it as Data\n* Descriptor signature (as well).</p>\n* @since 1.1\n*/\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\n\n/**\n* Value stored in size and similar fields if ZIP64 extensions are\n* used.\n* @since 1.3\n*/\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\n\n/**\n* Marks ZIP archives that were supposed to be split or spanned\n* but only needed a single segment in then end (so are actually\n* neither split nor spanned).\n*\n* <p>This is the \"PK00\" prefix found in some archives.</p>\n* @since 1.5\n*/\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\nnew ZipLong(0X30304B50L);\n\n/**\n* Archive extra data record signature.\n* @since 1.5\n*/\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nputLong(value, result, 0);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:putLong(J[BI)V",
                                    "method_body": "public static void putLong(long value, byte[] buf, int offset) {\nbuf[offset++] = (byte) ((value & BYTE_MASK));\nbuf[offset++] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nbuf[offset++] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nbuf[offset] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<init>()V",
                                    "method_body": "public X7875_NewUnix() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x7875);\nprivate static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);\nprivate static final long serialVersionUID = 1L;\n\nprivate int version = 1; // always '1' according to current info-zip spec.\n\n// BigInteger helps us with little-endian / big-endian conversions.\n// (thanks to BigInteger.toByteArray() and a reverse() method we created).\n// Also, the spec theoretically allows UID/GID up to 255 bytes long!\n//\n// NOTE:  equals() and hashCode() currently assume these can never be null.\nprivate BigInteger uid;\nprivate BigInteger gid;\n\n/**\n* Constructor for X7875_NewUnix.\n*/\npublic X7875_NewUnix() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getUID()J",
                                    "method_body": "public long getUID() { return ZipUtil.bigToLong(uid); }\npublic long getUID() { return ZipUtil.bigToLong(uid); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getGID()J",
                                    "method_body": "public long getGID() { return ZipUtil.bigToLong(gid); }\npublic long getGID() { return ZipUtil.bigToLong(gid); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:setUID(J)V",
                                    "method_body": "public void setUID(long l) {\nthis.uid = ZipUtil.longToBig(l);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:setGID(J)V",
                                    "method_body": "public void setGID(long l) {\nthis.gid = ZipUtil.longToBig(l);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nint uidSize = trimLeadingZeroesForceMinLength(uid.toByteArray()).length;\nint gidSize = trimLeadingZeroesForceMinLength(gid.toByteArray()).length;\n\n// The 3 comes from:  version=1 + uidsize=1 + gidsize=1\nreturn new ZipShort(3 + uidSize + gidSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getCentralDirectoryLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getCentralDirectoryLength() {\nreturn getLocalFileDataLength();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nbyte[] uidBytes = uid.toByteArray();\nbyte[] gidBytes = gid.toByteArray();\n\n// BigInteger might prepend a leading-zero to force a positive representation\n// (e.g., so that the sign-bit is set to zero).  We need to remove that\n// before sending the number over the wire.\nuidBytes = trimLeadingZeroesForceMinLength(uidBytes);\ngidBytes = trimLeadingZeroesForceMinLength(gidBytes);\n\n// Couldn't bring myself to just call getLocalFileDataLength() when we've\n// already got the arrays right here.  Yeah, yeah, I know, premature\n// optimization is the root of all...\n//\n// The 3 comes from:  version=1 + uidsize=1 + gidsize=1\nbyte[] data = new byte[3 + uidBytes.length + gidBytes.length];\n\n// reverse() switches byte array from big-endian to little-endian.\nreverse(uidBytes);\nreverse(gidBytes);\n\nint pos = 0;\ndata[pos++] = unsignedIntToSignedByte(version);\ndata[pos++] = unsignedIntToSignedByte(uidBytes.length);\nSystem.arraycopy(uidBytes, 0, data, pos, uidBytes.length);\npos += uidBytes.length;\ndata[pos++] = unsignedIntToSignedByte(gidBytes.length);\nSystem.arraycopy(gidBytes, 0, data, pos, gidBytes.length);\nreturn data;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:parseFromLocalFileData([BII)V",
                                    "method_body": "public void parseFromLocalFileData(\nbyte[] data, int offset, int length\n) throws ZipException {\nreset();\nthis.version = signedByteToUnsignedInt(data[offset++]);\nint uidSize = signedByteToUnsignedInt(data[offset++]);\nbyte[] uidBytes = new byte[uidSize];\nSystem.arraycopy(data, offset, uidBytes, 0, uidSize);\noffset += uidSize;\nthis.uid = new BigInteger(1, reverse(uidBytes)); // sign-bit forced positive\n\nint gidSize = signedByteToUnsignedInt(data[offset++]);\nbyte[] gidBytes = new byte[gidSize];\nSystem.arraycopy(data, offset, gidBytes, 0, gidSize);\nthis.gid = new BigInteger(1, reverse(gidBytes)); // sign-bit forced positive\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:reset()V",
                                    "method_body": "private void reset() {\n// Typical UID/GID of the first non-root user created on a unix system.\nuid = ONE_THOUSAND;\ngid = ONE_THOUSAND;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:trimLeadingZeroesForceMinLength([B)[B",
                                    "method_body": "static byte[] trimLeadingZeroesForceMinLength(byte[] array) {\nif (array == null) {\nreturn array;\n}\n\nint pos = 0;\nfor (byte b : array) {\nif (b == 0) {\npos++;\n} else {\nbreak;\n}\n}\n\n/*\n\nI agonized over my choice of MIN_LENGTH=1.  Here's the situation:\nInfoZip (the tool I am using to test interop) always sets these\nto length=4.  And so a UID of 0 (typically root) for example is\nencoded as {4,0,0,0,0} (len=4, 32 bits of zero), when it could just\nas easily be encoded as {1,0} (len=1, 8 bits of zero) according to\nthe spec.\n\nIn the end I decided on MIN_LENGTH=1 for four reasons:\n\n1.)  We are adhering to the spec as far as I can tell, and so\na consumer that cannot parse this is broken.\n\n2.)  Fundamentally, zip files are about shrinking things, so\nlet's save a few bytes per entry while we can.\n\n3.)  Of all the people creating zip files using commons-\ncompress, how many care about UNIX UID/GID attributes\nof the files they store?   (e.g., I am probably thinking\nway too hard about this and no one cares!)\n\n4.)  InfoZip's tool, even though it carefully stores every UID/GID\nfor every file zipped on a unix machine (by default) currently\nappears unable to ever restore UID/GID.\nunzip -X has no effect on my machine, even when run as root!!!!\n\nAnd thus it is decided:  MIN_LENGTH=1.\n\nIf anyone runs into interop problems from this, feel free to set\nit to MIN_LENGTH=4 at some future time, and then we will behave\nexactly like InfoZip (requires changes to unit tests, though).\n\nAnd I am sorry that the time you spent reading this comment is now\ngone and you can never have it back.\n\n*/\nfinal int MIN_LENGTH = 1;\n\nbyte[] trimmedArray = new byte[Math.max(MIN_LENGTH, array.length - pos)];\nint startPos = trimmedArray.length - (array.length - pos);\nSystem.arraycopy(array, pos, trimmedArray, startPos, trimmedArray.length - startPos);\nreturn trimmedArray;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n\n/**\n* Convert a Date object to a DOS date/time field.\n* @param time the <code>Date</code> to convert\n* @return the date as a <code>ZipLong</code>\n*/\npublic static ZipLong toDosTime(Date time) {\nreturn new ZipLong(toDosTime(time.getTime()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:reverse([B)[B",
                                    "method_body": "public static byte[] reverse(final byte[] array) {\nfinal int z = array.length - 1; // position of last element\nfor (int i = 0; i < array.length / 2; i++) {\nbyte x = array[i];\narray[i] = array[z - i];\narray[z - i] = x;\n}\nreturn array;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:bigToLong(Ljava/math/BigInteger;)J",
                                    "method_body": "static long bigToLong(BigInteger big) {\nif (big.bitLength() <= 63) { // bitLength() doesn't count the sign bit.\nreturn big.longValue();\n} else {\nthrow new NumberFormatException(\"The BigInteger cannot fit inside a 64 bit java long: [\" + big + \"]\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:longToBig(J)Ljava/math/BigInteger;",
                                    "method_body": "static BigInteger longToBig(long l) {\nif (l < Integer.MIN_VALUE) {\nthrow new IllegalArgumentException(\"Negative longs < -2^31 not permitted: [\" + l + \"]\");\n} else if (l < 0 && l >= Integer.MIN_VALUE) {\n// If someone passes in a -2, they probably mean 4294967294\n// (For example, Unix UID/GID's are 32 bit unsigned.)\nl = ZipUtil.adjustToLong((int) l);\n}\nreturn BigInteger.valueOf(l);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:signedByteToUnsignedInt(B)I",
                                    "method_body": "public static int signedByteToUnsignedInt(byte b) {\nif (b >= 0) {\nreturn b;\n} else {\nreturn 256 + b;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:unsignedIntToSignedByte(I)B",
                                    "method_body": "public static byte unsignedIntToSignedByte(int i) {\nif (i > 255 || i < 0) {\nthrow new IllegalArgumentException(\"Can only convert non-negative integers between [0,255] to byte: [\" + i + \"]\");\n}\nif (i < 128) {\nreturn (byte) i;\n} else {\nreturn (byte) (i - 256);\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 35,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.DetectArchiverTestCase.testCOMPRESS335",
                            "test_body": "59: public void testCOMPRESS335() throws Exception {\n60: final ArchiveInputStream tar = getStreamFor(\"COMPRESS-335.tar\");\n61: assertNotNull(tar);\n62: assertTrue(tar instanceof TarArchiveInputStream);\n63: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>()V",
                                    "method_body": "public ArchiveStreamFactory() {\nthis(null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ArchiveStreamFactory(String encoding) {\nsuper();\nthis.encoding = encoding;\n// Also set the original field so can continue to use it.\nthis.entryEncoding = encoding;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveInputStream(Ljava/io/InputStream;)Lorg/apache/commons/compress/archivers/ArchiveInputStream;",
                                    "method_body": "public ArchiveInputStream createArchiveInputStream(final InputStream in)\nthrows ArchiveException {\nif (in == null) {\nthrow new IllegalArgumentException(\"Stream must not be null.\");\n}\n\nif (!in.markSupported()) {\nthrow new IllegalArgumentException(\"Mark is not supported.\");\n}\n\nfinal byte[] signature = new byte[12];\nin.mark(signature.length);\ntry {\nint signatureLength = IOUtils.readFully(in, signature);\nin.reset();\nif (ZipArchiveInputStream.matches(signature, signatureLength)) {\nreturn createArchiveInputStream(ZIP, in);\n} else if (JarArchiveInputStream.matches(signature, signatureLength)) {\nreturn createArchiveInputStream(JAR, in);\n} else if (ArArchiveInputStream.matches(signature, signatureLength)) {\nreturn createArchiveInputStream(AR, in);\n} else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\nreturn createArchiveInputStream(CPIO, in);\n} else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\nreturn createArchiveInputStream(ARJ, in);\n} else if (SevenZFile.matches(signature, signatureLength)) {\nthrow new StreamingNotSupportedException(SEVEN_Z);\n}\n\n// Dump needs a bigger buffer to check the signature;\nfinal byte[] dumpsig = new byte[32];\nin.mark(dumpsig.length);\nsignatureLength = IOUtils.readFully(in, dumpsig);\nin.reset();\nif (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\nreturn createArchiveInputStream(DUMP, in);\n}\n\n// Tar needs an even bigger buffer to check the signature; read the first block\nfinal byte[] tarheader = new byte[512];\nin.mark(tarheader.length);\nsignatureLength = IOUtils.readFully(in, tarheader);\nin.reset();\nif (TarArchiveInputStream.matches(tarheader, signatureLength)) {\nreturn createArchiveInputStream(TAR, in);\n}\n// COMPRESS-117 - improve auto-recognition\nif (signatureLength >= 512) {\nTarArchiveInputStream tais = null;\ntry {\ntais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n// COMPRESS-191 - verify the header checksum\nif (tais.getNextTarEntry().isCheckSumOK()) {\nreturn createArchiveInputStream(TAR, in);\n}\n} catch (Exception e) { // NOPMD\n// can generate IllegalArgumentException as well\n// as IOException\n// autodetection, simply not a TAR\n// ignored\n} finally {\nIOUtils.closeQuietly(tais);\n}\n}\n} catch (IOException e) {\nthrow new ArchiveException(\"Could not use reset and mark operations.\", e);\n}\n\nthrow new ArchiveException(\"No Archiver found for the stream signature\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "public static final int EFS_FLAG = GeneralPurposeBit.UFT8_NAMES_FLAG;\n\nprivate static final byte[] EMPTY = new byte[0];\n\n/**\n* Current entry.\n*/\nprivate CurrentEntry entry;\n\n/**\n* The file comment.\n*/\nprivate String comment = \"\";\n\n/**\n* Compression level for next entry.\n*/\nprivate int level = DEFAULT_COMPRESSION;\n\n/**\n* Has the compression level changed when compared to the last\n* entry?\n*/\nprivate boolean hasCompressionLevelChanged = false;\n\n/**\n* Default compression method for next entry.\n*/\nprivate int method = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* List of ZipArchiveEntries written so far.\n*/\nprivate final List<ZipArchiveEntry> entries =\nnew LinkedList<ZipArchiveEntry>();\n\nprivate final StreamCompressor streamCompressor;\n\n/**\n* Start of central directory.\n*/\nprivate long cdOffset = 0;\n\n/**\n* Length of central directory.\n*/\nprivate long cdLength = 0;\n\n/**\n* Helper, a 0 as ZipShort.\n*/\nprivate static final byte[] ZERO = {0, 0};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\n//private static final int BYTE_BIT_SIZE = 8;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Data Descriptor signature.\n*\n* <p>Actually, PKWARE uses this as marker for split/spanned\n* archives and other archivers have started to use it as Data\n* Descriptor signature (as well).</p>\n* @since 1.1\n*/\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\n\n/**\n* Value stored in size and similar fields if ZIP64 extensions are\n* used.\n* @since 1.3\n*/\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\n\n/**\n* Marks ZIP archives that were supposed to be split or spanned\n* but only needed a single segment in then end (so are actually\n* neither split nor spanned).\n*\n* <p>This is the \"PK00\" prefix found in some archives.</p>\n* @since 1.5\n*/\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\nnew ZipLong(0X30304B50L);\n\n/**\n* Archive extra data record signature.\n* @since 1.5\n*/\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nputLong(value, result, 0);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:putLong(J[BI)V",
                                    "method_body": "public static void putLong(long value, byte[] buf, int offset) {\nbuf[offset++] = (byte) ((value & BYTE_MASK));\nbuf[offset++] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nbuf[offset++] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nbuf[offset] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n\nstatic {\nMap<String, SimpleEncodingHolder> se =\nnew HashMap<String, SimpleEncodingHolder>();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for UTF-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h = simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\n// check platform's default encoding\ncharsetName = Charset.defaultCharset().name();\n}\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}\nfor (String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data);\n} else {\nreturn new String(data,this.charsetName);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\n\n/**\n* <p>\n* Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\n* (either order accepted on input, big-endian used on output)\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, big-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, little-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\n\n/**\n* <p>\n* Eight-bit Unicode Transformation Format.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry() {\nString user = System.getProperty(\"user.name\", \"\");\n\nif (user.length() > MAX_NAMELEN) {\nuser = user.substring(0, MAX_NAMELEN);\n}\n\nthis.userName = user;\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public TarArchiveEntry(byte[] headerBuf, ZipEncoding encoding)\nthrows IOException {\nthis();\nparseTarHeader(headerBuf, encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isCheckSumOK()Z",
                                    "method_body": "public boolean isCheckSumOK() {\nreturn checkSumOK;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNUSparse()Z",
                                    "method_body": "public boolean isGNUSparse() {\nreturn linkFlag == LF_GNUTYPE_SPARSE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongLinkEntry()Z",
                                    "method_body": "public boolean isGNULongLinkEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGLINK;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongNameEntry()Z",
                                    "method_body": "public boolean isGNULongNameEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGNAME;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isPaxHeader()Z",
                                    "method_body": "public boolean isPaxHeader(){\nreturn linkFlag == LF_PAX_EXTENDED_HEADER_LC\n|| linkFlag == LF_PAX_EXTENDED_HEADER_UC;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nif (file != null) {\nreturn file.isDirectory();\n}\n\nif (linkFlag == LF_DIR) {\nreturn true;\n}\n\nif (getName().endsWith(\"/\")) {\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public void parseTarHeader(byte[] header, ZipEncoding encoding)\nthrows IOException {\nparseTarHeader(header, encoding, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;Z)V",
                                    "method_body": "private void parseTarHeader(byte[] header, ZipEncoding encoding,\nfinal boolean oldStyle)\nthrows IOException {\nint offset = 0;\n\nname = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n: TarUtils.parseName(header, offset, NAMELEN, encoding);\noffset += NAMELEN;\nmode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN);\noffset += MODELEN;\nuserId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\noffset += UIDLEN;\ngroupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\noffset += GIDLEN;\nsize = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\noffset += SIZELEN;\nmodTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN);\noffset += MODTIMELEN;\ncheckSumOK = TarUtils.verifyCheckSum(header);\noffset += CHKSUMLEN;\nlinkFlag = header[offset++];\nlinkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n: TarUtils.parseName(header, offset, NAMELEN, encoding);\noffset += NAMELEN;\nmagic = TarUtils.parseName(header, offset, MAGICLEN);\noffset += MAGICLEN;\nversion = TarUtils.parseName(header, offset, VERSIONLEN);\noffset += VERSIONLEN;\nuserName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)\n: TarUtils.parseName(header, offset, UNAMELEN, encoding);\noffset += UNAMELEN;\ngroupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN)\n: TarUtils.parseName(header, offset, GNAMELEN, encoding);\noffset += GNAMELEN;\ndevMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\ndevMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\n\nint type = evaluateType(header);\nswitch (type) {\ncase FORMAT_OLDGNU: {\noffset += ATIMELEN_GNU;\noffset += CTIMELEN_GNU;\noffset += OFFSETLEN_GNU;\noffset += LONGNAMESLEN_GNU;\noffset += PAD2LEN_GNU;\noffset += SPARSELEN_GNU;\nisExtended = TarUtils.parseBoolean(header, offset);\noffset += ISEXTENDEDLEN_GNU;\nrealSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU);\noffset += REALSIZELEN_GNU;\nbreak;\n}\ncase FORMAT_POSIX:\ndefault: {\nString prefix = oldStyle\n? TarUtils.parseName(header, offset, PREFIXLEN)\n: TarUtils.parseName(header, offset, PREFIXLEN, encoding);\n// SunOS tar -E does not add / to directory names, so fix\n// up to be consistent\nif (isDirectory() && !name.endsWith(\"/\")){\nname = name + \"/\";\n}\nif (prefix.length() > 0){\nname = prefix + \"/\" + name;\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:evaluateType([B)I",
                                    "method_body": "private int evaluateType(byte[] header) {\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_GNU, header, MAGIC_OFFSET, MAGICLEN)) {\nreturn FORMAT_OLDGNU;\n}\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_POSIX, header, MAGIC_OFFSET, MAGICLEN)) {\nreturn FORMAT_POSIX;\n}\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:<clinit>()V",
                                    "method_body": "private static final int BYTE_MASK = 255;\n\nstatic final ZipEncoding DEFAULT_ENCODING =\nZipEncodingHelper.getZipEncoding(null);\n\n/**\n* Encapsulates the algorithms used up to Commons Compress 1.3 as\n* ZipEncoding.\n*/\nstatic final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\npublic boolean canEncode(String name) { return true; }\n\npublic ByteBuffer encode(String name) {\nfinal int length = name.length();\nbyte[] buf = new byte[length];\n\n// copy until end of input or output is reached.\nfor (int i = 0; i < length; ++i) {\nbuf[i] = (byte) name.charAt(i);\n}\nreturn ByteBuffer.wrap(buf);\n}\n\npublic String decode(byte[] buffer) {\nfinal int length = buffer.length;\nStringBuilder result = new StringBuilder(length);\n\nfor (byte b : buffer) {\nif (b == 0) { // Trailing null\nbreak;\n}\nresult.append((char) (b & 0xFF)); // Allow for sign-extension\n}\n\nreturn result.toString();\n}\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\n\nif (length < 2){\nthrow new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n}\n\nif (buffer[start] == 0) {\nreturn 0L;\n}\n\n// Skip leading spaces\nwhile (start < end){\nif (buffer[start] == ' '){\nstart++;\n} else {\nbreak;\n}\n}\n\n// Trim all trailing NULs and spaces.\n// The ustar and POSIX tar specs require a trailing NUL or\n// space but some implementations use the extra digit for big\n// sizes/uids/gids ...\nbyte trailer = buffer[end - 1];\nwhile (start < end && (trailer == 0 || trailer == ' ')) {\nend--;\ntrailer = buffer[end - 1];\n}\n\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\n// CheckStyle:MagicNumber OFF\nif (currentByte < '0' || currentByte > '7'){\nthrow new IllegalArgumentException(\nexceptionMessage(buffer, offset, length, start, currentByte));\n}\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\n// CheckStyle:MagicNumber ON\n}\n\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctalOrBinary([BII)J",
                                    "method_body": "public static long parseOctalOrBinary(final byte[] buffer, final int offset,\nfinal int length) {\n\nif ((buffer[offset] & 0x80) == 0) {\nreturn parseOctal(buffer, offset, length);\n}\nfinal boolean negative = buffer[offset] == (byte) 0xff;\nif (length < 9) {\nreturn parseBinaryLong(buffer, offset, length, negative);\n}\nreturn parseBinaryBigInteger(buffer, offset, length, negative);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BII)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset, final int length) {\ntry {\nreturn parseName(buffer, offset, length, DEFAULT_ENCODING);\n} catch (IOException ex) {\ntry {\nreturn parseName(buffer, offset, length, FALLBACK_ENCODING);\n} catch (IOException ex2) {\n// impossible\nthrow new RuntimeException(ex2);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BIILorg/apache/commons/compress/archivers/zip/ZipEncoding;)Ljava/lang/String;",
                                    "method_body": "public static String parseName(byte[] buffer, final int offset,\nfinal int length,\nfinal ZipEncoding encoding)\nthrows IOException {\n\nint len = length;\nfor (; len > 0; len--) {\nif (buffer[offset + len - 1] != 0) {\nbreak;\n}\n}\nif (len > 0) {\nbyte[] b = new byte[len];\nSystem.arraycopy(buffer, offset, b, 0, len);\nreturn encoding.decode(b);\n}\nreturn \"\";\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:verifyCheckSum([B)Z",
                                    "method_body": "public static boolean verifyCheckSum(byte[] header) {\nlong storedSum = 0;\nlong unsignedSum = 0;\nlong signedSum = 0;\n\nint digits = 0;\nfor (int i = 0; i < header.length; i++) {\nbyte b = header[i];\nif (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\nif ('0' <= b && b <= '7' && digits++ < 6) {\nstoredSum = storedSum * 8 + b - '0';\n} else if (digits > 0) {\ndigits = 6;\n}\nb = ' ';\n}\nunsignedSum += 0xff & b;\nsignedSum += b;\n}\nreturn storedSum == unsignedSum || storedSum == signedSum;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:matchAsciiBuffer(Ljava/lang/String;[BII)Z",
                                    "method_body": "public static boolean matchAsciiBuffer(\nString expected, byte[] buffer, int offset, int length){\nbyte[] buffer1;\ntry {\nbuffer1 = expected.getBytes(CharsetNames.US_ASCII);\n} catch (UnsupportedEncodingException e) {\nthrow new RuntimeException(e); // Should not happen\n}\nreturn isEqual(buffer1, 0, buffer1.length, buffer, offset, length, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isEqual([BII[BIIZ)Z",
                                    "method_body": "public static boolean isEqual(\nfinal byte[] buffer1, final int offset1, final int length1,\nfinal byte[] buffer2, final int offset2, final int length2,\nboolean ignoreTrailingNulls){\nint minLen=length1 < length2 ? length1 : length2;\nfor (int i=0; i < minLen; i++){\nif (buffer1[offset1+i] != buffer2[offset2+i]){\nreturn false;\n}\n}\nif (length1 == length2){\nreturn true;\n}\nif (ignoreTrailingNulls){\nif (length1 > length2){\nfor(int i = length2; i < length1; i++){\nif (buffer1[offset1+i] != 0){\nreturn false;\n}\n}\n} else {\nfor(int i = length1; i < length2; i++){\nif (buffer2[offset2+i] != 0){\nreturn false;\n}\n}\n}\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isArrayZero([BI)Z",
                                    "method_body": "public static boolean isArrayZero(byte[] a, int size) {\nfor (int i = 0; i < size; i++) {\nif (a[i] != 0) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final int SKIP_BUF_SIZE = 4096;\n\n// This buffer does not need to be synchronised because it is write only; the contents are ignored\n// Does not affect Immutability\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n\n/** Private constructor to prevent instantiation of this utility class. */\nprivate IOUtils(){\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[B)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b) throws IOException {\nreturn readFully(input, b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(InputStream input, byte[] b, int offset, int len)\nthrows IOException {\nif (len < 0 || offset < 0 || len + offset > b.length) {\nthrow new IndexOutOfBoundsException();\n}\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\nbreak;\n}\ncount += x;\n}\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:closeQuietly(Ljava/io/Closeable;)V",
                                    "method_body": "public static void closeQuietly(Closeable c) {\nif (c != null) {\ntry {\nc.close();\n} catch (IOException ignored) { // NOPMD\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < 6) {\nreturn false;\n}\n\n// Check binary values\nif (signature[0] == 0x71 && (signature[1] & 0xFF) == 0xc7) {\nreturn true;\n}\nif (signature[1] == 0x71 && (signature[0] & 0xFF) == 0xc7) {\nreturn true;\n}\n\n// Check Ascii (String) values\n// 3037 3037 30nn\nif (signature[0] != 0x30) {\nreturn false;\n}\nif (signature[1] != 0x37) {\nreturn false;\n}\nif (signature[2] != 0x30) {\nreturn false;\n}\nif (signature[3] != 0x37) {\nreturn false;\n}\nif (signature[4] != 0x30) {\nreturn false;\n}\n// Check last byte\nif (signature[5] == 0x31) {\nreturn true;\n}\nif (signature[5] == 0x32) {\nreturn true;\n}\nif (signature[5] == 0x37) {\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<clinit>()V",
                                    "method_body": "private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\nprivate static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\nprivate static final byte[] DD = ZipLong.DD_SIG.getBytes();\n\n/**\n* Checks whether the current buffer contains the signature of a\n* &quot;data descriptor&quot;, &quot;local file header&quot; or\n* &quot;central directory entry&quot;.\n*\n* <p>If it contains such a signature, reads the data descriptor\n* and positions the stream right after the data descriptor.</p>\n*/\nprivate boolean bufferContainsSignature(ByteArrayOutputStream bos, int offset, int lastRead, int expectedDDLen)\nthrows IOException {\n\nboolean done = false;\nint readTooMuch = 0;\nfor (int i = 0; !done && i < lastRead - 4; i++) {\nif (buf.array()[i] == LFH[0] && buf.array()[i + 1] == LFH[1]) {\nif ((buf.array()[i + 2] == LFH[2] && buf.array()[i + 3] == LFH[3])\n|| (buf.array()[i] == CFH[2] && buf.array()[i + 3] == CFH[3])) {\n// found a LFH or CFH:\nreadTooMuch = offset + lastRead - i - expectedDDLen;\ndone = true;\n}\nelse if (buf.array()[i + 2] == DD[2] && buf.array()[i + 3] == DD[3]) {\n// found DD:\nreadTooMuch = offset + lastRead - i;\ndone = true;\n}\nif (done) {\n// * push back bytes read in excess as well as the data\n//   descriptor\n// * copy the remaining bytes to cache\n// * read data descriptor\npushback(buf.array(), offset + lastRead - readTooMuch, readTooMuch);\nbos.write(buf.array(), 0, i);\nreadDataDescriptor();\n}\n}\n}\nreturn done;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < ZipArchiveOutputStream.LFH_SIG.length) {\nreturn false;\n}\n\nreturn checksig(signature, ZipArchiveOutputStream.LFH_SIG) // normal file\n|| checksig(signature, ZipArchiveOutputStream.EOCD_SIG) // empty zip\n|| checksig(signature, ZipArchiveOutputStream.DD_SIG) // split zip\n|| checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:checksig([B[B)Z",
                                    "method_body": "private static boolean checksig(byte[] signature, byte[] expected) {\nfor (int i = 0; i < expected.length; i++) {\nif (signature[i] != expected[i]) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length ) {\nreturn ZipArchiveInputStream.matches(signature, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is) {\nthis(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\nthis(is, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;IILjava/lang/String;)V",
                                    "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize,\nString encoding) {\nthis.is = is;\nthis.hasHitEOF = false;\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.recordSize = recordSize;\nthis.blockSize = blockSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nis.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextTarEntry()Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;",
                                    "method_body": "public TarArchiveEntry getNextTarEntry() throws IOException {\nif (hasHitEOF) {\nreturn null;\n}\n\nif (currEntry != null) {\n/* Skip will only go to the end of the current entry */\nIOUtils.skip(this, Long.MAX_VALUE);\n\n/* skip to the end of the last record */\nskipRecordPadding();\n}\n\nbyte[] headerBuf = getRecord();\n\nif (headerBuf == null) {\n/* hit EOF */\ncurrEntry = null;\nreturn null;\n}\n\ntry {\ncurrEntry = new TarArchiveEntry(headerBuf, zipEncoding);\n} catch (IllegalArgumentException e) {\nIOException ioe = new IOException(\"Error detected parsing the header\");\nioe.initCause(e);\nthrow ioe;\n}\n\nentryOffset = 0;\nentrySize = currEntry.getSize();\n\nif (currEntry.isGNULongLinkEntry()) {\nbyte[] longLinkData = getLongNameData();\nif (longLinkData == null) {\n// Bugzilla: 40334\n// Malformed tar file - long link entry name not followed by\n// entry\nreturn null;\n}\ncurrEntry.setLinkName(zipEncoding.decode(longLinkData));\n}\n\nif (currEntry.isGNULongNameEntry()) {\nbyte[] longNameData = getLongNameData();\nif (longNameData == null) {\n// Bugzilla: 40334\n// Malformed tar file - long entry name not followed by\n// entry\nreturn null;\n}\ncurrEntry.setName(zipEncoding.decode(longNameData));\n}\n\nif (currEntry.isPaxHeader()){ // Process Pax headers\npaxHeaders();\n}\n\nif (currEntry.isGNUSparse()){ // Process sparse files\nreadGNUSparse();\n}\n\n// If the size of the next element in the archive has changed\n// due to a new size being reported in the posix header\n// information, we update entrySize here so that it contains\n// the correct value.\nentrySize = currEntry.getSize();\n\nreturn currEntry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getRecord()[B",
                                    "method_body": "private byte[] getRecord() throws IOException {\nbyte[] headerBuf = readRecord();\nhasHitEOF = isEOFRecord(headerBuf);\nif (hasHitEOF && headerBuf != null) {\ntryToConsumeSecondEOFRecord();\nconsumeRemainderOfLastBlock();\nheaderBuf = null;\n}\nreturn headerBuf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:isEOFRecord([B)Z",
                                    "method_body": "protected boolean isEOFRecord(byte[] record) {\nreturn record == null || ArchiveUtils.isArrayZero(record, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:readRecord()[B",
                                    "method_body": "protected byte[] readRecord() throws IOException {\n\nbyte[] record = new byte[recordSize];\n\nint readNow = IOUtils.readFully(is, record);\ncount(readNow);\nif (readNow != recordSize) {\nreturn null;\n}\n\nreturn record;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < TarConstants.VERSION_OFFSET+TarConstants.VERSIONLEN) {\nreturn false;\n}\n\nif (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_POSIX,\nsignature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n&&\nArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_POSIX,\nsignature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n){\nreturn true;\n}\nif (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_GNU,\nsignature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n&&\n(\nArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_SPACE,\nsignature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n||\nArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_ZERO,\nsignature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n)\n){\nreturn true;\n}\n// COMPRESS-107 - recognise Ant tar files\nif (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_ANT,\nsignature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n&&\nArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_ANT,\nsignature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n){\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:<clinit>()V",
                                    "method_body": "static final String BSD_LONGNAME_PREFIX = \"#1/\";\nprivate static final int BSD_LONGNAME_PREFIX_LEN =\nBSD_LONGNAME_PREFIX.length();\nprivate static final String BSD_LONGNAME_PATTERN =\n\"^\" + BSD_LONGNAME_PREFIX + \"\\\\d+\";\n\n/**\n* Does the name look like it is a long name (or a name containing\n* spaces) as encoded by BSD ar?\n*\n* <p>From the FreeBSD ar(5) man page:</p>\n* <pre>\n* BSD   In the BSD variant, names that are shorter than 16\n*       characters and without embedded spaces are stored\n*       directly in this field.  If a name has an embedded\n*       space, or if it is longer than 16 characters, then\n*       the string \"#1/\" followed by the decimal represen-\n*       tation of the length of the file name is placed in\n*       this field. The actual file name is stored immedi-\n*       ately after the archive header.  The content of the\n*       archive member follows the file name.  The ar_size\n*       field of the header (see below) will then hold the\n*       sum of the size of the file name and the size of\n*       the member.\n* </pre>\n*\n* @since 1.3\n*/\nprivate static boolean isBSDLongName(String name) {\nreturn name != null && name.matches(BSD_LONGNAME_PATTERN);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\n// 3c21 7261 6863 0a3e\n\nif (length < 8) {\nreturn false;\n}\nif (signature[0] != 0x21) {\nreturn false;\n}\nif (signature[1] != 0x3c) {\nreturn false;\n}\nif (signature[2] != 0x61) {\nreturn false;\n}\nif (signature[3] != 0x72) {\nreturn false;\n}\nif (signature[4] != 0x63) {\nreturn false;\n}\nif (signature[5] != 0x68) {\nreturn false;\n}\nif (signature[6] != 0x3e) {\nreturn false;\n}\nif (signature[7] != 0x0a) {\nreturn false;\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(final byte[] signature, final int length) {\nreturn length >= 2 &&\n(0xff & signature[0]) == ARJ_MAGIC_1 &&\n(0xff & signature[1]) == ARJ_MAGIC_2;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<clinit>()V",
                                    "method_body": "static final int SIGNATURE_HEADER_SIZE = 32;\n\nprivate final String fileName;\nprivate RandomAccessFile file;\nprivate final Archive archive;\nprivate int currentEntryIndex = -1;\nprivate int currentFolderIndex = -1;\nprivate InputStream currentFolderInputStream = null;\nprivate InputStream currentEntryInputStream = null;\nprivate byte[] password;\n\nstatic final byte[] sevenZSignature = {\n(byte)'7', (byte)'z', (byte)0xBC, (byte)0xAF, (byte)0x27, (byte)0x1C\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < sevenZSignature.length) {\nreturn false;\n}\n\nfor (int i = 0; i < sevenZSignature.length; i++) {\nif (signature[i] != sevenZSignature[i]) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:matches([BI)Z",
                                    "method_body": "public static boolean matches(byte[] buffer, int length) {\n// do we have enough of the header?\nif (length < 32) {\nreturn false;\n}\n\n// this is the best test\nif (length >= DumpArchiveConstants.TP_SIZE) {\nreturn DumpArchiveUtil.verify(buffer);\n}\n\n// this will work in a pinch.\nreturn DumpArchiveConstants.NFS_MAGIC == DumpArchiveUtil.convert32(buffer,\n24);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert32([BI)I",
                                    "method_body": "public static final int convert32(byte[] buffer, int offset) {\nint i = 0;\ni = buffer[offset + 3] << 24;\ni += (buffer[offset + 2] << 16) & 0x00FF0000;\ni += (buffer[offset + 1] << 8) & 0x0000FF00;\ni += buffer[offset] & 0x000000FF;\n\nreturn i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ArchiveException(String message) {\nsuper(message);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 36,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.sevenz.SevenZFileTest.readEntriesOfSize0",
                            "test_body": "267: public void readEntriesOfSize0() throws IOException {\n268: final SevenZFile sevenZFile = new SevenZFile(getFile(\"COMPRESS-348.7z\"));\n269: try {\n270: int entries = 0;\n271: SevenZArchiveEntry entry = sevenZFile.getNextEntry();\n272: while (entry != null) {\n273: entries++;\n274: int b = sevenZFile.read();\n275: if (\"2.txt\".equals(entry.getName()) || \"5.txt\".equals(entry.getName())) {\n276: assertEquals(-1, b);\n277: } else {\n278: assertNotEquals(-1, b);\n279: }\n280: entry = sevenZFile.getNextEntry();\n281: }\n282: assertEquals(5, entries);\n283: } finally {\n284: sevenZFile.close();\n285: }\n286: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>()V",
                                    "method_body": "public ArchiveStreamFactory() {\nthis(null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ArchiveStreamFactory(final String encoding) {\nsuper();\nthis.encoding = encoding;\n// Also set the original field so can continue to use it.\nthis.entryEncoding = encoding;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final int SKIP_BUF_SIZE = 4096;\n\n// This buffer does not need to be synchronised because it is write only; the contents are ignored\n// Does not affect Immutability\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n\n/** Private constructor to prevent instantiation of this utility class. */\nprivate IOUtils(){\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:skip(Ljava/io/InputStream;J)J",
                                    "method_body": "public static long skip(final InputStream input, long numToSkip) throws IOException {\nfinal long available = numToSkip;\nwhile (numToSkip > 0) {\nfinal long skipped = input.skip(numToSkip);\nif (skipped == 0) {\nbreak;\n}\nnumToSkip -= skipped;\n}\n\nwhile (numToSkip > 0) {\nfinal int read = readFully(input, SKIP_BUF, 0,\n(int) Math.min(numToSkip, SKIP_BUF_SIZE));\nif (read < 1) {\nbreak;\n}\nnumToSkip -= read;\n}\nreturn available - numToSkip;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(final InputStream input, final byte[] b, final int offset, final int len)\nthrows IOException {\nif (len < 0 || offset < 0 || len + offset > b.length) {\nthrow new IndexOutOfBoundsException();\n}\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\nbreak;\n}\ncount += x;\n}\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;[B)V",
                                    "method_body": "public SevenZFile(final File filename, final byte[] password) throws IOException {\nboolean succeeded = false;\nthis.file = new RandomAccessFile(filename, \"r\");\nthis.fileName = filename.getAbsolutePath();\ntry {\narchive = readHeaders(password);\nif (password != null) {\nthis.password = new byte[password.length];\nSystem.arraycopy(password, 0, this.password, 0, password.length);\n} else {\nthis.password = null;\n}\nsucceeded = true;\n} finally {\nif (!succeeded) {\nthis.file.close();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public SevenZFile(final File filename) throws IOException {\nthis(filename, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<clinit>()V",
                                    "method_body": "static final int SIGNATURE_HEADER_SIZE = 32;\n\nprivate final String fileName;\nprivate RandomAccessFile file;\nprivate final Archive archive;\nprivate int currentEntryIndex = -1;\nprivate int currentFolderIndex = -1;\nprivate InputStream currentFolderInputStream = null;\nprivate byte[] password;\n\nprivate final ArrayList<InputStream> deferredBlockStreams = new ArrayList<InputStream>();\n\nstatic final byte[] sevenZSignature = {\n(byte)'7', (byte)'z', (byte)0xBC, (byte)0xAF, (byte)0x27, (byte)0x1C\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:close()V",
                                    "method_body": "public void close() throws IOException {\nif (file != null) {\ntry {\nfile.close();\n} finally {\nfile = null;\nif (password != null) {\nArrays.fill(password, (byte) 0);\n}\npassword = null;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:getNextEntry()Lorg/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry;",
                                    "method_body": "public SevenZArchiveEntry getNextEntry() throws IOException {\nif (currentEntryIndex >= archive.files.length - 1) {\nreturn null;\n}\n++currentEntryIndex;\nfinal SevenZArchiveEntry entry = archive.files[currentEntryIndex];\nbuildDecodingStream();\nreturn entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeaders([B)Lorg/apache/commons/compress/archivers/sevenz/Archive;",
                                    "method_body": "private Archive readHeaders(final byte[] password) throws IOException {\nfinal byte[] signature = new byte[6];\nfile.readFully(signature);\nif (!Arrays.equals(signature, sevenZSignature)) {\nthrow new IOException(\"Bad 7z signature\");\n}\n// 7zFormat.txt has it wrong - it's first major then minor\nfinal byte archiveVersionMajor = file.readByte();\nfinal byte archiveVersionMinor = file.readByte();\nif (archiveVersionMajor != 0) {\nthrow new IOException(String.format(\"Unsupported 7z version (%d,%d)\",\narchiveVersionMajor, archiveVersionMinor));\n}\n\nfinal long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\nfinal StartHeader startHeader = readStartHeader(startHeaderCrc);\n\nfinal int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\nif (nextHeaderSizeInt != startHeader.nextHeaderSize) {\nthrow new IOException(\"cannot handle nextHeaderSize \" + startHeader.nextHeaderSize);\n}\nfile.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\nfinal byte[] nextHeader = new byte[nextHeaderSizeInt];\nfile.readFully(nextHeader);\nfinal CRC32 crc = new CRC32();\ncrc.update(nextHeader);\nif (startHeader.nextHeaderCrc != crc.getValue()) {\nthrow new IOException(\"NextHeader CRC mismatch\");\n}\n\nfinal ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\nDataInputStream nextHeaderInputStream = new DataInputStream(\nbyteStream);\nArchive archive = new Archive();\nint nid = nextHeaderInputStream.readUnsignedByte();\nif (nid == NID.kEncodedHeader) {\nnextHeaderInputStream =\nreadEncodedHeader(nextHeaderInputStream, archive, password);\n// Archive gets rebuilt with the new header\narchive = new Archive();\nnid = nextHeaderInputStream.readUnsignedByte();\n}\nif (nid == NID.kHeader) {\nreadHeader(nextHeaderInputStream, archive);\nnextHeaderInputStream.close();\n} else {\nthrow new IOException(\"Broken or unsupported archive: no Header\");\n}\nreturn archive;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStartHeader(J)Lorg/apache/commons/compress/archivers/sevenz/StartHeader;",
                                    "method_body": "private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\nfinal StartHeader startHeader = new StartHeader();\nDataInputStream dataInputStream = null;\ntry {\ndataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\nnew BoundedRandomAccessFileInputStream(file, 20), 20, startHeaderCrc));\nstartHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\nreturn startHeader;\n} finally {\nif (dataInputStream != null) {\ndataInputStream.close();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeader(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readHeader(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\n\nif (nid == NID.kArchiveProperties) {\nreadArchiveProperties(header);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kAdditionalStreamsInfo) {\nthrow new IOException(\"Additional streams unsupported\");\n//nid = header.readUnsignedByte();\n}\n\nif (nid == NID.kMainStreamsInfo) {\nreadStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kFilesInfo) {\nreadFilesInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated header, found \" + nid);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readEncodedHeader(Ljava/io/DataInputStream;Lorg/apache/commons/compress/archivers/sevenz/Archive;[B)Ljava/io/DataInputStream;",
                                    "method_body": "private DataInputStream readEncodedHeader(final DataInputStream header, final Archive archive,\nfinal byte[] password) throws IOException {\nreadStreamsInfo(header, archive);\n\n// FIXME: merge with buildDecodingStream()/buildDecoderStack() at some stage?\nfinal Folder folder = archive.folders[0];\nfinal int firstPackStreamIndex = 0;\nfinal long folderOffset = SIGNATURE_HEADER_SIZE + archive.packPos +\n0;\n\nfile.seek(folderOffset);\nInputStream inputStreamStack = new BoundedRandomAccessFileInputStream(file,\narchive.packSizes[firstPackStreamIndex]);\nfor (final Coder coder : folder.getOrderedCoders()) {\nif (coder.numInStreams != 1 || coder.numOutStreams != 1) {\nthrow new IOException(\"Multi input/output stream coders are not yet supported\");\n}\ninputStreamStack = Coders.addDecoder(fileName, inputStreamStack,\nfolder.getUnpackSizeForCoder(coder), coder, password);\n}\nif (folder.hasCrc) {\ninputStreamStack = new CRC32VerifyingInputStream(inputStreamStack,\nfolder.getUnpackSize(), folder.crc);\n}\nfinal byte[] nextHeader = new byte[(int)folder.getUnpackSize()];\nfinal DataInputStream nextHeaderInputStream = new DataInputStream(inputStreamStack);\ntry {\nnextHeaderInputStream.readFully(nextHeader);\n} finally {\nnextHeaderInputStream.close();\n}\nreturn new DataInputStream(new ByteArrayInputStream(nextHeader));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\n\nif (nid == NID.kPackInfo) {\nreadPackInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kUnpackInfo) {\nreadUnpackInfo(header, archive);\nnid = header.readUnsignedByte();\n} else {\n// archive without unpack/coders info\narchive.folders = new Folder[0];\n}\n\nif (nid == NID.kSubStreamsInfo) {\nreadSubStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated StreamsInfo\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readPackInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readPackInfo(final DataInput header, final Archive archive) throws IOException {\narchive.packPos = readUint64(header);\nfinal long numPackStreams = readUint64(header);\nint nid = header.readUnsignedByte();\nif (nid == NID.kSize) {\narchive.packSizes = new long[(int)numPackStreams];\nfor (int i = 0; i < archive.packSizes.length; i++) {\narchive.packSizes[i] = readUint64(header);\n}\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kCRC) {\narchive.packCrcsDefined = readAllOrBits(header, (int)numPackStreams);\narchive.packCrcs = new long[(int)numPackStreams];\nfor (int i = 0; i < (int)numPackStreams; i++) {\nif (archive.packCrcsDefined.get(i)) {\narchive.packCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n}\n}\n\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated PackInfo (\" + nid + \")\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUnpackInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readUnpackInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\nif (nid != NID.kFolder) {\nthrow new IOException(\"Expected kFolder, got \" + nid);\n}\nfinal long numFolders = readUint64(header);\nfinal Folder[] folders = new Folder[(int)numFolders];\narchive.folders = folders;\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"External unsupported\");\n}\nfor (int i = 0; i < (int)numFolders; i++) {\nfolders[i] = readFolder(header);\n}\n\nnid = header.readUnsignedByte();\nif (nid != NID.kCodersUnpackSize) {\nthrow new IOException(\"Expected kCodersUnpackSize, got \" + nid);\n}\nfor (final Folder folder : folders) {\nfolder.unpackSizes = new long[(int)folder.totalOutputStreams];\nfor (int i = 0; i < folder.totalOutputStreams; i++) {\nfolder.unpackSizes[i] = readUint64(header);\n}\n}\n\nnid = header.readUnsignedByte();\nif (nid == NID.kCRC) {\nfinal BitSet crcsDefined = readAllOrBits(header, (int)numFolders);\nfor (int i = 0; i < (int)numFolders; i++) {\nif (crcsDefined.get(i)) {\nfolders[i].hasCrc = true;\nfolders[i].crc = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n} else {\nfolders[i].hasCrc = false;\n}\n}\n\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated UnpackInfo\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readSubStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nfor (final Folder folder : archive.folders) {\nfolder.numUnpackSubStreams = 1;\n}\nint totalUnpackStreams = archive.folders.length;\n\nint nid = header.readUnsignedByte();\nif (nid == NID.kNumUnpackStream) {\ntotalUnpackStreams = 0;\nfor (final Folder folder : archive.folders) {\nfinal long numStreams = readUint64(header);\nfolder.numUnpackSubStreams = (int)numStreams;\ntotalUnpackStreams += numStreams;\n}\nnid = header.readUnsignedByte();\n}\n\nfinal SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\nsubStreamsInfo.unpackSizes = new long[totalUnpackStreams];\nsubStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\nsubStreamsInfo.crcs = new long[totalUnpackStreams];\n\nint nextUnpackStream = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams == 0) {\ncontinue;\n}\nlong sum = 0;\nif (nid == NID.kSize) {\nfor (int i = 0; i < folder.numUnpackSubStreams - 1; i++) {\nfinal long size = readUint64(header);\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = size;\nsum += size;\n}\n}\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;\n}\nif (nid == NID.kSize) {\nnid = header.readUnsignedByte();\n}\n\nint numDigests = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {\nnumDigests += folder.numUnpackSubStreams;\n}\n}\n\nif (nid == NID.kCRC) {\nfinal BitSet hasMissingCrc = readAllOrBits(header, numDigests);\nfinal long[] missingCrcs = new long[numDigests];\nfor (int i = 0; i < numDigests; i++) {\nif (hasMissingCrc.get(i)) {\nmissingCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n}\n}\nint nextCrc = 0;\nint nextMissingCrc = 0;\nfor (final Folder folder: archive.folders) {\nif (folder.numUnpackSubStreams == 1 && folder.hasCrc) {\nsubStreamsInfo.hasCrc.set(nextCrc, true);\nsubStreamsInfo.crcs[nextCrc] = folder.crc;\n++nextCrc;\n} else {\nfor (int i = 0; i < folder.numUnpackSubStreams; i++) {\nsubStreamsInfo.hasCrc.set(nextCrc, hasMissingCrc.get(nextMissingCrc));\nsubStreamsInfo.crcs[nextCrc] = missingCrcs[nextMissingCrc];\n++nextCrc;\n++nextMissingCrc;\n}\n}\n}\n\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated SubStreamsInfo\");\n}\n\narchive.subStreamsInfo = subStreamsInfo;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFolder(Ljava/io/DataInput;)Lorg/apache/commons/compress/archivers/sevenz/Folder;",
                                    "method_body": "private Folder readFolder(final DataInput header) throws IOException {\nfinal Folder folder = new Folder();\n\nfinal long numCoders = readUint64(header);\nfinal Coder[] coders = new Coder[(int)numCoders];\nlong totalInStreams = 0;\nlong totalOutStreams = 0;\nfor (int i = 0; i < coders.length; i++) {\ncoders[i] = new Coder();\nfinal int bits = header.readUnsignedByte();\nfinal int idSize = bits & 0xf;\nfinal boolean isSimple = (bits & 0x10) == 0;\nfinal boolean hasAttributes = (bits & 0x20) != 0;\nfinal boolean moreAlternativeMethods = (bits & 0x80) != 0;\n\ncoders[i].decompressionMethodId = new byte[idSize];\nheader.readFully(coders[i].decompressionMethodId);\nif (isSimple) {\ncoders[i].numInStreams = 1;\ncoders[i].numOutStreams = 1;\n} else {\ncoders[i].numInStreams = readUint64(header);\ncoders[i].numOutStreams = readUint64(header);\n}\ntotalInStreams += coders[i].numInStreams;\ntotalOutStreams += coders[i].numOutStreams;\nif (hasAttributes) {\nfinal long propertiesSize = readUint64(header);\ncoders[i].properties = new byte[(int)propertiesSize];\nheader.readFully(coders[i].properties);\n}\n// would need to keep looping as above:\nwhile (moreAlternativeMethods) {\nthrow new IOException(\"Alternative methods are unsupported, please report. \" +\n\"The reference implementation doesn't support them either.\");\n}\n}\nfolder.coders = coders;\nfolder.totalInputStreams = totalInStreams;\nfolder.totalOutputStreams = totalOutStreams;\n\nif (totalOutStreams == 0) {\nthrow new IOException(\"Total output streams can't be 0\");\n}\nfinal long numBindPairs = totalOutStreams - 1;\nfinal BindPair[] bindPairs = new BindPair[(int)numBindPairs];\nfor (int i = 0; i < bindPairs.length; i++) {\nbindPairs[i] = new BindPair();\nbindPairs[i].inIndex = readUint64(header);\nbindPairs[i].outIndex = readUint64(header);\n}\nfolder.bindPairs = bindPairs;\n\nif (totalInStreams < numBindPairs) {\nthrow new IOException(\"Total input streams can't be less than the number of bind pairs\");\n}\nfinal long numPackedStreams = totalInStreams - numBindPairs;\nfinal long packedStreams[] = new long[(int)numPackedStreams];\nif (numPackedStreams == 1) {\nint i;\nfor (i = 0; i < (int)totalInStreams; i++) {\nif (folder.findBindPairForInStream(i) < 0) {\nbreak;\n}\n}\nif (i == (int)totalInStreams) {\nthrow new IOException(\"Couldn't find stream's bind pair index\");\n}\npackedStreams[0] = i;\n} else {\nfor (int i = 0; i < (int)numPackedStreams; i++) {\npackedStreams[i] = readUint64(header);\n}\n}\nfolder.packedStreams = packedStreams;\n\nreturn folder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readAllOrBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readAllOrBits(final DataInput header, final int size) throws IOException {\nfinal int areAllDefined = header.readUnsignedByte();\nfinal BitSet bits;\nif (areAllDefined != 0) {\nbits = new BitSet(size);\nfor (int i = 0; i < size; i++) {\nbits.set(i, true);\n}\n} else {\nbits = readBits(header, size);\n}\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
                                    "method_body": "private BitSet readBits(final DataInput header, final int size) throws IOException {\nfinal BitSet bits = new BitSet(size);\nint mask = 0;\nint cache = 0;\nfor (int i = 0; i < size; i++) {\nif (mask == 0) {\nmask = 0x80;\ncache = header.readUnsignedByte();\n}\nbits.set(i, (cache & mask) != 0);\nmask >>>= 1;\n}\nreturn bits;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFilesInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void readFilesInfo(final DataInput header, final Archive archive) throws IOException {\nfinal long numFiles = readUint64(header);\nfinal SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\nfor (int i = 0; i < files.length; i++) {\nfiles[i] = new SevenZArchiveEntry();\n}\nBitSet isEmptyStream = null;\nBitSet isEmptyFile = null;\nBitSet isAnti = null;\nwhile (true) {\nfinal int propertyType = header.readUnsignedByte();\nif (propertyType == 0) {\nbreak;\n}\nfinal long size = readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream: {\nisEmptyStream = readBits(header, files.length);\nbreak;\n}\ncase NID.kEmptyFile: {\nif (isEmptyStream == null) { // protect against NPE\nthrow new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n}\nisEmptyFile = readBits(header, isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kAnti: {\nif (isEmptyStream == null) { // protect against NPE\nthrow new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n}\nisAnti = readBits(header, isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kName: {\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Not implemented\");\n}\nif (((size - 1) & 1) != 0) {\nthrow new IOException(\"File names length invalid\");\n}\nfinal byte[] names = new byte[(int)(size - 1)];\nheader.readFully(names);\nint nextFile = 0;\nint nextName = 0;\nfor (int i = 0; i < names.length; i += 2) {\nif (names[i] == 0 && names[i+1] == 0) {\nfiles[nextFile++].setName(new String(names, nextName, i-nextName, CharsetNames.UTF_16LE));\nnextName = i + 2;\n}\n}\nif (nextName != names.length || nextFile != files.length) {\nthrow new IOException(\"Error parsing file names\");\n}\nbreak;\n}\ncase NID.kCTime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasCreationDate(timesDefined.get(i));\nif (files[i].getHasCreationDate()) {\nfiles[i].setCreationDate(Long.reverseBytes(header.readLong()));\n}\n}\nbreak;\n}\ncase NID.kATime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasAccessDate(timesDefined.get(i));\nif (files[i].getHasAccessDate()) {\nfiles[i].setAccessDate(Long.reverseBytes(header.readLong()));\n}\n}\nbreak;\n}\ncase NID.kMTime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasLastModifiedDate(timesDefined.get(i));\nif (files[i].getHasLastModifiedDate()) {\nfiles[i].setLastModifiedDate(Long.reverseBytes(header.readLong()));\n}\n}\nbreak;\n}\ncase NID.kWinAttributes: {\nfinal BitSet attributesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n}\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasWindowsAttributes(attributesDefined.get(i));\nif (files[i].getHasWindowsAttributes()) {\nfiles[i].setWindowsAttributes(Integer.reverseBytes(header.readInt()));\n}\n}\nbreak;\n}\ncase NID.kStartPos: {\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy: {\n// 7z 9.20 asserts the content is all zeros and ignores the property\n// Compress up to 1.8.1 would throw an exception, now we ignore it (see COMPRESS-287\n\nif (skipBytesFully(header, size) < size) {\nthrow new IOException(\"Incomplete kDummy property\");\n}\nbreak;\n}\n\ndefault: {\n// Compress up to 1.8.1 would throw an exception, now we ignore it (see COMPRESS-287\nif (skipBytesFully(header, size) < size) {\nthrow new IOException(\"Incomplete property of type \" + propertyType);\n}\nbreak;\n}\n}\n}\nint nonEmptyFileCounter = 0;\nint emptyFileCounter = 0;\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasStream(isEmptyStream == null ? true : !isEmptyStream.get(i));\nif (files[i].hasStream()) {\nfiles[i].setDirectory(false);\nfiles[i].setAntiItem(false);\nfiles[i].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nfiles[i].setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nfiles[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n} else {\nfiles[i].setDirectory(isEmptyFile == null ? true : !isEmptyFile.get(emptyFileCounter));\nfiles[i].setAntiItem(isAnti == null ? false : isAnti.get(emptyFileCounter));\nfiles[i].setHasCrc(false);\nfiles[i].setSize(0);\n++emptyFileCounter;\n}\n}\narchive.files = files;\ncalculateStreamMap(archive);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:calculateStreamMap(Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
                                    "method_body": "private void calculateStreamMap(final Archive archive) throws IOException {\nfinal StreamMap streamMap = new StreamMap();\n\nint nextFolderPackStreamIndex = 0;\nfinal int numFolders = archive.folders != null ? archive.folders.length : 0;\nstreamMap.folderFirstPackStreamIndex = new int[numFolders];\nfor (int i = 0; i < numFolders; i++) {\nstreamMap.folderFirstPackStreamIndex[i] = nextFolderPackStreamIndex;\nnextFolderPackStreamIndex += archive.folders[i].packedStreams.length;\n}\n\nlong nextPackStreamOffset = 0;\nfinal int numPackSizes = archive.packSizes != null ? archive.packSizes.length : 0;\nstreamMap.packStreamOffsets = new long[numPackSizes];\nfor (int i = 0; i < numPackSizes; i++) {\nstreamMap.packStreamOffsets[i] = nextPackStreamOffset;\nnextPackStreamOffset += archive.packSizes[i];\n}\n\nstreamMap.folderFirstFileIndex = new int[numFolders];\nstreamMap.fileFolderIndex = new int[archive.files.length];\nint nextFolderIndex = 0;\nint nextFolderUnpackStreamIndex = 0;\nfor (int i = 0; i < archive.files.length; i++) {\nif (!archive.files[i].hasStream() && nextFolderUnpackStreamIndex == 0) {\nstreamMap.fileFolderIndex[i] = -1;\ncontinue;\n}\nif (nextFolderUnpackStreamIndex == 0) {\nfor (; nextFolderIndex < archive.folders.length; ++nextFolderIndex) {\nstreamMap.folderFirstFileIndex[nextFolderIndex] = i;\nif (archive.folders[nextFolderIndex].numUnpackSubStreams > 0) {\nbreak;\n}\n}\nif (nextFolderIndex >= archive.folders.length) {\nthrow new IOException(\"Too few folders in archive\");\n}\n}\nstreamMap.fileFolderIndex[i] = nextFolderIndex;\nif (!archive.files[i].hasStream()) {\ncontinue;\n}\n++nextFolderUnpackStreamIndex;\nif (nextFolderUnpackStreamIndex >= archive.folders[nextFolderIndex].numUnpackSubStreams) {\n++nextFolderIndex;\nnextFolderUnpackStreamIndex = 0;\n}\n}\n\narchive.streamMap = streamMap;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:buildDecodingStream()V",
                                    "method_body": "private void buildDecodingStream() throws IOException {\nfinal int folderIndex = archive.streamMap.fileFolderIndex[currentEntryIndex];\nif (folderIndex < 0) {\ndeferredBlockStreams.clear();\n// TODO: previously it'd return an empty stream?\n// new BoundedInputStream(new ByteArrayInputStream(new byte[0]), 0);\nreturn;\n}\nfinal SevenZArchiveEntry file = archive.files[currentEntryIndex];\nif (currentFolderIndex == folderIndex) {\n// (COMPRESS-320).\n// The current entry is within the same (potentially opened) folder. The\n// previous stream has to be fully decoded before we can start reading\n// but don't do it eagerly -- if the user skips over the entire folder nothing\n// is effectively decompressed.\n\nfile.setContentMethods(archive.files[currentEntryIndex - 1].getContentMethods());\n} else {\n// We're opening a new folder. Discard any queued streams/ folder stream.\ncurrentFolderIndex = folderIndex;\ndeferredBlockStreams.clear();\nif (currentFolderInputStream != null) {\ncurrentFolderInputStream.close();\ncurrentFolderInputStream = null;\n}\n\nfinal Folder folder = archive.folders[folderIndex];\nfinal int firstPackStreamIndex = archive.streamMap.folderFirstPackStreamIndex[folderIndex];\nfinal long folderOffset = SIGNATURE_HEADER_SIZE + archive.packPos +\narchive.streamMap.packStreamOffsets[firstPackStreamIndex];\ncurrentFolderInputStream = buildDecoderStack(folder, folderOffset, firstPackStreamIndex, file);\n}\n\nInputStream fileStream = new BoundedInputStream(currentFolderInputStream, file.getSize());\nif (file.getHasCrc()) {\nfileStream = new CRC32VerifyingInputStream(fileStream, file.getSize(), file.getCrcValue());\n}\n\ndeferredBlockStreams.add(fileStream);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:buildDecoderStack(Lorg/apache/commons/compress/archivers/sevenz/Folder;JILorg/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry;)Ljava/io/InputStream;",
                                    "method_body": "private InputStream buildDecoderStack(final Folder folder, final long folderOffset,\nfinal int firstPackStreamIndex, final SevenZArchiveEntry entry) throws IOException {\nfile.seek(folderOffset);\nInputStream inputStreamStack =\nnew BufferedInputStream(\nnew BoundedRandomAccessFileInputStream(file,\narchive.packSizes[firstPackStreamIndex]));\nfinal LinkedList<SevenZMethodConfiguration> methods = new LinkedList<SevenZMethodConfiguration>();\nfor (final Coder coder : folder.getOrderedCoders()) {\nif (coder.numInStreams != 1 || coder.numOutStreams != 1) {\nthrow new IOException(\"Multi input/output stream coders are not yet supported\");\n}\nfinal SevenZMethod method = SevenZMethod.byId(coder.decompressionMethodId);\ninputStreamStack = Coders.addDecoder(fileName, inputStreamStack,\nfolder.getUnpackSizeForCoder(coder), coder, password);\nmethods.addFirst(new SevenZMethodConfiguration(method,\nCoders.findByMethod(method).getOptionsFromCoder(coder, inputStreamStack)));\n}\nentry.setContentMethods(methods);\nif (folder.hasCrc) {\nreturn new CRC32VerifyingInputStream(inputStreamStack,\nfolder.getUnpackSize(), folder.crc);\n}\nreturn inputStreamStack;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:read()I",
                                    "method_body": "public int read() throws IOException {\nreturn getCurrentStream().read();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:getCurrentStream()Ljava/io/InputStream;",
                                    "method_body": "private InputStream getCurrentStream() throws IOException {\nif (deferredBlockStreams.isEmpty()) {\nthrow new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n}\n\nwhile (deferredBlockStreams.size() > 1) {\n// In solid compression mode we need to decompress all leading folder'\n// streams to get access to an entry. We defer this until really needed\n// so that entire blocks can be skipped without wasting time for decompression.\nfinal InputStream stream = deferredBlockStreams.remove(0);\nIOUtils.skip(stream, Long.MAX_VALUE);\nstream.close();\n}\n\nreturn deferredBlockStreams.get(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUint64(Ljava/io/DataInput;)J",
                                    "method_body": "private static long readUint64(final DataInput in) throws IOException {\n// long rather than int as it might get shifted beyond the range of an int\nfinal long firstByte = in.readUnsignedByte();\nint mask = 0x80;\nlong value = 0;\nfor (int i = 0; i < 8; i++) {\nif ((firstByte & mask) == 0) {\nreturn value | ((firstByte & (mask - 1)) << (8 * i));\n}\nfinal long nextByte = in.readUnsignedByte();\nvalue |= nextByte << (8 * i);\nmask >>>= 1;\n}\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:<init>(Ljava/lang/String;I[B)V",
                                    "method_body": "private SevenZMethod(final byte[] id) {\nthis.id = id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:byId([B)Lorg/apache/commons/compress/archivers/sevenz/SevenZMethod;",
                                    "method_body": "static SevenZMethod byId(final byte[] id) {\nfor (final SevenZMethod m : SevenZMethod.class.getEnumConstants()) {\nif (Arrays.equals(m.id, id)) {\nreturn m;\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;JJ)V",
                                    "method_body": "public ChecksumVerifyingInputStream(final Checksum checksum, final InputStream in,\nfinal long size, final long expectedChecksum) {\nthis.checksum = checksum;\nthis.in = in;\nthis.expectedChecksum = expectedChecksum;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining <= 0) {\nreturn -1;\n}\nfinal int ret = in.read();\nif (ret >= 0) {\nchecksum.update(ret);\n--bytesRemaining;\n}\nif (bytesRemaining == 0 && expectedChecksum != checksum.getValue()) {\nthrow new IOException(\"Checksum verification failed\");\n}\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read([BII)I",
                                    "method_body": "public int read(final byte[] b, final int off, final int len) throws IOException {\nfinal int ret = in.read(b, off, len);\nif (ret >= 0) {\nchecksum.update(b, off, ret);\nbytesRemaining -= ret;\n}\nif (bytesRemaining <= 0 && expectedChecksum != checksum.getValue()) {\nthrow new IOException(\"Checksum verification failed\");\n}\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:skip(J)J",
                                    "method_body": "public long skip(final long n) throws IOException {\n// Can't really skip, we have to hash everything to verify the checksum\nif (read() >= 0) {\nreturn 1;\n}\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nin.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.CRC32VerifyingInputStream:<init>(Ljava/io/InputStream;JJ)V",
                                    "method_body": "public CRC32VerifyingInputStream(final InputStream in, final long size, final long expectedCrc32) {\nsuper(new CRC32(), in, size, expectedCrc32);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:<init>(Ljava/io/RandomAccessFile;J)V",
                                    "method_body": "public BoundedRandomAccessFileInputStream(final RandomAccessFile file,\nfinal long size) {\nthis.file = file;\nthis.bytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining > 0) {\n--bytesRemaining;\nreturn file.read();\n}\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read([BII)I",
                                    "method_body": "public int read(final byte[] b, final int off, final int len) throws IOException {\nif (bytesRemaining == 0) {\nreturn -1;\n}\nint bytesToRead = len;\nif (bytesToRead > bytesRemaining) {\nbytesToRead = (int) bytesRemaining;\n}\nfinal int bytesRead = file.read(b, off, bytesToRead);\nif (bytesRead >= 0) {\nbytesRemaining -= bytesRead;\n}\nreturn bytesRead;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:close()V",
                                    "method_body": "public void close() {\n// the nested RandomAccessFile is controlled externally\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:getOrderedCoders()Ljava/lang/Iterable;",
                                    "method_body": "Iterable<Coder> getOrderedCoders() {\nfinal LinkedList<Coder> l = new LinkedList<Coder>();\nint current = (int) packedStreams[0]; // more that 2^31 coders?\nwhile (current != -1) {\nl.addLast(coders[current]);\nfinal int pair = findBindPairForOutStream(current);\ncurrent = pair != -1 ? (int) bindPairs[pair].inIndex : -1;\n}\nreturn l;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:findBindPairForInStream(I)I",
                                    "method_body": "int findBindPairForInStream(final int index) {\nfor (int i = 0; i < bindPairs.length; i++) {\nif (bindPairs[i].inIndex == index) {\nreturn i;\n}\n}\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:findBindPairForOutStream(I)I",
                                    "method_body": "int findBindPairForOutStream(final int index) {\nfor (int i = 0; i < bindPairs.length; i++) {\nif (bindPairs[i].outIndex == index) {\nreturn i;\n}\n}\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:getUnpackSize()J",
                                    "method_body": "long getUnpackSize() {\nif (totalOutputStreams == 0) {\nreturn 0;\n}\nfor (int i = ((int)totalOutputStreams) - 1; i >= 0; i--) {\nif (findBindPairForOutStream(i) < 0) {\nreturn unpackSizes[i];\n}\n}\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Folder:getUnpackSizeForCoder(Lorg/apache/commons/compress/archivers/sevenz/Coder;)J",
                                    "method_body": "long getUnpackSizeForCoder(final Coder coder) {\nif (coders != null) {\nfor (int i = 0; i < coders.length; i++) {\nif (coders[i] == coder) {\nreturn unpackSizes[i];\n}\n}\n}\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders:<clinit>()V",
                                    "method_body": "private static final Map<SevenZMethod, CoderBase> CODER_MAP = new HashMap<SevenZMethod, CoderBase>() {\n\nprivate static final long serialVersionUID = 1664829131806520867L;\n{\nput(SevenZMethod.COPY, new CopyDecoder());\nput(SevenZMethod.LZMA, new LZMADecoder());\nput(SevenZMethod.LZMA2, new LZMA2Decoder());\nput(SevenZMethod.DEFLATE, new DeflateDecoder());\nput(SevenZMethod.BZIP2, new BZIP2Decoder());\nput(SevenZMethod.AES256SHA256, new AES256SHA256Decoder());\nput(SevenZMethod.BCJ_X86_FILTER, new BCJDecoder(new X86Options()));\nput(SevenZMethod.BCJ_PPC_FILTER, new BCJDecoder(new PowerPCOptions()));\nput(SevenZMethod.BCJ_IA64_FILTER, new BCJDecoder(new IA64Options()));\nput(SevenZMethod.BCJ_ARM_FILTER, new BCJDecoder(new ARMOptions()));\nput(SevenZMethod.BCJ_ARM_THUMB_FILTER, new BCJDecoder(new ARMThumbOptions()));\nput(SevenZMethod.BCJ_SPARC_FILTER, new BCJDecoder(new SPARCOptions()));\nput(SevenZMethod.DELTA_FILTER, new DeltaDecoder());\n}};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders:findByMethod(Lorg/apache/commons/compress/archivers/sevenz/SevenZMethod;)Lorg/apache/commons/compress/archivers/sevenz/CoderBase;",
                                    "method_body": "static CoderBase findByMethod(final SevenZMethod method) {\nreturn CODER_MAP.get(method);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders:addDecoder(Ljava/lang/String;Ljava/io/InputStream;JLorg/apache/commons/compress/archivers/sevenz/Coder;[B)Ljava/io/InputStream;",
                                    "method_body": "static InputStream addDecoder(final String archiveName, final InputStream is, final long uncompressedLength,\nfinal Coder coder, final byte[] password) throws IOException {\nfinal CoderBase cb = findByMethod(SevenZMethod.byId(coder.decompressionMethodId));\nif (cb == null) {\nthrow new IOException(\"Unsupported compression method \" +\nArrays.toString(coder.decompressionMethodId)\n+ \" used in \" + archiveName);\n}\nreturn cb.decode(archiveName, is, uncompressedLength, coder, password);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.CoderBase:<init>([Ljava/lang/Class;)V",
                                    "method_body": "protected CoderBase(final Class<?>... acceptableOptions) {\nthis.acceptableOptions = acceptableOptions;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.CoderBase:<clinit>()V",
                                    "method_body": "private final Class<?>[] acceptableOptions;\nprivate static final byte[] NONE = new byte[0];\n\n/**\n* @param acceptableOptions types that can be used as options for this codec.\n*/\nprotected CoderBase(final Class<?>... acceptableOptions) {\nthis.acceptableOptions = acceptableOptions;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.CoderBase:getOptionsFromCoder(Lorg/apache/commons/compress/archivers/sevenz/Coder;Ljava/io/InputStream;)Ljava/lang/Object;",
                                    "method_body": "Object getOptionsFromCoder(final Coder coder, final InputStream in) {\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$LZMADecoder:decode(Ljava/lang/String;Ljava/io/InputStream;JLorg/apache/commons/compress/archivers/sevenz/Coder;[B)Ljava/io/InputStream;",
                                    "method_body": "InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength,\nfinal Coder coder, final byte[] password) throws IOException {\nfinal byte propsByte = coder.properties[0];\nlong dictSize = coder.properties[1];\nfor (int i = 1; i < 4; i++) {\ndictSize |= (coder.properties[i + 1] & 0xffl) << (8 * i);\n}\nif (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\nthrow new IOException(\"Dictionary larger than 4GiB maximum size used in \" + archiveName);\n}\nreturn new LZMAInputStream(in, uncompressedLength, propsByte, (int) dictSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.LZMA2Decoder:<init>()V",
                                    "method_body": "LZMA2Decoder() {\nsuper(LZMA2Options.class, Number.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$DeflateDecoder:<init>()V",
                                    "method_body": "DeflateDecoder() {\nsuper(Number.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$BZIP2Decoder:<init>()V",
                                    "method_body": "BZIP2Decoder() {\nsuper(Number.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.Coders$BCJDecoder:<init>(Lorg/tukaani/xz/FilterOptions;)V",
                                    "method_body": "BCJDecoder(final FilterOptions opts) {\nthis.opts = opts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.DeltaDecoder:<init>()V",
                                    "method_body": "DeltaDecoder() {\nsuper(Number.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:<init>()V",
                                    "method_body": "public SevenZArchiveEntry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "public void setName(final String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:hasStream()Z",
                                    "method_body": "public boolean hasStream() {\nreturn hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasStream(Z)V",
                                    "method_body": "public void setHasStream(final boolean hasStream) {\nthis.hasStream = hasStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setDirectory(Z)V",
                                    "method_body": "public void setDirectory(final boolean isDirectory) {\nthis.isDirectory = isDirectory;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setAntiItem(Z)V",
                                    "method_body": "public void setAntiItem(final boolean isAntiItem) {\nthis.isAntiItem = isAntiItem;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasLastModifiedDate()Z",
                                    "method_body": "public boolean getHasLastModifiedDate() {\nreturn hasLastModifiedDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasLastModifiedDate(Z)V",
                                    "method_body": "public void setHasLastModifiedDate(final boolean hasLastModifiedDate) {\nthis.hasLastModifiedDate = hasLastModifiedDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setLastModifiedDate(J)V",
                                    "method_body": "public void setLastModifiedDate(final long ntfsLastModifiedDate) {\nthis.lastModifiedDate = ntfsLastModifiedDate;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasWindowsAttributes()Z",
                                    "method_body": "public boolean getHasWindowsAttributes() {\nreturn hasWindowsAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasWindowsAttributes(Z)V",
                                    "method_body": "public void setHasWindowsAttributes(final boolean hasWindowsAttributes) {\nthis.hasWindowsAttributes = hasWindowsAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setWindowsAttributes(I)V",
                                    "method_body": "public void setWindowsAttributes(final int windowsAttributes) {\nthis.windowsAttributes = windowsAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasCrc()Z",
                                    "method_body": "public boolean getHasCrc() {\nreturn hasCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasCrc(Z)V",
                                    "method_body": "public void setHasCrc(final boolean hasCrc) {\nthis.hasCrc = hasCrc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getCrcValue()J",
                                    "method_body": "public long getCrcValue() {\nreturn crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCrcValue(J)V",
                                    "method_body": "public void setCrcValue(final long crc) {\nthis.crc = crc;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(final long size) {\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setContentMethods(Ljava/lang/Iterable;)V",
                                    "method_body": "public void setContentMethods(final Iterable<? extends SevenZMethodConfiguration> methods) {\nif (methods != null) {\nfinal LinkedList<SevenZMethodConfiguration> l = new LinkedList<SevenZMethodConfiguration>();\nfor (final SevenZMethodConfiguration m : methods) {\nl.addLast(m);\n}\ncontentMethods = Collections.unmodifiableList(l);\n} else {\ncontentMethods = null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getContentMethods()Ljava/lang/Iterable;",
                                    "method_body": "public Iterable<? extends SevenZMethodConfiguration> getContentMethods() {\nreturn contentMethods;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethodConfiguration:<init>(Lorg/apache/commons/compress/archivers/sevenz/SevenZMethod;Ljava/lang/Object;)V",
                                    "method_body": "public SevenZMethodConfiguration(final SevenZMethod method, final Object options) {\nthis.method = method;\nthis.options = options;\nif (options != null && !Coders.findByMethod(method).canAcceptOptions(options)) {\nthrow new IllegalArgumentException(\"The \" + method + \" method doesn't support options of type \"\n+ options.getClass());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.BoundedInputStream:<init>(Ljava/io/InputStream;J)V",
                                    "method_body": "public BoundedInputStream(final InputStream in, final long size) {\nthis.in = in;\nbytesRemaining = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.BoundedInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nif (bytesRemaining > 0) {\n--bytesRemaining;\nreturn in.read();\n}\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.BoundedInputStream:read([BII)I",
                                    "method_body": "public int read(final byte[] b, final int off, final int len) throws IOException {\nif (bytesRemaining == 0) {\nreturn -1;\n}\nint bytesToRead = len;\nif (bytesToRead > bytesRemaining) {\nbytesToRead = (int) bytesRemaining;\n}\nfinal int bytesRead = in.read(b, off, bytesToRead);\nif (bytesRead >= 0) {\nbytesRemaining -= bytesRead;\n}\nreturn bytesRead;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.BoundedInputStream:close()V",
                                    "method_body": "public void close() {\n// there isn't anything to close in this stream and the nested\n// stream is controlled externally\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 37,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest.survivesBlankLinesInPaxHeader",
                            "test_body": "305: public void survivesBlankLinesInPaxHeader() throws Exception {\n306: final TarArchiveInputStream is = getTestStream(\"/COMPRESS-355.tar\");\n307: try {\n308: final TarArchiveEntry entry = is.getNextTarEntry();\n309: assertEquals(\"package/package.json\", entry.getName());\n310: assertNull(is.getNextTarEntry());\n311: } finally {\n312: is.close();\n313: }\n314: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n\nstatic {\nfinal Map<String, SimpleEncodingHolder> se =\nnew HashMap<String, SimpleEncodingHolder>();\n\nfinal char[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nfinal SimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\n\nfinal char[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nfinal SimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(final String name) {\n\n// fallback encoding is good enough for UTF-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nfinal SimpleEncodingHolder h = simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nfinal Charset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (final UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\n// check platform's default encoding\ncharsetName = Charset.defaultCharset().name();\n}\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}\nfor (final String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(final char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(final String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(final byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data);\n}\nreturn new String(data,this.charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\n\n/**\n* <p>\n* Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\n* (either order accepted on input, big-endian used on output)\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, big-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, little-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\n\n/**\n* <p>\n* Eight-bit Unicode Transformation Format.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry() {\nString user = System.getProperty(\"user.name\", \"\");\n\nif (user.length() > MAX_NAMELEN) {\nuser = user.substring(0, MAX_NAMELEN);\n}\n\nthis.userName = user;\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public TarArchiveEntry(final byte[] headerBuf, final ZipEncoding encoding)\nthrows IOException {\nthis();\nparseTarHeader(headerBuf, encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<clinit>()V",
                                    "method_body": "private static final TarArchiveEntry[] EMPTY_TAR_ARCHIVE_ENTRIES = new TarArchiveEntry[0];\n\n/** The entry's name. */\nprivate String name = \"\";\n\n/** Whether to enforce leading slashes on the name */\nprivate boolean preserveLeadingSlashes;\n\n/** The entry's permission mode. */\nprivate int mode;\n\n/** The entry's user id. */\nprivate long userId = 0;\n\n/** The entry's group id. */\nprivate long groupId = 0;\n\n/** The entry's size. */\nprivate long size = 0;\n\n/** The entry's modification time. */\nprivate long modTime;\n\n/** If the header checksum is reasonably correct. */\nprivate boolean checkSumOK;\n\n/** The entry's link flag. */\nprivate byte linkFlag;\n\n/** The entry's link name. */\nprivate String linkName = \"\";\n\n/** The entry's magic tag. */\nprivate String magic = MAGIC_POSIX;\n/** The version of the format */\nprivate String version = VERSION_POSIX;\n\n/** The entry's user name. */\nprivate String userName;\n\n/** The entry's group name. */\nprivate String groupName = \"\";\n\n/** The entry's major device number. */\nprivate int devMajor = 0;\n\n/** The entry's minor device number. */\nprivate int devMinor = 0;\n\n/** If an extension sparse header follows. */\nprivate boolean isExtended;\n\n/** The entry's real size in case of a sparse file. */\nprivate long realSize;\n\n/** is this entry a GNU sparse entry using one of the PAX formats? */\nprivate boolean paxGNUSparse;\n\n/** is this entry a star sparse entry using the PAX header? */\nprivate boolean starSparse;\n\n/** The entry's file reference */\nprivate final File file;\n\n/** Maximum length of a user's name in the tar file */\npublic static final int MAX_NAMELEN = 31;\n\n/** Default permissions bits for directories */\npublic static final int DEFAULT_DIR_MODE = 040755;\n\n/** Default permissions bits for files */\npublic static final int DEFAULT_FILE_MODE = 0100644;\n\n/** Convert millis to seconds */\npublic static final int MILLIS_PER_SECOND = 1000;\n\n/**\n* Construct an empty entry and prepares the header values.\n*/\nprivate TarArchiveEntry() {\nString user = System.getProperty(\"user.name\", \"\");\n\nif (user.length() > MAX_NAMELEN) {\nuser = user.substring(0, MAX_NAMELEN);\n}\n\nthis.userName = user;\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongLinkEntry()Z",
                                    "method_body": "public boolean isGNULongLinkEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGLINK;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongNameEntry()Z",
                                    "method_body": "public boolean isGNULongNameEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGNAME;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isPaxHeader()Z",
                                    "method_body": "public boolean isPaxHeader(){\nreturn linkFlag == LF_PAX_EXTENDED_HEADER_LC\n|| linkFlag == LF_PAX_EXTENDED_HEADER_UC;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGlobalPaxHeader()Z",
                                    "method_body": "public boolean isGlobalPaxHeader(){\nreturn linkFlag == LF_PAX_GLOBAL_EXTENDED_HEADER;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nif (file != null) {\nreturn file.isDirectory();\n}\n\nif (linkFlag == LF_DIR) {\nreturn true;\n}\n\nif (getName().endsWith(\"/\")) {\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public void parseTarHeader(final byte[] header, final ZipEncoding encoding)\nthrows IOException {\nparseTarHeader(header, encoding, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;Z)V",
                                    "method_body": "private void parseTarHeader(final byte[] header, final ZipEncoding encoding,\nfinal boolean oldStyle)\nthrows IOException {\nint offset = 0;\n\nname = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n: TarUtils.parseName(header, offset, NAMELEN, encoding);\noffset += NAMELEN;\nmode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN);\noffset += MODELEN;\nuserId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\noffset += UIDLEN;\ngroupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\noffset += GIDLEN;\nsize = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\noffset += SIZELEN;\nmodTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN);\noffset += MODTIMELEN;\ncheckSumOK = TarUtils.verifyCheckSum(header);\noffset += CHKSUMLEN;\nlinkFlag = header[offset++];\nlinkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n: TarUtils.parseName(header, offset, NAMELEN, encoding);\noffset += NAMELEN;\nmagic = TarUtils.parseName(header, offset, MAGICLEN);\noffset += MAGICLEN;\nversion = TarUtils.parseName(header, offset, VERSIONLEN);\noffset += VERSIONLEN;\nuserName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)\n: TarUtils.parseName(header, offset, UNAMELEN, encoding);\noffset += UNAMELEN;\ngroupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN)\n: TarUtils.parseName(header, offset, GNAMELEN, encoding);\noffset += GNAMELEN;\ndevMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\ndevMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\n\nfinal int type = evaluateType(header);\nswitch (type) {\ncase FORMAT_OLDGNU: {\noffset += ATIMELEN_GNU;\noffset += CTIMELEN_GNU;\noffset += OFFSETLEN_GNU;\noffset += LONGNAMESLEN_GNU;\noffset += PAD2LEN_GNU;\noffset += SPARSELEN_GNU;\nisExtended = TarUtils.parseBoolean(header, offset);\noffset += ISEXTENDEDLEN_GNU;\nrealSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU);\noffset += REALSIZELEN_GNU;\nbreak;\n}\ncase FORMAT_XSTAR: {\nfinal String xstarPrefix = oldStyle\n? TarUtils.parseName(header, offset, PREFIXLEN_XSTAR)\n: TarUtils.parseName(header, offset, PREFIXLEN_XSTAR, encoding);\nif (xstarPrefix.length() > 0) {\nname = xstarPrefix + \"/\" + name;\n}\nbreak;\n}\ncase FORMAT_POSIX:\ndefault: {\nfinal String prefix = oldStyle\n? TarUtils.parseName(header, offset, PREFIXLEN)\n: TarUtils.parseName(header, offset, PREFIXLEN, encoding);\n// SunOS tar -E does not add / to directory names, so fix\n// up to be consistent\nif (isDirectory() && !name.endsWith(\"/\")){\nname = name + \"/\";\n}\nif (prefix.length() > 0){\nname = prefix + \"/\" + name;\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:evaluateType([B)I",
                                    "method_body": "private int evaluateType(final byte[] header) {\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_GNU, header, MAGIC_OFFSET, MAGICLEN)) {\nreturn FORMAT_OLDGNU;\n}\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_POSIX, header, MAGIC_OFFSET, MAGICLEN)) {\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_XSTAR, header, XSTAR_MAGIC_OFFSET,\nXSTAR_MAGIC_LEN)) {\nreturn FORMAT_XSTAR;\n}\nreturn FORMAT_POSIX;\n}\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:<clinit>()V",
                                    "method_body": "private static final int BYTE_MASK = 255;\n\nstatic final ZipEncoding DEFAULT_ENCODING =\nZipEncodingHelper.getZipEncoding(null);\n\n/**\n* Encapsulates the algorithms used up to Commons Compress 1.3 as\n* ZipEncoding.\n*/\nstatic final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\n@Override\npublic boolean canEncode(final String name) { return true; }\n\n@Override\npublic ByteBuffer encode(final String name) {\nfinal int length = name.length();\nfinal byte[] buf = new byte[length];\n\n// copy until end of input or output is reached.\nfor (int i = 0; i < length; ++i) {\nbuf[i] = (byte) name.charAt(i);\n}\nreturn ByteBuffer.wrap(buf);\n}\n\n@Override\npublic String decode(final byte[] buffer) {\nfinal int length = buffer.length;\nfinal StringBuilder result = new StringBuilder(length);\n\nfor (final byte b : buffer) {\nif (b == 0) { // Trailing null\nbreak;\n}\nresult.append((char) (b & 0xFF)); // Allow for sign-extension\n}\n\nreturn result.toString();\n}\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\n\nif (length < 2){\nthrow new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n}\n\nif (buffer[start] == 0) {\nreturn 0L;\n}\n\n// Skip leading spaces\nwhile (start < end){\nif (buffer[start] == ' '){\nstart++;\n} else {\nbreak;\n}\n}\n\n// Trim all trailing NULs and spaces.\n// The ustar and POSIX tar specs require a trailing NUL or\n// space but some implementations use the extra digit for big\n// sizes/uids/gids ...\nbyte trailer = buffer[end - 1];\nwhile (start < end && (trailer == 0 || trailer == ' ')) {\nend--;\ntrailer = buffer[end - 1];\n}\n\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\n// CheckStyle:MagicNumber OFF\nif (currentByte < '0' || currentByte > '7'){\nthrow new IllegalArgumentException(\nexceptionMessage(buffer, offset, length, start, currentByte));\n}\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\n// CheckStyle:MagicNumber ON\n}\n\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctalOrBinary([BII)J",
                                    "method_body": "public static long parseOctalOrBinary(final byte[] buffer, final int offset,\nfinal int length) {\n\nif ((buffer[offset] & 0x80) == 0) {\nreturn parseOctal(buffer, offset, length);\n}\nfinal boolean negative = buffer[offset] == (byte) 0xff;\nif (length < 9) {\nreturn parseBinaryLong(buffer, offset, length, negative);\n}\nreturn parseBinaryBigInteger(buffer, offset, length, negative);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseBinaryLong([BIIZ)J",
                                    "method_body": "private static long parseBinaryLong(final byte[] buffer, final int offset,\nfinal int length,\nfinal boolean negative) {\nif (length >= 9) {\nthrow new IllegalArgumentException(\"At offset \" + offset + \", \"\n+ length + \" byte binary number\"\n+ \" exceeds maximum signed long\"\n+ \" value\");\n}\nlong val = 0;\nfor (int i = 1; i < length; i++) {\nval = (val << 8) + (buffer[offset + i] & 0xff);\n}\nif (negative) {\n// 2's complement\nval--;\nval ^= (long) Math.pow(2, (length - 1) * 8) - 1;\n}\nreturn negative ? -val : val;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BII)Ljava/lang/String;",
                                    "method_body": "public static String parseName(final byte[] buffer, final int offset, final int length) {\ntry {\nreturn parseName(buffer, offset, length, DEFAULT_ENCODING);\n} catch (final IOException ex) {\ntry {\nreturn parseName(buffer, offset, length, FALLBACK_ENCODING);\n} catch (final IOException ex2) {\n// impossible\nthrow new RuntimeException(ex2);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BIILorg/apache/commons/compress/archivers/zip/ZipEncoding;)Ljava/lang/String;",
                                    "method_body": "public static String parseName(final byte[] buffer, final int offset,\nfinal int length,\nfinal ZipEncoding encoding)\nthrows IOException {\n\nint len = length;\nfor (; len > 0; len--) {\nif (buffer[offset + len - 1] != 0) {\nbreak;\n}\n}\nif (len > 0) {\nfinal byte[] b = new byte[len];\nSystem.arraycopy(buffer, offset, b, 0, len);\nreturn encoding.decode(b);\n}\nreturn \"\";\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:verifyCheckSum([B)Z",
                                    "method_body": "public static boolean verifyCheckSum(final byte[] header) {\nfinal long storedSum = parseOctal(header, CHKSUM_OFFSET, CHKSUMLEN);\nlong unsignedSum = 0;\nlong signedSum = 0;\n\nfor (int i = 0; i < header.length; i++) {\nbyte b = header[i];\nif (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\nb = ' ';\n}\nunsignedSum += 0xff & b;\nsignedSum += b;\n}\nreturn storedSum == unsignedSum || storedSum == signedSum;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:matchAsciiBuffer(Ljava/lang/String;[BII)Z",
                                    "method_body": "public static boolean matchAsciiBuffer(\nfinal String expected, final byte[] buffer, final int offset, final int length){\nbyte[] buffer1;\ntry {\nbuffer1 = expected.getBytes(CharsetNames.US_ASCII);\n} catch (final UnsupportedEncodingException e) {\nthrow new RuntimeException(e); // Should not happen\n}\nreturn isEqual(buffer1, 0, buffer1.length, buffer, offset, length, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isEqual([BII[BIIZ)Z",
                                    "method_body": "public static boolean isEqual(\nfinal byte[] buffer1, final int offset1, final int length1,\nfinal byte[] buffer2, final int offset2, final int length2,\nfinal boolean ignoreTrailingNulls){\nfinal int minLen=length1 < length2 ? length1 : length2;\nfor (int i=0; i < minLen; i++){\nif (buffer1[offset1+i] != buffer2[offset2+i]){\nreturn false;\n}\n}\nif (length1 == length2){\nreturn true;\n}\nif (ignoreTrailingNulls){\nif (length1 > length2){\nfor(int i = length2; i < length1; i++){\nif (buffer1[offset1+i] != 0){\nreturn false;\n}\n}\n} else {\nfor(int i = length1; i < length2; i++){\nif (buffer2[offset2+i] != 0){\nreturn false;\n}\n}\n}\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isArrayZero([BI)Z",
                                    "method_body": "public static boolean isArrayZero(final byte[] a, final int size) {\nfor (int i = 0; i < size; i++) {\nif (a[i] != 0) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final int SKIP_BUF_SIZE = 4096;\n\n// This buffer does not need to be synchronised because it is write only; the contents are ignored\n// Does not affect Immutability\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n\n/** Private constructor to prevent instantiation of this utility class. */\nprivate IOUtils(){\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[B)I",
                                    "method_body": "public static int readFully(final InputStream input, final byte[] b) throws IOException {\nreturn readFully(input, b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(final InputStream input, final byte[] b, final int offset, final int len)\nthrows IOException {\nif (len < 0 || offset < 0 || len + offset > b.length) {\nthrow new IndexOutOfBoundsException();\n}\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\nbreak;\n}\ncount += x;\n}\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nfinal int num = read(SINGLE, 0, 1);\nreturn num == -1 ? -1 : SINGLE[0] & BYTE_MASK;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(final int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(final long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(final InputStream is) {\nthis(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(final InputStream is, final int blockSize, final int recordSize) {\nthis(is, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;IILjava/lang/String;)V",
                                    "method_body": "public TarArchiveInputStream(final InputStream is, final int blockSize, final int recordSize,\nfinal String encoding) {\nthis.is = is;\nthis.hasHitEOF = false;\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.recordSize = recordSize;\nthis.blockSize = blockSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nis.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:available()I",
                                    "method_body": "public int available() throws IOException {\nif (isDirectory()) {\nreturn 0;\n}\nif (entrySize - entryOffset > Integer.MAX_VALUE) {\nreturn Integer.MAX_VALUE;\n}\nreturn (int) (entrySize - entryOffset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextTarEntry()Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;",
                                    "method_body": "public TarArchiveEntry getNextTarEntry() throws IOException {\nif (hasHitEOF) {\nreturn null;\n}\n\nif (currEntry != null) {\n/* Skip will only go to the end of the current entry */\nIOUtils.skip(this, Long.MAX_VALUE);\n\n/* skip to the end of the last record */\nskipRecordPadding();\n}\n\nfinal byte[] headerBuf = getRecord();\n\nif (headerBuf == null) {\n/* hit EOF */\ncurrEntry = null;\nreturn null;\n}\n\ntry {\ncurrEntry = new TarArchiveEntry(headerBuf, zipEncoding);\n} catch (final IllegalArgumentException e) {\nthrow new IOException(\"Error detected parsing the header\", e);\n}\n\nentryOffset = 0;\nentrySize = currEntry.getSize();\n\nif (currEntry.isGNULongLinkEntry()) {\nfinal byte[] longLinkData = getLongNameData();\nif (longLinkData == null) {\n// Bugzilla: 40334\n// Malformed tar file - long link entry name not followed by\n// entry\nreturn null;\n}\ncurrEntry.setLinkName(zipEncoding.decode(longLinkData));\n}\n\nif (currEntry.isGNULongNameEntry()) {\nfinal byte[] longNameData = getLongNameData();\nif (longNameData == null) {\n// Bugzilla: 40334\n// Malformed tar file - long entry name not followed by\n// entry\nreturn null;\n}\ncurrEntry.setName(zipEncoding.decode(longNameData));\n}\n\nif (currEntry.isGlobalPaxHeader()){ // Process Global Pax headers\nreadGlobalPaxHeaders();\n}\n\nif (currEntry.isPaxHeader()){ // Process Pax headers\npaxHeaders();\n} else if (!globalPaxHeaders.isEmpty()) {\napplyPaxHeadersToCurrentEntry(globalPaxHeaders);\n}\n\nif (currEntry.isOldGNUSparse()){ // Process sparse files\nreadOldGNUSparse();\n}\n\n// If the size of the next element in the archive has changed\n// due to a new size being reported in the posix header\n// information, we update entrySize here so that it contains\n// the correct value.\nentrySize = currEntry.getSize();\n\nreturn currEntry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getRecord()[B",
                                    "method_body": "private byte[] getRecord() throws IOException {\nbyte[] headerBuf = readRecord();\nhasHitEOF = isEOFRecord(headerBuf);\nif (hasHitEOF && headerBuf != null) {\ntryToConsumeSecondEOFRecord();\nconsumeRemainderOfLastBlock();\nheaderBuf = null;\n}\nreturn headerBuf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:isEOFRecord([B)Z",
                                    "method_body": "protected boolean isEOFRecord(final byte[] record) {\nreturn record == null || ArchiveUtils.isArrayZero(record, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:readRecord()[B",
                                    "method_body": "protected byte[] readRecord() throws IOException {\n\nfinal byte[] record = new byte[recordSize];\n\nfinal int readNow = IOUtils.readFully(is, record);\ncount(readNow);\nif (readNow != recordSize) {\nreturn null;\n}\n\nreturn record;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:paxHeaders()V",
                                    "method_body": "private void paxHeaders() throws IOException{\nfinal Map<String, String> headers = parsePaxHeaders(this);\ngetNextEntry(); // Get the actual file entry\napplyPaxHeadersToCurrentEntry(headers);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:parsePaxHeaders(Ljava/io/InputStream;)Ljava/util/Map;",
                                    "method_body": "Map<String, String> parsePaxHeaders(final InputStream i)\nthrows IOException {\nfinal Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n// Format is \"length keyword=value\\n\";\nwhile(true){ // get length\nint ch;\nint len = 0;\nint read = 0;\nwhile((ch = i.read()) != -1) {\nread++;\nif (ch == ' '){\n// Get keyword\nfinal ByteArrayOutputStream coll = new ByteArrayOutputStream();\nwhile((ch = i.read()) != -1) {\nread++;\nif (ch == '='){ // end of keyword\nfinal String keyword = coll.toString(CharsetNames.UTF_8);\n// Get rest of entry\nfinal int restLen = len - read;\nif (restLen == 1) { // only NL\nheaders.remove(keyword);\n} else {\nfinal byte[] rest = new byte[restLen];\nfinal int got = IOUtils.readFully(i, rest);\nif (got != restLen) {\nthrow new IOException(\"Failed to read \"\n+ \"Paxheader. Expected \"\n+ restLen\n+ \" bytes, read \"\n+ got);\n}\n// Drop trailing NL\nfinal String value = new String(rest, 0,\nrestLen - 1, CharsetNames.UTF_8);\nheaders.put(keyword, value);\n}\nbreak;\n}\ncoll.write((byte) ch);\n}\nbreak; // Processed single header\n}\nlen *= 10;\nlen += ch - '0';\n}\nif (ch == -1){ // EOF\nbreak;\n}\n}\nreturn headers;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:isDirectory()Z",
                                    "method_body": "private boolean isDirectory() {\nreturn currEntry != null && currEntry.isDirectory();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:read([BII)I",
                                    "method_body": "public int read(final byte[] buf, final int offset, int numToRead) throws IOException {\nint totalRead = 0;\n\nif (hasHitEOF || isDirectory() || entryOffset >= entrySize) {\nreturn -1;\n}\n\nif (currEntry == null) {\nthrow new IllegalStateException(\"No current tar entry\");\n}\n\nnumToRead = Math.min(numToRead, available());\n\ntotalRead = is.read(buf, offset, numToRead);\n\nif (totalRead == -1) {\nif (numToRead > 0) {\nthrow new IOException(\"Truncated TAR archive\");\n}\nhasHitEOF = true;\n} else {\ncount(totalRead);\nentryOffset += totalRead;\n}\n\nreturn totalRead;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 38,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest.survivesPaxHeaderWithNameEndingInSlash",
                            "test_body": "320: public void survivesPaxHeaderWithNameEndingInSlash() throws Exception {\n321: final TarArchiveInputStream is = getTestStream(\"/COMPRESS-356.tar\");\n322: try {\n323: final TarArchiveEntry entry = is.getNextTarEntry();\n324: assertEquals(\"package/package.json\", entry.getName());\n325: assertNull(is.getNextTarEntry());\n326: } finally {\n327: is.close();\n328: }\n329: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n\nstatic {\nfinal Map<String, SimpleEncodingHolder> se =\nnew HashMap<String, SimpleEncodingHolder>();\n\nfinal char[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nfinal SimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\n\nfinal char[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nfinal SimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(final String name) {\n\n// fallback encoding is good enough for UTF-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nfinal SimpleEncodingHolder h = simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nfinal Charset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (final UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\n// check platform's default encoding\ncharsetName = Charset.defaultCharset().name();\n}\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}\nfor (final String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(final char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(final String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(final byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data);\n}\nreturn new String(data,this.charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\n\n/**\n* <p>\n* Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\n* (either order accepted on input, big-endian used on output)\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, big-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, little-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\n\n/**\n* <p>\n* Eight-bit Unicode Transformation Format.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
                                    "method_body": "private TarArchiveEntry() {\nString user = System.getProperty(\"user.name\", \"\");\n\nif (user.length() > MAX_NAMELEN) {\nuser = user.substring(0, MAX_NAMELEN);\n}\n\nthis.userName = user;\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public TarArchiveEntry(final byte[] headerBuf, final ZipEncoding encoding)\nthrows IOException {\nthis();\nparseTarHeader(headerBuf, encoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<clinit>()V",
                                    "method_body": "private static final TarArchiveEntry[] EMPTY_TAR_ARCHIVE_ENTRIES = new TarArchiveEntry[0];\n\n/** The entry's name. */\nprivate String name = \"\";\n\n/** Whether to enforce leading slashes on the name */\nprivate boolean preserveLeadingSlashes;\n\n/** The entry's permission mode. */\nprivate int mode;\n\n/** The entry's user id. */\nprivate long userId = 0;\n\n/** The entry's group id. */\nprivate long groupId = 0;\n\n/** The entry's size. */\nprivate long size = 0;\n\n/** The entry's modification time. */\nprivate long modTime;\n\n/** If the header checksum is reasonably correct. */\nprivate boolean checkSumOK;\n\n/** The entry's link flag. */\nprivate byte linkFlag;\n\n/** The entry's link name. */\nprivate String linkName = \"\";\n\n/** The entry's magic tag. */\nprivate String magic = MAGIC_POSIX;\n/** The version of the format */\nprivate String version = VERSION_POSIX;\n\n/** The entry's user name. */\nprivate String userName;\n\n/** The entry's group name. */\nprivate String groupName = \"\";\n\n/** The entry's major device number. */\nprivate int devMajor = 0;\n\n/** The entry's minor device number. */\nprivate int devMinor = 0;\n\n/** If an extension sparse header follows. */\nprivate boolean isExtended;\n\n/** The entry's real size in case of a sparse file. */\nprivate long realSize;\n\n/** is this entry a GNU sparse entry using one of the PAX formats? */\nprivate boolean paxGNUSparse;\n\n/** is this entry a star sparse entry using the PAX header? */\nprivate boolean starSparse;\n\n/** The entry's file reference */\nprivate final File file;\n\n/** Maximum length of a user's name in the tar file */\npublic static final int MAX_NAMELEN = 31;\n\n/** Default permissions bits for directories */\npublic static final int DEFAULT_DIR_MODE = 040755;\n\n/** Default permissions bits for files */\npublic static final int DEFAULT_FILE_MODE = 0100644;\n\n/** Convert millis to seconds */\npublic static final int MILLIS_PER_SECOND = 1000;\n\n/**\n* Construct an empty entry and prepares the header values.\n*/\nprivate TarArchiveEntry() {\nString user = System.getProperty(\"user.name\", \"\");\n\nif (user.length() > MAX_NAMELEN) {\nuser = user.substring(0, MAX_NAMELEN);\n}\n\nthis.userName = user;\nthis.file = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongLinkEntry()Z",
                                    "method_body": "public boolean isGNULongLinkEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGLINK;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongNameEntry()Z",
                                    "method_body": "public boolean isGNULongNameEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGNAME;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isPaxHeader()Z",
                                    "method_body": "public boolean isPaxHeader(){\nreturn linkFlag == LF_PAX_EXTENDED_HEADER_LC\n|| linkFlag == LF_PAX_EXTENDED_HEADER_UC;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGlobalPaxHeader()Z",
                                    "method_body": "public boolean isGlobalPaxHeader(){\nreturn linkFlag == LF_PAX_GLOBAL_EXTENDED_HEADER;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isDirectory()Z",
                                    "method_body": "public boolean isDirectory() {\nif (file != null) {\nreturn file.isDirectory();\n}\n\nif (linkFlag == LF_DIR) {\nreturn true;\n}\n\nif (getName().endsWith(\"/\")) {\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;)V",
                                    "method_body": "public void parseTarHeader(final byte[] header, final ZipEncoding encoding)\nthrows IOException {\nparseTarHeader(header, encoding, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([BLorg/apache/commons/compress/archivers/zip/ZipEncoding;Z)V",
                                    "method_body": "private void parseTarHeader(final byte[] header, final ZipEncoding encoding,\nfinal boolean oldStyle)\nthrows IOException {\nint offset = 0;\n\nname = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n: TarUtils.parseName(header, offset, NAMELEN, encoding);\noffset += NAMELEN;\nmode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN);\noffset += MODELEN;\nuserId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\noffset += UIDLEN;\ngroupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\noffset += GIDLEN;\nsize = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\noffset += SIZELEN;\nmodTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN);\noffset += MODTIMELEN;\ncheckSumOK = TarUtils.verifyCheckSum(header);\noffset += CHKSUMLEN;\nlinkFlag = header[offset++];\nlinkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n: TarUtils.parseName(header, offset, NAMELEN, encoding);\noffset += NAMELEN;\nmagic = TarUtils.parseName(header, offset, MAGICLEN);\noffset += MAGICLEN;\nversion = TarUtils.parseName(header, offset, VERSIONLEN);\noffset += VERSIONLEN;\nuserName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)\n: TarUtils.parseName(header, offset, UNAMELEN, encoding);\noffset += UNAMELEN;\ngroupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN)\n: TarUtils.parseName(header, offset, GNAMELEN, encoding);\noffset += GNAMELEN;\ndevMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\ndevMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\noffset += DEVLEN;\n\nfinal int type = evaluateType(header);\nswitch (type) {\ncase FORMAT_OLDGNU: {\noffset += ATIMELEN_GNU;\noffset += CTIMELEN_GNU;\noffset += OFFSETLEN_GNU;\noffset += LONGNAMESLEN_GNU;\noffset += PAD2LEN_GNU;\noffset += SPARSELEN_GNU;\nisExtended = TarUtils.parseBoolean(header, offset);\noffset += ISEXTENDEDLEN_GNU;\nrealSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU);\noffset += REALSIZELEN_GNU;\nbreak;\n}\ncase FORMAT_XSTAR: {\nfinal String xstarPrefix = oldStyle\n? TarUtils.parseName(header, offset, PREFIXLEN_XSTAR)\n: TarUtils.parseName(header, offset, PREFIXLEN_XSTAR, encoding);\nif (xstarPrefix.length() > 0) {\nname = xstarPrefix + \"/\" + name;\n}\nbreak;\n}\ncase FORMAT_POSIX:\ndefault: {\nfinal String prefix = oldStyle\n? TarUtils.parseName(header, offset, PREFIXLEN)\n: TarUtils.parseName(header, offset, PREFIXLEN, encoding);\n// SunOS tar -E does not add / to directory names, so fix\n// up to be consistent\nif (isDirectory() && !name.endsWith(\"/\")){\nname = name + \"/\";\n}\nif (prefix.length() > 0){\nname = prefix + \"/\" + name;\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:evaluateType([B)I",
                                    "method_body": "private int evaluateType(final byte[] header) {\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_GNU, header, MAGIC_OFFSET, MAGICLEN)) {\nreturn FORMAT_OLDGNU;\n}\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_POSIX, header, MAGIC_OFFSET, MAGICLEN)) {\nif (ArchiveUtils.matchAsciiBuffer(MAGIC_XSTAR, header, XSTAR_MAGIC_OFFSET,\nXSTAR_MAGIC_LEN)) {\nreturn FORMAT_XSTAR;\n}\nreturn FORMAT_POSIX;\n}\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:<clinit>()V",
                                    "method_body": "private static final int BYTE_MASK = 255;\n\nstatic final ZipEncoding DEFAULT_ENCODING =\nZipEncodingHelper.getZipEncoding(null);\n\n/**\n* Encapsulates the algorithms used up to Commons Compress 1.3 as\n* ZipEncoding.\n*/\nstatic final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\n@Override\npublic boolean canEncode(final String name) { return true; }\n\n@Override\npublic ByteBuffer encode(final String name) {\nfinal int length = name.length();\nfinal byte[] buf = new byte[length];\n\n// copy until end of input or output is reached.\nfor (int i = 0; i < length; ++i) {\nbuf[i] = (byte) name.charAt(i);\n}\nreturn ByteBuffer.wrap(buf);\n}\n\n@Override\npublic String decode(final byte[] buffer) {\nfinal int length = buffer.length;\nfinal StringBuilder result = new StringBuilder(length);\n\nfor (final byte b : buffer) {\nif (b == 0) { // Trailing null\nbreak;\n}\nresult.append((char) (b & 0xFF)); // Allow for sign-extension\n}\n\nreturn result.toString();\n}\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\n\nif (length < 2){\nthrow new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n}\n\nif (buffer[start] == 0) {\nreturn 0L;\n}\n\n// Skip leading spaces\nwhile (start < end){\nif (buffer[start] == ' '){\nstart++;\n} else {\nbreak;\n}\n}\n\n// Trim all trailing NULs and spaces.\n// The ustar and POSIX tar specs require a trailing NUL or\n// space but some implementations use the extra digit for big\n// sizes/uids/gids ...\nbyte trailer = buffer[end - 1];\nwhile (start < end && (trailer == 0 || trailer == ' ')) {\nend--;\ntrailer = buffer[end - 1];\n}\n\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\n// CheckStyle:MagicNumber OFF\nif (currentByte < '0' || currentByte > '7'){\nthrow new IllegalArgumentException(\nexceptionMessage(buffer, offset, length, start, currentByte));\n}\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\n// CheckStyle:MagicNumber ON\n}\n\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctalOrBinary([BII)J",
                                    "method_body": "public static long parseOctalOrBinary(final byte[] buffer, final int offset,\nfinal int length) {\n\nif ((buffer[offset] & 0x80) == 0) {\nreturn parseOctal(buffer, offset, length);\n}\nfinal boolean negative = buffer[offset] == (byte) 0xff;\nif (length < 9) {\nreturn parseBinaryLong(buffer, offset, length, negative);\n}\nreturn parseBinaryBigInteger(buffer, offset, length, negative);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseBinaryLong([BIIZ)J",
                                    "method_body": "private static long parseBinaryLong(final byte[] buffer, final int offset,\nfinal int length,\nfinal boolean negative) {\nif (length >= 9) {\nthrow new IllegalArgumentException(\"At offset \" + offset + \", \"\n+ length + \" byte binary number\"\n+ \" exceeds maximum signed long\"\n+ \" value\");\n}\nlong val = 0;\nfor (int i = 1; i < length; i++) {\nval = (val << 8) + (buffer[offset + i] & 0xff);\n}\nif (negative) {\n// 2's complement\nval--;\nval ^= (long) Math.pow(2, (length - 1) * 8) - 1;\n}\nreturn negative ? -val : val;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:exceptionMessage([BIIIB)Ljava/lang/String;",
                                    "method_body": "private static String exceptionMessage(final byte[] buffer, final int offset,\nfinal int length, final int current, final byte currentByte) {\n// default charset is good enough for an exception message,\n//\n// the alternative was to modify parseOctal and\n// parseOctalOrBinary to receive the ZipEncoding of the\n// archive (deprecating the existing public methods, of\n// course) and dealing with the fact that ZipEncoding#decode\n// can throw an IOException which parseOctal* doesn't declare\nString string = new String(buffer, offset, length);\n\nstring=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed\nfinal String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;\nreturn s;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BII)Ljava/lang/String;",
                                    "method_body": "public static String parseName(final byte[] buffer, final int offset, final int length) {\ntry {\nreturn parseName(buffer, offset, length, DEFAULT_ENCODING);\n} catch (final IOException ex) {\ntry {\nreturn parseName(buffer, offset, length, FALLBACK_ENCODING);\n} catch (final IOException ex2) {\n// impossible\nthrow new RuntimeException(ex2);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BIILorg/apache/commons/compress/archivers/zip/ZipEncoding;)Ljava/lang/String;",
                                    "method_body": "public static String parseName(final byte[] buffer, final int offset,\nfinal int length,\nfinal ZipEncoding encoding)\nthrows IOException {\n\nint len = length;\nfor (; len > 0; len--) {\nif (buffer[offset + len - 1] != 0) {\nbreak;\n}\n}\nif (len > 0) {\nfinal byte[] b = new byte[len];\nSystem.arraycopy(buffer, offset, b, 0, len);\nreturn encoding.decode(b);\n}\nreturn \"\";\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:verifyCheckSum([B)Z",
                                    "method_body": "public static boolean verifyCheckSum(final byte[] header) {\nfinal long storedSum = parseOctal(header, CHKSUM_OFFSET, CHKSUMLEN);\nlong unsignedSum = 0;\nlong signedSum = 0;\n\nfor (int i = 0; i < header.length; i++) {\nbyte b = header[i];\nif (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\nb = ' ';\n}\nunsignedSum += 0xff & b;\nsignedSum += b;\n}\nreturn storedSum == unsignedSum || storedSum == signedSum;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:matchAsciiBuffer(Ljava/lang/String;[BII)Z",
                                    "method_body": "public static boolean matchAsciiBuffer(\nfinal String expected, final byte[] buffer, final int offset, final int length){\nbyte[] buffer1;\ntry {\nbuffer1 = expected.getBytes(CharsetNames.US_ASCII);\n} catch (final UnsupportedEncodingException e) {\nthrow new RuntimeException(e); // Should not happen\n}\nreturn isEqual(buffer1, 0, buffer1.length, buffer, offset, length, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isEqual([BII[BIIZ)Z",
                                    "method_body": "public static boolean isEqual(\nfinal byte[] buffer1, final int offset1, final int length1,\nfinal byte[] buffer2, final int offset2, final int length2,\nfinal boolean ignoreTrailingNulls){\nfinal int minLen=length1 < length2 ? length1 : length2;\nfor (int i=0; i < minLen; i++){\nif (buffer1[offset1+i] != buffer2[offset2+i]){\nreturn false;\n}\n}\nif (length1 == length2){\nreturn true;\n}\nif (ignoreTrailingNulls){\nif (length1 > length2){\nfor(int i = length2; i < length1; i++){\nif (buffer1[offset1+i] != 0){\nreturn false;\n}\n}\n} else {\nfor(int i = length1; i < length2; i++){\nif (buffer2[offset2+i] != 0){\nreturn false;\n}\n}\n}\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:isArrayZero([BI)Z",
                                    "method_body": "public static boolean isArrayZero(final byte[] a, final int size) {\nfor (int i = 0; i < size; i++) {\nif (a[i] != 0) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final int SKIP_BUF_SIZE = 4096;\n\n// This buffer does not need to be synchronised because it is write only; the contents are ignored\n// Does not affect Immutability\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n\n/** Private constructor to prevent instantiation of this utility class. */\nprivate IOUtils(){\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:skip(Ljava/io/InputStream;J)J",
                                    "method_body": "public static long skip(final InputStream input, long numToSkip) throws IOException {\nfinal long available = numToSkip;\nwhile (numToSkip > 0) {\nfinal long skipped = input.skip(numToSkip);\nif (skipped == 0) {\nbreak;\n}\nnumToSkip -= skipped;\n}\n\nwhile (numToSkip > 0) {\nfinal int read = readFully(input, SKIP_BUF, 0,\n(int) Math.min(numToSkip, SKIP_BUF_SIZE));\nif (read < 1) {\nbreak;\n}\nnumToSkip -= read;\n}\nreturn available - numToSkip;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[B)I",
                                    "method_body": "public static int readFully(final InputStream input, final byte[] b) throws IOException {\nreturn readFully(input, b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(final InputStream input, final byte[] b, final int offset, final int len)\nthrows IOException {\nif (len < 0 || offset < 0 || len + offset > b.length) {\nthrow new IndexOutOfBoundsException();\n}\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\nbreak;\n}\ncount += x;\n}\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nfinal int num = read(SINGLE, 0, 1);\nreturn num == -1 ? -1 : SINGLE[0] & BYTE_MASK;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(final int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(final long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public TarArchiveInputStream(final InputStream is) {\nthis(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
                                    "method_body": "public TarArchiveInputStream(final InputStream is, final int blockSize, final int recordSize) {\nthis(is, blockSize, recordSize, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;IILjava/lang/String;)V",
                                    "method_body": "public TarArchiveInputStream(final InputStream is, final int blockSize, final int recordSize,\nfinal String encoding) {\nthis.is = is;\nthis.hasHitEOF = false;\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.recordSize = recordSize;\nthis.blockSize = blockSize;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nis.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:skip(J)J",
                                    "method_body": "public long skip(final long n) throws IOException {\nif (n <= 0 || isDirectory()) {\nreturn 0;\n}\n\nfinal long available = entrySize - entryOffset;\nfinal long skipped = is.skip(Math.min(n, available));\ncount(skipped);\nentryOffset += skipped;\nreturn skipped;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextTarEntry()Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;",
                                    "method_body": "public TarArchiveEntry getNextTarEntry() throws IOException {\nif (hasHitEOF) {\nreturn null;\n}\n\nif (currEntry != null) {\n/* Skip will only go to the end of the current entry */\nIOUtils.skip(this, Long.MAX_VALUE);\n\n/* skip to the end of the last record */\nskipRecordPadding();\n}\n\nfinal byte[] headerBuf = getRecord();\n\nif (headerBuf == null) {\n/* hit EOF */\ncurrEntry = null;\nreturn null;\n}\n\ntry {\ncurrEntry = new TarArchiveEntry(headerBuf, zipEncoding);\n} catch (final IllegalArgumentException e) {\nthrow new IOException(\"Error detected parsing the header\", e);\n}\n\nentryOffset = 0;\nentrySize = currEntry.getSize();\n\nif (currEntry.isGNULongLinkEntry()) {\nfinal byte[] longLinkData = getLongNameData();\nif (longLinkData == null) {\n// Bugzilla: 40334\n// Malformed tar file - long link entry name not followed by\n// entry\nreturn null;\n}\ncurrEntry.setLinkName(zipEncoding.decode(longLinkData));\n}\n\nif (currEntry.isGNULongNameEntry()) {\nfinal byte[] longNameData = getLongNameData();\nif (longNameData == null) {\n// Bugzilla: 40334\n// Malformed tar file - long entry name not followed by\n// entry\nreturn null;\n}\ncurrEntry.setName(zipEncoding.decode(longNameData));\n}\n\nif (currEntry.isGlobalPaxHeader()){ // Process Global Pax headers\nreadGlobalPaxHeaders();\n}\n\nif (currEntry.isPaxHeader()){ // Process Pax headers\npaxHeaders();\n} else if (!globalPaxHeaders.isEmpty()) {\napplyPaxHeadersToCurrentEntry(globalPaxHeaders);\n}\n\nif (currEntry.isOldGNUSparse()){ // Process sparse files\nreadOldGNUSparse();\n}\n\n// If the size of the next element in the archive has changed\n// due to a new size being reported in the posix header\n// information, we update entrySize here so that it contains\n// the correct value.\nentrySize = currEntry.getSize();\n\nreturn currEntry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:skipRecordPadding()V",
                                    "method_body": "private void skipRecordPadding() throws IOException {\nif (!isDirectory() && this.entrySize > 0 && this.entrySize % this.recordSize != 0) {\nfinal long numRecords = (this.entrySize / this.recordSize) + 1;\nfinal long padding = (numRecords * this.recordSize) - this.entrySize;\nfinal long skipped = IOUtils.skip(is, padding);\ncount(skipped);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getRecord()[B",
                                    "method_body": "private byte[] getRecord() throws IOException {\nbyte[] headerBuf = readRecord();\nhasHitEOF = isEOFRecord(headerBuf);\nif (hasHitEOF && headerBuf != null) {\ntryToConsumeSecondEOFRecord();\nconsumeRemainderOfLastBlock();\nheaderBuf = null;\n}\nreturn headerBuf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:isEOFRecord([B)Z",
                                    "method_body": "protected boolean isEOFRecord(final byte[] record) {\nreturn record == null || ArchiveUtils.isArrayZero(record, recordSize);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:readRecord()[B",
                                    "method_body": "protected byte[] readRecord() throws IOException {\n\nfinal byte[] record = new byte[recordSize];\n\nfinal int readNow = IOUtils.readFully(is, record);\ncount(readNow);\nif (readNow != recordSize) {\nreturn null;\n}\n\nreturn record;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:paxHeaders()V",
                                    "method_body": "private void paxHeaders() throws IOException{\nfinal Map<String, String> headers = parsePaxHeaders(this);\ngetNextEntry(); // Get the actual file entry\napplyPaxHeadersToCurrentEntry(headers);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:parsePaxHeaders(Ljava/io/InputStream;)Ljava/util/Map;",
                                    "method_body": "Map<String, String> parsePaxHeaders(final InputStream i)\nthrows IOException {\nfinal Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n// Format is \"length keyword=value\\n\";\nwhile(true){ // get length\nint ch;\nint len = 0;\nint read = 0;\nwhile((ch = i.read()) != -1) {\nread++;\nif (ch == '\\n') { // blank line in header\nbreak;\n} else if (ch == ' '){ // End of length string\n// Get keyword\nfinal ByteArrayOutputStream coll = new ByteArrayOutputStream();\nwhile((ch = i.read()) != -1) {\nread++;\nif (ch == '='){ // end of keyword\nfinal String keyword = coll.toString(CharsetNames.UTF_8);\n// Get rest of entry\nfinal int restLen = len - read;\nif (restLen == 1) { // only NL\nheaders.remove(keyword);\n} else {\nfinal byte[] rest = new byte[restLen];\nfinal int got = IOUtils.readFully(i, rest);\nif (got != restLen) {\nthrow new IOException(\"Failed to read \"\n+ \"Paxheader. Expected \"\n+ restLen\n+ \" bytes, read \"\n+ got);\n}\n// Drop trailing NL\nfinal String value = new String(rest, 0,\nrestLen - 1, CharsetNames.UTF_8);\nheaders.put(keyword, value);\n}\nbreak;\n}\ncoll.write((byte) ch);\n}\nbreak; // Processed single header\n}\nlen *= 10;\nlen += ch - '0';\n}\nif (ch == -1){ // EOF\nbreak;\n}\n}\nreturn headers;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:isDirectory()Z",
                                    "method_body": "private boolean isDirectory() {\nreturn currEntry != null && currEntry.isDirectory();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextEntry()Lorg/apache/commons/compress/archivers/ArchiveEntry;",
                                    "method_body": "public ArchiveEntry getNextEntry() throws IOException {\nreturn getNextTarEntry();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:read([BII)I",
                                    "method_body": "public int read(final byte[] buf, final int offset, int numToRead) throws IOException {\nint totalRead = 0;\n\nif (hasHitEOF || isDirectory() || entryOffset >= entrySize) {\nreturn -1;\n}\n\nif (currEntry == null) {\nthrow new IllegalStateException(\"No current tar entry\");\n}\n\nnumToRead = Math.min(numToRead, available());\n\ntotalRead = is.read(buf, offset, numToRead);\n\nif (totalRead == -1) {\nif (numToRead > 0) {\nthrow new IOException(\"Truncated TAR archive\");\n}\nhasHitEOF = true;\n} else {\ncount(totalRead);\nentryOffset += totalRead;\n}\n\nreturn totalRead;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 39,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.ArchiveUtilsTest.sanitizeShortensString",
                            "test_body": "71: public void sanitizeShortensString() {\n72: String input = \"012345678901234567890123456789012345678901234567890123456789\"\n73: + \"012345678901234567890123456789012345678901234567890123456789\"\n74: + \"012345678901234567890123456789012345678901234567890123456789\"\n75: + \"012345678901234567890123456789012345678901234567890123456789\"\n76: + \"012345678901234567890123456789012345678901234567890123456789\";\n77: String expected = \"012345678901234567890123456789012345678901234567890123456789\"\n78: + \"012345678901234567890123456789012345678901234567890123456789\"\n79: + \"012345678901234567890123456789012345678901234567890123456789\"\n80: + \"012345678901234567890123456789012345678901234567890123456789\"\n81: + \"012345678901...\";\n82: assertEquals(expected, ArchiveUtils.sanitize(input));\n83: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>()V",
                                    "method_body": "public ArchiveStreamFactory() {\nthis(null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ArchiveStreamFactory(final String encoding) {\nsuper();\nthis.encoding = encoding;\n// Also set the original field so can continue to use it.\nthis.entryEncoding = encoding;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ArchiveUtils:sanitize(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public static String sanitize(String s) {\nfinal char[] chars = s.toCharArray();\nfinal int len = chars.length;\nfinal StringBuilder sb = new StringBuilder();\nfor (int i = 0; i < len; i++) {\nfinal char c = chars[i];\nif (!Character.isISOControl(c)) {\nCharacter.UnicodeBlock block = Character.UnicodeBlock.of(c);\nif (block != null && block != Character.UnicodeBlock.SPECIALS) {\nsb.append(c);\ncontinue;\n}\n}\nsb.append('?');\n}\nreturn sb.toString();\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 40,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.utils.BitInputStreamTest.bigEndianWithOverflow",
                            "test_body": "149: public void bigEndianWithOverflow() throws Exception {\n150: ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n151: 87, // 01010111\n152: 45, // 00101101\n153: 66, // 01000010\n154: 15, // 00001111\n155: 90, // 01011010\n156: 29, // 00011101\n157: 88, // 01011000\n158: 61, // 00111101\n159: 33, // 00100001\n160: 74  // 01001010\n161: });\n162: BitInputStream bin = new BitInputStream(in, ByteOrder.BIG_ENDIAN);\n163: assertEquals(10, // 01010\n164: bin.readBits(5));\n165: assertEquals(8274274654740644818l, //111-00101101-01000010-00001111-01011010-00011101-01011000-00111101-0010\n166: bin.readBits(63));\n167: assertEquals(330, // 0001-01001010\n168: bin.readBits(12));\n169: assertEquals(-1 , bin.readBits(1));\n170: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.utils.BitInputStream:<init>(Ljava/io/InputStream;Ljava/nio/ByteOrder;)V",
                                    "method_body": "public BitInputStream(final InputStream in, final ByteOrder byteOrder) {\nthis.in = in;\nthis.byteOrder = byteOrder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.BitInputStream:<clinit>()V",
                                    "method_body": "private static final int MAXIMUM_CACHE_SIZE = 63; // bits in long minus sign bit\nprivate static final long[] MASKS = new long[MAXIMUM_CACHE_SIZE + 1];\n\nstatic {\nfor (int i = 1; i <= MAXIMUM_CACHE_SIZE; i++) {\nMASKS[i] = (MASKS[i - 1] << 1) + 1;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.BitInputStream:readBits(I)J",
                                    "method_body": "public long readBits(final int count) throws IOException {\nif (count < 0 || count > MAXIMUM_CACHE_SIZE) {\nthrow new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n}\nwhile (bitsCachedSize < count) {\nfinal long nextByte = in.read();\nif (nextByte < 0) {\nreturn nextByte;\n}\nif (byteOrder == ByteOrder.LITTLE_ENDIAN) {\nbitsCached |= (nextByte << bitsCachedSize);\n} else {\nbitsCached <<= 8;\nbitsCached |= nextByte;\n}\nbitsCachedSize += 8;\n}\n// bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow\n\nfinal long bitsOut;\nif (byteOrder == ByteOrder.LITTLE_ENDIAN) {\nbitsOut = (bitsCached & MASKS[count]);\nbitsCached >>>= count;\n} else {\nbitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n}\nbitsCachedSize -= count;\nreturn bitsOut;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.utils.BitInputStreamTest.littleEndianWithOverflow",
                            "test_body": "125: public void littleEndianWithOverflow() throws Exception {\n126: ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n127: 87, // 01010111\n128: 45, // 00101101\n129: 66, // 01000010\n130: 15, // 00001111\n131: 90, // 01011010\n132: 29, // 00011101\n133: 88, // 01011000\n134: 61, // 00111101\n135: 33, // 00100001\n136: 74  // 01001010\n137: });\n138: BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN);\n139: assertEquals(23, // 10111\n140: bin.readBits(5));\n141: assertEquals(714595605644185962l, // 0001-00111101-01011000-00011101-01011010-00001111-01000010-00101101-010\n142: bin.readBits(63));\n143: assertEquals(1186, // 01001010-0010\n144: bin.readBits(12));\n145: assertEquals(-1 , bin.readBits(1));\n146: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.utils.BitInputStream:<init>(Ljava/io/InputStream;Ljava/nio/ByteOrder;)V",
                                    "method_body": "public BitInputStream(final InputStream in, final ByteOrder byteOrder) {\nthis.in = in;\nthis.byteOrder = byteOrder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.BitInputStream:<clinit>()V",
                                    "method_body": "private static final int MAXIMUM_CACHE_SIZE = 63; // bits in long minus sign bit\nprivate static final long[] MASKS = new long[MAXIMUM_CACHE_SIZE + 1];\n\nstatic {\nfor (int i = 1; i <= MAXIMUM_CACHE_SIZE; i++) {\nMASKS[i] = (MASKS[i - 1] << 1) + 1;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.BitInputStream:readBits(I)J",
                                    "method_body": "public long readBits(final int count) throws IOException {\nif (count < 0 || count > MAXIMUM_CACHE_SIZE) {\nthrow new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n}\nwhile (bitsCachedSize < count) {\nfinal long nextByte = in.read();\nif (nextByte < 0) {\nreturn nextByte;\n}\nif (byteOrder == ByteOrder.LITTLE_ENDIAN) {\nbitsCached |= (nextByte << bitsCachedSize);\n} else {\nbitsCached <<= 8;\nbitsCached |= nextByte;\n}\nbitsCachedSize += 8;\n}\n// bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow\n\nfinal long bitsOut;\nif (byteOrder == ByteOrder.LITTLE_ENDIAN) {\nbitsOut = (bitsCached & MASKS[count]);\nbitsCached >>>= count;\n} else {\nbitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n}\nbitsCachedSize -= count;\nreturn bitsOut;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 41,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.ZipTestCase.testListAllFilesWithNestedArchive",
                            "test_body": "243: public void testListAllFilesWithNestedArchive() throws Exception {\n244: final File input = getFile(\"OSX_ArchiveWithNestedArchive.zip\");\n245: 246: final List<String> results = new ArrayList<>();\n247: final List<ZipException> expectedExceptions = new ArrayList<>();\n248: 249: final InputStream is = new FileInputStream(input);\n250: ArchiveInputStream in = null;\n251: try {\n252: in = new ArchiveStreamFactory().createArchiveInputStream(\"zip\", is);\n253: 254: ZipArchiveEntry entry = null;\n255: while ((entry = (ZipArchiveEntry) in.getNextEntry()) != null) {\n256: results.add(entry.getName());\n257: 258: final ArchiveInputStream nestedIn = new ArchiveStreamFactory().createArchiveInputStream(\"zip\", in);\n259: try {\n260: ZipArchiveEntry nestedEntry = null;\n261: while ((nestedEntry = (ZipArchiveEntry) nestedIn.getNextEntry()) != null) {\n262: results.add(nestedEntry.getName());\n263: }\n264: } catch (ZipException ex) {\n265: // expected since you cannot create a final ArchiveInputStream from test3.xml\n266: expectedExceptions.add(ex);\n267: }\n268: // nested stream must not be closed here\n269: }\n270: } finally {\n271: if (in != null) {\n272: in.close();\n273: }\n274: }\n275: is.close();\n276: 277: assertTrue(results.contains(\"NestedArchiv.zip\"));\n278: assertTrue(results.contains(\"test1.xml\"));\n279: assertTrue(results.contains(\"test2.xml\"));\n280: assertTrue(results.contains(\"test3.xml\"));\n281: assertEquals(1, expectedExceptions.size());\n282: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(final long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>([B)V",
                                    "method_body": "public ZipLong (final byte[] bytes) {\nthis(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>([BI)V",
                                    "method_body": "public ZipLong (final byte[] bytes, final int offset) {\nvalue = ZipLong.getValue(bytes, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\n//private static final int BYTE_BIT_SIZE = 8;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Data Descriptor signature.\n*\n* <p>Actually, PKWARE uses this as marker for split/spanned\n* archives and other archivers have started to use it as Data\n* Descriptor signature (as well).</p>\n* @since 1.1\n*/\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\n\n/**\n* Value stored in size and similar fields if ZIP64 extensions are\n* used.\n* @since 1.3\n*/\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\n\n/**\n* Marks ZIP archives that were supposed to be split or spanned\n* but only needed a single segment in then end (so are actually\n* neither split nor spanned).\n*\n* <p>This is the \"PK00\" prefix found in some archives.</p>\n* @since 1.5\n*/\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\nnew ZipLong(0X30304B50L);\n\n/**\n* Archive extra data record signature.\n* @since 1.5\n*/\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(final long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue()J",
                                    "method_body": "public long getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(final long value) {\nfinal byte[] result = new byte[WORD];\nputLong(value, result, 0);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:putLong(J[BI)V",
                                    "method_body": "public static void putLong(final long value, final byte[] buf, int offset) {\nbuf[offset++] = (byte) ((value & BYTE_MASK));\nbuf[offset++] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nbuf[offset++] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nbuf[offset] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(final byte[] bytes, final int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(final Object o) {\nif (o == null || !(o instanceof ZipLong)) {\nreturn false;\n}\nreturn value == ((ZipLong) o).getValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n\nstatic {\nfinal Map<String, SimpleEncodingHolder> se =\nnew HashMap<>();\n\nfinal char[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nfinal SimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\n\nfinal char[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nfinal SimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(final String name) {\n\n// fallback encoding is good enough for UTF-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nfinal SimpleEncodingHolder h = simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nfinal Charset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (final UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\n// check platform's default encoding\ncharsetName = Charset.defaultCharset().name();\n}\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}\nfor (final String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(final char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(final String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\n\n/**\n* <p>\n* Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\n* (either order accepted on input, big-endian used on output)\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, big-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, little-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\n\n/**\n* <p>\n* Eight-bit Unicode Transformation Format.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final int SKIP_BUF_SIZE = 4096;\n\n// This buffer does not need to be synchronised because it is write only; the contents are ignored\n// Does not affect Immutability\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n\n/** Private constructor to prevent instantiation of this utility class. */\nprivate IOUtils(){\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[B)I",
                                    "method_body": "public static int readFully(final InputStream input, final byte[] b) throws IOException {\nreturn readFully(input, b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(final InputStream input, final byte[] b, final int offset, final int len)\nthrows IOException {\nif (len < 0 || offset < 0 || len + offset > b.length) {\nthrow new IndexOutOfBoundsException();\n}\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\nbreak;\n}\ncount += x;\n}\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(final int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(final long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public ZipArchiveInputStream(final InputStream inputStream) {\nthis(inputStream, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveInputStream(final InputStream inputStream, final String encoding) {\nthis(inputStream, encoding, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipArchiveInputStream(final InputStream inputStream, final String encoding, final boolean useUnicodeExtraFields) {\nthis(inputStream, encoding, useUnicodeExtraFields, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;ZZ)V",
                                    "method_body": "public ZipArchiveInputStream(final InputStream inputStream,\nfinal String encoding,\nfinal boolean useUnicodeExtraFields,\nfinal boolean allowStoredEntriesWithDataDescriptor) {\nthis.encoding = encoding;\nzipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\nin = new PushbackInputStream(inputStream, buf.capacity());\nthis.allowStoredEntriesWithDataDescriptor =\nallowStoredEntriesWithDataDescriptor;\n// haven't read anything so far\nbuf.limit(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<clinit>()V",
                                    "method_body": "private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\nprivate static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\nprivate static final byte[] DD = ZipLong.DD_SIG.getBytes();\n\n/**\n* Checks whether the current buffer contains the signature of a\n* &quot;data descriptor&quot;, &quot;local file header&quot; or\n* &quot;central directory entry&quot;.\n*\n* <p>If it contains such a signature, reads the data descriptor\n* and positions the stream right after the data descriptor.</p>\n*/\nprivate boolean bufferContainsSignature(final ByteArrayOutputStream bos, final int offset, final int lastRead, final int expectedDDLen)\nthrows IOException {\n\nboolean done = false;\nint readTooMuch = 0;\nfor (int i = 0; !done && i < lastRead - 4; i++) {\nif (buf.array()[i] == LFH[0] && buf.array()[i + 1] == LFH[1]) {\nif ((buf.array()[i + 2] == LFH[2] && buf.array()[i + 3] == LFH[3])\n|| (buf.array()[i] == CFH[2] && buf.array()[i + 3] == CFH[3])) {\n// found a LFH or CFH:\nreadTooMuch = offset + lastRead - i - expectedDDLen;\ndone = true;\n}\nelse if (buf.array()[i + 2] == DD[2] && buf.array()[i + 3] == DD[3]) {\n// found DD:\nreadTooMuch = offset + lastRead - i;\ndone = true;\n}\nif (done) {\n// * push back bytes read in excess as well as the data\n//   descriptor\n// * copy the remaining bytes to cache\n// * read data descriptor\npushback(buf.array(), offset + lastRead - readTooMuch, readTooMuch);\nbos.write(buf.array(), 0, i);\nreadDataDescriptor();\n}\n}\n}\nreturn done;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:getNextZipEntry()Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;",
                                    "method_body": "public ZipArchiveEntry getNextZipEntry() throws IOException {\nboolean firstEntry = true;\nif (closed || hitCentralDirectory) {\nreturn null;\n}\nif (current != null) {\ncloseEntry();\nfirstEntry = false;\n}\n\ntry {\nif (firstEntry) {\n// split archives have a special signature before the\n// first local file header - look for it and fail with\n// the appropriate error message if this is a split\n// archive.\nreadFirstLocalFileHeader(LFH_BUF);\n} else {\nreadFully(LFH_BUF);\n}\n} catch (final EOFException e) {\nreturn null;\n}\n\nfinal ZipLong sig = new ZipLong(LFH_BUF);\nif (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\nhitCentralDirectory = true;\nskipRemainderOfArchive();\n}\nif (!sig.equals(ZipLong.LFH_SIG)) {\nreturn null;\n}\n\nint off = WORD;\ncurrent = new CurrentEntry();\n\nfinal int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\noff += SHORT;\ncurrent.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n\nfinal GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\nfinal boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\nfinal ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\ncurrent.hasDataDescriptor = gpFlag.usesDataDescriptor();\ncurrent.entry.setGeneralPurposeBit(gpFlag);\n\noff += SHORT;\n\ncurrent.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\noff += SHORT;\n\nfinal long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\ncurrent.entry.setTime(time);\noff += WORD;\n\nZipLong size = null, cSize = null;\nif (!current.hasDataDescriptor) {\ncurrent.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\noff += WORD;\n\ncSize = new ZipLong(LFH_BUF, off);\noff += WORD;\n\nsize = new ZipLong(LFH_BUF, off);\noff += WORD;\n} else {\noff += 3 * WORD;\n}\n\nfinal int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n\noff += SHORT;\n\nfinal int extraLen = ZipShort.getValue(LFH_BUF, off);\noff += SHORT;\n\nfinal byte[] fileName = new byte[fileNameLen];\nreadFully(fileName);\ncurrent.entry.setName(entryEncoding.decode(fileName), fileName);\n\nfinal byte[] extraData = new byte[extraLen];\nreadFully(extraData);\ncurrent.entry.setExtra(extraData);\n\nif (!hasUTF8Flag && useUnicodeExtraFields) {\nZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n}\n\nprocessZip64Extra(size, cSize);\n\nif (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {\nif (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\ncurrent.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n} else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\ncurrent.in = new ExplodingInputStream(\ncurrent.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\ncurrent.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\nnew BoundedInputStream(in, current.entry.getCompressedSize()));\n} else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\ncurrent.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n}\n}\n\nentriesRead++;\nreturn current.entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readFirstLocalFileHeader([B)V",
                                    "method_body": "private void readFirstLocalFileHeader(final byte[] lfh) throws IOException {\nreadFully(lfh);\nfinal ZipLong sig = new ZipLong(lfh);\nif (sig.equals(ZipLong.DD_SIG)) {\nthrow new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.SPLITTING);\n}\n\nif (sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER)) {\n// The archive is not really split as only one segment was\n// needed in the end.  Just skip over the marker.\nfinal byte[] missedLfhBytes = new byte[4];\nreadFully(missedLfhBytes);\nSystem.arraycopy(lfh, 4, lfh, 0, LFH_LEN - 4);\nSystem.arraycopy(missedLfhBytes, 0, lfh, LFH_LEN - 4, 4);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!closed) {\nclosed = true;\ntry {\nin.close();\n} finally {\ninf.end();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readFully([B)V",
                                    "method_body": "private void readFully(final byte[] b) throws IOException {\nfinal int count = IOUtils.readFully(in, b);\ncount(count);\nif (count < b.length) {\nthrow new EOFException();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>()V",
                                    "method_body": "public ArchiveStreamFactory() {\nthis(null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ArchiveStreamFactory(final String encoding) {\nsuper();\nthis.encoding = encoding;\n// Also set the original field so can continue to use it.\nthis.entryEncoding = encoding;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:<clinit>()V",
                                    "method_body": "private static final int TAR_HEADER_SIZE = 512;\n\nprivate static final int DUMP_SIGNATURE_SIZE = 32;\n\nprivate static final int SIGNATURE_SIZE = 12;\n\nprivate static final ArchiveStreamFactory SINGLETON = new ArchiveStreamFactory();\n\n/**\n* Constant (value {@value}) used to identify the AR archive format."
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveInputStream(Ljava/lang/String;Ljava/io/InputStream;)Lorg/apache/commons/compress/archivers/ArchiveInputStream;",
                                    "method_body": "public ArchiveInputStream createArchiveInputStream(final String archiverName, final InputStream in)\nthrows ArchiveException {\nreturn createArchiveInputStream(archiverName, in, entryEncoding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveInputStream(Ljava/lang/String;Ljava/io/InputStream;Ljava/lang/String;)Lorg/apache/commons/compress/archivers/ArchiveInputStream;",
                                    "method_body": "public ArchiveInputStream createArchiveInputStream(final String archiverName, final InputStream in,\nfinal String actualEncoding) throws ArchiveException {\n\nif (archiverName == null) {\nthrow new IllegalArgumentException(\"Archivername must not be null.\");\n}\n\nif (in == null) {\nthrow new IllegalArgumentException(\"InputStream must not be null.\");\n}\n\nif (AR.equalsIgnoreCase(archiverName)) {\nreturn new ArArchiveInputStream(in);\n}\nif (ARJ.equalsIgnoreCase(archiverName)) {\nif (actualEncoding != null) {\nreturn new ArjArchiveInputStream(in, actualEncoding);\n}\nreturn new ArjArchiveInputStream(in);\n}\nif (ZIP.equalsIgnoreCase(archiverName)) {\nif (actualEncoding != null) {\nreturn new ZipArchiveInputStream(in, actualEncoding);\n}\nreturn new ZipArchiveInputStream(in);\n}\nif (TAR.equalsIgnoreCase(archiverName)) {\nif (actualEncoding != null) {\nreturn new TarArchiveInputStream(in, actualEncoding);\n}\nreturn new TarArchiveInputStream(in);\n}\nif (JAR.equalsIgnoreCase(archiverName)) {\nif (actualEncoding != null) {\nreturn new JarArchiveInputStream(in, actualEncoding);\n}\nreturn new JarArchiveInputStream(in);\n}\nif (CPIO.equalsIgnoreCase(archiverName)) {\nif (actualEncoding != null) {\nreturn new CpioArchiveInputStream(in, actualEncoding);\n}\nreturn new CpioArchiveInputStream(in);\n}\nif (DUMP.equalsIgnoreCase(archiverName)) {\nif (actualEncoding != null) {\nreturn new DumpArchiveInputStream(in, actualEncoding);\n}\nreturn new DumpArchiveInputStream(in);\n}\nif (SEVEN_Z.equalsIgnoreCase(archiverName)) {\nthrow new StreamingNotSupportedException(SEVEN_Z);\n}\n\nfinal ArchiveStreamProvider archiveStreamProvider = getArchiveInputStreamProviders().get(toKey(archiverName));\nif (archiveStreamProvider != null) {\nreturn archiveStreamProvider.createArchiveInputStream(archiverName, in, actualEncoding);\n}\n\nthrow new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(final String name) {\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "protected ZipArchiveEntry() {\nthis(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<clinit>()V",
                                    "method_body": "public static final int PLATFORM_UNIX = 3;\npublic static final int PLATFORM_FAT  = 0;\npublic static final int CRC_UNKNOWN = -1;\nprivate static final int SHORT_MASK = 0xFFFF;\nprivate static final int SHORT_SHIFT = 16;\nprivate static final byte[] EMPTY = new byte[0];\n\n/**\n* The {@link java.util.zip.ZipEntry} base class only supports"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getMethod()I",
                                    "method_body": "public int getMethod() {\nreturn method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setMethod(I)V",
                                    "method_body": "public void setMethod(final int method) {\nif (method < 0) {\nthrow new IllegalArgumentException(\n\"ZIP compression method can not be negative: \" + method);\n}\nthis.method = method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setPlatform(I)V",
                                    "method_body": "protected void setPlatform(final int platform) {\nthis.platform = platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void setExtraFields(final ZipExtraField[] fields) {\nfinal List<ZipExtraField> newFields = new ArrayList<>();\nfor (final ZipExtraField field : fields) {\nif (field instanceof UnparseableExtraFieldData) {\nunparseableExtra = (UnparseableExtraFieldData) field;\n} else {\nnewFields.add( field);\n}\n}\nextraFields = newFields.toArray(new ZipExtraField[newFields.size()]);\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getAllExtraFieldsNoCopy()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "private ZipExtraField[] getAllExtraFieldsNoCopy() {\nif (extraFields == null) {\nreturn getUnparseableOnly();\n}\nreturn unparseableExtra != null ? getMergedFields() : extraFields;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField getExtraField(final ZipShort type) {\nif (extraFields != null) {\nfor (final ZipExtraField extraField : extraFields) {\nif (type.equals(extraField.getHeaderId())) {\nreturn extraField;\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra([B)V",
                                    "method_body": "public void setExtra(final byte[] extra) throws RuntimeException {\ntry {\nfinal ZipExtraField[] local =\nExtraFieldUtils.parse(extra, true,\nExtraFieldUtils.UnparseableExtraField.READ);\nmergeExtraFields(local, true);\n} catch (final ZipException e) {\n// actually this is not possible as of Commons Compress 1.1\nthrow new RuntimeException(\"Error parsing extra fields for entry: \"\n+ getName() + \" - \" + e.getMessage(), e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getAllExtraFieldsNoCopy()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "protected void setName(String name) {\nif (name != null && getPlatform() == PLATFORM_FAT\n&& !name.contains(\"/\")) {\nname = name.replace('\\\\', '/');\n}\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(final long size) {\nif (size < 0) {\nthrow new IllegalArgumentException(\"invalid entry size\");\n}\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;[B)V",
                                    "method_body": "protected void setName(final String name, final byte[] rawName) {\nsetName(name);\nthis.rawName = rawName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getGeneralPurposeBit()Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "public GeneralPurposeBit getGeneralPurposeBit() {\nreturn gpb;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setGeneralPurposeBit(Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;)V",
                                    "method_body": "public void setGeneralPurposeBit(final GeneralPurposeBit b) {\ngpb = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:mergeExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;Z)V",
                                    "method_body": "private void mergeExtraFields(final ZipExtraField[] f, final boolean local)\nthrows ZipException {\nif (extraFields == null) {\nsetExtraFields(f);\n} else {\nfor (final ZipExtraField element : f) {\nZipExtraField existing;\nif (element instanceof UnparseableExtraFieldData) {\nexisting = unparseableExtra;\n} else {\nexisting = getExtraField(element.getHeaderId());\n}\nif (existing == null) {\naddExtraField(element);\n} else {\nif (local) {\nfinal byte[] b = element.getLocalFileDataData();\nexisting.parseFromLocalFileData(b, 0, b.length);\n} else {\nfinal byte[] b = element.getCentralDirectoryData();\nexisting.parseFromCentralDirectoryData(b, 0, b.length);\n}\n}\n}\nsetExtra();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:<init>()V",
                                    "method_body": "public GeneralPurposeBit() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesUTF8ForNames()Z",
                                    "method_body": "public boolean usesUTF8ForNames() {\nreturn languageEncodingFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useUTF8ForNames(Z)V",
                                    "method_body": "public void useUTF8ForNames(final boolean b) {\nlanguageEncodingFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesDataDescriptor()Z",
                                    "method_body": "public boolean usesDataDescriptor() {\nreturn dataDescriptorFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useDataDescriptor(Z)V",
                                    "method_body": "public void useDataDescriptor(final boolean b) {\ndataDescriptorFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesEncryption()Z",
                                    "method_body": "public boolean usesEncryption() {\nreturn encryptionFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useEncryption(Z)V",
                                    "method_body": "public void useEncryption(final boolean b) {\nencryptionFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useStrongEncryption(Z)V",
                                    "method_body": "public void useStrongEncryption(final boolean b) {\nstrongEncryptionFlag = b;\nif (b) {\nuseEncryption(true);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:parse([BI)Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "public static GeneralPurposeBit parse(final byte[] data, final int offset) {\nfinal int generalPurposeFlag = ZipShort.getValue(data, offset);\nfinal GeneralPurposeBit b = new GeneralPurposeBit();\nb.useDataDescriptor((generalPurposeFlag & DATA_DESCRIPTOR_FLAG) != 0);\nb.useUTF8ForNames((generalPurposeFlag & UFT8_NAMES_FLAG) != 0);\nb.useStrongEncryption((generalPurposeFlag & STRONG_ENCRYPTION_FLAG) != 0);\nb.useEncryption((generalPurposeFlag & ENCRYPTION_FLAG) != 0);\nb.slidingDictionarySize = (generalPurposeFlag & SLIDING_DICTIONARY_SIZE_FLAG) != 0 ? 8192 : 4096;\nb.numberOfShannonFanoTrees = (generalPurposeFlag & NUMBER_OF_SHANNON_FANO_TREES_FLAG) != 0 ? 3 : 2;\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "public static final int EFS_FLAG = GeneralPurposeBit.UFT8_NAMES_FLAG;\n\nprivate static final byte[] EMPTY = new byte[0];\n\n/**\n* Current entry.\n*/\nprivate CurrentEntry entry;\n\n/**\n* The file comment.\n*/\nprivate String comment = \"\";\n\n/**\n* Compression level for next entry.\n*/\nprivate int level = DEFAULT_COMPRESSION;\n\n/**\n* Has the compression level changed when compared to the last\n* entry?\n*/\nprivate boolean hasCompressionLevelChanged = false;\n\n/**\n* Default compression method for next entry.\n*/\nprivate int method = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* List of ZipArchiveEntries written so far.\n*/\nprivate final List<ZipArchiveEntry> entries =\nnew LinkedList<>();\n\nprivate final StreamCompressor streamCompressor;\n\n/**\n* Start of central directory.\n*/\nprivate long cdOffset = 0;\n\n/**\n* Length of central directory.\n*/\nprivate long cdLength = 0;\n\n/**\n* Helper, a 0 as ZipShort.\n*/\nprivate static final byte[] ZERO = {0, 0};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(final byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(final byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data);\n}\nreturn new String(data,this.charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\n\n/** No-arg constructor */\npublic JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (final int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>([BI)V",
                                    "method_body": "public ZipShort (final byte[] bytes, final int offset) {\nvalue = ZipShort.getValue(bytes, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nfinal byte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
                                    "method_body": "public int getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([BI)I",
                                    "method_body": "public static int getValue(final byte[] bytes, final int offset) {\nint value = (bytes[offset + 1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([B)I",
                                    "method_body": "public static int getValue(final byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(final Object o) {\nif (o == null || !(o instanceof ZipShort)) {\nreturn false;\n}\nreturn value == ((ZipShort) o).getValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n\n/**\n* Static registry of known extra fields.\n*/\nprivate static final Map<ZipShort, Class<?>> implementations;\n\nstatic {\nimplementations = new ConcurrentHashMap<>();\nregister(AsiExtraField.class);\nregister(X5455_ExtendedTimestamp.class);\nregister(X7875_NewUnix.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\nregister(Zip64ExtendedInformationExtraField.class);\nregister(X000A_NTFS.class);\nregister(X0014_X509Certificates.class);\nregister(X0015_CertificateIdForFile.class);\nregister(X0016_CertificateIdForCentralDirectory.class);\nregister(X0017_StrongEncryptionHeader.class);\nregister(X0019_EncryptionRecipientCertificateList.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(final Class<?> c) {\ntry {\nfinal ZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n} catch (final ClassCastException cc) {\nthrow new RuntimeException(c + \" doesn\\'t implement ZipExtraField\");\n} catch (final InstantiationException ie) {\nthrow new RuntimeException(c + \" is not a concrete class\");\n} catch (final IllegalAccessException ie) {\nthrow new RuntimeException(c + \"\\'s no-arg constructor is not public\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:createExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField createExtraField(final ZipShort headerId)\nthrows InstantiationException, IllegalAccessException {\nfinal Class<?> c = implementations.get(headerId);\nif (c != null) {\nreturn (ZipExtraField) c.newInstance();\n}\nfinal UnrecognizedExtraField u = new UnrecognizedExtraField();\nu.setHeaderId(headerId);\nreturn u;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:parse([BZLorg/apache/commons/compress/archivers/zip/ExtraFieldUtils$UnparseableExtraField;)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField[] parse(final byte[] data, final boolean local,\nfinal UnparseableExtraField onUnparseableData)\nthrows ZipException {\nfinal List<ZipExtraField> v = new ArrayList<>();\nint start = 0;\nLOOP:\nwhile (start <= data.length - WORD) {\nfinal ZipShort headerId = new ZipShort(data, start);\nfinal int length = new ZipShort(data, start + 2).getValue();\nif (start + WORD + length > data.length) {\nswitch(onUnparseableData.getKey()) {\ncase UnparseableExtraField.THROW_KEY:\nthrow new ZipException(\"bad extra field starting at \"\n+ start + \".  Block length of \"\n+ length + \" bytes exceeds remaining\"\n+ \" data of \"\n+ (data.length - start - WORD)\n+ \" bytes.\");\ncase UnparseableExtraField.READ_KEY:\nfinal UnparseableExtraFieldData field =\nnew UnparseableExtraFieldData();\nif (local) {\nfield.parseFromLocalFileData(data, start,\ndata.length - start);\n} else {\nfield.parseFromCentralDirectoryData(data, start,\ndata.length - start);\n}\nv.add(field);\n//$FALL-THROUGH$\ncase UnparseableExtraField.SKIP_KEY:\n// since we cannot parse the data we must assume\n// the extra field consumes the whole rest of the\n// available data\nbreak LOOP;\ndefault:\nthrow new ZipException(\"unknown UnparseableExtraField key: \"\n+ onUnparseableData.getKey());\n}\n}\ntry {\nfinal ZipExtraField ze = createExtraField(headerId);\nif (local) {\nze.parseFromLocalFileData(data, start + WORD, length);\n} else {\nze.parseFromCentralDirectoryData(data, start + WORD,\nlength);\n}\nv.add(ze);\n} catch (final InstantiationException | IllegalAccessException ie) {\nthrow (ZipException) new ZipException(ie.getMessage()).initCause(ie);\n}\nstart += length + WORD;\n}\n\nfinal ZipExtraField[] result = new ZipExtraField[v.size()];\nreturn v.toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data) {\nfinal boolean lastIsUnparseableHolder = data.length > 0\n&& data[data.length - 1] instanceof UnparseableExtraFieldData;\nfinal int regularExtraFieldCount =\nlastIsUnparseableHolder ? data.length - 1 : data.length;\n\nint sum = WORD * regularExtraFieldCount;\nfor (final ZipExtraField element : data) {\nsum += element.getLocalFileDataLength().getValue();\n}\n\nfinal byte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n0, result, start + 2, 2);\nstart += WORD;\nfinal byte[] local = data[i].getLocalFileDataData();\nif (local != null) {\nSystem.arraycopy(local, 0, result, start, local.length);\nstart += local.length;\n}\n}\nif (lastIsUnparseableHolder) {\nfinal byte[] local = data[data.length - 1].getLocalFileDataData();\nif (local != null) {\nSystem.arraycopy(local, 0, result, start, local.length);\n}\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate static final int      WORD = 4;\n/**\n* Standard Unix stat(2) file mode.\n*/\nprivate int mode = 0;\n/**\n* User ID.\n*/\nprivate int uid = 0;\n/**\n* Group ID.\n*/\nprivate int gid = 0;\n/**\n* File this entry points to, if it is a symbolic link.\n*\n* <p>empty string - if entry is not a symbolic link.</p>\n*/\nprivate String link = \"\";\n/**\n* Is this an entry for a directory?\n*/\nprivate boolean dirFlag = false;\n\n/**\n* Instance used to calculate checksums.\n*/\nprivate CRC32 crc = new CRC32();\n\n/** Constructor for AsiExtraField. */\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<init>()V",
                                    "method_body": "public X5455_ExtendedTimestamp() {}\npublic X5455_ExtendedTimestamp() {}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x5455);\nprivate static final long serialVersionUID = 1L;\n\n/**\n* The bit set inside the flags by when the last modification time\n* is present in this extra field.\n*/\npublic static final byte MODIFY_TIME_BIT = 1;\n/**\n* The bit set inside the flags by when the lasr access time is\n* present in this extra field.\n*/\npublic static final byte ACCESS_TIME_BIT = 2;\n/**\n* The bit set inside the flags by when the original creation time\n* is present in this extra field.\n*/\npublic static final byte CREATE_TIME_BIT = 4;\n\n// The 3 boolean fields (below) come from this flags byte.  The remaining 5 bits\n// are ignored according to the current version of the spec (December 2012).\nprivate byte flags;\n\n// Note: even if bit1 and bit2 are set, the Central data will still not contain\n// access/create fields:  only local data ever holds those!  This causes\n// some of our implementation to look a little odd, with seemingly spurious\n// != null and length checks.\nprivate boolean bit0_modifyTimePresent;\nprivate boolean bit1_accessTimePresent;\nprivate boolean bit2_createTimePresent;\n\nprivate ZipLong modifyTime;\nprivate ZipLong accessTime;\nprivate ZipLong createTime;\n\n/**\n* Constructor for X5455_ExtendedTimestamp.\n*/\npublic X5455_ExtendedTimestamp() {}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<init>()V",
                                    "method_body": "public X7875_NewUnix() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x7875);\nprivate static final ZipShort ZERO = new ZipShort(0);\nprivate static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);\nprivate static final long serialVersionUID = 1L;\n\nprivate int version = 1; // always '1' according to current info-zip spec.\n\n// BigInteger helps us with little-endian / big-endian conversions.\n// (thanks to BigInteger.toByteArray() and a reverse() method we created).\n// Also, the spec theoretically allows UID/GID up to 255 bytes long!\n//\n// NOTE:  equals() and hashCode() currently assume these can never be null.\nprivate BigInteger uid;\nprivate BigInteger gid;\n\n/**\n* Constructor for X7875_NewUnix.\n*/\npublic X7875_NewUnix() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:reset()V",
                                    "method_body": "private void reset() {\n// Typical UID/GID of the first non-root user created on a unix system.\nuid = ONE_THOUSAND;\ngid = ONE_THOUSAND;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\n\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\n\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<init>()V",
                                    "method_body": "public Zip64ExtendedInformationExtraField() { }\npublic Zip64ExtendedInformationExtraField() { }"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<clinit>()V",
                                    "method_body": "static final ZipShort HEADER_ID = new ZipShort(0x0001);\n\nprivate static final String LFH_MUST_HAVE_BOTH_SIZES_MSG =\n\"Zip64 extended information must contain\"\n+ \" both size values in the local file header.\";\nprivate static final byte[] EMPTY = new byte[0];\n\nprivate ZipEightByteInteger size, compressedSize, relativeHeaderOffset;\nprivate ZipLong diskStart;\n\n/**\n* Stored in {@link #parseFromCentralDirectoryData\n* parseFromCentralDirectoryData} so it can be reused when ZipFile"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X000A_NTFS:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x000a);\nprivate static final ZipShort TIME_ATTR_TAG = new ZipShort(0x0001);\nprivate static final ZipShort TIME_ATTR_SIZE = new ZipShort(3 * 8);\n\nprivate ZipEightByteInteger modifyTime = ZipEightByteInteger.ZERO;\nprivate ZipEightByteInteger accessTime = ZipEightByteInteger.ZERO;\nprivate ZipEightByteInteger createTime = ZipEightByteInteger.ZERO;\n\n/**\n* The Header-ID.\n*\n* @return the value for the header id for this extrafield\n*/\n@Override\npublic ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X000A_NTFS:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<init>(J)V",
                                    "method_body": "public ZipEightByteInteger(final long value) {\nthis(BigInteger.valueOf(value));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<init>(Ljava/math/BigInteger;)V",
                                    "method_body": "public ZipEightByteInteger(final BigInteger value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate static final int BYTE_4 = 4;\nprivate static final long BYTE_4_MASK = 0xFF00000000L;\nprivate static final int BYTE_4_SHIFT = 32;\n\nprivate static final int BYTE_5 = 5;\nprivate static final long BYTE_5_MASK = 0xFF0000000000L;\nprivate static final int BYTE_5_SHIFT = 40;\n\nprivate static final int BYTE_6 = 6;\nprivate static final long BYTE_6_MASK = 0xFF000000000000L;\nprivate static final int BYTE_6_SHIFT = 48;\n\nprivate static final int BYTE_7 = 7;\nprivate static final long BYTE_7_MASK = 0x7F00000000000000L;\nprivate static final int BYTE_7_SHIFT = 56;\n\nprivate static final int LEFTMOST_BIT_SHIFT = 63;\nprivate static final byte LEFTMOST_BIT = (byte) 0x80;\n\nprivate final BigInteger value;\n\npublic static final ZipEightByteInteger ZERO = new ZipEightByteInteger(0);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipEightByteInteger\n*/\npublic ZipEightByteInteger(final long value) {\nthis(BigInteger.valueOf(value));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.PKWareExtraHeader:<init>(Lorg/apache/commons/compress/archivers/zip/ZipShort;)V",
                                    "method_body": "protected PKWareExtraHeader(final ZipShort headerId) {\nthis.headerId = headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.PKWareExtraHeader:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0014_X509Certificates:<init>()V",
                                    "method_body": "public X0014_X509Certificates() {\nsuper(new ZipShort(0x0014));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0015_CertificateIdForFile:<init>()V",
                                    "method_body": "public X0015_CertificateIdForFile() {\nsuper(new ZipShort(0x0015));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0016_CertificateIdForCentralDirectory:<init>()V",
                                    "method_body": "public X0016_CertificateIdForCentralDirectory() {\nsuper(new ZipShort(0x0016));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0017_StrongEncryptionHeader:<init>()V",
                                    "method_body": "public X0017_StrongEncryptionHeader() {\nsuper(new ZipShort(0x0017));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0019_EncryptionRecipientCertificateList:<init>()V",
                                    "method_body": "public X0019_EncryptionRecipientCertificateList() {\nsuper(new ZipShort(0x0019));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n\n/**\n* Convert a Date object to a DOS date/time field.\n* @param time the <code>Date</code> to convert\n* @return the date as a <code>ZipLong</code>\n*/\npublic static ZipLong toDosTime(final Date time) {\nreturn new ZipLong(toDosTime(time.getTime()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:dosToJavaTime(J)J",
                                    "method_body": "public static long dosToJavaTime(final long dosTime) {\nfinal Calendar cal = Calendar.getInstance();\n// CheckStyle:MagicNumberCheck OFF - no point\ncal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\ncal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\ncal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);\ncal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);\ncal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);\ncal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);\ncal.set(Calendar.MILLISECOND, 0);\n// CheckStyle:MagicNumberCheck ON\nreturn cal.getTime().getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:setNameAndCommentFromExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;[B[B)V",
                                    "method_body": "static void setNameAndCommentFromExtraFields(final ZipArchiveEntry ze,\nfinal byte[] originalNameBytes,\nfinal byte[] commentBytes) {\nfinal UnicodePathExtraField name = (UnicodePathExtraField)\nze.getExtraField(UnicodePathExtraField.UPATH_ID);\nfinal String originalName = ze.getName();\nfinal String newName = getUnicodeStringIfOriginalMatches(name,\noriginalNameBytes);\nif (newName != null && !originalName.equals(newName)) {\nze.setName(newName);\n}\n\nif (commentBytes != null && commentBytes.length > 0) {\nfinal UnicodeCommentExtraField cmt = (UnicodeCommentExtraField)\nze.getExtraField(UnicodeCommentExtraField.UCOM_ID);\nfinal String newComment =\ngetUnicodeStringIfOriginalMatches(cmt, commentBytes);\nif (newComment != null) {\nze.setComment(newComment);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:getUnicodeStringIfOriginalMatches(Lorg/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField;[B)Ljava/lang/String;",
                                    "method_body": "String getUnicodeStringIfOriginalMatches(final AbstractUnicodeExtraField f,\nfinal byte[] orig) {\nif (f != null) {\nfinal CRC32 crc32 = new CRC32();\ncrc32.update(orig);\nfinal long origCRC32 = crc32.getValue();\n\nif (origCRC32 == f.getNameCRC32()) {\ntry {\nreturn ZipEncodingHelper\n.UTF8_ZIP_ENCODING.decode(f.getUnicodeName());\n} catch (final IOException ex) {\n// UTF-8 unsupported?  should be impossible the\n// Unicode*ExtraField must contain some bad bytes\n\n// TODO log this anywhere?\nreturn null;\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:copy([B)[B",
                                    "method_body": "static byte[] copy(final byte[] from) {\nif (from != null) {\nfinal byte[] to = new byte[from.length];\nSystem.arraycopy(from, 0, to, 0, to.length);\nreturn to;\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:supportsEncryptionOf(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private static boolean supportsEncryptionOf(final ZipArchiveEntry entry) {\nreturn !entry.getGeneralPurposeBit().usesEncryption();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:supportsMethodOf(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private static boolean supportsMethodOf(final ZipArchiveEntry entry) {\nreturn entry.getMethod() == ZipEntry.STORED\n|| entry.getMethod() == ZipMethod.UNSHRINKING.getCode()\n|| entry.getMethod() == ZipMethod.IMPLODING.getCode()\n|| entry.getMethod() == ZipEntry.DEFLATED\n|| entry.getMethod() == ZipMethod.BZIP2.getCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:checkRequestedFeatures(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "static void checkRequestedFeatures(final ZipArchiveEntry ze)\nthrows UnsupportedZipFeatureException {\nif (!supportsEncryptionOf(ze)) {\nthrow\nnew UnsupportedZipFeatureException(UnsupportedZipFeatureException\n.Feature.ENCRYPTION, ze);\n}\nif (!supportsMethodOf(ze)) {\nfinal ZipMethod m = ZipMethod.getMethodByCode(ze.getMethod());\nif (m == null) {\nthrow\nnew UnsupportedZipFeatureException(UnsupportedZipFeatureException\n.Feature.METHOD, ze);\n}\nthrow new UnsupportedZipFeatureException(m, ze);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:<init>(Ljava/lang/String;I)V",
                                    "method_body": "private ZipMethod() {\nthis(UNKNOWN_CODE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:<init>(Ljava/lang/String;II)V",
                                    "method_body": "ZipMethod(final int code) {\nthis.code = code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:getCode()I",
                                    "method_body": "public int getCode() {\nreturn code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:pushedBackBytes(J)V",
                                    "method_body": "protected void pushedBackBytes(final long pushedBack) {\nbytesRead -= pushedBack;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:processZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipLong;Lorg/apache/commons/compress/archivers/zip/ZipLong;)V",
                                    "method_body": "private void processZip64Extra(final ZipLong size, final ZipLong cSize) {\nfinal Zip64ExtendedInformationExtraField z64 =\n(Zip64ExtendedInformationExtraField)\ncurrent.entry.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\ncurrent.usesZip64 = z64 != null;\nif (!current.hasDataDescriptor) {\nif (z64 != null // same as current.usesZip64 but avoids NPE warning\n&& (cSize.equals(ZipLong.ZIP64_MAGIC) || size.equals(ZipLong.ZIP64_MAGIC)) ) {\ncurrent.entry.setCompressedSize(z64.getCompressedSize().getLongValue());\ncurrent.entry.setSize(z64.getSize().getLongValue());\n} else {\ncurrent.entry.setCompressedSize(cSize.getValue());\ncurrent.entry.setSize(size.getValue());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:getNextEntry()Lorg/apache/commons/compress/archivers/ArchiveEntry;",
                                    "method_body": "public ArchiveEntry getNextEntry() throws IOException {\nreturn getNextZipEntry();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:read([BII)I",
                                    "method_body": "public int read(final byte[] buffer, final int offset, final int length) throws IOException {\nif (closed) {\nthrow new IOException(\"The stream is closed\");\n}\n\nif (current == null) {\nreturn -1;\n}\n\n// avoid int overflow, check null buffer\nif (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\nthrow new ArrayIndexOutOfBoundsException();\n}\n\nZipUtil.checkRequestedFeatures(current.entry);\nif (!supportsDataDescriptorFor(current.entry)) {\nthrow new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR,\ncurrent.entry);\n}\n\nint read;\nif (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\nread = readStored(buffer, offset, length);\n} else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\nread = readDeflated(buffer, offset, length);\n} else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()\n|| current.entry.getMethod() == ZipMethod.IMPLODING.getCode()\n|| current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\nread = current.in.read(buffer, offset, length);\n} else {\nthrow new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()),\ncurrent.entry);\n}\n\nif (read >= 0) {\ncurrent.crc.update(buffer, offset, read);\n}\n\nreturn read;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readDeflated([BII)I",
                                    "method_body": "private int readDeflated(final byte[] buffer, final int offset, final int length) throws IOException {\nfinal int read = readFromInflater(buffer, offset, length);\nif (read <= 0) {\nif (inf.finished()) {\nreturn -1;\n} else if (inf.needsDictionary()) {\nthrow new ZipException(\"This archive needs a preset dictionary\"\n+ \" which is not supported by Commons\"\n+ \" Compress.\");\n} else if (read == -1) {\nthrow new IOException(\"Truncated ZIP file\");\n}\n}\nreturn read;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readFromInflater([BII)I",
                                    "method_body": "private int readFromInflater(final byte[] buffer, final int offset, final int length) throws IOException {\nint read = 0;\ndo {\nif (inf.needsInput()) {\nfinal int l = fill();\nif (l > 0) {\ncurrent.bytesReadFromStream += buf.limit();\n} else if (l == -1) {\nreturn -1;\n} else {\nbreak;\n}\n}\ntry {\nread = inf.inflate(buffer, offset, length);\n} catch (final DataFormatException e) {\nthrow (IOException) new ZipException(e.getMessage()).initCause(e);\n}\n} while (read == 0 && inf.needsInput());\nreturn read;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:skip(J)J",
                                    "method_body": "public long skip(final long value) throws IOException {\nif (value >= 0) {\nlong skipped = 0;\nwhile (skipped < value) {\nfinal long rem = value - skipped;\nfinal int x = read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));\nif (x == -1) {\nreturn skipped;\n}\nskipped += x;\n}\nreturn skipped;\n}\nthrow new IllegalArgumentException();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:closeEntry()V",
                                    "method_body": "private void closeEntry() throws IOException {\nif (closed) {\nthrow new IOException(\"The stream is closed\");\n}\nif (current == null) {\nreturn;\n}\n\n// Ensure all entry bytes are read\nif (currentEntryHasOutstandingBytes()) {\ndrainCurrentEntryData();\n} else {\nskip(Long.MAX_VALUE);\n\nfinal long inB = current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED\n? getBytesInflated() : current.bytesRead;\n\n// this is at most a single read() operation and can't\n// exceed the range of int\nfinal int diff = (int) (current.bytesReadFromStream - inB);\n\n// Pushback any required bytes\nif (diff > 0) {\npushback(buf.array(), buf.limit() - diff, diff);\ncurrent.bytesReadFromStream -= diff;\n}\n\n// Drain remainder of entry if not all data bytes were required\nif (currentEntryHasOutstandingBytes()) {\ndrainCurrentEntryData();\n}\n}\n\nif (lastStoredEntry == null && current.hasDataDescriptor) {\nreadDataDescriptor();\n}\n\ninf.reset();\nbuf.clear().flip();\ncurrent = null;\nlastStoredEntry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:currentEntryHasOutstandingBytes()Z",
                                    "method_body": "private boolean currentEntryHasOutstandingBytes() {\nreturn current.bytesReadFromStream <= current.entry.getCompressedSize()\n&& !current.hasDataDescriptor;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:getBytesInflated()J",
                                    "method_body": "private long getBytesInflated() {\nlong inB = inf.getBytesRead();\nif (current.bytesReadFromStream >= TWO_EXP_32) {\nwhile (inB + TWO_EXP_32 <= current.bytesReadFromStream) {\ninB += TWO_EXP_32;\n}\n}\nreturn inB;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:fill()I",
                                    "method_body": "private int fill() throws IOException {\nif (closed) {\nthrow new IOException(\"The stream is closed\");\n}\nfinal int length = in.read(buf.array());\nif (length > 0) {\nbuf.limit(length);\ncount(buf.limit());\ninf.setInput(buf.array(), 0, buf.limit());\n}\nreturn length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readDataDescriptor()V",
                                    "method_body": "private void readDataDescriptor() throws IOException {\nreadFully(WORD_BUF);\nZipLong val = new ZipLong(WORD_BUF);\nif (ZipLong.DD_SIG.equals(val)) {\n// data descriptor with signature, skip sig\nreadFully(WORD_BUF);\nval = new ZipLong(WORD_BUF);\n}\ncurrent.entry.setCrc(val.getValue());\n\n// if there is a ZIP64 extra field, sizes are eight bytes\n// each, otherwise four bytes each.  Unfortunately some\n// implementations - namely Java7 - use eight bytes without\n// using a ZIP64 extra field -\n// http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7073588\n\n// just read 16 bytes and check whether bytes nine to twelve\n// look like one of the signatures of what could follow a data\n// descriptor (ignoring archive decryption headers for now).\n// If so, push back eight bytes and assume sizes are four\n// bytes, otherwise sizes are eight bytes each.\nreadFully(TWO_DWORD_BUF);\nfinal ZipLong potentialSig = new ZipLong(TWO_DWORD_BUF, DWORD);\nif (potentialSig.equals(ZipLong.CFH_SIG) || potentialSig.equals(ZipLong.LFH_SIG)) {\npushback(TWO_DWORD_BUF, DWORD, DWORD);\ncurrent.entry.setCompressedSize(ZipLong.getValue(TWO_DWORD_BUF));\ncurrent.entry.setSize(ZipLong.getValue(TWO_DWORD_BUF, WORD));\n} else {\ncurrent.entry.setCompressedSize(ZipEightByteInteger.getLongValue(TWO_DWORD_BUF));\ncurrent.entry.setSize(ZipEightByteInteger.getLongValue(TWO_DWORD_BUF, DWORD));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:supportsDataDescriptorFor(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private boolean supportsDataDescriptorFor(final ZipArchiveEntry entry) {\nreturn !entry.getGeneralPurposeBit().usesDataDescriptor()\n\n|| (allowStoredEntriesWithDataDescriptor && entry.getMethod() == ZipEntry.STORED)\n|| entry.getMethod() == ZipEntry.DEFLATED;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:pushback([BII)V",
                                    "method_body": "private void pushback(final byte[] buf, final int offset, final int length) throws IOException {\n((PushbackInputStream) in).unread(buf, offset, length);\npushedBackBytes(length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:skipRemainderOfArchive()V",
                                    "method_body": "private void skipRemainderOfArchive() throws IOException {\n// skip over central directory. One LFH has been read too much\n// already.  The calculation discounts file names and extra\n// data so it will be too short.\nrealSkip(entriesRead * CFH_LEN - LFH_LEN);\nfindEocdRecord();\nrealSkip(ZipFile.MIN_EOCD_SIZE - WORD /* signature */ - SHORT /* comment len */);\nreadFully(SHORT_BUF);\n// file comment\nrealSkip(ZipShort.getValue(SHORT_BUF));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:findEocdRecord()V",
                                    "method_body": "private void findEocdRecord() throws IOException {\nint currentByte = -1;\nboolean skipReadCall = false;\nwhile (skipReadCall || (currentByte = readOneByte()) > -1) {\nskipReadCall = false;\nif (!isFirstByteOfEocdSig(currentByte)) {\ncontinue;\n}\ncurrentByte = readOneByte();\nif (currentByte != ZipArchiveOutputStream.EOCD_SIG[1]) {\nif (currentByte == -1) {\nbreak;\n}\nskipReadCall = isFirstByteOfEocdSig(currentByte);\ncontinue;\n}\ncurrentByte = readOneByte();\nif (currentByte != ZipArchiveOutputStream.EOCD_SIG[2]) {\nif (currentByte == -1) {\nbreak;\n}\nskipReadCall = isFirstByteOfEocdSig(currentByte);\ncontinue;\n}\ncurrentByte = readOneByte();\nif (currentByte == -1\n|| currentByte == ZipArchiveOutputStream.EOCD_SIG[3]) {\nbreak;\n}\nskipReadCall = isFirstByteOfEocdSig(currentByte);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:realSkip(J)V",
                                    "method_body": "private void realSkip(final long value) throws IOException {\nif (value >= 0) {\nlong skipped = 0;\nwhile (skipped < value) {\nfinal long rem = value - skipped;\nfinal int x = in.read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));\nif (x == -1) {\nreturn;\n}\ncount(x);\nskipped += x;\n}\nreturn;\n}\nthrow new IllegalArgumentException();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readOneByte()I",
                                    "method_body": "private int readOneByte() throws IOException {\nfinal int b = in.read();\nif (b != -1) {\ncount(1);\n}\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:isFirstByteOfEocdSig(I)Z",
                                    "method_body": "private boolean isFirstByteOfEocdSig(final int b) {\nreturn b == ZipArchiveOutputStream.EOCD_SIG[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<init>(I)V",
                                    "method_body": "private UnparseableExtraField(final int k) {\nkey = k;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<clinit>()V",
                                    "method_body": "public static final int THROW_KEY = 0;\n/**\n* Key for \"skip\" action.\n*/\npublic static final int SKIP_KEY = 1;\n/**\n* Key for \"read\" action.\n*/\npublic static final int READ_KEY = 2;\n\n/**\n* Throw an exception if field cannot be parsed.\n*/\npublic static final UnparseableExtraField THROW\n= new UnparseableExtraField(THROW_KEY);\n\n/**\n* Skip the extra field entirely and don't make its data\n* available - effectively removing the extra field data.\n*/\npublic static final UnparseableExtraField SKIP\n= new UnparseableExtraField(SKIP_KEY);\n\n/**\n* Read the extra field data into an instance of {@link\n* UnparseableExtraFieldData UnparseableExtraFieldData}."
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setHeaderId(Lorg/apache/commons/compress/archivers/zip/ZipShort;)V",
                                    "method_body": "public void setHeaderId(final ZipShort headerId) {\nthis.headerId = headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:setLocalFileDataData([B)V",
                                    "method_body": "public void setLocalFileDataData(final byte[] data) {\nlocalData = ZipUtil.copy(data);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getLocalFileDataLength() {\nreturn new ZipShort(localData != null ? localData.length : 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:getLocalFileDataData()[B",
                                    "method_body": "public byte[] getLocalFileDataData() {\nreturn ZipUtil.copy(localData);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField:parseFromLocalFileData([BII)V",
                                    "method_body": "public void parseFromLocalFileData(final byte[] data, final int offset, final int length) {\nfinal byte[] tmp = new byte[length];\nSystem.arraycopy(data, offset, tmp, 0, length);\nsetLocalFileDataData(tmp);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest.testThrowOnInvalidEntry",
                            "test_body": "236: public void testThrowOnInvalidEntry() throws Exception {\n237: final InputStream is = ZipArchiveInputStreamTest.class\n238: .getResourceAsStream(\"/invalid-zip.zip\");\n239: final ZipArchiveInputStream zip = new ZipArchiveInputStream(is);\n240: 241: try {\n242: zip.getNextZipEntry();\n243: fail(\"IOException expected\");\n244: } catch (ZipException expected) {\n245: assertTrue(expected.getMessage().contains(\"Unexpected record signature\"));\n246: } finally {\n247: zip.close();\n248: }\n249: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(final long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>([B)V",
                                    "method_body": "public ZipLong (final byte[] bytes) {\nthis(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>([BI)V",
                                    "method_body": "public ZipLong (final byte[] bytes, final int offset) {\nvalue = ZipLong.getValue(bytes, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\n//private static final int BYTE_BIT_SIZE = 8;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Data Descriptor signature.\n*\n* <p>Actually, PKWARE uses this as marker for split/spanned\n* archives and other archivers have started to use it as Data\n* Descriptor signature (as well).</p>\n* @since 1.1\n*/\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\n\n/**\n* Value stored in size and similar fields if ZIP64 extensions are\n* used.\n* @since 1.3\n*/\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\n\n/**\n* Marks ZIP archives that were supposed to be split or spanned\n* but only needed a single segment in then end (so are actually\n* neither split nor spanned).\n*\n* <p>This is the \"PK00\" prefix found in some archives.</p>\n* @since 1.5\n*/\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\nnew ZipLong(0X30304B50L);\n\n/**\n* Archive extra data record signature.\n* @since 1.5\n*/\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(final long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue()J",
                                    "method_body": "public long getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(final long value) {\nfinal byte[] result = new byte[WORD];\nputLong(value, result, 0);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:putLong(J[BI)V",
                                    "method_body": "public static void putLong(final long value, final byte[] buf, int offset) {\nbuf[offset++] = (byte) ((value & BYTE_MASK));\nbuf[offset++] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nbuf[offset++] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nbuf[offset] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(final byte[] bytes, final int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(final Object o) {\nif (o == null || !(o instanceof ZipLong)) {\nreturn false;\n}\nreturn value == ((ZipLong) o).getValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n\nstatic {\nfinal Map<String, SimpleEncodingHolder> se =\nnew HashMap<>();\n\nfinal char[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nfinal SimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\n\nfinal char[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nfinal SimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(final String name) {\n\n// fallback encoding is good enough for UTF-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nfinal SimpleEncodingHolder h = simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nfinal Charset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (final UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\n// check platform's default encoding\ncharsetName = Charset.defaultCharset().name();\n}\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}\nfor (final String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(final char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(final String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\n\n/**\n* <p>\n* Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\n* (either order accepted on input, big-endian used on output)\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, big-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, little-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\n\n/**\n* <p>\n* Eight-bit Unicode Transformation Format.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final int SKIP_BUF_SIZE = 4096;\n\n// This buffer does not need to be synchronised because it is write only; the contents are ignored\n// Does not affect Immutability\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n\n/** Private constructor to prevent instantiation of this utility class. */\nprivate IOUtils(){\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[B)I",
                                    "method_body": "public static int readFully(final InputStream input, final byte[] b) throws IOException {\nreturn readFully(input, b, 0, b.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
                                    "method_body": "public static int readFully(final InputStream input, final byte[] b, final int offset, final int len)\nthrows IOException {\nif (len < 0 || offset < 0 || len + offset > b.length) {\nthrow new IndexOutOfBoundsException();\n}\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\nbreak;\n}\ncount += x;\n}\nreturn count;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
                                    "method_body": "protected void count(final int read) {\ncount((long) read);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
                                    "method_body": "protected void count(final long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public ZipArchiveInputStream(final InputStream inputStream) {\nthis(inputStream, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveInputStream(final InputStream inputStream, final String encoding) {\nthis(inputStream, encoding, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipArchiveInputStream(final InputStream inputStream, final String encoding, final boolean useUnicodeExtraFields) {\nthis(inputStream, encoding, useUnicodeExtraFields, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;ZZ)V",
                                    "method_body": "public ZipArchiveInputStream(final InputStream inputStream,\nfinal String encoding,\nfinal boolean useUnicodeExtraFields,\nfinal boolean allowStoredEntriesWithDataDescriptor) {\nthis.encoding = encoding;\nzipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\nin = new PushbackInputStream(inputStream, buf.capacity());\nthis.allowStoredEntriesWithDataDescriptor =\nallowStoredEntriesWithDataDescriptor;\n// haven't read anything so far\nbuf.limit(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<clinit>()V",
                                    "method_body": "private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\nprivate static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\nprivate static final byte[] DD = ZipLong.DD_SIG.getBytes();\n\n/**\n* Checks whether the current buffer contains the signature of a\n* &quot;data descriptor&quot;, &quot;local file header&quot; or\n* &quot;central directory entry&quot;.\n*\n* <p>If it contains such a signature, reads the data descriptor\n* and positions the stream right after the data descriptor.</p>\n*/\nprivate boolean bufferContainsSignature(final ByteArrayOutputStream bos, final int offset, final int lastRead, final int expectedDDLen)\nthrows IOException {\n\nboolean done = false;\nint readTooMuch = 0;\nfor (int i = 0; !done && i < lastRead - 4; i++) {\nif (buf.array()[i] == LFH[0] && buf.array()[i + 1] == LFH[1]) {\nif ((buf.array()[i + 2] == LFH[2] && buf.array()[i + 3] == LFH[3])\n|| (buf.array()[i] == CFH[2] && buf.array()[i + 3] == CFH[3])) {\n// found a LFH or CFH:\nreadTooMuch = offset + lastRead - i - expectedDDLen;\ndone = true;\n}\nelse if (buf.array()[i + 2] == DD[2] && buf.array()[i + 3] == DD[3]) {\n// found DD:\nreadTooMuch = offset + lastRead - i;\ndone = true;\n}\nif (done) {\n// * push back bytes read in excess as well as the data\n//   descriptor\n// * copy the remaining bytes to cache\n// * read data descriptor\npushback(buf.array(), offset + lastRead - readTooMuch, readTooMuch);\nbos.write(buf.array(), 0, i);\nreadDataDescriptor();\n}\n}\n}\nreturn done;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:getNextZipEntry()Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;",
                                    "method_body": "public ZipArchiveEntry getNextZipEntry() throws IOException {\nboolean firstEntry = true;\nif (closed || hitCentralDirectory) {\nreturn null;\n}\nif (current != null) {\ncloseEntry();\nfirstEntry = false;\n}\n\ntry {\nif (firstEntry) {\n// split archives have a special signature before the\n// first local file header - look for it and fail with\n// the appropriate error message if this is a split\n// archive.\nreadFirstLocalFileHeader(LFH_BUF);\n} else {\nreadFully(LFH_BUF);\n}\n} catch (final EOFException e) {\nreturn null;\n}\n\nfinal ZipLong sig = new ZipLong(LFH_BUF);\nif (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\nhitCentralDirectory = true;\nskipRemainderOfArchive();\n}\nif (!sig.equals(ZipLong.LFH_SIG)) {\nreturn null;\n}\n\nint off = WORD;\ncurrent = new CurrentEntry();\n\nfinal int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\noff += SHORT;\ncurrent.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n\nfinal GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\nfinal boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\nfinal ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\ncurrent.hasDataDescriptor = gpFlag.usesDataDescriptor();\ncurrent.entry.setGeneralPurposeBit(gpFlag);\n\noff += SHORT;\n\ncurrent.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\noff += SHORT;\n\nfinal long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\ncurrent.entry.setTime(time);\noff += WORD;\n\nZipLong size = null, cSize = null;\nif (!current.hasDataDescriptor) {\ncurrent.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\noff += WORD;\n\ncSize = new ZipLong(LFH_BUF, off);\noff += WORD;\n\nsize = new ZipLong(LFH_BUF, off);\noff += WORD;\n} else {\noff += 3 * WORD;\n}\n\nfinal int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n\noff += SHORT;\n\nfinal int extraLen = ZipShort.getValue(LFH_BUF, off);\noff += SHORT;\n\nfinal byte[] fileName = new byte[fileNameLen];\nreadFully(fileName);\ncurrent.entry.setName(entryEncoding.decode(fileName), fileName);\n\nfinal byte[] extraData = new byte[extraLen];\nreadFully(extraData);\ncurrent.entry.setExtra(extraData);\n\nif (!hasUTF8Flag && useUnicodeExtraFields) {\nZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n}\n\nprocessZip64Extra(size, cSize);\n\nif (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {\nif (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\ncurrent.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n} else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\ncurrent.in = new ExplodingInputStream(\ncurrent.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\ncurrent.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\nnew BoundedInputStream(in, current.entry.getCompressedSize()));\n} else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\ncurrent.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n}\n}\n\nentriesRead++;\nreturn current.entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readFirstLocalFileHeader([B)V",
                                    "method_body": "private void readFirstLocalFileHeader(final byte[] lfh) throws IOException {\nreadFully(lfh);\nfinal ZipLong sig = new ZipLong(lfh);\nif (sig.equals(ZipLong.DD_SIG)) {\nthrow new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.SPLITTING);\n}\n\nif (sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER)) {\n// The archive is not really split as only one segment was\n// needed in the end.  Just skip over the marker.\nfinal byte[] missedLfhBytes = new byte[4];\nreadFully(missedLfhBytes);\nSystem.arraycopy(lfh, 4, lfh, 0, LFH_LEN - 4);\nSystem.arraycopy(missedLfhBytes, 0, lfh, LFH_LEN - 4, 4);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!closed) {\nclosed = true;\ntry {\nin.close();\n} finally {\ninf.end();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readFully([B)V",
                                    "method_body": "private void readFully(final byte[] b) throws IOException {\nfinal int count = IOUtils.readFully(in, b);\ncount(count);\nif (count < b.length) {\nthrow new EOFException();\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 42,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveEntryTest.isUnixSymlinkIsFalseIfMoreThanOneFlagIsSet",
                            "test_body": "277: public void isUnixSymlinkIsFalseIfMoreThanOneFlagIsSet() throws Exception {\n278: try (ZipFile zf = new ZipFile(getFile(\"COMPRESS-379.jar\"))) {\n279: ZipArchiveEntry ze = zf.getEntry(\"META-INF/maven/\");\n280: assertFalse(ze.isUnixSymlink());\n281: }\n282: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(final String name) {\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "protected ZipArchiveEntry() {\nthis(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<clinit>()V",
                                    "method_body": "public static final int PLATFORM_UNIX = 3;\npublic static final int PLATFORM_FAT  = 0;\npublic static final int CRC_UNKNOWN = -1;\nprivate static final int SHORT_MASK = 0xFFFF;\nprivate static final int SHORT_SHIFT = 16;\nprivate static final byte[] EMPTY = new byte[0];\n\n/**\n* The {@link java.util.zip.ZipEntry} base class only supports"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setMethod(I)V",
                                    "method_body": "public void setMethod(final int method) {\nif (method < 0) {\nthrow new IllegalArgumentException(\n\"ZIP compression method can not be negative: \" + method);\n}\nthis.method = method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setInternalAttributes(I)V",
                                    "method_body": "public void setInternalAttributes(final int value) {\ninternalAttributes = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExternalAttributes()J",
                                    "method_body": "public long getExternalAttributes() {\nreturn externalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExternalAttributes(J)V",
                                    "method_body": "public void setExternalAttributes(final long value) {\nexternalAttributes = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getUnixMode()I",
                                    "method_body": "public int getUnixMode() {\nreturn platform != PLATFORM_UNIX ? 0 :\n(int) ((getExternalAttributes() >> SHORT_SHIFT) & SHORT_MASK);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:isUnixSymlink()Z",
                                    "method_body": "public boolean isUnixSymlink() {\nreturn (getUnixMode() & UnixStat.LINK_FLAG) == UnixStat.LINK_FLAG;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setPlatform(I)V",
                                    "method_body": "protected void setPlatform(final int platform) {\nthis.platform = platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void setExtraFields(final ZipExtraField[] fields) {\nfinal List<ZipExtraField> newFields = new ArrayList<>();\nfor (final ZipExtraField field : fields) {\nif (field instanceof UnparseableExtraFieldData) {\nunparseableExtra = (UnparseableExtraFieldData) field;\n} else {\nnewFields.add( field);\n}\n}\nextraFields = newFields.toArray(new ZipExtraField[newFields.size()]);\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getAllExtraFieldsNoCopy()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "private ZipExtraField[] getAllExtraFieldsNoCopy() {\nif (extraFields == null) {\nreturn getUnparseableOnly();\n}\nreturn unparseableExtra != null ? getMergedFields() : extraFields;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField getExtraField(final ZipShort type) {\nif (extraFields != null) {\nfor (final ZipExtraField extraField : extraFields) {\nif (type.equals(extraField.getHeaderId())) {\nreturn extraField;\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra([B)V",
                                    "method_body": "public void setExtra(final byte[] extra) throws RuntimeException {\ntry {\nfinal ZipExtraField[] local =\nExtraFieldUtils.parse(extra, true,\nExtraFieldUtils.UnparseableExtraField.READ);\nmergeExtraFields(local, true);\n} catch (final ZipException e) {\n// actually this is not possible as of Commons Compress 1.1\nthrow new RuntimeException(\"Error parsing extra fields for entry: \" //NOSONAR\n+ getName() + \" - \" + e.getMessage(), e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getAllExtraFieldsNoCopy()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setCentralDirectoryExtra([B)V",
                                    "method_body": "public void setCentralDirectoryExtra(final byte[] b) {\ntry {\nfinal ZipExtraField[] central =\nExtraFieldUtils.parse(b, false,\nExtraFieldUtils.UnparseableExtraField.READ);\nmergeExtraFields(central, false);\n} catch (final ZipException e) {\nthrow new RuntimeException(e.getMessage(), e); //NOSONAR\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "protected void setName(String name) {\nif (name != null && getPlatform() == PLATFORM_FAT\n&& !name.contains(\"/\")) {\nname = name.replace('\\\\', '/');\n}\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(final long size) {\nif (size < 0) {\nthrow new IllegalArgumentException(\"invalid entry size\");\n}\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;[B)V",
                                    "method_body": "protected void setName(final String name, final byte[] rawName) {\nsetName(name);\nthis.rawName = rawName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\n// this method has severe consequences on performance. We cannot rely\n// on the super.hashCode() method since super.getName() always return\n// the empty string in the current implemention (there's no setter)\n// so it is basically draining the performance of a hashmap lookup\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setGeneralPurposeBit(Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;)V",
                                    "method_body": "public void setGeneralPurposeBit(final GeneralPurposeBit b) {\ngpb = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:mergeExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;Z)V",
                                    "method_body": "private void mergeExtraFields(final ZipExtraField[] f, final boolean local)\nthrows ZipException {\nif (extraFields == null) {\nsetExtraFields(f);\n} else {\nfor (final ZipExtraField element : f) {\nZipExtraField existing;\nif (element instanceof UnparseableExtraFieldData) {\nexisting = unparseableExtra;\n} else {\nexisting = getExtraField(element.getHeaderId());\n}\nif (existing == null) {\naddExtraField(element);\n} else {\nif (local) {\nfinal byte[] b = element.getLocalFileDataData();\nexisting.parseFromLocalFileData(b, 0, b.length);\n} else {\nfinal byte[] b = element.getCentralDirectoryData();\nexisting.parseFromCentralDirectoryData(b, 0, b.length);\n}\n}\n}\nsetExtra();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setVersionMadeBy(I)V",
                                    "method_body": "public void setVersionMadeBy(final int versionMadeBy) {\nthis.versionMadeBy = versionMadeBy;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setVersionRequired(I)V",
                                    "method_body": "public void setVersionRequired(final int versionRequired) {\nthis.versionRequired = versionRequired;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setRawFlag(I)V",
                                    "method_body": "public void setRawFlag(final int rawFlag) {\nthis.rawFlag = rawFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:<init>()V",
                                    "method_body": "public GeneralPurposeBit() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesUTF8ForNames()Z",
                                    "method_body": "public boolean usesUTF8ForNames() {\nreturn languageEncodingFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useUTF8ForNames(Z)V",
                                    "method_body": "public void useUTF8ForNames(final boolean b) {\nlanguageEncodingFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useDataDescriptor(Z)V",
                                    "method_body": "public void useDataDescriptor(final boolean b) {\ndataDescriptorFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useEncryption(Z)V",
                                    "method_body": "public void useEncryption(final boolean b) {\nencryptionFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useStrongEncryption(Z)V",
                                    "method_body": "public void useStrongEncryption(final boolean b) {\nstrongEncryptionFlag = b;\nif (b) {\nuseEncryption(true);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:parse([BI)Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "public static GeneralPurposeBit parse(final byte[] data, final int offset) {\nfinal int generalPurposeFlag = ZipShort.getValue(data, offset);\nfinal GeneralPurposeBit b = new GeneralPurposeBit();\nb.useDataDescriptor((generalPurposeFlag & DATA_DESCRIPTOR_FLAG) != 0);\nb.useUTF8ForNames((generalPurposeFlag & UFT8_NAMES_FLAG) != 0);\nb.useStrongEncryption((generalPurposeFlag & STRONG_ENCRYPTION_FLAG) != 0);\nb.useEncryption((generalPurposeFlag & ENCRYPTION_FLAG) != 0);\nb.slidingDictionarySize = (generalPurposeFlag & SLIDING_DICTIONARY_SIZE_FLAG) != 0 ? 8192 : 4096;\nb.numberOfShannonFanoTrees = (generalPurposeFlag & NUMBER_OF_SHANNON_FANO_TREES_FLAG) != 0 ? 3 : 2;\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "public static final int EFS_FLAG = GeneralPurposeBit.UFT8_NAMES_FLAG;\n\nprivate static final byte[] EMPTY = new byte[0];\n\n/**\n* Current entry.\n*/\nprivate CurrentEntry entry;\n\n/**\n* The file comment.\n*/\nprivate String comment = \"\";\n\n/**\n* Compression level for next entry.\n*/\nprivate int level = DEFAULT_COMPRESSION;\n\n/**\n* Has the compression level changed when compared to the last\n* entry?\n*/\nprivate boolean hasCompressionLevelChanged = false;\n\n/**\n* Default compression method for next entry.\n*/\nprivate int method = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* List of ZipArchiveEntries written so far.\n*/\nprivate final List<ZipArchiveEntry> entries =\nnew LinkedList<>();\n\nprivate final StreamCompressor streamCompressor;\n\n/**\n* Start of central directory.\n*/\nprivate long cdOffset = 0;\n\n/**\n* Length of central directory.\n*/\nprivate long cdLength = 0;\n\n/**\n* Helper, a 0 as ZipShort.\n*/\nprivate static final byte[] ZERO = {0, 0};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(final long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\n//private static final int BYTE_BIT_SIZE = 8;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Data Descriptor signature.\n*\n* <p>Actually, PKWARE uses this as marker for split/spanned\n* archives and other archivers have started to use it as Data\n* Descriptor signature (as well).</p>\n* @since 1.1\n*/\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\n\n/**\n* Value stored in size and similar fields if ZIP64 extensions are\n* used.\n* @since 1.3\n*/\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\n\n/**\n* Marks ZIP archives that were supposed to be split or spanned\n* but only needed a single segment in then end (so are actually\n* neither split nor spanned).\n*\n* <p>This is the \"PK00\" prefix found in some archives.</p>\n* @since 1.5\n*/\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\nnew ZipLong(0X30304B50L);\n\n/**\n* Archive extra data record signature.\n* @since 1.5\n*/\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(final long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(final long value) {\nfinal byte[] result = new byte[WORD];\nputLong(value, result, 0);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:putLong(J[BI)V",
                                    "method_body": "public static void putLong(final long value, final byte[] buf, int offset) {\nbuf[offset++] = (byte) ((value & BYTE_MASK));\nbuf[offset++] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nbuf[offset++] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nbuf[offset] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(final byte[] bytes, final int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(final byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n\nstatic {\nfinal Map<String, SimpleEncodingHolder> se =\nnew HashMap<>();\n\nfinal char[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nfinal SimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\n\nfinal char[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nfinal SimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(final String name) {\n\n// fallback encoding is good enough for UTF-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nfinal SimpleEncodingHolder h = simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nfinal Charset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (final UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\n// check platform's default encoding\ncharsetName = Charset.defaultCharset().name();\n}\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}\nfor (final String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(final char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(final String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(final byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data);\n}\nreturn new String(data,this.charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\n\n/**\n* <p>\n* Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\n* (either order accepted on input, big-endian used on output)\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, big-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, little-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\n\n/**\n* <p>\n* Eight-bit Unicode Transformation Format.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\n\n/** No-arg constructor */\npublic JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (final int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([BI)I",
                                    "method_body": "public static int getValue(final byte[] bytes, final int offset) {\nint value = (bytes[offset + 1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([B)I",
                                    "method_body": "public static int getValue(final byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n\n/**\n* Static registry of known extra fields.\n*/\nprivate static final Map<ZipShort, Class<?>> implementations;\n\nstatic {\nimplementations = new ConcurrentHashMap<>();\nregister(AsiExtraField.class);\nregister(X5455_ExtendedTimestamp.class);\nregister(X7875_NewUnix.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\nregister(Zip64ExtendedInformationExtraField.class);\nregister(X000A_NTFS.class);\nregister(X0014_X509Certificates.class);\nregister(X0015_CertificateIdForFile.class);\nregister(X0016_CertificateIdForCentralDirectory.class);\nregister(X0017_StrongEncryptionHeader.class);\nregister(X0019_EncryptionRecipientCertificateList.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(final Class<?> c) {\ntry {\nfinal ZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n} catch (final ClassCastException cc) {\nthrow new RuntimeException(c + \" doesn\\'t implement ZipExtraField\"); //NOSONAR\n} catch (final InstantiationException ie) {\nthrow new RuntimeException(c + \" is not a concrete class\"); //NOSONAR\n} catch (final IllegalAccessException ie) {\nthrow new RuntimeException(c + \"\\'s no-arg constructor is not public\"); //NOSONAR\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:parse([BZLorg/apache/commons/compress/archivers/zip/ExtraFieldUtils$UnparseableExtraField;)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField[] parse(final byte[] data, final boolean local,\nfinal UnparseableExtraField onUnparseableData)\nthrows ZipException {\nfinal List<ZipExtraField> v = new ArrayList<>();\nint start = 0;\nLOOP:\nwhile (start <= data.length - WORD) {\nfinal ZipShort headerId = new ZipShort(data, start);\nfinal int length = new ZipShort(data, start + 2).getValue();\nif (start + WORD + length > data.length) {\nswitch(onUnparseableData.getKey()) {\ncase UnparseableExtraField.THROW_KEY:\nthrow new ZipException(\"bad extra field starting at \"\n+ start + \".  Block length of \"\n+ length + \" bytes exceeds remaining\"\n+ \" data of \"\n+ (data.length - start - WORD)\n+ \" bytes.\");\ncase UnparseableExtraField.READ_KEY:\nfinal UnparseableExtraFieldData field =\nnew UnparseableExtraFieldData();\nif (local) {\nfield.parseFromLocalFileData(data, start,\ndata.length - start);\n} else {\nfield.parseFromCentralDirectoryData(data, start,\ndata.length - start);\n}\nv.add(field);\n//$FALL-THROUGH$\ncase UnparseableExtraField.SKIP_KEY:\n// since we cannot parse the data we must assume\n// the extra field consumes the whole rest of the\n// available data\nbreak LOOP;\ndefault:\nthrow new ZipException(\"unknown UnparseableExtraField key: \"\n+ onUnparseableData.getKey());\n}\n}\ntry {\nfinal ZipExtraField ze = createExtraField(headerId);\nif (local) {\nze.parseFromLocalFileData(data, start + WORD, length);\n} else {\nze.parseFromCentralDirectoryData(data, start + WORD,\nlength);\n}\nv.add(ze);\n} catch (final InstantiationException | IllegalAccessException ie) {\nthrow (ZipException) new ZipException(ie.getMessage()).initCause(ie);\n}\nstart += length + WORD;\n}\n\nfinal ZipExtraField[] result = new ZipExtraField[v.size()];\nreturn v.toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data) {\nfinal boolean lastIsUnparseableHolder = data.length > 0\n&& data[data.length - 1] instanceof UnparseableExtraFieldData;\nfinal int regularExtraFieldCount =\nlastIsUnparseableHolder ? data.length - 1 : data.length;\n\nint sum = WORD * regularExtraFieldCount;\nfor (final ZipExtraField element : data) {\nsum += element.getLocalFileDataLength().getValue();\n}\n\nfinal byte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n0, result, start + 2, 2);\nstart += WORD;\nfinal byte[] local = data[i].getLocalFileDataData();\nif (local != null) {\nSystem.arraycopy(local, 0, result, start, local.length);\nstart += local.length;\n}\n}\nif (lastIsUnparseableHolder) {\nfinal byte[] local = data[data.length - 1].getLocalFileDataData();\nif (local != null) {\nSystem.arraycopy(local, 0, result, start, local.length);\n}\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate static final int      WORD = 4;\n/**\n* Standard Unix stat(2) file mode.\n*/\nprivate int mode = 0;\n/**\n* User ID.\n*/\nprivate int uid = 0;\n/**\n* Group ID.\n*/\nprivate int gid = 0;\n/**\n* File this entry points to, if it is a symbolic link.\n*\n* <p>empty string - if entry is not a symbolic link.</p>\n*/\nprivate String link = \"\";\n/**\n* Is this an entry for a directory?\n*/\nprivate boolean dirFlag = false;\n\n/**\n* Instance used to calculate checksums.\n*/\nprivate CRC32 crc = new CRC32();\n\n/** Constructor for AsiExtraField. */\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<init>()V",
                                    "method_body": "public X5455_ExtendedTimestamp() {}\npublic X5455_ExtendedTimestamp() {}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x5455);\nprivate static final long serialVersionUID = 1L;\n\n/**\n* The bit set inside the flags by when the last modification time\n* is present in this extra field.\n*/\npublic static final byte MODIFY_TIME_BIT = 1;\n/**\n* The bit set inside the flags by when the lasr access time is\n* present in this extra field.\n*/\npublic static final byte ACCESS_TIME_BIT = 2;\n/**\n* The bit set inside the flags by when the original creation time\n* is present in this extra field.\n*/\npublic static final byte CREATE_TIME_BIT = 4;\n\n// The 3 boolean fields (below) come from this flags byte.  The remaining 5 bits\n// are ignored according to the current version of the spec (December 2012).\nprivate byte flags;\n\n// Note: even if bit1 and bit2 are set, the Central data will still not contain\n// access/create fields:  only local data ever holds those!  This causes\n// some of our implementation to look a little odd, with seemingly spurious\n// != null and length checks.\nprivate boolean bit0_modifyTimePresent;\nprivate boolean bit1_accessTimePresent;\nprivate boolean bit2_createTimePresent;\n\nprivate ZipLong modifyTime;\nprivate ZipLong accessTime;\nprivate ZipLong createTime;\n\n/**\n* Constructor for X5455_ExtendedTimestamp.\n*/\npublic X5455_ExtendedTimestamp() {}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<init>()V",
                                    "method_body": "public X7875_NewUnix() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x7875);\nprivate static final ZipShort ZERO = new ZipShort(0);\nprivate static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);\nprivate static final long serialVersionUID = 1L;\n\nprivate int version = 1; // always '1' according to current info-zip spec.\n\n// BigInteger helps us with little-endian / big-endian conversions.\n// (thanks to BigInteger.toByteArray() and a reverse() method we created).\n// Also, the spec theoretically allows UID/GID up to 255 bytes long!\n//\n// NOTE:  equals() and hashCode() currently assume these can never be null.\nprivate BigInteger uid;\nprivate BigInteger gid;\n\n/**\n* Constructor for X7875_NewUnix.\n*/\npublic X7875_NewUnix() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:reset()V",
                                    "method_body": "private void reset() {\n// Typical UID/GID of the first non-root user created on a unix system.\nuid = ONE_THOUSAND;\ngid = ONE_THOUSAND;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\n\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\n\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<init>()V",
                                    "method_body": "public Zip64ExtendedInformationExtraField() { }\npublic Zip64ExtendedInformationExtraField() { }"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<clinit>()V",
                                    "method_body": "static final ZipShort HEADER_ID = new ZipShort(0x0001);\n\nprivate static final String LFH_MUST_HAVE_BOTH_SIZES_MSG =\n\"Zip64 extended information must contain\"\n+ \" both size values in the local file header.\";\nprivate static final byte[] EMPTY = new byte[0];\n\nprivate ZipEightByteInteger size, compressedSize, relativeHeaderOffset;\nprivate ZipLong diskStart;\n\n/**\n* Stored in {@link #parseFromCentralDirectoryData\n* parseFromCentralDirectoryData} so it can be reused when ZipFile"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X000A_NTFS:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x000a);\nprivate static final ZipShort TIME_ATTR_TAG = new ZipShort(0x0001);\nprivate static final ZipShort TIME_ATTR_SIZE = new ZipShort(3 * 8);\n\nprivate ZipEightByteInteger modifyTime = ZipEightByteInteger.ZERO;\nprivate ZipEightByteInteger accessTime = ZipEightByteInteger.ZERO;\nprivate ZipEightByteInteger createTime = ZipEightByteInteger.ZERO;\n\n/**\n* The Header-ID.\n*\n* @return the value for the header id for this extrafield\n*/\n@Override\npublic ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X000A_NTFS:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<init>(J)V",
                                    "method_body": "public ZipEightByteInteger(final long value) {\nthis(BigInteger.valueOf(value));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<init>(Ljava/math/BigInteger;)V",
                                    "method_body": "public ZipEightByteInteger(final BigInteger value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate static final int BYTE_4 = 4;\nprivate static final long BYTE_4_MASK = 0xFF00000000L;\nprivate static final int BYTE_4_SHIFT = 32;\n\nprivate static final int BYTE_5 = 5;\nprivate static final long BYTE_5_MASK = 0xFF0000000000L;\nprivate static final int BYTE_5_SHIFT = 40;\n\nprivate static final int BYTE_6 = 6;\nprivate static final long BYTE_6_MASK = 0xFF000000000000L;\nprivate static final int BYTE_6_SHIFT = 48;\n\nprivate static final int BYTE_7 = 7;\nprivate static final long BYTE_7_MASK = 0x7F00000000000000L;\nprivate static final int BYTE_7_SHIFT = 56;\n\nprivate static final int LEFTMOST_BIT_SHIFT = 63;\nprivate static final byte LEFTMOST_BIT = (byte) 0x80;\n\nprivate final BigInteger value;\n\npublic static final ZipEightByteInteger ZERO = new ZipEightByteInteger(0);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipEightByteInteger\n*/\npublic ZipEightByteInteger(final long value) {\nthis(BigInteger.valueOf(value));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.PKWareExtraHeader:<init>(Lorg/apache/commons/compress/archivers/zip/ZipShort;)V",
                                    "method_body": "protected PKWareExtraHeader(final ZipShort headerId) {\nthis.headerId = headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.PKWareExtraHeader:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0014_X509Certificates:<init>()V",
                                    "method_body": "public X0014_X509Certificates() {\nsuper(new ZipShort(0x0014));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0015_CertificateIdForFile:<init>()V",
                                    "method_body": "public X0015_CertificateIdForFile() {\nsuper(new ZipShort(0x0015));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0016_CertificateIdForCentralDirectory:<init>()V",
                                    "method_body": "public X0016_CertificateIdForCentralDirectory() {\nsuper(new ZipShort(0x0016));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0017_StrongEncryptionHeader:<init>()V",
                                    "method_body": "public X0017_StrongEncryptionHeader() {\nsuper(new ZipShort(0x0017));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0019_EncryptionRecipientCertificateList:<init>()V",
                                    "method_body": "public X0019_EncryptionRecipientCertificateList() {\nsuper(new ZipShort(0x0019));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n\n/**\n* Convert a Date object to a DOS date/time field.\n* @param time the <code>Date</code> to convert\n* @return the date as a <code>ZipLong</code>\n*/\npublic static ZipLong toDosTime(final Date time) {\nreturn new ZipLong(toDosTime(time.getTime()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:dosToJavaTime(J)J",
                                    "method_body": "public static long dosToJavaTime(final long dosTime) {\nfinal Calendar cal = Calendar.getInstance();\n// CheckStyle:MagicNumberCheck OFF - no point\ncal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\ncal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\ncal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);\ncal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);\ncal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);\ncal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);\ncal.set(Calendar.MILLISECOND, 0);\n// CheckStyle:MagicNumberCheck ON\nreturn cal.getTime().getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final int SKIP_BUF_SIZE = 4096;\n\n// This buffer does not need to be synchronised because it is write only; the contents are ignored\n// Does not affect Immutability\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n\n/** Private constructor to prevent instantiation of this utility class. */\nprivate IOUtils(){\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/nio/channels/ReadableByteChannel;Ljava/nio/ByteBuffer;)V",
                                    "method_body": "public static void readFully(ReadableByteChannel channel, ByteBuffer b) throws IOException {\nfinal int expectedLength = b.remaining();\nint read = 0;\nwhile (read < expectedLength) {\nint readNow = channel.read(b);\nif (readNow <= 0) {\nbreak;\n}\nread += readNow;\n}\nif (read < expectedLength) {\nthrow new EOFException();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<init>(I)V",
                                    "method_body": "private UnparseableExtraField(final int k) {\nkey = k;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<clinit>()V",
                                    "method_body": "public static final int THROW_KEY = 0;\n/**\n* Key for \"skip\" action.\n*/\npublic static final int SKIP_KEY = 1;\n/**\n* Key for \"read\" action.\n*/\npublic static final int READ_KEY = 2;\n\n/**\n* Throw an exception if field cannot be parsed.\n*/\npublic static final UnparseableExtraField THROW\n= new UnparseableExtraField(THROW_KEY);\n\n/**\n* Skip the extra field entirely and don't make its data\n* available - effectively removing the extra field data.\n*/\npublic static final UnparseableExtraField SKIP\n= new UnparseableExtraField(SKIP_KEY);\n\n/**\n* Read the extra field data into an instance of {@link\n* UnparseableExtraFieldData UnparseableExtraFieldData}."
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipFile(final File f) throws IOException {\nthis(f, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;)V",
                                    "method_body": "public ZipFile(final File f, final String encoding) throws IOException {\nthis(f, encoding, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(final File f, final String encoding, final boolean useUnicodeExtraFields)\nthrows IOException {\nthis(Files.newByteChannel(f.toPath(), EnumSet.of(StandardOpenOption.READ)),\nf.getAbsolutePath(), encoding, useUnicodeExtraFields, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/nio/channels/SeekableByteChannel;Ljava/lang/String;Ljava/lang/String;ZZ)V",
                                    "method_body": "private ZipFile(final SeekableByteChannel channel, final String archiveName,\nfinal String encoding, final boolean useUnicodeExtraFields,\nfinal boolean closeOnError)\nthrows IOException {\nthis.archiveName = archiveName;\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = channel;\nboolean success = false;\ntry {\nfinal Map<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag =\npopulateFromCentralDirectory();\nresolveLocalFileHeaderData(entriesWithoutUTF8Flag);\nsuccess = true;\n} finally {\nclosed = !success;\nif (!success && closeOnError) {\nIOUtils.closeQuietly(archive);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<clinit>()V",
                                    "method_body": "private static final int CFH_LEN =\n/* version made by                 */ SHORT\n/* version needed to extract       */ + SHORT\n/* general purpose bit flag        */ + SHORT\n/* compression method              */ + SHORT\n/* last mod file time              */ + SHORT\n/* last mod file date              */ + SHORT\n/* crc-32                          */ + WORD\n/* compressed size                 */ + WORD\n/* uncompressed size               */ + WORD\n/* filename length                 */ + SHORT\n/* extra field length              */ + SHORT\n/* file comment length             */ + SHORT\n/* disk number start               */ + SHORT\n/* internal file attributes        */ + SHORT\n/* external file attributes        */ + WORD\n/* relative offset of local header */ + WORD;\n\nprivate static final long CFH_SIG =\nZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n\n/**\n* Reads the central directory of the given archive and populates\n* the internal tables with ZipArchiveEntry instances.\n*\n* <p>The ZipArchiveEntrys will know all data that can be obtained from\n* the central directory alone, but not the data that requires the\n* local file header or additional data to be read.</p>\n*\n* @return a map of zipentries that didn't have the language\n* encoding flag set when read.\n*/\nprivate Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory()\nthrows IOException {\nfinal HashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\nnew HashMap<>();\n\npositionAtCentralDirectory();\n\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nlong sig = ZipLong.getValue(wordBuf);\n\nif (sig != CFH_SIG && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n+ \" corrupt archive.\");\n}\n\nwhile (sig == CFH_SIG) {\nreadCentralDirectoryEntry(noUTF8Flag);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nsig = ZipLong.getValue(wordBuf);\n}\nreturn noUTF8Flag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:close()V",
                                    "method_body": "public void close() throws IOException {\n// this flag is only written here and read in finalize() which\n// can never be run in parallel.\n// no synchronization needed.\nclosed = true;\n\narchive.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:getEntry(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;",
                                    "method_body": "public ZipArchiveEntry getEntry(final String name) {\nfinal LinkedList<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\nreturn entriesOfThatName != null ? entriesOfThatName.getFirst() : null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory()\nthrows IOException {\nfinal HashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\nnew HashMap<>();\n\npositionAtCentralDirectory();\n\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nlong sig = ZipLong.getValue(wordBuf);\n\nif (sig != CFH_SIG && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n+ \" corrupt archive.\");\n}\n\nwhile (sig == CFH_SIG) {\nreadCentralDirectoryEntry(noUTF8Flag);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nsig = ZipLong.getValue(wordBuf);\n}\nreturn noUTF8Flag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:readCentralDirectoryEntry(Ljava/util/Map;)V",
                                    "method_body": "private void\nreadCentralDirectoryEntry(final Map<ZipArchiveEntry, NameAndComment> noUTF8Flag)\nthrows IOException {\ncfhBbuf.rewind();\nIOUtils.readFully(archive, cfhBbuf);\nint off = 0;\nfinal OffsetEntry offset = new OffsetEntry();\nfinal Entry ze = new Entry(offset);\n\nfinal int versionMadeBy = ZipShort.getValue(cfhBuf, off);\noff += SHORT;\nze.setVersionMadeBy(versionMadeBy);\nze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\nze.setVersionRequired(ZipShort.getValue(cfhBuf, off));\noff += SHORT; // version required\n\nfinal GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(cfhBuf, off);\nfinal boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\nfinal ZipEncoding entryEncoding =\nhasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\nze.setGeneralPurposeBit(gpFlag);\nze.setRawFlag(ZipShort.getValue(cfhBuf, off));\n\noff += SHORT;\n\n//noinspection MagicConstant\nze.setMethod(ZipShort.getValue(cfhBuf, off));\noff += SHORT;\n\nfinal long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfhBuf, off));\nze.setTime(time);\noff += WORD;\n\nze.setCrc(ZipLong.getValue(cfhBuf, off));\noff += WORD;\n\nze.setCompressedSize(ZipLong.getValue(cfhBuf, off));\noff += WORD;\n\nze.setSize(ZipLong.getValue(cfhBuf, off));\noff += WORD;\n\nfinal int fileNameLen = ZipShort.getValue(cfhBuf, off);\noff += SHORT;\n\nfinal int extraLen = ZipShort.getValue(cfhBuf, off);\noff += SHORT;\n\nfinal int commentLen = ZipShort.getValue(cfhBuf, off);\noff += SHORT;\n\nfinal int diskStart = ZipShort.getValue(cfhBuf, off);\noff += SHORT;\n\nze.setInternalAttributes(ZipShort.getValue(cfhBuf, off));\noff += SHORT;\n\nze.setExternalAttributes(ZipLong.getValue(cfhBuf, off));\noff += WORD;\n\nfinal byte[] fileName = new byte[fileNameLen];\nIOUtils.readFully(archive, ByteBuffer.wrap(fileName));\nze.setName(entryEncoding.decode(fileName), fileName);\n\n// LFH offset,\noffset.headerOffset = ZipLong.getValue(cfhBuf, off);\n// data offset will be filled later\nentries.add(ze);\n\nfinal byte[] cdExtraData = new byte[extraLen];\nIOUtils.readFully(archive, ByteBuffer.wrap(cdExtraData));\nze.setCentralDirectoryExtra(cdExtraData);\n\nsetSizesAndOffsetFromZip64Extra(ze, offset, diskStart);\n\nfinal byte[] comment = new byte[commentLen];\nIOUtils.readFully(archive, ByteBuffer.wrap(comment));\nze.setComment(entryEncoding.decode(comment));\n\nif (!hasUTF8Flag && useUnicodeExtraFields) {\nnoUTF8Flag.put(ze, new NameAndComment(fileName, comment));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:setSizesAndOffsetFromZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Lorg/apache/commons/compress/archivers/zip/ZipFile$OffsetEntry;I)V",
                                    "method_body": "private void setSizesAndOffsetFromZip64Extra(final ZipArchiveEntry ze,\nfinal OffsetEntry offset,\nfinal int diskStart)\nthrows IOException {\nfinal Zip64ExtendedInformationExtraField z64 =\n(Zip64ExtendedInformationExtraField)\nze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\nif (z64 != null) {\nfinal boolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\nfinal boolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\nfinal boolean hasRelativeHeaderOffset =\noffset.headerOffset == ZIP64_MAGIC;\nz64.reparseCentralDirectoryData(hasUncompressedSize,\nhasCompressedSize,\nhasRelativeHeaderOffset,\ndiskStart == ZIP64_MAGIC_SHORT);\n\nif (hasUncompressedSize) {\nze.setSize(z64.getSize().getLongValue());\n} else if (hasCompressedSize) {\nz64.setSize(new ZipEightByteInteger(ze.getSize()));\n}\n\nif (hasCompressedSize) {\nze.setCompressedSize(z64.getCompressedSize().getLongValue());\n} else if (hasUncompressedSize) {\nz64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));\n}\n\nif (hasRelativeHeaderOffset) {\noffset.headerOffset =\nz64.getRelativeHeaderOffset().getLongValue();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nthrows IOException {\npositionAtEndOfCentralDirectoryRecord();\nboolean found = false;\nfinal boolean searchedForZip64EOCD =\narchive.position() > ZIP64_EOCDL_LENGTH;\nif (searchedForZip64EOCD) {\narchive.position(archive.position() - ZIP64_EOCDL_LENGTH);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nfound = Arrays.equals(ZipArchiveOutputStream.ZIP64_EOCD_LOC_SIG,\nwordBuf);\n}\nif (!found) {\n// not a ZIP64 archive\nif (searchedForZip64EOCD) {\nskipBytes(ZIP64_EOCDL_LENGTH - WORD);\n}\npositionAtCentralDirectory32();\n} else {\npositionAtCentralDirectory64();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory32()V",
                                    "method_body": "private void positionAtCentralDirectory32()\nthrows IOException {\nskipBytes(CFD_LOCATOR_OFFSET);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\narchive.position(ZipLong.getValue(wordBuf));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtEndOfCentralDirectoryRecord()V",
                                    "method_body": "private void positionAtEndOfCentralDirectoryRecord()\nthrows IOException {\nfinal boolean found = tryToLocateSignature(MIN_EOCD_SIZE, MAX_EOCD_SIZE,\nZipArchiveOutputStream.EOCD_SIG);\nif (!found) {\nthrow new ZipException(\"archive is not a ZIP archive\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:tryToLocateSignature(JJ[B)Z",
                                    "method_body": "private boolean tryToLocateSignature(final long minDistanceFromEnd,\nfinal long maxDistanceFromEnd,\nfinal byte[] sig) throws IOException {\nboolean found = false;\nlong off = archive.size() - minDistanceFromEnd;\nfinal long stopSearching =\nMath.max(0L, archive.size() - maxDistanceFromEnd);\nif (off >= 0) {\nfor (; off >= stopSearching; off--) {\narchive.position(off);\ntry {\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nwordBbuf.flip();\n} catch (EOFException ex) {\nbreak;\n}\nint curr = wordBbuf.get();\nif (curr == sig[POS_0]) {\ncurr = wordBbuf.get();\nif (curr == sig[POS_1]) {\ncurr = wordBbuf.get();\nif (curr == sig[POS_2]) {\ncurr = wordBbuf.get();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\n}\n}\n}\n}\n}\n}\nif (found) {\narchive.position(off);\n}\nreturn found;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:skipBytes(I)V",
                                    "method_body": "private void skipBytes(final int count) throws IOException {\nlong currentPosition = archive.position();\nlong newPosition = currentPosition + count;\nif (newPosition > archive.size()) {\nthrow new EOFException();\n}\narchive.position(newPosition);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:resolveLocalFileHeaderData(Ljava/util/Map;)V",
                                    "method_body": "private void resolveLocalFileHeaderData(final Map<ZipArchiveEntry, NameAndComment>\nentriesWithoutUTF8Flag)\nthrows IOException {\nfor (final ZipArchiveEntry zipArchiveEntry : entries) {\n// entries is filled in populateFromCentralDirectory and\n// never modified\nfinal Entry ze = (Entry) zipArchiveEntry;\nfinal OffsetEntry offsetEntry = ze.getOffsetEntry();\nfinal long offset = offsetEntry.headerOffset;\narchive.position(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nwordBbuf.flip();\nwordBbuf.get(shortBuf);\nfinal int fileNameLen = ZipShort.getValue(shortBuf);\nwordBbuf.get(shortBuf);\nfinal int extraFieldLen = ZipShort.getValue(shortBuf);\nskipBytes(fileNameLen);\nfinal byte[] localExtraData = new byte[extraFieldLen];\nIOUtils.readFully(archive, ByteBuffer.wrap(localExtraData));\nze.setExtra(localExtraData);\noffsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n+ SHORT + SHORT + fileNameLen + extraFieldLen;\n\nif (entriesWithoutUTF8Flag.containsKey(ze)) {\nfinal NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\nZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\nnc.comment);\n}\n\nfinal String name = ze.getName();\nLinkedList<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\nif (entriesOfThatName == null) {\nentriesOfThatName = new LinkedList<>();\nnameMap.put(name, entriesOfThatName);\n}\nentriesOfThatName.addLast(ze);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$OffsetEntry:access$002(Lorg/apache/commons/compress/archivers/zip/ZipFile$OffsetEntry;J)J",
                                    "method_body": "private static final int HASH_SIZE = 509;\nstatic final int NIBLET_MASK = 0x0f;\nstatic final int BYTE_SHIFT = 8;\nprivate static final int POS_0 = 0;\nprivate static final int POS_1 = 1;\nprivate static final int POS_2 = 2;\nprivate static final int POS_3 = 3;\n\n/**\n* List of entries in the order they appear inside the central\n* directory.\n*/\nprivate final List<ZipArchiveEntry> entries =\nnew LinkedList<>();\n\n/**\n* Maps String to list of ZipArchiveEntrys, name -> actual entries.\n*/\nprivate final Map<String, LinkedList<ZipArchiveEntry>> nameMap =\nnew HashMap<>(HASH_SIZE);\n\nprivate static final class OffsetEntry {\nprivate long headerOffset = -1;\nprivate long dataOffset = -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$Entry:<init>(Lorg/apache/commons/compress/archivers/zip/ZipFile$OffsetEntry;)V",
                                    "method_body": "Entry(final OffsetEntry offset) {\nthis.offsetEntry = offset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$Entry:getOffsetEntry()Lorg/apache/commons/compress/archivers/zip/ZipFile$OffsetEntry;",
                                    "method_body": "OffsetEntry getOffsetEntry() {\nreturn offsetEntry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$Entry:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn 3 * super.hashCode()\n+ (int) (offsetEntry.headerOffset % Integer.MAX_VALUE);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 43,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.DataDescriptorTest.doesntWriteDataDescriptorWhenAddingRawEntries",
                            "test_body": "135: public void doesntWriteDataDescriptorWhenAddingRawEntries() throws IOException {\n136: ByteArrayOutputStream init = new ByteArrayOutputStream();\n137: try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(init)) {\n138: zos.putArchiveEntry(new ZipArchiveEntry(\"test1.txt\"));\n139: zos.write(\"foo\".getBytes(\"UTF-8\"));\n140: zos.closeArchiveEntry();\n141: }\n142: 143: File f = new File(dir, \"test.zip\");\n144: try (FileOutputStream fos = new FileOutputStream(f)) {\n145: fos.write(init.toByteArray());\n146: }\n147: 148: ByteArrayOutputStream o = new ByteArrayOutputStream();\n149: ZipArchiveEntry zae;\n150: try (ZipFile zf = new ZipFile(f);\n151: ZipArchiveOutputStream zos = new ZipArchiveOutputStream(o)) {\n152: zae = zf.getEntry(\"test1.txt\");\n153: zos.addRawArchiveEntry(zae, zf.getRawInputStream(zae));\n154: }\n155: 156: byte[] data = o.toByteArray();\n157: byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);\n158: // still 2.0 because of Deflate\n159: assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);\n160: byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);\n161: // no DD but EFS flag\n162: assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);\n163: 164: int cdhStart = findCentralDirectory(data);\n165: byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);\n166: assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);\n167: byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);\n168: assertArrayEquals(new byte[] { 0, 8 }, gpbInCDH);\n169: 170: int ddStart = cdhStart - 16;\n171: assertNotEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));\n172: long crcFromLFH = ZipLong.getValue(data, 14);\n173: long cSizeFromLFH = ZipLong.getValue(data, 18);\n174: long sizeFromLFH = ZipLong.getValue(data, 22);\n175: assertEquals(3, sizeFromLFH);\n176: 177: long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);\n178: assertEquals(crcFromLFH, crcFromCDH);\n179: long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);\n180: assertEquals(cSizeFromLFH, cSizeFromCDH);\n181: long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);\n182: assertEquals(sizeFromLFH, sizeFromCDH);\n183: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(final String name) {\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/util/zip/ZipEntry;)V",
                                    "method_body": "public ZipArchiveEntry(final java.util.zip.ZipEntry entry) throws ZipException {\nsuper(entry);\nsetName(entry.getName());\nfinal byte[] extra = entry.getExtra();\nif (extra != null) {\nsetExtraFields(ExtraFieldUtils.parse(extra, true,\nExtraFieldUtils\n.UnparseableExtraField.READ));\n} else {\n// initializes extra data to an empty byte array\nsetExtra();\n}\nsetMethod(entry.getMethod());\nthis.size = entry.getSize();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "public ZipArchiveEntry(final ZipArchiveEntry entry) throws ZipException {\nthis((java.util.zip.ZipEntry) entry);\nsetInternalAttributes(entry.getInternalAttributes());\nsetExternalAttributes(entry.getExternalAttributes());\nsetExtraFields(getAllExtraFieldsNoCopy());\nsetPlatform(entry.getPlatform());\nfinal GeneralPurposeBit other = entry.getGeneralPurposeBit();\nsetGeneralPurposeBit(other == null ? null :\n(GeneralPurposeBit) other.clone());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
                                    "method_body": "protected ZipArchiveEntry() {\nthis(\"\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<clinit>()V",
                                    "method_body": "public static final int PLATFORM_UNIX = 3;\npublic static final int PLATFORM_FAT  = 0;\npublic static final int CRC_UNKNOWN = -1;\nprivate static final int SHORT_MASK = 0xFFFF;\nprivate static final int SHORT_SHIFT = 16;\nprivate static final byte[] EMPTY = new byte[0];\n\n/**\n* The {@link java.util.zip.ZipEntry} base class only supports"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getMethod()I",
                                    "method_body": "public int getMethod() {\nreturn method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setMethod(I)V",
                                    "method_body": "public void setMethod(final int method) {\nif (method < 0) {\nthrow new IllegalArgumentException(\n\"ZIP compression method can not be negative: \" + method);\n}\nthis.method = method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getInternalAttributes()I",
                                    "method_body": "public int getInternalAttributes() {\nreturn internalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setInternalAttributes(I)V",
                                    "method_body": "public void setInternalAttributes(final int value) {\ninternalAttributes = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExternalAttributes()J",
                                    "method_body": "public long getExternalAttributes() {\nreturn externalAttributes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExternalAttributes(J)V",
                                    "method_body": "public void setExternalAttributes(final long value) {\nexternalAttributes = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setPlatform(I)V",
                                    "method_body": "protected void setPlatform(final int platform) {\nthis.platform = platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getAlignment()I",
                                    "method_body": "protected int getAlignment() {\nreturn this.alignment;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
                                    "method_body": "public void setExtraFields(final ZipExtraField[] fields) {\nfinal List<ZipExtraField> newFields = new ArrayList<>();\nfor (final ZipExtraField field : fields) {\nif (field instanceof UnparseableExtraFieldData) {\nunparseableExtra = (UnparseableExtraFieldData) field;\n} else {\nnewFields.add( field);\n}\n}\nextraFields = newFields.toArray(new ZipExtraField[newFields.size()]);\nsetExtra();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getAllExtraFieldsNoCopy()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "private ZipExtraField[] getAllExtraFieldsNoCopy() {\nif (extraFields == null) {\nreturn getUnparseableOnly();\n}\nreturn unparseableExtra != null ? getMergedFields() : extraFields;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getUnparseableOnly()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "private ZipExtraField[] getUnparseableOnly() {\nreturn unparseableExtra == null ? noExtraFields : new ZipExtraField[] { unparseableExtra };\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public ZipExtraField getExtraField(final ZipShort type) {\nif (extraFields != null) {\nfor (final ZipExtraField extraField : extraFields) {\nif (type.equals(extraField.getHeaderId())) {\nreturn extraField;\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra([B)V",
                                    "method_body": "public void setExtra(final byte[] extra) throws RuntimeException {\ntry {\nfinal ZipExtraField[] local =\nExtraFieldUtils.parse(extra, true,\nExtraFieldUtils.UnparseableExtraField.READ);\nmergeExtraFields(local, true);\n} catch (final ZipException e) {\n// actually this is not possible as of Commons Compress 1.1\nthrow new RuntimeException(\"Error parsing extra fields for entry: \" //NOSONAR\n+ getName() + \" - \" + e.getMessage(), e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
                                    "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getAllExtraFieldsNoCopy()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setCentralDirectoryExtra([B)V",
                                    "method_body": "public void setCentralDirectoryExtra(final byte[] b) {\ntry {\nfinal ZipExtraField[] central =\nExtraFieldUtils.parse(b, false,\nExtraFieldUtils.UnparseableExtraField.READ);\nmergeExtraFields(central, false);\n} catch (final ZipException e) {\nthrow new RuntimeException(e.getMessage(), e); //NOSONAR\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
                                    "method_body": "public byte[] getLocalFileDataExtra() {\nfinal byte[] extra = getExtra();\nreturn extra != null ? extra : EMPTY;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getCentralDirectoryExtra()[B",
                                    "method_body": "public byte[] getCentralDirectoryExtra() {\nreturn ExtraFieldUtils.mergeCentralDirectoryData(getAllExtraFieldsNoCopy());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "protected void setName(String name) {\nif (name != null && getPlatform() == PLATFORM_FAT\n&& !name.contains(\"/\")) {\nname = name.replace('\\\\', '/');\n}\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getSize()J",
                                    "method_body": "public long getSize() {\nreturn size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setSize(J)V",
                                    "method_body": "public void setSize(final long size) {\nif (size < 0) {\nthrow new IllegalArgumentException(\"invalid entry size\");\n}\nthis.size = size;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;[B)V",
                                    "method_body": "protected void setName(final String name, final byte[] rawName) {\nsetName(name);\nthis.rawName = rawName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalHeaderOffset()J",
                                    "method_body": "protected long getLocalHeaderOffset() {\nreturn this.localHeaderOffset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setLocalHeaderOffset(J)V",
                                    "method_body": "protected void setLocalHeaderOffset(long localHeaderOffset) {\nthis.localHeaderOffset = localHeaderOffset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getDataOffset()J",
                                    "method_body": "public long getDataOffset() {\nreturn dataOffset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setDataOffset(J)V",
                                    "method_body": "protected void setDataOffset(long dataOffset) {\nthis.dataOffset = dataOffset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setStreamContiguous(Z)V",
                                    "method_body": "protected void setStreamContiguous(boolean isStreamContiguous) {\nthis.isStreamContiguous = isStreamContiguous;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:hashCode()I",
                                    "method_body": "public int hashCode() {\n// this method has severe consequences on performance. We cannot rely\n// on the super.hashCode() method since super.getName() always return\n// the empty string in the current implemention (there's no setter)\n// so it is basically draining the performance of a hashmap lookup\nreturn getName().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getGeneralPurposeBit()Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "public GeneralPurposeBit getGeneralPurposeBit() {\nreturn gpb;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setGeneralPurposeBit(Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;)V",
                                    "method_body": "public void setGeneralPurposeBit(final GeneralPurposeBit b) {\ngpb = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:mergeExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;Z)V",
                                    "method_body": "private void mergeExtraFields(final ZipExtraField[] f, final boolean local)\nthrows ZipException {\nif (extraFields == null) {\nsetExtraFields(f);\n} else {\nfor (final ZipExtraField element : f) {\nZipExtraField existing;\nif (element instanceof UnparseableExtraFieldData) {\nexisting = unparseableExtra;\n} else {\nexisting = getExtraField(element.getHeaderId());\n}\nif (existing == null) {\naddExtraField(element);\n} else {\nif (local) {\nfinal byte[] b = element.getLocalFileDataData();\nexisting.parseFromLocalFileData(b, 0, b.length);\n} else {\nfinal byte[] b = element.getCentralDirectoryData();\nexisting.parseFromCentralDirectoryData(b, 0, b.length);\n}\n}\n}\nsetExtra();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setVersionMadeBy(I)V",
                                    "method_body": "public void setVersionMadeBy(final int versionMadeBy) {\nthis.versionMadeBy = versionMadeBy;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setVersionRequired(I)V",
                                    "method_body": "public void setVersionRequired(final int versionRequired) {\nthis.versionRequired = versionRequired;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setRawFlag(I)V",
                                    "method_body": "public void setRawFlag(final int rawFlag) {\nthis.rawFlag = rawFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:<init>()V",
                                    "method_body": "public GeneralPurposeBit() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesUTF8ForNames()Z",
                                    "method_body": "public boolean usesUTF8ForNames() {\nreturn languageEncodingFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useUTF8ForNames(Z)V",
                                    "method_body": "public void useUTF8ForNames(final boolean b) {\nlanguageEncodingFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useDataDescriptor(Z)V",
                                    "method_body": "public void useDataDescriptor(final boolean b) {\ndataDescriptorFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesEncryption()Z",
                                    "method_body": "public boolean usesEncryption() {\nreturn encryptionFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useEncryption(Z)V",
                                    "method_body": "public void useEncryption(final boolean b) {\nencryptionFlag = b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useStrongEncryption(Z)V",
                                    "method_body": "public void useStrongEncryption(final boolean b) {\nstrongEncryptionFlag = b;\nif (b) {\nuseEncryption(true);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:encode([BI)V",
                                    "method_body": "public void encode(final byte[] buf, final int offset) {\nZipShort.putShort((dataDescriptorFlag ? DATA_DESCRIPTOR_FLAG : 0)\n|\n(languageEncodingFlag ? UFT8_NAMES_FLAG : 0)\n|\n(encryptionFlag ? ENCRYPTION_FLAG : 0)\n|\n(strongEncryptionFlag ? STRONG_ENCRYPTION_FLAG : 0)\n, buf, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:parse([BI)Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "public static GeneralPurposeBit parse(final byte[] data, final int offset) {\nfinal int generalPurposeFlag = ZipShort.getValue(data, offset);\nfinal GeneralPurposeBit b = new GeneralPurposeBit();\nb.useDataDescriptor((generalPurposeFlag & DATA_DESCRIPTOR_FLAG) != 0);\nb.useUTF8ForNames((generalPurposeFlag & UFT8_NAMES_FLAG) != 0);\nb.useStrongEncryption((generalPurposeFlag & STRONG_ENCRYPTION_FLAG) != 0);\nb.useEncryption((generalPurposeFlag & ENCRYPTION_FLAG) != 0);\nb.slidingDictionarySize = (generalPurposeFlag & SLIDING_DICTIONARY_SIZE_FLAG) != 0 ? 8192 : 4096;\nb.numberOfShannonFanoTrees = (generalPurposeFlag & NUMBER_OF_SHANNON_FANO_TREES_FLAG) != 0 ? 3 : 2;\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:clone()Ljava/lang/Object;",
                                    "method_body": "public Object clone() {\ntry {\nreturn super.clone();\n} catch (final CloneNotSupportedException ex) {\n// impossible\nthrow new RuntimeException(\"GeneralPurposeBit is not Cloneable?\", ex); //NOSONAR\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveOutputStream:count(I)V",
                                    "method_body": "protected void count(final int written) {\ncount((long) written);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.ArchiveOutputStream:count(J)V",
                                    "method_body": "protected void count(final long written) {\nif (written != -1) {\nbytesWritten = bytesWritten + written;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
                                    "method_body": "public ZipArchiveOutputStream(final OutputStream out) {\nthis.out = out;\nthis.channel = null;\ndef = new Deflater(level, true);\nstreamCompressor = StreamCompressor.create(out, def);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
                                    "method_body": "public static final int EFS_FLAG = GeneralPurposeBit.UFT8_NAMES_FLAG;\n\nprivate static final byte[] EMPTY = new byte[0];\n\n/**\n* Current entry.\n*/\nprivate CurrentEntry entry;\n\n/**\n* The file comment.\n*/\nprivate String comment = \"\";\n\n/**\n* Compression level for next entry.\n*/\nprivate int level = DEFAULT_COMPRESSION;\n\n/**\n* Has the compression level changed when compared to the last\n* entry?\n*/\nprivate boolean hasCompressionLevelChanged = false;\n\n/**\n* Default compression method for next entry.\n*/\nprivate int method = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* List of ZipArchiveEntries written so far.\n*/\nprivate final List<ZipArchiveEntry> entries =\nnew LinkedList<>();\n\nprivate final StreamCompressor streamCompressor;\n\n/**\n* Start of central directory.\n*/\nprivate long cdOffset = 0;\n\n/**\n* Length of central directory.\n*/\nprivate long cdLength = 0;\n\n/**\n* Helper, a 0 as ZipShort.\n*/\nprivate static final byte[] ZERO = {0, 0};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:finish()V",
                                    "method_body": "public void finish() throws IOException {\nif (finished) {\nthrow new IOException(\"This archive has already been finished\");\n}\n\nif (entry != null) {\nthrow new IOException(\"This archive contains unclosed entries.\");\n}\n\ncdOffset = streamCompressor.getTotalBytesWritten();\nwriteCentralDirectoryInChunks();\n\ncdLength = streamCompressor.getTotalBytesWritten() - cdOffset;\nwriteZip64CentralDirectory();\nwriteCentralDirectoryEnd();\nmetaData.clear();\nentries.clear();\nstreamCompressor.close();\nfinished = true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryInChunks()V",
                                    "method_body": "private void writeCentralDirectoryInChunks() throws IOException {\nfinal int NUM_PER_WRITE = 1000;\nfinal ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(70 * NUM_PER_WRITE);\nint count = 0;\nfor (final ZipArchiveEntry ze : entries) {\nbyteArrayOutputStream.write(createCentralFileHeader(ze));\nif (++count > NUM_PER_WRITE){\nwriteCounted(byteArrayOutputStream.toByteArray());\nbyteArrayOutputStream.reset();\ncount = 0;\n}\n}\nwriteCounted(byteArrayOutputStream.toByteArray());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeArchiveEntry()V",
                                    "method_body": "public void closeArchiveEntry() throws IOException {\npreClose();\n\nflushDeflater();\n\nfinal long bytesWritten = streamCompressor.getTotalBytesWritten() - entry.dataStart;\nfinal long realCrc = streamCompressor.getCrc32();\nentry.bytesRead = streamCompressor.getBytesRead();\nfinal Zip64Mode effectiveMode = getEffectiveZip64Mode(entry.entry);\nfinal boolean actuallyNeedsZip64 = handleSizesAndCrc(bytesWritten, realCrc, effectiveMode);\ncloseEntry(actuallyNeedsZip64, false);\nstreamCompressor.reset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeCopiedEntry(Z)V",
                                    "method_body": "private void closeCopiedEntry(final boolean phased) throws IOException {\npreClose();\nentry.bytesRead = entry.entry.getSize();\nfinal Zip64Mode effectiveMode = getEffectiveZip64Mode(entry.entry);\nfinal boolean actuallyNeedsZip64 = checkIfNeedsZip64(effectiveMode);\ncloseEntry(actuallyNeedsZip64, phased);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeEntry(ZZ)V",
                                    "method_body": "private void closeEntry(final boolean actuallyNeedsZip64, final boolean phased) throws IOException {\nif (!phased && channel != null) {\nrewriteSizesAndCrc(actuallyNeedsZip64);\n}\n\nif (!phased) {\nwriteDataDescriptor(entry.entry);\n}\nentry = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:preClose()V",
                                    "method_body": "private void preClose() throws IOException {\nif (finished) {\nthrow new IOException(\"Stream has already been finished\");\n}\n\nif (entry == null) {\nthrow new IOException(\"No current entry to close\");\n}\n\nif (!entry.hasWritten) {\nwrite(EMPTY, 0, 0);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:addRawArchiveEntry(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Ljava/io/InputStream;)V",
                                    "method_body": "public void addRawArchiveEntry(final ZipArchiveEntry entry, final InputStream rawStream)\nthrows IOException {\nfinal ZipArchiveEntry ae = new ZipArchiveEntry(entry);\nif (hasZip64Extra(ae)) {\n// Will be re-added as required. this may make the file generated with this method\n// somewhat smaller than standard mode,\n// since standard mode is unable to remove the zip 64 header.\nae.removeExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n}\nfinal boolean is2PhaseSource = ae.getCrc() != ZipArchiveEntry.CRC_UNKNOWN\n&& ae.getSize() != ArchiveEntry.SIZE_UNKNOWN\n&& ae.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN;\nputArchiveEntry(ae, is2PhaseSource);\ncopyFromZipInputStream(rawStream);\ncloseCopiedEntry(is2PhaseSource);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:flushDeflater()V",
                                    "method_body": "private void flushDeflater() throws IOException {\nif (entry.entry.getMethod() == DEFLATED) {\nstreamCompressor.flushDeflater();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:handleSizesAndCrc(JJLorg/apache/commons/compress/archivers/zip/Zip64Mode;)Z",
                                    "method_body": "private boolean handleSizesAndCrc(final long bytesWritten, final long crc,\nfinal Zip64Mode effectiveMode)\nthrows ZipException {\nif (entry.entry.getMethod() == DEFLATED) {\n/* It turns out def.getBytesRead() returns wrong values if\n* the size exceeds 4 GB on Java < Java7\nentry.entry.setSize(def.getBytesRead());\n*/\nentry.entry.setSize(entry.bytesRead);\nentry.entry.setCompressedSize(bytesWritten);\nentry.entry.setCrc(crc);\n\n} else if (channel == null) {\nif (entry.entry.getCrc() != crc) {\nthrow new ZipException(\"bad CRC checksum for entry \"\n+ entry.entry.getName() + \": \"\n+ Long.toHexString(entry.entry.getCrc())\n+ \" instead of \"\n+ Long.toHexString(crc));\n}\n\nif (entry.entry.getSize() != bytesWritten) {\nthrow new ZipException(\"bad size for entry \"\n+ entry.entry.getName() + \": \"\n+ entry.entry.getSize()\n+ \" instead of \"\n+ bytesWritten);\n}\n} else { /* method is STORED and we used SeekableByteChannel */\nentry.entry.setSize(bytesWritten);\nentry.entry.setCompressedSize(bytesWritten);\nentry.entry.setCrc(crc);\n}\n\nreturn checkIfNeedsZip64(effectiveMode);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:checkIfNeedsZip64(Lorg/apache/commons/compress/archivers/zip/Zip64Mode;)Z",
                                    "method_body": "private boolean checkIfNeedsZip64(final Zip64Mode effectiveMode)\nthrows ZipException {\nfinal boolean actuallyNeedsZip64 = isZip64Required(entry.entry, effectiveMode);\nif (actuallyNeedsZip64 && effectiveMode == Zip64Mode.Never) {\nthrow new Zip64RequiredException(Zip64RequiredException.getEntryTooBigMessage(entry.entry));\n}\nreturn actuallyNeedsZip64;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:isZip64Required(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Lorg/apache/commons/compress/archivers/zip/Zip64Mode;)Z",
                                    "method_body": "private boolean isZip64Required(final ZipArchiveEntry entry1, final Zip64Mode requestedMode) {\nreturn requestedMode == Zip64Mode.Always || isTooLageForZip32(entry1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:isTooLageForZip32(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private boolean isTooLageForZip32(final ZipArchiveEntry zipArchiveEntry){\nreturn zipArchiveEntry.getSize() >= ZIP64_MAGIC || zipArchiveEntry.getCompressedSize() >= ZIP64_MAGIC;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
                                    "method_body": "public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\nputArchiveEntry(archiveEntry, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;Z)V",
                                    "method_body": "private void putArchiveEntry(final ArchiveEntry archiveEntry, final boolean phased) throws IOException {\nif (finished) {\nthrow new IOException(\"Stream has already been finished\");\n}\n\nif (entry != null) {\ncloseArchiveEntry();\n}\n\nentry = new CurrentEntry((ZipArchiveEntry) archiveEntry);\nentries.add(entry.entry);\n\nsetDefaults(entry.entry);\n\nfinal Zip64Mode effectiveMode = getEffectiveZip64Mode(entry.entry);\nvalidateSizeInformation(effectiveMode);\n\nif (shouldAddZip64Extra(entry.entry, effectiveMode)) {\n\nfinal Zip64ExtendedInformationExtraField z64 = getZip64Extra(entry.entry);\n\nZipEightByteInteger size, compressedSize;\nif (phased) {\n// sizes are already known\nsize = new ZipEightByteInteger(entry.entry.getSize());\ncompressedSize = new ZipEightByteInteger(entry.entry.getCompressedSize());\n} else if (entry.entry.getMethod() == STORED\n&& entry.entry.getSize() != ArchiveEntry.SIZE_UNKNOWN) {\n// actually, we already know the sizes\ncompressedSize = size = new ZipEightByteInteger(entry.entry.getSize());\n} else {\n// just a placeholder, real data will be in data\n// descriptor or inserted later via SeekableByteChannel\ncompressedSize = size = ZipEightByteInteger.ZERO;\n}\nz64.setSize(size);\nz64.setCompressedSize(compressedSize);\nentry.entry.setExtra();\n}\n\nif (entry.entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\ndef.setLevel(level);\nhasCompressionLevelChanged = false;\n}\nwriteLocalFileHeader((ZipArchiveEntry) archiveEntry, phased);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setDefaults(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "private void setDefaults(final ZipArchiveEntry entry) {\nif (entry.getMethod() == -1) { // not specified\nentry.setMethod(method);\n}\n\nif (entry.getTime() == -1) { // not specified\nentry.setTime(System.currentTimeMillis());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:validateSizeInformation(Lorg/apache/commons/compress/archivers/zip/Zip64Mode;)V",
                                    "method_body": "private void validateSizeInformation(final Zip64Mode effectiveMode)\nthrows ZipException {\n// Size/CRC not required if SeekableByteChannel is used\nif (entry.entry.getMethod() == STORED && channel == null) {\nif (entry.entry.getSize() == ArchiveEntry.SIZE_UNKNOWN) {\nthrow new ZipException(\"uncompressed size is required for\"\n+ \" STORED method when not writing to a\"\n+ \" file\");\n}\nif (entry.entry.getCrc() == ZipArchiveEntry.CRC_UNKNOWN) {\nthrow new ZipException(\"crc checksum is required for STORED\"\n+ \" method when not writing to a file\");\n}\nentry.entry.setCompressedSize(entry.entry.getSize());\n}\n\nif ((entry.entry.getSize() >= ZIP64_MAGIC\n|| entry.entry.getCompressedSize() >= ZIP64_MAGIC)\n&& effectiveMode == Zip64Mode.Never) {\nthrow new Zip64RequiredException(Zip64RequiredException\n.getEntryTooBigMessage(entry.entry));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:shouldAddZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Lorg/apache/commons/compress/archivers/zip/Zip64Mode;)Z",
                                    "method_body": "private boolean shouldAddZip64Extra(final ZipArchiveEntry entry, final Zip64Mode mode) {\nreturn mode == Zip64Mode.Always\n|| entry.getSize() >= ZIP64_MAGIC\n|| entry.getCompressedSize() >= ZIP64_MAGIC\n|| (entry.getSize() == ArchiveEntry.SIZE_UNKNOWN\n&& channel != null && mode != Zip64Mode.Never);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:write([BII)V",
                                    "method_body": "public void write(final byte[] b, final int offset, final int length) throws IOException {\nif (entry == null) {\nthrow new IllegalStateException(\"No current entry\");\n}\nZipUtil.checkRequestedFeatures(entry.entry);\nfinal long writtenThisTime = streamCompressor.write(b, offset, length, entry.entry.getMethod());\ncount(writtenThisTime);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCounted([B)V",
                                    "method_body": "private void writeCounted(final byte[] data) throws IOException {\nstreamCompressor.writeCounted(data);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:copyFromZipInputStream(Ljava/io/InputStream;)V",
                                    "method_body": "private void copyFromZipInputStream(final InputStream src) throws IOException {\nif (entry == null) {\nthrow new IllegalStateException(\"No current entry\");\n}\nZipUtil.checkRequestedFeatures(entry.entry);\nentry.hasWritten = true;\nint length;\nwhile ((length = src.read(copyBuffer)) >= 0 )\n{\nstreamCompressor.writeCounted(copyBuffer, 0, length);\ncount( length );\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!finished) {\nfinish();\n}\ndestroy();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Z)V",
                                    "method_body": "private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nfinal ByteBuffer name = getName(ze);\n\nif (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\naddUnicodeExtraFields(ze, encodable, name);\n}\n\nfinal long localHeaderStart = streamCompressor.getTotalBytesWritten();\nfinal byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\nmetaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\nentry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\nwriteCounted(localHeader);\nentry.dataStart = streamCompressor.getTotalBytesWritten();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:createLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Ljava/nio/ByteBuffer;ZZJ)[B",
                                    "method_body": "private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\nfinal boolean phased, long archiveOffset) throws IOException {\nResourceAlignmentExtraField oldAlignmentEx =\n(ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\nif (oldAlignmentEx != null) {\nze.removeExtraField(ResourceAlignmentExtraField.ID);\n}\n\nint alignment = ze.getAlignment();\nif (alignment <= 0 && oldAlignmentEx != null) {\nalignment = oldAlignmentEx.getAlignment();\n}\n\nif (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\nint oldLength = LFH_FILENAME_OFFSET +\nname.limit() - name.position() +\nze.getLocalFileDataExtra().length;\n\nint padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE\n- ResourceAlignmentExtraField.BASE_SIZE) &\n(alignment - 1));\nze.addExtraField(new ResourceAlignmentExtraField(alignment,\noldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n}\n\nfinal byte[] extra = ze.getLocalFileDataExtra();\nfinal int nameLen = name.limit() - name.position();\nfinal int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\nfinal byte[] buf = new byte[len];\n\nSystem.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n\n//store method in local variable to prevent multiple method calls\nfinal int zipMethod = ze.getMethod();\nfinal boolean dataDescriptor = usesDataDescriptor(zipMethod);\n\nputShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n\nfinal GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\ngeneralPurposeBit.encode(buf, LFH_GPB_OFFSET);\n\n// compression method\nputShort(zipMethod, buf, LFH_METHOD_OFFSET);\n\nZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n\n// CRC\nif (phased){\nputLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n} else if (zipMethod == DEFLATED || channel != null) {\nSystem.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n} else {\nputLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n}\n\n// compressed length\n// uncompressed length\nif (hasZip64Extra(entry.entry)){\n// point to ZIP64 extended information extra field for\n// sizes, may get rewritten once sizes are known if\n// stream is seekable\nZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\nZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n} else if (phased) {\nputLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\nputLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n} else if (zipMethod == DEFLATED || channel != null) {\nSystem.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\nSystem.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n} else { // Stored\nputLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\nputLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n}\n// file name length\nputShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n\n// extra field length\nputShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n\n// file name\nSystem.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n\n// extra fields\nSystem.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n\nreturn buf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeDataDescriptor(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\nif (ze.getMethod() != DEFLATED || channel != null) {\nreturn;\n}\nwriteCounted(DD_SIG);\nwriteCounted(ZipLong.getBytes(ze.getCrc()));\nif (!hasZip64Extra(ze)) {\nwriteCounted(ZipLong.getBytes(ze.getCompressedSize()));\nwriteCounted(ZipLong.getBytes(ze.getSize()));\n} else {\nwriteCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\nwriteCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:createCentralFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)[B",
                                    "method_body": "private byte[] createCentralFileHeader(final ZipArchiveEntry ze) throws IOException {\n\nfinal EntryMetaData entryMetaData = metaData.get(ze);\nfinal boolean needsZip64Extra = hasZip64Extra(ze)\n|| ze.getCompressedSize() >= ZIP64_MAGIC\n|| ze.getSize() >= ZIP64_MAGIC\n|| entryMetaData.offset >= ZIP64_MAGIC\n|| zip64Mode == Zip64Mode.Always;\n\nif (needsZip64Extra && zip64Mode == Zip64Mode.Never) {\n// must be the offset that is too big, otherwise an\n// exception would have been throw in putArchiveEntry or\n// closeArchiveEntry\nthrow new Zip64RequiredException(Zip64RequiredException\n.ARCHIVE_TOO_BIG_MESSAGE);\n}\n\n\nhandleZip64Extra(ze, entryMetaData.offset, needsZip64Extra);\n\nreturn createCentralFileHeader(ze, getName(ze), entryMetaData, needsZip64Extra);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:createCentralFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Ljava/nio/ByteBuffer;Lorg/apache/commons/compress/archivers/zip/ZipArchiveOutputStream$EntryMetaData;Z)[B",
                                    "method_body": "private byte[] createCentralFileHeader(final ZipArchiveEntry ze, final ByteBuffer name,\nfinal EntryMetaData entryMetaData,\nfinal boolean needsZip64Extra) throws IOException {\nfinal byte[] extra = ze.getCentralDirectoryExtra();\n\n// file comment length\nString comm = ze.getComment();\nif (comm == null) {\ncomm = \"\";\n}\n\nfinal ByteBuffer commentB = getEntryEncoding(ze).encode(comm);\nfinal int nameLen = name.limit() - name.position();\nfinal int commentLen = commentB.limit() - commentB.position();\nfinal int len= CFH_FILENAME_OFFSET + nameLen + extra.length + commentLen;\nfinal byte[] buf = new byte[len];\n\nSystem.arraycopy(CFH_SIG,  0, buf, CFH_SIG_OFFSET, WORD);\n\n// version made by\n// CheckStyle:MagicNumber OFF\nputShort((ze.getPlatform() << 8) | (!hasUsedZip64 ? DATA_DESCRIPTOR_MIN_VERSION : ZIP64_MIN_VERSION),\nbuf, CFH_VERSION_MADE_BY_OFFSET);\n\nfinal int zipMethod = ze.getMethod();\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nputShort(versionNeededToExtract(zipMethod, needsZip64Extra, entryMetaData.usesDataDescriptor),\nbuf, CFH_VERSION_NEEDED_OFFSET);\ngetGeneralPurposeBits(!encodable && fallbackToUTF8, entryMetaData.usesDataDescriptor).encode(buf, CFH_GPB_OFFSET);\n\n// compression method\nputShort(zipMethod, buf, CFH_METHOD_OFFSET);\n\n\n// last mod. time and date\nZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, CFH_TIME_OFFSET);\n\n// CRC\n// compressed length\n// uncompressed length\nputLong(ze.getCrc(), buf, CFH_CRC_OFFSET);\nif (ze.getCompressedSize() >= ZIP64_MAGIC\n|| ze.getSize() >= ZIP64_MAGIC\n|| zip64Mode == Zip64Mode.Always) {\nZipLong.ZIP64_MAGIC.putLong(buf, CFH_COMPRESSED_SIZE_OFFSET);\nZipLong.ZIP64_MAGIC.putLong(buf, CFH_ORIGINAL_SIZE_OFFSET);\n} else {\nputLong(ze.getCompressedSize(), buf, CFH_COMPRESSED_SIZE_OFFSET);\nputLong(ze.getSize(), buf, CFH_ORIGINAL_SIZE_OFFSET);\n}\n\nputShort(nameLen, buf, CFH_FILENAME_LENGTH_OFFSET);\n\n// extra field length\nputShort(extra.length, buf, CFH_EXTRA_LENGTH_OFFSET);\n\nputShort(commentLen, buf, CFH_COMMENT_LENGTH_OFFSET);\n\n// disk number start\nSystem.arraycopy(ZERO, 0, buf, CFH_DISK_NUMBER_OFFSET, SHORT);\n\n// internal file attributes\nputShort(ze.getInternalAttributes(), buf, CFH_INTERNAL_ATTRIBUTES_OFFSET);\n\n// external file attributes\nputLong(ze.getExternalAttributes(), buf, CFH_EXTERNAL_ATTRIBUTES_OFFSET);\n\n// relative offset of LFH\nif (entryMetaData.offset >= ZIP64_MAGIC || zip64Mode == Zip64Mode.Always) {\nputLong(ZIP64_MAGIC, buf, CFH_LFH_OFFSET);\n} else {\nputLong(Math.min(entryMetaData.offset, ZIP64_MAGIC), buf, CFH_LFH_OFFSET);\n}\n\n// file name\nSystem.arraycopy(name.array(), name.arrayOffset(), buf, CFH_FILENAME_OFFSET, nameLen);\n\nfinal int extraStart = CFH_FILENAME_OFFSET + nameLen;\nSystem.arraycopy(extra, 0, buf, extraStart, extra.length);\n\nfinal int commentStart = extraStart + extra.length;\n\n// file comment\nSystem.arraycopy(commentB.array(), commentB.arrayOffset(), buf, commentStart, commentLen);\nreturn buf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:handleZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;JZ)V",
                                    "method_body": "private void handleZip64Extra(final ZipArchiveEntry ze, final long lfhOffset,\nfinal boolean needsZip64Extra) {\nif (needsZip64Extra) {\nfinal Zip64ExtendedInformationExtraField z64 = getZip64Extra(ze);\nif (ze.getCompressedSize() >= ZIP64_MAGIC\n|| ze.getSize() >= ZIP64_MAGIC\n|| zip64Mode == Zip64Mode.Always) {\nz64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));\nz64.setSize(new ZipEightByteInteger(ze.getSize()));\n} else {\n// reset value that may have been set for LFH\nz64.setCompressedSize(null);\nz64.setSize(null);\n}\nif (lfhOffset >= ZIP64_MAGIC || zip64Mode == Zip64Mode.Always) {\nz64.setRelativeHeaderOffset(new ZipEightByteInteger(lfhOffset));\n}\nze.setExtra();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryEnd()V",
                                    "method_body": "protected void writeCentralDirectoryEnd() throws IOException {\nwriteCounted(EOCD_SIG);\n\n// disk numbers\nwriteCounted(ZERO);\nwriteCounted(ZERO);\n\n// number of entries\nfinal int numberOfEntries = entries.size();\nif (numberOfEntries > ZIP64_MAGIC_SHORT\n&& zip64Mode == Zip64Mode.Never) {\nthrow new Zip64RequiredException(Zip64RequiredException\n.TOO_MANY_ENTRIES_MESSAGE);\n}\nif (cdOffset > ZIP64_MAGIC && zip64Mode == Zip64Mode.Never) {\nthrow new Zip64RequiredException(Zip64RequiredException\n.ARCHIVE_TOO_BIG_MESSAGE);\n}\n\nfinal byte[] num = ZipShort.getBytes(Math.min(numberOfEntries,\nZIP64_MAGIC_SHORT));\nwriteCounted(num);\nwriteCounted(num);\n\n// length and location of CD\nwriteCounted(ZipLong.getBytes(Math.min(cdLength, ZIP64_MAGIC)));\nwriteCounted(ZipLong.getBytes(Math.min(cdOffset, ZIP64_MAGIC)));\n\n// ZIP file comment\nfinal ByteBuffer data = this.zipEncoding.encode(comment);\nfinal int dataLen = data.limit() - data.position();\nwriteCounted(ZipShort.getBytes(dataLen));\nstreamCompressor.writeCounted(data.array(), data.arrayOffset(), dataLen);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeZip64CentralDirectory()V",
                                    "method_body": "protected void writeZip64CentralDirectory() throws IOException {\nif (zip64Mode == Zip64Mode.Never) {\nreturn;\n}\n\nif (!hasUsedZip64\n&& (cdOffset >= ZIP64_MAGIC || cdLength >= ZIP64_MAGIC\n|| entries.size() >= ZIP64_MAGIC_SHORT)) {\n// actually \"will use\"\nhasUsedZip64 = true;\n}\n\nif (!hasUsedZip64) {\nreturn;\n}\n\nfinal long offset = streamCompressor.getTotalBytesWritten();\n\nwriteOut(ZIP64_EOCD_SIG);\n// size, we don't have any variable length as we don't support\n// the extensible data sector, yet\nwriteOut(ZipEightByteInteger\n.getBytes(SHORT   /* version made by */\n+ SHORT /* version needed to extract */\n+ WORD  /* disk number */\n+ WORD  /* disk with central directory */\n+ DWORD /* number of entries in CD on this disk */\n+ DWORD /* total number of entries */\n+ DWORD /* size of CD */\n+ (long) DWORD /* offset of CD */\n));\n\n// version made by and version needed to extract\nwriteOut(ZipShort.getBytes(ZIP64_MIN_VERSION));\nwriteOut(ZipShort.getBytes(ZIP64_MIN_VERSION));\n\n// disk numbers - four bytes this time\nwriteOut(LZERO);\nwriteOut(LZERO);\n\n// number of entries\nfinal byte[] num = ZipEightByteInteger.getBytes(entries.size());\nwriteOut(num);\nwriteOut(num);\n\n// length and location of CD\nwriteOut(ZipEightByteInteger.getBytes(cdLength));\nwriteOut(ZipEightByteInteger.getBytes(cdOffset));\n\n// no \"zip64 extensible data sector\" for now\n\n// and now the \"ZIP64 end of central directory locator\"\nwriteOut(ZIP64_EOCD_LOC_SIG);\n\n// disk number holding the ZIP64 EOCD record\nwriteOut(LZERO);\n// relative offset of ZIP64 EOCD record\nwriteOut(ZipEightByteInteger.getBytes(offset));\n// total number of disks\nwriteOut(ONE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:getGeneralPurposeBits(ZZ)Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "private GeneralPurposeBit getGeneralPurposeBits(final boolean utfFallback, boolean usesDataDescriptor) {\nfinal GeneralPurposeBit b = new GeneralPurposeBit();\nb.useUTF8ForNames(useUTF8Flag || utfFallback);\nif (usesDataDescriptor) {\nb.useDataDescriptor(true);\n}\nreturn b;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:versionNeededToExtract(IZZ)I",
                                    "method_body": "private int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\nif (zip64) {\nreturn ZIP64_MIN_VERSION;\n}\nif (usedDataDescriptor) {\nreturn DATA_DESCRIPTOR_MIN_VERSION;\n}\nreturn versionNeededToExtractMethod(zipMethod);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:usesDataDescriptor(I)Z",
                                    "method_body": "private boolean usesDataDescriptor(final int zipMethod) {\nreturn zipMethod == DEFLATED && channel == null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:hasZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private boolean hasZip64Extra(final ZipArchiveEntry ze) {\nreturn ze.getExtraField(Zip64ExtendedInformationExtraField\n.HEADER_ID)\n!= null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:getEffectiveZip64Mode(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Lorg/apache/commons/compress/archivers/zip/Zip64Mode;",
                                    "method_body": "private Zip64Mode getEffectiveZip64Mode(final ZipArchiveEntry ze) {\nif (zip64Mode != Zip64Mode.AsNeeded\n|| channel != null\n|| ze.getMethod() != DEFLATED\n|| ze.getSize() != ArchiveEntry.SIZE_UNKNOWN) {\nreturn zip64Mode;\n}\nreturn Zip64Mode.Never;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:getEntryEncoding(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "private ZipEncoding getEntryEncoding(final ZipArchiveEntry ze) {\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nreturn !encodable && fallbackToUTF8\n? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:getName(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Ljava/nio/ByteBuffer;",
                                    "method_body": "private ByteBuffer getName(final ZipArchiveEntry ze) throws IOException {\nreturn getEntryEncoding(ze).encode(ze.getName());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:destroy()V",
                                    "method_body": "void destroy() throws IOException {\nif (channel != null) {\nchannel.close();\n}\nif (out != null) {\nout.close();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(final long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Data Descriptor signature.\n*\n* <p>Actually, PKWARE uses this as marker for split/spanned\n* archives and other archivers have started to use it as Data\n* Descriptor signature (as well).</p>\n* @since 1.1\n*/\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\n\n/**\n* Value stored in size and similar fields if ZIP64 extensions are\n* used.\n* @since 1.3\n*/\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\n\n/**\n* Marks ZIP archives that were supposed to be split or spanned\n* but only needed a single segment in then end (so are actually\n* neither split nor spanned).\n*\n* <p>This is the \"PK00\" prefix found in some archives.</p>\n* @since 1.5\n*/\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\nnew ZipLong(0X30304B50L);\n\n/**\n* Archive extra data record signature.\n* @since 1.5\n*/\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(final long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(final long value) {\nfinal byte[] result = new byte[WORD];\nputLong(value, result, 0);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:putLong(J[BI)V",
                                    "method_body": "public static void putLong(final long value, final byte[] buf, int offset) {\nByteUtils.toLittleEndian(buf, value, offset, 4);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
                                    "method_body": "public static long getValue(final byte[] bytes, final int offset) {\nreturn ByteUtils.fromLittleEndian(bytes, offset, 4);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
                                    "method_body": "public static long getValue(final byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ByteUtils:fromLittleEndian([BII)J",
                                    "method_body": "public static long fromLittleEndian(byte[] bytes, final int off, final int length) {\ncheckReadLength(length);\nlong l = 0;\nfor (int i = 0; i < length; i++) {\nl |= (bytes[off + i] & 0xffl) << (8 * i);\n}\nreturn l;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ByteUtils:toLittleEndian([BJII)V",
                                    "method_body": "public static void toLittleEndian(final byte[] b, final long value, final int off, final int length) {\nlong num = value;\nfor (int i = 0; i < length; i++) {\nb[off + i] = (byte) (num & 0xff);\nnum >>= 8;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ByteUtils:checkReadLength(I)V",
                                    "method_body": "private static final void checkReadLength(int length) {\nif (length > 8) {\nthrow new IllegalArgumentException(\"can't read more than eight bytes into a long value\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n\nstatic {\nfinal Map<String, SimpleEncodingHolder> se =\nnew HashMap<>();\n\nfinal char[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nfinal SimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\n\nfinal char[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nfinal SimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(final String name) {\n\n// fallback encoding is good enough for UTF-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nfinal SimpleEncodingHolder h = simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nfinal Charset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (final UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\n// check platform's default encoding\ncharsetName = Charset.defaultCharset().name();\n}\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}\nfor (final String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(final char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(final String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:canEncode(Ljava/lang/String;)Z",
                                    "method_body": "public boolean canEncode(final String name) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:encode(Ljava/lang/String;)Ljava/nio/ByteBuffer;",
                                    "method_body": "public ByteBuffer encode(final String name) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn ByteBuffer.wrap(name.getBytes());\n}\nreturn ByteBuffer.wrap(name.getBytes(this.charsetName));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
                                    "method_body": "public String decode(final byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data);\n}\nreturn new String(data,this.charsetName);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\n\n/**\n* <p>\n* Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\n* (either order accepted on input, big-endian used on output)\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, big-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, little-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\n\n/**\n* <p>\n* Eight-bit Unicode Transformation Format.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<init>(Ljava/lang/String;)V",
                                    "method_body": "private UnicodeExtraFieldPolicy(final String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$UnicodeExtraFieldPolicy:<clinit>()V",
                                    "method_body": "public static final UnicodeExtraFieldPolicy ALWAYS = new UnicodeExtraFieldPolicy(\"always\");\n/**\n* Never create Unicode extra fields.\n*/\npublic static final UnicodeExtraFieldPolicy NEVER = new UnicodeExtraFieldPolicy(\"never\");\n/**\n* Create Unicode extra fields for filenames that cannot be\n* encoded using the specified encoding.\n*/\npublic static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\nnew UnicodeExtraFieldPolicy(\"not encodeable\");\n\nprivate final String name;\nprivate UnicodeExtraFieldPolicy(final String n) {\nname = n;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:<init>(Ljava/util/zip/Deflater;)V",
                                    "method_body": "StreamCompressor(final Deflater deflater) {\nthis.def = deflater;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:create(Ljava/io/OutputStream;Ljava/util/zip/Deflater;)Lorg/apache/commons/compress/archivers/zip/StreamCompressor;",
                                    "method_body": "static StreamCompressor create(final OutputStream os, final Deflater deflater) {\nreturn new OutputStreamCompressor(deflater, os);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:getCrc32()J",
                                    "method_body": "public long getCrc32() {\nreturn crc.getValue();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:getBytesRead()J",
                                    "method_body": "public long getBytesRead() {\nreturn sourcePayloadLength;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:getTotalBytesWritten()J",
                                    "method_body": "public long getTotalBytesWritten() {\nreturn totalWrittenToOutputStream;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:write([BIII)J",
                                    "method_body": "long write(final byte[] b, final int offset, final int length, final int method) throws IOException {\nfinal long current = writtenToOutputStreamForLastEntry;\ncrc.update(b, offset, length);\nif (method == ZipEntry.DEFLATED) {\nwriteDeflated(b, offset, length);\n} else {\nwriteCounted(b, offset, length);\n}\nsourcePayloadLength += length;\nreturn writtenToOutputStreamForLastEntry - current;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:reset()V",
                                    "method_body": "void reset() {\ncrc.reset();\ndef.reset();\nsourcePayloadLength = 0;\nwrittenToOutputStreamForLastEntry = 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:close()V",
                                    "method_body": "public void close() throws IOException {\ndef.end();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:flushDeflater()V",
                                    "method_body": "void flushDeflater() throws IOException {\ndef.finish();\nwhile (!def.finished()) {\ndeflate();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:writeDeflated([BII)V",
                                    "method_body": "private void writeDeflated(final byte[] b, final int offset, final int length)\nthrows IOException {\nif (length > 0 && !def.finished()) {\nif (length <= DEFLATER_BLOCK_SIZE) {\ndef.setInput(b, offset, length);\ndeflateUntilInputIsNeeded();\n} else {\nfinal int fullblocks = length / DEFLATER_BLOCK_SIZE;\nfor (int i = 0; i < fullblocks; i++) {\ndef.setInput(b, offset + i * DEFLATER_BLOCK_SIZE,\nDEFLATER_BLOCK_SIZE);\ndeflateUntilInputIsNeeded();\n}\nfinal int done = fullblocks * DEFLATER_BLOCK_SIZE;\nif (done < length) {\ndef.setInput(b, offset + done, length - done);\ndeflateUntilInputIsNeeded();\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:deflateUntilInputIsNeeded()V",
                                    "method_body": "private void deflateUntilInputIsNeeded() throws IOException {\nwhile (!def.needsInput()) {\ndeflate();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:deflate()V",
                                    "method_body": "void deflate() throws IOException {\nfinal int len = def.deflate(outputBuffer, 0, outputBuffer.length);\nif (len > 0) {\nwriteCounted(outputBuffer, 0, len);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:writeCounted([B)V",
                                    "method_body": "public void writeCounted(final byte[] data) throws IOException {\nwriteCounted(data, 0, data.length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:writeCounted([BII)V",
                                    "method_body": "public void writeCounted(final byte[] data, final int offset, final int length) throws IOException {\nwriteOut(data, offset, length);\nwrittenToOutputStreamForLastEntry += length;\ntotalWrittenToOutputStream += length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor$OutputStreamCompressor:<init>(Ljava/util/zip/Deflater;Ljava/io/OutputStream;)V",
                                    "method_body": "public OutputStreamCompressor(final Deflater deflater, final OutputStream os) {\nsuper(deflater);\nthis.os = os;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor$OutputStreamCompressor:writeOut([BII)V",
                                    "method_body": "protected final void writeOut(final byte[] data, final int offset, final int length)\nthrows IOException {\nos.write(data, offset, length);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
                                    "method_body": "public JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
                                    "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\n\n/** No-arg constructor */\npublic JarMarker() {\n// empty\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (final int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<clinit>()V",
                                    "method_body": "public static final ZipShort ZERO = new ZipShort(0);\n\nprivate static final long serialVersionUID = 1L;\n\nprivate final int value;\n\n/**\n* Create instance from a number.\n* @param value the int to store as a ZipShort\n*/\npublic ZipShort (final int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes(I)[B",
                                    "method_body": "public static byte[] getBytes(final int value) {\nfinal byte[] result = new byte[2];\nputShort(value, result, 0);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:putShort(I[BI)V",
                                    "method_body": "public static void putShort(final int value, final byte[] buf, final int offset) {\nByteUtils.toLittleEndian(buf, value, offset, 2);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([BI)I",
                                    "method_body": "public static int getValue(final byte[] bytes, final int offset) {\nreturn (int) ByteUtils.fromLittleEndian(bytes, offset, 2);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([B)I",
                                    "method_body": "public static int getValue(final byte[] bytes) {\nreturn getValue(bytes, 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
                                    "method_body": "private static final int WORD = 4;\n\n/**\n* Static registry of known extra fields.\n*/\nprivate static final Map<ZipShort, Class<?>> implementations;\n\nstatic {\nimplementations = new ConcurrentHashMap<>();\nregister(AsiExtraField.class);\nregister(X5455_ExtendedTimestamp.class);\nregister(X7875_NewUnix.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\nregister(Zip64ExtendedInformationExtraField.class);\nregister(X000A_NTFS.class);\nregister(X0014_X509Certificates.class);\nregister(X0015_CertificateIdForFile.class);\nregister(X0016_CertificateIdForCentralDirectory.class);\nregister(X0017_StrongEncryptionHeader.class);\nregister(X0019_EncryptionRecipientCertificateList.class);\nregister(ResourceAlignmentExtraField.class);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
                                    "method_body": "public static void register(final Class<?> c) {\ntry {\nfinal ZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n} catch (final ClassCastException cc) {\nthrow new RuntimeException(c + \" doesn\\'t implement ZipExtraField\"); //NOSONAR\n} catch (final InstantiationException ie) {\nthrow new RuntimeException(c + \" is not a concrete class\"); //NOSONAR\n} catch (final IllegalAccessException ie) {\nthrow new RuntimeException(c + \"\\'s no-arg constructor is not public\"); //NOSONAR\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:parse([BZLorg/apache/commons/compress/archivers/zip/ExtraFieldUtils$UnparseableExtraField;)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
                                    "method_body": "public static ZipExtraField[] parse(final byte[] data, final boolean local,\nfinal UnparseableExtraField onUnparseableData)\nthrows ZipException {\nfinal List<ZipExtraField> v = new ArrayList<>();\nint start = 0;\nLOOP:\nwhile (start <= data.length - WORD) {\nfinal ZipShort headerId = new ZipShort(data, start);\nfinal int length = new ZipShort(data, start + 2).getValue();\nif (start + WORD + length > data.length) {\nswitch(onUnparseableData.getKey()) {\ncase UnparseableExtraField.THROW_KEY:\nthrow new ZipException(\"bad extra field starting at \"\n+ start + \".  Block length of \"\n+ length + \" bytes exceeds remaining\"\n+ \" data of \"\n+ (data.length - start - WORD)\n+ \" bytes.\");\ncase UnparseableExtraField.READ_KEY:\nfinal UnparseableExtraFieldData field =\nnew UnparseableExtraFieldData();\nif (local) {\nfield.parseFromLocalFileData(data, start,\ndata.length - start);\n} else {\nfield.parseFromCentralDirectoryData(data, start,\ndata.length - start);\n}\nv.add(field);\n//$FALL-THROUGH$\ncase UnparseableExtraField.SKIP_KEY:\n// since we cannot parse the data we must assume\n// the extra field consumes the whole rest of the\n// available data\nbreak LOOP;\ndefault:\nthrow new ZipException(\"unknown UnparseableExtraField key: \"\n+ onUnparseableData.getKey());\n}\n}\ntry {\nfinal ZipExtraField ze = createExtraField(headerId);\nif (local) {\nze.parseFromLocalFileData(data, start + WORD, length);\n} else {\nze.parseFromCentralDirectoryData(data, start + WORD,\nlength);\n}\nv.add(ze);\n} catch (final InstantiationException | IllegalAccessException ie) {\nthrow (ZipException) new ZipException(ie.getMessage()).initCause(ie);\n}\nstart += length + WORD;\n}\n\nfinal ZipExtraField[] result = new ZipExtraField[v.size()];\nreturn v.toArray(result);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data) {\nfinal boolean lastIsUnparseableHolder = data.length > 0\n&& data[data.length - 1] instanceof UnparseableExtraFieldData;\nfinal int regularExtraFieldCount =\nlastIsUnparseableHolder ? data.length - 1 : data.length;\n\nint sum = WORD * regularExtraFieldCount;\nfor (final ZipExtraField element : data) {\nsum += element.getLocalFileDataLength().getValue();\n}\n\nfinal byte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n0, result, start + 2, 2);\nstart += WORD;\nfinal byte[] local = data[i].getLocalFileDataData();\nif (local != null) {\nSystem.arraycopy(local, 0, result, start, local.length);\nstart += local.length;\n}\n}\nif (lastIsUnparseableHolder) {\nfinal byte[] local = data[data.length - 1].getLocalFileDataData();\nif (local != null) {\nSystem.arraycopy(local, 0, result, start, local.length);\n}\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeCentralDirectoryData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
                                    "method_body": "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data) {\nfinal boolean lastIsUnparseableHolder = data.length > 0\n&& data[data.length - 1] instanceof UnparseableExtraFieldData;\nfinal int regularExtraFieldCount =\nlastIsUnparseableHolder ? data.length - 1 : data.length;\n\nint sum = WORD * regularExtraFieldCount;\nfor (final ZipExtraField element : data) {\nsum += element.getCentralDirectoryLength().getValue();\n}\nfinal byte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n0, result, start + 2, 2);\nstart += WORD;\nfinal byte[] local = data[i].getCentralDirectoryData();\nif (local != null) {\nSystem.arraycopy(local, 0, result, start, local.length);\nstart += local.length;\n}\n}\nif (lastIsUnparseableHolder) {\nfinal byte[] local = data[data.length - 1].getCentralDirectoryData();\nif (local != null) {\nSystem.arraycopy(local, 0, result, start, local.length);\n}\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
                                    "method_body": "public AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate static final int      WORD = 4;\n/**\n* Standard Unix stat(2) file mode.\n*/\nprivate int mode = 0;\n/**\n* User ID.\n*/\nprivate int uid = 0;\n/**\n* Group ID.\n*/\nprivate int gid = 0;\n/**\n* File this entry points to, if it is a symbolic link.\n*\n* <p>empty string - if entry is not a symbolic link.</p>\n*/\nprivate String link = \"\";\n/**\n* Is this an entry for a directory?\n*/\nprivate boolean dirFlag = false;\n\n/**\n* Instance used to calculate checksums.\n*/\nprivate CRC32 crc = new CRC32();\n\n/** Constructor for AsiExtraField. */\npublic AsiExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<init>()V",
                                    "method_body": "public X5455_ExtendedTimestamp() {}\npublic X5455_ExtendedTimestamp() {}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x5455);\nprivate static final long serialVersionUID = 1L;\n\n/**\n* The bit set inside the flags by when the last modification time\n* is present in this extra field.\n*/\npublic static final byte MODIFY_TIME_BIT = 1;\n/**\n* The bit set inside the flags by when the lasr access time is\n* present in this extra field.\n*/\npublic static final byte ACCESS_TIME_BIT = 2;\n/**\n* The bit set inside the flags by when the original creation time\n* is present in this extra field.\n*/\npublic static final byte CREATE_TIME_BIT = 4;\n\n// The 3 boolean fields (below) come from this flags byte.  The remaining 5 bits\n// are ignored according to the current version of the spec (December 2012).\nprivate byte flags;\n\n// Note: even if bit1 and bit2 are set, the Central data will still not contain\n// access/create fields:  only local data ever holds those!  This causes\n// some of our implementation to look a little odd, with seemingly spurious\n// != null and length checks.\nprivate boolean bit0_modifyTimePresent;\nprivate boolean bit1_accessTimePresent;\nprivate boolean bit2_createTimePresent;\n\nprivate ZipLong modifyTime;\nprivate ZipLong accessTime;\nprivate ZipLong createTime;\n\n/**\n* Constructor for X5455_ExtendedTimestamp.\n*/\npublic X5455_ExtendedTimestamp() {}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<init>()V",
                                    "method_body": "public X7875_NewUnix() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x7875);\nprivate static final ZipShort ZERO = new ZipShort(0);\nprivate static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);\nprivate static final long serialVersionUID = 1L;\n\nprivate int version = 1; // always '1' according to current info-zip spec.\n\n// BigInteger helps us with little-endian / big-endian conversions.\n// (thanks to BigInteger.toByteArray() and a reverse() method we created).\n// Also, the spec theoretically allows UID/GID up to 255 bytes long!\n//\n// NOTE:  equals() and hashCode() currently assume these can never be null.\nprivate BigInteger uid;\nprivate BigInteger gid;\n\n/**\n* Constructor for X7875_NewUnix.\n*/\npublic X7875_NewUnix() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:reset()V",
                                    "method_body": "private void reset() {\n// Typical UID/GID of the first non-root user created on a unix system.\nuid = ONE_THOUSAND;\ngid = ONE_THOUSAND;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
                                    "method_body": "protected AbstractUnicodeExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
                                    "method_body": "public UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\n\npublic UnicodePathExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
                                    "method_body": "public UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\n\npublic UnicodeCommentExtraField () {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<init>()V",
                                    "method_body": "public Zip64ExtendedInformationExtraField() { }\npublic Zip64ExtendedInformationExtraField() { }"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<clinit>()V",
                                    "method_body": "static final ZipShort HEADER_ID = new ZipShort(0x0001);\n\nprivate static final String LFH_MUST_HAVE_BOTH_SIZES_MSG =\n\"Zip64 extended information must contain\"\n+ \" both size values in the local file header.\";\nprivate static final byte[] EMPTY = new byte[0];\n\nprivate ZipEightByteInteger size, compressedSize, relativeHeaderOffset;\nprivate ZipLong diskStart;\n\n/**\n* Stored in {@link #parseFromCentralDirectoryData\n* parseFromCentralDirectoryData} so it can be reused when ZipFile"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X000A_NTFS:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x000a);\nprivate static final ZipShort TIME_ATTR_TAG = new ZipShort(0x0001);\nprivate static final ZipShort TIME_ATTR_SIZE = new ZipShort(3 * 8);\n\nprivate ZipEightByteInteger modifyTime = ZipEightByteInteger.ZERO;\nprivate ZipEightByteInteger accessTime = ZipEightByteInteger.ZERO;\nprivate ZipEightByteInteger createTime = ZipEightByteInteger.ZERO;\n\n/**\n* The Header-ID.\n*\n* @return the value for the header id for this extrafield\n*/\n@Override\npublic ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X000A_NTFS:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<init>(J)V",
                                    "method_body": "public ZipEightByteInteger(final long value) {\nthis(BigInteger.valueOf(value));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<init>(Ljava/math/BigInteger;)V",
                                    "method_body": "public ZipEightByteInteger(final BigInteger value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate static final int BYTE_4 = 4;\nprivate static final long BYTE_4_MASK = 0xFF00000000L;\nprivate static final int BYTE_4_SHIFT = 32;\n\nprivate static final int BYTE_5 = 5;\nprivate static final long BYTE_5_MASK = 0xFF0000000000L;\nprivate static final int BYTE_5_SHIFT = 40;\n\nprivate static final int BYTE_6 = 6;\nprivate static final long BYTE_6_MASK = 0xFF000000000000L;\nprivate static final int BYTE_6_SHIFT = 48;\n\nprivate static final int BYTE_7 = 7;\nprivate static final long BYTE_7_MASK = 0x7F00000000000000L;\nprivate static final int BYTE_7_SHIFT = 56;\n\nprivate static final int LEFTMOST_BIT_SHIFT = 63;\nprivate static final byte LEFTMOST_BIT = (byte) 0x80;\n\nprivate final BigInteger value;\n\npublic static final ZipEightByteInteger ZERO = new ZipEightByteInteger(0);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipEightByteInteger\n*/\npublic ZipEightByteInteger(final long value) {\nthis(BigInteger.valueOf(value));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.PKWareExtraHeader:<init>(Lorg/apache/commons/compress/archivers/zip/ZipShort;)V",
                                    "method_body": "protected PKWareExtraHeader(final ZipShort headerId) {\nthis.headerId = headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.PKWareExtraHeader:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn headerId;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0014_X509Certificates:<init>()V",
                                    "method_body": "public X0014_X509Certificates() {\nsuper(new ZipShort(0x0014));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0015_CertificateIdForFile:<init>()V",
                                    "method_body": "public X0015_CertificateIdForFile() {\nsuper(new ZipShort(0x0015));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0016_CertificateIdForCentralDirectory:<init>()V",
                                    "method_body": "public X0016_CertificateIdForCentralDirectory() {\nsuper(new ZipShort(0x0016));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0017_StrongEncryptionHeader:<init>()V",
                                    "method_body": "public X0017_StrongEncryptionHeader() {\nsuper(new ZipShort(0x0017));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X0019_EncryptionRecipientCertificateList:<init>()V",
                                    "method_body": "public X0019_EncryptionRecipientCertificateList() {\nsuper(new ZipShort(0x0019));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ResourceAlignmentExtraField:<init>()V",
                                    "method_body": "public ResourceAlignmentExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ResourceAlignmentExtraField:<clinit>()V",
                                    "method_body": "public static final ZipShort ID = new ZipShort(0xa11e);\n\npublic static final int BASE_SIZE = 2;\n\nprivate static final int ALLOW_METHOD_MESSAGE_CHANGE_FLAG = 0x8000;\n\nprivate short alignment;\n\nprivate boolean allowMethodChange;\n\nprivate int padding = 0;\n\npublic ResourceAlignmentExtraField() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ResourceAlignmentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
                                    "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$CurrentEntry:<init>(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "private CurrentEntry(final ZipArchiveEntry entry) {\nthis.entry = entry;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n\n/**\n* Convert a Date object to a DOS date/time field.\n* @param time the <code>Date</code> to convert\n* @return the date as a <code>ZipLong</code>\n*/\npublic static ZipLong toDosTime(final Date time) {\nreturn new ZipLong(toDosTime(time.getTime()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(Ljava/util/Calendar;J[BI)V",
                                    "method_body": "static void toDosTime(final Calendar c, final long t, final byte[] buf, final int offset) {\nc.setTimeInMillis(t);\n\nfinal int year = c.get(Calendar.YEAR);\nif (year < 1980) {\nSystem.arraycopy(DOS_TIME_MIN, 0, buf, offset, DOS_TIME_MIN.length);// stop callers from changing the array\nreturn;\n}\nfinal int month = c.get(Calendar.MONTH) + 1;\nfinal long value =  ((year - 1980) << 25)\n|         (month << 21)\n|         (c.get(Calendar.DAY_OF_MONTH) << 16)\n|         (c.get(Calendar.HOUR_OF_DAY) << 11)\n|         (c.get(Calendar.MINUTE) << 5)\n|         (c.get(Calendar.SECOND) >> 1);\nZipLong.putLong(value, buf, offset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:dosToJavaTime(J)J",
                                    "method_body": "public static long dosToJavaTime(final long dosTime) {\nfinal Calendar cal = Calendar.getInstance();\n// CheckStyle:MagicNumberCheck OFF - no point\ncal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\ncal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\ncal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);\ncal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);\ncal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);\ncal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);\ncal.set(Calendar.MILLISECOND, 0);\n// CheckStyle:MagicNumberCheck ON\nreturn cal.getTime().getTime();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:supportsEncryptionOf(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private static boolean supportsEncryptionOf(final ZipArchiveEntry entry) {\nreturn !entry.getGeneralPurposeBit().usesEncryption();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:supportsMethodOf(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private static boolean supportsMethodOf(final ZipArchiveEntry entry) {\nreturn entry.getMethod() == ZipEntry.STORED\n|| entry.getMethod() == ZipMethod.UNSHRINKING.getCode()\n|| entry.getMethod() == ZipMethod.IMPLODING.getCode()\n|| entry.getMethod() == ZipEntry.DEFLATED\n|| entry.getMethod() == ZipMethod.BZIP2.getCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:checkRequestedFeatures(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
                                    "method_body": "static void checkRequestedFeatures(final ZipArchiveEntry ze)\nthrows UnsupportedZipFeatureException {\nif (!supportsEncryptionOf(ze)) {\nthrow\nnew UnsupportedZipFeatureException(UnsupportedZipFeatureException\n.Feature.ENCRYPTION, ze);\n}\nif (!supportsMethodOf(ze)) {\nfinal ZipMethod m = ZipMethod.getMethodByCode(ze.getMethod());\nif (m == null) {\nthrow\nnew UnsupportedZipFeatureException(UnsupportedZipFeatureException\n.Feature.METHOD, ze);\n}\nthrow new UnsupportedZipFeatureException(m, ze);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$EntryMetaData:<init>(JZ)V",
                                    "method_body": "private EntryMetaData(long offset, boolean usesDataDescriptor) {\nthis.offset = offset;\nthis.usesDataDescriptor = usesDataDescriptor;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:<init>(Ljava/lang/String;I)V",
                                    "method_body": "private ZipMethod() {\nthis(UNKNOWN_CODE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:<init>(Ljava/lang/String;II)V",
                                    "method_body": "ZipMethod(final int code) {\nthis.code = code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:getCode()I",
                                    "method_body": "public int getCode() {\nreturn code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:<clinit>()V",
                                    "method_body": "private static final int COPY_BUF_SIZE = 8024;\nprivate static final int SKIP_BUF_SIZE = 4096;\n\n// This buffer does not need to be synchronised because it is write only; the contents are ignored\n// Does not affect Immutability\nprivate static final byte[] SKIP_BUF = new byte[SKIP_BUF_SIZE];\n\n/** Private constructor to prevent instantiation of this utility class. */\nprivate IOUtils(){\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/nio/channels/ReadableByteChannel;Ljava/nio/ByteBuffer;)V",
                                    "method_body": "public static void readFully(ReadableByteChannel channel, ByteBuffer b) throws IOException {\nfinal int expectedLength = b.remaining();\nint read = 0;\nwhile (read < expectedLength) {\nint readNow = channel.read(b);\nif (readNow <= 0) {\nbreak;\n}\nread += readNow;\n}\nif (read < expectedLength) {\nthrow new EOFException();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<init>(I)V",
                                    "method_body": "private UnparseableExtraField(final int k) {\nkey = k;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<clinit>()V",
                                    "method_body": "public static final int THROW_KEY = 0;\n/**\n* Key for \"skip\" action.\n*/\npublic static final int SKIP_KEY = 1;\n/**\n* Key for \"read\" action.\n*/\npublic static final int READ_KEY = 2;\n\n/**\n* Throw an exception if field cannot be parsed.\n*/\npublic static final UnparseableExtraField THROW\n= new UnparseableExtraField(THROW_KEY);\n\n/**\n* Skip the extra field entirely and don't make its data\n* available - effectively removing the extra field data.\n*/\npublic static final UnparseableExtraField SKIP\n= new UnparseableExtraField(SKIP_KEY);\n\n/**\n* Read the extra field data into an instance of {@link\n* UnparseableExtraFieldData UnparseableExtraFieldData}."
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;)V",
                                    "method_body": "public ZipFile(final File f) throws IOException {\nthis(f, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;)V",
                                    "method_body": "public ZipFile(final File f, final String encoding) throws IOException {\nthis(f, encoding, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipFile(final File f, final String encoding, final boolean useUnicodeExtraFields)\nthrows IOException {\nthis(Files.newByteChannel(f.toPath(), EnumSet.of(StandardOpenOption.READ)),\nf.getAbsolutePath(), encoding, useUnicodeExtraFields, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/nio/channels/SeekableByteChannel;Ljava/lang/String;Ljava/lang/String;ZZ)V",
                                    "method_body": "private ZipFile(final SeekableByteChannel channel, final String archiveName,\nfinal String encoding, final boolean useUnicodeExtraFields,\nfinal boolean closeOnError)\nthrows IOException {\nthis.archiveName = archiveName;\nthis.encoding = encoding;\nthis.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\narchive = channel;\nboolean success = false;\ntry {\nfinal Map<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag =\npopulateFromCentralDirectory();\nresolveLocalFileHeaderData(entriesWithoutUTF8Flag);\nsuccess = true;\n} finally {\nclosed = !success;\nif (!success && closeOnError) {\nIOUtils.closeQuietly(archive);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<clinit>()V",
                                    "method_body": "private static final int CFH_LEN =\n/* version made by                 */ SHORT\n/* version needed to extract       */ + SHORT\n/* general purpose bit flag        */ + SHORT\n/* compression method              */ + SHORT\n/* last mod file time              */ + SHORT\n/* last mod file date              */ + SHORT\n/* crc-32                          */ + WORD\n/* compressed size                 */ + WORD\n/* uncompressed size               */ + WORD\n/* filename length                 */ + SHORT\n/* extra field length              */ + SHORT\n/* file comment length             */ + SHORT\n/* disk number start               */ + SHORT\n/* internal file attributes        */ + SHORT\n/* external file attributes        */ + WORD\n/* relative offset of local header */ + WORD;\n\nprivate static final long CFH_SIG =\nZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n\n/**\n* Reads the central directory of the given archive and populates\n* the internal tables with ZipArchiveEntry instances.\n*\n* <p>The ZipArchiveEntrys will know all data that can be obtained from\n* the central directory alone, but not the data that requires the\n* local file header or additional data to be read.</p>\n*\n* @return a map of zipentries that didn't have the language\n* encoding flag set when read.\n*/\nprivate Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory()\nthrows IOException {\nfinal HashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\nnew HashMap<>();\n\npositionAtCentralDirectory();\n\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nlong sig = ZipLong.getValue(wordBuf);\n\nif (sig != CFH_SIG && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n+ \" corrupt archive.\");\n}\n\nwhile (sig == CFH_SIG) {\nreadCentralDirectoryEntry(noUTF8Flag);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nsig = ZipLong.getValue(wordBuf);\n}\nreturn noUTF8Flag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:close()V",
                                    "method_body": "public void close() throws IOException {\n// this flag is only written here and read in finalize() which\n// can never be run in parallel.\n// no synchronization needed.\nclosed = true;\n\narchive.close();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:getEntry(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;",
                                    "method_body": "public ZipArchiveEntry getEntry(final String name) {\nfinal LinkedList<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\nreturn entriesOfThatName != null ? entriesOfThatName.getFirst() : null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:getRawInputStream(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Ljava/io/InputStream;",
                                    "method_body": "public InputStream getRawInputStream(final ZipArchiveEntry ze) {\nif (!(ze instanceof Entry)) {\nreturn null;\n}\nfinal long start = ze.getDataOffset();\nreturn createBoundedInputStream(start, ze.getCompressedSize());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:populateFromCentralDirectory()Ljava/util/Map;",
                                    "method_body": "private Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory()\nthrows IOException {\nfinal HashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\nnew HashMap<>();\n\npositionAtCentralDirectory();\n\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nlong sig = ZipLong.getValue(wordBuf);\n\nif (sig != CFH_SIG && startsWithLocalFileHeader()) {\nthrow new IOException(\"central directory is empty, can't expand\"\n+ \" corrupt archive.\");\n}\n\nwhile (sig == CFH_SIG) {\nreadCentralDirectoryEntry(noUTF8Flag);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nsig = ZipLong.getValue(wordBuf);\n}\nreturn noUTF8Flag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:readCentralDirectoryEntry(Ljava/util/Map;)V",
                                    "method_body": "private void\nreadCentralDirectoryEntry(final Map<ZipArchiveEntry, NameAndComment> noUTF8Flag)\nthrows IOException {\ncfhBbuf.rewind();\nIOUtils.readFully(archive, cfhBbuf);\nint off = 0;\nfinal Entry ze = new Entry();\n\nfinal int versionMadeBy = ZipShort.getValue(cfhBuf, off);\noff += SHORT;\nze.setVersionMadeBy(versionMadeBy);\nze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\nze.setVersionRequired(ZipShort.getValue(cfhBuf, off));\noff += SHORT; // version required\n\nfinal GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(cfhBuf, off);\nfinal boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\nfinal ZipEncoding entryEncoding =\nhasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\nze.setGeneralPurposeBit(gpFlag);\nze.setRawFlag(ZipShort.getValue(cfhBuf, off));\n\noff += SHORT;\n\n//noinspection MagicConstant\nze.setMethod(ZipShort.getValue(cfhBuf, off));\noff += SHORT;\n\nfinal long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfhBuf, off));\nze.setTime(time);\noff += WORD;\n\nze.setCrc(ZipLong.getValue(cfhBuf, off));\noff += WORD;\n\nze.setCompressedSize(ZipLong.getValue(cfhBuf, off));\noff += WORD;\n\nze.setSize(ZipLong.getValue(cfhBuf, off));\noff += WORD;\n\nfinal int fileNameLen = ZipShort.getValue(cfhBuf, off);\noff += SHORT;\n\nfinal int extraLen = ZipShort.getValue(cfhBuf, off);\noff += SHORT;\n\nfinal int commentLen = ZipShort.getValue(cfhBuf, off);\noff += SHORT;\n\nfinal int diskStart = ZipShort.getValue(cfhBuf, off);\noff += SHORT;\n\nze.setInternalAttributes(ZipShort.getValue(cfhBuf, off));\noff += SHORT;\n\nze.setExternalAttributes(ZipLong.getValue(cfhBuf, off));\noff += WORD;\n\nfinal byte[] fileName = new byte[fileNameLen];\nIOUtils.readFully(archive, ByteBuffer.wrap(fileName));\nze.setName(entryEncoding.decode(fileName), fileName);\n\n// LFH offset,\nze.setLocalHeaderOffset(ZipLong.getValue(cfhBuf, off));\n// data offset will be filled later\nentries.add(ze);\n\nfinal byte[] cdExtraData = new byte[extraLen];\nIOUtils.readFully(archive, ByteBuffer.wrap(cdExtraData));\nze.setCentralDirectoryExtra(cdExtraData);\n\nsetSizesAndOffsetFromZip64Extra(ze, diskStart);\n\nfinal byte[] comment = new byte[commentLen];\nIOUtils.readFully(archive, ByteBuffer.wrap(comment));\nze.setComment(entryEncoding.decode(comment));\n\nif (!hasUTF8Flag && useUnicodeExtraFields) {\nnoUTF8Flag.put(ze, new NameAndComment(fileName, comment));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:setSizesAndOffsetFromZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;I)V",
                                    "method_body": "private void setSizesAndOffsetFromZip64Extra(final ZipArchiveEntry ze,\nfinal int diskStart)\nthrows IOException {\nfinal Zip64ExtendedInformationExtraField z64 =\n(Zip64ExtendedInformationExtraField)\nze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\nif (z64 != null) {\nfinal boolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\nfinal boolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\nfinal boolean hasRelativeHeaderOffset =\nze.getLocalHeaderOffset() == ZIP64_MAGIC;\nz64.reparseCentralDirectoryData(hasUncompressedSize,\nhasCompressedSize,\nhasRelativeHeaderOffset,\ndiskStart == ZIP64_MAGIC_SHORT);\n\nif (hasUncompressedSize) {\nze.setSize(z64.getSize().getLongValue());\n} else if (hasCompressedSize) {\nz64.setSize(new ZipEightByteInteger(ze.getSize()));\n}\n\nif (hasCompressedSize) {\nze.setCompressedSize(z64.getCompressedSize().getLongValue());\n} else if (hasUncompressedSize) {\nz64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));\n}\n\nif (hasRelativeHeaderOffset) {\nze.setLocalHeaderOffset(z64.getRelativeHeaderOffset().getLongValue());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory()V",
                                    "method_body": "private void positionAtCentralDirectory()\nthrows IOException {\npositionAtEndOfCentralDirectoryRecord();\nboolean found = false;\nfinal boolean searchedForZip64EOCD =\narchive.position() > ZIP64_EOCDL_LENGTH;\nif (searchedForZip64EOCD) {\narchive.position(archive.position() - ZIP64_EOCDL_LENGTH);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nfound = Arrays.equals(ZipArchiveOutputStream.ZIP64_EOCD_LOC_SIG,\nwordBuf);\n}\nif (!found) {\n// not a ZIP64 archive\nif (searchedForZip64EOCD) {\nskipBytes(ZIP64_EOCDL_LENGTH - WORD);\n}\npositionAtCentralDirectory32();\n} else {\npositionAtCentralDirectory64();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtCentralDirectory32()V",
                                    "method_body": "private void positionAtCentralDirectory32()\nthrows IOException {\nskipBytes(CFD_LOCATOR_OFFSET);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\narchive.position(ZipLong.getValue(wordBuf));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:positionAtEndOfCentralDirectoryRecord()V",
                                    "method_body": "private void positionAtEndOfCentralDirectoryRecord()\nthrows IOException {\nfinal boolean found = tryToLocateSignature(MIN_EOCD_SIZE, MAX_EOCD_SIZE,\nZipArchiveOutputStream.EOCD_SIG);\nif (!found) {\nthrow new ZipException(\"archive is not a ZIP archive\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:tryToLocateSignature(JJ[B)Z",
                                    "method_body": "private boolean tryToLocateSignature(final long minDistanceFromEnd,\nfinal long maxDistanceFromEnd,\nfinal byte[] sig) throws IOException {\nboolean found = false;\nlong off = archive.size() - minDistanceFromEnd;\nfinal long stopSearching =\nMath.max(0L, archive.size() - maxDistanceFromEnd);\nif (off >= 0) {\nfor (; off >= stopSearching; off--) {\narchive.position(off);\ntry {\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nwordBbuf.flip();\n} catch (EOFException ex) {\nbreak;\n}\nint curr = wordBbuf.get();\nif (curr == sig[POS_0]) {\ncurr = wordBbuf.get();\nif (curr == sig[POS_1]) {\ncurr = wordBbuf.get();\nif (curr == sig[POS_2]) {\ncurr = wordBbuf.get();\nif (curr == sig[POS_3]) {\nfound = true;\nbreak;\n}\n}\n}\n}\n}\n}\nif (found) {\narchive.position(off);\n}\nreturn found;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:skipBytes(I)V",
                                    "method_body": "private void skipBytes(final int count) throws IOException {\nlong currentPosition = archive.position();\nlong newPosition = currentPosition + count;\nif (newPosition > archive.size()) {\nthrow new EOFException();\n}\narchive.position(newPosition);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:resolveLocalFileHeaderData(Ljava/util/Map;)V",
                                    "method_body": "private void resolveLocalFileHeaderData(final Map<ZipArchiveEntry, NameAndComment>\nentriesWithoutUTF8Flag)\nthrows IOException {\nfor (final ZipArchiveEntry zipArchiveEntry : entries) {\n// entries is filled in populateFromCentralDirectory and\n// never modified\nfinal Entry ze = (Entry) zipArchiveEntry;\nfinal long offset = ze.getLocalHeaderOffset();\narchive.position(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\nwordBbuf.rewind();\nIOUtils.readFully(archive, wordBbuf);\nwordBbuf.flip();\nwordBbuf.get(shortBuf);\nfinal int fileNameLen = ZipShort.getValue(shortBuf);\nwordBbuf.get(shortBuf);\nfinal int extraFieldLen = ZipShort.getValue(shortBuf);\nskipBytes(fileNameLen);\nfinal byte[] localExtraData = new byte[extraFieldLen];\nIOUtils.readFully(archive, ByteBuffer.wrap(localExtraData));\nze.setExtra(localExtraData);\nze.setDataOffset(offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n+ SHORT + SHORT + fileNameLen + extraFieldLen);\nze.setStreamContiguous(true);\n\nif (entriesWithoutUTF8Flag.containsKey(ze)) {\nfinal NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\nZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\nnc.comment);\n}\n\nfinal String name = ze.getName();\nLinkedList<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\nif (entriesOfThatName == null) {\nentriesOfThatName = new LinkedList<>();\nnameMap.put(name, entriesOfThatName);\n}\nentriesOfThatName.addLast(ze);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:createBoundedInputStream(JJ)Lorg/apache/commons/compress/archivers/zip/ZipFile$BoundedInputStream;",
                                    "method_body": "private BoundedInputStream createBoundedInputStream(long start, long remaining) {\nreturn archive instanceof FileChannel ?\nnew BoundedFileChannelInputStream(start, remaining) :\nnew BoundedInputStream(start, remaining);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$Entry:<init>()V",
                                    "method_body": "Entry() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$Entry:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn 3 * super.hashCode()\n+ (int) getLocalHeaderOffset()+(int)(getLocalHeaderOffset()>>32);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$BoundedInputStream:<init>(Lorg/apache/commons/compress/archivers/zip/ZipFile;JJ)V",
                                    "method_body": "BoundedInputStream(final long start, final long remaining) {\nthis.end = start+remaining;\nif (this.end < start) {\n// check for potential vulnerability due to overflow\nthrow new IllegalArgumentException(\"Invalid length of stream at offset=\"+start+\", length=\"+remaining);\n}\nloc = start;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$BoundedInputStream:read([BII)I",
                                    "method_body": "public synchronized int read(final byte[] b, final int off, int len) throws IOException {\nif (len <= 0) {\nreturn 0;\n}\n\nif (len > end-loc) {\nif (loc >= end) {\nif (loc == end && addDummy) {\naddDummy = false;\nb[off] = 0;\nreturn 1;\n}\nreturn -1;\n}\nlen = (int)(end-loc);\n}\n\nByteBuffer buf;\nbuf = ByteBuffer.wrap(b, off, len);\nint ret = read(loc, buf);\nif (ret > 0) {\nloc += ret;\nreturn ret;\n}\nreturn ret;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$BoundedFileChannelInputStream:<init>(Lorg/apache/commons/compress/archivers/zip/ZipFile;JJ)V",
                                    "method_body": "BoundedFileChannelInputStream(final long start, final long remaining) {\nsuper(start, remaining);\narchive = (FileChannel)ZipFile.this.archive;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$BoundedFileChannelInputStream:read(JLjava/nio/ByteBuffer;)I",
                                    "method_body": "protected int read(long pos, ByteBuffer buf) throws IOException {\nint read = archive.read(buf, pos);\nbuf.flip();\nreturn read;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 44,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest.testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
                            "test_body": "120: public void testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo() {\n121: 122: ChecksumCalculatingInputStream checksumCalculatingInputStream = new ChecksumCalculatingInputStream(null,new ByteArrayInputStream(new byte[1]));\n123: 124: 125: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumCalculatingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;)V",
                                    "method_body": "public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n\n\n\nthis.checksum = checksum;\nthis.in = in;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest.testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree",
                            "test_body": "129: public void testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree() {\n130: 131: ChecksumCalculatingInputStream checksumCalculatingInputStream = new ChecksumCalculatingInputStream(new CRC32(),null);\n132: 133: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumCalculatingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;)V",
                                    "method_body": "public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n\n\n\nthis.checksum = checksum;\nthis.in = in;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest.testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
                            "test_body": "111: public void testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne() {\n112: 113: ChecksumCalculatingInputStream checksumCalculatingInputStream = new ChecksumCalculatingInputStream(null,null);\n114: 115: 116: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ChecksumCalculatingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;)V",
                                    "method_body": "public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n\n\n\nthis.checksum = checksum;\nthis.in = in;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 45,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.tar.TarUtilsTest.testRoundTripOctalOrBinary8",
                            "test_body": "147: public void testRoundTripOctalOrBinary8() {\n148: testRoundTripOctalOrBinary(8);\n149: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n\nstatic {\nfinal Map<String, SimpleEncodingHolder> se =\nnew HashMap<>();\n\nfinal char[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nfinal SimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\n\nfinal char[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nfinal SimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(final String name) {\n\n// fallback encoding is good enough for UTF-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nfinal SimpleEncodingHolder h = simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nfinal Charset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (final UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\n// check platform's default encoding\ncharsetName = Charset.defaultCharset().name();\n}\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}\nfor (final String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
                                    "method_body": "SimpleEncodingHolder(final char [] highChars) {\nthis.highChars = highChars;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
                                    "method_body": "public FallbackZipEncoding(final String charsetName) {\nthis.charsetName = charsetName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\n\n/**\n* <p>\n* Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\n* (either order accepted on input, big-endian used on output)\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, big-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, little-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\n\n/**\n* <p>\n* Eight-bit Unicode Transformation Format.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:<clinit>()V",
                                    "method_body": "private static final int BYTE_MASK = 255;\n\nstatic final ZipEncoding DEFAULT_ENCODING =\nZipEncodingHelper.getZipEncoding(null);\n\n/**\n* Encapsulates the algorithms used up to Commons Compress 1.3 as\n* ZipEncoding.\n*/\nstatic final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\n@Override\npublic boolean canEncode(final String name) { return true; }\n\n@Override\npublic ByteBuffer encode(final String name) {\nfinal int length = name.length();\nfinal byte[] buf = new byte[length];\n\n// copy until end of input or output is reached.\nfor (int i = 0; i < length; ++i) {\nbuf[i] = (byte) name.charAt(i);\n}\nreturn ByteBuffer.wrap(buf);\n}\n\n@Override\npublic String decode(final byte[] buffer) {\nfinal int length = buffer.length;\nfinal StringBuilder result = new StringBuilder(length);\n\nfor (final byte b : buffer) {\nif (b == 0) { // Trailing null\nbreak;\n}\nresult.append((char) (b & 0xFF)); // Allow for sign-extension\n}\n\nreturn result.toString();\n}\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
                                    "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\n\nif (length < 2){\nthrow new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n}\n\nif (buffer[start] == 0) {\nreturn 0L;\n}\n\n// Skip leading spaces\nwhile (start < end){\nif (buffer[start] == ' '){\nstart++;\n} else {\nbreak;\n}\n}\n\n// Trim all trailing NULs and spaces.\n// The ustar and POSIX tar specs require a trailing NUL or\n// space but some implementations use the extra digit for big\n// sizes/uids/gids ...\nbyte trailer = buffer[end - 1];\nwhile (start < end && (trailer == 0 || trailer == ' ')) {\nend--;\ntrailer = buffer[end - 1];\n}\n\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\n// CheckStyle:MagicNumber OFF\nif (currentByte < '0' || currentByte > '7'){\nthrow new IllegalArgumentException(\nexceptionMessage(buffer, offset, length, start, currentByte));\n}\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\n// CheckStyle:MagicNumber ON\n}\n\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctalOrBinary([BII)J",
                                    "method_body": "public static long parseOctalOrBinary(final byte[] buffer, final int offset,\nfinal int length) {\n\nif ((buffer[offset] & 0x80) == 0) {\nreturn parseOctal(buffer, offset, length);\n}\nfinal boolean negative = buffer[offset] == (byte) 0xff;\nif (length < 9) {\nreturn parseBinaryLong(buffer, offset, length, negative);\n}\nreturn parseBinaryBigInteger(buffer, offset, length, negative);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseBinaryLong([BIIZ)J",
                                    "method_body": "private static long parseBinaryLong(final byte[] buffer, final int offset,\nfinal int length,\nfinal boolean negative) {\nif (length >= 9) {\nthrow new IllegalArgumentException(\"At offset \" + offset + \", \"\n+ length + \" byte binary number\"\n+ \" exceeds maximum signed long\"\n+ \" value\");\n}\nlong val = 0;\nfor (int i = 1; i < length; i++) {\nval = (val << 8) + (buffer[offset + i] & 0xff);\n}\nif (negative) {\n// 2's complement\nval--;\nval ^= (long) Math.pow(2.0, (length - 1) * 8.0) - 1;\n}\nreturn negative ? -val : val;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatUnsignedOctalString(J[BII)V",
                                    "method_body": "public static void formatUnsignedOctalString(final long value, final byte[] buffer,\nfinal int offset, final int length) {\nint remaining = length;\nremaining--;\nif (value == 0) {\nbuffer[offset + remaining--] = (byte) '0';\n} else {\nlong val = value;\nfor (; remaining >= 0 && val != 0; --remaining) {\n// CheckStyle:MagicNumber OFF\nbuffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));\nval = val >>> 3;\n// CheckStyle:MagicNumber ON\n}\nif (val != 0){\nthrow new IllegalArgumentException\n(value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length);\n}\n}\n\nfor (; remaining >= 0; --remaining) { // leading zeros\nbuffer[offset + remaining] = (byte) '0';\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatLongOctalBytes(J[BII)I",
                                    "method_body": "public static int formatLongOctalBytes(final long value, final byte[] buf, final int offset, final int length) {\n\nfinal int idx=length-1; // For space\n\nformatUnsignedOctalString(value, buf, offset, idx);\nbuf[offset + idx] = (byte) ' '; // Trailing space\n\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatLongOctalOrBinaryBytes(J[BII)I",
                                    "method_body": "public static int formatLongOctalOrBinaryBytes(\nfinal long value, final byte[] buf, final int offset, final int length) {\n\n// Check whether we are dealing with UID/GID or SIZE field\nfinal long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\nfinal boolean negative = value < 0;\nif (!negative && value <= maxAsOctalChar) { // OK to store as octal chars\nreturn formatLongOctalBytes(value, buf, offset, length);\n}\n\nif (length < 9) {\nformatLongBinary(value, buf, offset, length, negative);\n}\nformatBigIntegerBinary(value, buf, offset, length, negative);\n\nbuf[offset] = (byte) (negative ? 0xff : 0x80);\nreturn offset + length;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatLongBinary(J[BIIZ)V",
                                    "method_body": "private static void formatLongBinary(final long value, final byte[] buf,\nfinal int offset, final int length,\nfinal boolean negative) {\nfinal int bits = (length - 1) * 8;\nfinal long max = 1l << bits;\nlong val = Math.abs(value); // Long.MIN_VALUE stays Long.MIN_VALUE\nif (val < 0 || val >= max) {\nthrow new IllegalArgumentException(\"Value \" + value +\n\" is too large for \" + length + \" byte field.\");\n}\nif (negative) {\nval ^= max - 1;\nval++;\nval |= 0xffl << bits;\n}\nfor (int i = offset + length - 1; i >= offset; i--) {\nbuf[i] = (byte) val;\nval >>= 8;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatBigIntegerBinary(J[BIIZ)V",
                                    "method_body": "private static void formatBigIntegerBinary(final long value, final byte[] buf,\nfinal int offset,\nfinal int length,\nfinal boolean negative) {\nfinal BigInteger val = BigInteger.valueOf(value);\nfinal byte[] b = val.toByteArray();\nfinal int len = b.length;\nif (len > length - 1) {\nthrow new IllegalArgumentException(\"Value \" + value +\n\" is too large for \" + length + \" byte field.\");\n}\nfinal int off = offset + length - len;\nSystem.arraycopy(b, 0, buf, off, len);\nfinal byte fill = (byte) (negative ? 0xff : 0);\nfor (int i = offset + 1; i < off; i++) {\nbuf[i] = fill;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:finalize()V",
                                    "method_body": "protected void finalize() throws Throwable {\ntry {\nif (!closed) {\nSystem.err.println(\"Cleaning up unclosed ZipFile for archive \"\n+ archiveName);\nclose();\n}\n} finally {\nsuper.finalize();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:finalize()V",
                                    "method_body": "protected void finalize() throws Throwable {\nif (!closed) {\nSystem.err.println(\"Unclosed BZip2CompressorOutputStream detected, will *not* close it\");\n}\nsuper.finalize();\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 46,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestampTest.testGettersSetters",
                            "test_body": "200: public void testGettersSetters() {\n201: // X5455 is concerned with time, so let's\n202: // get a timestamp to play with (Jan 1st, 2000).\n203: final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n204: cal.set(Calendar.YEAR, 2000);\n205: cal.set(Calendar.MONTH, Calendar.JANUARY);\n206: cal.set(Calendar.DATE, 1);\n207: cal.set(Calendar.HOUR_OF_DAY, 0);\n208: cal.set(Calendar.MINUTE, 0);\n209: cal.set(Calendar.SECOND, 0);\n210: cal.set(Calendar.MILLISECOND, 0);\n211: final long timeMillis = cal.getTimeInMillis();\n212: final ZipLong time = new ZipLong(timeMillis / 1000);\n213: 214: // set too big\n215: try {\n216: // Java time is 1000 x larger (milliseconds).\n217: xf.setModifyJavaTime(new Date(1000L * (MAX_TIME_SECONDS.getValue() + 1L)));\n218: fail(\"Time too big for 32 bits!\");\n219: } catch (final IllegalArgumentException iae) {\n220: // All is good.\n221: }\n222: 223: // get/set modify time\n224: xf.setModifyTime(time);\n225: assertEquals(time, xf.getModifyTime());\n226: Date xfModifyJavaTime = xf.getModifyJavaTime();\n227: assertEquals(timeMillis, xfModifyJavaTime.getTime());\n228: xf.setModifyJavaTime(new Date(timeMillis));\n229: assertEquals(time, xf.getModifyTime());\n230: assertEquals(timeMillis, xf.getModifyJavaTime().getTime());\n231: // Make sure milliseconds get zeroed out:\n232: xf.setModifyJavaTime(new Date(timeMillis + 123));\n233: assertEquals(time, xf.getModifyTime());\n234: assertEquals(timeMillis, xf.getModifyJavaTime().getTime());\n235: // Null\n236: xf.setModifyTime(null);\n237: assertNull(xf.getModifyJavaTime());\n238: xf.setModifyJavaTime(null);\n239: assertNull(xf.getModifyTime());\n240: 241: // get/set access time\n242: xf.setAccessTime(time);\n243: assertEquals(time, xf.getAccessTime());\n244: assertEquals(timeMillis, xf.getAccessJavaTime().getTime());\n245: xf.setAccessJavaTime(new Date(timeMillis));\n246: assertEquals(time, xf.getAccessTime());\n247: assertEquals(timeMillis, xf.getAccessJavaTime().getTime());\n248: // Make sure milliseconds get zeroed out:\n249: xf.setAccessJavaTime(new Date(timeMillis + 123));\n250: assertEquals(time, xf.getAccessTime());\n251: assertEquals(timeMillis, xf.getAccessJavaTime().getTime());\n252: // Null\n253: xf.setAccessTime(null);\n254: assertNull(xf.getAccessJavaTime());\n255: xf.setAccessJavaTime(null);\n256: assertNull(xf.getAccessTime());\n257: 258: // get/set create time\n259: xf.setCreateTime(time);\n260: assertEquals(time, xf.getCreateTime());\n261: assertEquals(timeMillis, xf.getCreateJavaTime().getTime());\n262: xf.setCreateJavaTime(new Date(timeMillis));\n263: assertEquals(time, xf.getCreateTime());\n264: assertEquals(timeMillis, xf.getCreateJavaTime().getTime());\n265: // Make sure milliseconds get zeroed out:\n266: xf.setCreateJavaTime(new Date(timeMillis + 123));\n267: assertEquals(time, xf.getCreateTime());\n268: assertEquals(timeMillis, xf.getCreateJavaTime().getTime());\n269: // Null\n270: xf.setCreateTime(null);\n271: assertNull(xf.getCreateJavaTime());\n272: xf.setCreateJavaTime(null);\n273: assertNull(xf.getCreateTime());\n274: 275: 276: // initialize for flags\n277: xf.setModifyTime(time);\n278: xf.setAccessTime(time);\n279: xf.setCreateTime(time);\n280: 281: // get/set flags: 000\n282: xf.setFlags((byte) 0);\n283: assertEquals(0, xf.getFlags());\n284: assertFalse(xf.isBit0_modifyTimePresent());\n285: assertFalse(xf.isBit1_accessTimePresent());\n286: assertFalse(xf.isBit2_createTimePresent());\n287: // Local length=1, Central length=1 (flags only!)\n288: assertEquals(1, xf.getLocalFileDataLength().getValue());\n289: assertEquals(1, xf.getCentralDirectoryLength().getValue());\n290: 291: // get/set flags: 001\n292: xf.setFlags((byte) 1);\n293: assertEquals(1, xf.getFlags());\n294: assertTrue(xf.isBit0_modifyTimePresent());\n295: assertFalse(xf.isBit1_accessTimePresent());\n296: assertFalse(xf.isBit2_createTimePresent());\n297: // Local length=5, Central length=5 (flags + mod)\n298: assertEquals(5, xf.getLocalFileDataLength().getValue());\n299: assertEquals(5, xf.getCentralDirectoryLength().getValue());\n300: 301: // get/set flags: 010\n302: xf.setFlags((byte) 2);\n303: assertEquals(2, xf.getFlags());\n304: assertFalse(xf.isBit0_modifyTimePresent());\n305: assertTrue(xf.isBit1_accessTimePresent());\n306: assertFalse(xf.isBit2_createTimePresent());\n307: // Local length=5, Central length=1\n308: assertEquals(5, xf.getLocalFileDataLength().getValue());\n309: assertEquals(1, xf.getCentralDirectoryLength().getValue());\n310: 311: // get/set flags: 100\n312: xf.setFlags((byte) 4);\n313: assertEquals(4, xf.getFlags());\n314: assertFalse(xf.isBit0_modifyTimePresent());\n315: assertFalse(xf.isBit1_accessTimePresent());\n316: assertTrue(xf.isBit2_createTimePresent());\n317: // Local length=5, Central length=1\n318: assertEquals(5, xf.getLocalFileDataLength().getValue());\n319: assertEquals(1, xf.getCentralDirectoryLength().getValue());\n320: 321: // get/set flags: 111\n322: xf.setFlags((byte) 7);\n323: assertEquals(7, xf.getFlags());\n324: assertTrue(xf.isBit0_modifyTimePresent());\n325: assertTrue(xf.isBit1_accessTimePresent());\n326: assertTrue(xf.isBit2_createTimePresent());\n327: // Local length=13, Central length=5\n328: assertEquals(13, xf.getLocalFileDataLength().getValue());\n329: assertEquals(5, xf.getCentralDirectoryLength().getValue());\n330: 331: // get/set flags: 11111111\n332: xf.setFlags((byte) -1);\n333: assertEquals(-1, xf.getFlags());\n334: assertTrue(xf.isBit0_modifyTimePresent());\n335: assertTrue(xf.isBit1_accessTimePresent());\n336: assertTrue(xf.isBit2_createTimePresent());\n337: // Local length=13, Central length=5\n338: assertEquals(13, xf.getLocalFileDataLength().getValue());\n339: assertEquals(5, xf.getCentralDirectoryLength().getValue());\n340: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(final long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(I)V",
                                    "method_body": "public ZipLong(int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Data Descriptor signature.\n*\n* <p>Actually, PKWARE uses this as marker for split/spanned\n* archives and other archivers have started to use it as Data\n* Descriptor signature (as well).</p>\n* @since 1.1\n*/\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\n\n/**\n* Value stored in size and similar fields if ZIP64 extensions are\n* used.\n* @since 1.3\n*/\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\n\n/**\n* Marks ZIP archives that were supposed to be split or spanned\n* but only needed a single segment in then end (so are actually\n* neither split nor spanned).\n*\n* <p>This is the \"PK00\" prefix found in some archives.</p>\n* @since 1.5\n*/\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\nnew ZipLong(0X30304B50L);\n\n/**\n* Archive extra data record signature.\n* @since 1.5\n*/\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(final long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue()J",
                                    "method_body": "public long getValue() {\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
                                    "method_body": "public ZipShort (final int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<clinit>()V",
                                    "method_body": "public static final ZipShort ZERO = new ZipShort(0);\n\nprivate static final long serialVersionUID = 1L;\n\nprivate final int value;\n\n/**\n* Create instance from a number.\n* @param value the int to store as a ZipShort\n*/\npublic ZipShort (final int value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<init>()V",
                                    "method_body": "public X5455_ExtendedTimestamp() {}\npublic X5455_ExtendedTimestamp() {}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<clinit>()V",
                                    "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x5455);\nprivate static final long serialVersionUID = 1L;\n\n/**\n* The bit set inside the flags by when the last modification time\n* is present in this extra field.\n*/\npublic static final byte MODIFY_TIME_BIT = 1;\n/**\n* The bit set inside the flags by when the lasr access time is\n* present in this extra field.\n*/\npublic static final byte ACCESS_TIME_BIT = 2;\n/**\n* The bit set inside the flags by when the original creation time\n* is present in this extra field.\n*/\npublic static final byte CREATE_TIME_BIT = 4;\n\n// The 3 boolean fields (below) come from this flags byte.  The remaining 5 bits\n// are ignored according to the current version of the spec (December 2012).\nprivate byte flags;\n\n// Note: even if bit1 and bit2 are set, the Central data will still not contain\n// access/create fields:  only local data ever holds those!  This causes\n// some of our implementation to look a little odd, with seemingly spurious\n// != null and length checks.\nprivate boolean bit0_modifyTimePresent;\nprivate boolean bit1_accessTimePresent;\nprivate boolean bit2_createTimePresent;\n\nprivate ZipLong modifyTime;\nprivate ZipLong accessTime;\nprivate ZipLong createTime;\n\n/**\n* Constructor for X5455_ExtendedTimestamp.\n*/\npublic X5455_ExtendedTimestamp() {}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:setModifyTime(Lorg/apache/commons/compress/archivers/zip/ZipLong;)V",
                                    "method_body": "public void setModifyTime(final ZipLong l) {\nbit0_modifyTimePresent = l != null;\nflags = (byte) (l != null ? (flags | MODIFY_TIME_BIT)\n: (flags & ~MODIFY_TIME_BIT));\nthis.modifyTime = l;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:setModifyJavaTime(Ljava/util/Date;)V",
                                    "method_body": "public void setModifyJavaTime(final Date d) { setModifyTime(dateToZipLong(d)); }\npublic void setModifyJavaTime(final Date d) { setModifyTime(dateToZipLong(d)); }"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:dateToZipLong(Ljava/util/Date;)Lorg/apache/commons/compress/archivers/zip/ZipLong;",
                                    "method_body": "private static ZipLong dateToZipLong(final Date d) {\nif (d == null) { return null; }\n\nreturn unixTimeToZipLong(d.getTime() / 1000);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:unixTimeToZipLong(J)Lorg/apache/commons/compress/archivers/zip/ZipLong;",
                                    "method_body": "private static ZipLong unixTimeToZipLong(long l) {\nfinal long TWO_TO_32 = 0x100000000L;\nif (l >= TWO_TO_32) {\nthrow new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l);\n}\nreturn new ZipLong(l);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 47,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest.properlyMarksEntriesAsUnreadableIfUncompressedSizeIsUnknown",
                            "test_body": "330: public void properlyMarksEntriesAsUnreadableIfUncompressedSizeIsUnknown() throws Exception {\n331: // we never read any data\n332: try (ZipArchiveInputStream zis = new ZipArchiveInputStream(new ByteArrayInputStream(new byte[0]))) {\n333: ZipArchiveEntry e = new ZipArchiveEntry(\"test\");\n334: e.setMethod(ZipMethod.DEFLATED.getCode());\n335: assertTrue(zis.canReadEntryData(e));\n336: e.setMethod(ZipMethod.ENHANCED_DEFLATED.getCode());\n337: assertTrue(zis.canReadEntryData(e));\n338: e.setMethod(ZipMethod.BZIP2.getCode());\n339: assertFalse(zis.canReadEntryData(e));\n340: }\n341: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveEntry(final String name) {\nsuper(name);\nsetName(name);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<clinit>()V",
                                    "method_body": "public static final int PLATFORM_UNIX = 3;\npublic static final int PLATFORM_FAT  = 0;\npublic static final int CRC_UNKNOWN = -1;\nprivate static final int SHORT_MASK = 0xFFFF;\nprivate static final int SHORT_SHIFT = 16;\nprivate static final byte[] EMPTY = new byte[0];\n\n/**\n* Indicates how the name of this entry has been determined.\n* @since 1.16\n*/\npublic enum NameSource {\n/**\n* The name has been read from the archive using the encoding\n* of the archive specified when creating the {@link\n* ZipArchiveInputStream} or {@link ZipFile} (defaults to the\n* platform's default encoding).\n*/\nNAME,\n/**\n* The name has been read from the archive and the archive\n* specified the EFS flag which indicates the name has been\n* encoded as UTF-8.\n*/\nNAME_WITH_EFS_FLAG,\n/**\n* The name has been read from an {@link UnicodePathExtraField\n* Unicode Extra Field}.\n*/\nUNICODE_EXTRA_FIELD\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getMethod()I",
                                    "method_body": "public int getMethod() {\nreturn method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setMethod(I)V",
                                    "method_body": "public void setMethod(final int method) {\nif (method < 0) {\nthrow new IllegalArgumentException(\n\"ZIP compression method can not be negative: \" + method);\n}\nthis.method = method;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
                                    "method_body": "public int getPlatform() {\nreturn platform;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;)V",
                                    "method_body": "protected void setName(String name) {\nif (name != null && getPlatform() == PLATFORM_FAT\n&& !name.contains(\"/\")) {\nname = name.replace('\\\\', '/');\n}\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getGeneralPurposeBit()Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
                                    "method_body": "public GeneralPurposeBit getGeneralPurposeBit() {\nreturn gpb;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:<init>()V",
                                    "method_body": "public GeneralPurposeBit() {\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesDataDescriptor()Z",
                                    "method_body": "public boolean usesDataDescriptor() {\nreturn dataDescriptorFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesEncryption()Z",
                                    "method_body": "public boolean usesEncryption() {\nreturn encryptionFlag;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry$NameSource:<clinit>()V",
                                    "method_body": "public static final int PLATFORM_UNIX = 3;\npublic static final int PLATFORM_FAT  = 0;\npublic static final int CRC_UNKNOWN = -1;\nprivate static final int SHORT_MASK = 0xFFFF;\nprivate static final int SHORT_SHIFT = 16;\nprivate static final byte[] EMPTY = new byte[0];\n\n/**\n* Indicates how the name of this entry has been determined.\n* @since 1.16\n*/\npublic enum NameSource {\n/**\n* The name has been read from the archive using the encoding\n* of the archive specified when creating the {@link\n* ZipArchiveInputStream} or {@link ZipFile} (defaults to the\n* platform's default encoding).\n*/\nNAME,\n/**\n* The name has been read from the archive and the archive\n* specified the EFS flag which indicates the name has been\n* encoded as UTF-8.\n*/\nNAME_WITH_EFS_FLAG,\n/**\n* The name has been read from an {@link UnicodePathExtraField\n* Unicode Extra Field}.\n*/\nUNICODE_EXTRA_FIELD\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
                                    "method_body": "public ZipLong(final long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Data Descriptor signature.\n*\n* <p>Actually, PKWARE uses this as marker for split/spanned\n* archives and other archivers have started to use it as Data\n* Descriptor signature (as well).</p>\n* @since 1.1\n*/\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\n\n/**\n* Value stored in size and similar fields if ZIP64 extensions are\n* used.\n* @since 1.3\n*/\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\n\n/**\n* Marks ZIP archives that were supposed to be split or spanned\n* but only needed a single segment in then end (so are actually\n* neither split nor spanned).\n*\n* <p>This is the \"PK00\" prefix found in some archives.</p>\n* @since 1.5\n*/\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\nnew ZipLong(0X30304B50L);\n\n/**\n* Archive extra data record signature.\n* @since 1.5\n*/\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(final long value) {\nthis.value = value;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
                                    "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
                                    "method_body": "public static byte[] getBytes(final long value) {\nfinal byte[] result = new byte[WORD];\nputLong(value, result, 0);\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:putLong(J[BI)V",
                                    "method_body": "public static void putLong(final long value, final byte[] buf, int offset) {\nByteUtils.toLittleEndian(buf, value, offset, 4);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.ByteUtils:toLittleEndian([BJII)V",
                                    "method_body": "public static void toLittleEndian(final byte[] b, final long value, final int off, final int length) {\nlong num = value;\nfor (int i = 0; i < length; i++) {\nb[off + i] = (byte) (num & 0xff);\nnum >>= 8;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
                                    "method_body": "static final String UTF8 = \"UTF8\";\n\n/**\n* the encoding UTF-8\n*/\nstatic final ZipEncoding UTF8_ZIP_ENCODING = getZipEncoding(UTF8);\n\n/**\n* Instantiates a zip encoding. An NIO based character set encoder/decoder will be returned.\n* As a special case, if the character set is UTF-8, the nio encoder will be configured  replace malformed and\n* unmappable characters with '?'. This matches existing behavior from the older fallback encoder.\n* <p>\n*     If the requested characer set cannot be found, the platform default will\n*     be used instead.\n* </p>\n* @param name The name of the zip encoding. Specify {@code null} for"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
                                    "method_body": "public static ZipEncoding getZipEncoding(final String name) {\nCharset cs = Charset.defaultCharset();\nif (name != null) {\ntry {\ncs = Charset.forName(name);\n} catch (UnsupportedCharsetException e) { // NOSONAR we use the default encoding instead\n}\n}\nboolean useReplacement = isUTF8(cs.name());\nreturn new NioZipEncoding(cs, useReplacement);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
                                    "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\n// check platform's default encoding\ncharsetName = Charset.defaultCharset().name();\n}\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}\nfor (final String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\n\n/**\n* <p>\n* Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\n* (either order accepted on input, big-endian used on output)\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, big-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, little-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\n\n/**\n* <p>\n* Eight-bit Unicode Transformation Format.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:<init>(Ljava/nio/charset/Charset;Z)V",
                                    "method_body": "NioZipEncoding(final Charset charset, boolean useReplacement) {\nthis.charset = charset;\nthis.useReplacement = useReplacement;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.NioZipEncoding:<clinit>()V",
                                    "method_body": "private final Charset charset;\nprivate final boolean useReplacement;\nprivate static final char REPLACEMENT = '?';\nprivate static final byte[] REPLACEMENT_BYTES = { (byte) REPLACEMENT };"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
                                    "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n\n/**\n* Convert a Date object to a DOS date/time field.\n* @param time the <code>Date</code> to convert\n* @return the date as a <code>ZipLong</code>\n*/\npublic static ZipLong toDosTime(final Date time) {\nreturn new ZipLong(toDosTime(time.getTime()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:canHandleEntryData(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "static boolean canHandleEntryData(final ZipArchiveEntry entry) {\nreturn supportsEncryptionOf(entry) && supportsMethodOf(entry);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:supportsEncryptionOf(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private static boolean supportsEncryptionOf(final ZipArchiveEntry entry) {\nreturn !entry.getGeneralPurposeBit().usesEncryption();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:supportsMethodOf(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private static boolean supportsMethodOf(final ZipArchiveEntry entry) {\nreturn entry.getMethod() == ZipEntry.STORED\n|| entry.getMethod() == ZipMethod.UNSHRINKING.getCode()\n|| entry.getMethod() == ZipMethod.IMPLODING.getCode()\n|| entry.getMethod() == ZipEntry.DEFLATED\n|| entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode()\n|| entry.getMethod() == ZipMethod.BZIP2.getCode();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:<init>(Ljava/lang/String;I)V",
                                    "method_body": "private ZipMethod() {\nthis(UNKNOWN_CODE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:<init>(Ljava/lang/String;II)V",
                                    "method_body": "ZipMethod(final int code) {\nthis.code = code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:getCode()I",
                                    "method_body": "public int getCode() {\nreturn code;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public ZipArchiveInputStream(final InputStream inputStream) {\nthis(inputStream, ZipEncodingHelper.UTF8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
                                    "method_body": "public ZipArchiveInputStream(final InputStream inputStream, final String encoding) {\nthis(inputStream, encoding, true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;Z)V",
                                    "method_body": "public ZipArchiveInputStream(final InputStream inputStream, final String encoding, final boolean useUnicodeExtraFields) {\nthis(inputStream, encoding, useUnicodeExtraFields, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;ZZ)V",
                                    "method_body": "public ZipArchiveInputStream(final InputStream inputStream,\nfinal String encoding,\nfinal boolean useUnicodeExtraFields,\nfinal boolean allowStoredEntriesWithDataDescriptor) {\nthis.encoding = encoding;\nzipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\nin = new PushbackInputStream(inputStream, buf.capacity());\nthis.allowStoredEntriesWithDataDescriptor =\nallowStoredEntriesWithDataDescriptor;\n// haven't read anything so far\nbuf.limit(0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<clinit>()V",
                                    "method_body": "private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\nprivate static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\nprivate static final byte[] DD = ZipLong.DD_SIG.getBytes();\n\n/**\n* Checks whether the current buffer contains the signature of a\n* &quot;data descriptor&quot;, &quot;local file header&quot; or\n* &quot;central directory entry&quot;.\n*\n* <p>If it contains such a signature, reads the data descriptor\n* and positions the stream right after the data descriptor.</p>\n*/\nprivate boolean bufferContainsSignature(final ByteArrayOutputStream bos, final int offset, final int lastRead, final int expectedDDLen)\nthrows IOException {\n\nboolean done = false;\nint readTooMuch = 0;\nfor (int i = 0; !done && i < lastRead - 4; i++) {\nif (buf.array()[i] == LFH[0] && buf.array()[i + 1] == LFH[1]) {\nif ((buf.array()[i + 2] == LFH[2] && buf.array()[i + 3] == LFH[3])\n|| (buf.array()[i] == CFH[2] && buf.array()[i + 3] == CFH[3])) {\n// found a LFH or CFH:\nreadTooMuch = offset + lastRead - i - expectedDDLen;\ndone = true;\n}\nelse if (buf.array()[i + 2] == DD[2] && buf.array()[i + 3] == DD[3]) {\n// found DD:\nreadTooMuch = offset + lastRead - i;\ndone = true;\n}\nif (done) {\n// * push back bytes read in excess as well as the data\n//   descriptor\n// * copy the remaining bytes to cache\n// * read data descriptor\npushback(buf.array(), offset + lastRead - readTooMuch, readTooMuch);\nbos.write(buf.array(), 0, i);\nreadDataDescriptor();\n}\n}\n}\nreturn done;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:canReadEntryData(Lorg/apache/commons/compress/archivers/ArchiveEntry;)Z",
                                    "method_body": "public boolean canReadEntryData(final ArchiveEntry ae) {\nif (ae instanceof ZipArchiveEntry) {\nfinal ZipArchiveEntry ze = (ZipArchiveEntry) ae;\nreturn ZipUtil.canHandleEntryData(ze)\n&& supportsDataDescriptorFor(ze);\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:close()V",
                                    "method_body": "public void close() throws IOException {\nif (!closed) {\nclosed = true;\ntry {\nin.close();\n} finally {\ninf.end();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:supportsDataDescriptorFor(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
                                    "method_body": "private boolean supportsDataDescriptorFor(final ZipArchiveEntry entry) {\nreturn !entry.getGeneralPurposeBit().usesDataDescriptor()\n\n|| (allowStoredEntriesWithDataDescriptor && entry.getMethod() == ZipEntry.STORED)\n|| entry.getMethod() == ZipEntry.DEFLATED\n|| entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode();\n}"
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}