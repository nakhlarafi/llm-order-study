{
    "projects": [
        {
            "name": "Codec",
            "bugs": [
                {
                    "bug_id": 1,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.language.MetaphoneTest.testLocaleIndependence",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.language.Metaphone:<init>()V",
                                    "method_body": "public Metaphone() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Metaphone:metaphone(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String metaphone(String txt) {\nboolean hard = false ;\nif ((txt == null) || (txt.length() == 0)) {\nreturn \"\" ;\n}\n// single character is itself\nif (txt.length() == 1) {\nreturn txt.toUpperCase() ;\n}\n\nchar[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray() ;\n\nStringBuffer local = new StringBuffer(40); // manipulate\nStringBuffer code = new StringBuffer(10) ; //   output\n// handle initial 2 characters exceptions\nswitch(inwd[0]) {\ncase 'K' :\ncase 'G' :\ncase 'P' : /* looking for KN, etc*/\nif (inwd[1] == 'N') {\nlocal.append(inwd, 1, inwd.length - 1);\n} else {\nlocal.append(inwd);\n}\nbreak;\ncase 'A': /* looking for AE */\nif (inwd[1] == 'E') {\nlocal.append(inwd, 1, inwd.length - 1);\n} else {\nlocal.append(inwd);\n}\nbreak;\ncase 'W' : /* looking for WR or WH */\nif (inwd[1] == 'R') {   // WR -> R\nlocal.append(inwd, 1, inwd.length - 1);\nbreak ;\n}\nif (inwd[1] == 'H') {\nlocal.append(inwd, 1, inwd.length - 1);\nlocal.setCharAt(0, 'W'); // WH -> W\n} else {\nlocal.append(inwd);\n}\nbreak;\ncase 'X' : /* initial X becomes S */\ninwd[0] = 'S';\nlocal.append(inwd);\nbreak ;\ndefault :\nlocal.append(inwd);\n} // now local has working string with initials fixed\n\nint wdsz = local.length();\nint n = 0 ;\n\nwhile ((code.length() < this.getMaxCodeLen()) &&\n(n < wdsz) ) { // max code size of 4 works well\nchar symb = local.charAt(n) ;\n// remove duplicate letters except C\nif ((symb != 'C') && (isPreviousChar( local, n, symb )) ) {\nn++ ;\n} else { // not dup\nswitch(symb) {\ncase 'A' : case 'E' : case 'I' : case 'O' : case 'U' :\nif (n == 0) {\ncode.append(symb);\n}\nbreak ; // only use vowel if leading char\ncase 'B' :\nif ( isPreviousChar(local, n, 'M') &&\nisLastChar(wdsz, n) ) { // B is silent if word ends in MB\nbreak;\n}\ncode.append(symb);\nbreak;\ncase 'C' : // lots of C special cases\n/* discard if SCI, SCE or SCY */\nif ( isPreviousChar(local, n, 'S') &&\n!isLastChar(wdsz, n) &&\n(FRONTV.indexOf(local.charAt(n + 1)) >= 0) ) {\nbreak;\n}\nif (regionMatch(local, n, \"CIA\")) { // \"CIA\" -> X\ncode.append('X');\nbreak;\n}\nif (!isLastChar(wdsz, n) &&\n(FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {\ncode.append('S');\nbreak; // CI,CE,CY -> S\n}\nif (isPreviousChar(local, n, 'S') &&\nisNextChar(local, n, 'H') ) { // SCH->sk\ncode.append('K') ;\nbreak ;\n}\nif (isNextChar(local, n, 'H')) { // detect CH\nif ((n == 0) &&\n(wdsz >= 3) &&\nisVowel(local,2) ) { // CH consonant -> K consonant\ncode.append('K');\n} else {\ncode.append('X'); // CHvowel -> X\n}\n} else {\ncode.append('K');\n}\nbreak ;\ncase 'D' :\nif (!isLastChar(wdsz, n + 1) &&\nisNextChar(local, n, 'G') &&\n(FRONTV.indexOf(local.charAt(n + 2)) >= 0)) { // DGE DGI DGY -> J\ncode.append('J'); n += 2 ;\n} else {\ncode.append('T');\n}\nbreak ;\ncase 'G' : // GH silent at end or before consonant\nif (isLastChar(wdsz, n + 1) &&\nisNextChar(local, n, 'H')) {\nbreak;\n}\nif (!isLastChar(wdsz, n + 1) &&\nisNextChar(local,n,'H') &&\n!isVowel(local,n+2)) {\nbreak;\n}\nif ((n > 0) &&\n( regionMatch(local, n, \"GN\") ||\nregionMatch(local, n, \"GNED\") ) ) {\nbreak; // silent G\n}\nif (isPreviousChar(local, n, 'G')) {\nhard = true ;\n} else {\nhard = false ;\n}\nif (!isLastChar(wdsz, n) &&\n(FRONTV.indexOf(local.charAt(n + 1)) >= 0) &&\n(!hard)) {\ncode.append('J');\n} else {\ncode.append('K');\n}\nbreak ;\ncase 'H':\nif (isLastChar(wdsz, n)) {\nbreak ; // terminal H\n}\nif ((n > 0) &&\n(VARSON.indexOf(local.charAt(n - 1)) >= 0)) {\nbreak;\n}\nif (isVowel(local,n+1)) {\ncode.append('H'); // Hvowel\n}\nbreak;\ncase 'F':\ncase 'J' :\ncase 'L' :\ncase 'M':\ncase 'N' :\ncase 'R' :\ncode.append(symb);\nbreak;\ncase 'K' :\nif (n > 0) { // not initial\nif (!isPreviousChar(local, n, 'C')) {\ncode.append(symb);\n}\n} else {\ncode.append(symb); // initial K\n}\nbreak ;\ncase 'P' :\nif (isNextChar(local,n,'H')) {\n// PH -> F\ncode.append('F');\n} else {\ncode.append(symb);\n}\nbreak ;\ncase 'Q' :\ncode.append('K');\nbreak;\ncase 'S' :\nif (regionMatch(local,n,\"SH\") ||\nregionMatch(local,n,\"SIO\") ||\nregionMatch(local,n,\"SIA\")) {\ncode.append('X');\n} else {\ncode.append('S');\n}\nbreak;\ncase 'T' :\nif (regionMatch(local,n,\"TIA\") ||\nregionMatch(local,n,\"TIO\")) {\ncode.append('X');\nbreak;\n}\nif (regionMatch(local,n,\"TCH\")) {\n// Silent if in \"TCH\"\nbreak;\n}\n// substitute numeral 0 for TH (resembles theta after all)\nif (regionMatch(local,n,\"TH\")) {\ncode.append('0');\n} else {\ncode.append('T');\n}\nbreak ;\ncase 'V' :\ncode.append('F'); break ;\ncase 'W' : case 'Y' : // silent if not followed by vowel\nif (!isLastChar(wdsz,n) &&\nisVowel(local,n+1)) {\ncode.append(symb);\n}\nbreak ;\ncase 'X' :\ncode.append('K'); code.append('S');\nbreak ;\ncase 'Z' :\ncode.append('S'); break ;\n} // end switch\nn++ ;\n} // end else from symb != 'C'\nif (code.length() > this.getMaxCodeLen()) {\ncode.setLength(this.getMaxCodeLen());\n}\n}\nreturn code.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Metaphone:encode(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(String pString) {\nreturn metaphone(pString);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.language.DoubleMetaphoneTest.testLocaleIndependence",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.language.Metaphone:<init>()V",
                                    "method_body": "public Metaphone() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Metaphone:metaphone(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String metaphone(String txt) {\nboolean hard = false ;\nif ((txt == null) || (txt.length() == 0)) {\nreturn \"\" ;\n}\n// single character is itself\nif (txt.length() == 1) {\nreturn txt.toUpperCase() ;\n}\n\nchar[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray() ;\n\nStringBuffer local = new StringBuffer(40); // manipulate\nStringBuffer code = new StringBuffer(10) ; //   output\n// handle initial 2 characters exceptions\nswitch(inwd[0]) {\ncase 'K' :\ncase 'G' :\ncase 'P' : /* looking for KN, etc*/\nif (inwd[1] == 'N') {\nlocal.append(inwd, 1, inwd.length - 1);\n} else {\nlocal.append(inwd);\n}\nbreak;\ncase 'A': /* looking for AE */\nif (inwd[1] == 'E') {\nlocal.append(inwd, 1, inwd.length - 1);\n} else {\nlocal.append(inwd);\n}\nbreak;\ncase 'W' : /* looking for WR or WH */\nif (inwd[1] == 'R') {   // WR -> R\nlocal.append(inwd, 1, inwd.length - 1);\nbreak ;\n}\nif (inwd[1] == 'H') {\nlocal.append(inwd, 1, inwd.length - 1);\nlocal.setCharAt(0, 'W'); // WH -> W\n} else {\nlocal.append(inwd);\n}\nbreak;\ncase 'X' : /* initial X becomes S */\ninwd[0] = 'S';\nlocal.append(inwd);\nbreak ;\ndefault :\nlocal.append(inwd);\n} // now local has working string with initials fixed\n\nint wdsz = local.length();\nint n = 0 ;\n\nwhile ((code.length() < this.getMaxCodeLen()) &&\n(n < wdsz) ) { // max code size of 4 works well\nchar symb = local.charAt(n) ;\n// remove duplicate letters except C\nif ((symb != 'C') && (isPreviousChar( local, n, symb )) ) {\nn++ ;\n} else { // not dup\nswitch(symb) {\ncase 'A' : case 'E' : case 'I' : case 'O' : case 'U' :\nif (n == 0) {\ncode.append(symb);\n}\nbreak ; // only use vowel if leading char\ncase 'B' :\nif ( isPreviousChar(local, n, 'M') &&\nisLastChar(wdsz, n) ) { // B is silent if word ends in MB\nbreak;\n}\ncode.append(symb);\nbreak;\ncase 'C' : // lots of C special cases\n/* discard if SCI, SCE or SCY */\nif ( isPreviousChar(local, n, 'S') &&\n!isLastChar(wdsz, n) &&\n(FRONTV.indexOf(local.charAt(n + 1)) >= 0) ) {\nbreak;\n}\nif (regionMatch(local, n, \"CIA\")) { // \"CIA\" -> X\ncode.append('X');\nbreak;\n}\nif (!isLastChar(wdsz, n) &&\n(FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {\ncode.append('S');\nbreak; // CI,CE,CY -> S\n}\nif (isPreviousChar(local, n, 'S') &&\nisNextChar(local, n, 'H') ) { // SCH->sk\ncode.append('K') ;\nbreak ;\n}\nif (isNextChar(local, n, 'H')) { // detect CH\nif ((n == 0) &&\n(wdsz >= 3) &&\nisVowel(local,2) ) { // CH consonant -> K consonant\ncode.append('K');\n} else {\ncode.append('X'); // CHvowel -> X\n}\n} else {\ncode.append('K');\n}\nbreak ;\ncase 'D' :\nif (!isLastChar(wdsz, n + 1) &&\nisNextChar(local, n, 'G') &&\n(FRONTV.indexOf(local.charAt(n + 2)) >= 0)) { // DGE DGI DGY -> J\ncode.append('J'); n += 2 ;\n} else {\ncode.append('T');\n}\nbreak ;\ncase 'G' : // GH silent at end or before consonant\nif (isLastChar(wdsz, n + 1) &&\nisNextChar(local, n, 'H')) {\nbreak;\n}\nif (!isLastChar(wdsz, n + 1) &&\nisNextChar(local,n,'H') &&\n!isVowel(local,n+2)) {\nbreak;\n}\nif ((n > 0) &&\n( regionMatch(local, n, \"GN\") ||\nregionMatch(local, n, \"GNED\") ) ) {\nbreak; // silent G\n}\nif (isPreviousChar(local, n, 'G')) {\nhard = true ;\n} else {\nhard = false ;\n}\nif (!isLastChar(wdsz, n) &&\n(FRONTV.indexOf(local.charAt(n + 1)) >= 0) &&\n(!hard)) {\ncode.append('J');\n} else {\ncode.append('K');\n}\nbreak ;\ncase 'H':\nif (isLastChar(wdsz, n)) {\nbreak ; // terminal H\n}\nif ((n > 0) &&\n(VARSON.indexOf(local.charAt(n - 1)) >= 0)) {\nbreak;\n}\nif (isVowel(local,n+1)) {\ncode.append('H'); // Hvowel\n}\nbreak;\ncase 'F':\ncase 'J' :\ncase 'L' :\ncase 'M':\ncase 'N' :\ncase 'R' :\ncode.append(symb);\nbreak;\ncase 'K' :\nif (n > 0) { // not initial\nif (!isPreviousChar(local, n, 'C')) {\ncode.append(symb);\n}\n} else {\ncode.append(symb); // initial K\n}\nbreak ;\ncase 'P' :\nif (isNextChar(local,n,'H')) {\n// PH -> F\ncode.append('F');\n} else {\ncode.append(symb);\n}\nbreak ;\ncase 'Q' :\ncode.append('K');\nbreak;\ncase 'S' :\nif (regionMatch(local,n,\"SH\") ||\nregionMatch(local,n,\"SIO\") ||\nregionMatch(local,n,\"SIA\")) {\ncode.append('X');\n} else {\ncode.append('S');\n}\nbreak;\ncase 'T' :\nif (regionMatch(local,n,\"TIA\") ||\nregionMatch(local,n,\"TIO\")) {\ncode.append('X');\nbreak;\n}\nif (regionMatch(local,n,\"TCH\")) {\n// Silent if in \"TCH\"\nbreak;\n}\n// substitute numeral 0 for TH (resembles theta after all)\nif (regionMatch(local,n,\"TH\")) {\ncode.append('0');\n} else {\ncode.append('T');\n}\nbreak ;\ncase 'V' :\ncode.append('F'); break ;\ncase 'W' : case 'Y' : // silent if not followed by vowel\nif (!isLastChar(wdsz,n) &&\nisVowel(local,n+1)) {\ncode.append(symb);\n}\nbreak ;\ncase 'X' :\ncode.append('K'); code.append('S');\nbreak ;\ncase 'Z' :\ncode.append('S'); break ;\n} // end switch\nn++ ;\n} // end else from symb != 'C'\nif (code.length() > this.getMaxCodeLen()) {\ncode.setLength(this.getMaxCodeLen());\n}\n}\nreturn code.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Metaphone:encode(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(String pString) {\nreturn metaphone(pString);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:<init>()V",
                                    "method_body": "public DoubleMetaphone() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:<clinit>()V",
                                    "method_body": "private static final String VOWELS = \"AEIOUY\";\n\n/**\n* Prefixes when present which are not pronounced\n*/\nprivate static final String[] SILENT_START =\n{ \"GN\", \"KN\", \"PN\", \"WR\", \"PS\" };"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.language.SoundexTest.testLocaleIndependence",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:<init>()V",
                                    "method_body": "public Soundex() {\nthis(US_ENGLISH_MAPPING);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:<init>([C)V",
                                    "method_body": "public Soundex(char[] mapping) {\nthis.setSoundexMapping(mapping);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:<clinit>()V",
                                    "method_body": "public static final String US_ENGLISH_MAPPING_STRING = \"01230120022455012623010202\";\n\n/**\n* This is a default mapping of the 26 letters used in US English. A value of <code>0</code> for a letter position\n* means do not encode.\n*\n* @see Soundex#Soundex(char[])\n*/\npublic static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();\n\n/**\n* An instance of Soundex using the US_ENGLISH_MAPPING mapping.\n*\n* @see #US_ENGLISH_MAPPING\n*/\npublic static final Soundex US_ENGLISH = new Soundex();\n\n\n/**\n* Encodes the Strings and returns the number of characters in the two encoded Strings that are the same. This\n* return value ranges from 0 through 4: 0 indicates little or no similarity, and 4 indicates strong similarity or\n* identical values.\n*\n* @param s1\n*                  A String that will be encoded and compared.\n* @param s2\n*                  A String that will be encoded and compared.\n* @return The number of characters in the two encoded Strings that are the same from 0 to 4.\n*\n* @see SoundexUtils#difference(StringEncoder,String,String)\n* @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\"> MS\n*          T-SQL DIFFERENCE </a>\n*\n* @throws EncoderException\n*                  if an error occurs encoding one of the strings\n* @since 1.3\n*/\npublic int difference(String s1, String s2) throws EncoderException {\nreturn SoundexUtils.difference(this, s1, s2);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:encode(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(String pString) {\nreturn soundex(pString);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:getMappingCode(Ljava/lang/String;I)C",
                                    "method_body": "private char getMappingCode(String str, int index) {\n// map() throws IllegalArgumentException\nchar mappedChar = this.map(str.charAt(index));\n// HW rule check\nif (index > 1 && mappedChar != '0') {\nchar hwChar = str.charAt(index - 1);\nif ('H' == hwChar || 'W' == hwChar) {\nchar preHWChar = str.charAt(index - 2);\nchar firstCode = this.map(preHWChar);\nif (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\nreturn 0;\n}\n}\n}\nreturn mappedChar;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:getSoundexMapping()[C",
                                    "method_body": "private char[] getSoundexMapping() {\nreturn this.soundexMapping;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:map(C)C",
                                    "method_body": "private char map(char ch) {\nint index = ch - 'A';\nif (index < 0 || index >= this.getSoundexMapping().length) {\nthrow new IllegalArgumentException(\"The character is not mapped: \" + ch);\n}\nreturn this.getSoundexMapping()[index];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:setSoundexMapping([C)V",
                                    "method_body": "private void setSoundexMapping(char[] soundexMapping) {\nthis.soundexMapping = soundexMapping;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:soundex(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String soundex(String str) {\nif (str == null) {\nreturn null;\n}\nstr = SoundexUtils.clean(str);\nif (str.length() == 0) {\nreturn str;\n}\nchar out[] = {'0', '0', '0', '0'};\nchar last, mapped;\nint incount = 1, count = 1;\nout[0] = str.charAt(0);\n// getMappingCode() throws IllegalArgumentException\nlast = getMappingCode(str, 0);\nwhile ((incount < str.length()) && (count < out.length)) {\nmapped = getMappingCode(str, incount++);\nif (mapped != 0) {\nif ((mapped != '0') && (mapped != last)) {\nout[count++] = mapped;\n}\nlast = mapped;\n}\n}\nreturn new String(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.SoundexUtils:clean(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String clean(String str) {\nif (str == null || str.length() == 0) {\nreturn str;\n}\nint len = str.length();\nchar[] chars = new char[len];\nint count = 0;\nfor (int i = 0; i < len; i++) {\nif (Character.isLetter(str.charAt(i))) {\nchars[count++] = str.charAt(i);\n}\n}\nif (count == len) {\nreturn str.toUpperCase();\n}\nreturn new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.language.RefinedSoundexTest.testLocaleIndependence",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.language.SoundexUtils:clean(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String clean(String str) {\nif (str == null || str.length() == 0) {\nreturn str;\n}\nint len = str.length();\nchar[] chars = new char[len];\nint count = 0;\nfor (int i = 0; i < len; i++) {\nif (Character.isLetter(str.charAt(i))) {\nchars[count++] = str.charAt(i);\n}\n}\nif (count == len) {\nreturn str.toUpperCase();\n}\nreturn new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.RefinedSoundex:<init>()V",
                                    "method_body": "public RefinedSoundex() {\nthis(US_ENGLISH_MAPPING);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.RefinedSoundex:<init>([C)V",
                                    "method_body": "public RefinedSoundex(char[] mapping) {\nthis.soundexMapping = mapping;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.RefinedSoundex:<clinit>()V",
                                    "method_body": "public static final char[] US_ENGLISH_MAPPING = \"01360240043788015936020505\".toCharArray();\n\n/**\n* Every letter of the alphabet is \"mapped\" to a numerical value. This char\n* array holds the values to which each letter is mapped. This\n* implementation contains a default map for US_ENGLISH\n*/\nprivate final char[] soundexMapping;\n\n/**\n* This static variable contains an instance of the RefinedSoundex using\n* the US_ENGLISH mapping.\n*/\npublic static final RefinedSoundex US_ENGLISH = new RefinedSoundex();\n\n/**\n* Creates an instance of the RefinedSoundex object using the default US\n* English mapping.\n*/\npublic RefinedSoundex() {\nthis(US_ENGLISH_MAPPING);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.RefinedSoundex:encode(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(String pString) {\nreturn soundex(pString);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.RefinedSoundex:getMappingCode(C)C",
                                    "method_body": "char getMappingCode(char c) {\nif (!Character.isLetter(c)) {\nreturn 0;\n}\nreturn this.soundexMapping[Character.toUpperCase(c) - 'A'];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.RefinedSoundex:soundex(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String soundex(String str) {\nif (str == null) {\nreturn null;\n}\nstr = SoundexUtils.clean(str);\nif (str.length() == 0) {\nreturn str;\n}\n\nStringBuffer sBuf = new StringBuffer();\nsBuf.append(str.charAt(0));\n\nchar last, current;\nlast = '*';\n\nfor (int i = 0; i < str.length(); i++) {\n\ncurrent = getMappingCode(str.charAt(i));\nif (current == last) {\ncontinue;\n} else if (current != 0) {\nsBuf.append(current);\n}\n\nlast = current;\n\n}\n\nreturn sBuf.toString();\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.language.CaverphoneTest.testLocaleIndependence",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.language.Caverphone:<init>()V",
                                    "method_body": "public Caverphone() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Caverphone:caverphone(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String caverphone(String txt) {\n// NOTE: Version 1.0 of Caverphone is easily derivable from this code\n// by commenting out the 2.0 lines and adding in the 1.0 lines\n\nif( txt == null || txt.length() == 0 ) {\nreturn \"1111111111\";\n}\n\n// 1. Convert to lowercase\ntxt = txt.toLowerCase();\n\n// 2. Remove anything not A-Z\ntxt = txt.replaceAll(\"[^a-z]\", \"\");\n\n// 2.5. Remove final e\ntxt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n\n// 3. Handle various start options\ntxt = txt.replaceAll(\"^cough\", \"cou2f\");\ntxt = txt.replaceAll(\"^rough\", \"rou2f\");\ntxt = txt.replaceAll(\"^tough\", \"tou2f\");\ntxt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\ntxt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\ntxt = txt.replaceAll(\"^gn\", \"2n\");\ntxt = txt.replaceAll(\"^mb\", \"m2\");\n\n// 4. Handle replacements\ntxt = txt.replaceAll(\"cq\", \"2q\");\ntxt = txt.replaceAll(\"ci\", \"si\");\ntxt = txt.replaceAll(\"ce\", \"se\");\ntxt = txt.replaceAll(\"cy\", \"sy\");\ntxt = txt.replaceAll(\"tch\", \"2ch\");\ntxt = txt.replaceAll(\"c\", \"k\");\ntxt = txt.replaceAll(\"q\", \"k\");\ntxt = txt.replaceAll(\"x\", \"k\");\ntxt = txt.replaceAll(\"v\", \"f\");\ntxt = txt.replaceAll(\"dg\", \"2g\");\ntxt = txt.replaceAll(\"tio\", \"sio\");\ntxt = txt.replaceAll(\"tia\", \"sia\");\ntxt = txt.replaceAll(\"d\", \"t\");\ntxt = txt.replaceAll(\"ph\", \"fh\");\ntxt = txt.replaceAll(\"b\", \"p\");\ntxt = txt.replaceAll(\"sh\", \"s2\");\ntxt = txt.replaceAll(\"z\", \"s\");\ntxt = txt.replaceAll(\"^[aeiou]\", \"A\");\ntxt = txt.replaceAll(\"[aeiou]\", \"3\");\ntxt = txt.replaceAll(\"j\", \"y\");        // 2.0 only\ntxt = txt.replaceAll(\"^y3\", \"Y3\");     // 2.0 only\ntxt = txt.replaceAll(\"^y\", \"A\");       // 2.0 only\ntxt = txt.replaceAll(\"y\", \"3\");        // 2.0 only\ntxt = txt.replaceAll(\"3gh3\", \"3kh3\");\ntxt = txt.replaceAll(\"gh\", \"22\");\ntxt = txt.replaceAll(\"g\", \"k\");\ntxt = txt.replaceAll(\"s+\", \"S\");\ntxt = txt.replaceAll(\"t+\", \"T\");\ntxt = txt.replaceAll(\"p+\", \"P\");\ntxt = txt.replaceAll(\"k+\", \"K\");\ntxt = txt.replaceAll(\"f+\", \"F\");\ntxt = txt.replaceAll(\"m+\", \"M\");\ntxt = txt.replaceAll(\"n+\", \"N\");\ntxt = txt.replaceAll(\"w3\", \"W3\");\n//txt = txt.replaceAll(\"wy\", \"Wy\");    // 1.0 only\ntxt = txt.replaceAll(\"wh3\", \"Wh3\");\ntxt = txt.replaceAll(\"w$\", \"3\");       // 2.0 only\n//txt = txt.replaceAll(\"why\", \"Why\");  // 1.0 only\ntxt = txt.replaceAll(\"w\", \"2\");\ntxt = txt.replaceAll(\"^h\", \"A\");\ntxt = txt.replaceAll(\"h\", \"2\");\ntxt = txt.replaceAll(\"r3\", \"R3\");\ntxt = txt.replaceAll(\"r$\", \"3\");       // 2.0 only\n//txt = txt.replaceAll(\"ry\", \"Ry\");    // 1.0 only\ntxt = txt.replaceAll(\"r\", \"2\");\ntxt = txt.replaceAll(\"l3\", \"L3\");\ntxt = txt.replaceAll(\"l$\", \"3\");       // 2.0 only\n//txt = txt.replaceAll(\"ly\", \"Ly\");    // 1.0 only\ntxt = txt.replaceAll(\"l\", \"2\");\n//txt = txt.replaceAll(\"j\", \"y\");      // 1.0 only\n//txt = txt.replaceAll(\"y3\", \"Y3\");    // 1.0 only\n//txt = txt.replaceAll(\"y\", \"2\");      // 1.0 only\n\n// 5. Handle removals\ntxt = txt.replaceAll(\"2\", \"\");\ntxt = txt.replaceAll(\"3$\", \"A\");       // 2.0 only\ntxt = txt.replaceAll(\"3\", \"\");\n\n// 6. put ten 1s on the end\ntxt = txt + \"111111\" + \"1111\";        // 1.0 only has 6 1s\n\n// 7. take the first six characters as the code\nreturn txt.substring(0, 10);          // 1.0 truncates to 6\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Caverphone:encode(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(String pString) {\nreturn caverphone(pString);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 2,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.binary.Base64OutputStreamTest.testBase64EmptyOutputStream",
                            "test_body": "50: public void testBase64EmptyOutputStream() throws Exception {\n51: byte[] emptyEncoded = new byte[0];\n52: byte[] emptyDecoded = new byte[0];\n53: testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);\n54: testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);\n55: }    \n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[B)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator) {\nthis(lineLength, lineSeparator, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[BZ)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\nthis.lineLength = lineLength;\nthis.lineSeparator = new byte[lineSeparator.length];\nSystem.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\nif (lineLength > 0) {\nthis.encodeSize = 4 + lineSeparator.length;\n} else {\nthis.encodeSize = 4;\n}\nthis.decodeSize = this.encodeSize - 1;\nif (containsBase64Byte(lineSeparator)) {\nString sep;\ntry {\nsep = new String(lineSeparator, \"UTF-8\");\n} catch (UnsupportedEncodingException uee) {\nsep = new String(lineSeparator);\n}\nthrow new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n}\nthis.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<clinit>()V",
                                    "method_body": "static final int CHUNK_SIZE = 76;\n\n/**\n* Chunk separator per RFC 2045 section 2.1.\n*\n* @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n*/\nstatic final byte[] CHUNK_SEPARATOR = {'\\r','\\n'};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:avail()I",
                                    "method_body": "int avail() {\nreturn buf != null ? pos - readPos : 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:resizeBuf()V",
                                    "method_body": "private void resizeBuf() {\nif (buf == null) {\nbuf = new byte[8192];\npos = 0;\nreadPos = 0;\n} else {\nbyte[] b = new byte[buf.length * 2];\nSystem.arraycopy(buf, 0, b, 0, buf.length);\nbuf = b;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:readResults([BII)I",
                                    "method_body": "int readResults(byte[] b, int bPos, int bAvail) {\nif (buf != null) {\nint len = Math.min(avail(), bAvail);\nif (buf != b) {\nSystem.arraycopy(buf, readPos, b, bPos, len);\nreadPos += len;\nif (readPos >= pos) {\nbuf = null;\n}\n} else {\n// Re-using the original consumer's output array is only\n// allowed for one round.\nbuf = null;\n}\nreturn len;\n}\nreturn eof ? -1 : 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode([BII)V",
                                    "method_body": "void encode(byte[] in, int inPos, int inAvail) {\nif (eof) {\nreturn;\n}\n// inAvail < 0 is how we're informed of EOF in the underlying data we're\n// encoding.\nif (inAvail < 0) {\neof = true;\nif (buf == null || buf.length - pos < encodeSize) {\nresizeBuf();\n}\nswitch (modulus) {\ncase 1:\nbuf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\nbuf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n// URL-SAFE skips the padding to further reduce size.\nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuf[pos++] = PAD;\nbuf[pos++] = PAD;\n}\nbreak;\n\ncase 2:\nbuf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\nbuf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\nbuf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n// URL-SAFE skips the padding to further reduce size.\nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuf[pos++] = PAD;\n}\nbreak;\n}\nif (lineLength > 0) {\nSystem.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\npos += lineSeparator.length;\n}\n} else {\nfor (int i = 0; i < inAvail; i++) {\nif (buf == null || buf.length - pos < encodeSize) {\nresizeBuf();\n}\nmodulus = (++modulus) % 3;\nint b = in[inPos++];\nif (b < 0) { b += 256; }\nx = (x << 8) + b;\nif (0 == modulus) {\nbuf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\nbuf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\nbuf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\nbuf[pos++] = encodeTable[x & MASK_6BITS];\ncurrentLinePos += 4;\nif (lineLength > 0 && lineLength <= currentLinePos) {\nSystem.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\npos += lineSeparator.length;\ncurrentLinePos = 0;\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isBase64(B)Z",
                                    "method_body": "public static boolean isBase64(byte octet) {\nreturn octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:containsBase64Byte([B)Z",
                                    "method_body": "private static boolean containsBase64Byte(byte[] arrayOctet) {\nfor (int i = 0; i < arrayOctet.length; i++) {\nif (isBase64(arrayOctet[i])) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64OutputStream:<init>(Ljava/io/OutputStream;ZI[B)V",
                                    "method_body": "public Base64OutputStream(OutputStream out, boolean doEncode, int lineLength, byte[] lineSeparator) {\nsuper(out);\nthis.doEncode = doEncode;\nthis.base64 = new Base64(lineLength, lineSeparator);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64OutputStream:flush(Z)V",
                                    "method_body": "private void flush(boolean propogate) throws IOException {\nint avail = base64.avail();\nif (avail > 0) {\nbyte[] buf = new byte[avail];\nint c = base64.readResults(buf, 0, avail);\nif (c > 0) {\nout.write(buf, 0, c);\n}\n}\nif (propogate) {\nout.flush();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64OutputStream:flush()V",
                                    "method_body": "public void flush() throws IOException {\nflush(true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64OutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\n// Notify encoder of EOF (-1).\nif (doEncode) {\nbase64.encode(singleByte, 0, -1);\n} else {\nbase64.decode(singleByte, 0, -1);\n}\nflush();\nout.close();\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.binary.Base64InputStreamTest.testBase64EmptyInputStream",
                            "test_body": "50: public void testBase64EmptyInputStream() throws Exception {\n51: byte[] emptyEncoded = new byte[0];\n52: byte[] emptyDecoded = new byte[0];\n53: testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);\n54: testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);\n55: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[B)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator) {\nthis(lineLength, lineSeparator, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[BZ)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\nthis.lineLength = lineLength;\nthis.lineSeparator = new byte[lineSeparator.length];\nSystem.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\nif (lineLength > 0) {\nthis.encodeSize = 4 + lineSeparator.length;\n} else {\nthis.encodeSize = 4;\n}\nthis.decodeSize = this.encodeSize - 1;\nif (containsBase64Byte(lineSeparator)) {\nString sep;\ntry {\nsep = new String(lineSeparator, \"UTF-8\");\n} catch (UnsupportedEncodingException uee) {\nsep = new String(lineSeparator);\n}\nthrow new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n}\nthis.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<clinit>()V",
                                    "method_body": "static final int CHUNK_SIZE = 76;\n\n/**\n* Chunk separator per RFC 2045 section 2.1.\n*\n* @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n*/\nstatic final byte[] CHUNK_SEPARATOR = {'\\r','\\n'};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:hasData()Z",
                                    "method_body": "boolean hasData() {\nreturn this.buf != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:avail()I",
                                    "method_body": "int avail() {\nreturn buf != null ? pos - readPos : 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:resizeBuf()V",
                                    "method_body": "private void resizeBuf() {\nif (buf == null) {\nbuf = new byte[8192];\npos = 0;\nreadPos = 0;\n} else {\nbyte[] b = new byte[buf.length * 2];\nSystem.arraycopy(buf, 0, b, 0, buf.length);\nbuf = b;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:readResults([BII)I",
                                    "method_body": "int readResults(byte[] b, int bPos, int bAvail) {\nif (buf != null) {\nint len = Math.min(avail(), bAvail);\nif (buf != b) {\nSystem.arraycopy(buf, readPos, b, bPos, len);\nreadPos += len;\nif (readPos >= pos) {\nbuf = null;\n}\n} else {\n// Re-using the original consumer's output array is only\n// allowed for one round.\nbuf = null;\n}\nreturn len;\n}\nreturn eof ? -1 : 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode([BII)V",
                                    "method_body": "void encode(byte[] in, int inPos, int inAvail) {\nif (eof) {\nreturn;\n}\n// inAvail < 0 is how we're informed of EOF in the underlying data we're\n// encoding.\nif (inAvail < 0) {\neof = true;\nif (buf == null || buf.length - pos < encodeSize) {\nresizeBuf();\n}\nswitch (modulus) {\ncase 1:\nbuf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\nbuf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n// URL-SAFE skips the padding to further reduce size.\nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuf[pos++] = PAD;\nbuf[pos++] = PAD;\n}\nbreak;\n\ncase 2:\nbuf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\nbuf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\nbuf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n// URL-SAFE skips the padding to further reduce size.\nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuf[pos++] = PAD;\n}\nbreak;\n}\nif (lineLength > 0) {\nSystem.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\npos += lineSeparator.length;\n}\n} else {\nfor (int i = 0; i < inAvail; i++) {\nif (buf == null || buf.length - pos < encodeSize) {\nresizeBuf();\n}\nmodulus = (++modulus) % 3;\nint b = in[inPos++];\nif (b < 0) { b += 256; }\nx = (x << 8) + b;\nif (0 == modulus) {\nbuf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\nbuf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\nbuf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\nbuf[pos++] = encodeTable[x & MASK_6BITS];\ncurrentLinePos += 4;\nif (lineLength > 0 && lineLength <= currentLinePos) {\nSystem.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\npos += lineSeparator.length;\ncurrentLinePos = 0;\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isBase64(B)Z",
                                    "method_body": "public static boolean isBase64(byte octet) {\nreturn octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:containsBase64Byte([B)Z",
                                    "method_body": "private static boolean containsBase64Byte(byte[] arrayOctet) {\nfor (int i = 0; i < arrayOctet.length; i++) {\nif (isBase64(arrayOctet[i])) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64InputStream:<init>(Ljava/io/InputStream;ZI[B)V",
                                    "method_body": "public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {\nsuper(in);\nthis.doEncode = doEncode;\nthis.base64 = new Base64(lineLength, lineSeparator);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64InputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nint r = read(singleByte, 0, 1);\nwhile (r == 0) {\nr = read(singleByte, 0, 1);\n}\nif (r > 0) {\nreturn singleByte[0] < 0 ? 256 + singleByte[0] : singleByte[0];\n}\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64InputStream:read([BII)I",
                                    "method_body": "public int read(byte b[], int offset, int len) throws IOException {\nif (b == null) {\nthrow new NullPointerException();\n} else if (offset < 0 || len < 0 || offset + len < 0) {\nthrow new IndexOutOfBoundsException();\n} else if (offset > b.length || offset + len > b.length) {\nthrow new IndexOutOfBoundsException();\n} else if (len == 0) {\nreturn 0;\n} else {\nif (!base64.hasData()) {\nbyte[] buf = new byte[doEncode ? 4096 : 8192];\nint c = in.read(buf);\n\n// A little optimization to avoid System.arraycopy()\n// when possible.\nif (c > 0 && b.length == len) {\nbase64.setInitialBuffer(b, offset, len);\n}\n\nif (doEncode) {\nbase64.encode(buf, 0, c);\n} else {\nbase64.decode(buf, 0, c);\n}\n}\nreturn base64.readResults(b, offset, len);\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 3,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.language.DoubleMetaphone2Test.testDoubleMetaphoneAlternate",
                            "test_body": "80: public void testDoubleMetaphoneAlternate() {\n81: String value = null;\n82: for (int i = 0; i < TEST_DATA.length; i++) {\n83: value = TEST_DATA[i][0];\n84: assertEquals(\"Test [\" + i + \"]=\" + value, TEST_DATA[i][2], doubleMetaphone.doubleMetaphone(value, true));\n85: }\n86: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:<init>()V",
                                    "method_body": "public DoubleMetaphone() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:<clinit>()V",
                                    "method_body": "private static final String VOWELS = \"AEIOUY\";\n\n/**\n* Prefixes when present which are not pronounced\n*/\nprivate static final String[] SILENT_START =\n{ \"GN\", \"KN\", \"PN\", \"WR\", \"PS\" };"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:doubleMetaphone(Ljava/lang/String;Z)Ljava/lang/String;",
                                    "method_body": "public String doubleMetaphone(String value, boolean alternate) {\nvalue = cleanInput(value);\nif (value == null) {\nreturn null;\n}\n\nboolean slavoGermanic = isSlavoGermanic(value);\nint index = isSilentStart(value) ? 1 : 0;\n\nDoubleMetaphoneResult result = new DoubleMetaphoneResult(this.getMaxCodeLen());\n\nwhile (!result.isComplete() && index <= value.length() - 1) {\nswitch (value.charAt(index)) {\ncase 'A':\ncase 'E':\ncase 'I':\ncase 'O':\ncase 'U':\ncase 'Y':\nindex = handleAEIOUY(value, result, index);\nbreak;\ncase 'B':\nresult.append('P');\nindex = charAt(value, index + 1) == 'B' ? index + 2 : index + 1;\nbreak;\ncase '\\u00C7':\n// A C with a Cedilla\nresult.append('S');\nindex++;\nbreak;\ncase 'C':\nindex = handleC(value, result, index);\nbreak;\ncase 'D':\nindex = handleD(value, result, index);\nbreak;\ncase 'F':\nresult.append('F');\nindex = charAt(value, index + 1) == 'F' ? index + 2 : index + 1;\nbreak;\ncase 'G':\nindex = handleG(value, result, index, slavoGermanic);\nbreak;\ncase 'H':\nindex = handleH(value, result, index);\nbreak;\ncase 'J':\nindex = handleJ(value, result, index, slavoGermanic);\nbreak;\ncase 'K':\nresult.append('K');\nindex = charAt(value, index + 1) == 'K' ? index + 2 : index + 1;\nbreak;\ncase 'L':\nindex = handleL(value, result, index);\nbreak;\ncase 'M':\nresult.append('M');\nindex = conditionM0(value, index) ? index + 2 : index + 1;\nbreak;\ncase 'N':\nresult.append('N');\nindex = charAt(value, index + 1) == 'N' ? index + 2 : index + 1;\nbreak;\ncase '\\u00D1':\n// N with a tilde (spanish ene)\nresult.append('N');\nindex++;\nbreak;\ncase 'P':\nindex = handleP(value, result, index);\nbreak;\ncase 'Q':\nresult.append('K');\nindex = charAt(value, index + 1) == 'Q' ? index + 2 : index + 1;\nbreak;\ncase 'R':\nindex = handleR(value, result, index, slavoGermanic);\nbreak;\ncase 'S':\nindex = handleS(value, result, index, slavoGermanic);\nbreak;\ncase 'T':\nindex = handleT(value, result, index);\nbreak;\ncase 'V':\nresult.append('F');\nindex = charAt(value, index + 1) == 'V' ? index + 2 : index + 1;\nbreak;\ncase 'W':\nindex = handleW(value, result, index);\nbreak;\ncase 'X':\nindex = handleX(value, result, index);\nbreak;\ncase 'Z':\nindex = handleZ(value, result, index, slavoGermanic);\nbreak;\ndefault:\nindex++;\nbreak;\n}\n}\n\nreturn alternate ? result.getAlternate() : result.getPrimary();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:getMaxCodeLen()I",
                                    "method_body": "public int getMaxCodeLen() {\nreturn this.maxCodeLen;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:handleAEIOUY(Ljava/lang/String;Lorg/apache/commons/codec/language/DoubleMetaphone$DoubleMetaphoneResult;I)I",
                                    "method_body": "private int handleAEIOUY(String value, DoubleMetaphoneResult result, int\nindex) {\nif (index == 0) {\nresult.append('A');\n}\nreturn index + 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:handleC(Ljava/lang/String;Lorg/apache/commons/codec/language/DoubleMetaphone$DoubleMetaphoneResult;I)I",
                                    "method_body": "private int handleC(String value,\nDoubleMetaphoneResult result,\nint index) {\nif (conditionC0(value, index)) {  // very confusing, moved out\nresult.append('K');\nindex += 2;\n} else if (index == 0 && contains(value, index, 6, \"CAESAR\")) {\nresult.append('S');\nindex += 2;\n} else if (contains(value, index, 2, \"CH\")) {\nindex = handleCH(value, result, index);\n} else if (contains(value, index, 2, \"CZ\") &&\n!contains(value, index - 2, 4, \"WICZ\")) {\n//-- \"Czerny\" --//\nresult.append('S', 'X');\nindex += 2;\n} else if (contains(value, index + 1, 3, \"CIA\")) {\n//-- \"focaccia\" --//\nresult.append('X');\nindex += 3;\n} else if (contains(value, index, 2, \"CC\") &&\n!(index == 1 && charAt(value, 0) == 'M')) {\n//-- double \"cc\" but not \"McClelland\" --//\nreturn handleCC(value, result, index);\n} else if (contains(value, index, 2, \"CK\", \"CG\", \"CQ\")) {\nresult.append('K');\nindex += 2;\n} else if (contains(value, index, 2, \"CI\", \"CE\", \"CY\")) {\n//-- Italian vs. English --//\nif (contains(value, index, 3, \"CIO\", \"CIE\", \"CIA\")) {\nresult.append('S', 'X');\n} else {\nresult.append('S');\n}\nindex += 2;\n} else {\nresult.append('K');\nif (contains(value, index + 1, 2, \" C\", \" Q\", \" G\")) {\n//-- Mac Caffrey, Mac Gregor --//\nindex += 3;\n} else if (contains(value, index + 1, 1, \"C\", \"K\", \"Q\") &&\n!contains(value, index + 1, 2, \"CE\", \"CI\")) {\nindex += 2;\n} else {\nindex++;\n}\n}\n\nreturn index;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:handleD(Ljava/lang/String;Lorg/apache/commons/codec/language/DoubleMetaphone$DoubleMetaphoneResult;I)I",
                                    "method_body": "private int handleD(String value,\nDoubleMetaphoneResult result,\nint index) {\nif (contains(value, index, 2, \"DG\")) {\n//-- \"Edge\" --//\nif (contains(value, index + 2, 1, \"I\", \"E\", \"Y\")) {\nresult.append('J');\nindex += 3;\n//-- \"Edgar\" --//\n} else {\nresult.append(\"TK\");\nindex += 2;\n}\n} else if (contains(value, index, 2, \"DT\", \"DD\")) {\nresult.append('T');\nindex += 2;\n} else {\nresult.append('T');\nindex++;\n}\nreturn index;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:handleG(Ljava/lang/String;Lorg/apache/commons/codec/language/DoubleMetaphone$DoubleMetaphoneResult;IZ)I",
                                    "method_body": "private int handleG(String value,\nDoubleMetaphoneResult result,\nint index,\nboolean slavoGermanic) {\nif (charAt(value, index + 1) == 'H') {\nindex = handleGH(value, result, index);\n} else if (charAt(value, index + 1) == 'N') {\nif (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\nresult.append(\"KN\", \"N\");\n} else if (!contains(value, index + 2, 2, \"EY\") &&\ncharAt(value, index + 1) != 'Y' && !slavoGermanic) {\nresult.append(\"N\", \"KN\");\n} else {\nresult.append(\"KN\");\n}\nindex = index + 2;\n} else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) {\nresult.append(\"KL\", \"L\");\nindex += 2;\n} else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\n//-- -ges-, -gep-, -gel-, -gie- at beginning --//\nresult.append('K', 'J');\nindex += 2;\n} else if ((contains(value, index + 1, 2, \"ER\") ||\ncharAt(value, index + 1) == 'Y') &&\n!contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n!contains(value, index - 1, 1, \"E\", \"I\") &&\n!contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n//-- -ger-, -gy- --//\nresult.append('K', 'J');\nindex += 2;\n} else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") ||\ncontains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n//-- Italian \"biaggi\" --//\nif ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n//-- obvious germanic --//\nresult.append('K');\n} else if (contains(value, index + 1, 4, \"IER\")) {\nresult.append('J');\n} else {\nresult.append('J', 'K');\n}\nindex += 2;\n} else if (charAt(value, index + 1) == 'G') {\nindex += 2;\nresult.append('K');\n} else {\nindex++;\nresult.append('K');\n}\nreturn index;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:handleH(Ljava/lang/String;Lorg/apache/commons/codec/language/DoubleMetaphone$DoubleMetaphoneResult;I)I",
                                    "method_body": "private int handleH(String value,\nDoubleMetaphoneResult result,\nint index) {\n//-- only keep if first & before vowel or between 2 vowels --//\nif ((index == 0 || isVowel(charAt(value, index - 1))) &&\nisVowel(charAt(value, index + 1))) {\nresult.append('H');\nindex += 2;\n//-- also takes car of \"HH\" --//\n} else {\nindex++;\n}\nreturn index;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:handleL(Ljava/lang/String;Lorg/apache/commons/codec/language/DoubleMetaphone$DoubleMetaphoneResult;I)I",
                                    "method_body": "private int handleL(String value,\nDoubleMetaphoneResult result,\nint index) {\nif (charAt(value, index + 1) == 'L') {\nif (conditionL0(value, index)) {\nresult.appendPrimary('L');\n} else {\nresult.append('L');\n}\nindex += 2;\n} else {\nindex++;\nresult.append('L');\n}\nreturn index;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:handleP(Ljava/lang/String;Lorg/apache/commons/codec/language/DoubleMetaphone$DoubleMetaphoneResult;I)I",
                                    "method_body": "private int handleP(String value,\nDoubleMetaphoneResult result,\nint index) {\nif (charAt(value, index + 1) == 'H') {\nresult.append('F');\nindex += 2;\n} else {\nresult.append('P');\nindex = contains(value, index + 1, 1, \"P\", \"B\") ? index + 2 : index + 1;\n}\nreturn index;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:handleR(Ljava/lang/String;Lorg/apache/commons/codec/language/DoubleMetaphone$DoubleMetaphoneResult;IZ)I",
                                    "method_body": "private int handleR(String value,\nDoubleMetaphoneResult result,\nint index,\nboolean slavoGermanic) {\nif (index == value.length() - 1 && !slavoGermanic &&\ncontains(value, index - 2, 2, \"IE\") &&\n!contains(value, index - 4, 2, \"ME\", \"MA\")) {\nresult.appendAlternate('R');\n} else {\nresult.append('R');\n}\nreturn charAt(value, index + 1) == 'R' ? index + 2 : index + 1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:handleS(Ljava/lang/String;Lorg/apache/commons/codec/language/DoubleMetaphone$DoubleMetaphoneResult;IZ)I",
                                    "method_body": "private int handleS(String value,\nDoubleMetaphoneResult result,\nint index,\nboolean slavoGermanic) {\nif (contains(value, index - 1, 3, \"ISL\", \"YSL\")) {\n//-- special cases \"island\", \"isle\", \"carlisle\", \"carlysle\" --//\nindex++;\n} else if (index == 0 && contains(value, index, 5, \"SUGAR\")) {\n//-- special case \"sugar-\" --//\nresult.append('X', 'S');\nindex++;\n} else if (contains(value, index, 2, \"SH\")) {\nif (contains(value, index + 1, 4,\n\"HEIM\", \"HOEK\", \"HOLM\", \"HOLZ\")) {\n//-- germanic --//\nresult.append('S');\n} else {\nresult.append('X');\n}\nindex += 2;\n} else if (contains(value, index, 3, \"SIO\", \"SIA\") || contains(value, index, 4, \"SIAN\")) {\n//-- Italian and Armenian --//\nif (slavoGermanic) {\nresult.append('S');\n} else {\nresult.append('S', 'X');\n}\nindex += 3;\n} else if ((index == 0 && contains(value, index + 1, 1, \"M\", \"N\", \"L\", \"W\")) || contains(value, index + 1, 1, \"Z\")) {\n//-- german & anglicisations, e.g. \"smith\" match \"schmidt\" //\n// \"snider\" match \"schneider\" --//\n//-- also, -sz- in slavic language altho in hungarian it //\n//   is pronounced \"s\" --//\nresult.append('S', 'X');\nindex = contains(value, index + 1, 1, \"Z\") ? index + 2 : index + 1;\n} else if (contains(value, index, 2, \"SC\")) {\nindex = handleSC(value, result, index);\n} else {\nif (index == value.length() - 1 && contains(value, index - 2,\n2, \"AI\", \"OI\")){\n//-- french e.g. \"resnais\", \"artois\" --//\nresult.appendAlternate('S');\n} else {\nresult.append('S');\n}\nindex = contains(value, index + 1, 1, \"S\", \"Z\") ? index + 2 : index + 1;\n}\nreturn index;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:handleT(Ljava/lang/String;Lorg/apache/commons/codec/language/DoubleMetaphone$DoubleMetaphoneResult;I)I",
                                    "method_body": "private int handleT(String value,\nDoubleMetaphoneResult result,\nint index) {\nif (contains(value, index, 4, \"TION\")) {\nresult.append('X');\nindex += 3;\n} else if (contains(value, index, 3, \"TIA\", \"TCH\")) {\nresult.append('X');\nindex += 3;\n} else if (contains(value, index, 2, \"TH\") || contains(value, index,\n3, \"TTH\")) {\nif (contains(value, index + 2, 2, \"OM\", \"AM\") ||\n//-- special case \"thomas\", \"thames\" or germanic --//\ncontains(value, 0, 4, \"VAN \", \"VON \") ||\ncontains(value, 0, 3, \"SCH\")) {\nresult.append('T');\n} else {\nresult.append('0', 'T');\n}\nindex += 2;\n} else {\nresult.append('T');\nindex = contains(value, index + 1, 1, \"T\", \"D\") ? index + 2 : index + 1;\n}\nreturn index;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:handleW(Ljava/lang/String;Lorg/apache/commons/codec/language/DoubleMetaphone$DoubleMetaphoneResult;I)I",
                                    "method_body": "private int handleW(String value,\nDoubleMetaphoneResult result,\nint index) {\nif (contains(value, index, 2, \"WR\")) {\n//-- can also be in middle of word --//\nresult.append('R');\nindex += 2;\n} else {\nif (index == 0 && (isVowel(charAt(value, index + 1)) ||\ncontains(value, index, 2, \"WH\"))) {\nif (isVowel(charAt(value, index + 1))) {\n//-- Wasserman should match Vasserman --//\nresult.append('A', 'F');\n} else {\n//-- need Uomo to match Womo --//\nresult.append('A');\n}\nindex++;\n} else if ((index == value.length() - 1 && isVowel(charAt(value, index - 1))) ||\ncontains(value, index - 1,\n5, \"EWSKI\", \"EWSKY\", \"OWSKI\", \"OWSKY\") ||\ncontains(value, 0, 3, \"SCH\")) {\n//-- Arnow should match Arnoff --//\nresult.appendAlternate('F');\nindex++;\n} else if (contains(value, index, 4, \"WICZ\", \"WITZ\")) {\n//-- Polish e.g. \"filipowicz\" --//\nresult.append(\"TS\", \"FX\");\nindex += 4;\n} else {\nindex++;\n}\n}\nreturn index;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:conditionC0(Ljava/lang/String;I)Z",
                                    "method_body": "private boolean conditionC0(String value, int index) {\nif (contains(value, index, 4, \"CHIA\")) {\nreturn true;\n} else if (index <= 1) {\nreturn false;\n} else if (isVowel(charAt(value, index - 2))) {\nreturn false;\n} else if (!contains(value, index - 1, 3, \"ACH\")) {\nreturn false;\n} else {\nchar c = charAt(value, index + 2);\nreturn (c != 'I' && c != 'E') ||\ncontains(value, index - 2, 6, \"BACHER\", \"MACHER\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:conditionL0(Ljava/lang/String;I)Z",
                                    "method_body": "private boolean conditionL0(String value, int index) {\nif (index == value.length() - 3 &&\ncontains(value, index - 1, 4, \"ILLO\", \"ILLA\", \"ALLE\")) {\nreturn true;\n} else if ((contains(value, value.length() - 2, 2, \"AS\", \"OS\") ||\ncontains(value, value.length() - 1, 1, \"A\", \"O\")) &&\ncontains(value, index - 1, 4, \"ALLE\")) {\nreturn true;\n} else {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:conditionM0(Ljava/lang/String;I)Z",
                                    "method_body": "private boolean conditionM0(String value, int index) {\nif (charAt(value, index + 1) == 'M') {\nreturn true;\n}\nreturn contains(value, index - 1, 3, \"UMB\") &&\n((index + 1) == value.length() - 1 || contains(value,\nindex + 2, 2, \"ER\"));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:isSlavoGermanic(Ljava/lang/String;)Z",
                                    "method_body": "private boolean isSlavoGermanic(String value) {\nreturn value.indexOf('W') > -1 || value.indexOf('K') > -1 ||\nvalue.indexOf(\"CZ\") > -1 || value.indexOf(\"WITZ\") > -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:isVowel(C)Z",
                                    "method_body": "private boolean isVowel(char ch) {\nreturn VOWELS.indexOf(ch) != -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:isSilentStart(Ljava/lang/String;)Z",
                                    "method_body": "private boolean isSilentStart(String value) {\nboolean result = false;\nfor (int i = 0; i < SILENT_START.length; i++) {\nif (value.startsWith(SILENT_START[i])) {\nresult = true;\nbreak;\n}\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:cleanInput(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private String cleanInput(String input) {\nif (input == null) {\nreturn null;\n}\ninput = input.trim();\nif (input.length() == 0) {\nreturn null;\n}\nreturn input.toUpperCase(java.util.Locale.ENGLISH);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:charAt(Ljava/lang/String;I)C",
                                    "method_body": "protected char charAt(String value, int index) {\nif (index < 0 || index >= value.length()) {\nreturn Character.MIN_VALUE;\n}\nreturn value.charAt(index);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:contains(Ljava/lang/String;IILjava/lang/String;)Z",
                                    "method_body": "private static boolean contains(String value, int start, int length,\nString criteria) {\nreturn contains(value, start, length,\nnew String[] { criteria });\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:contains(Ljava/lang/String;IILjava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean contains(String value, int start, int length,\nString criteria1, String criteria2) {\nreturn contains(value, start, length,\nnew String[] { criteria1, criteria2 });\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:contains(Ljava/lang/String;IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean contains(String value, int start, int length,\nString criteria1, String criteria2,\nString criteria3) {\nreturn contains(value, start, length,\nnew String[] { criteria1, criteria2, criteria3 });\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:contains(Ljava/lang/String;IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "private static boolean contains(String value, int start, int length,\nString criteria1, String criteria2,\nString criteria3, String criteria4) {\nreturn contains(value, start, length,\nnew String[] { criteria1, criteria2, criteria3,\ncriteria4 });\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:contains(Ljava/lang/String;II[Ljava/lang/String;)Z",
                                    "method_body": "protected static boolean contains(String value, int start, int length,\nString[] criteria) {\nboolean result = false;\nif (start >= 0 && start + length <= value.length()) {\nString target = value.substring(start, start + length);\n\nfor (int i = 0; i < criteria.length; i++) {\nif (target.equals(criteria[i])) {\nresult = true;\nbreak;\n}\n}\n}\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult:<init>(Lorg/apache/commons/codec/language/DoubleMetaphone;I)V",
                                    "method_body": "public DoubleMetaphoneResult(int maxLength) {\nthis.maxLength = maxLength;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult:append(C)V",
                                    "method_body": "public void append(char value) {\nappendPrimary(value);\nappendAlternate(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult:append(CC)V",
                                    "method_body": "public void append(char primary, char alternate) {\nappendPrimary(primary);\nappendAlternate(alternate);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult:appendPrimary(C)V",
                                    "method_body": "public void appendPrimary(char value) {\nif (this.primary.length() < this.maxLength) {\nthis.primary.append(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult:appendAlternate(C)V",
                                    "method_body": "public void appendAlternate(char value) {\nif (this.alternate.length() < this.maxLength) {\nthis.alternate.append(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult:getAlternate()Ljava/lang/String;",
                                    "method_body": "public String getAlternate() {\nreturn this.alternate.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult:isComplete()Z",
                                    "method_body": "public boolean isComplete() {\nreturn this.primary.length() >= this.maxLength &&\nthis.alternate.length() >= this.maxLength;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 4,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.binary.Base64Codec13Test.testBinaryEncoder",
                            "test_body": "407: public void testBinaryEncoder() throws EncoderException {\n408: BinaryEncoder enc = new Base64();\n409: for (int i = 0; i < STRINGS.length; i++) {\n410: if (STRINGS[i] != null) {\n411: byte[] base64 = utf8(STRINGS[i]);\n412: byte[] binary = BYTES[i];\n413: boolean b = Arrays.equals(base64, enc.encode(binary));\n414: assertTrue(\"BinaryEncoder test-\" + i, b);\n415: }\n416: }\n417: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>()V",
                                    "method_body": "public Base64() {\nthis(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(Z)V",
                                    "method_body": "public Base64(boolean urlSafe) {\nthis(CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[BZ)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\nif (lineSeparator == null) {\nlineLength = 0;  // disable chunk-separating\nlineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n}\nthis.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\nthis.lineSeparator = new byte[lineSeparator.length];\nSystem.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\nif (lineLength > 0) {\nthis.encodeSize = 4 + lineSeparator.length;\n} else {\nthis.encodeSize = 4;\n}\nthis.decodeSize = this.encodeSize - 1;\nif (containsBase64Byte(lineSeparator)) {\nString sep = StringUtils.newStringUtf8(lineSeparator);\nthrow new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n}\nthis.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<clinit>()V",
                                    "method_body": "static final int CHUNK_SIZE = 76;\n\n/**\n* Chunk separator per RFC 2045 section 2.1.\n*\n* <p>\n* N.B. The next major release may break compatibility and make this field private.\n* </p>\n*\n* @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n*/\nstatic final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isUrlSafe()Z",
                                    "method_body": "public boolean isUrlSafe() {\nreturn this.encodeTable == URL_SAFE_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:setInitialBuffer([BII)V",
                                    "method_body": "void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n// We can re-use consumer's original output array under\n// special circumstances, saving on some System.arraycopy().\nif (out != null && out.length == outAvail) {\nbuffer = out;\npos = outPos;\nreadPos = outPos;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode([BII)V",
                                    "method_body": "void encode(byte[] in, int inPos, int inAvail) {\nif (eof) {\nreturn;\n}\n// inAvail < 0 is how we're informed of EOF in the underlying data we're\n// encoding.\nif (inAvail < 0) {\neof = true;\nif (buffer == null || buffer.length - pos < encodeSize) {\nresizeBuffer();\n}\nswitch (modulus) {\ncase 1 :\nbuffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n// URL-SAFE skips the padding to further reduce size.\nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuffer[pos++] = PAD;\nbuffer[pos++] = PAD;\n}\nbreak;\n\ncase 2 :\nbuffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n// URL-SAFE skips the padding to further reduce size.\nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuffer[pos++] = PAD;\n}\nbreak;\n}\nif (lineLength > 0 && pos > 0) {\nSystem.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\npos += lineSeparator.length;\n}\n} else {\nfor (int i = 0; i < inAvail; i++) {\nif (buffer == null || buffer.length - pos < encodeSize) {\nresizeBuffer();\n}\nmodulus = (++modulus) % 3;\nint b = in[inPos++];\nif (b < 0) {\nb += 256;\n}\nx = (x << 8) + b;\nif (0 == modulus) {\nbuffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\nbuffer[pos++] = encodeTable[x & MASK_6BITS];\ncurrentLinePos += 4;\nif (lineLength > 0 && lineLength <= currentLinePos) {\nSystem.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\npos += lineSeparator.length;\ncurrentLinePos = 0;\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isBase64(B)Z",
                                    "method_body": "public static boolean isBase64(byte octet) {\nreturn octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:containsBase64Byte([B)Z",
                                    "method_body": "private static boolean containsBase64Byte(byte[] arrayOctet) {\nfor (int i = 0; i < arrayOctet.length; i++) {\nif (isBase64(arrayOctet[i])) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode([B)[B",
                                    "method_body": "public byte[] encode(byte[] pArray) {\nreset();\nif (pArray == null || pArray.length == 0) {\nreturn pArray;\n}\nlong len = getEncodeLength(pArray, lineLength, lineSeparator);\nbyte[] buf = new byte[(int) len];\nsetInitialBuffer(buf, 0, buf.length);\nencode(pArray, 0, pArray.length);\nencode(pArray, 0, -1); // Notify encoder of EOF.\n// Encoder might have resized, even though it was unnecessary.\nif (buffer != buf) {\nreadResults(buf, 0, buf.length);\n}\n// In URL-SAFE mode we skip the padding characters, so sometimes our\n// final length is a bit smaller.\nif (isUrlSafe() && pos < buf.length) {\nbyte[] smallerBuf = new byte[pos];\nSystem.arraycopy(buf, 0, smallerBuf, 0, pos);\nbuf = smallerBuf;\n}\nreturn buf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:getEncodeLength([BI[B)J",
                                    "method_body": "private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\n// base64 always encodes to multiples of 4.\nchunkSize = (chunkSize / 4) * 4;\n\nlong len = (pArray.length * 4) / 3;\nlong mod = len % 4;\nif (mod != 0) {\nlen += 4 - mod;\n}\nif (chunkSize > 0) {\nboolean lenChunksPerfectly = len % chunkSize == 0;\nlen += (len / chunkSize) * chunkSeparator.length;\nif (!lenChunksPerfectly) {\nlen += chunkSeparator.length;\n}\n}\nreturn len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:reset()V",
                                    "method_body": "private void reset() {\nbuffer = null;\npos = 0;\nreadPos = 0;\ncurrentLinePos = 0;\nmodulus = 0;\neof = false;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.binary.Base64Codec13Test.testEncoder",
                            "test_body": "371: public void testEncoder() throws EncoderException {\n372: Encoder enc = new Base64();\n373: for (int i = 0; i < STRINGS.length; i++) {\n374: if (STRINGS[i] != null) {\n375: byte[] base64 = utf8(STRINGS[i]);\n376: byte[] binary = BYTES[i];\n377: boolean b = Arrays.equals(base64, (byte[]) enc.encode(binary));\n378: assertTrue(\"Encoder test-\" + i, b);\n379: }\n380: }\n381: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>()V",
                                    "method_body": "public Base64() {\nthis(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(Z)V",
                                    "method_body": "public Base64(boolean urlSafe) {\nthis(CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[BZ)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\nif (lineSeparator == null) {\nlineLength = 0;  // disable chunk-separating\nlineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n}\nthis.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\nthis.lineSeparator = new byte[lineSeparator.length];\nSystem.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\nif (lineLength > 0) {\nthis.encodeSize = 4 + lineSeparator.length;\n} else {\nthis.encodeSize = 4;\n}\nthis.decodeSize = this.encodeSize - 1;\nif (containsBase64Byte(lineSeparator)) {\nString sep = StringUtils.newStringUtf8(lineSeparator);\nthrow new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n}\nthis.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<clinit>()V",
                                    "method_body": "static final int CHUNK_SIZE = 76;\n\n/**\n* Chunk separator per RFC 2045 section 2.1.\n*\n* <p>\n* N.B. The next major release may break compatibility and make this field private.\n* </p>\n*\n* @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n*/\nstatic final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isUrlSafe()Z",
                                    "method_body": "public boolean isUrlSafe() {\nreturn this.encodeTable == URL_SAFE_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:setInitialBuffer([BII)V",
                                    "method_body": "void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n// We can re-use consumer's original output array under\n// special circumstances, saving on some System.arraycopy().\nif (out != null && out.length == outAvail) {\nbuffer = out;\npos = outPos;\nreadPos = outPos;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode([BII)V",
                                    "method_body": "void encode(byte[] in, int inPos, int inAvail) {\nif (eof) {\nreturn;\n}\n// inAvail < 0 is how we're informed of EOF in the underlying data we're\n// encoding.\nif (inAvail < 0) {\neof = true;\nif (buffer == null || buffer.length - pos < encodeSize) {\nresizeBuffer();\n}\nswitch (modulus) {\ncase 1 :\nbuffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n// URL-SAFE skips the padding to further reduce size.\nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuffer[pos++] = PAD;\nbuffer[pos++] = PAD;\n}\nbreak;\n\ncase 2 :\nbuffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n// URL-SAFE skips the padding to further reduce size.\nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuffer[pos++] = PAD;\n}\nbreak;\n}\nif (lineLength > 0 && pos > 0) {\nSystem.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\npos += lineSeparator.length;\n}\n} else {\nfor (int i = 0; i < inAvail; i++) {\nif (buffer == null || buffer.length - pos < encodeSize) {\nresizeBuffer();\n}\nmodulus = (++modulus) % 3;\nint b = in[inPos++];\nif (b < 0) {\nb += 256;\n}\nx = (x << 8) + b;\nif (0 == modulus) {\nbuffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\nbuffer[pos++] = encodeTable[x & MASK_6BITS];\ncurrentLinePos += 4;\nif (lineLength > 0 && lineLength <= currentLinePos) {\nSystem.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\npos += lineSeparator.length;\ncurrentLinePos = 0;\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isBase64(B)Z",
                                    "method_body": "public static boolean isBase64(byte octet) {\nreturn octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:containsBase64Byte([B)Z",
                                    "method_body": "private static boolean containsBase64Byte(byte[] arrayOctet) {\nfor (int i = 0; i < arrayOctet.length; i++) {\nif (isBase64(arrayOctet[i])) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode(Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public Object encode(Object pObject) throws EncoderException {\nif (!(pObject instanceof byte[])) {\nthrow new EncoderException(\"Parameter supplied to Base64 encode is not a byte[]\");\n}\nreturn encode((byte[]) pObject);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode([B)[B",
                                    "method_body": "public byte[] encode(byte[] pArray) {\nreset();\nif (pArray == null || pArray.length == 0) {\nreturn pArray;\n}\nlong len = getEncodeLength(pArray, lineLength, lineSeparator);\nbyte[] buf = new byte[(int) len];\nsetInitialBuffer(buf, 0, buf.length);\nencode(pArray, 0, pArray.length);\nencode(pArray, 0, -1); // Notify encoder of EOF.\n// Encoder might have resized, even though it was unnecessary.\nif (buffer != buf) {\nreadResults(buf, 0, buf.length);\n}\n// In URL-SAFE mode we skip the padding characters, so sometimes our\n// final length is a bit smaller.\nif (isUrlSafe() && pos < buf.length) {\nbyte[] smallerBuf = new byte[pos];\nSystem.arraycopy(buf, 0, smallerBuf, 0, pos);\nbuf = smallerBuf;\n}\nreturn buf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:getEncodeLength([BI[B)J",
                                    "method_body": "private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\n// base64 always encodes to multiples of 4.\nchunkSize = (chunkSize / 4) * 4;\n\nlong len = (pArray.length * 4) / 3;\nlong mod = len % 4;\nif (mod != 0) {\nlen += 4 - mod;\n}\nif (chunkSize > 0) {\nboolean lenChunksPerfectly = len % chunkSize == 0;\nlen += (len / chunkSize) * chunkSeparator.length;\nif (!lenChunksPerfectly) {\nlen += chunkSeparator.length;\n}\n}\nreturn len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:reset()V",
                                    "method_body": "private void reset() {\nbuffer = null;\npos = 0;\nreadPos = 0;\ncurrentLinePos = 0;\nmodulus = 0;\neof = false;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 5,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.binary.Base64OutputStreamTest.testCodec98NPE",
                            "test_body": "55: public void testCodec98NPE() throws Exception {\n56: byte[] codec98 = StringUtils.getBytesUtf8(Base64TestData.CODEC_98_NPE);\n57: byte[] codec98_1024 = new byte[1024];\n58: System.arraycopy(codec98, 0, codec98_1024, 0, codec98.length);\n59: ByteArrayOutputStream data = new ByteArrayOutputStream(1024);\n60: Base64OutputStream stream = new Base64OutputStream(data, false);\n61: stream.write(codec98_1024, 0, 1024);\n62: stream.close();\n63: 64: byte[] decodedBytes = data.toByteArray();\n65: String decoded = StringUtils.newStringUtf8(decodedBytes);\n66: assertEquals(\n67: \"codec-98 NPE Base64OutputStream\", Base64TestData.CODEC_98_NPE_DECODED, decoded\n68: );\n69: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(Z)V",
                                    "method_body": "public Base64(boolean urlSafe) {\nthis(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[BZ)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\nif (lineSeparator == null) {\nlineLength = 0;  // disable chunk-separating\nlineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n}\nthis.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\nthis.lineSeparator = new byte[lineSeparator.length];\nSystem.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\nif (lineLength > 0) {\nthis.encodeSize = 4 + lineSeparator.length;\n} else {\nthis.encodeSize = 4;\n}\nthis.decodeSize = this.encodeSize - 1;\nif (containsBase64Byte(lineSeparator)) {\nString sep = StringUtils.newStringUtf8(lineSeparator);\nthrow new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n}\nthis.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<clinit>()V",
                                    "method_body": "public static final int PEM_CHUNK_SIZE = 64;\n\n/**\n* Chunk separator per RFC 2045 section 2.1.\n*\n* <p>\n* N.B. The next major release may break compatibility and make this field private.\n* </p>\n*\n* @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n*/\nstatic final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:avail()I",
                                    "method_body": "int avail() {\nreturn buffer != null ? pos - readPos : 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:readResults([BII)I",
                                    "method_body": "int readResults(byte[] b, int bPos, int bAvail) {\nif (buffer != null) {\nint len = Math.min(avail(), bAvail);\nif (buffer != b) {\nSystem.arraycopy(buffer, readPos, b, bPos, len);\nreadPos += len;\nif (readPos >= pos) {\nbuffer = null;\n}\n} else {\n// Re-using the original consumer's output array is only\n// allowed for one round.\nbuffer = null;\n}\nreturn len;\n}\nreturn eof ? -1 : 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:decode([BII)V",
                                    "method_body": "void decode(byte[] in, int inPos, int inAvail) {\nif (eof) {\nreturn;\n}\nif (inAvail < 0) {\neof = true;\n}\nfor (int i = 0; i < inAvail; i++) {\nif (buffer == null || buffer.length - pos < decodeSize) {\nresizeBuffer();\n}\nbyte b = in[inPos++];\nif (b == PAD) {\n// We're done.\neof = true;\nbreak;\n} else {\nif (b >= 0 && b < DECODE_TABLE.length) {\nint result = DECODE_TABLE[b];\nif (result >= 0) {\nmodulus = (++modulus) % 4;\nx = (x << 6) + result;\nif (modulus == 0) {\nbuffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\nbuffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\nbuffer[pos++] = (byte) (x & MASK_8BITS);\n}\n}\n}\n}\n}\n\n// Two forms of EOF as far as base64 decoder is concerned: actual\n// EOF (-1) and first time '=' character is encountered in stream.\n// This approach makes the '=' padding characters completely optional.\nif (eof && modulus != 0) {\n\nx = x << 6;\nswitch (modulus) {\ncase 2 :\nx = x << 6;\nbuffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\nbreak;\ncase 3 :\nbuffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\nbuffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\nbreak;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isBase64(B)Z",
                                    "method_body": "public static boolean isBase64(byte octet) {\nreturn octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:containsBase64Byte([B)Z",
                                    "method_body": "private static boolean containsBase64Byte(byte[] arrayOctet) {\nfor (int i = 0; i < arrayOctet.length; i++) {\nif (isBase64(arrayOctet[i])) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUtf8(Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUtf8(String string) {\nreturn StringUtils.getBytesUnchecked(string, CharEncoding.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUnchecked(Ljava/lang/String;Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUnchecked(String string, String charsetName) {\nif (string == null) {\nreturn null;\n}\ntry {\nreturn string.getBytes(charsetName);\n} catch (UnsupportedEncodingException e) {\nthrow StringUtils.newIllegalStateException(charsetName, e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:resizeBuffer()V",
                                    "method_body": "private void resizeBuffer() {\nif (buffer == null) {\nbuffer = new byte[DEFAULT_BUFFER_SIZE];\npos = 0;\nreadPos = 0;\n} else {\nbyte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\nSystem.arraycopy(buffer, 0, b, 0, buffer.length);\nbuffer = b;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64OutputStream:<init>(Ljava/io/OutputStream;Z)V",
                                    "method_body": "public Base64OutputStream(OutputStream out, boolean doEncode) {\nsuper(out);\nthis.doEncode = doEncode;\nthis.base64 = new Base64(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64OutputStream:write([BII)V",
                                    "method_body": "public void write(byte b[], int offset, int len) throws IOException {\nif (b == null) {\nthrow new NullPointerException();\n} else if (offset < 0 || len < 0) {\nthrow new IndexOutOfBoundsException();\n} else if (offset > b.length || offset + len > b.length) {\nthrow new IndexOutOfBoundsException();\n} else if (len > 0) {\nif (doEncode) {\nbase64.encode(b, offset, len);\n} else {\nbase64.decode(b, offset, len);\n}\nflush(false);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64OutputStream:flush(Z)V",
                                    "method_body": "private void flush(boolean propogate) throws IOException {\nint avail = base64.avail();\nif (avail > 0) {\nbyte[] buf = new byte[avail];\nint c = base64.readResults(buf, 0, avail);\nif (c > 0) {\nout.write(buf, 0, c);\n}\n}\nif (propogate) {\nout.flush();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64OutputStream:close()V",
                                    "method_body": "public void close() throws IOException {\n// Notify encoder of EOF (-1).\nif (doEncode) {\nbase64.encode(singleByte, 0, -1);\n} else {\nbase64.decode(singleByte, 0, -1);\n}\nflush();\nout.close();\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.binary.Base64InputStreamTest.testCodec98NPE",
                            "test_body": "55: public void testCodec98NPE() throws Exception {\n56: byte[] codec98 = StringUtils.getBytesUtf8(Base64TestData.CODEC_98_NPE);\n57: ByteArrayInputStream data = new ByteArrayInputStream(codec98);\n58: Base64InputStream stream = new Base64InputStream(data);\n59: 60: // This line causes an NPE in commons-codec-1.4.jar:\n61: byte[] decodedBytes = Base64TestData.streamToBytes(stream, new byte[1024]);\n62: 63: String decoded = StringUtils.newStringUtf8(decodedBytes);\n64: assertEquals(\n65: \"codec-98 NPE Base64InputStream\", Base64TestData.CODEC_98_NPE_DECODED, decoded\n66: );\n67: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(Z)V",
                                    "method_body": "public Base64(boolean urlSafe) {\nthis(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[BZ)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\nif (lineSeparator == null) {\nlineLength = 0;  // disable chunk-separating\nlineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n}\nthis.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\nthis.lineSeparator = new byte[lineSeparator.length];\nSystem.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\nif (lineLength > 0) {\nthis.encodeSize = 4 + lineSeparator.length;\n} else {\nthis.encodeSize = 4;\n}\nthis.decodeSize = this.encodeSize - 1;\nif (containsBase64Byte(lineSeparator)) {\nString sep = StringUtils.newStringUtf8(lineSeparator);\nthrow new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n}\nthis.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<clinit>()V",
                                    "method_body": "public static final int PEM_CHUNK_SIZE = 64;\n\n/**\n* Chunk separator per RFC 2045 section 2.1.\n*\n* <p>\n* N.B. The next major release may break compatibility and make this field private.\n* </p>\n*\n* @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n*/\nstatic final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:hasData()Z",
                                    "method_body": "boolean hasData() {\nreturn this.buffer != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:avail()I",
                                    "method_body": "int avail() {\nreturn buffer != null ? pos - readPos : 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:readResults([BII)I",
                                    "method_body": "int readResults(byte[] b, int bPos, int bAvail) {\nif (buffer != null) {\nint len = Math.min(avail(), bAvail);\nif (buffer != b) {\nSystem.arraycopy(buffer, readPos, b, bPos, len);\nreadPos += len;\nif (readPos >= pos) {\nbuffer = null;\n}\n} else {\n// Re-using the original consumer's output array is only\n// allowed for one round.\nbuffer = null;\n}\nreturn len;\n}\nreturn eof ? -1 : 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:setInitialBuffer([BII)V",
                                    "method_body": "void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n// We can re-use consumer's original output array under\n// special circumstances, saving on some System.arraycopy().\nif (out != null && out.length == outAvail) {\nbuffer = out;\npos = outPos;\nreadPos = outPos;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:decode([BII)V",
                                    "method_body": "void decode(byte[] in, int inPos, int inAvail) {\nif (eof) {\nreturn;\n}\nif (inAvail < 0) {\neof = true;\n}\nfor (int i = 0; i < inAvail; i++) {\nif (buffer == null || buffer.length - pos < decodeSize) {\nresizeBuffer();\n}\nbyte b = in[inPos++];\nif (b == PAD) {\n// We're done.\neof = true;\nbreak;\n} else {\nif (b >= 0 && b < DECODE_TABLE.length) {\nint result = DECODE_TABLE[b];\nif (result >= 0) {\nmodulus = (++modulus) % 4;\nx = (x << 6) + result;\nif (modulus == 0) {\nbuffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\nbuffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\nbuffer[pos++] = (byte) (x & MASK_8BITS);\n}\n}\n}\n}\n}\n\n// Two forms of EOF as far as base64 decoder is concerned: actual\n// EOF (-1) and first time '=' character is encountered in stream.\n// This approach makes the '=' padding characters completely optional.\nif (eof && modulus != 0) {\n\nx = x << 6;\nswitch (modulus) {\ncase 2 :\nx = x << 6;\nbuffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\nbreak;\ncase 3 :\nbuffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\nbuffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\nbreak;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isBase64(B)Z",
                                    "method_body": "public static boolean isBase64(byte octet) {\nreturn octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:containsBase64Byte([B)Z",
                                    "method_body": "private static boolean containsBase64Byte(byte[] arrayOctet) {\nfor (int i = 0; i < arrayOctet.length; i++) {\nif (isBase64(arrayOctet[i])) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUtf8(Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUtf8(String string) {\nreturn StringUtils.getBytesUnchecked(string, CharEncoding.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUnchecked(Ljava/lang/String;Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUnchecked(String string, String charsetName) {\nif (string == null) {\nreturn null;\n}\ntry {\nreturn string.getBytes(charsetName);\n} catch (UnsupportedEncodingException e) {\nthrow StringUtils.newIllegalStateException(charsetName, e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64InputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public Base64InputStream(InputStream in) {\nthis(in, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64InputStream:<init>(Ljava/io/InputStream;Z)V",
                                    "method_body": "public Base64InputStream(InputStream in, boolean doEncode) {\nsuper(in);\nthis.doEncode = doEncode;\nthis.base64 = new Base64(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64InputStream:read([BII)I",
                                    "method_body": "public int read(byte b[], int offset, int len) throws IOException {\nif (b == null) {\nthrow new NullPointerException();\n} else if (offset < 0 || len < 0) {\nthrow new IndexOutOfBoundsException();\n} else if (offset > b.length || offset + len > b.length) {\nthrow new IndexOutOfBoundsException();\n} else if (len == 0) {\nreturn 0;\n} else {\nif (!base64.hasData()) {\nbyte[] buf = new byte[doEncode ? 4096 : 8192];\nint c = in.read(buf);\n// A little optimization to avoid System.arraycopy()\n// when possible.\nif (c > 0 && b.length == len) {\nbase64.setInitialBuffer(b, offset, len);\n}\nif (doEncode) {\nbase64.encode(buf, 0, c);\n} else {\nbase64.decode(buf, 0, c);\n}\n}\nreturn base64.readResults(b, offset, len);\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 6,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.binary.Base64InputStreamTest.testCodec101",
                            "test_body": "55: public void testCodec101() throws Exception {\n56: byte[] codec101 = StringUtils.getBytesUtf8(Base64TestData.CODEC_101_MULTIPLE_OF_3);\n57: ByteArrayInputStream bais = new ByteArrayInputStream(codec101);\n58: Base64InputStream in = new Base64InputStream(bais);\n59: byte[] result = new byte[8192];\n60: int c = in.read(result);\n61: assertTrue(\"Codec101: First read successful [c=\" + c + \"]\", c > 0);\n62: 63: c = in.read(result);\n64: assertTrue(\"Codec101: Second read should report end-of-stream [c=\" + c + \"]\", c < 0);\n65: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(Z)V",
                                    "method_body": "public Base64(boolean urlSafe) {\nthis(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[BZ)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\nif (lineSeparator == null) {\nlineLength = 0;  // disable chunk-separating\nlineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n}\nthis.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\nthis.lineSeparator = new byte[lineSeparator.length];\nSystem.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\nif (lineLength > 0) {\nthis.encodeSize = 4 + lineSeparator.length;\n} else {\nthis.encodeSize = 4;\n}\nthis.decodeSize = this.encodeSize - 1;\nif (containsBase64Byte(lineSeparator)) {\nString sep = StringUtils.newStringUtf8(lineSeparator);\nthrow new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n}\nthis.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<clinit>()V",
                                    "method_body": "public static final int PEM_CHUNK_SIZE = 64;\n\n/**\n* Chunk separator per RFC 2045 section 2.1.\n*\n* <p>\n* N.B. The next major release may break compatibility and make this field private.\n* </p>\n*\n* @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n*/\nstatic final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:hasData()Z",
                                    "method_body": "boolean hasData() {\nreturn this.buffer != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:avail()I",
                                    "method_body": "int avail() {\nreturn buffer != null ? pos - readPos : 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:readResults([BII)I",
                                    "method_body": "int readResults(byte[] b, int bPos, int bAvail) {\nif (buffer != null) {\nint len = Math.min(avail(), bAvail);\nif (buffer != b) {\nSystem.arraycopy(buffer, readPos, b, bPos, len);\nreadPos += len;\nif (readPos >= pos) {\nbuffer = null;\n}\n} else {\n// Re-using the original consumer's output array is only\n// allowed for one round.\nbuffer = null;\n}\nreturn len;\n}\nreturn eof ? -1 : 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:setInitialBuffer([BII)V",
                                    "method_body": "void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n// We can re-use consumer's original output array under\n// special circumstances, saving on some System.arraycopy().\nif (out != null && out.length == outAvail) {\nbuffer = out;\npos = outPos;\nreadPos = outPos;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:decode([BII)V",
                                    "method_body": "void decode(byte[] in, int inPos, int inAvail) {\nif (eof) {\nreturn;\n}\nif (inAvail < 0) {\neof = true;\n}\nfor (int i = 0; i < inAvail; i++) {\nif (buffer == null || buffer.length - pos < decodeSize) {\nresizeBuffer();\n}\nbyte b = in[inPos++];\nif (b == PAD) {\n// We're done.\neof = true;\nbreak;\n} else {\nif (b >= 0 && b < DECODE_TABLE.length) {\nint result = DECODE_TABLE[b];\nif (result >= 0) {\nmodulus = (++modulus) % 4;\nx = (x << 6) + result;\nif (modulus == 0) {\nbuffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\nbuffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\nbuffer[pos++] = (byte) (x & MASK_8BITS);\n}\n}\n}\n}\n}\n\n// Two forms of EOF as far as base64 decoder is concerned: actual\n// EOF (-1) and first time '=' character is encountered in stream.\n// This approach makes the '=' padding characters completely optional.\nif (eof && modulus != 0) {\nif (buffer == null || buffer.length - pos < decodeSize) {\nresizeBuffer();\n}\n\nx = x << 6;\nswitch (modulus) {\ncase 2 :\nx = x << 6;\nbuffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\nbreak;\ncase 3 :\nbuffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\nbuffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\nbreak;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isBase64(B)Z",
                                    "method_body": "public static boolean isBase64(byte octet) {\nreturn octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:containsBase64Byte([B)Z",
                                    "method_body": "private static boolean containsBase64Byte(byte[] arrayOctet) {\nfor (int i = 0; i < arrayOctet.length; i++) {\nif (isBase64(arrayOctet[i])) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUtf8(Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUtf8(String string) {\nreturn StringUtils.getBytesUnchecked(string, CharEncoding.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUnchecked(Ljava/lang/String;Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUnchecked(String string, String charsetName) {\nif (string == null) {\nreturn null;\n}\ntry {\nreturn string.getBytes(charsetName);\n} catch (UnsupportedEncodingException e) {\nthrow StringUtils.newIllegalStateException(charsetName, e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64InputStream:<init>(Ljava/io/InputStream;)V",
                                    "method_body": "public Base64InputStream(InputStream in) {\nthis(in, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64InputStream:<init>(Ljava/io/InputStream;Z)V",
                                    "method_body": "public Base64InputStream(InputStream in, boolean doEncode) {\nsuper(in);\nthis.doEncode = doEncode;\nthis.base64 = new Base64(false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64InputStream:read([BII)I",
                                    "method_body": "public int read(byte b[], int offset, int len) throws IOException {\nif (b == null) {\nthrow new NullPointerException();\n} else if (offset < 0 || len < 0) {\nthrow new IndexOutOfBoundsException();\n} else if (offset > b.length || offset + len > b.length) {\nthrow new IndexOutOfBoundsException();\n} else if (len == 0) {\nreturn 0;\n} else {\n/*\nRationale for while-loop on (readLen == 0):\n-----\nBase64.readResults() usually returns > 0 or EOF (-1).  In the\nrare case where it returns 0, we just keep trying.\n\nThis is essentially an undocumented contract for InputStream\nimplementors that want their code to work properly with\njava.io.InputStreamReader, since the latter hates it when\nInputStream.read(byte[]) returns a zero.  Unfortunately our\nreadResults() call must return 0 if a large amount of the data\nbeing decoded was non-base64, so this while-loop enables proper\ninterop with InputStreamReader for that scenario.\n-----\nThis is a fix for CODEC-101\n*/\nif (!base64.hasData()) {\nbyte[] buf = new byte[doEncode ? 4096 : 8192];\nint c = in.read(buf);\n// A little optimization to avoid System.arraycopy()\n// when possible.\nif (c > 0 && b.length == len) {\nbase64.setInitialBuffer(b, offset, len);\n}\nif (doEncode) {\nbase64.encode(buf, 0, c);\n} else {\nbase64.decode(buf, 0, c);\n}\n}\nreturn base64.readResults(b, offset, len);\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 7,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.binary.Base64Test.testRfc4648Section10Encode",
                            "test_body": "584: public void testRfc4648Section10Encode() {\n585: assertEquals(\"\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"\")));\n586: assertEquals(\"Zg==\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"f\")));\n587: assertEquals(\"Zm8=\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"fo\")));\n588: assertEquals(\"Zm9v\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"foo\")));\n589: assertEquals(\"Zm9vYg==\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"foob\")));\n590: assertEquals(\"Zm9vYmE=\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"fooba\")));\n591: assertEquals(\"Zm9vYmFy\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"foobar\")));\n592: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(Z)V",
                                    "method_body": "public Base64(boolean urlSafe) {\nthis(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[BZ)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\nif (lineSeparator == null) {\nlineLength = 0;  // disable chunk-separating\nlineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n}\nthis.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\nthis.lineSeparator = new byte[lineSeparator.length];\nSystem.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\nif (lineLength > 0) {\nthis.encodeSize = 4 + lineSeparator.length;\n} else {\nthis.encodeSize = 4;\n}\nthis.decodeSize = this.encodeSize - 1;\nif (containsBase64Byte(lineSeparator)) {\nString sep = StringUtils.newStringUtf8(lineSeparator);\nthrow new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n}\nthis.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<clinit>()V",
                                    "method_body": "public static final int PEM_CHUNK_SIZE = 64;\n\n/**\n* Chunk separator per RFC 2045 section 2.1.\n*\n* <p>\n* N.B. The next major release may break compatibility and make this field private.\n* </p>\n*\n* @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n*/\nstatic final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isUrlSafe()Z",
                                    "method_body": "public boolean isUrlSafe() {\nreturn this.encodeTable == URL_SAFE_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:setInitialBuffer([BII)V",
                                    "method_body": "void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n// We can re-use consumer's original output array under\n// special circumstances, saving on some System.arraycopy().\nif (out != null && out.length == outAvail) {\nbuffer = out;\npos = outPos;\nreadPos = outPos;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode([BII)V",
                                    "method_body": "void encode(byte[] in, int inPos, int inAvail) {\nif (eof) {\nreturn;\n}\n// inAvail < 0 is how we're informed of EOF in the underlying data we're\n// encoding.\nif (inAvail < 0) {\neof = true;\nif (buffer == null || buffer.length - pos < encodeSize) {\nresizeBuffer();\n}\nswitch (modulus) {\ncase 1 :\nbuffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n// URL-SAFE skips the padding to further reduce size.\nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuffer[pos++] = PAD;\nbuffer[pos++] = PAD;\n}\nbreak;\n\ncase 2 :\nbuffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n// URL-SAFE skips the padding to further reduce size.\nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuffer[pos++] = PAD;\n}\nbreak;\n}\nif (lineLength > 0 && pos > 0) {\nSystem.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\npos += lineSeparator.length;\n}\n} else {\nfor (int i = 0; i < inAvail; i++) {\nif (buffer == null || buffer.length - pos < encodeSize) {\nresizeBuffer();\n}\nmodulus = (++modulus) % 3;\nint b = in[inPos++];\nif (b < 0) {\nb += 256;\n}\nx = (x << 8) + b;\nif (0 == modulus) {\nbuffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\nbuffer[pos++] = encodeTable[x & MASK_6BITS];\ncurrentLinePos += 4;\nif (lineLength > 0 && lineLength <= currentLinePos) {\nSystem.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\npos += lineSeparator.length;\ncurrentLinePos = 0;\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isBase64(B)Z",
                                    "method_body": "public static boolean isBase64(byte octet) {\nreturn octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:containsBase64Byte([B)Z",
                                    "method_body": "private static boolean containsBase64Byte(byte[] arrayOctet) {\nfor (int i = 0; i < arrayOctet.length; i++) {\nif (isBase64(arrayOctet[i])) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encodeBase64String([B)Ljava/lang/String;",
                                    "method_body": "public static String encodeBase64String(byte[] binaryData) {\nreturn StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encodeBase64([BZ)[B",
                                    "method_body": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\nreturn encodeBase64(binaryData, isChunked, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encodeBase64([BZZ)[B",
                                    "method_body": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\nreturn encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encodeBase64([BZZI)[B",
                                    "method_body": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\nif (binaryData == null || binaryData.length == 0) {\nreturn binaryData;\n}\n\nlong len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\nif (len > maxResultSize) {\nthrow new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\nlen +\n\") than the specified maxium size of \" +\nmaxResultSize);\n}\n\nBase64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\nreturn b64.encode(binaryData);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode([B)[B",
                                    "method_body": "public byte[] encode(byte[] pArray) {\nreset();\nif (pArray == null || pArray.length == 0) {\nreturn pArray;\n}\nlong len = getEncodeLength(pArray, lineLength, lineSeparator);\nbyte[] buf = new byte[(int) len];\nsetInitialBuffer(buf, 0, buf.length);\nencode(pArray, 0, pArray.length);\nencode(pArray, 0, -1); // Notify encoder of EOF.\n// Encoder might have resized, even though it was unnecessary.\nif (buffer != buf) {\nreadResults(buf, 0, buf.length);\n}\n// In URL-SAFE mode we skip the padding characters, so sometimes our\n// final length is a bit smaller.\nif (isUrlSafe() && pos < buf.length) {\nbyte[] smallerBuf = new byte[pos];\nSystem.arraycopy(buf, 0, smallerBuf, 0, pos);\nbuf = smallerBuf;\n}\nreturn buf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:getEncodeLength([BI[B)J",
                                    "method_body": "private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\n// base64 always encodes to multiples of 4.\nchunkSize = (chunkSize / 4) * 4;\n\nlong len = (pArray.length * 4) / 3;\nlong mod = len % 4;\nif (mod != 0) {\nlen += 4 - mod;\n}\nif (chunkSize > 0) {\nboolean lenChunksPerfectly = len % chunkSize == 0;\nlen += (len / chunkSize) * chunkSeparator.length;\nif (!lenChunksPerfectly) {\nlen += chunkSeparator.length;\n}\n}\nreturn len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:reset()V",
                                    "method_body": "private void reset() {\nbuffer = null;\npos = 0;\nreadPos = 0;\ncurrentLinePos = 0;\nmodulus = 0;\neof = false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUtf8(Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUtf8(String string) {\nreturn StringUtils.getBytesUnchecked(string, CharEncoding.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUnchecked(Ljava/lang/String;Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUnchecked(String string, String charsetName) {\nif (string == null) {\nreturn null;\n}\ntry {\nreturn string.getBytes(charsetName);\n} catch (UnsupportedEncodingException e) {\nthrow StringUtils.newIllegalStateException(charsetName, e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:newString([BLjava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public static String newString(byte[] bytes, String charsetName) {\nif (bytes == null) {\nreturn null;\n}\ntry {\nreturn new String(bytes, charsetName);\n} catch (UnsupportedEncodingException e) {\nthrow StringUtils.newIllegalStateException(charsetName, e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:newStringUtf8([B)Ljava/lang/String;",
                                    "method_body": "public static String newStringUtf8(byte[] bytes) {\nreturn StringUtils.newString(bytes, CharEncoding.UTF_8);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.binary.Base64Test.testByteToStringVariations",
                            "test_body": "1121: public void testByteToStringVariations() throws DecoderException {\n1122: Base64 base64 = new Base64(0);\n1123: byte[] b1 = StringUtils.getBytesUtf8(\"Hello World\");\n1124: byte[] b2 = new byte[0];\n1125: byte[] b3 = null;\n1126: byte[] b4 = Hex.decodeHex(\"2bf7cc2701fe4397b49ebeed5acc7090\".toCharArray());  // for url-safe tests\n1127: 1128: assertEquals(\"byteToString Hello World\", \"SGVsbG8gV29ybGQ=\", base64.encodeToString(b1));\n1129: assertEquals(\"byteToString static Hello World\", \"SGVsbG8gV29ybGQ=\", Base64.encodeBase64String(b1));\n1130: assertEquals(\"byteToString \\\"\\\"\", \"\", base64.encodeToString(b2));\n1131: assertEquals(\"byteToString static \\\"\\\"\", \"\", Base64.encodeBase64String(b2));\n1132: assertEquals(\"byteToString null\", null, base64.encodeToString(b3));\n1133: assertEquals(\"byteToString static null\", null, Base64.encodeBase64String(b3));\n1134: assertEquals(\"byteToString UUID\", \"K/fMJwH+Q5e0nr7tWsxwkA==\", base64.encodeToString(b4));\n1135: assertEquals(\"byteToString static UUID\", \"K/fMJwH+Q5e0nr7tWsxwkA==\", Base64.encodeBase64String(b4));\n1136: assertEquals(\"byteToString static-url-safe UUID\", \"K_fMJwH-Q5e0nr7tWsxwkA\", Base64.encodeBase64URLSafeString(b4));\n1137: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(Z)V",
                                    "method_body": "public Base64(boolean urlSafe) {\nthis(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I)V",
                                    "method_body": "public Base64(int lineLength) {\nthis(lineLength, CHUNK_SEPARATOR);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[B)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator) {\nthis(lineLength, lineSeparator, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[BZ)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\nif (lineSeparator == null) {\nlineLength = 0;  // disable chunk-separating\nlineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n}\nthis.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\nthis.lineSeparator = new byte[lineSeparator.length];\nSystem.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\nif (lineLength > 0) {\nthis.encodeSize = 4 + lineSeparator.length;\n} else {\nthis.encodeSize = 4;\n}\nthis.decodeSize = this.encodeSize - 1;\nif (containsBase64Byte(lineSeparator)) {\nString sep = StringUtils.newStringUtf8(lineSeparator);\nthrow new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n}\nthis.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<clinit>()V",
                                    "method_body": "public static final int PEM_CHUNK_SIZE = 64;\n\n/**\n* Chunk separator per RFC 2045 section 2.1.\n*\n* <p>\n* N.B. The next major release may break compatibility and make this field private.\n* </p>\n*\n* @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n*/\nstatic final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isUrlSafe()Z",
                                    "method_body": "public boolean isUrlSafe() {\nreturn this.encodeTable == URL_SAFE_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:setInitialBuffer([BII)V",
                                    "method_body": "void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n// We can re-use consumer's original output array under\n// special circumstances, saving on some System.arraycopy().\nif (out != null && out.length == outAvail) {\nbuffer = out;\npos = outPos;\nreadPos = outPos;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode([BII)V",
                                    "method_body": "void encode(byte[] in, int inPos, int inAvail) {\nif (eof) {\nreturn;\n}\n// inAvail < 0 is how we're informed of EOF in the underlying data we're\n// encoding.\nif (inAvail < 0) {\neof = true;\nif (buffer == null || buffer.length - pos < encodeSize) {\nresizeBuffer();\n}\nswitch (modulus) {\ncase 1 :\nbuffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n// URL-SAFE skips the padding to further reduce size.\nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuffer[pos++] = PAD;\nbuffer[pos++] = PAD;\n}\nbreak;\n\ncase 2 :\nbuffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n// URL-SAFE skips the padding to further reduce size.\nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuffer[pos++] = PAD;\n}\nbreak;\n}\nif (lineLength > 0 && pos > 0) {\nSystem.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\npos += lineSeparator.length;\n}\n} else {\nfor (int i = 0; i < inAvail; i++) {\nif (buffer == null || buffer.length - pos < encodeSize) {\nresizeBuffer();\n}\nmodulus = (++modulus) % 3;\nint b = in[inPos++];\nif (b < 0) {\nb += 256;\n}\nx = (x << 8) + b;\nif (0 == modulus) {\nbuffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\nbuffer[pos++] = encodeTable[x & MASK_6BITS];\ncurrentLinePos += 4;\nif (lineLength > 0 && lineLength <= currentLinePos) {\nSystem.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\npos += lineSeparator.length;\ncurrentLinePos = 0;\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isBase64(B)Z",
                                    "method_body": "public static boolean isBase64(byte octet) {\nreturn octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:containsBase64Byte([B)Z",
                                    "method_body": "private static boolean containsBase64Byte(byte[] arrayOctet) {\nfor (int i = 0; i < arrayOctet.length; i++) {\nif (isBase64(arrayOctet[i])) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encodeBase64String([B)Ljava/lang/String;",
                                    "method_body": "public static String encodeBase64String(byte[] binaryData) {\nreturn StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encodeBase64([BZ)[B",
                                    "method_body": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\nreturn encodeBase64(binaryData, isChunked, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encodeBase64([BZZ)[B",
                                    "method_body": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\nreturn encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encodeBase64([BZZI)[B",
                                    "method_body": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\nif (binaryData == null || binaryData.length == 0) {\nreturn binaryData;\n}\n\nlong len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\nif (len > maxResultSize) {\nthrow new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\nlen +\n\") than the specified maxium size of \" +\nmaxResultSize);\n}\n\nBase64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\nreturn b64.encode(binaryData);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encodeToString([B)Ljava/lang/String;",
                                    "method_body": "public String encodeToString(byte[] pArray) {\nreturn StringUtils.newStringUtf8(encode(pArray));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode([B)[B",
                                    "method_body": "public byte[] encode(byte[] pArray) {\nreset();\nif (pArray == null || pArray.length == 0) {\nreturn pArray;\n}\nlong len = getEncodeLength(pArray, lineLength, lineSeparator);\nbyte[] buf = new byte[(int) len];\nsetInitialBuffer(buf, 0, buf.length);\nencode(pArray, 0, pArray.length);\nencode(pArray, 0, -1); // Notify encoder of EOF.\n// Encoder might have resized, even though it was unnecessary.\nif (buffer != buf) {\nreadResults(buf, 0, buf.length);\n}\n// In URL-SAFE mode we skip the padding characters, so sometimes our\n// final length is a bit smaller.\nif (isUrlSafe() && pos < buf.length) {\nbyte[] smallerBuf = new byte[pos];\nSystem.arraycopy(buf, 0, smallerBuf, 0, pos);\nbuf = smallerBuf;\n}\nreturn buf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:getEncodeLength([BI[B)J",
                                    "method_body": "private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\n// base64 always encodes to multiples of 4.\nchunkSize = (chunkSize / 4) * 4;\n\nlong len = (pArray.length * 4) / 3;\nlong mod = len % 4;\nif (mod != 0) {\nlen += 4 - mod;\n}\nif (chunkSize > 0) {\nboolean lenChunksPerfectly = len % chunkSize == 0;\nlen += (len / chunkSize) * chunkSeparator.length;\nif (!lenChunksPerfectly) {\nlen += chunkSeparator.length;\n}\n}\nreturn len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:reset()V",
                                    "method_body": "private void reset() {\nbuffer = null;\npos = 0;\nreadPos = 0;\ncurrentLinePos = 0;\nmodulus = 0;\neof = false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUtf8(Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUtf8(String string) {\nreturn StringUtils.getBytesUnchecked(string, CharEncoding.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUnchecked(Ljava/lang/String;Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUnchecked(String string, String charsetName) {\nif (string == null) {\nreturn null;\n}\ntry {\nreturn string.getBytes(charsetName);\n} catch (UnsupportedEncodingException e) {\nthrow StringUtils.newIllegalStateException(charsetName, e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:newString([BLjava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public static String newString(byte[] bytes, String charsetName) {\nif (bytes == null) {\nreturn null;\n}\ntry {\nreturn new String(bytes, charsetName);\n} catch (UnsupportedEncodingException e) {\nthrow StringUtils.newIllegalStateException(charsetName, e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:newStringUtf8([B)Ljava/lang/String;",
                                    "method_body": "public static String newStringUtf8(byte[] bytes) {\nreturn StringUtils.newString(bytes, CharEncoding.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Hex:<clinit>()V",
                                    "method_body": "public static final String DEFAULT_CHARSET_NAME = CharEncoding.UTF_8;\n\n/**\n* Used to build output as Hex\n*/\nprivate static final char[] DIGITS_LOWER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Hex:decodeHex([C)[B",
                                    "method_body": "public static byte[] decodeHex(char[] data) throws DecoderException {\n\nint len = data.length;\n\nif ((len & 0x01) != 0) {\nthrow new DecoderException(\"Odd number of characters.\");\n}\n\nbyte[] out = new byte[len >> 1];\n\n// two characters form the hex value.\nfor (int i = 0, j = 0; j < len; i++) {\nint f = toDigit(data[j], j) << 4;\nj++;\nf = f | toDigit(data[j], j);\nj++;\nout[i] = (byte) (f & 0xFF);\n}\n\nreturn out;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Hex:toDigit(CI)I",
                                    "method_body": "protected static int toDigit(char ch, int index) throws DecoderException {\nint digit = Character.digit(ch, 16);\nif (digit == -1) {\nthrow new DecoderException(\"Illegal hexadecimal character \" + ch + \" at index \" + index);\n}\nreturn digit;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 8,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.binary.Base64InputStreamTest.testCodec105",
                            "test_body": "55: public void testCodec105() throws IOException {\n56: Base64InputStream in = new Base64InputStream(new Codec105ErrorInputStream(), true, 0, null);\n57: for (int i = 0; i < 5; i++) {\n58: in.read();\n59: }\n60: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[B)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator) {\nthis(lineLength, lineSeparator, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[BZ)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\nif (lineSeparator == null) {\nlineLength = 0;  // disable chunk-separating\nlineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n}\nthis.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\nthis.lineSeparator = new byte[lineSeparator.length];\nSystem.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\nif (lineLength > 0) {\nthis.encodeSize = 4 + lineSeparator.length;\n} else {\nthis.encodeSize = 4;\n}\nthis.decodeSize = this.encodeSize - 1;\nif (containsBase64Byte(lineSeparator)) {\nString sep = StringUtils.newStringUtf8(lineSeparator);\nthrow new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n}\nthis.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<clinit>()V",
                                    "method_body": "public static final int PEM_CHUNK_SIZE = 64;\n\n/**\n* Chunk separator per RFC 2045 section 2.1.\n*\n* <p>\n* N.B. The next major release may break compatibility and make this field private.\n* </p>\n*\n* @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n*/\nstatic final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:hasData()Z",
                                    "method_body": "boolean hasData() {\nreturn this.buffer != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:avail()I",
                                    "method_body": "int avail() {\nreturn buffer != null ? pos - readPos : 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:resizeBuffer()V",
                                    "method_body": "private void resizeBuffer() {\nif (buffer == null) {\nbuffer = new byte[DEFAULT_BUFFER_SIZE];\npos = 0;\nreadPos = 0;\n} else {\nbyte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\nSystem.arraycopy(buffer, 0, b, 0, buffer.length);\nbuffer = b;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:readResults([BII)I",
                                    "method_body": "int readResults(byte[] b, int bPos, int bAvail) {\nif (buffer != null) {\nint len = Math.min(avail(), bAvail);\nSystem.arraycopy(buffer, readPos, b, bPos, len);\nreadPos += len;\nif (readPos >= pos) {\nbuffer = null;\n}\nreturn len;\n}\nreturn eof ? -1 : 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:setInitialBuffer([BII)V",
                                    "method_body": "void setInitialBuffer(byte[] out, int outPos, int outAvail) {\nif (out != null && out.length == outAvail) {\nbuffer = out;\npos = outPos;\nreadPos = outPos;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode([BII)V",
                                    "method_body": "void encode(byte[] in, int inPos, int inAvail) {\nif (eof) {\nreturn;\n}\n// inAvail < 0 is how we're informed of EOF in the underlying data we're\n// encoding.\nif (inAvail < 0) {\neof = true;\nif (buffer == null || buffer.length - pos < encodeSize) {\nresizeBuffer();\n}\nswitch (modulus) {\ncase 1 :\nbuffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n// URL-SAFE skips the padding to further reduce size.\nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuffer[pos++] = PAD;\nbuffer[pos++] = PAD;\n}\nbreak;\n\ncase 2 :\nbuffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n// URL-SAFE skips the padding to further reduce size.\nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuffer[pos++] = PAD;\n}\nbreak;\n}\n// Don't want to append the CRLF two times in a row, so make sure previous\n// character is not from CRLF!\nbyte b = lineSeparator[lineSeparator.length - 1];\nif (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {\nSystem.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\npos += lineSeparator.length;\n}\n} else {\nfor (int i = 0; i < inAvail; i++) {\nif (buffer == null || buffer.length - pos < encodeSize) {\nresizeBuffer();\n}\nmodulus = (++modulus) % 3;\nint b = in[inPos++];\nif (b < 0) {\nb += 256;\n}\nx = (x << 8) + b;\nif (0 == modulus) {\nbuffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\nbuffer[pos++] = encodeTable[x & MASK_6BITS];\ncurrentLinePos += 4;\nif (lineLength > 0 && lineLength <= currentLinePos) {\nSystem.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\npos += lineSeparator.length;\ncurrentLinePos = 0;\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isBase64(B)Z",
                                    "method_body": "public static boolean isBase64(byte octet) {\nreturn octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:containsBase64Byte([B)Z",
                                    "method_body": "private static boolean containsBase64Byte(byte[] arrayOctet) {\nfor (int i = 0; i < arrayOctet.length; i++) {\nif (isBase64(arrayOctet[i])) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64InputStream:<init>(Ljava/io/InputStream;ZI[B)V",
                                    "method_body": "public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {\nsuper(in);\nthis.doEncode = doEncode;\nthis.base64 = new Base64(lineLength, lineSeparator);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64InputStream:read()I",
                                    "method_body": "public int read() throws IOException {\nint r = read(singleByte, 0, 1);\nwhile (r == 0) {\nr = read(singleByte, 0, 1);\n}\nif (r > 0) {\nreturn singleByte[0] < 0 ? 256 + singleByte[0] : singleByte[0];\n}\nreturn -1;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64InputStream:read([BII)I",
                                    "method_body": "public int read(byte b[], int offset, int len) throws IOException {\nif (b == null) {\nthrow new NullPointerException();\n} else if (offset < 0 || len < 0) {\nthrow new IndexOutOfBoundsException();\n} else if (offset > b.length || offset + len > b.length) {\nthrow new IndexOutOfBoundsException();\n} else if (len == 0) {\nreturn 0;\n} else {\nint readLen = 0;\n/*\nRationale for while-loop on (readLen == 0):\n-----\nBase64.readResults() usually returns > 0 or EOF (-1).  In the\nrare case where it returns 0, we just keep trying.\n\nThis is essentially an undocumented contract for InputStream\nimplementors that want their code to work properly with\njava.io.InputStreamReader, since the latter hates it when\nInputStream.read(byte[]) returns a zero.  Unfortunately our\nreadResults() call must return 0 if a large amount of the data\nbeing decoded was non-base64, so this while-loop enables proper\ninterop with InputStreamReader for that scenario.\n-----\nThis is a fix for CODEC-101\n*/\nwhile (readLen == 0) {\nif (!base64.hasData()) {\nbyte[] buf = new byte[doEncode ? 4096 : 8192];\nint c = in.read(buf);\nif (c > 0 && b.length == len) {\nbase64.setInitialBuffer(b, offset, len);\n}\nif (doEncode) {\nbase64.encode(buf, 0, c);\n} else {\nbase64.decode(buf, 0, c);\n}\n}\nreadLen = base64.readResults(b, offset, len);\n}\nreturn readLen;\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 9,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.binary.Base64Test.testCodec112",
                            "test_body": "340: public void testCodec112() { // size calculation assumes always chunked\n341: byte[] in = new byte[] {0};\n342: byte[] out=Base64.encodeBase64(in);\n343: Base64.encodeBase64(in, false, false, out.length);\n344: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[BZ)V",
                                    "method_body": "public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\nif (lineSeparator == null) {\nlineLength = 0;  // disable chunk-separating\nlineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n}\nthis.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\nthis.lineSeparator = new byte[lineSeparator.length];\nSystem.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\nif (lineLength > 0) {\nthis.encodeSize = 4 + lineSeparator.length;\n} else {\nthis.encodeSize = 4;\n}\nthis.decodeSize = this.encodeSize - 1;\nif (containsBase64Byte(lineSeparator)) {\nString sep = StringUtils.newStringUtf8(lineSeparator);\nthrow new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n}\nthis.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:<clinit>()V",
                                    "method_body": "public static final int PEM_CHUNK_SIZE = 64;\n\n/**\n* Chunk separator per RFC 2045 section 2.1.\n*\n* <p>\n* N.B. The next major release may break compatibility and make this field private.\n* </p>\n*\n* @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n*/\nstatic final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:avail()I",
                                    "method_body": "int avail() {\nreturn buffer != null ? pos - readPos : 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:resizeBuffer()V",
                                    "method_body": "private void resizeBuffer() {\nif (buffer == null) {\nbuffer = new byte[DEFAULT_BUFFER_SIZE];\npos = 0;\nreadPos = 0;\n} else {\nbyte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\nSystem.arraycopy(buffer, 0, b, 0, buffer.length);\nbuffer = b;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:readResults([BII)I",
                                    "method_body": "int readResults(byte[] b, int bPos, int bAvail) {\nif (buffer != null) {\nint len = Math.min(avail(), bAvail);\nSystem.arraycopy(buffer, readPos, b, bPos, len);\nreadPos += len;\nif (readPos >= pos) {\nbuffer = null;\n}\nreturn len;\n}\nreturn eof ? -1 : 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode([BII)V",
                                    "method_body": "void encode(byte[] in, int inPos, int inAvail) {\nif (eof) {\nreturn;\n}\n// inAvail < 0 is how we're informed of EOF in the underlying data we're\n// encoding.\nif (inAvail < 0) {\neof = true;\nif (buffer == null || buffer.length - pos < encodeSize) {\nresizeBuffer();\n}\nswitch (modulus) {\ncase 1 :\nbuffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n// URL-SAFE skips the padding to further reduce size.\nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuffer[pos++] = PAD;\nbuffer[pos++] = PAD;\n}\nbreak;\n\ncase 2 :\nbuffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n// URL-SAFE skips the padding to further reduce size.\nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuffer[pos++] = PAD;\n}\nbreak;\n}\n// Don't want to append the CRLF two times in a row, so make sure previous\n// character is not from CRLF!\nbyte b = lineSeparator[lineSeparator.length - 1];\nif (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {\nSystem.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\npos += lineSeparator.length;\n}\n} else {\nfor (int i = 0; i < inAvail; i++) {\nif (buffer == null || buffer.length - pos < encodeSize) {\nresizeBuffer();\n}\nmodulus = (++modulus) % 3;\nint b = in[inPos++];\nif (b < 0) {\nb += 256;\n}\nx = (x << 8) + b;\nif (0 == modulus) {\nbuffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\nbuffer[pos++] = encodeTable[x & MASK_6BITS];\ncurrentLinePos += 4;\nif (lineLength > 0 && lineLength <= currentLinePos) {\nSystem.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\npos += lineSeparator.length;\ncurrentLinePos = 0;\n}\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:isBase64(B)Z",
                                    "method_body": "public static boolean isBase64(byte octet) {\nreturn octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:containsBase64Byte([B)Z",
                                    "method_body": "private static boolean containsBase64Byte(byte[] arrayOctet) {\nfor (int i = 0; i < arrayOctet.length; i++) {\nif (isBase64(arrayOctet[i])) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encodeBase64([B)[B",
                                    "method_body": "public static byte[] encodeBase64(byte[] binaryData) {\nreturn encodeBase64(binaryData, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encodeBase64([BZ)[B",
                                    "method_body": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\nreturn encodeBase64(binaryData, isChunked, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encodeBase64([BZZ)[B",
                                    "method_body": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\nreturn encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encodeBase64([BZZI)[B",
                                    "method_body": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\nif (binaryData == null || binaryData.length == 0) {\nreturn binaryData;\n}\n\nlong len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\nif (len > maxResultSize) {\nthrow new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\nlen +\n\") than the specified maxium size of \" +\nmaxResultSize);\n}\n\nBase64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\nreturn b64.encode(binaryData);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:encode([B)[B",
                                    "method_body": "public byte[] encode(byte[] pArray) {\nreset();\nif (pArray == null || pArray.length == 0) {\nreturn pArray;\n}\nencode(pArray, 0, pArray.length);\nencode(pArray, 0, -1); // Notify encoder of EOF.\nbyte[] buf = new byte[pos - readPos];\nreadResults(buf, 0, buf.length);\nreturn buf;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:getEncodeLength([BI[B)J",
                                    "method_body": "private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\n// base64 always encodes to multiples of 4.\nchunkSize = (chunkSize / 4) * 4;\n\nlong len = (pArray.length * 4) / 3;\nlong mod = len % 4;\nif (mod != 0) {\nlen += 4 - mod;\n}\nif (chunkSize > 0) {\nboolean lenChunksPerfectly = len % chunkSize == 0;\nlen += (len / chunkSize) * chunkSeparator.length;\nif (!lenChunksPerfectly) {\nlen += chunkSeparator.length;\n}\n}\nreturn len;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base64:reset()V",
                                    "method_body": "private void reset() {\nbuffer = null;\npos = 0;\nreadPos = 0;\ncurrentLinePos = 0;\nmodulus = 0;\neof = false;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 10,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.language.CaverphoneTest.testEndMb",
                            "test_body": "333: public void testEndMb() throws EncoderException {\n334: String[][] data = {{\"mb\", \"M111111111\"}, {\"mbmb\", \"MPM1111111\"}};\n335: this.checkEncodings(data);\n336: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.language.Caverphone:<init>()V",
                                    "method_body": "public Caverphone() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Caverphone:caverphone(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String caverphone(String txt) {\n// NOTE: Version 1.0 of Caverphone is easily derivable from this code\n// by commenting out the 2.0 lines and adding in the 1.0 lines\n\nif( txt == null || txt.length() == 0 ) {\nreturn \"1111111111\";\n}\n\n// 1. Convert to lowercase\ntxt = txt.toLowerCase(java.util.Locale.ENGLISH);\n\n// 2. Remove anything not A-Z\ntxt = txt.replaceAll(\"[^a-z]\", \"\");\n\n// 2.5. Remove final e\ntxt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n\n// 3. Handle various start options\ntxt = txt.replaceAll(\"^cough\", \"cou2f\");\ntxt = txt.replaceAll(\"^rough\", \"rou2f\");\ntxt = txt.replaceAll(\"^tough\", \"tou2f\");\ntxt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\ntxt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\ntxt = txt.replaceAll(\"^gn\", \"2n\");\n\n// End\ntxt = txt.replaceAll(\"^mb\", \"m2\");\n\n// 4. Handle replacements\ntxt = txt.replaceAll(\"cq\", \"2q\");\ntxt = txt.replaceAll(\"ci\", \"si\");\ntxt = txt.replaceAll(\"ce\", \"se\");\ntxt = txt.replaceAll(\"cy\", \"sy\");\ntxt = txt.replaceAll(\"tch\", \"2ch\");\ntxt = txt.replaceAll(\"c\", \"k\");\ntxt = txt.replaceAll(\"q\", \"k\");\ntxt = txt.replaceAll(\"x\", \"k\");\ntxt = txt.replaceAll(\"v\", \"f\");\ntxt = txt.replaceAll(\"dg\", \"2g\");\ntxt = txt.replaceAll(\"tio\", \"sio\");\ntxt = txt.replaceAll(\"tia\", \"sia\");\ntxt = txt.replaceAll(\"d\", \"t\");\ntxt = txt.replaceAll(\"ph\", \"fh\");\ntxt = txt.replaceAll(\"b\", \"p\");\ntxt = txt.replaceAll(\"sh\", \"s2\");\ntxt = txt.replaceAll(\"z\", \"s\");\ntxt = txt.replaceAll(\"^[aeiou]\", \"A\");\ntxt = txt.replaceAll(\"[aeiou]\", \"3\");\ntxt = txt.replaceAll(\"j\", \"y\");        // 2.0 only\ntxt = txt.replaceAll(\"^y3\", \"Y3\");     // 2.0 only\ntxt = txt.replaceAll(\"^y\", \"A\");       // 2.0 only\ntxt = txt.replaceAll(\"y\", \"3\");        // 2.0 only\ntxt = txt.replaceAll(\"3gh3\", \"3kh3\");\ntxt = txt.replaceAll(\"gh\", \"22\");\ntxt = txt.replaceAll(\"g\", \"k\");\ntxt = txt.replaceAll(\"s+\", \"S\");\ntxt = txt.replaceAll(\"t+\", \"T\");\ntxt = txt.replaceAll(\"p+\", \"P\");\ntxt = txt.replaceAll(\"k+\", \"K\");\ntxt = txt.replaceAll(\"f+\", \"F\");\ntxt = txt.replaceAll(\"m+\", \"M\");\ntxt = txt.replaceAll(\"n+\", \"N\");\ntxt = txt.replaceAll(\"w3\", \"W3\");\n//txt = txt.replaceAll(\"wy\", \"Wy\");    // 1.0 only\ntxt = txt.replaceAll(\"wh3\", \"Wh3\");\ntxt = txt.replaceAll(\"w$\", \"3\");       // 2.0 only\n//txt = txt.replaceAll(\"why\", \"Why\");  // 1.0 only\ntxt = txt.replaceAll(\"w\", \"2\");\ntxt = txt.replaceAll(\"^h\", \"A\");\ntxt = txt.replaceAll(\"h\", \"2\");\ntxt = txt.replaceAll(\"r3\", \"R3\");\ntxt = txt.replaceAll(\"r$\", \"3\");       // 2.0 only\n//txt = txt.replaceAll(\"ry\", \"Ry\");    // 1.0 only\ntxt = txt.replaceAll(\"r\", \"2\");\ntxt = txt.replaceAll(\"l3\", \"L3\");\ntxt = txt.replaceAll(\"l$\", \"3\");       // 2.0 only\n//txt = txt.replaceAll(\"ly\", \"Ly\");    // 1.0 only\ntxt = txt.replaceAll(\"l\", \"2\");\n//txt = txt.replaceAll(\"j\", \"y\");      // 1.0 only\n//txt = txt.replaceAll(\"y3\", \"Y3\");    // 1.0 only\n//txt = txt.replaceAll(\"y\", \"2\");      // 1.0 only\n\n// 5. Handle removals\ntxt = txt.replaceAll(\"2\", \"\");\ntxt = txt.replaceAll(\"3$\", \"A\");       // 2.0 only\ntxt = txt.replaceAll(\"3\", \"\");\n\n// 6. put ten 1s on the end\ntxt = txt + \"111111\" + \"1111\";        // 1.0 only has 6 1s\n\n// 7. take the first six characters as the code\nreturn txt.substring(0, 10);          // 1.0 truncates to 6\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Caverphone:encode(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(String pString) {\nreturn caverphone(pString);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 11,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.net.QuotedPrintableCodecTest.testSoftLineBreakDecode",
                            "test_body": "267: public void testSoftLineBreakDecode() throws Exception {\n268: String qpdata = \"If you believe that truth=3Dbeauty, then surely=20=\\r\\nmathematics \" +\n269: \"is the most beautiful branch of philosophy.\";\n270: String expected = \"If you believe that truth=beauty, then surely mathematics \" +\n271: \"is the most beautiful branch of philosophy.\";\n272: 273: QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n274: assertEquals(expected, qpcodec.decode(qpdata));\n275: 276: String encoded = qpcodec.encode(expected);\n277: assertEquals(expected, qpcodec.decode(encoded));\n278: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.DecoderException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public DecoderException(String message) {\nsuper(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUsAscii(Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUsAscii(String string) {\nreturn StringUtils.getBytesUnchecked(string, CharEncoding.US_ASCII);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUnchecked(Ljava/lang/String;Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUnchecked(String string, String charsetName) {\nif (string == null) {\nreturn null;\n}\ntry {\nreturn string.getBytes(charsetName);\n} catch (UnsupportedEncodingException e) {\nthrow StringUtils.newIllegalStateException(charsetName, e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<init>()V",
                                    "method_body": "public QuotedPrintableCodec() {\nthis(CharEncoding.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<init>(Ljava/lang/String;)V",
                                    "method_body": "public QuotedPrintableCodec(String charset) {\nsuper();\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<clinit>()V",
                                    "method_body": "private final String charset;\n\n/**\n* BitSet of printable characters as defined in RFC 1521.\n*/\nprivate static final BitSet PRINTABLE_CHARS = new BitSet(256);\n\nprivate static final byte ESCAPE_CHAR = '=';\n\nprivate static final byte TAB = 9;\n\nprivate static final byte SPACE = 32;\n\n\n\n/** Safe line length for quoted printable encoded text. */\n\n// Static initializer for printable chars collection\nstatic {\n// alpha characters\nfor (int i = 33; i <= 60; i++) {\nPRINTABLE_CHARS.set(i);\n}\nfor (int i = 62; i <= 126; i++) {\nPRINTABLE_CHARS.set(i);\n}\nPRINTABLE_CHARS.set(TAB);\nPRINTABLE_CHARS.set(SPACE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:decodeQuotedPrintable([B)[B",
                                    "method_body": "public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\nif (bytes == null) {\nreturn null;\n}\nByteArrayOutputStream buffer = new ByteArrayOutputStream();\nfor (int i = 0; i < bytes.length; i++) {\nfinal int b = bytes[i];\nif (b == ESCAPE_CHAR) {\ntry {\n// if the next octet is a CR we have found a soft line break\nint u = Utils.digit16(bytes[++i]);\nint l = Utils.digit16(bytes[++i]);\nbuffer.write((char) ((u << 4) + l));\n} catch (ArrayIndexOutOfBoundsException e) {\nthrow new DecoderException(\"Invalid quoted-printable encoding\", e);\n}\n} else {\n// every other octet is appended except for CR & LF\nbuffer.write(b);\n}\n}\nreturn buffer.toByteArray();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:decode([B)[B",
                                    "method_body": "public byte[] decode(byte[] bytes) throws DecoderException {\nreturn decodeQuotedPrintable(bytes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:decode(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String decode(String pString, String charset) throws DecoderException, UnsupportedEncodingException {\nif (pString == null) {\nreturn null;\n}\nreturn new String(decode(StringUtils.getBytesUsAscii(pString)), charset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:decode(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String decode(String pString) throws DecoderException {\nif (pString == null) {\nreturn null;\n}\ntry {\nreturn decode(pString, getDefaultCharset());\n} catch (UnsupportedEncodingException e) {\nthrow new DecoderException(e.getMessage(), e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:getDefaultCharset()Ljava/lang/String;",
                                    "method_body": "public String getDefaultCharset() {\nreturn this.charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.Utils:digit16(B)I",
                                    "method_body": "static int digit16(byte b) throws DecoderException {\nint i = Character.digit((char) b, 16);\nif (i == -1) {\nthrow new DecoderException(\"Invalid URL encoding: not a valid digit (radix \" + URLCodec.RADIX + \"): \" + b);\n}\nreturn i;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.net.QuotedPrintableCodecTest.testSkipNotEncodedCRLF",
                            "test_body": "295: public void testSkipNotEncodedCRLF() throws Exception {\n296: String qpdata = \"CRLF in an\\n encoded text should be=20=\\r\\n\\rskipped in the\\r decoding.\";\n297: String expected = \"CRLF in an encoded text should be skipped in the decoding.\";\n298: 299: QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n300: assertEquals(expected, qpcodec.decode(qpdata));\n301: 302: String encoded = qpcodec.encode(expected);\n303: assertEquals(expected, qpcodec.decode(encoded));\n304: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.DecoderException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public DecoderException(String message) {\nsuper(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUsAscii(Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUsAscii(String string) {\nreturn StringUtils.getBytesUnchecked(string, CharEncoding.US_ASCII);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:getBytesUnchecked(Ljava/lang/String;Ljava/lang/String;)[B",
                                    "method_body": "public static byte[] getBytesUnchecked(String string, String charsetName) {\nif (string == null) {\nreturn null;\n}\ntry {\nreturn string.getBytes(charsetName);\n} catch (UnsupportedEncodingException e) {\nthrow StringUtils.newIllegalStateException(charsetName, e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<init>()V",
                                    "method_body": "public QuotedPrintableCodec() {\nthis(CharEncoding.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<init>(Ljava/lang/String;)V",
                                    "method_body": "public QuotedPrintableCodec(String charset) {\nsuper();\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<clinit>()V",
                                    "method_body": "private final String charset;\n\n/**\n* BitSet of printable characters as defined in RFC 1521.\n*/\nprivate static final BitSet PRINTABLE_CHARS = new BitSet(256);\n\nprivate static final byte ESCAPE_CHAR = '=';\n\nprivate static final byte TAB = 9;\n\nprivate static final byte SPACE = 32;\n\n\n\n/** Safe line length for quoted printable encoded text. */\n\n// Static initializer for printable chars collection\nstatic {\n// alpha characters\nfor (int i = 33; i <= 60; i++) {\nPRINTABLE_CHARS.set(i);\n}\nfor (int i = 62; i <= 126; i++) {\nPRINTABLE_CHARS.set(i);\n}\nPRINTABLE_CHARS.set(TAB);\nPRINTABLE_CHARS.set(SPACE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:decodeQuotedPrintable([B)[B",
                                    "method_body": "public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\nif (bytes == null) {\nreturn null;\n}\nByteArrayOutputStream buffer = new ByteArrayOutputStream();\nfor (int i = 0; i < bytes.length; i++) {\nfinal int b = bytes[i];\nif (b == ESCAPE_CHAR) {\ntry {\n// if the next octet is a CR we have found a soft line break\nint u = Utils.digit16(bytes[++i]);\nint l = Utils.digit16(bytes[++i]);\nbuffer.write((char) ((u << 4) + l));\n} catch (ArrayIndexOutOfBoundsException e) {\nthrow new DecoderException(\"Invalid quoted-printable encoding\", e);\n}\n} else {\n// every other octet is appended except for CR & LF\nbuffer.write(b);\n}\n}\nreturn buffer.toByteArray();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:decode([B)[B",
                                    "method_body": "public byte[] decode(byte[] bytes) throws DecoderException {\nreturn decodeQuotedPrintable(bytes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:decode(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String decode(String pString, String charset) throws DecoderException, UnsupportedEncodingException {\nif (pString == null) {\nreturn null;\n}\nreturn new String(decode(StringUtils.getBytesUsAscii(pString)), charset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:decode(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String decode(String pString) throws DecoderException {\nif (pString == null) {\nreturn null;\n}\ntry {\nreturn decode(pString, getDefaultCharset());\n} catch (UnsupportedEncodingException e) {\nthrow new DecoderException(e.getMessage(), e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:getDefaultCharset()Ljava/lang/String;",
                                    "method_body": "public String getDefaultCharset() {\nreturn this.charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.Utils:digit16(B)I",
                                    "method_body": "static int digit16(byte b) throws DecoderException {\nint i = Character.digit((char) b, 16);\nif (i == -1) {\nthrow new DecoderException(\"Invalid URL encoding: not a valid digit (radix \" + URLCodec.RADIX + \"): \" + b);\n}\nreturn i;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.net.QuotedPrintableCodecTest.testTrailingSpecial",
                            "test_body": "307: public void testTrailingSpecial() throws Exception {\n308: final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n309: 310: String plain =\"This is a example of a quoted-printable text file. This might contain sp=cial chars.\";\n311: String expected = \"This is a example of a quoted-printable text file. This might contain sp=3D=\\r\\ncial chars.\";\n312: assertEquals(expected, qpcodec.encode(plain));\n313: 314: plain =\"This is a example of a quoted-printable text file. This might contain ta\\tbs as well.\";\n315: expected = \"This is a example of a quoted-printable text file. This might contain ta=09=\\r\\nbs as well.\";\n316: assertEquals(expected, qpcodec.encode(plain));\n317: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<init>()V",
                                    "method_body": "public QuotedPrintableCodec() {\nthis(CharEncoding.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<init>(Ljava/lang/String;)V",
                                    "method_body": "public QuotedPrintableCodec(String charset) {\nsuper();\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<clinit>()V",
                                    "method_body": "private final String charset;\n\n/**\n* BitSet of printable characters as defined in RFC 1521.\n*/\nprivate static final BitSet PRINTABLE_CHARS = new BitSet(256);\n\nprivate static final byte ESCAPE_CHAR = '=';\n\nprivate static final byte TAB = 9;\n\nprivate static final byte SPACE = 32;\n\n\n\n/** Safe line length for quoted printable encoded text. */\n\n// Static initializer for printable chars collection\nstatic {\n// alpha characters\nfor (int i = 33; i <= 60; i++) {\nPRINTABLE_CHARS.set(i);\n}\nfor (int i = 62; i <= 126; i++) {\nPRINTABLE_CHARS.set(i);\n}\nPRINTABLE_CHARS.set(TAB);\nPRINTABLE_CHARS.set(SPACE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:getDefaultCharset()Ljava/lang/String;",
                                    "method_body": "public String getDefaultCharset() {\nreturn this.charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:newString([BLjava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public static String newString(byte[] bytes, String charsetName) {\nif (bytes == null) {\nreturn null;\n}\ntry {\nreturn new String(bytes, charsetName);\n} catch (UnsupportedEncodingException e) {\nthrow StringUtils.newIllegalStateException(charsetName, e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:newStringUsAscii([B)Ljava/lang/String;",
                                    "method_body": "public static String newStringUsAscii(byte[] bytes) {\nreturn StringUtils.newString(bytes, CharEncoding.US_ASCII);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encodeQuotedPrintable(ILjava/io/ByteArrayOutputStream;)V",
                                    "method_body": "private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\nbuffer.write(ESCAPE_CHAR);\nchar hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\nchar hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\nbuffer.write(hex1);\nbuffer.write(hex2);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encodeQuotedPrintable(Ljava/util/BitSet;[B)[B",
                                    "method_body": "public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\nif (bytes == null) {\nreturn null;\n}\nif (printable == null) {\nprintable = PRINTABLE_CHARS;\n}\nByteArrayOutputStream buffer = new ByteArrayOutputStream();\n// encode up to buffer.length - 3, the last three octets will be treated\n// separately for simplification of note #3\n// up to this length it is safe to add any byte, encoded or not\nfor (byte c : bytes) {\nint b = c;\nif (b < 0) {\nb = 256 + b;\n}\nif (printable.get(b)) {\nbuffer.write(b);\n} else {\n// rule #3: whitespace at the end of a line *must* be encoded\n\n// rule #5: soft line break\nencodeQuotedPrintable(b, buffer);\n}\n}\n\n// rule #3: whitespace at the end of a line *must* be encoded\n// if we would do a soft break line after this octet, encode whitespace\n\n// note #3: '=' *must not* be the ultimate or penultimate character\n// simplification: if < 6 bytes left, do a soft line break as we may need\n//                 exactly 6 bytes space for the last 2 bytes\n// rule #3: trailing whitespace shall be encoded\n\nreturn buffer.toByteArray();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encode([B)[B",
                                    "method_body": "public byte[] encode(byte[] bytes) {\nreturn encodeQuotedPrintable(PRINTABLE_CHARS, bytes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encode(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(String pString) throws EncoderException {\nif (pString == null) {\nreturn null;\n}\ntry {\nreturn encode(pString, getDefaultCharset());\n} catch (UnsupportedEncodingException e) {\nthrow new EncoderException(e.getMessage(), e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encode(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(String pString, String charset) throws UnsupportedEncodingException {\nif (pString == null) {\nreturn null;\n}\nreturn StringUtils.newStringUsAscii(encode(pString.getBytes(charset)));\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.net.QuotedPrintableCodecTest.testUltimateSoftBreak",
                            "test_body": "320: public void testUltimateSoftBreak() throws Exception {\n321: final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n322: 323: String plain =\"This is a example of a quoted-printable text file. There is no end to it\\t\";\n324: String expected = \"This is a example of a quoted-printable text file. There is no end to i=\\r\\nt=09\";\n325: 326: assertEquals(expected, qpcodec.encode(plain));\n327: 328: plain =\"This is a example of a quoted-printable text file. There is no end to it \";\n329: expected = \"This is a example of a quoted-printable text file. There is no end to i=\\r\\nt=20\";\n330: 331: assertEquals(expected, qpcodec.encode(plain));\n332: 333: // whitespace before soft break\n334: plain =\"This is a example of a quoted-printable text file. There is no end to   \";\n335: expected = \"This is a example of a quoted-printable text file. There is no end to=20=\\r\\n =20\";\n336: 337: assertEquals(expected, qpcodec.encode(plain));\n338: 339: // non-printable character before soft break\n340: plain =\"This is a example of a quoted-printable text file. There is no end to=  \";\n341: expected = \"This is a example of a quoted-printable text file. There is no end to=3D=\\r\\n =20\";\n342: 343: assertEquals(expected, qpcodec.encode(plain));\n344: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<init>()V",
                                    "method_body": "public QuotedPrintableCodec() {\nthis(CharEncoding.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<init>(Ljava/lang/String;)V",
                                    "method_body": "public QuotedPrintableCodec(String charset) {\nsuper();\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<clinit>()V",
                                    "method_body": "private final String charset;\n\n/**\n* BitSet of printable characters as defined in RFC 1521.\n*/\nprivate static final BitSet PRINTABLE_CHARS = new BitSet(256);\n\nprivate static final byte ESCAPE_CHAR = '=';\n\nprivate static final byte TAB = 9;\n\nprivate static final byte SPACE = 32;\n\n\n\n/** Safe line length for quoted printable encoded text. */\n\n// Static initializer for printable chars collection\nstatic {\n// alpha characters\nfor (int i = 33; i <= 60; i++) {\nPRINTABLE_CHARS.set(i);\n}\nfor (int i = 62; i <= 126; i++) {\nPRINTABLE_CHARS.set(i);\n}\nPRINTABLE_CHARS.set(TAB);\nPRINTABLE_CHARS.set(SPACE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:getDefaultCharset()Ljava/lang/String;",
                                    "method_body": "public String getDefaultCharset() {\nreturn this.charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:newString([BLjava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public static String newString(byte[] bytes, String charsetName) {\nif (bytes == null) {\nreturn null;\n}\ntry {\nreturn new String(bytes, charsetName);\n} catch (UnsupportedEncodingException e) {\nthrow StringUtils.newIllegalStateException(charsetName, e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:newStringUsAscii([B)Ljava/lang/String;",
                                    "method_body": "public static String newStringUsAscii(byte[] bytes) {\nreturn StringUtils.newString(bytes, CharEncoding.US_ASCII);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encodeQuotedPrintable(Ljava/util/BitSet;[B)[B",
                                    "method_body": "public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\nif (bytes == null) {\nreturn null;\n}\nif (printable == null) {\nprintable = PRINTABLE_CHARS;\n}\nByteArrayOutputStream buffer = new ByteArrayOutputStream();\n// encode up to buffer.length - 3, the last three octets will be treated\n// separately for simplification of note #3\n// up to this length it is safe to add any byte, encoded or not\nfor (byte c : bytes) {\nint b = c;\nif (b < 0) {\nb = 256 + b;\n}\nif (printable.get(b)) {\nbuffer.write(b);\n} else {\n// rule #3: whitespace at the end of a line *must* be encoded\n\n// rule #5: soft line break\nencodeQuotedPrintable(b, buffer);\n}\n}\n\n// rule #3: whitespace at the end of a line *must* be encoded\n// if we would do a soft break line after this octet, encode whitespace\n\n// note #3: '=' *must not* be the ultimate or penultimate character\n// simplification: if < 6 bytes left, do a soft line break as we may need\n//                 exactly 6 bytes space for the last 2 bytes\n// rule #3: trailing whitespace shall be encoded\n\nreturn buffer.toByteArray();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encode([B)[B",
                                    "method_body": "public byte[] encode(byte[] bytes) {\nreturn encodeQuotedPrintable(PRINTABLE_CHARS, bytes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encode(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(String pString) throws EncoderException {\nif (pString == null) {\nreturn null;\n}\ntry {\nreturn encode(pString, getDefaultCharset());\n} catch (UnsupportedEncodingException e) {\nthrow new EncoderException(e.getMessage(), e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encode(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(String pString, String charset) throws UnsupportedEncodingException {\nif (pString == null) {\nreturn null;\n}\nreturn StringUtils.newStringUsAscii(encode(pString.getBytes(charset)));\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.net.QuotedPrintableCodecTest.testSoftLineBreakEncode",
                            "test_body": "281: public void testSoftLineBreakEncode() throws Exception {\n282: String qpdata = \"If you believe that truth=3Dbeauty, then surely mathematics is the most \" +\n283: \"b=\\r\\neautiful branch of philosophy.\";\n284: String expected = \"If you believe that truth=beauty, then surely mathematics is the most \" +\n285: \"beautiful branch of philosophy.\";\n286: 287: QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n288: assertEquals(qpdata, qpcodec.encode(expected));\n289: 290: String decoded = qpcodec.decode(qpdata);\n291: assertEquals(qpdata, qpcodec.encode(decoded));\n292: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<init>()V",
                                    "method_body": "public QuotedPrintableCodec() {\nthis(CharEncoding.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<init>(Ljava/lang/String;)V",
                                    "method_body": "public QuotedPrintableCodec(String charset) {\nsuper();\nthis.charset = charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:<clinit>()V",
                                    "method_body": "private final String charset;\n\n/**\n* BitSet of printable characters as defined in RFC 1521.\n*/\nprivate static final BitSet PRINTABLE_CHARS = new BitSet(256);\n\nprivate static final byte ESCAPE_CHAR = '=';\n\nprivate static final byte TAB = 9;\n\nprivate static final byte SPACE = 32;\n\n\n\n/** Safe line length for quoted printable encoded text. */\n\n// Static initializer for printable chars collection\nstatic {\n// alpha characters\nfor (int i = 33; i <= 60; i++) {\nPRINTABLE_CHARS.set(i);\n}\nfor (int i = 62; i <= 126; i++) {\nPRINTABLE_CHARS.set(i);\n}\nPRINTABLE_CHARS.set(TAB);\nPRINTABLE_CHARS.set(SPACE);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:getDefaultCharset()Ljava/lang/String;",
                                    "method_body": "public String getDefaultCharset() {\nreturn this.charset;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:newString([BLjava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public static String newString(byte[] bytes, String charsetName) {\nif (bytes == null) {\nreturn null;\n}\ntry {\nreturn new String(bytes, charsetName);\n} catch (UnsupportedEncodingException e) {\nthrow StringUtils.newIllegalStateException(charsetName, e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:newStringUsAscii([B)Ljava/lang/String;",
                                    "method_body": "public static String newStringUsAscii(byte[] bytes) {\nreturn StringUtils.newString(bytes, CharEncoding.US_ASCII);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encodeQuotedPrintable(ILjava/io/ByteArrayOutputStream;)V",
                                    "method_body": "private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\nbuffer.write(ESCAPE_CHAR);\nchar hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\nchar hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\nbuffer.write(hex1);\nbuffer.write(hex2);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encodeQuotedPrintable(Ljava/util/BitSet;[B)[B",
                                    "method_body": "public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\nif (bytes == null) {\nreturn null;\n}\nif (printable == null) {\nprintable = PRINTABLE_CHARS;\n}\nByteArrayOutputStream buffer = new ByteArrayOutputStream();\n// encode up to buffer.length - 3, the last three octets will be treated\n// separately for simplification of note #3\n// up to this length it is safe to add any byte, encoded or not\nfor (byte c : bytes) {\nint b = c;\nif (b < 0) {\nb = 256 + b;\n}\nif (printable.get(b)) {\nbuffer.write(b);\n} else {\n// rule #3: whitespace at the end of a line *must* be encoded\n\n// rule #5: soft line break\nencodeQuotedPrintable(b, buffer);\n}\n}\n\n// rule #3: whitespace at the end of a line *must* be encoded\n// if we would do a soft break line after this octet, encode whitespace\n\n// note #3: '=' *must not* be the ultimate or penultimate character\n// simplification: if < 6 bytes left, do a soft line break as we may need\n//                 exactly 6 bytes space for the last 2 bytes\n// rule #3: trailing whitespace shall be encoded\n\nreturn buffer.toByteArray();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encode([B)[B",
                                    "method_body": "public byte[] encode(byte[] bytes) {\nreturn encodeQuotedPrintable(PRINTABLE_CHARS, bytes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encode(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(String pString) throws EncoderException {\nif (pString == null) {\nreturn null;\n}\ntry {\nreturn encode(pString, getDefaultCharset());\n} catch (UnsupportedEncodingException e) {\nthrow new EncoderException(e.getMessage(), e);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.net.QuotedPrintableCodec:encode(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(String pString, String charset) throws UnsupportedEncodingException {\nif (pString == null) {\nreturn null;\n}\nreturn StringUtils.newStringUsAscii(encode(pString.getBytes(charset)));\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 13,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.language.DoubleMetaphoneTest.testCodec184",
                            "test_body": "1064: public void testCodec184() throws Throwable {\n1065: assertTrue(new DoubleMetaphone().isDoubleMetaphoneEqual(\"\", \"\", false));\n1066: assertTrue(new DoubleMetaphone().isDoubleMetaphoneEqual(\"\", \"\", true));\n1067: assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual(\"aa\", \"\", false));\n1068: assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual(\"aa\", \"\", true));\n1069: assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual(\"\", \"aa\", false));\n1070: assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual(\"\", \"aa\", true));\n1071: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:<init>()V",
                                    "method_body": "public DoubleMetaphone() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:<clinit>()V",
                                    "method_body": "private static final String VOWELS = \"AEIOUY\";\n\n/**\n* Prefixes when present which are not pronounced\n*/\nprivate static final String[] SILENT_START =\n{ \"GN\", \"KN\", \"PN\", \"WR\", \"PS\" };"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:doubleMetaphone(Ljava/lang/String;Z)Ljava/lang/String;",
                                    "method_body": "public String doubleMetaphone(String value, final boolean alternate) {\nvalue = cleanInput(value);\nif (value == null) {\nreturn null;\n}\n\nfinal boolean slavoGermanic = isSlavoGermanic(value);\nint index = isSilentStart(value) ? 1 : 0;\n\nfinal DoubleMetaphoneResult result = new DoubleMetaphoneResult(this.getMaxCodeLen());\n\nwhile (!result.isComplete() && index <= value.length() - 1) {\nswitch (value.charAt(index)) {\ncase 'A':\ncase 'E':\ncase 'I':\ncase 'O':\ncase 'U':\ncase 'Y':\nindex = handleAEIOUY(result, index);\nbreak;\ncase 'B':\nresult.append('P');\nindex = charAt(value, index + 1) == 'B' ? index + 2 : index + 1;\nbreak;\ncase '\\u00C7':\n// A C with a Cedilla\nresult.append('S');\nindex++;\nbreak;\ncase 'C':\nindex = handleC(value, result, index);\nbreak;\ncase 'D':\nindex = handleD(value, result, index);\nbreak;\ncase 'F':\nresult.append('F');\nindex = charAt(value, index + 1) == 'F' ? index + 2 : index + 1;\nbreak;\ncase 'G':\nindex = handleG(value, result, index, slavoGermanic);\nbreak;\ncase 'H':\nindex = handleH(value, result, index);\nbreak;\ncase 'J':\nindex = handleJ(value, result, index, slavoGermanic);\nbreak;\ncase 'K':\nresult.append('K');\nindex = charAt(value, index + 1) == 'K' ? index + 2 : index + 1;\nbreak;\ncase 'L':\nindex = handleL(value, result, index);\nbreak;\ncase 'M':\nresult.append('M');\nindex = conditionM0(value, index) ? index + 2 : index + 1;\nbreak;\ncase 'N':\nresult.append('N');\nindex = charAt(value, index + 1) == 'N' ? index + 2 : index + 1;\nbreak;\ncase '\\u00D1':\n// N with a tilde (spanish ene)\nresult.append('N');\nindex++;\nbreak;\ncase 'P':\nindex = handleP(value, result, index);\nbreak;\ncase 'Q':\nresult.append('K');\nindex = charAt(value, index + 1) == 'Q' ? index + 2 : index + 1;\nbreak;\ncase 'R':\nindex = handleR(value, result, index, slavoGermanic);\nbreak;\ncase 'S':\nindex = handleS(value, result, index, slavoGermanic);\nbreak;\ncase 'T':\nindex = handleT(value, result, index);\nbreak;\ncase 'V':\nresult.append('F');\nindex = charAt(value, index + 1) == 'V' ? index + 2 : index + 1;\nbreak;\ncase 'W':\nindex = handleW(value, result, index);\nbreak;\ncase 'X':\nindex = handleX(value, result, index);\nbreak;\ncase 'Z':\nindex = handleZ(value, result, index, slavoGermanic);\nbreak;\ndefault:\nindex++;\nbreak;\n}\n}\n\nreturn alternate ? result.getAlternate() : result.getPrimary();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:isDoubleMetaphoneEqual(Ljava/lang/String;Ljava/lang/String;Z)Z",
                                    "method_body": "public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {\nreturn doubleMetaphone(value1, alternate).equals(doubleMetaphone(value2, alternate));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:cleanInput(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private String cleanInput(String input) {\nif (input == null) {\nreturn null;\n}\ninput = input.trim();\nif (input.length() == 0) {\nreturn null;\n}\nreturn input.toUpperCase(java.util.Locale.ENGLISH);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.language.DoubleMetaphoneTest.testIsDoubleMetaphoneEqualBasic",
                            "test_body": "1123: public void testIsDoubleMetaphoneEqualBasic() {\n1124: final String[][] testFixture = new String[][] { { \n1125: \"\", \"\" }, {\n1126: \"Case\", \"case\" }, {\n1127: \"CASE\", \"Case\" }, {\n1128: \"caSe\", \"cAsE\" }, {\n1129: \"cookie\", \"quick\" }, {\n1130: \"quick\", \"cookie\" }, {\n1131: \"Brian\", \"Bryan\" }, {\n1132: \"Auto\", \"Otto\" }, {\n1133: \"Steven\", \"Stefan\" }, {\n1134: \"Philipowitz\", \"Filipowicz\" }\n1135: };\n1136: doubleMetaphoneEqualTest(testFixture, false);\n1137: doubleMetaphoneEqualTest(testFixture, true);\n1138: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:<init>()V",
                                    "method_body": "public DoubleMetaphone() {\nsuper();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:<clinit>()V",
                                    "method_body": "private static final String VOWELS = \"AEIOUY\";\n\n/**\n* Prefixes when present which are not pronounced\n*/\nprivate static final String[] SILENT_START =\n{ \"GN\", \"KN\", \"PN\", \"WR\", \"PS\" };"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:doubleMetaphone(Ljava/lang/String;Z)Ljava/lang/String;",
                                    "method_body": "public String doubleMetaphone(String value, final boolean alternate) {\nvalue = cleanInput(value);\nif (value == null) {\nreturn null;\n}\n\nfinal boolean slavoGermanic = isSlavoGermanic(value);\nint index = isSilentStart(value) ? 1 : 0;\n\nfinal DoubleMetaphoneResult result = new DoubleMetaphoneResult(this.getMaxCodeLen());\n\nwhile (!result.isComplete() && index <= value.length() - 1) {\nswitch (value.charAt(index)) {\ncase 'A':\ncase 'E':\ncase 'I':\ncase 'O':\ncase 'U':\ncase 'Y':\nindex = handleAEIOUY(result, index);\nbreak;\ncase 'B':\nresult.append('P');\nindex = charAt(value, index + 1) == 'B' ? index + 2 : index + 1;\nbreak;\ncase '\\u00C7':\n// A C with a Cedilla\nresult.append('S');\nindex++;\nbreak;\ncase 'C':\nindex = handleC(value, result, index);\nbreak;\ncase 'D':\nindex = handleD(value, result, index);\nbreak;\ncase 'F':\nresult.append('F');\nindex = charAt(value, index + 1) == 'F' ? index + 2 : index + 1;\nbreak;\ncase 'G':\nindex = handleG(value, result, index, slavoGermanic);\nbreak;\ncase 'H':\nindex = handleH(value, result, index);\nbreak;\ncase 'J':\nindex = handleJ(value, result, index, slavoGermanic);\nbreak;\ncase 'K':\nresult.append('K');\nindex = charAt(value, index + 1) == 'K' ? index + 2 : index + 1;\nbreak;\ncase 'L':\nindex = handleL(value, result, index);\nbreak;\ncase 'M':\nresult.append('M');\nindex = conditionM0(value, index) ? index + 2 : index + 1;\nbreak;\ncase 'N':\nresult.append('N');\nindex = charAt(value, index + 1) == 'N' ? index + 2 : index + 1;\nbreak;\ncase '\\u00D1':\n// N with a tilde (spanish ene)\nresult.append('N');\nindex++;\nbreak;\ncase 'P':\nindex = handleP(value, result, index);\nbreak;\ncase 'Q':\nresult.append('K');\nindex = charAt(value, index + 1) == 'Q' ? index + 2 : index + 1;\nbreak;\ncase 'R':\nindex = handleR(value, result, index, slavoGermanic);\nbreak;\ncase 'S':\nindex = handleS(value, result, index, slavoGermanic);\nbreak;\ncase 'T':\nindex = handleT(value, result, index);\nbreak;\ncase 'V':\nresult.append('F');\nindex = charAt(value, index + 1) == 'V' ? index + 2 : index + 1;\nbreak;\ncase 'W':\nindex = handleW(value, result, index);\nbreak;\ncase 'X':\nindex = handleX(value, result, index);\nbreak;\ncase 'Z':\nindex = handleZ(value, result, index, slavoGermanic);\nbreak;\ndefault:\nindex++;\nbreak;\n}\n}\n\nreturn alternate ? result.getAlternate() : result.getPrimary();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:isDoubleMetaphoneEqual(Ljava/lang/String;Ljava/lang/String;Z)Z",
                                    "method_body": "public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {\nreturn doubleMetaphone(value1, alternate).equals(doubleMetaphone(value2, alternate));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.DoubleMetaphone:cleanInput(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private String cleanInput(String input) {\nif (input == null) {\nreturn null;\n}\ninput = input.trim();\nif (input.length() == 0) {\nreturn null;\n}\nreturn input.toUpperCase(java.util.Locale.ENGLISH);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 14,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.language.bm.PhoneticEngineRegressionTest.testCompatibilityWithOriginalVersion",
                            "test_body": "181: public void testCompatibilityWithOriginalVersion() {\n182: // see CODEC-187\n183: // comparison: http://stevemorse.org/census/soundex.html\n184: 185: Map<String, String> args = new TreeMap<String, String>();\n186: args.put(\"nameType\", \"GENERIC\");\n187: args.put(\"ruleType\", \"APPROX\");\n188: 189: assertEquals(encode(args, true, \"abram\"), \"Ybram|Ybrom|abram|abran|abrom|abron|avram|avrom|obram|obran|obrom|obron|ovram|ovrom\");\n190: assertEquals(encode(args, true, \"Bendzin\"), \"bndzn|bntsn|bnzn|vndzn|vntsn\");\n191: 192: args.put(\"nameType\", \"ASHKENAZI\");\n193: args.put(\"ruleType\", \"APPROX\");\n194: 195: assertEquals(encode(args, true, \"abram\"), \"Ybram|Ybrom|abram|abrom|avram|avrom|imbram|imbrom|obram|obrom|ombram|ombrom|ovram|ovrom\");\n196: assertEquals(encode(args, true, \"Halpern\"), \"YlpYrn|Ylpirn|alpYrn|alpirn|olpYrn|olpirn|xalpirn|xolpirn\");\n197: 198: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.NameType:<init>(Ljava/lang/String;ILjava/lang/String;)V",
                                    "method_body": "NameType(final String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.NameType:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn this.name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.RuleType:<init>(Ljava/lang/String;ILjava/lang/String;)V",
                                    "method_body": "RuleType(final String name) {\nthis.name = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.RuleType:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn this.name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine:<init>(Lorg/apache/commons/codec/language/bm/NameType;Lorg/apache/commons/codec/language/bm/RuleType;Z)V",
                                    "method_body": "public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat) {\nthis(nameType, ruleType, concat, DEFAULT_MAX_PHONEMES);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine:<init>(Lorg/apache/commons/codec/language/bm/NameType;Lorg/apache/commons/codec/language/bm/RuleType;ZI)V",
                                    "method_body": "public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat,\nfinal int maxPhonemes) {\nif (ruleType == RuleType.RULES) {\nthrow new IllegalArgumentException(\"ruleType must not be \" + RuleType.RULES);\n}\nthis.nameType = nameType;\nthis.ruleType = ruleType;\nthis.concat = concat;\nthis.lang = Lang.instance(nameType);\nthis.maxPhonemes = maxPhonemes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine:<clinit>()V",
                                    "method_body": "private static final Map<NameType, Set<String>> NAME_PREFIXES = new EnumMap<NameType, Set<String>>(NameType.class);\n\nstatic {\nNAME_PREFIXES.put(NameType.ASHKENAZI,\nCollections.unmodifiableSet(\nnew HashSet<String>(Arrays.asList(\"bar\", \"ben\", \"da\", \"de\", \"van\", \"von\"))));\nNAME_PREFIXES.put(NameType.SEPHARDIC,\nCollections.unmodifiableSet(\nnew HashSet<String>(Arrays.asList(\"al\", \"el\", \"da\", \"dal\", \"de\", \"del\", \"dela\", \"de la\",\n\"della\", \"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\"))));\nNAME_PREFIXES.put(NameType.GENERIC,\nCollections.unmodifiableSet(\nnew HashSet<String>(Arrays.asList(\"da\", \"dal\", \"de\", \"del\", \"dela\", \"de la\", \"della\",\n\"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\"))));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine:join(Ljava/lang/Iterable;Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String join(final Iterable<String> strings, final String sep) {\nfinal StringBuilder sb = new StringBuilder();\nfinal Iterator<String> si = strings.iterator();\nif (si.hasNext()) {\nsb.append(si.next());\n}\nwhile (si.hasNext()) {\nsb.append(sep).append(si.next());\n}\n\nreturn sb.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine:applyFinalRules(Lorg/apache/commons/codec/language/bm/PhoneticEngine$PhonemeBuilder;Ljava/util/Map;)Lorg/apache/commons/codec/language/bm/PhoneticEngine$PhonemeBuilder;",
                                    "method_body": "private PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,\nfinal Map<String, List<Rule>> finalRules) {\nif (finalRules == null) {\nthrow new NullPointerException(\"finalRules can not be null\");\n}\nif (finalRules.isEmpty()) {\nreturn phonemeBuilder;\n}\n\nfinal Set<Rule.Phoneme> phonemes = new TreeSet<Rule.Phoneme>(Rule.Phoneme.COMPARATOR);\n\nfor (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {\nPhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());\nfinal String phonemeText = phoneme.getPhonemeText().toString();\n\nfor (int i = 0; i < phonemeText.length();) {\nfinal RulesApplication rulesApplication =\nnew RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();\nfinal boolean found = rulesApplication.isFound();\nsubBuilder = rulesApplication.getPhonemeBuilder();\n\nif (!found) {\n// not found, appending as-is\nsubBuilder.append(phonemeText.subSequence(i, i + 1));\n}\n\ni = rulesApplication.getI();\n}\n\n// the phonemes map orders the phonemes only based on their text, but ignores the language set\n// when adding new phonemes, check for equal phonemes and merge their language set, otherwise\n// phonemes with the same text but different language set get lost\nphonemes.addAll(subBuilder.getPhonemes());\n}\n\nreturn new PhonemeBuilder(phonemes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine:encode(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(final String input) {\nfinal Languages.LanguageSet languageSet = this.lang.guessLanguages(input);\nreturn encode(input, languageSet);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine:encode(Ljava/lang/String;Lorg/apache/commons/codec/language/bm/Languages$LanguageSet;)Ljava/lang/String;",
                                    "method_body": "public String encode(String input, final Languages.LanguageSet languageSet) {\nfinal Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);\n// rules common across many (all) languages\nfinal Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, \"common\");\n// rules that apply to a specific language that may be ambiguous or wrong if applied to other languages\nfinal Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);\n\n// tidy the input\n// lower case is a locale-dependent operation\ninput = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();\n\nif (this.nameType == NameType.GENERIC) {\nif (input.length() >= 2 && input.substring(0, 2).equals(\"d'\")) { // check for d'\nfinal String remainder = input.substring(2);\nfinal String combined = \"d\" + remainder;\nreturn \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\";\n}\nfor (final String l : NAME_PREFIXES.get(this.nameType)) {\n// handle generic prefixes\nif (input.startsWith(l + \" \")) {\n// check for any prefix in the words list\nfinal String remainder = input.substring(l.length() + 1); // input without the prefix\nfinal String combined = l + remainder; // input with prefix without space\nreturn \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\";\n}\n}\n}\n\nfinal List<String> words = Arrays.asList(input.split(\"\\\\s+\"));\nfinal List<String> words2 = new ArrayList<String>();\n\n// special-case handling of word prefixes based upon the name type\nswitch (this.nameType) {\ncase SEPHARDIC:\nfor (final String aWord : words) {\nfinal String[] parts = aWord.split(\"'\");\nfinal String lastPart = parts[parts.length - 1];\nwords2.add(lastPart);\n}\nwords2.removeAll(NAME_PREFIXES.get(this.nameType));\nbreak;\ncase ASHKENAZI:\nwords2.addAll(words);\nwords2.removeAll(NAME_PREFIXES.get(this.nameType));\nbreak;\ncase GENERIC:\nwords2.addAll(words);\nbreak;\ndefault:\nthrow new IllegalStateException(\"Unreachable case: \" + this.nameType);\n}\n\nif (this.concat) {\n// concat mode enabled\ninput = join(words2, \" \");\n} else if (words2.size() == 1) {\n// not a multi-word name\ninput = words.iterator().next();\n} else {\n// encode each word in a multi-word name separately (normally used for approx matches)\nfinal StringBuilder result = new StringBuilder();\nfor (final String word : words2) {\nresult.append(\"-\").append(encode(word));\n}\n// return the result without the leading \"-\"\nreturn result.substring(1);\n}\n\nPhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);\n\n// loop over each char in the input - we will handle the increment manually\nfor (int i = 0; i < input.length();) {\nfinal RulesApplication rulesApplication =\nnew RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();\ni = rulesApplication.getI();\nphonemeBuilder = rulesApplication.getPhonemeBuilder();\n}\n\n// Apply the general rules\nphonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);\n// Apply the language-specific rules\nphonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);\n\nreturn phonemeBuilder.makeString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Lang:<init>(Ljava/util/List;Lorg/apache/commons/codec/language/bm/Languages;)V",
                                    "method_body": "private Lang(final List<LangRule> rules, final Languages languages) {\nthis.rules = Collections.unmodifiableList(rules);\nthis.languages = languages;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Lang:<clinit>()V",
                                    "method_body": "private static final Map<NameType, Lang> Langs = new EnumMap<NameType, Lang>(NameType.class);\n\nprivate static final String LANGUAGE_RULES_RN = \"org/apache/commons/codec/language/bm/lang.txt\";\n\nstatic {\nfor (final NameType s : NameType.values()) {\nLangs.put(s, loadFromResource(LANGUAGE_RULES_RN, Languages.getInstance(s)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Lang:instance(Lorg/apache/commons/codec/language/bm/NameType;)Lorg/apache/commons/codec/language/bm/Lang;",
                                    "method_body": "public static Lang instance(final NameType nameType) {\nreturn Langs.get(nameType);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Lang:loadFromResource(Ljava/lang/String;Lorg/apache/commons/codec/language/bm/Languages;)Lorg/apache/commons/codec/language/bm/Lang;",
                                    "method_body": "public static Lang loadFromResource(final String languageRulesResourceName, final Languages languages) {\nfinal List<LangRule> rules = new ArrayList<LangRule>();\nfinal InputStream lRulesIS = Lang.class.getClassLoader().getResourceAsStream(languageRulesResourceName);\n\nif (lRulesIS == null) {\nthrow new IllegalStateException(\"Unable to resolve required resource:\" + LANGUAGE_RULES_RN);\n}\n\nfinal Scanner scanner = new Scanner(lRulesIS, ResourceConstants.ENCODING);\ntry {\nboolean inExtendedComment = false;\nwhile (scanner.hasNextLine()) {\nfinal String rawLine = scanner.nextLine();\nString line = rawLine;\nif (inExtendedComment) {\n// check for closing comment marker, otherwise discard doc comment line\nif (line.endsWith(ResourceConstants.EXT_CMT_END)) {\ninExtendedComment = false;\n}\n} else {\nif (line.startsWith(ResourceConstants.EXT_CMT_START)) {\ninExtendedComment = true;\n} else {\n// discard comments\nfinal int cmtI = line.indexOf(ResourceConstants.CMT);\nif (cmtI >= 0) {\nline = line.substring(0, cmtI);\n}\n\n// trim leading-trailing whitespace\nline = line.trim();\n\nif (line.length() == 0) {\ncontinue; // empty lines can be safely skipped\n}\n\n// split it up\nfinal String[] parts = line.split(\"\\\\s+\");\n\nif (parts.length != 3) {\nthrow new IllegalArgumentException(\"Malformed line '\" + rawLine +\n\"' in language resource '\" + languageRulesResourceName + \"'\");\n}\n\nfinal Pattern pattern = Pattern.compile(parts[0]);\nfinal String[] langs = parts[1].split(\"\\\\+\");\nfinal boolean accept = parts[2].equals(\"true\");\n\nrules.add(new LangRule(pattern, new HashSet<String>(Arrays.asList(langs)), accept));\n}\n}\n}\n} finally {\nscanner.close();\n}\nreturn new Lang(rules, languages);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Lang:guessLanguages(Ljava/lang/String;)Lorg/apache/commons/codec/language/bm/Languages$LanguageSet;",
                                    "method_body": "public Languages.LanguageSet guessLanguages(final String input) {\nfinal String text = input.toLowerCase(Locale.ENGLISH);\n\nfinal Set<String> langs = new HashSet<String>(this.languages.getLanguages());\nfor (final LangRule rule : this.rules) {\nif (rule.matches(text)) {\nif (rule.acceptOnMatch) {\nlangs.retainAll(rule.languages);\n} else {\nlangs.removeAll(rule.languages);\n}\n}\n}\n\nfinal Languages.LanguageSet ls = Languages.LanguageSet.from(langs);\nreturn ls.equals(Languages.NO_LANGUAGES) ? Languages.ANY_LANGUAGE : ls;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Languages:<init>(Ljava/util/Set;)V",
                                    "method_body": "private Languages(final Set<String> languages) {\nthis.languages = languages;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Languages:<clinit>()V",
                                    "method_body": "public static final String ANY = \"any\";\n\nprivate static final Map<NameType, Languages> LANGUAGES = new EnumMap<NameType, Languages>(NameType.class);\n\nstatic {\nfor (final NameType s : NameType.values()) {\nLANGUAGES.put(s, getInstance(langResourceName(s)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Languages:getInstance(Lorg/apache/commons/codec/language/bm/NameType;)Lorg/apache/commons/codec/language/bm/Languages;",
                                    "method_body": "public static Languages getInstance(final NameType nameType) {\nreturn LANGUAGES.get(nameType);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Languages:getInstance(Ljava/lang/String;)Lorg/apache/commons/codec/language/bm/Languages;",
                                    "method_body": "public static Languages getInstance(final String languagesResourceName) {\n// read languages list\nfinal Set<String> ls = new HashSet<String>();\nfinal InputStream langIS = Languages.class.getClassLoader().getResourceAsStream(languagesResourceName);\n\nif (langIS == null) {\nthrow new IllegalArgumentException(\"Unable to resolve required resource: \" + languagesResourceName);\n}\n\nfinal Scanner lsScanner = new Scanner(langIS, ResourceConstants.ENCODING);\ntry {\nboolean inExtendedComment = false;\nwhile (lsScanner.hasNextLine()) {\nfinal String line = lsScanner.nextLine().trim();\nif (inExtendedComment) {\nif (line.endsWith(ResourceConstants.EXT_CMT_END)) {\ninExtendedComment = false;\n}\n} else {\nif (line.startsWith(ResourceConstants.EXT_CMT_START)) {\ninExtendedComment = true;\n} else if (line.length() > 0) {\nls.add(line);\n}\n}\n}\n} finally {\nlsScanner.close();\n}\n\nreturn new Languages(Collections.unmodifiableSet(ls));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Languages:langResourceName(Lorg/apache/commons/codec/language/bm/NameType;)Ljava/lang/String;",
                                    "method_body": "private static String langResourceName(final NameType nameType) {\nreturn String.format(\"org/apache/commons/codec/language/bm/%s_languages.txt\", nameType.getName());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Languages:getLanguages()Ljava/util/Set;",
                                    "method_body": "public Set<String> getLanguages() {\nreturn this.languages;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Languages$LanguageSet:from(Ljava/util/Set;)Lorg/apache/commons/codec/language/bm/Languages$LanguageSet;",
                                    "method_body": "public static LanguageSet from(final Set<String> langs) {\nreturn langs.isEmpty() ? NO_LANGUAGES : new SomeLanguages(langs);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Languages$1:isEmpty()Z",
                                    "method_body": "public boolean isEmpty() {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Languages$SomeLanguages:<init>(Ljava/util/Set;)V",
                                    "method_body": "public abstract boolean contains(String language);\n\npublic abstract String getAny();\n\npublic abstract boolean isEmpty();\n\npublic abstract boolean isSingleton();\n\npublic abstract LanguageSet restrictTo(LanguageSet other);\n\npublic abstract LanguageSet merge(LanguageSet other);\n}\n\n/**\n* Some languages, explicitly enumerated.\n*/\npublic static final class SomeLanguages extends LanguageSet {\nprivate final Set<String> languages;\n\nprivate SomeLanguages(final Set<String> languages) {\nthis.languages = Collections.unmodifiableSet(languages);\n}\n\n@Override\npublic boolean contains(final String language) {\nreturn this.languages.contains(language);\n}\n\n@Override\npublic String getAny() {\nreturn this.languages.iterator().next();\n}\n\npublic Set<String> getLanguages() {\nreturn this.languages;\n}\n\n@Override\npublic boolean isEmpty() {\nreturn this.languages.isEmpty();\n}\n\n@Override\npublic boolean isSingleton() {\nreturn this.languages.size() == 1;\n}\n\n@Override\npublic LanguageSet restrictTo(final LanguageSet other) {\nif (other == NO_LANGUAGES) {\nreturn other;\n} else if (other == ANY_LANGUAGE) {\nreturn this;\n} else {\nfinal SomeLanguages sl = (SomeLanguages) other;\nfinal Set<String> ls = new HashSet<String>(Math.min(languages.size(), sl.languages.size()));\nfor (String lang : languages) {\nif (sl.languages.contains(lang)) {\nls.add(lang);\n}\n}\nreturn from(ls);\n}\n}\n\n@Override\npublic LanguageSet merge(final LanguageSet other) {\nif (other == NO_LANGUAGES) {\nreturn this;\n} else if (other == ANY_LANGUAGE) {\nreturn other;\n} else {\nfinal SomeLanguages sl = (SomeLanguages) other;\nfinal Set<String> ls = new HashSet<String>(languages);\nfor (String lang : sl.languages) {\nls.add(lang);\n}\nreturn from(ls);\n}\n}\n\n@Override\npublic String toString() {\nreturn \"Languages(\" + languages.toString() + \")\";\n}\n\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Languages$SomeLanguages:isEmpty()Z",
                                    "method_body": "public abstract boolean contains(String language);\n\npublic abstract String getAny();\n\npublic abstract boolean isEmpty();\n\npublic abstract boolean isSingleton();\n\npublic abstract LanguageSet restrictTo(LanguageSet other);\n\npublic abstract LanguageSet merge(LanguageSet other);\n}\n\n/**\n* Some languages, explicitly enumerated.\n*/\npublic static final class SomeLanguages extends LanguageSet {\nprivate final Set<String> languages;\n\nprivate SomeLanguages(final Set<String> languages) {\nthis.languages = Collections.unmodifiableSet(languages);\n}\n\n@Override\npublic boolean contains(final String language) {\nreturn this.languages.contains(language);\n}\n\n@Override\npublic String getAny() {\nreturn this.languages.iterator().next();\n}\n\npublic Set<String> getLanguages() {\nreturn this.languages;\n}\n\n@Override\npublic boolean isEmpty() {\nreturn this.languages.isEmpty();\n}\n\n@Override\npublic boolean isSingleton() {\nreturn this.languages.size() == 1;\n}\n\n@Override\npublic LanguageSet restrictTo(final LanguageSet other) {\nif (other == NO_LANGUAGES) {\nreturn other;\n} else if (other == ANY_LANGUAGE) {\nreturn this;\n} else {\nfinal SomeLanguages sl = (SomeLanguages) other;\nfinal Set<String> ls = new HashSet<String>(Math.min(languages.size(), sl.languages.size()));\nfor (String lang : languages) {\nif (sl.languages.contains(lang)) {\nls.add(lang);\n}\n}\nreturn from(ls);\n}\n}\n\n@Override\npublic LanguageSet merge(final LanguageSet other) {\nif (other == NO_LANGUAGES) {\nreturn this;\n} else if (other == ANY_LANGUAGE) {\nreturn other;\n} else {\nfinal SomeLanguages sl = (SomeLanguages) other;\nfinal Set<String> ls = new HashSet<String>(languages);\nfor (String lang : sl.languages) {\nls.add(lang);\n}\nreturn from(ls);\n}\n}\n\n@Override\npublic String toString() {\nreturn \"Languages(\" + languages.toString() + \")\";\n}\n\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Languages$SomeLanguages:isSingleton()Z",
                                    "method_body": "public abstract boolean contains(String language);\n\npublic abstract String getAny();\n\npublic abstract boolean isEmpty();\n\npublic abstract boolean isSingleton();\n\npublic abstract LanguageSet restrictTo(LanguageSet other);\n\npublic abstract LanguageSet merge(LanguageSet other);\n}\n\n/**\n* Some languages, explicitly enumerated.\n*/\npublic static final class SomeLanguages extends LanguageSet {\nprivate final Set<String> languages;\n\nprivate SomeLanguages(final Set<String> languages) {\nthis.languages = Collections.unmodifiableSet(languages);\n}\n\n@Override\npublic boolean contains(final String language) {\nreturn this.languages.contains(language);\n}\n\n@Override\npublic String getAny() {\nreturn this.languages.iterator().next();\n}\n\npublic Set<String> getLanguages() {\nreturn this.languages;\n}\n\n@Override\npublic boolean isEmpty() {\nreturn this.languages.isEmpty();\n}\n\n@Override\npublic boolean isSingleton() {\nreturn this.languages.size() == 1;\n}\n\n@Override\npublic LanguageSet restrictTo(final LanguageSet other) {\nif (other == NO_LANGUAGES) {\nreturn other;\n} else if (other == ANY_LANGUAGE) {\nreturn this;\n} else {\nfinal SomeLanguages sl = (SomeLanguages) other;\nfinal Set<String> ls = new HashSet<String>(Math.min(languages.size(), sl.languages.size()));\nfor (String lang : languages) {\nif (sl.languages.contains(lang)) {\nls.add(lang);\n}\n}\nreturn from(ls);\n}\n}\n\n@Override\npublic LanguageSet merge(final LanguageSet other) {\nif (other == NO_LANGUAGES) {\nreturn this;\n} else if (other == ANY_LANGUAGE) {\nreturn other;\n} else {\nfinal SomeLanguages sl = (SomeLanguages) other;\nfinal Set<String> ls = new HashSet<String>(languages);\nfor (String lang : sl.languages) {\nls.add(lang);\n}\nreturn from(ls);\n}\n}\n\n@Override\npublic String toString() {\nreturn \"Languages(\" + languages.toString() + \")\";\n}\n\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Languages$SomeLanguages:restrictTo(Lorg/apache/commons/codec/language/bm/Languages$LanguageSet;)Lorg/apache/commons/codec/language/bm/Languages$LanguageSet;",
                                    "method_body": "public abstract boolean contains(String language);\n\npublic abstract String getAny();\n\npublic abstract boolean isEmpty();\n\npublic abstract boolean isSingleton();\n\npublic abstract LanguageSet restrictTo(LanguageSet other);\n\npublic abstract LanguageSet merge(LanguageSet other);\n}\n\n/**\n* Some languages, explicitly enumerated.\n*/\npublic static final class SomeLanguages extends LanguageSet {\nprivate final Set<String> languages;\n\nprivate SomeLanguages(final Set<String> languages) {\nthis.languages = Collections.unmodifiableSet(languages);\n}\n\n@Override\npublic boolean contains(final String language) {\nreturn this.languages.contains(language);\n}\n\n@Override\npublic String getAny() {\nreturn this.languages.iterator().next();\n}\n\npublic Set<String> getLanguages() {\nreturn this.languages;\n}\n\n@Override\npublic boolean isEmpty() {\nreturn this.languages.isEmpty();\n}\n\n@Override\npublic boolean isSingleton() {\nreturn this.languages.size() == 1;\n}\n\n@Override\npublic LanguageSet restrictTo(final LanguageSet other) {\nif (other == NO_LANGUAGES) {\nreturn other;\n} else if (other == ANY_LANGUAGE) {\nreturn this;\n} else {\nfinal SomeLanguages sl = (SomeLanguages) other;\nfinal Set<String> ls = new HashSet<String>(Math.min(languages.size(), sl.languages.size()));\nfor (String lang : languages) {\nif (sl.languages.contains(lang)) {\nls.add(lang);\n}\n}\nreturn from(ls);\n}\n}\n\n@Override\npublic LanguageSet merge(final LanguageSet other) {\nif (other == NO_LANGUAGES) {\nreturn this;\n} else if (other == ANY_LANGUAGE) {\nreturn other;\n} else {\nfinal SomeLanguages sl = (SomeLanguages) other;\nfinal Set<String> ls = new HashSet<String>(languages);\nfor (String lang : sl.languages) {\nls.add(lang);\n}\nreturn from(ls);\n}\n}\n\n@Override\npublic String toString() {\nreturn \"Languages(\" + languages.toString() + \")\";\n}\n\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:<init>(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lorg/apache/commons/codec/language/bm/Rule$PhonemeExpr;)V",
                                    "method_body": "public Rule(final String pattern, final String lContext, final String rContext, final PhonemeExpr phoneme) {\nthis.pattern = pattern;\nthis.lContext = pattern(lContext + \"$\");\nthis.rContext = pattern(\"^\" + rContext);\nthis.phoneme = phoneme;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:<clinit>()V",
                                    "method_body": "boolean isMatch(CharSequence input);\n}\n\npublic static final RPattern ALL_STRINGS_RMATCHER = new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn true;\n}\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:contains(Ljava/lang/CharSequence;C)Z",
                                    "method_body": "private static boolean contains(final CharSequence chars, final char input) {\nfor (int i = 0; i < chars.length(); i++) {\nif (chars.charAt(i) == input) {\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:createResourceName(Lorg/apache/commons/codec/language/bm/NameType;Lorg/apache/commons/codec/language/bm/RuleType;Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String createResourceName(final NameType nameType, final RuleType rt, final String lang) {\nreturn String.format(\"org/apache/commons/codec/language/bm/%s_%s_%s.txt\",\nnameType.getName(), rt.getName(), lang);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:createScanner(Lorg/apache/commons/codec/language/bm/NameType;Lorg/apache/commons/codec/language/bm/RuleType;Ljava/lang/String;)Ljava/util/Scanner;",
                                    "method_body": "private static Scanner createScanner(final NameType nameType, final RuleType rt, final String lang) {\nfinal String resName = createResourceName(nameType, rt, lang);\nfinal InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\n\nif (rulesIS == null) {\nthrow new IllegalArgumentException(\"Unable to load resource: \" + resName);\n}\n\nreturn new Scanner(rulesIS, ResourceConstants.ENCODING);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:createScanner(Ljava/lang/String;)Ljava/util/Scanner;",
                                    "method_body": "private static Scanner createScanner(final String lang) {\nfinal String resName = String.format(\"org/apache/commons/codec/language/bm/%s.txt\", lang);\nfinal InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\n\nif (rulesIS == null) {\nthrow new IllegalArgumentException(\"Unable to load resource: \" + resName);\n}\n\nreturn new Scanner(rulesIS, ResourceConstants.ENCODING);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:getInstanceMap(Lorg/apache/commons/codec/language/bm/NameType;Lorg/apache/commons/codec/language/bm/RuleType;Lorg/apache/commons/codec/language/bm/Languages$LanguageSet;)Ljava/util/Map;",
                                    "method_body": "public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt,\nfinal Languages.LanguageSet langs) {\nreturn langs.isSingleton() ? getInstanceMap(nameType, rt, langs.getAny()) :\ngetInstanceMap(nameType, rt, Languages.ANY);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:getInstanceMap(Lorg/apache/commons/codec/language/bm/NameType;Lorg/apache/commons/codec/language/bm/RuleType;Ljava/lang/String;)Ljava/util/Map;",
                                    "method_body": "public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt,\nfinal String lang) {\nfinal Map<String, List<Rule>> rules = RULES.get(nameType).get(rt).get(lang);\n\nif (rules == null) {\nthrow new IllegalArgumentException(String.format(\"No rules found for %s, %s, %s.\",\nnameType.getName(), rt.getName(), lang));\n}\n\nreturn rules;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:parsePhoneme(Ljava/lang/String;)Lorg/apache/commons/codec/language/bm/Rule$Phoneme;",
                                    "method_body": "private static Phoneme parsePhoneme(final String ph) {\nfinal int open = ph.indexOf(\"[\");\nif (open >= 0) {\nif (!ph.endsWith(\"]\")) {\nthrow new IllegalArgumentException(\"Phoneme expression contains a '[' but does not end in ']'\");\n}\nfinal String before = ph.substring(0, open);\nfinal String in = ph.substring(open + 1, ph.length() - 1);\nfinal Set<String> langs = new HashSet<String>(Arrays.asList(in.split(\"[+]\")));\n\nreturn new Phoneme(before, Languages.LanguageSet.from(langs));\n} else {\nreturn new Phoneme(ph, Languages.ANY_LANGUAGE);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:parsePhonemeExpr(Ljava/lang/String;)Lorg/apache/commons/codec/language/bm/Rule$PhonemeExpr;",
                                    "method_body": "private static PhonemeExpr parsePhonemeExpr(final String ph) {\nif (ph.startsWith(\"(\")) { // we have a bracketed list of options\nif (!ph.endsWith(\")\")) {\nthrow new IllegalArgumentException(\"Phoneme starts with '(' so must end with ')'\");\n}\n\nfinal List<Phoneme> phs = new ArrayList<Phoneme>();\nfinal String body = ph.substring(1, ph.length() - 1);\nfor (final String part : body.split(\"[|]\")) {\nphs.add(parsePhoneme(part));\n}\nif (body.startsWith(\"|\") || body.endsWith(\"|\")) {\nphs.add(new Phoneme(\"\", Languages.ANY_LANGUAGE));\n}\n\nreturn new PhonemeList(phs);\n} else {\nreturn parsePhoneme(ph);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:parseRules(Ljava/util/Scanner;Ljava/lang/String;)Ljava/util/Map;",
                                    "method_body": "private static Map<String, List<Rule>> parseRules(final Scanner scanner, final String location) {\nfinal Map<String, List<Rule>> lines = new HashMap<String, List<Rule>>();\nint currentLine = 0;\n\nboolean inMultilineComment = false;\nwhile (scanner.hasNextLine()) {\ncurrentLine++;\nfinal String rawLine = scanner.nextLine();\nString line = rawLine;\n\nif (inMultilineComment) {\nif (line.endsWith(ResourceConstants.EXT_CMT_END)) {\ninMultilineComment = false;\n}\n} else {\nif (line.startsWith(ResourceConstants.EXT_CMT_START)) {\ninMultilineComment = true;\n} else {\n// discard comments\nfinal int cmtI = line.indexOf(ResourceConstants.CMT);\nif (cmtI >= 0) {\nline = line.substring(0, cmtI);\n}\n\n// trim leading-trailing whitespace\nline = line.trim();\n\nif (line.length() == 0) {\ncontinue; // empty lines can be safely skipped\n}\n\nif (line.startsWith(HASH_INCLUDE)) {\n// include statement\nfinal String incl = line.substring(HASH_INCLUDE.length()).trim();\nif (incl.contains(\" \")) {\nthrow new IllegalArgumentException(\"Malformed import statement '\" + rawLine + \"' in \" +\nlocation);\n} else {\nlines.putAll(parseRules(createScanner(incl), location + \"->\" + incl));\n}\n} else {\n// rule\nfinal String[] parts = line.split(\"\\\\s+\");\nif (parts.length != 4) {\nthrow new IllegalArgumentException(\"Malformed rule statement split into \" + parts.length +\n\" parts: \" + rawLine + \" in \" + location);\n} else {\ntry {\nfinal String pat = stripQuotes(parts[0]);\nfinal String lCon = stripQuotes(parts[1]);\nfinal String rCon = stripQuotes(parts[2]);\nfinal PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3]));\nfinal int cLine = currentLine;\nfinal Rule r = new Rule(pat, lCon, rCon, ph) {\nprivate final int myLine = cLine;\nprivate final String loc = location;\n\n@Override\npublic String toString() {\nfinal StringBuilder sb = new StringBuilder();\nsb.append(\"Rule\");\nsb.append(\"{line=\").append(myLine);\nsb.append(\", loc='\").append(loc).append('\\'');\nsb.append(\", pat='\").append(pat).append('\\'');\nsb.append(\", lcon='\").append(lCon).append('\\'');\nsb.append(\", rcon='\").append(rCon).append('\\'');\nsb.append('}');\nreturn sb.toString();\n}\n};\nfinal String patternKey = r.pattern.substring(0,1);\nList<Rule> rules = lines.get(patternKey);\nif (rules == null) {\nrules = new ArrayList<Rule>();\nlines.put(patternKey, rules);\n}\nrules.add(r);\n} catch (final IllegalArgumentException e) {\nthrow new IllegalStateException(\"Problem parsing line '\" + currentLine + \"' in \" +\nlocation, e);\n}\n}\n}\n}\n}\n}\n\nreturn lines;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:pattern(Ljava/lang/String;)Lorg/apache/commons/codec/language/bm/Rule$RPattern;",
                                    "method_body": "private static RPattern pattern(final String regex) {\nfinal boolean startsWith = regex.startsWith(\"^\");\nfinal boolean endsWith = regex.endsWith(\"$\");\nfinal String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\nfinal boolean boxes = content.contains(\"[\");\n\nif (!boxes) {\nif (startsWith && endsWith) {\n// exact match\nif (content.length() == 0) {\n// empty\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() == 0;\n}\n};\n} else {\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.equals(content);\n}\n};\n}\n} else if ((startsWith || endsWith) && content.length() == 0) {\n// matches every string\nreturn ALL_STRINGS_RMATCHER;\n} else if (startsWith) {\n// matches from start\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn startsWith(input, content);\n}\n};\n} else if (endsWith) {\n// matches from start\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn endsWith(input, content);\n}\n};\n}\n} else {\nfinal boolean startsWithBox = content.startsWith(\"[\");\nfinal boolean endsWithBox = content.endsWith(\"]\");\n\nif (startsWithBox && endsWithBox) {\nString boxContent = content.substring(1, content.length() - 1);\nif (!boxContent.contains(\"[\")) {\n// box containing alternatives\nfinal boolean negate = boxContent.startsWith(\"^\");\nif (negate) {\nboxContent = boxContent.substring(1);\n}\nfinal String bContent = boxContent;\nfinal boolean shouldMatch = !negate;\n\nif (startsWith && endsWith) {\n// exact match\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n}\n};\n} else if (startsWith) {\n// first char\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n}\n};\n} else if (endsWith) {\n// last char\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() > 0 &&\ncontains(bContent, input.charAt(input.length() - 1)) == shouldMatch;\n}\n};\n}\n}\n}\n}\n\nreturn new RPattern() {\nPattern pattern = Pattern.compile(regex);\n\n@Override\npublic boolean isMatch(final CharSequence input) {\nfinal Matcher matcher = pattern.matcher(input);\nreturn matcher.find();\n}\n};\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:startsWith(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Z",
                                    "method_body": "private static boolean startsWith(final CharSequence input, final CharSequence prefix) {\nif (prefix.length() > input.length()) {\nreturn false;\n}\nfor (int i = 0; i < prefix.length(); i++) {\nif (input.charAt(i) != prefix.charAt(i)) {\nreturn false;\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:stripQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static String stripQuotes(String str) {\nif (str.startsWith(DOUBLE_QUOTE)) {\nstr = str.substring(1);\n}\n\nif (str.endsWith(DOUBLE_QUOTE)) {\nstr = str.substring(0, str.length() - 1);\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:getPattern()Ljava/lang/String;",
                                    "method_body": "public String getPattern() {\nreturn this.pattern;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:getPhoneme()Lorg/apache/commons/codec/language/bm/Rule$PhonemeExpr;",
                                    "method_body": "public PhonemeExpr getPhoneme() {\nreturn this.phoneme;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule:patternAndContextMatches(Ljava/lang/CharSequence;I)Z",
                                    "method_body": "public boolean patternAndContextMatches(final CharSequence input, final int i) {\nif (i < 0) {\nthrow new IndexOutOfBoundsException(\"Can not match pattern at negative indexes\");\n}\n\nfinal int patternLength = this.pattern.length();\nfinal int ipl = i + patternLength;\n\nif (ipl > input.length()) {\n// not enough room for the pattern to match\nreturn false;\n}\n\n// evaluate the pattern, left context and right context\n// fail early if any of the evaluations is not successful\nif (!input.subSequence(i, ipl).equals(this.pattern)) {\nreturn false;\n} else if (!this.rContext.isMatch(input.subSequence(ipl, input.length()))) {\nreturn false;\n}\nreturn this.lContext.isMatch(input.subSequence(0, i));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$1:isMatch(Ljava/lang/CharSequence;)Z",
                                    "method_body": "boolean isMatch(CharSequence input);\n}\n\npublic static final RPattern ALL_STRINGS_RMATCHER = new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn true;\n}\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$Phoneme:<init>(Ljava/lang/CharSequence;Lorg/apache/commons/codec/language/bm/Languages$LanguageSet;)V",
                                    "method_body": "public Phoneme(final CharSequence phonemeText, final Languages.LanguageSet languages) {\nthis.phonemeText = new StringBuilder(phonemeText);\nthis.languages = languages;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$Phoneme:<init>(Lorg/apache/commons/codec/language/bm/Rule$Phoneme;Lorg/apache/commons/codec/language/bm/Rule$Phoneme;Lorg/apache/commons/codec/language/bm/Languages$LanguageSet;)V",
                                    "method_body": "public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight, final Languages.LanguageSet languages) {\nthis(phonemeLeft.phonemeText, languages);\nthis.phonemeText.append(phonemeRight.phonemeText);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$Phoneme:<clinit>()V",
                                    "method_body": "public static final Comparator<Phoneme> COMPARATOR = new Comparator<Phoneme>() {\n@Override\npublic int compare(final Phoneme o1, final Phoneme o2) {\nfor (int i = 0; i < o1.phonemeText.length(); i++) {\nif (i >= o2.phonemeText.length()) {\nreturn +1;\n}\nfinal int c = o1.phonemeText.charAt(i) - o2.phonemeText.charAt(i);\nif (c != 0) {\nreturn c;\n}\n}\n\nif (o1.phonemeText.length() < o2.phonemeText.length()) {\nreturn -1;\n}\n\nreturn 0;\n}\n};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$Phoneme:append(Ljava/lang/CharSequence;)Lorg/apache/commons/codec/language/bm/Rule$Phoneme;",
                                    "method_body": "public Phoneme append(final CharSequence str) {\nthis.phonemeText.append(str);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$Phoneme:getLanguages()Lorg/apache/commons/codec/language/bm/Languages$LanguageSet;",
                                    "method_body": "public Languages.LanguageSet getLanguages() {\nreturn this.languages;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$Phoneme:getPhonemes()Ljava/lang/Iterable;",
                                    "method_body": "public Iterable<Phoneme> getPhonemes() {\nreturn Collections.singleton(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$Phoneme:getPhonemeText()Ljava/lang/CharSequence;",
                                    "method_body": "public CharSequence getPhonemeText() {\nreturn this.phonemeText;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$Phoneme$1:compare(Lorg/apache/commons/codec/language/bm/Rule$Phoneme;Lorg/apache/commons/codec/language/bm/Rule$Phoneme;)I",
                                    "method_body": "public int compare(final Phoneme o1, final Phoneme o2) {\nfor (int i = 0; i < o1.phonemeText.length(); i++) {\nif (i >= o2.phonemeText.length()) {\nreturn +1;\n}\nfinal int c = o1.phonemeText.charAt(i) - o2.phonemeText.charAt(i);\nif (c != 0) {\nreturn c;\n}\n}\n\nif (o1.phonemeText.length() < o2.phonemeText.length()) {\nreturn -1;\n}\n\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$3:isMatch(Ljava/lang/CharSequence;)Z",
                                    "method_body": "private static RPattern pattern(final String regex) {\nfinal boolean startsWith = regex.startsWith(\"^\");\nfinal boolean endsWith = regex.endsWith(\"$\");\nfinal String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\nfinal boolean boxes = content.contains(\"[\");\n\nif (!boxes) {\nif (startsWith && endsWith) {\n// exact match\nif (content.length() == 0) {\n// empty\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() == 0;\n}\n};\n} else {\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.equals(content);\n}\n};\n}\n} else if ((startsWith || endsWith) && content.length() == 0) {\n// matches every string\nreturn ALL_STRINGS_RMATCHER;\n} else if (startsWith) {\n// matches from start\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn startsWith(input, content);\n}\n};\n} else if (endsWith) {\n// matches from start\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn endsWith(input, content);\n}\n};\n}\n} else {\nfinal boolean startsWithBox = content.startsWith(\"[\");\nfinal boolean endsWithBox = content.endsWith(\"]\");\n\nif (startsWithBox && endsWithBox) {\nString boxContent = content.substring(1, content.length() - 1);\nif (!boxContent.contains(\"[\")) {\n// box containing alternatives\nfinal boolean negate = boxContent.startsWith(\"^\");\nif (negate) {\nboxContent = boxContent.substring(1);\n}\nfinal String bContent = boxContent;\nfinal boolean shouldMatch = !negate;\n\nif (startsWith && endsWith) {\n// exact match\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n}\n};\n} else if (startsWith) {\n// first char\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n}\n};\n} else if (endsWith) {\n// last char\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() > 0 &&\ncontains(bContent, input.charAt(input.length() - 1)) == shouldMatch;\n}\n};\n}\n}\n}\n}\n\nreturn new RPattern() {\nPattern pattern = Pattern.compile(regex);\n\n@Override\npublic boolean isMatch(final CharSequence input) {\nfinal Matcher matcher = pattern.matcher(input);\nreturn matcher.find();\n}\n};\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$9:isMatch(Ljava/lang/CharSequence;)Z",
                                    "method_body": "private static RPattern pattern(final String regex) {\nfinal boolean startsWith = regex.startsWith(\"^\");\nfinal boolean endsWith = regex.endsWith(\"$\");\nfinal String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\nfinal boolean boxes = content.contains(\"[\");\n\nif (!boxes) {\nif (startsWith && endsWith) {\n// exact match\nif (content.length() == 0) {\n// empty\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() == 0;\n}\n};\n} else {\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.equals(content);\n}\n};\n}\n} else if ((startsWith || endsWith) && content.length() == 0) {\n// matches every string\nreturn ALL_STRINGS_RMATCHER;\n} else if (startsWith) {\n// matches from start\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn startsWith(input, content);\n}\n};\n} else if (endsWith) {\n// matches from start\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn endsWith(input, content);\n}\n};\n}\n} else {\nfinal boolean startsWithBox = content.startsWith(\"[\");\nfinal boolean endsWithBox = content.endsWith(\"]\");\n\nif (startsWithBox && endsWithBox) {\nString boxContent = content.substring(1, content.length() - 1);\nif (!boxContent.contains(\"[\")) {\n// box containing alternatives\nfinal boolean negate = boxContent.startsWith(\"^\");\nif (negate) {\nboxContent = boxContent.substring(1);\n}\nfinal String bContent = boxContent;\nfinal boolean shouldMatch = !negate;\n\nif (startsWith && endsWith) {\n// exact match\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n}\n};\n} else if (startsWith) {\n// first char\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n}\n};\n} else if (endsWith) {\n// last char\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() > 0 &&\ncontains(bContent, input.charAt(input.length() - 1)) == shouldMatch;\n}\n};\n}\n}\n}\n}\n\nreturn new RPattern() {\nPattern pattern = Pattern.compile(regex);\n\n@Override\npublic boolean isMatch(final CharSequence input) {\nfinal Matcher matcher = pattern.matcher(input);\nreturn matcher.find();\n}\n};\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$7:isMatch(Ljava/lang/CharSequence;)Z",
                                    "method_body": "private static RPattern pattern(final String regex) {\nfinal boolean startsWith = regex.startsWith(\"^\");\nfinal boolean endsWith = regex.endsWith(\"$\");\nfinal String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\nfinal boolean boxes = content.contains(\"[\");\n\nif (!boxes) {\nif (startsWith && endsWith) {\n// exact match\nif (content.length() == 0) {\n// empty\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() == 0;\n}\n};\n} else {\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.equals(content);\n}\n};\n}\n} else if ((startsWith || endsWith) && content.length() == 0) {\n// matches every string\nreturn ALL_STRINGS_RMATCHER;\n} else if (startsWith) {\n// matches from start\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn startsWith(input, content);\n}\n};\n} else if (endsWith) {\n// matches from start\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn endsWith(input, content);\n}\n};\n}\n} else {\nfinal boolean startsWithBox = content.startsWith(\"[\");\nfinal boolean endsWithBox = content.endsWith(\"]\");\n\nif (startsWithBox && endsWithBox) {\nString boxContent = content.substring(1, content.length() - 1);\nif (!boxContent.contains(\"[\")) {\n// box containing alternatives\nfinal boolean negate = boxContent.startsWith(\"^\");\nif (negate) {\nboxContent = boxContent.substring(1);\n}\nfinal String bContent = boxContent;\nfinal boolean shouldMatch = !negate;\n\nif (startsWith && endsWith) {\n// exact match\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n}\n};\n} else if (startsWith) {\n// first char\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n}\n};\n} else if (endsWith) {\n// last char\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() > 0 &&\ncontains(bContent, input.charAt(input.length() - 1)) == shouldMatch;\n}\n};\n}\n}\n}\n}\n\nreturn new RPattern() {\nPattern pattern = Pattern.compile(regex);\n\n@Override\npublic boolean isMatch(final CharSequence input) {\nfinal Matcher matcher = pattern.matcher(input);\nreturn matcher.find();\n}\n};\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$PhonemeList:<init>(Ljava/util/List;)V",
                                    "method_body": "Iterable<Phoneme> getPhonemes();\n}\n\npublic static final class PhonemeList implements PhonemeExpr {\nprivate final List<Phoneme> phonemes;\n\npublic PhonemeList(final List<Phoneme> phonemes) {\nthis.phonemes = phonemes;\n}\n\n@Override\npublic List<Phoneme> getPhonemes() {\nreturn this.phonemes;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$PhonemeList:getPhonemes()Ljava/util/List;",
                                    "method_body": "Iterable<Phoneme> getPhonemes();\n}\n\npublic static final class PhonemeList implements PhonemeExpr {\nprivate final List<Phoneme> phonemes;\n\npublic PhonemeList(final List<Phoneme> phonemes) {\nthis.phonemes = phonemes;\n}\n\n@Override\npublic List<Phoneme> getPhonemes() {\nreturn this.phonemes;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$4:isMatch(Ljava/lang/CharSequence;)Z",
                                    "method_body": "private static RPattern pattern(final String regex) {\nfinal boolean startsWith = regex.startsWith(\"^\");\nfinal boolean endsWith = regex.endsWith(\"$\");\nfinal String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\nfinal boolean boxes = content.contains(\"[\");\n\nif (!boxes) {\nif (startsWith && endsWith) {\n// exact match\nif (content.length() == 0) {\n// empty\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() == 0;\n}\n};\n} else {\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.equals(content);\n}\n};\n}\n} else if ((startsWith || endsWith) && content.length() == 0) {\n// matches every string\nreturn ALL_STRINGS_RMATCHER;\n} else if (startsWith) {\n// matches from start\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn startsWith(input, content);\n}\n};\n} else if (endsWith) {\n// matches from start\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn endsWith(input, content);\n}\n};\n}\n} else {\nfinal boolean startsWithBox = content.startsWith(\"[\");\nfinal boolean endsWithBox = content.endsWith(\"]\");\n\nif (startsWithBox && endsWithBox) {\nString boxContent = content.substring(1, content.length() - 1);\nif (!boxContent.contains(\"[\")) {\n// box containing alternatives\nfinal boolean negate = boxContent.startsWith(\"^\");\nif (negate) {\nboxContent = boxContent.substring(1);\n}\nfinal String bContent = boxContent;\nfinal boolean shouldMatch = !negate;\n\nif (startsWith && endsWith) {\n// exact match\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n}\n};\n} else if (startsWith) {\n// first char\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n}\n};\n} else if (endsWith) {\n// last char\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() > 0 &&\ncontains(bContent, input.charAt(input.length() - 1)) == shouldMatch;\n}\n};\n}\n}\n}\n}\n\nreturn new RPattern() {\nPattern pattern = Pattern.compile(regex);\n\n@Override\npublic boolean isMatch(final CharSequence input) {\nfinal Matcher matcher = pattern.matcher(input);\nreturn matcher.find();\n}\n};\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$8:isMatch(Ljava/lang/CharSequence;)Z",
                                    "method_body": "private static RPattern pattern(final String regex) {\nfinal boolean startsWith = regex.startsWith(\"^\");\nfinal boolean endsWith = regex.endsWith(\"$\");\nfinal String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\nfinal boolean boxes = content.contains(\"[\");\n\nif (!boxes) {\nif (startsWith && endsWith) {\n// exact match\nif (content.length() == 0) {\n// empty\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() == 0;\n}\n};\n} else {\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.equals(content);\n}\n};\n}\n} else if ((startsWith || endsWith) && content.length() == 0) {\n// matches every string\nreturn ALL_STRINGS_RMATCHER;\n} else if (startsWith) {\n// matches from start\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn startsWith(input, content);\n}\n};\n} else if (endsWith) {\n// matches from start\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn endsWith(input, content);\n}\n};\n}\n} else {\nfinal boolean startsWithBox = content.startsWith(\"[\");\nfinal boolean endsWithBox = content.endsWith(\"]\");\n\nif (startsWithBox && endsWithBox) {\nString boxContent = content.substring(1, content.length() - 1);\nif (!boxContent.contains(\"[\")) {\n// box containing alternatives\nfinal boolean negate = boxContent.startsWith(\"^\");\nif (negate) {\nboxContent = boxContent.substring(1);\n}\nfinal String bContent = boxContent;\nfinal boolean shouldMatch = !negate;\n\nif (startsWith && endsWith) {\n// exact match\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n}\n};\n} else if (startsWith) {\n// first char\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n}\n};\n} else if (endsWith) {\n// last char\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() > 0 &&\ncontains(bContent, input.charAt(input.length() - 1)) == shouldMatch;\n}\n};\n}\n}\n}\n}\n\nreturn new RPattern() {\nPattern pattern = Pattern.compile(regex);\n\n@Override\npublic boolean isMatch(final CharSequence input) {\nfinal Matcher matcher = pattern.matcher(input);\nreturn matcher.find();\n}\n};\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$10:isMatch(Ljava/lang/CharSequence;)Z",
                                    "method_body": "private static RPattern pattern(final String regex) {\nfinal boolean startsWith = regex.startsWith(\"^\");\nfinal boolean endsWith = regex.endsWith(\"$\");\nfinal String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\nfinal boolean boxes = content.contains(\"[\");\n\nif (!boxes) {\nif (startsWith && endsWith) {\n// exact match\nif (content.length() == 0) {\n// empty\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() == 0;\n}\n};\n} else {\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.equals(content);\n}\n};\n}\n} else if ((startsWith || endsWith) && content.length() == 0) {\n// matches every string\nreturn ALL_STRINGS_RMATCHER;\n} else if (startsWith) {\n// matches from start\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn startsWith(input, content);\n}\n};\n} else if (endsWith) {\n// matches from start\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn endsWith(input, content);\n}\n};\n}\n} else {\nfinal boolean startsWithBox = content.startsWith(\"[\");\nfinal boolean endsWithBox = content.endsWith(\"]\");\n\nif (startsWithBox && endsWithBox) {\nString boxContent = content.substring(1, content.length() - 1);\nif (!boxContent.contains(\"[\")) {\n// box containing alternatives\nfinal boolean negate = boxContent.startsWith(\"^\");\nif (negate) {\nboxContent = boxContent.substring(1);\n}\nfinal String bContent = boxContent;\nfinal boolean shouldMatch = !negate;\n\nif (startsWith && endsWith) {\n// exact match\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n}\n};\n} else if (startsWith) {\n// first char\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n}\n};\n} else if (endsWith) {\n// last char\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() > 0 &&\ncontains(bContent, input.charAt(input.length() - 1)) == shouldMatch;\n}\n};\n}\n}\n}\n}\n\nreturn new RPattern() {\nPattern pattern = Pattern.compile(regex);\n\n@Override\npublic boolean isMatch(final CharSequence input) {\nfinal Matcher matcher = pattern.matcher(input);\nreturn matcher.find();\n}\n};\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.Rule$5:isMatch(Ljava/lang/CharSequence;)Z",
                                    "method_body": "private static RPattern pattern(final String regex) {\nfinal boolean startsWith = regex.startsWith(\"^\");\nfinal boolean endsWith = regex.endsWith(\"$\");\nfinal String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\nfinal boolean boxes = content.contains(\"[\");\n\nif (!boxes) {\nif (startsWith && endsWith) {\n// exact match\nif (content.length() == 0) {\n// empty\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() == 0;\n}\n};\n} else {\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.equals(content);\n}\n};\n}\n} else if ((startsWith || endsWith) && content.length() == 0) {\n// matches every string\nreturn ALL_STRINGS_RMATCHER;\n} else if (startsWith) {\n// matches from start\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn startsWith(input, content);\n}\n};\n} else if (endsWith) {\n// matches from start\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn endsWith(input, content);\n}\n};\n}\n} else {\nfinal boolean startsWithBox = content.startsWith(\"[\");\nfinal boolean endsWithBox = content.endsWith(\"]\");\n\nif (startsWithBox && endsWithBox) {\nString boxContent = content.substring(1, content.length() - 1);\nif (!boxContent.contains(\"[\")) {\n// box containing alternatives\nfinal boolean negate = boxContent.startsWith(\"^\");\nif (negate) {\nboxContent = boxContent.substring(1);\n}\nfinal String bContent = boxContent;\nfinal boolean shouldMatch = !negate;\n\nif (startsWith && endsWith) {\n// exact match\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n}\n};\n} else if (startsWith) {\n// first char\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n}\n};\n} else if (endsWith) {\n// last char\nreturn new RPattern() {\n@Override\npublic boolean isMatch(final CharSequence input) {\nreturn input.length() > 0 &&\ncontains(bContent, input.charAt(input.length() - 1)) == shouldMatch;\n}\n};\n}\n}\n}\n}\n\nreturn new RPattern() {\nPattern pattern = Pattern.compile(regex);\n\n@Override\npublic boolean isMatch(final CharSequence input) {\nfinal Matcher matcher = pattern.matcher(input);\nreturn matcher.find();\n}\n};\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$1:<clinit>()V",
                                    "method_body": "public String encode(String input, final Languages.LanguageSet languageSet) {\nfinal Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);\n// rules common across many (all) languages\nfinal Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, \"common\");\n// rules that apply to a specific language that may be ambiguous or wrong if applied to other languages\nfinal Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);\n\n// tidy the input\n// lower case is a locale-dependent operation\ninput = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();\n\nif (this.nameType == NameType.GENERIC) {\nif (input.length() >= 2 && input.substring(0, 2).equals(\"d'\")) { // check for d'\nfinal String remainder = input.substring(2);\nfinal String combined = \"d\" + remainder;\nreturn \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\";\n}\nfor (final String l : NAME_PREFIXES.get(this.nameType)) {\n// handle generic prefixes\nif (input.startsWith(l + \" \")) {\n// check for any prefix in the words list\nfinal String remainder = input.substring(l.length() + 1); // input without the prefix\nfinal String combined = l + remainder; // input with prefix without space\nreturn \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\";\n}\n}\n}\n\nfinal List<String> words = Arrays.asList(input.split(\"\\\\s+\"));\nfinal List<String> words2 = new ArrayList<String>();\n\n// special-case handling of word prefixes based upon the name type\nswitch (this.nameType) {\ncase SEPHARDIC:\nfor (final String aWord : words) {\nfinal String[] parts = aWord.split(\"'\");\nfinal String lastPart = parts[parts.length - 1];\nwords2.add(lastPart);\n}\nwords2.removeAll(NAME_PREFIXES.get(this.nameType));\nbreak;\ncase ASHKENAZI:\nwords2.addAll(words);\nwords2.removeAll(NAME_PREFIXES.get(this.nameType));\nbreak;\ncase GENERIC:\nwords2.addAll(words);\nbreak;\ndefault:\nthrow new IllegalStateException(\"Unreachable case: \" + this.nameType);\n}\n\nif (this.concat) {\n// concat mode enabled\ninput = join(words2, \" \");\n} else if (words2.size() == 1) {\n// not a multi-word name\ninput = words.iterator().next();\n} else {\n// encode each word in a multi-word name separately (normally used for approx matches)\nfinal StringBuilder result = new StringBuilder();\nfor (final String word : words2) {\nresult.append(\"-\").append(encode(word));\n}\n// return the result without the leading \"-\"\nreturn result.substring(1);\n}\n\nPhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);\n\n// loop over each char in the input - we will handle the increment manually\nfor (int i = 0; i < input.length();) {\nfinal RulesApplication rulesApplication =\nnew RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();\ni = rulesApplication.getI();\nphonemeBuilder = rulesApplication.getPhonemeBuilder();\n}\n\n// Apply the general rules\nphonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);\n// Apply the language-specific rules\nphonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);\n\nreturn phonemeBuilder.makeString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder:<init>(Lorg/apache/commons/codec/language/bm/Rule$Phoneme;)V",
                                    "method_body": "private PhonemeBuilder(final Rule.Phoneme phoneme) {\nthis.phonemes = new LinkedHashSet<Rule.Phoneme>();\nthis.phonemes.add(phoneme);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder:<init>(Ljava/util/Set;)V",
                                    "method_body": "private PhonemeBuilder(final Set<Rule.Phoneme> phonemes) {\nthis.phonemes = phonemes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder:empty(Lorg/apache/commons/codec/language/bm/Languages$LanguageSet;)Lorg/apache/commons/codec/language/bm/PhoneticEngine$PhonemeBuilder;",
                                    "method_body": "public static PhonemeBuilder empty(final Languages.LanguageSet languages) {\nreturn new PhonemeBuilder(new Rule.Phoneme(\"\", languages));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder:append(Ljava/lang/CharSequence;)V",
                                    "method_body": "public void append(final CharSequence str) {\nfor (final Rule.Phoneme ph : this.phonemes) {\nph.append(str);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder:apply(Lorg/apache/commons/codec/language/bm/Rule$PhonemeExpr;I)V",
                                    "method_body": "public void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {\nfinal Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);\n\nEXPR: for (final Rule.Phoneme left : this.phonemes) {\nfor (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {\nfinal LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());\nif (!languages.isEmpty()) {\nfinal Rule.Phoneme join = new Phoneme(left, right, languages);\nif (newPhonemes.size() < maxPhonemes) {\nnewPhonemes.add(join);\nif (newPhonemes.size() >= maxPhonemes) {\nbreak EXPR;\n}\n}\n}\n}\n}\n\nthis.phonemes.clear();\nthis.phonemes.addAll(newPhonemes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder:getPhonemes()Ljava/util/Set;",
                                    "method_body": "public Set<Rule.Phoneme> getPhonemes() {\nreturn this.phonemes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder:makeString()Ljava/lang/String;",
                                    "method_body": "public String makeString() {\nfinal StringBuilder sb = new StringBuilder();\n\nfor (final Rule.Phoneme ph : this.phonemes) {\nif (sb.length() > 0) {\nsb.append(\"|\");\n}\nsb.append(ph.getPhonemeText());\n}\n\nreturn sb.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication:<init>(Ljava/util/Map;Ljava/lang/CharSequence;Lorg/apache/commons/codec/language/bm/PhoneticEngine$PhonemeBuilder;II)V",
                                    "method_body": "public RulesApplication(final Map<String, List<Rule>> finalRules, final CharSequence input,\nfinal PhonemeBuilder phonemeBuilder, final int i, final int maxPhonemes) {\nif (finalRules == null) {\nthrow new NullPointerException(\"The finalRules argument must not be null\");\n}\nthis.finalRules = finalRules;\nthis.phonemeBuilder = phonemeBuilder;\nthis.input = input;\nthis.i = i;\nthis.maxPhonemes = maxPhonemes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication:getI()I",
                                    "method_body": "public int getI() {\nreturn this.i;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication:getPhonemeBuilder()Lorg/apache/commons/codec/language/bm/PhoneticEngine$PhonemeBuilder;",
                                    "method_body": "public PhonemeBuilder getPhonemeBuilder() {\nreturn this.phonemeBuilder;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication:invoke()Lorg/apache/commons/codec/language/bm/PhoneticEngine$RulesApplication;",
                                    "method_body": "public RulesApplication invoke() {\nthis.found = false;\nint patternLength = 1;\nfinal List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));\nif (rules != null) {\nfor (final Rule rule : rules) {\nfinal String pattern = rule.getPattern();\npatternLength = pattern.length();\nif (rule.patternAndContextMatches(this.input, this.i)) {\nthis.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);\nthis.found = true;\nbreak;\n}\n}\n}\n\nif (!this.found) {\npatternLength = 1;\n}\n\nthis.i += patternLength;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication:isFound()Z",
                                    "method_body": "public boolean isFound() {\nreturn this.found;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 15,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.language.SoundexTest.testHWRuleEx1",
                            "test_body": "224: public void testHWRuleEx1() {\n225: // From\n226: // http://www.archives.gov/research_room/genealogy/census/soundex.html:\n227: // Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1\n228: // for the F). It is not coded A-226.\n229: Assert.assertEquals(\"A261\", this.getStringEncoder().encode(\"Ashcraft\"));\n230: Assert.assertEquals(\"A261\", this.getStringEncoder().encode(\"Ashcroft\"));\n231: Assert.assertEquals(\"Y330\", this.getStringEncoder().encode(\"yehudit\"));\n232: Assert.assertEquals(\"Y330\", this.getStringEncoder().encode(\"yhwdyt\"));\n233: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:<init>()V",
                                    "method_body": "public Soundex() {\nthis.soundexMapping = US_ENGLISH_MAPPING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:<clinit>()V",
                                    "method_body": "public static final String US_ENGLISH_MAPPING_STRING = \"01230120022455012623010202\";\n\n/**\n* This is a default mapping of the 26 letters used in US English. A value of <code>0</code> for a letter position\n* means do not encode.\n*\n* @see Soundex#Soundex(char[])\n*/\nprivate static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();\n\n/**\n* An instance of Soundex using the US_ENGLISH_MAPPING mapping.\n*\n* @see #US_ENGLISH_MAPPING\n*/\npublic static final Soundex US_ENGLISH = new Soundex();\n\n/**\n* The maximum length of a Soundex code - Soundex codes are only four characters by definition.\n*\n* @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\n*/\n@Deprecated\nprivate int maxLength = 4;\n\n/**\n* Every letter of the alphabet is \"mapped\" to a numerical value. This char array holds the values to which each\n* letter is mapped. This implementation contains a default map for US_ENGLISH\n*/\nprivate final char[] soundexMapping;\n\n/**\n* Creates an instance using US_ENGLISH_MAPPING\n*\n* @see Soundex#Soundex(char[])\n* @see Soundex#US_ENGLISH_MAPPING\n*/\npublic Soundex() {\nthis.soundexMapping = US_ENGLISH_MAPPING;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:encode(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String encode(final String str) {\nreturn soundex(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:getMappingCode(Ljava/lang/String;I)C",
                                    "method_body": "private char getMappingCode(final String str, final int index) {\n// map() throws IllegalArgumentException\nfinal char mappedChar = this.map(str.charAt(index));\n// HW rule check\nif (index > 1 && mappedChar != '0') {\nfinal char hwChar = str.charAt(index - 1);\nif ('H' == hwChar || 'W' == hwChar) {\nfinal char preHWChar = str.charAt(index - 2);\nfinal char firstCode = this.map(preHWChar);\nif (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\nreturn 0;\n}\n}\n}\nreturn mappedChar;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:getSoundexMapping()[C",
                                    "method_body": "private char[] getSoundexMapping() {\nreturn this.soundexMapping;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:map(C)C",
                                    "method_body": "private char map(final char ch) {\nfinal int index = ch - 'A';\nif (index < 0 || index >= this.getSoundexMapping().length) {\nthrow new IllegalArgumentException(\"The character is not mapped: \" + ch);\n}\nreturn this.getSoundexMapping()[index];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.Soundex:soundex(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String soundex(String str) {\nif (str == null) {\nreturn null;\n}\nstr = SoundexUtils.clean(str);\nif (str.length() == 0) {\nreturn str;\n}\nfinal char out[] = {'0', '0', '0', '0'};\nchar last, mapped;\nint incount = 1, count = 1;\nout[0] = str.charAt(0);\n// getMappingCode() throws IllegalArgumentException\nlast = getMappingCode(str, 0);\nwhile (incount < str.length() && count < out.length) {\nmapped = getMappingCode(str, incount++);\nif (mapped != 0) {\nif (mapped != '0' && mapped != last) {\nout[count++] = mapped;\n}\nlast = mapped;\n}\n}\nreturn new String(out);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.language.SoundexUtils:clean(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String clean(final String str) {\nif (str == null || str.length() == 0) {\nreturn str;\n}\nfinal int len = str.length();\nfinal char[] chars = new char[len];\nint count = 0;\nfor (int i = 0; i < len; i++) {\nif (Character.isLetter(str.charAt(i))) {\nchars[count++] = str.charAt(i);\n}\n}\nif (count == len) {\nreturn str.toUpperCase(java.util.Locale.ENGLISH);\n}\nreturn new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 16,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.binary.Base32Test.testCodec200",
                            "test_body": "157: public void testCodec200() {\n158: final Base32 codec = new Base32(true, (byte)'W'); // should be allowed\n159: assertNotNull(codec);\n160: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.BaseNCodec:<init>(IIIIB)V",
                                    "method_body": "protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize,\nfinal int lineLength, final int chunkSeparatorLength, final byte pad) {\nthis.unencodedBlockSize = unencodedBlockSize;\nthis.encodedBlockSize = encodedBlockSize;\nfinal boolean useChunking = lineLength > 0 && chunkSeparatorLength > 0;\nthis.lineLength = useChunking ? (lineLength / encodedBlockSize) * encodedBlockSize : 0;\nthis.chunkSeparatorLength = chunkSeparatorLength;\n\nthis.pad = pad;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base32:<init>(ZB)V",
                                    "method_body": "public Base32(final boolean useHex, final byte pad) {\nthis(0, null, useHex, pad);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base32:<init>(I[BZB)V",
                                    "method_body": "public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte pad) {\nsuper(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, lineLength,\nlineSeparator == null ? 0 : lineSeparator.length, pad);\nif (useHex) {\nthis.encodeTable = HEX_ENCODE_TABLE;\nthis.decodeTable = HEX_DECODE_TABLE;\n} else {\nthis.encodeTable = ENCODE_TABLE;\nthis.decodeTable = DECODE_TABLE;\n}\nif (lineLength > 0) {\nif (lineSeparator == null) {\nthrow new IllegalArgumentException(\"lineLength \" + lineLength + \" > 0, but lineSeparator is null\");\n}\n// Must be done after initializing the tables\nif (containsAlphabetOrPad(lineSeparator)) {\nfinal String sep = StringUtils.newStringUtf8(lineSeparator);\nthrow new IllegalArgumentException(\"lineSeparator must not contain Base32 characters: [\" + sep + \"]\");\n}\nthis.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;\nthis.lineSeparator = new byte[lineSeparator.length];\nSystem.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n} else {\nthis.encodeSize = BYTES_PER_ENCODED_BLOCK;\nthis.lineSeparator = null;\n}\nthis.decodeSize = this.encodeSize - 1;\n\nif (isInAlphabet(pad) || isWhiteSpace(pad)) {\nthrow new IllegalArgumentException(\"pad must not be in alphabet or whitespace\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base32:<clinit>()V",
                                    "method_body": "private static final int BITS_PER_ENCODED_BYTE = 5;\nprivate static final int BYTES_PER_ENCODED_BLOCK = 8;\nprivate static final int BYTES_PER_UNENCODED_BLOCK = 5;\n\n/**\n* Chunk separator per RFC 2045 section 2.1.\n*\n* @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n*/\nprivate static final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.Base32:isInAlphabet(B)Z",
                                    "method_body": "public boolean isInAlphabet(final byte octet) {\nreturn octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 17,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.binary.StringUtilsTest.testNewStringNullInput_CODEC229",
                            "test_body": "149: public void testNewStringNullInput_CODEC229() {\n150: Assert.assertNull(StringUtils.newStringUtf8(null));\n151: Assert.assertNull(StringUtils.newStringIso8859_1(null));\n152: Assert.assertNull(StringUtils.newStringUsAscii(null));\n153: Assert.assertNull(StringUtils.newStringUtf16(null));\n154: Assert.assertNull(StringUtils.newStringUtf16Be(null));\n155: Assert.assertNull(StringUtils.newStringUtf16Le(null));\n156: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:newString([BLjava/nio/charset/Charset;)Ljava/lang/String;",
                                    "method_body": "private static String newString(final byte[] bytes, final Charset charset) {\nreturn bytes == null ? null : new String(bytes, charset);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:newStringIso8859_1([B)Ljava/lang/String;",
                                    "method_body": "public static String newStringIso8859_1(final byte[] bytes) {\nreturn new String(bytes, Charsets.ISO_8859_1);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:newStringUtf8([B)Ljava/lang/String;",
                                    "method_body": "public static String newStringUtf8(final byte[] bytes) {\nreturn newString(bytes, Charsets.UTF_8);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.Charsets:<clinit>()V",
                                    "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharEncoding.ISO_8859_1);\n\n/**\n* Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n* <p>\n* On Java 7 or later, use {@link java.nio.charset.StandardCharsets#ISO_8859_1} instead."
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 18,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.codec.binary.StringUtilsTest.testEqualsCS1",
                            "test_body": "224: public void testEqualsCS1() {\n225: Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abc\"), null));\n226: Assert.assertFalse(StringUtils.equals(null, new StringBuilder(\"abc\")));\n227: Assert.assertTrue(StringUtils.equals(new StringBuilder(\"abc\"), new StringBuilder(\"abc\")));\n228: Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abc\"), new StringBuilder(\"abcd\")));\n229: Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abcd\"), new StringBuilder(\"abc\")));\n230: Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abc\"), new StringBuilder(\"ABC\")));\n231: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:equals(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\nif (cs1 == cs2) {\nreturn true;\n}\nif (cs1 == null || cs2 == null) {\nreturn false;\n}\nif (cs1 instanceof String && cs2 instanceof String) {\nreturn cs1.equals(cs2);\n}\nreturn CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.CharSequenceUtils:regionMatches(Ljava/lang/CharSequence;ZILjava/lang/CharSequence;II)Z",
                                    "method_body": "static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart,\nfinal CharSequence substring, final int start, final int length) {\nif (cs instanceof String && substring instanceof String) {\nreturn ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length);\n}\nint index1 = thisStart;\nint index2 = start;\nint tmpLen = length;\n\nwhile (tmpLen-- > 0) {\nfinal char c1 = cs.charAt(index1++);\nfinal char c2 = substring.charAt(index2++);\n\nif (c1 == c2) {\ncontinue;\n}\n\nif (!ignoreCase) {\nreturn false;\n}\n\n// The same check as in String.regionMatches():\nif (Character.toUpperCase(c1) != Character.toUpperCase(c2) &&\nCharacter.toLowerCase(c1) != Character.toLowerCase(c2)) {\nreturn false;\n}\n}\n\nreturn true;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.codec.binary.StringUtilsTest.testEqualsCS2",
                            "test_body": "234: public void testEqualsCS2() {\n235: Assert.assertTrue(StringUtils.equals(\"abc\", new StringBuilder(\"abc\")));\n236: Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abc\"), \"abcd\"));\n237: Assert.assertFalse(StringUtils.equals(\"abcd\", new StringBuilder(\"abc\")));\n238: Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abc\"), \"ABC\"));\n239: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.codec.binary.StringUtils:equals(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Z",
                                    "method_body": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\nif (cs1 == cs2) {\nreturn true;\n}\nif (cs1 == null || cs2 == null) {\nreturn false;\n}\nif (cs1 instanceof String && cs2 instanceof String) {\nreturn cs1.equals(cs2);\n}\nreturn CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.codec.binary.CharSequenceUtils:regionMatches(Ljava/lang/CharSequence;ZILjava/lang/CharSequence;II)Z",
                                    "method_body": "static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart,\nfinal CharSequence substring, final int start, final int length) {\nif (cs instanceof String && substring instanceof String) {\nreturn ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length);\n}\nint index1 = thisStart;\nint index2 = start;\nint tmpLen = length;\n\nwhile (tmpLen-- > 0) {\nfinal char c1 = cs.charAt(index1++);\nfinal char c2 = substring.charAt(index2++);\n\nif (c1 == c2) {\ncontinue;\n}\n\nif (!ignoreCase) {\nreturn false;\n}\n\n// The same check as in String.regionMatches():\nif (Character.toUpperCase(c1) != Character.toUpperCase(c2) &&\nCharacter.toLowerCase(c1) != Character.toLowerCase(c2)) {\nreturn false;\n}\n}\n\nreturn true;\n}"
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}