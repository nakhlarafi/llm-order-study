{
    "projects": [
        {
            "name": "JacksonXml",
            "bugs": [
                {
                    "bug_id": 1,
                    "tests": [
                        {
                            "test_name": "com.fasterxml.jackson.dataformat.xml.lists.NestedUnwrappedLists180Test.testNestedUnwrappedLists180",
                            "test_body": "public void testNestedUnwrappedLists180() throws Exception\n{\n/*\nRecords recs = new Records();\nrecs.records.add(new Record());\nrecs.records.add(new Record());\nrecs.records.add(new Record());\nrecs.records.get(0).fields.add(new Field(\"a\"));\nrecs.records.get(2).fields.add(new Field(\"b\"));\nString xml = MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(recs);\n*/\nString xml =\n\"<Records>\\n\"\n// Important: it's the empty CDATA here that causes breakage -- empty element alone would be fine\n//+\"<records>\\n</records>\\n\"\n+\"<records></records>\\n\"\n+\"  <records>\\n\"\n+\"   <fields name='b'/>\\n\"\n+\"  </records>\\n\"\n+\"</Records>\\n\"\n;\n//System.out.println(\"XML: \"+xml);\nRecords result = MAPPER.readValue(xml, Records.class);\nassertNotNull(result.records);\nassertEquals(2, result.records.size());\nassertNotNull(result.records.get(1));\nassertEquals(1, result.records.get(1).fields.size());\nassertEquals(\"b\", result.records.get(1).fields.get(0).name);\n// also, first one ought not be null should it? Ideally not...\nassertNotNull(result.records.get(0));\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<init>()V",
                                    "method_body": "public XmlMapper() {\nthis(new XmlFactory());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<init>(Lcom/fasterxml/jackson/dataformat/xml/XmlFactory;)V",
                                    "method_body": "public XmlMapper(XmlFactory xmlFactory) {\nthis(xmlFactory, DEFAULT_XML_MODULE);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<init>(Lcom/fasterxml/jackson/dataformat/xml/XmlFactory;Lcom/fasterxml/jackson/dataformat/xml/JacksonXmlModule;)V",
                                    "method_body": "public XmlMapper(XmlFactory xmlFactory, JacksonXmlModule module)\n{\n/* Need to override serializer provider (due to root name handling);\n* deserializer provider fine as is\n*/\nsuper(xmlFactory, new XmlSerializerProvider(new XmlRootNameLookup()), null);\n_xmlModule = module;\n// but all the rest is done via Module interface!\nif (module != null) {\nregisterModule(module);\n}\n// 19-May-2015, tatu: Must ensure we use XML-specific indenter\n_serializationConfig = _serializationConfig.withDefaultPrettyPrinter(DEFAULT_XML_PRETTY_PRINTER);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\nprotected final static JacksonXmlModule DEFAULT_XML_MODULE = new JacksonXmlModule();\n\nprotected final static DefaultXmlPrettyPrinter DEFAULT_XML_PRETTY_PRINTER = new DefaultXmlPrettyPrinter();\n\n// need to hold on to module instance just in case copy() is used\nprotected final JacksonXmlModule _xmlModule;\n\n/*\n/**********************************************************\n/* Life-cycle: construction, configuration\n/**********************************************************\n*/\n\npublic XmlMapper() {\nthis(new XmlFactory());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlModule:<init>()V",
                                    "method_body": "public JacksonXmlModule()\n{\nsuper(\"JackxonXmlModule\", PackageVersion.VERSION);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlModule:setupModule(Lcom/fasterxml/jackson/databind/Module$SetupContext;)V",
                                    "method_body": "public void setupModule(SetupContext context)\n{\n// Need to modify BeanDeserializer, BeanSerializer that are used\ncontext.addBeanSerializerModifier(new XmlBeanSerializerModifier());\ncontext.addBeanDeserializerModifier(new XmlBeanDeserializerModifier(_cfgNameForTextElement));\n\n// as well as AnnotationIntrospector\ncontext.insertAnnotationIntrospector(_constructIntrospector());\n\n// and finally inform XmlFactory about overrides, if need be:\nif (_cfgNameForTextElement != FromXmlParser.DEFAULT_UNNAMED_TEXT_PROPERTY) {\nXmlMapper m = (XmlMapper) context.getOwner();\nm.setXMLTextElementName(_cfgNameForTextElement);\n}\n\n/* Usually this would be the first call; but here anything added will\n* be stuff user may has added, so do it afterwards instead.\n*/\nsuper.setupModule(context);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlModule:_constructIntrospector()Lcom/fasterxml/jackson/databind/AnnotationIntrospector;",
                                    "method_body": "protected AnnotationIntrospector _constructIntrospector() {\nreturn new JacksonXmlAnnotationIntrospector(_cfgDefaultUseWrapper);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.PackageVersion:<clinit>()V",
                                    "method_body": "public final static Version VERSION = VersionUtil.parseVersion(\n\"2.7.0-rc4-SNAPSHOT\", \"com.fasterxml.jackson.dataformat\", \"jackson-dataformat-xml\");\n\n@Override\npublic Version version() {\nreturn VERSION;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter:<init>()V",
                                    "method_body": "public void writeIndentation(JsonGenerator g, int level) throws IOException;\n\npublic void writeIndentation(XMLStreamWriter2 sw, int level) throws XMLStreamException;\n\n/**\n* @return True if indenter is considered inline (does not add linefeeds),\n*   false otherwise\n*/\npublic boolean isInline();\n}\n\n/*\n/**********************************************************\n/* Configuration\n/**********************************************************\n*/\n\n/**\n* By default, let's use only spaces to separate array values.\n*/\nprotected Indenter _arrayIndenter = new FixedSpaceIndenter();\n\n/**\n* By default, let's use linefeed-adding indenter for separate\n* object entries. We'll further configure indenter to use\n* system-specific linefeeds, and 2 spaces per level (as opposed to,\n* say, single tabs)\n*/\nprotected Indenter _objectIndenter = new Lf2SpacesIndenter();\n\n// // // Config, other white space configuration\n\n/**\n* By default we will add spaces around colons used to\n* separate object fields and values.\n* If disabled, will not use spaces around colon.\n*/\nprotected boolean _spacesInObjectEntries = true;\n\n/*\n/**********************************************************\n/* State\n/**********************************************************\n*/\n\n/**\n* Number of open levels of nesting. Used to determine amount of\n* indentation to use.\n*/\nprotected transient int _nesting = 0;\n\n/**\n* Marker flag set on start element, and cleared if an end element\n* is encountered. Used for suppressing indentation to allow empty\n* elements.\n*\n* @since 2.3.0\n*/\nprotected transient boolean _justHadStartElement;\n\n/*\n/**********************************************************\n/* Life-cycle (construct, configure)\n/**********************************************************\n*/\n\npublic DefaultXmlPrettyPrinter() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter$FixedSpaceIndenter:<init>()V",
                                    "method_body": "public FixedSpaceIndenter() { }\npublic FixedSpaceIndenter() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter$Lf2SpacesIndenter:<init>()V",
                                    "method_body": "public Lf2SpacesIndenter() { }\npublic Lf2SpacesIndenter() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter$Lf2SpacesIndenter:<clinit>()V",
                                    "method_body": "final static int SPACE_COUNT = 64;\nfinal static char[] SPACES = new char[SPACE_COUNT];\nstatic {\nArrays.fill(SPACES, ' ');\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>()V",
                                    "method_body": "public XmlFactory() { this(null, null, null); }\npublic XmlFactory() { this(null, null, null); }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>(Lcom/fasterxml/jackson/core/ObjectCodec;Ljavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;)V",
                                    "method_body": "public XmlFactory(ObjectCodec oc, XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n{\nthis(oc, DEFAULT_XML_PARSER_FEATURE_FLAGS, DEFAULT_XML_GENERATOR_FEATURE_FLAGS,\nxmlIn, xmlOut, null);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>(Lcom/fasterxml/jackson/core/ObjectCodec;IILjavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;Ljava/lang/String;)V",
                                    "method_body": "protected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\nXMLInputFactory xmlIn, XMLOutputFactory xmlOut,\nString nameForTextElem)\n{\nsuper(oc);\n_xmlParserFeatures = xpFeatures;\n_xmlGeneratorFeatures = xgFeatures;\n_cfgNameForTextElement = nameForTextElem;\nif (xmlIn == null) {\nxmlIn = XMLInputFactory.newInstance();\n}\nif (xmlOut == null) {\nxmlOut = XMLOutputFactory.newInstance();\n}\n_initFactories(xmlIn, xmlOut);\n_xmlInputFactory = xmlIn;\n_xmlOutputFactory = xmlOut;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<clinit>()V",
                                    "method_body": "public final static String FORMAT_NAME_XML = \"XML\";\n\n/**\n* Bitfield (set of flags) of all parser features that are enabled\n* by default.\n*/\nfinal static int DEFAULT_XML_PARSER_FEATURE_FLAGS = FromXmlParser.Feature.collectDefaults();\n\n/**\n* Bitfield (set of flags) of all generator features that are enabled\n* by default.\n*/\nfinal static int DEFAULT_XML_GENERATOR_FEATURE_FLAGS = ToXmlGenerator.Feature.collectDefaults();\n\n/*\n/**********************************************************\n/* Configuration\n/**********************************************************\n*/\n\nprotected int _xmlParserFeatures;\n\nprotected int _xmlGeneratorFeatures;\n\n// non-final for setters (why are they needed again?)\nprotected transient XMLInputFactory _xmlInputFactory;\n\nprotected transient XMLOutputFactory _xmlOutputFactory;\n\nprotected String _cfgNameForTextElement;\n\n/*\n/**********************************************************\n/* Factory construction, configuration\n/**********************************************************\n*/\n\n/**\n* Default constructor used to create factory instances.\n* Creation of a factory instance is a light-weight operation,\n* but it is still a good idea to reuse limited number of\n* factory instances (and quite often just a single instance):\n* factories are used as context for storing some reused\n* processing objects (such as symbol tables parsers use)\n* and this reuse only works within context of a single\n* factory instance.\n*/\npublic XmlFactory() { this(null, null, null); }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_initFactories(Ljavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;)V",
                                    "method_body": "protected void _initFactories(XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n{\n// Better ensure namespaces get built properly, so:\nxmlOut.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\n// and for parser, force coalescing as well (much simpler to use)\nxmlIn.setProperty(XMLInputFactory.IS_COALESCING, Boolean.TRUE);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:createParser(Ljava/lang/String;)Lcom/fasterxml/jackson/core/JsonParser;",
                                    "method_body": "public JsonParser createParser(String content) throws IOException {\nReader r = new StringReader(content);\nIOContext ctxt = _createContext(r, true);\nif (_inputDecorator != null) {\nr = _inputDecorator.decorate(ctxt, r);\n}\nreturn _createParser(r, ctxt);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_createParser(Ljava/io/Reader;Lcom/fasterxml/jackson/core/io/IOContext;)Lcom/fasterxml/jackson/dataformat/xml/deser/FromXmlParser;",
                                    "method_body": "protected FromXmlParser _createParser(Reader r, IOContext ctxt) throws IOException\n{\nXMLStreamReader sr;\ntry {\nsr = _xmlInputFactory.createXMLStreamReader(r);\nsr = _initializeXmlReader(sr);\n} catch (XMLStreamException e) {\nreturn StaxUtil.throwXmlAsIOException(e);\n}\nFromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n_objectCodec, sr);\nif (_cfgNameForTextElement != null) {\nxp.setXMLTextElementName(_cfgNameForTextElement);\n}\nreturn xp;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_initializeXmlReader(Ljavax/xml/stream/XMLStreamReader;)Ljavax/xml/stream/XMLStreamReader;",
                                    "method_body": "protected final XMLStreamReader _initializeXmlReader(XMLStreamReader sr) throws IOException, XMLStreamException\n{\n// for now, nothing to do... except let's find the root element\nwhile (sr.next() != XMLStreamConstants.START_ELEMENT) {\n;\n}\nreturn sr;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature:<clinit>()V",
                                    "method_body": "public final static String DEFAULT_UNNAMED_TEXT_PROPERTY = \"\";\n\n/**\n* Enumeration that defines all togglable features for XML parsers.\n* None defined so far (2.6), so just a placeholder.\n*/\npublic enum Feature implements FormatFeature\n{\n;\n\nfinal boolean _defaultState;\nfinal int _mask;\n\n/**\n* Method that calculates bit set (flags) of all features that\n* are enabled by default.\n*/\npublic static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}\n\nprivate Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}\n\n@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public int getMask() { return _mask; }\n@Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature:collectDefaults()I",
                                    "method_body": "public static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:<init>(Ljava/lang/String;IZ)V",
                                    "method_body": "private Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:<clinit>()V",
                                    "method_body": "protected final static String DEFAULT_UNKNOWN_ELEMENT = \"unknown\";\n\n/**\n* Enumeration that defines all togglable extra XML-specific features\n*/\npublic enum Feature implements FormatFeature\n{\n/**\n* Feature that controls whether XML declaration should be written before\n* when generator is initialized (true) or not (false)\n*/\nWRITE_XML_DECLARATION(false),\n\n/**\n* Feature that controls whether output should be done as XML 1.1; if so,\n* certain aspects may differ from default (1.0) processing: for example,\n* XML declaration will be automatically added (regardless of setting\n* <code>WRITE_XML_DECLARATION</code>) as this is required for reader to\n* know to use 1.1 compliant handling. XML 1.1 can be used to allow quoted\n* control characters (Ascii codes 0 through 31) as well as additional linefeeds\n* and name characters.\n*/\nWRITE_XML_1_1(false)\n;\n\nfinal boolean _defaultState;\nfinal int _mask;\n\n/**\n* Method that calculates bit set (flags) of all features that\n* are enabled by default.\n*/\npublic static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}\n\nprivate Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}\n\n@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public int getMask() { return _mask; }\n@Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:collectDefaults()I",
                                    "method_body": "public static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:enabledByDefault()Z",
                                    "method_body": "@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public boolean enabledByDefault() { return _defaultState; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:<init>(Lcom/fasterxml/jackson/dataformat/xml/util/XmlRootNameLookup;)V",
                                    "method_body": "public XmlSerializerProvider(XmlRootNameLookup rootNames)\n{\nsuper();\n_rootNameLookup = rootNames;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\n/**\n* If all we get to serialize is a null, there's no way to figure out\n* expected root name; so let's just default to something like \"&lt;null>\"...\n*/\nprotected final static QName ROOT_NAME_FOR_NULL = new QName(\"null\");\n\nprotected final XmlRootNameLookup _rootNameLookup;\n\npublic XmlSerializerProvider(XmlRootNameLookup rootNames)\n{\nsuper();\n_rootNameLookup = rootNames;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.XmlRootNameLookup:<init>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\n/**\n* For efficient operation, let's try to minimize number of times we\n* need to introspect root element name to use.\n*<p>\n* Note: changed to <code>transient</code> for 2.3; no point in serializing such\n* state\n*/\nprotected final transient LRUMap<ClassKey,QName> _rootNames = new LRUMap<ClassKey,QName>(40, 200);\n\npublic XmlRootNameLookup() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerModifier:<init>()V",
                                    "method_body": "public XmlBeanSerializerModifier() { }\npublic XmlBeanSerializerModifier() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlBeanDeserializerModifier:<init>(Ljava/lang/String;)V",
                                    "method_body": "public XmlBeanDeserializerModifier(String nameForTextValue)\n{\n_cfgNameForTextValue = nameForTextValue;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlBeanDeserializerModifier:updateProperties(Lcom/fasterxml/jackson/databind/DeserializationConfig;Lcom/fasterxml/jackson/databind/BeanDescription;Ljava/util/List;)Ljava/util/List;",
                                    "method_body": "public List<BeanPropertyDefinition> updateProperties(DeserializationConfig config,\nBeanDescription beanDesc, List<BeanPropertyDefinition> propDefs)\n{\nfinal AnnotationIntrospector intr = config.getAnnotationIntrospector();\nint changed = 0;\n\nfor (int i = 0, propCount = propDefs.size(); i < propCount; ++i) {\nBeanPropertyDefinition prop = propDefs.get(i);\nAnnotatedMember acc = prop.getPrimaryMember();\n// should not be null, but just in case:\nif (acc == null) {\ncontinue;\n}\n/* First: handle \"as text\"? Such properties\n* are exposed as values of 'unnamed' fields; so one way to\n* map them is to rename property to have name \"\"... (and\n* hope this does not break other parts...)\n*/\nBoolean b = AnnotationUtil.findIsTextAnnotation(intr, acc);\nif (b != null && b.booleanValue()) {\n// unwrapped properties will appear as 'unnamed' (empty String)\nBeanPropertyDefinition newProp = prop.withSimpleName(_cfgNameForTextValue);\nif (newProp != prop) {\npropDefs.set(i, newProp);\n}\ncontinue;\n}\n// second: do we need to handle wrapping (for Lists)?\nPropertyName wrapperName = prop.getWrapperName();\n\nif (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\nString localName = wrapperName.getSimpleName();\nif ((localName != null && localName.length() > 0)\n&& !localName.equals(prop.getName())) {\n// make copy-on-write as necessary\nif (changed == 0) {\npropDefs = new ArrayList<BeanPropertyDefinition>(propDefs);\n}\n++changed;\npropDefs.set(i, prop.withSimpleName(localName));\ncontinue;\n}\n// otherwise unwrapped; needs handling but later on\n}\n}\nreturn propDefs;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlBeanDeserializerModifier:modifyDeserializer(Lcom/fasterxml/jackson/databind/DeserializationConfig;Lcom/fasterxml/jackson/databind/BeanDescription;Lcom/fasterxml/jackson/databind/JsonDeserializer;)Lcom/fasterxml/jackson/databind/JsonDeserializer;",
                                    "method_body": "public JsonDeserializer<?> modifyDeserializer(DeserializationConfig config,\nBeanDescription beanDesc, JsonDeserializer<?> deser0)\n{\nif (!(deser0 instanceof BeanDeserializerBase)) {\nreturn deser0;\n}\n/* 17-Aug-2013, tatu: One important special case first: if we have one \"XML Text\"\n* property, it may be exposed as VALUE_STRING token (depending on whether any attribute\n* values are exposed): and to deserialize from that, we need special handling unless POJO\n* has appropriate single-string creator method.\n*/\nBeanDeserializerBase deser = (BeanDeserializerBase) deser0;\n\n// Heuristics are bit tricky; but for now let's assume that if POJO\n// can already work with VALUE_STRING, it's ok and doesn't need extra support\nif (!deser.getValueInstantiator().canCreateFromString()) {\nSettableBeanProperty textProp = _findSoleTextProp(config, deser.properties());\nif (textProp != null) {\nreturn new XmlTextDeserializer(deser, textProp);\n}\n}\nreturn new WrapperHandlingDeserializer(deser);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlBeanDeserializerModifier:_findSoleTextProp(Lcom/fasterxml/jackson/databind/DeserializationConfig;Ljava/util/Iterator;)Lcom/fasterxml/jackson/databind/deser/SettableBeanProperty;",
                                    "method_body": "private SettableBeanProperty _findSoleTextProp(DeserializationConfig config,\nIterator<SettableBeanProperty> propIt)\n{\nfinal AnnotationIntrospector ai = config.getAnnotationIntrospector();\nSettableBeanProperty textProp = null;\nwhile (propIt.hasNext()) {\nSettableBeanProperty prop = propIt.next();\nAnnotatedMember m = prop.getMember();\nif (m != null) {\n// Ok, let's use a simple check: we should have renamed it earlier so:\nPropertyName n = prop.getFullName();\nif (_cfgNameForTextValue.equals(n.getSimpleName())) {\n// should we verify we only got one?\ntextProp = prop;\ncontinue;\n}\n// as-attribute are ok as well\nBoolean b = AnnotationUtil.findIsAttributeAnnotation(ai, m);\nif (b != null && b.booleanValue()) {\ncontinue;\n}\n}\n// Otherwise, it's something else; no go\nreturn null;\n}\nreturn textProp;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:<init>(Z)V",
                                    "method_body": "public JacksonXmlAnnotationIntrospector(boolean defaultUseWrapper) {\n_cfgDefaultUseWrapper = defaultUseWrapper;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:isOutputAsAttribute(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Ljava/lang/Boolean;",
                                    "method_body": "public Boolean isOutputAsAttribute(Annotated ann)\n{\nJacksonXmlProperty prop = ann.getAnnotation(JacksonXmlProperty.class);\nif (prop != null) {\nreturn prop.isAttribute() ? Boolean.TRUE : Boolean.FALSE;\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:isOutputAsText(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Ljava/lang/Boolean;",
                                    "method_body": "public Boolean isOutputAsText(Annotated ann)\n{\nJacksonXmlText prop = ann.getAnnotation(JacksonXmlText.class);\nif (prop != null) {\nreturn prop.value() ? Boolean.TRUE : Boolean.FALSE;\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:findNameForDeserialization(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Lcom/fasterxml/jackson/databind/PropertyName;",
                                    "method_body": "public PropertyName findNameForDeserialization(Annotated a)\n{\nPropertyName name = _findXmlName(a);\nif (name == null) {\nname = super.findNameForDeserialization(a);\nif (name == null) {\nif (a.hasAnnotation(JacksonXmlText.class)) {\nreturn PropertyName.USE_DEFAULT;\n}\n}\n}\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:_findXmlName(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Lcom/fasterxml/jackson/databind/PropertyName;",
                                    "method_body": "protected PropertyName _findXmlName(Annotated a)\n{\nJacksonXmlProperty pann = a.getAnnotation(JacksonXmlProperty.class);\nif (pann != null) {\nreturn PropertyName.construct(pann.localName(), pann.namespace());\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:<init>(Lcom/fasterxml/jackson/core/io/IOContext;IILcom/fasterxml/jackson/core/ObjectCodec;Ljavax/xml/stream/XMLStreamReader;)V",
                                    "method_body": "public FromXmlParser(IOContext ctxt, int genericParserFeatures, int xmlFeatures,\nObjectCodec codec, XMLStreamReader xmlReader)\n{\nsuper(genericParserFeatures);\n_formatFeatures = xmlFeatures;\n_ioContext = ctxt;\n_objectCodec = codec;\n_parsingContext = XmlReadContext.createRootContext(-1, -1);\n// and thereby start a scope\n_nextToken = JsonToken.START_OBJECT;\n_xmlTokens = new XmlTokenStream(xmlReader, ctxt.getSourceReference());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:addVirtualWrapping(Ljava/util/Set;)V",
                                    "method_body": "public void addVirtualWrapping(Set<String> namesToWrap)\n{\n/* 17-Sep-2012, tatu: Not 100% sure why, but this is necessary to avoid\n*   problems with Lists-in-Lists properties\n*/\nString name = _xmlTokens.getLocalName();\nif (name != null && namesToWrap.contains(name)) {\n_xmlTokens.repeatStartElement();\n}\n_namesToWrap = namesToWrap;\n_parsingContext.setNamesToWrap(namesToWrap);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:getCurrentName()Ljava/lang/String;",
                                    "method_body": "public String getCurrentName() throws IOException\n{\n// start markers require information from parent\nString name;\nif (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\nXmlReadContext parent = _parsingContext.getParent();\nname = parent.getCurrentName();\n} else {\nname = _parsingContext.getCurrentName();\n}\n// sanity check\nif (name == null) {\nthrow new IllegalStateException(\"Missing name, in state: \"+_currToken);\n}\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:close()V",
                                    "method_body": "public void close() throws IOException\n{\nif (!_closed) {\n_closed = true;\ntry {\nif (_ioContext.isResourceManaged() || isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)) {\n_xmlTokens.closeCompletely();\n} else {\n_xmlTokens.close();\n}\n} finally {\n// as per [JACKSON-324], do in finally block\n// Also, internal buffer(s) can now be released as well\n_releaseBuffers();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:getParsingContext()Lcom/fasterxml/jackson/dataformat/xml/deser/XmlReadContext;",
                                    "method_body": "public XmlReadContext getParsingContext() {\nreturn _parsingContext;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:isExpectedStartArrayToken()Z",
                                    "method_body": "public boolean isExpectedStartArrayToken()\n{\nJsonToken t = _currToken;\nif (t == JsonToken.START_OBJECT) {\n_currToken = JsonToken.START_ARRAY;\n// Ok: must replace current context with array as well\n_parsingContext.convertToArray();\n//System.out.println(\" isExpectedArrayStart: OBJ->Array, wraps now: \"+_parsingContext.getNamesToWrap());\n// And just in case a field name was to be returned, wipe it\n_nextToken = null;\n// and last thing, [dataformat-xml#33], better ignore attributes\n_xmlTokens.skipAttributes();\nreturn true;\n}\n//System.out.println(\" isExpectedArrayStart?: t=\"+t);\nreturn (t == JsonToken.START_ARRAY);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:nextToken()Lcom/fasterxml/jackson/core/JsonToken;",
                                    "method_body": "public JsonToken nextToken() throws IOException\n{\n_binaryValue = null;\nif (_nextToken != null) {\nJsonToken t = _nextToken;\n_currToken = t;\n_nextToken = null;\nswitch (t) {\ncase START_OBJECT:\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nbreak;\ncase START_ARRAY:\n_parsingContext = _parsingContext.createChildArrayContext(-1, -1);\nbreak;\ncase END_OBJECT:\ncase END_ARRAY:\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nbreak;\ncase FIELD_NAME:\n_parsingContext.setCurrentName(_xmlTokens.getLocalName());\nbreak;\ndefault: // VALUE_STRING, VALUE_NULL\n// should be fine as is?\n}\nreturn t;\n}\nint token = _xmlTokens.next();\n\n// Need to have a loop just because we may have to eat/convert\n// a start-element that indicates an array element.\nwhile (token == XmlTokenStream.XML_START_ELEMENT) {\n// If we thought we might get leaf, no such luck\nif (_mayBeLeaf) {\n// leave _mayBeLeaf set, as we start a new context\n_nextToken = JsonToken.FIELD_NAME;\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\nif (_parsingContext.inArray()) {\n// Yup: in array, so this element could be verified; but it won't be\n// reported anyway, and we need to process following event.\ntoken = _xmlTokens.next();\n_mayBeLeaf = true;\ncontinue;\n}\nString name = _xmlTokens.getLocalName();\n_parsingContext.setCurrentName(name);\n\n// Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n// Couple of ways to do it; but start by making _xmlTokens replay the thing...\nif (_namesToWrap != null && _namesToWrap.contains(name)) {\n_xmlTokens.repeatStartElement();\n}\n\n_mayBeLeaf = true;\n// Ok: in array context we need to skip reporting field names.\n// But what's the best way to find next token?\nreturn (_currToken = JsonToken.FIELD_NAME);\n}\n\n// Ok; beyond start element, what do we get?\nswitch (token) {\ncase XmlTokenStream.XML_END_ELEMENT:\n// Simple, except that if this is a leaf, need to suppress end:\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n//    expose as empty Object, not null\nreturn (_currToken = JsonToken.VALUE_NULL);\n}\n_currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nreturn _currToken;\n\ncase XmlTokenStream.XML_ATTRIBUTE_NAME:\n// If there was a chance of leaf node, no more...\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n_nextToken = JsonToken.FIELD_NAME;\n_currText = _xmlTokens.getText();\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\n_parsingContext.setCurrentName(_xmlTokens.getLocalName());\nreturn (_currToken = JsonToken.FIELD_NAME);\ncase XmlTokenStream.XML_ATTRIBUTE_VALUE:\n_currText = _xmlTokens.getText();\nreturn (_currToken = JsonToken.VALUE_STRING);\ncase XmlTokenStream.XML_TEXT:\n_currText = _xmlTokens.getText();\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n/* One more refinement (pronunced like \"hack\") is that if\n* we had an empty String (or all white space), and we are\n* deserializing an array, we better hide the empty text.\n*/\n// Also: must skip following END_ELEMENT\n_xmlTokens.skipEndElement();\nif (_parsingContext.inArray()) {\nif (_isEmpty(_currText)) {\n// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n//    expose as empty Object, not null (or, worse, as used to\n//    be done, by swallowing the token)\n_currToken = JsonToken.END_ARRAY;\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nreturn _currToken;\n}\n}\nreturn (_currToken = JsonToken.VALUE_STRING);\n} else {\n// [dataformat-xml#177]: empty text may also need to be skipped\nif (_parsingContext.inObject()\n&& (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n_currToken = JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nreturn _currToken;\n}\n}\n// If not a leaf (or otherwise ignorable), need to transform into property...\n_parsingContext.setCurrentName(_cfgNameForTextElement);\n_nextToken = JsonToken.VALUE_STRING;\nreturn (_currToken = JsonToken.FIELD_NAME);\ncase XmlTokenStream.XML_END:\nreturn (_currToken = null);\n}\n\n// should never get here\n_throwInternal();\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:getText()Ljava/lang/String;",
                                    "method_body": "public String getText() throws IOException\n{\nif (_currToken == null) {\nreturn null;\n}\nswitch (_currToken) {\ncase FIELD_NAME:\nreturn getCurrentName();\ncase VALUE_STRING:\nreturn _currText;\ndefault:\nreturn _currToken.asString();\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:_releaseBuffers()V",
                                    "method_body": "protected void _releaseBuffers() throws IOException {\n// anything we can/must release? Underlying parser should do all of it, for now?\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:<init>(Lcom/fasterxml/jackson/dataformat/xml/deser/XmlReadContext;III)V",
                                    "method_body": "public XmlReadContext(XmlReadContext parent, int type, int lineNr, int colNr)\n{\nsuper();\n_type = type;\n_parent = parent;\n_lineNr = lineNr;\n_columnNr = colNr;\n_index = -1;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:createRootContext(II)Lcom/fasterxml/jackson/dataformat/xml/deser/XmlReadContext;",
                                    "method_body": "public static XmlReadContext createRootContext(int lineNr, int colNr) {\nreturn new XmlReadContext(null, TYPE_ROOT, lineNr, colNr);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:createChildObjectContext(II)Lcom/fasterxml/jackson/dataformat/xml/deser/XmlReadContext;",
                                    "method_body": "public final XmlReadContext createChildObjectContext(int lineNr, int colNr)\n{\nXmlReadContext ctxt = _child;\nif (ctxt == null) {\n_child = ctxt = new XmlReadContext(this, TYPE_OBJECT, lineNr, colNr);\nreturn ctxt;\n}\nctxt.reset(TYPE_OBJECT, lineNr, colNr);\nreturn ctxt;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:getCurrentName()Ljava/lang/String;",
                                    "method_body": "public final String getCurrentName() { return _currentName; }\npublic final String getCurrentName() { return _currentName; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:getParent()Lcom/fasterxml/jackson/dataformat/xml/deser/XmlReadContext;",
                                    "method_body": "public final XmlReadContext getParent() { return _parent; }\npublic final XmlReadContext getParent() { return _parent; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:setCurrentName(Ljava/lang/String;)V",
                                    "method_body": "public void setCurrentName(String name) {\n_currentName = name;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:setNamesToWrap(Ljava/util/Set;)V",
                                    "method_body": "public void setNamesToWrap(Set<String> namesToWrap) {\n_namesToWrap = namesToWrap;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:getNamesToWrap()Ljava/util/Set;",
                                    "method_body": "public Set<String> getNamesToWrap() {\nreturn _namesToWrap;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:convertToArray()V",
                                    "method_body": "protected void convertToArray() {\n_type = TYPE_ARRAY;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:<init>(Ljavax/xml/stream/XMLStreamReader;Ljava/lang/Object;)V",
                                    "method_body": "public XmlTokenStream(XMLStreamReader xmlReader, Object sourceRef)\n{\n_sourceReference = sourceRef;\n// Let's ensure we point to START_ELEMENT...\nif (xmlReader.getEventType() != XMLStreamConstants.START_ELEMENT) {\nthrow new IllegalArgumentException(\"Invalid XMLStreamReader passed: should be pointing to START_ELEMENT (\"\n+XMLStreamConstants.START_ELEMENT+\"), instead got \"+xmlReader.getEventType());\n}\n_xmlReader = Stax2ReaderAdapter.wrapIfNecessary(xmlReader);\n_currentState = XML_START_ELEMENT;\n_localName = _xmlReader.getLocalName();\n_namespaceURI = _xmlReader.getNamespaceURI();\n_attributeCount = _xmlReader.getAttributeCount();\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:next()I",
                                    "method_body": "public int next() throws IOException\n{\nif (_repeatElement != 0) {\nreturn (_currentState = _handleRepeatElement());\n}\ntry {\nreturn _next();\n} catch (XMLStreamException e) {\nStaxUtil.throwXmlAsIOException(e);\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:getText()Ljava/lang/String;",
                                    "method_body": "public String getText() { return _textValue; }\npublic String getText() { return _textValue; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:getLocalName()Ljava/lang/String;",
                                    "method_body": "public String getLocalName() { return _localName; }\npublic String getLocalName() { return _localName; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:closeCompletely()V",
                                    "method_body": "public void closeCompletely() throws IOException\n{\ntry {\n_xmlReader.closeCompletely();\n} catch (XMLStreamException e) {\nStaxUtil.throwXmlAsIOException(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:repeatStartElement()V",
                                    "method_body": "protected void repeatStartElement()\n{\n//System.out.println(\" -> repeatStartElement for \"+_localName);\n// sanity check: can only be used when just returned START_ELEMENT:\nif (_currentState != XML_START_ELEMENT) {\nthrow new IllegalStateException(\"Current state not XML_START_ELEMENT (\"\n+XML_START_ELEMENT+\") but \"+_currentState);\n}\n// Important: add wrapper, to keep track...\nif (_currentWrapper == null) {\n_currentWrapper = ElementWrapper.matchingWrapper(_currentWrapper, _localName, _namespaceURI);\n} else {\n_currentWrapper = ElementWrapper.matchingWrapper(_currentWrapper.getParent(), _localName, _namespaceURI);\n}\n_repeatElement = REPLAY_START_DUP;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:skipAttributes()V",
                                    "method_body": "protected void skipAttributes()\n{\nif (_currentState == XML_ATTRIBUTE_NAME) {\n_attributeCount = 0;\n_currentState = XML_START_ELEMENT;\n} else if (_currentState == XML_START_ELEMENT) {\n/* 06-Jan-2012, tatu: As per [#47] it looks like we should NOT do anything\n*   in this particular case, because it occurs when original element had\n*   no attributes and we now point to the first child element.\n*/\n//              _attributeCount = 0;\n} else if (_currentState == XML_TEXT) {\n; // nothing to do... is it even legal?\n} else {\nthrow new IllegalStateException(\"Current state not XML_START_ELEMENT or XML_ATTRIBUTE_NAME (\"\n+XML_START_ELEMENT+\") but \"+_currentState);\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:_collectUntilTag()Ljava/lang/String;",
                                    "method_body": "private final String _collectUntilTag() throws XMLStreamException\n{\nString text = null;\nwhile (true) {\nswitch (_xmlReader.next()) {\ncase XMLStreamConstants.START_ELEMENT:\ncase XMLStreamConstants.END_ELEMENT:\ncase XMLStreamConstants.END_DOCUMENT:\nreturn text;\n// note: SPACE is ignorable (and seldom seen), not to be included\ncase XMLStreamConstants.CHARACTERS:\ncase XMLStreamConstants.CDATA:\nif (text == null) {\ntext = _xmlReader.getText();\n} else { // can be optimized in future, if need be:\ntext += _xmlReader.getText();\n}\nbreak;\ndefault:\n// any other type (proc instr, comment etc) is just ignored\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:_skipUntilTag()I",
                                    "method_body": "private final int _skipUntilTag() throws XMLStreamException\n{\nwhile (_xmlReader.hasNext()) {\nint type;\nswitch (type = _xmlReader.next()) {\ncase XMLStreamConstants.START_ELEMENT:\ncase XMLStreamConstants.END_ELEMENT:\ncase XMLStreamConstants.END_DOCUMENT:\nreturn type;\ndefault:\n// any other type (proc instr, comment etc) is just ignored\n}\n}\nthrow new IllegalStateException(\"Expected to find a tag, instead reached end of input\");\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:_initStartElement()I",
                                    "method_body": "private final int _initStartElement() throws XMLStreamException\n{\nfinal String ns = _xmlReader.getNamespaceURI();\nfinal String localName = _xmlReader.getLocalName();\n_attributeCount = _xmlReader.getAttributeCount();\n_nextAttributeIndex = 0;\n\n/* Support for virtual wrapping: in wrapping, may either\n* create a new wrapper scope (if in sub-tree, or matches\n* wrapper element itself), or implicitly close existing\n* scope.\n*/\nif (_currentWrapper != null) {\nif (_currentWrapper.matchesWrapper(localName, ns)) {\n_currentWrapper = _currentWrapper.intermediateWrapper();\n} else {\n// implicit end is more interesting:\n_localName = _currentWrapper.getWrapperLocalName();\n_namespaceURI = _currentWrapper.getWrapperNamespace();\n_currentWrapper = _currentWrapper.getParent();\n//System.out.println(\" START_ELEMENT (\"+localName+\") not matching '\"+_localName+\"'; add extra XML-END-ELEMENT!\");\n// Important! We also need to restore the START_ELEMENT, so:\n_nextLocalName = localName;\n_nextNamespaceURI = ns;\n_repeatElement = REPLAY_START_DELAYED;\nreturn (_currentState = XML_END_ELEMENT);\n}\n}\n_localName = localName;\n_namespaceURI = ns;\nreturn (_currentState = XML_START_ELEMENT);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:_handleRepeatElement()I",
                                    "method_body": "protected int _handleRepeatElement() throws IOException\n{\nint type = _repeatElement;\n_repeatElement = 0;\nif (type == REPLAY_START_DUP) {\n//System.out.println(\"handleRepeat for START_ELEMENT: \"+_localName+\" (\"+_xmlReader.getLocalName()+\")\");\n// important: add the virtual element second time, but not with name to match\n_currentWrapper = _currentWrapper.intermediateWrapper();\nreturn XML_START_ELEMENT;\n}\nif (type == REPLAY_END) {\n//System.out.println(\"handleRepeat for END_ELEMENT: \"+_localName+\" (\"+_xmlReader.getLocalName()+\")\");\n_localName = _xmlReader.getLocalName();\n_namespaceURI = _xmlReader.getNamespaceURI();\nif (_currentWrapper != null) {\n_currentWrapper = _currentWrapper.getParent();\n}\nreturn XML_END_ELEMENT;\n}\nif (type == REPLAY_START_DELAYED) {\nif (_currentWrapper != null) {\n_currentWrapper = _currentWrapper.intermediateWrapper();\n}\n_localName = _nextLocalName;\n_namespaceURI = _nextNamespaceURI;\n_nextLocalName = null;\n_nextNamespaceURI = null;\n\n//System.out.println(\"handleRepeat for START_DELAYED: \"+_localName+\" (\"+_xmlReader.getLocalName()+\")\");\n\nreturn XML_START_ELEMENT;\n}\nthrow new IllegalStateException(\"Unrecognized type to repeat: \"+type);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:_handleEndElement()I",
                                    "method_body": "private final int _handleEndElement()\n{\nif (_currentWrapper != null) {\nElementWrapper w = _currentWrapper;\n// important: if we close the scope, must duplicate END_ELEMENT as well\nif (w.isMatching()) {\n_repeatElement = REPLAY_END;\n_localName = w.getWrapperLocalName();\n_namespaceURI = w.getWrapperNamespace();\n_currentWrapper = _currentWrapper.getParent();\n//System.out.println(\" IMPLICIT requestRepeat of END_ELEMENT '\"+_localName);\n} else {\n_currentWrapper = _currentWrapper.getParent();\n}\n}\nreturn (_currentState = XML_END_ELEMENT);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$1:<clinit>()V",
                                    "method_body": "public JsonToken nextToken() throws IOException\n{\n_binaryValue = null;\nif (_nextToken != null) {\nJsonToken t = _nextToken;\n_currToken = t;\n_nextToken = null;\nswitch (t) {\ncase START_OBJECT:\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nbreak;\ncase START_ARRAY:\n_parsingContext = _parsingContext.createChildArrayContext(-1, -1);\nbreak;\ncase END_OBJECT:\ncase END_ARRAY:\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nbreak;\ncase FIELD_NAME:\n_parsingContext.setCurrentName(_xmlTokens.getLocalName());\nbreak;\ndefault: // VALUE_STRING, VALUE_NULL\n// should be fine as is?\n}\nreturn t;\n}\nint token = _xmlTokens.next();\n\n// Need to have a loop just because we may have to eat/convert\n// a start-element that indicates an array element.\nwhile (token == XmlTokenStream.XML_START_ELEMENT) {\n// If we thought we might get leaf, no such luck\nif (_mayBeLeaf) {\n// leave _mayBeLeaf set, as we start a new context\n_nextToken = JsonToken.FIELD_NAME;\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\nif (_parsingContext.inArray()) {\n// Yup: in array, so this element could be verified; but it won't be\n// reported anyway, and we need to process following event.\ntoken = _xmlTokens.next();\n_mayBeLeaf = true;\ncontinue;\n}\nString name = _xmlTokens.getLocalName();\n_parsingContext.setCurrentName(name);\n\n// Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n// Couple of ways to do it; but start by making _xmlTokens replay the thing...\nif (_namesToWrap != null && _namesToWrap.contains(name)) {\n_xmlTokens.repeatStartElement();\n}\n\n_mayBeLeaf = true;\n// Ok: in array context we need to skip reporting field names.\n// But what's the best way to find next token?\nreturn (_currToken = JsonToken.FIELD_NAME);\n}\n\n// Ok; beyond start element, what do we get?\nswitch (token) {\ncase XmlTokenStream.XML_END_ELEMENT:\n// Simple, except that if this is a leaf, need to suppress end:\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n//    expose as empty Object, not null\nreturn (_currToken = JsonToken.VALUE_NULL);\n}\n_currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nreturn _currToken;\n\ncase XmlTokenStream.XML_ATTRIBUTE_NAME:\n// If there was a chance of leaf node, no more...\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n_nextToken = JsonToken.FIELD_NAME;\n_currText = _xmlTokens.getText();\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\n_parsingContext.setCurrentName(_xmlTokens.getLocalName());\nreturn (_currToken = JsonToken.FIELD_NAME);\ncase XmlTokenStream.XML_ATTRIBUTE_VALUE:\n_currText = _xmlTokens.getText();\nreturn (_currToken = JsonToken.VALUE_STRING);\ncase XmlTokenStream.XML_TEXT:\n_currText = _xmlTokens.getText();\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n/* One more refinement (pronunced like \"hack\") is that if\n* we had an empty String (or all white space), and we are\n* deserializing an array, we better hide the empty text.\n*/\n// Also: must skip following END_ELEMENT\n_xmlTokens.skipEndElement();\nif (_parsingContext.inArray()) {\nif (_isEmpty(_currText)) {\n// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n//    expose as empty Object, not null (or, worse, as used to\n//    be done, by swallowing the token)\n_currToken = JsonToken.END_ARRAY;\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nreturn _currToken;\n}\n}\nreturn (_currToken = JsonToken.VALUE_STRING);\n} else {\n// [dataformat-xml#177]: empty text may also need to be skipped\nif (_parsingContext.inObject()\n&& (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n_currToken = JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nreturn _currToken;\n}\n}\n// If not a leaf (or otherwise ignorable), need to transform into property...\n_parsingContext.setCurrentName(_cfgNameForTextElement);\n_nextToken = JsonToken.VALUE_STRING;\nreturn (_currToken = JsonToken.FIELD_NAME);\ncase XmlTokenStream.XML_END:\nreturn (_currToken = null);\n}\n\n// should never get here\n_throwInternal();\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.AnnotationUtil:findIsAttributeAnnotation(Lcom/fasterxml/jackson/databind/AnnotationIntrospector;Lcom/fasterxml/jackson/databind/introspect/AnnotatedMember;)Ljava/lang/Boolean;",
                                    "method_body": "public static Boolean findIsAttributeAnnotation(AnnotationIntrospector ai,\nAnnotatedMember prop)\n{\nfor (AnnotationIntrospector intr : ai.allIntrospectors()) {\nif (intr instanceof XmlAnnotationIntrospector) {\nBoolean b = ((XmlAnnotationIntrospector) intr).isOutputAsAttribute(prop);\nif (b != null) {\nreturn b;\n}\n} else  if (intr instanceof JaxbAnnotationIntrospector) {\nBoolean b = ((JaxbAnnotationIntrospector) intr).isOutputAsAttribute(prop);\nif (b != null) {\nreturn b;\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.AnnotationUtil:findIsTextAnnotation(Lcom/fasterxml/jackson/databind/AnnotationIntrospector;Lcom/fasterxml/jackson/databind/introspect/AnnotatedMember;)Ljava/lang/Boolean;",
                                    "method_body": "public static Boolean findIsTextAnnotation(AnnotationIntrospector ai,\nAnnotatedMember prop)\n{\nfor (AnnotationIntrospector intr : ai.allIntrospectors()) {\nif (intr instanceof XmlAnnotationIntrospector) {\nBoolean b = ((XmlAnnotationIntrospector) intr).isOutputAsText(prop);\nif (b != null) {\nreturn b;\n}\n} else  if (intr instanceof JaxbAnnotationIntrospector) {\nBoolean b = ((JaxbAnnotationIntrospector) intr).isOutputAsText(prop);\nif (b != null) {\nreturn b;\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.WrapperHandlingDeserializer:<init>(Lcom/fasterxml/jackson/databind/deser/BeanDeserializerBase;)V",
                                    "method_body": "public WrapperHandlingDeserializer(BeanDeserializerBase delegate) {\nthis(delegate, null);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.WrapperHandlingDeserializer:<init>(Lcom/fasterxml/jackson/databind/deser/BeanDeserializerBase;Ljava/util/Set;)V",
                                    "method_body": "public WrapperHandlingDeserializer(BeanDeserializerBase delegate, Set<String> namesToWrap)\n{\nsuper(delegate);\n_namesToWrap = namesToWrap;\n_type = delegate.getValueType();\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.WrapperHandlingDeserializer:createContextual(Lcom/fasterxml/jackson/databind/DeserializationContext;Lcom/fasterxml/jackson/databind/BeanProperty;)Lcom/fasterxml/jackson/databind/JsonDeserializer;",
                                    "method_body": "public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\nBeanProperty property)\nthrows JsonMappingException\n{\n// !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n//    out for 2.5 just to increase compatibility slightly with 2.4 databind\n/*\nJavaType vt = _type;\nif (vt == null) {\nvt = ctxt.constructType(_delegatee.handledType());\n}\nJsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n*/\n\nJsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\nBeanDeserializerBase newDelegatee = _verifyDeserType(del);\n\n// Let's go through the properties now...\nIterator<SettableBeanProperty> it = newDelegatee.properties();\nHashSet<String> unwrappedNames = null;\nwhile (it.hasNext()) {\nSettableBeanProperty prop = it.next();\n/* First things first: only consider array/Collection types\n* (not perfect check, but simplest reasonable check)\n*/\nJavaType type = prop.getType();\nif (!TypeUtil.isIndexedType(type)) {\ncontinue;\n}\nPropertyName wrapperName = prop.getWrapperName();\n// skip anything with wrapper (should work as is)\nif (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\ncontinue;\n}\nif (unwrappedNames == null) {\nunwrappedNames = new HashSet<String>();\n}\n// not optimal; should be able to use PropertyName...\nunwrappedNames.add(prop.getName());\n}\n// Ok: if nothing to take care of, just return the delegatee...\nif (unwrappedNames == null) {\nreturn newDelegatee;\n}\n// Otherwise, create the thing that can deal with virtual wrapping\nreturn new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.WrapperHandlingDeserializer:deserialize(Lcom/fasterxml/jackson/core/JsonParser;Lcom/fasterxml/jackson/databind/DeserializationContext;)Ljava/lang/Object;",
                                    "method_body": "public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n{\n_configureParser(jp);\nreturn _delegatee.deserialize(jp,  ctxt);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.WrapperHandlingDeserializer:_configureParser(Lcom/fasterxml/jackson/core/JsonParser;)V",
                                    "method_body": "protected final void _configureParser(JsonParser jp) throws IOException\n{\n/* 19-Aug-2013, tatu: Although we should not usually get called with\n*   parser of other types, there are some cases where this may happen:\n*   specifically, during structural value conversions.\n*/\nif (jp instanceof FromXmlParser) {\n((FromXmlParser) jp).addVirtualWrapping(_namesToWrap);\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.WrapperHandlingDeserializer:_verifyDeserType(Lcom/fasterxml/jackson/databind/JsonDeserializer;)Lcom/fasterxml/jackson/databind/deser/BeanDeserializerBase;",
                                    "method_body": "protected BeanDeserializerBase _verifyDeserType(JsonDeserializer<?> deser)\n{\nif (!(deser instanceof BeanDeserializerBase)) {\nthrow new IllegalArgumentException(\"Can not change delegate to be of type \"\n+deser.getClass().getName());\n}\nreturn (BeanDeserializerBase) deser;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.TypeUtil:isIndexedType(Lcom/fasterxml/jackson/databind/JavaType;)Z",
                                    "method_body": "public static boolean isIndexedType(JavaType type)\n{\nif (type.isContainerType()) {\nClass<?> cls = type.getRawClass();\n// One special case; byte[] will be serialized as base64-encoded String, not real array, so:\n// (actually, ditto for char[]; thought to be a String)\nif (cls == byte[].class || cls == char[].class) {\nreturn false;\n}\n// issue#5: also, should not add wrapping for Maps\nif (Map.class.isAssignableFrom(cls)) {\nreturn false;\n}\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.ElementWrapper:<init>(Lcom/fasterxml/jackson/dataformat/xml/deser/ElementWrapper;Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "private ElementWrapper(ElementWrapper parent,\nString wrapperLocalName, String wrapperNamespace)\n{\n_parent = parent;\n_wrapperName = wrapperLocalName;\n_wrapperNamespace = (wrapperNamespace == null) ? \"\" : wrapperNamespace;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.ElementWrapper:matchingWrapper(Lcom/fasterxml/jackson/dataformat/xml/deser/ElementWrapper;Ljava/lang/String;Ljava/lang/String;)Lcom/fasterxml/jackson/dataformat/xml/deser/ElementWrapper;",
                                    "method_body": "public static ElementWrapper matchingWrapper(ElementWrapper parent,\nString wrapperLocalName, String wrapperNamespace)\n{\nreturn new ElementWrapper(parent, wrapperLocalName, wrapperNamespace);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.ElementWrapper:intermediateWrapper()Lcom/fasterxml/jackson/dataformat/xml/deser/ElementWrapper;",
                                    "method_body": "public ElementWrapper intermediateWrapper() {\nreturn new ElementWrapper(this, null, null);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.ElementWrapper:isMatching()Z",
                                    "method_body": "public boolean isMatching() { return _wrapperName != null; }\npublic boolean isMatching() { return _wrapperName != null; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.ElementWrapper:getWrapperLocalName()Ljava/lang/String;",
                                    "method_body": "public String getWrapperLocalName() { return _wrapperName; }\npublic String getWrapperLocalName() { return _wrapperName; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.ElementWrapper:getWrapperNamespace()Ljava/lang/String;",
                                    "method_body": "public String getWrapperNamespace() { return _wrapperNamespace; }\npublic String getWrapperNamespace() { return _wrapperNamespace; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.ElementWrapper:getParent()Lcom/fasterxml/jackson/dataformat/xml/deser/ElementWrapper;",
                                    "method_body": "public ElementWrapper getParent() { return _parent; }\npublic ElementWrapper getParent() { return _parent; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.ElementWrapper:matchesWrapper(Ljava/lang/String;Ljava/lang/String;)Z",
                                    "method_body": "public boolean matchesWrapper(String localName, String ns)\n{\n// null means \"anything goes\", so:\nif (_wrapperName == null) {\nreturn true;\n}\nif (ns == null) {\nns = \"\";\n}\nreturn _wrapperName.equals(localName) && _wrapperNamespace.equals(ns);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.fasterxml.jackson.dataformat.xml.lists.NestedUnwrappedListsTest.testNestedWithEmpty",
                            "test_body": "public void testNestedWithEmpty() throws Exception\n{\nfinal String XML =\n\"<ServiceDelivery>\\n\"\n+\"  <ResponseTimestamp>2012-09-12T09:28:17.213-04:00</ResponseTimestamp>\\n\"\n+\"  <VehicleMonitoringDelivery>\\n\"\n+\"  </VehicleMonitoringDelivery>\\n\"\n+\"</ServiceDelivery>\\n\"\n;\nServiceDelivery svc = _xmlMapper.readValue(XML, ServiceDelivery.class);\nassertNotNull(svc);\nassertNotNull(svc.vehicleMonitoringDelivery);\n// 06-Jan-2015, tatu: Really should have one empty entry, not 0\nassertEquals(1, svc.vehicleMonitoringDelivery.size());\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<init>()V",
                                    "method_body": "public XmlMapper() {\nthis(new XmlFactory());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<init>(Lcom/fasterxml/jackson/dataformat/xml/XmlFactory;)V",
                                    "method_body": "public XmlMapper(XmlFactory xmlFactory) {\nthis(xmlFactory, DEFAULT_XML_MODULE);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<init>(Lcom/fasterxml/jackson/dataformat/xml/XmlFactory;Lcom/fasterxml/jackson/dataformat/xml/JacksonXmlModule;)V",
                                    "method_body": "public XmlMapper(XmlFactory xmlFactory, JacksonXmlModule module)\n{\n/* Need to override serializer provider (due to root name handling);\n* deserializer provider fine as is\n*/\nsuper(xmlFactory, new XmlSerializerProvider(new XmlRootNameLookup()), null);\n_xmlModule = module;\n// but all the rest is done via Module interface!\nif (module != null) {\nregisterModule(module);\n}\n// 19-May-2015, tatu: Must ensure we use XML-specific indenter\n_serializationConfig = _serializationConfig.withDefaultPrettyPrinter(DEFAULT_XML_PRETTY_PRINTER);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\nprotected final static JacksonXmlModule DEFAULT_XML_MODULE = new JacksonXmlModule();\n\nprotected final static DefaultXmlPrettyPrinter DEFAULT_XML_PRETTY_PRINTER = new DefaultXmlPrettyPrinter();\n\n// need to hold on to module instance just in case copy() is used\nprotected final JacksonXmlModule _xmlModule;\n\n/*\n/**********************************************************\n/* Life-cycle: construction, configuration\n/**********************************************************\n*/\n\npublic XmlMapper() {\nthis(new XmlFactory());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlModule:<init>()V",
                                    "method_body": "public JacksonXmlModule()\n{\nsuper(\"JackxonXmlModule\", PackageVersion.VERSION);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlModule:setupModule(Lcom/fasterxml/jackson/databind/Module$SetupContext;)V",
                                    "method_body": "public void setupModule(SetupContext context)\n{\n// Need to modify BeanDeserializer, BeanSerializer that are used\ncontext.addBeanSerializerModifier(new XmlBeanSerializerModifier());\ncontext.addBeanDeserializerModifier(new XmlBeanDeserializerModifier(_cfgNameForTextElement));\n\n// as well as AnnotationIntrospector\ncontext.insertAnnotationIntrospector(_constructIntrospector());\n\n// and finally inform XmlFactory about overrides, if need be:\nif (_cfgNameForTextElement != FromXmlParser.DEFAULT_UNNAMED_TEXT_PROPERTY) {\nXmlMapper m = (XmlMapper) context.getOwner();\nm.setXMLTextElementName(_cfgNameForTextElement);\n}\n\n/* Usually this would be the first call; but here anything added will\n* be stuff user may has added, so do it afterwards instead.\n*/\nsuper.setupModule(context);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlModule:_constructIntrospector()Lcom/fasterxml/jackson/databind/AnnotationIntrospector;",
                                    "method_body": "protected AnnotationIntrospector _constructIntrospector() {\nreturn new JacksonXmlAnnotationIntrospector(_cfgDefaultUseWrapper);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.PackageVersion:<clinit>()V",
                                    "method_body": "public final static Version VERSION = VersionUtil.parseVersion(\n\"2.7.0-rc4-SNAPSHOT\", \"com.fasterxml.jackson.dataformat\", \"jackson-dataformat-xml\");\n\n@Override\npublic Version version() {\nreturn VERSION;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter:<init>()V",
                                    "method_body": "public void writeIndentation(JsonGenerator g, int level) throws IOException;\n\npublic void writeIndentation(XMLStreamWriter2 sw, int level) throws XMLStreamException;\n\n/**\n* @return True if indenter is considered inline (does not add linefeeds),\n*   false otherwise\n*/\npublic boolean isInline();\n}\n\n/*\n/**********************************************************\n/* Configuration\n/**********************************************************\n*/\n\n/**\n* By default, let's use only spaces to separate array values.\n*/\nprotected Indenter _arrayIndenter = new FixedSpaceIndenter();\n\n/**\n* By default, let's use linefeed-adding indenter for separate\n* object entries. We'll further configure indenter to use\n* system-specific linefeeds, and 2 spaces per level (as opposed to,\n* say, single tabs)\n*/\nprotected Indenter _objectIndenter = new Lf2SpacesIndenter();\n\n// // // Config, other white space configuration\n\n/**\n* By default we will add spaces around colons used to\n* separate object fields and values.\n* If disabled, will not use spaces around colon.\n*/\nprotected boolean _spacesInObjectEntries = true;\n\n/*\n/**********************************************************\n/* State\n/**********************************************************\n*/\n\n/**\n* Number of open levels of nesting. Used to determine amount of\n* indentation to use.\n*/\nprotected transient int _nesting = 0;\n\n/**\n* Marker flag set on start element, and cleared if an end element\n* is encountered. Used for suppressing indentation to allow empty\n* elements.\n*\n* @since 2.3.0\n*/\nprotected transient boolean _justHadStartElement;\n\n/*\n/**********************************************************\n/* Life-cycle (construct, configure)\n/**********************************************************\n*/\n\npublic DefaultXmlPrettyPrinter() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter$FixedSpaceIndenter:<init>()V",
                                    "method_body": "public FixedSpaceIndenter() { }\npublic FixedSpaceIndenter() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter$Lf2SpacesIndenter:<init>()V",
                                    "method_body": "public Lf2SpacesIndenter() { }\npublic Lf2SpacesIndenter() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter$Lf2SpacesIndenter:<clinit>()V",
                                    "method_body": "final static int SPACE_COUNT = 64;\nfinal static char[] SPACES = new char[SPACE_COUNT];\nstatic {\nArrays.fill(SPACES, ' ');\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>()V",
                                    "method_body": "public XmlFactory() { this(null, null, null); }\npublic XmlFactory() { this(null, null, null); }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>(Lcom/fasterxml/jackson/core/ObjectCodec;Ljavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;)V",
                                    "method_body": "public XmlFactory(ObjectCodec oc, XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n{\nthis(oc, DEFAULT_XML_PARSER_FEATURE_FLAGS, DEFAULT_XML_GENERATOR_FEATURE_FLAGS,\nxmlIn, xmlOut, null);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>(Lcom/fasterxml/jackson/core/ObjectCodec;IILjavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;Ljava/lang/String;)V",
                                    "method_body": "protected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\nXMLInputFactory xmlIn, XMLOutputFactory xmlOut,\nString nameForTextElem)\n{\nsuper(oc);\n_xmlParserFeatures = xpFeatures;\n_xmlGeneratorFeatures = xgFeatures;\n_cfgNameForTextElement = nameForTextElem;\nif (xmlIn == null) {\nxmlIn = XMLInputFactory.newInstance();\n}\nif (xmlOut == null) {\nxmlOut = XMLOutputFactory.newInstance();\n}\n_initFactories(xmlIn, xmlOut);\n_xmlInputFactory = xmlIn;\n_xmlOutputFactory = xmlOut;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<clinit>()V",
                                    "method_body": "public final static String FORMAT_NAME_XML = \"XML\";\n\n/**\n* Bitfield (set of flags) of all parser features that are enabled\n* by default.\n*/\nfinal static int DEFAULT_XML_PARSER_FEATURE_FLAGS = FromXmlParser.Feature.collectDefaults();\n\n/**\n* Bitfield (set of flags) of all generator features that are enabled\n* by default.\n*/\nfinal static int DEFAULT_XML_GENERATOR_FEATURE_FLAGS = ToXmlGenerator.Feature.collectDefaults();\n\n/*\n/**********************************************************\n/* Configuration\n/**********************************************************\n*/\n\nprotected int _xmlParserFeatures;\n\nprotected int _xmlGeneratorFeatures;\n\n// non-final for setters (why are they needed again?)\nprotected transient XMLInputFactory _xmlInputFactory;\n\nprotected transient XMLOutputFactory _xmlOutputFactory;\n\nprotected String _cfgNameForTextElement;\n\n/*\n/**********************************************************\n/* Factory construction, configuration\n/**********************************************************\n*/\n\n/**\n* Default constructor used to create factory instances.\n* Creation of a factory instance is a light-weight operation,\n* but it is still a good idea to reuse limited number of\n* factory instances (and quite often just a single instance):\n* factories are used as context for storing some reused\n* processing objects (such as symbol tables parsers use)\n* and this reuse only works within context of a single\n* factory instance.\n*/\npublic XmlFactory() { this(null, null, null); }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_initFactories(Ljavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;)V",
                                    "method_body": "protected void _initFactories(XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n{\n// Better ensure namespaces get built properly, so:\nxmlOut.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\n// and for parser, force coalescing as well (much simpler to use)\nxmlIn.setProperty(XMLInputFactory.IS_COALESCING, Boolean.TRUE);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:createParser(Ljava/lang/String;)Lcom/fasterxml/jackson/core/JsonParser;",
                                    "method_body": "public JsonParser createParser(String content) throws IOException {\nReader r = new StringReader(content);\nIOContext ctxt = _createContext(r, true);\nif (_inputDecorator != null) {\nr = _inputDecorator.decorate(ctxt, r);\n}\nreturn _createParser(r, ctxt);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_createParser(Ljava/io/Reader;Lcom/fasterxml/jackson/core/io/IOContext;)Lcom/fasterxml/jackson/dataformat/xml/deser/FromXmlParser;",
                                    "method_body": "protected FromXmlParser _createParser(Reader r, IOContext ctxt) throws IOException\n{\nXMLStreamReader sr;\ntry {\nsr = _xmlInputFactory.createXMLStreamReader(r);\nsr = _initializeXmlReader(sr);\n} catch (XMLStreamException e) {\nreturn StaxUtil.throwXmlAsIOException(e);\n}\nFromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n_objectCodec, sr);\nif (_cfgNameForTextElement != null) {\nxp.setXMLTextElementName(_cfgNameForTextElement);\n}\nreturn xp;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_initializeXmlReader(Ljavax/xml/stream/XMLStreamReader;)Ljavax/xml/stream/XMLStreamReader;",
                                    "method_body": "protected final XMLStreamReader _initializeXmlReader(XMLStreamReader sr) throws IOException, XMLStreamException\n{\n// for now, nothing to do... except let's find the root element\nwhile (sr.next() != XMLStreamConstants.START_ELEMENT) {\n;\n}\nreturn sr;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature:<clinit>()V",
                                    "method_body": "public final static String DEFAULT_UNNAMED_TEXT_PROPERTY = \"\";\n\n/**\n* Enumeration that defines all togglable features for XML parsers.\n* None defined so far (2.6), so just a placeholder.\n*/\npublic enum Feature implements FormatFeature\n{\n;\n\nfinal boolean _defaultState;\nfinal int _mask;\n\n/**\n* Method that calculates bit set (flags) of all features that\n* are enabled by default.\n*/\npublic static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}\n\nprivate Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}\n\n@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public int getMask() { return _mask; }\n@Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature:collectDefaults()I",
                                    "method_body": "public static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:<init>(Ljava/lang/String;IZ)V",
                                    "method_body": "private Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:<clinit>()V",
                                    "method_body": "protected final static String DEFAULT_UNKNOWN_ELEMENT = \"unknown\";\n\n/**\n* Enumeration that defines all togglable extra XML-specific features\n*/\npublic enum Feature implements FormatFeature\n{\n/**\n* Feature that controls whether XML declaration should be written before\n* when generator is initialized (true) or not (false)\n*/\nWRITE_XML_DECLARATION(false),\n\n/**\n* Feature that controls whether output should be done as XML 1.1; if so,\n* certain aspects may differ from default (1.0) processing: for example,\n* XML declaration will be automatically added (regardless of setting\n* <code>WRITE_XML_DECLARATION</code>) as this is required for reader to\n* know to use 1.1 compliant handling. XML 1.1 can be used to allow quoted\n* control characters (Ascii codes 0 through 31) as well as additional linefeeds\n* and name characters.\n*/\nWRITE_XML_1_1(false)\n;\n\nfinal boolean _defaultState;\nfinal int _mask;\n\n/**\n* Method that calculates bit set (flags) of all features that\n* are enabled by default.\n*/\npublic static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}\n\nprivate Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}\n\n@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public int getMask() { return _mask; }\n@Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:collectDefaults()I",
                                    "method_body": "public static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:enabledByDefault()Z",
                                    "method_body": "@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public boolean enabledByDefault() { return _defaultState; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:<init>(Lcom/fasterxml/jackson/dataformat/xml/util/XmlRootNameLookup;)V",
                                    "method_body": "public XmlSerializerProvider(XmlRootNameLookup rootNames)\n{\nsuper();\n_rootNameLookup = rootNames;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\n/**\n* If all we get to serialize is a null, there's no way to figure out\n* expected root name; so let's just default to something like \"&lt;null>\"...\n*/\nprotected final static QName ROOT_NAME_FOR_NULL = new QName(\"null\");\n\nprotected final XmlRootNameLookup _rootNameLookup;\n\npublic XmlSerializerProvider(XmlRootNameLookup rootNames)\n{\nsuper();\n_rootNameLookup = rootNames;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.XmlRootNameLookup:<init>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\n/**\n* For efficient operation, let's try to minimize number of times we\n* need to introspect root element name to use.\n*<p>\n* Note: changed to <code>transient</code> for 2.3; no point in serializing such\n* state\n*/\nprotected final transient LRUMap<ClassKey,QName> _rootNames = new LRUMap<ClassKey,QName>(40, 200);\n\npublic XmlRootNameLookup() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerModifier:<init>()V",
                                    "method_body": "public XmlBeanSerializerModifier() { }\npublic XmlBeanSerializerModifier() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlBeanDeserializerModifier:<init>(Ljava/lang/String;)V",
                                    "method_body": "public XmlBeanDeserializerModifier(String nameForTextValue)\n{\n_cfgNameForTextValue = nameForTextValue;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlBeanDeserializerModifier:updateProperties(Lcom/fasterxml/jackson/databind/DeserializationConfig;Lcom/fasterxml/jackson/databind/BeanDescription;Ljava/util/List;)Ljava/util/List;",
                                    "method_body": "public List<BeanPropertyDefinition> updateProperties(DeserializationConfig config,\nBeanDescription beanDesc, List<BeanPropertyDefinition> propDefs)\n{\nfinal AnnotationIntrospector intr = config.getAnnotationIntrospector();\nint changed = 0;\n\nfor (int i = 0, propCount = propDefs.size(); i < propCount; ++i) {\nBeanPropertyDefinition prop = propDefs.get(i);\nAnnotatedMember acc = prop.getPrimaryMember();\n// should not be null, but just in case:\nif (acc == null) {\ncontinue;\n}\n/* First: handle \"as text\"? Such properties\n* are exposed as values of 'unnamed' fields; so one way to\n* map them is to rename property to have name \"\"... (and\n* hope this does not break other parts...)\n*/\nBoolean b = AnnotationUtil.findIsTextAnnotation(intr, acc);\nif (b != null && b.booleanValue()) {\n// unwrapped properties will appear as 'unnamed' (empty String)\nBeanPropertyDefinition newProp = prop.withSimpleName(_cfgNameForTextValue);\nif (newProp != prop) {\npropDefs.set(i, newProp);\n}\ncontinue;\n}\n// second: do we need to handle wrapping (for Lists)?\nPropertyName wrapperName = prop.getWrapperName();\n\nif (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\nString localName = wrapperName.getSimpleName();\nif ((localName != null && localName.length() > 0)\n&& !localName.equals(prop.getName())) {\n// make copy-on-write as necessary\nif (changed == 0) {\npropDefs = new ArrayList<BeanPropertyDefinition>(propDefs);\n}\n++changed;\npropDefs.set(i, prop.withSimpleName(localName));\ncontinue;\n}\n// otherwise unwrapped; needs handling but later on\n}\n}\nreturn propDefs;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlBeanDeserializerModifier:modifyDeserializer(Lcom/fasterxml/jackson/databind/DeserializationConfig;Lcom/fasterxml/jackson/databind/BeanDescription;Lcom/fasterxml/jackson/databind/JsonDeserializer;)Lcom/fasterxml/jackson/databind/JsonDeserializer;",
                                    "method_body": "public JsonDeserializer<?> modifyDeserializer(DeserializationConfig config,\nBeanDescription beanDesc, JsonDeserializer<?> deser0)\n{\nif (!(deser0 instanceof BeanDeserializerBase)) {\nreturn deser0;\n}\n/* 17-Aug-2013, tatu: One important special case first: if we have one \"XML Text\"\n* property, it may be exposed as VALUE_STRING token (depending on whether any attribute\n* values are exposed): and to deserialize from that, we need special handling unless POJO\n* has appropriate single-string creator method.\n*/\nBeanDeserializerBase deser = (BeanDeserializerBase) deser0;\n\n// Heuristics are bit tricky; but for now let's assume that if POJO\n// can already work with VALUE_STRING, it's ok and doesn't need extra support\nif (!deser.getValueInstantiator().canCreateFromString()) {\nSettableBeanProperty textProp = _findSoleTextProp(config, deser.properties());\nif (textProp != null) {\nreturn new XmlTextDeserializer(deser, textProp);\n}\n}\nreturn new WrapperHandlingDeserializer(deser);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlBeanDeserializerModifier:_findSoleTextProp(Lcom/fasterxml/jackson/databind/DeserializationConfig;Ljava/util/Iterator;)Lcom/fasterxml/jackson/databind/deser/SettableBeanProperty;",
                                    "method_body": "private SettableBeanProperty _findSoleTextProp(DeserializationConfig config,\nIterator<SettableBeanProperty> propIt)\n{\nfinal AnnotationIntrospector ai = config.getAnnotationIntrospector();\nSettableBeanProperty textProp = null;\nwhile (propIt.hasNext()) {\nSettableBeanProperty prop = propIt.next();\nAnnotatedMember m = prop.getMember();\nif (m != null) {\n// Ok, let's use a simple check: we should have renamed it earlier so:\nPropertyName n = prop.getFullName();\nif (_cfgNameForTextValue.equals(n.getSimpleName())) {\n// should we verify we only got one?\ntextProp = prop;\ncontinue;\n}\n// as-attribute are ok as well\nBoolean b = AnnotationUtil.findIsAttributeAnnotation(ai, m);\nif (b != null && b.booleanValue()) {\ncontinue;\n}\n}\n// Otherwise, it's something else; no go\nreturn null;\n}\nreturn textProp;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:<init>(Z)V",
                                    "method_body": "public JacksonXmlAnnotationIntrospector(boolean defaultUseWrapper) {\n_cfgDefaultUseWrapper = defaultUseWrapper;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:findWrapperName(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Lcom/fasterxml/jackson/databind/PropertyName;",
                                    "method_body": "public PropertyName findWrapperName(Annotated ann)\n{\nJacksonXmlElementWrapper w = ann.getAnnotation(JacksonXmlElementWrapper.class);\nif (w != null) {\n// Special case: wrapping explicitly blocked?\nif (!w.useWrapping()) {\nreturn PropertyName.NO_NAME;\n}\n// also: need to ensure we use marker:\nString localName = w.localName();\nif (localName == null || localName.length() == 0) {\nreturn PropertyName.USE_DEFAULT;\n}\nreturn PropertyName.construct(w.localName(), w.namespace());\n}\n/* 09-Sep-2012, tatu: In absence of configurating we need to use our\n*   default settings...\n*/\nif (_cfgDefaultUseWrapper) {\nreturn PropertyName.USE_DEFAULT;\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:isOutputAsAttribute(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Ljava/lang/Boolean;",
                                    "method_body": "public Boolean isOutputAsAttribute(Annotated ann)\n{\nJacksonXmlProperty prop = ann.getAnnotation(JacksonXmlProperty.class);\nif (prop != null) {\nreturn prop.isAttribute() ? Boolean.TRUE : Boolean.FALSE;\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:isOutputAsText(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Ljava/lang/Boolean;",
                                    "method_body": "public Boolean isOutputAsText(Annotated ann)\n{\nJacksonXmlText prop = ann.getAnnotation(JacksonXmlText.class);\nif (prop != null) {\nreturn prop.value() ? Boolean.TRUE : Boolean.FALSE;\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:findNameForDeserialization(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Lcom/fasterxml/jackson/databind/PropertyName;",
                                    "method_body": "public PropertyName findNameForDeserialization(Annotated a)\n{\nPropertyName name = _findXmlName(a);\nif (name == null) {\nname = super.findNameForDeserialization(a);\nif (name == null) {\nif (a.hasAnnotation(JacksonXmlText.class)) {\nreturn PropertyName.USE_DEFAULT;\n}\n}\n}\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:_findXmlName(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Lcom/fasterxml/jackson/databind/PropertyName;",
                                    "method_body": "protected PropertyName _findXmlName(Annotated a)\n{\nJacksonXmlProperty pann = a.getAnnotation(JacksonXmlProperty.class);\nif (pann != null) {\nreturn PropertyName.construct(pann.localName(), pann.namespace());\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:<init>(Lcom/fasterxml/jackson/core/io/IOContext;IILcom/fasterxml/jackson/core/ObjectCodec;Ljavax/xml/stream/XMLStreamReader;)V",
                                    "method_body": "public FromXmlParser(IOContext ctxt, int genericParserFeatures, int xmlFeatures,\nObjectCodec codec, XMLStreamReader xmlReader)\n{\nsuper(genericParserFeatures);\n_formatFeatures = xmlFeatures;\n_ioContext = ctxt;\n_objectCodec = codec;\n_parsingContext = XmlReadContext.createRootContext(-1, -1);\n// and thereby start a scope\n_nextToken = JsonToken.START_OBJECT;\n_xmlTokens = new XmlTokenStream(xmlReader, ctxt.getSourceReference());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:addVirtualWrapping(Ljava/util/Set;)V",
                                    "method_body": "public void addVirtualWrapping(Set<String> namesToWrap)\n{\n/* 17-Sep-2012, tatu: Not 100% sure why, but this is necessary to avoid\n*   problems with Lists-in-Lists properties\n*/\nString name = _xmlTokens.getLocalName();\nif (name != null && namesToWrap.contains(name)) {\n_xmlTokens.repeatStartElement();\n}\n_namesToWrap = namesToWrap;\n_parsingContext.setNamesToWrap(namesToWrap);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:getCurrentName()Ljava/lang/String;",
                                    "method_body": "public String getCurrentName() throws IOException\n{\n// start markers require information from parent\nString name;\nif (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\nXmlReadContext parent = _parsingContext.getParent();\nname = parent.getCurrentName();\n} else {\nname = _parsingContext.getCurrentName();\n}\n// sanity check\nif (name == null) {\nthrow new IllegalStateException(\"Missing name, in state: \"+_currToken);\n}\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:close()V",
                                    "method_body": "public void close() throws IOException\n{\nif (!_closed) {\n_closed = true;\ntry {\nif (_ioContext.isResourceManaged() || isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)) {\n_xmlTokens.closeCompletely();\n} else {\n_xmlTokens.close();\n}\n} finally {\n// as per [JACKSON-324], do in finally block\n// Also, internal buffer(s) can now be released as well\n_releaseBuffers();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:getParsingContext()Lcom/fasterxml/jackson/dataformat/xml/deser/XmlReadContext;",
                                    "method_body": "public XmlReadContext getParsingContext() {\nreturn _parsingContext;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:isExpectedStartArrayToken()Z",
                                    "method_body": "public boolean isExpectedStartArrayToken()\n{\nJsonToken t = _currToken;\nif (t == JsonToken.START_OBJECT) {\n_currToken = JsonToken.START_ARRAY;\n// Ok: must replace current context with array as well\n_parsingContext.convertToArray();\n//System.out.println(\" isExpectedArrayStart: OBJ->Array, wraps now: \"+_parsingContext.getNamesToWrap());\n// And just in case a field name was to be returned, wipe it\n_nextToken = null;\n// and last thing, [dataformat-xml#33], better ignore attributes\n_xmlTokens.skipAttributes();\nreturn true;\n}\n//System.out.println(\" isExpectedArrayStart?: t=\"+t);\nreturn (t == JsonToken.START_ARRAY);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:getText()Ljava/lang/String;",
                                    "method_body": "public String getText() throws IOException\n{\nif (_currToken == null) {\nreturn null;\n}\nswitch (_currToken) {\ncase FIELD_NAME:\nreturn getCurrentName();\ncase VALUE_STRING:\nreturn _currText;\ndefault:\nreturn _currToken.asString();\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:_releaseBuffers()V",
                                    "method_body": "protected void _releaseBuffers() throws IOException {\n// anything we can/must release? Underlying parser should do all of it, for now?\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:<init>(Lcom/fasterxml/jackson/dataformat/xml/deser/XmlReadContext;III)V",
                                    "method_body": "public XmlReadContext(XmlReadContext parent, int type, int lineNr, int colNr)\n{\nsuper();\n_type = type;\n_parent = parent;\n_lineNr = lineNr;\n_columnNr = colNr;\n_index = -1;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:createRootContext(II)Lcom/fasterxml/jackson/dataformat/xml/deser/XmlReadContext;",
                                    "method_body": "public static XmlReadContext createRootContext(int lineNr, int colNr) {\nreturn new XmlReadContext(null, TYPE_ROOT, lineNr, colNr);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:createChildObjectContext(II)Lcom/fasterxml/jackson/dataformat/xml/deser/XmlReadContext;",
                                    "method_body": "public final XmlReadContext createChildObjectContext(int lineNr, int colNr)\n{\nXmlReadContext ctxt = _child;\nif (ctxt == null) {\n_child = ctxt = new XmlReadContext(this, TYPE_OBJECT, lineNr, colNr);\nreturn ctxt;\n}\nctxt.reset(TYPE_OBJECT, lineNr, colNr);\nreturn ctxt;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:getCurrentName()Ljava/lang/String;",
                                    "method_body": "public final String getCurrentName() { return _currentName; }\npublic final String getCurrentName() { return _currentName; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:getParent()Lcom/fasterxml/jackson/dataformat/xml/deser/XmlReadContext;",
                                    "method_body": "public final XmlReadContext getParent() { return _parent; }\npublic final XmlReadContext getParent() { return _parent; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:setCurrentName(Ljava/lang/String;)V",
                                    "method_body": "public void setCurrentName(String name) {\n_currentName = name;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:setNamesToWrap(Ljava/util/Set;)V",
                                    "method_body": "public void setNamesToWrap(Set<String> namesToWrap) {\n_namesToWrap = namesToWrap;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:getNamesToWrap()Ljava/util/Set;",
                                    "method_body": "public Set<String> getNamesToWrap() {\nreturn _namesToWrap;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:convertToArray()V",
                                    "method_body": "protected void convertToArray() {\n_type = TYPE_ARRAY;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:<init>(Ljavax/xml/stream/XMLStreamReader;Ljava/lang/Object;)V",
                                    "method_body": "public XmlTokenStream(XMLStreamReader xmlReader, Object sourceRef)\n{\n_sourceReference = sourceRef;\n// Let's ensure we point to START_ELEMENT...\nif (xmlReader.getEventType() != XMLStreamConstants.START_ELEMENT) {\nthrow new IllegalArgumentException(\"Invalid XMLStreamReader passed: should be pointing to START_ELEMENT (\"\n+XMLStreamConstants.START_ELEMENT+\"), instead got \"+xmlReader.getEventType());\n}\n_xmlReader = Stax2ReaderAdapter.wrapIfNecessary(xmlReader);\n_currentState = XML_START_ELEMENT;\n_localName = _xmlReader.getLocalName();\n_namespaceURI = _xmlReader.getNamespaceURI();\n_attributeCount = _xmlReader.getAttributeCount();\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:next()I",
                                    "method_body": "public int next() throws IOException\n{\nif (_repeatElement != 0) {\nreturn (_currentState = _handleRepeatElement());\n}\ntry {\nreturn _next();\n} catch (XMLStreamException e) {\nStaxUtil.throwXmlAsIOException(e);\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:getText()Ljava/lang/String;",
                                    "method_body": "public String getText() { return _textValue; }\npublic String getText() { return _textValue; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:getLocalName()Ljava/lang/String;",
                                    "method_body": "public String getLocalName() { return _localName; }\npublic String getLocalName() { return _localName; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:closeCompletely()V",
                                    "method_body": "public void closeCompletely() throws IOException\n{\ntry {\n_xmlReader.closeCompletely();\n} catch (XMLStreamException e) {\nStaxUtil.throwXmlAsIOException(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:repeatStartElement()V",
                                    "method_body": "protected void repeatStartElement()\n{\n//System.out.println(\" -> repeatStartElement for \"+_localName);\n// sanity check: can only be used when just returned START_ELEMENT:\nif (_currentState != XML_START_ELEMENT) {\nthrow new IllegalStateException(\"Current state not XML_START_ELEMENT (\"\n+XML_START_ELEMENT+\") but \"+_currentState);\n}\n// Important: add wrapper, to keep track...\nif (_currentWrapper == null) {\n_currentWrapper = ElementWrapper.matchingWrapper(_currentWrapper, _localName, _namespaceURI);\n} else {\n_currentWrapper = ElementWrapper.matchingWrapper(_currentWrapper.getParent(), _localName, _namespaceURI);\n}\n_repeatElement = REPLAY_START_DUP;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:skipAttributes()V",
                                    "method_body": "protected void skipAttributes()\n{\nif (_currentState == XML_ATTRIBUTE_NAME) {\n_attributeCount = 0;\n_currentState = XML_START_ELEMENT;\n} else if (_currentState == XML_START_ELEMENT) {\n/* 06-Jan-2012, tatu: As per [#47] it looks like we should NOT do anything\n*   in this particular case, because it occurs when original element had\n*   no attributes and we now point to the first child element.\n*/\n//              _attributeCount = 0;\n} else if (_currentState == XML_TEXT) {\n; // nothing to do... is it even legal?\n} else {\nthrow new IllegalStateException(\"Current state not XML_START_ELEMENT or XML_ATTRIBUTE_NAME (\"\n+XML_START_ELEMENT+\") but \"+_currentState);\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:_next()I",
                                    "method_body": "private final int _next() throws XMLStreamException\n{\nswitch (_currentState) {\ncase XML_ATTRIBUTE_VALUE:\n++_nextAttributeIndex;\n// fall through\ncase XML_START_ELEMENT: // attributes to return?\nif (_nextAttributeIndex < _attributeCount) {\n_localName = _xmlReader.getAttributeLocalName(_nextAttributeIndex);\n_namespaceURI = _xmlReader.getAttributeNamespace(_nextAttributeIndex);\n_textValue = _xmlReader.getAttributeValue(_nextAttributeIndex);\nreturn (_currentState = XML_ATTRIBUTE_NAME);\n}\n// otherwise need to find START/END_ELEMENT or text\nString text = _collectUntilTag();\n// If it's START_ELEMENT, ignore any text\nif (_xmlReader.getEventType() == XMLStreamReader.START_ELEMENT) {\nreturn _initStartElement();\n}\n// For END_ELEMENT we will return text, if any\nif (text != null) {\n_textValue = text;\nreturn (_currentState = XML_TEXT);\n}\nreturn _handleEndElement();\ncase XML_ATTRIBUTE_NAME:\n// if we just returned name, will need to just send value next\nreturn (_currentState = XML_ATTRIBUTE_VALUE);\ncase XML_TEXT:\n// text is always followed by END_ELEMENT\nreturn _handleEndElement();\ncase XML_END:\nreturn XML_END;\n//            throw new IllegalStateException(\"No more XML tokens available (end of input)\");\n}\n\n// Ok: must be END_ELEMENT; see what tag we get (or end)\nswitch (_skipUntilTag()) {\ncase XMLStreamConstants.END_DOCUMENT:\nreturn (_currentState = XML_END);\ncase XMLStreamConstants.END_ELEMENT:\nreturn _handleEndElement();\n}\n// START_ELEMENT...\nreturn _initStartElement();\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:_collectUntilTag()Ljava/lang/String;",
                                    "method_body": "private final String _collectUntilTag() throws XMLStreamException\n{\nString text = null;\nwhile (true) {\nswitch (_xmlReader.next()) {\ncase XMLStreamConstants.START_ELEMENT:\ncase XMLStreamConstants.END_ELEMENT:\ncase XMLStreamConstants.END_DOCUMENT:\nreturn text;\n// note: SPACE is ignorable (and seldom seen), not to be included\ncase XMLStreamConstants.CHARACTERS:\ncase XMLStreamConstants.CDATA:\nif (text == null) {\ntext = _xmlReader.getText();\n} else { // can be optimized in future, if need be:\ntext += _xmlReader.getText();\n}\nbreak;\ndefault:\n// any other type (proc instr, comment etc) is just ignored\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:_skipUntilTag()I",
                                    "method_body": "private final int _skipUntilTag() throws XMLStreamException\n{\nwhile (_xmlReader.hasNext()) {\nint type;\nswitch (type = _xmlReader.next()) {\ncase XMLStreamConstants.START_ELEMENT:\ncase XMLStreamConstants.END_ELEMENT:\ncase XMLStreamConstants.END_DOCUMENT:\nreturn type;\ndefault:\n// any other type (proc instr, comment etc) is just ignored\n}\n}\nthrow new IllegalStateException(\"Expected to find a tag, instead reached end of input\");\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:_initStartElement()I",
                                    "method_body": "private final int _initStartElement() throws XMLStreamException\n{\nfinal String ns = _xmlReader.getNamespaceURI();\nfinal String localName = _xmlReader.getLocalName();\n_attributeCount = _xmlReader.getAttributeCount();\n_nextAttributeIndex = 0;\n\n/* Support for virtual wrapping: in wrapping, may either\n* create a new wrapper scope (if in sub-tree, or matches\n* wrapper element itself), or implicitly close existing\n* scope.\n*/\nif (_currentWrapper != null) {\nif (_currentWrapper.matchesWrapper(localName, ns)) {\n_currentWrapper = _currentWrapper.intermediateWrapper();\n} else {\n// implicit end is more interesting:\n_localName = _currentWrapper.getWrapperLocalName();\n_namespaceURI = _currentWrapper.getWrapperNamespace();\n_currentWrapper = _currentWrapper.getParent();\n//System.out.println(\" START_ELEMENT (\"+localName+\") not matching '\"+_localName+\"'; add extra XML-END-ELEMENT!\");\n// Important! We also need to restore the START_ELEMENT, so:\n_nextLocalName = localName;\n_nextNamespaceURI = ns;\n_repeatElement = REPLAY_START_DELAYED;\nreturn (_currentState = XML_END_ELEMENT);\n}\n}\n_localName = localName;\n_namespaceURI = ns;\nreturn (_currentState = XML_START_ELEMENT);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:_handleEndElement()I",
                                    "method_body": "private final int _handleEndElement()\n{\nif (_currentWrapper != null) {\nElementWrapper w = _currentWrapper;\n// important: if we close the scope, must duplicate END_ELEMENT as well\nif (w.isMatching()) {\n_repeatElement = REPLAY_END;\n_localName = w.getWrapperLocalName();\n_namespaceURI = w.getWrapperNamespace();\n_currentWrapper = _currentWrapper.getParent();\n//System.out.println(\" IMPLICIT requestRepeat of END_ELEMENT '\"+_localName);\n} else {\n_currentWrapper = _currentWrapper.getParent();\n}\n}\nreturn (_currentState = XML_END_ELEMENT);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$1:<clinit>()V",
                                    "method_body": "public JsonToken nextToken() throws IOException\n{\n_binaryValue = null;\nif (_nextToken != null) {\nJsonToken t = _nextToken;\n_currToken = t;\n_nextToken = null;\nswitch (t) {\ncase START_OBJECT:\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nbreak;\ncase START_ARRAY:\n_parsingContext = _parsingContext.createChildArrayContext(-1, -1);\nbreak;\ncase END_OBJECT:\ncase END_ARRAY:\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nbreak;\ncase FIELD_NAME:\n_parsingContext.setCurrentName(_xmlTokens.getLocalName());\nbreak;\ndefault: // VALUE_STRING, VALUE_NULL\n// should be fine as is?\n}\nreturn t;\n}\nint token = _xmlTokens.next();\n\n// Need to have a loop just because we may have to eat/convert\n// a start-element that indicates an array element.\nwhile (token == XmlTokenStream.XML_START_ELEMENT) {\n// If we thought we might get leaf, no such luck\nif (_mayBeLeaf) {\n// leave _mayBeLeaf set, as we start a new context\n_nextToken = JsonToken.FIELD_NAME;\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\nif (_parsingContext.inArray()) {\n// Yup: in array, so this element could be verified; but it won't be\n// reported anyway, and we need to process following event.\ntoken = _xmlTokens.next();\n_mayBeLeaf = true;\ncontinue;\n}\nString name = _xmlTokens.getLocalName();\n_parsingContext.setCurrentName(name);\n\n// Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n// Couple of ways to do it; but start by making _xmlTokens replay the thing...\nif (_namesToWrap != null && _namesToWrap.contains(name)) {\n_xmlTokens.repeatStartElement();\n}\n\n_mayBeLeaf = true;\n// Ok: in array context we need to skip reporting field names.\n// But what's the best way to find next token?\nreturn (_currToken = JsonToken.FIELD_NAME);\n}\n\n// Ok; beyond start element, what do we get?\nswitch (token) {\ncase XmlTokenStream.XML_END_ELEMENT:\n// Simple, except that if this is a leaf, need to suppress end:\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n//    expose as empty Object, not null\nreturn (_currToken = JsonToken.VALUE_NULL);\n}\n_currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nreturn _currToken;\n\ncase XmlTokenStream.XML_ATTRIBUTE_NAME:\n// If there was a chance of leaf node, no more...\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n_nextToken = JsonToken.FIELD_NAME;\n_currText = _xmlTokens.getText();\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\n_parsingContext.setCurrentName(_xmlTokens.getLocalName());\nreturn (_currToken = JsonToken.FIELD_NAME);\ncase XmlTokenStream.XML_ATTRIBUTE_VALUE:\n_currText = _xmlTokens.getText();\nreturn (_currToken = JsonToken.VALUE_STRING);\ncase XmlTokenStream.XML_TEXT:\n_currText = _xmlTokens.getText();\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n/* One more refinement (pronunced like \"hack\") is that if\n* we had an empty String (or all white space), and we are\n* deserializing an array, we better hide the empty text.\n*/\n// Also: must skip following END_ELEMENT\n_xmlTokens.skipEndElement();\nif (_parsingContext.inArray()) {\nif (_isEmpty(_currText)) {\n// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n//    expose as empty Object, not null (or, worse, as used to\n//    be done, by swallowing the token)\n_currToken = JsonToken.END_ARRAY;\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nreturn _currToken;\n}\n}\nreturn (_currToken = JsonToken.VALUE_STRING);\n} else {\n// [dataformat-xml#177]: empty text may also need to be skipped\nif (_parsingContext.inObject()\n&& (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n_currToken = JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nreturn _currToken;\n}\n}\n// If not a leaf (or otherwise ignorable), need to transform into property...\n_parsingContext.setCurrentName(_cfgNameForTextElement);\n_nextToken = JsonToken.VALUE_STRING;\nreturn (_currToken = JsonToken.FIELD_NAME);\ncase XmlTokenStream.XML_END:\nreturn (_currToken = null);\n}\n\n// should never get here\n_throwInternal();\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.AnnotationUtil:findIsAttributeAnnotation(Lcom/fasterxml/jackson/databind/AnnotationIntrospector;Lcom/fasterxml/jackson/databind/introspect/AnnotatedMember;)Ljava/lang/Boolean;",
                                    "method_body": "public static Boolean findIsAttributeAnnotation(AnnotationIntrospector ai,\nAnnotatedMember prop)\n{\nfor (AnnotationIntrospector intr : ai.allIntrospectors()) {\nif (intr instanceof XmlAnnotationIntrospector) {\nBoolean b = ((XmlAnnotationIntrospector) intr).isOutputAsAttribute(prop);\nif (b != null) {\nreturn b;\n}\n} else  if (intr instanceof JaxbAnnotationIntrospector) {\nBoolean b = ((JaxbAnnotationIntrospector) intr).isOutputAsAttribute(prop);\nif (b != null) {\nreturn b;\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.AnnotationUtil:findIsTextAnnotation(Lcom/fasterxml/jackson/databind/AnnotationIntrospector;Lcom/fasterxml/jackson/databind/introspect/AnnotatedMember;)Ljava/lang/Boolean;",
                                    "method_body": "public static Boolean findIsTextAnnotation(AnnotationIntrospector ai,\nAnnotatedMember prop)\n{\nfor (AnnotationIntrospector intr : ai.allIntrospectors()) {\nif (intr instanceof XmlAnnotationIntrospector) {\nBoolean b = ((XmlAnnotationIntrospector) intr).isOutputAsText(prop);\nif (b != null) {\nreturn b;\n}\n} else  if (intr instanceof JaxbAnnotationIntrospector) {\nBoolean b = ((JaxbAnnotationIntrospector) intr).isOutputAsText(prop);\nif (b != null) {\nreturn b;\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.WrapperHandlingDeserializer:<init>(Lcom/fasterxml/jackson/databind/deser/BeanDeserializerBase;)V",
                                    "method_body": "public WrapperHandlingDeserializer(BeanDeserializerBase delegate) {\nthis(delegate, null);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.WrapperHandlingDeserializer:<init>(Lcom/fasterxml/jackson/databind/deser/BeanDeserializerBase;Ljava/util/Set;)V",
                                    "method_body": "public WrapperHandlingDeserializer(BeanDeserializerBase delegate, Set<String> namesToWrap)\n{\nsuper(delegate);\n_namesToWrap = namesToWrap;\n_type = delegate.getValueType();\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.WrapperHandlingDeserializer:createContextual(Lcom/fasterxml/jackson/databind/DeserializationContext;Lcom/fasterxml/jackson/databind/BeanProperty;)Lcom/fasterxml/jackson/databind/JsonDeserializer;",
                                    "method_body": "public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\nBeanProperty property)\nthrows JsonMappingException\n{\n// !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n//    out for 2.5 just to increase compatibility slightly with 2.4 databind\n/*\nJavaType vt = _type;\nif (vt == null) {\nvt = ctxt.constructType(_delegatee.handledType());\n}\nJsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n*/\n\nJsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\nBeanDeserializerBase newDelegatee = _verifyDeserType(del);\n\n// Let's go through the properties now...\nIterator<SettableBeanProperty> it = newDelegatee.properties();\nHashSet<String> unwrappedNames = null;\nwhile (it.hasNext()) {\nSettableBeanProperty prop = it.next();\n/* First things first: only consider array/Collection types\n* (not perfect check, but simplest reasonable check)\n*/\nJavaType type = prop.getType();\nif (!TypeUtil.isIndexedType(type)) {\ncontinue;\n}\nPropertyName wrapperName = prop.getWrapperName();\n// skip anything with wrapper (should work as is)\nif (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\ncontinue;\n}\nif (unwrappedNames == null) {\nunwrappedNames = new HashSet<String>();\n}\n// not optimal; should be able to use PropertyName...\nunwrappedNames.add(prop.getName());\n}\n// Ok: if nothing to take care of, just return the delegatee...\nif (unwrappedNames == null) {\nreturn newDelegatee;\n}\n// Otherwise, create the thing that can deal with virtual wrapping\nreturn new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.WrapperHandlingDeserializer:deserialize(Lcom/fasterxml/jackson/core/JsonParser;Lcom/fasterxml/jackson/databind/DeserializationContext;)Ljava/lang/Object;",
                                    "method_body": "public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n{\n_configureParser(jp);\nreturn _delegatee.deserialize(jp,  ctxt);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.WrapperHandlingDeserializer:_configureParser(Lcom/fasterxml/jackson/core/JsonParser;)V",
                                    "method_body": "protected final void _configureParser(JsonParser jp) throws IOException\n{\n/* 19-Aug-2013, tatu: Although we should not usually get called with\n*   parser of other types, there are some cases where this may happen:\n*   specifically, during structural value conversions.\n*/\nif (jp instanceof FromXmlParser) {\n((FromXmlParser) jp).addVirtualWrapping(_namesToWrap);\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.WrapperHandlingDeserializer:_verifyDeserType(Lcom/fasterxml/jackson/databind/JsonDeserializer;)Lcom/fasterxml/jackson/databind/deser/BeanDeserializerBase;",
                                    "method_body": "protected BeanDeserializerBase _verifyDeserType(JsonDeserializer<?> deser)\n{\nif (!(deser instanceof BeanDeserializerBase)) {\nthrow new IllegalArgumentException(\"Can not change delegate to be of type \"\n+deser.getClass().getName());\n}\nreturn (BeanDeserializerBase) deser;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.TypeUtil:isIndexedType(Lcom/fasterxml/jackson/databind/JavaType;)Z",
                                    "method_body": "public static boolean isIndexedType(JavaType type)\n{\nif (type.isContainerType()) {\nClass<?> cls = type.getRawClass();\n// One special case; byte[] will be serialized as base64-encoded String, not real array, so:\n// (actually, ditto for char[]; thought to be a String)\nif (cls == byte[].class || cls == char[].class) {\nreturn false;\n}\n// issue#5: also, should not add wrapping for Maps\nif (Map.class.isAssignableFrom(cls)) {\nreturn false;\n}\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.ElementWrapper:<init>(Lcom/fasterxml/jackson/dataformat/xml/deser/ElementWrapper;Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "private ElementWrapper(ElementWrapper parent,\nString wrapperLocalName, String wrapperNamespace)\n{\n_parent = parent;\n_wrapperName = wrapperLocalName;\n_wrapperNamespace = (wrapperNamespace == null) ? \"\" : wrapperNamespace;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.ElementWrapper:matchingWrapper(Lcom/fasterxml/jackson/dataformat/xml/deser/ElementWrapper;Ljava/lang/String;Ljava/lang/String;)Lcom/fasterxml/jackson/dataformat/xml/deser/ElementWrapper;",
                                    "method_body": "public static ElementWrapper matchingWrapper(ElementWrapper parent,\nString wrapperLocalName, String wrapperNamespace)\n{\nreturn new ElementWrapper(parent, wrapperLocalName, wrapperNamespace);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.ElementWrapper:intermediateWrapper()Lcom/fasterxml/jackson/dataformat/xml/deser/ElementWrapper;",
                                    "method_body": "public ElementWrapper intermediateWrapper() {\nreturn new ElementWrapper(this, null, null);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.ElementWrapper:isMatching()Z",
                                    "method_body": "public boolean isMatching() { return _wrapperName != null; }\npublic boolean isMatching() { return _wrapperName != null; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.ElementWrapper:getWrapperLocalName()Ljava/lang/String;",
                                    "method_body": "public String getWrapperLocalName() { return _wrapperName; }\npublic String getWrapperLocalName() { return _wrapperName; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.ElementWrapper:getWrapperNamespace()Ljava/lang/String;",
                                    "method_body": "public String getWrapperNamespace() { return _wrapperNamespace; }\npublic String getWrapperNamespace() { return _wrapperNamespace; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.ElementWrapper:getParent()Lcom/fasterxml/jackson/dataformat/xml/deser/ElementWrapper;",
                                    "method_body": "public ElementWrapper getParent() { return _parent; }\npublic ElementWrapper getParent() { return _parent; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:setDefaultUseWrapper(Z)Lcom/fasterxml/jackson/dataformat/xml/XmlMapper;",
                                    "method_body": "public XmlMapper setDefaultUseWrapper(boolean state) {\n// ser and deser configs should usually have the same introspector, so:\nAnnotationIntrospector ai0 = getDeserializationConfig().getAnnotationIntrospector();\nfor (AnnotationIntrospector ai : ai0.allIntrospectors()) {\nif (ai instanceof XmlAnnotationIntrospector) {\n((XmlAnnotationIntrospector) ai).setDefaultUseWrapper(state);\n}\n}\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:setDefaultUseWrapper(Z)V",
                                    "method_body": "public void setDefaultUseWrapper(boolean b) {\n_cfgDefaultUseWrapper = b;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:_isEmpty(Ljava/lang/String;)Z",
                                    "method_body": "protected boolean _isEmpty(String str)\n{\nint len = (str == null) ? 0 : str.length();\nif (len > 0) {\nfor (int i = 0; i < len; ++i) {\nif (str.charAt(i) > ' ') {\nreturn false;\n}\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:skipEndElement()V",
                                    "method_body": "public void skipEndElement() throws IOException\n{\nint type = next();\nif (type != XML_END_ELEMENT) {\nthrow new IOException(\"Expected END_ELEMENT, got event of type \"+type);\n}\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "com.fasterxml.jackson.dataformat.xml.lists.NestedUnwrappedListsTest.testNestedWithEmpty2",
                            "test_body": "public void testNestedWithEmpty2() throws Exception\n{\nfinal String XML =\n\"<ServiceDelivery>\\n\"\n+\"  <ResponseTimestamp>2012-09-12T09:28:17.213-04:00</ResponseTimestamp>\\n\"\n+\"  <VehicleMonitoringDelivery>\\n\"\n+\"    <VehicleActivity>\\n\"\n+\"    </VehicleActivity>\\n\"\n+\"  </VehicleMonitoringDelivery>\\n\"\n+\"</ServiceDelivery>\\n\"\n;\nServiceDelivery svc = _xmlMapper.readValue(XML, ServiceDelivery.class);\nassertNotNull(svc);\nassertNotNull(svc.vehicleMonitoringDelivery);\nassertEquals(1, svc.vehicleMonitoringDelivery.size());\nVehicleMonitoringDelivery del = svc.vehicleMonitoringDelivery.get(0);\nassertNotNull(del.vehicleActivity);\n// 06-Jan-2015, tatu: Really should have one empty entry, not 0\nassertEquals(1, del.vehicleActivity.size());\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<init>()V",
                                    "method_body": "public XmlMapper() {\nthis(new XmlFactory());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<init>(Lcom/fasterxml/jackson/dataformat/xml/XmlFactory;)V",
                                    "method_body": "public XmlMapper(XmlFactory xmlFactory) {\nthis(xmlFactory, DEFAULT_XML_MODULE);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<init>(Lcom/fasterxml/jackson/dataformat/xml/XmlFactory;Lcom/fasterxml/jackson/dataformat/xml/JacksonXmlModule;)V",
                                    "method_body": "public XmlMapper(XmlFactory xmlFactory, JacksonXmlModule module)\n{\n/* Need to override serializer provider (due to root name handling);\n* deserializer provider fine as is\n*/\nsuper(xmlFactory, new XmlSerializerProvider(new XmlRootNameLookup()), null);\n_xmlModule = module;\n// but all the rest is done via Module interface!\nif (module != null) {\nregisterModule(module);\n}\n// 19-May-2015, tatu: Must ensure we use XML-specific indenter\n_serializationConfig = _serializationConfig.withDefaultPrettyPrinter(DEFAULT_XML_PRETTY_PRINTER);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\nprotected final static JacksonXmlModule DEFAULT_XML_MODULE = new JacksonXmlModule();\n\nprotected final static DefaultXmlPrettyPrinter DEFAULT_XML_PRETTY_PRINTER = new DefaultXmlPrettyPrinter();\n\n// need to hold on to module instance just in case copy() is used\nprotected final JacksonXmlModule _xmlModule;\n\n/*\n/**********************************************************\n/* Life-cycle: construction, configuration\n/**********************************************************\n*/\n\npublic XmlMapper() {\nthis(new XmlFactory());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlModule:<init>()V",
                                    "method_body": "public JacksonXmlModule()\n{\nsuper(\"JackxonXmlModule\", PackageVersion.VERSION);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlModule:setupModule(Lcom/fasterxml/jackson/databind/Module$SetupContext;)V",
                                    "method_body": "public void setupModule(SetupContext context)\n{\n// Need to modify BeanDeserializer, BeanSerializer that are used\ncontext.addBeanSerializerModifier(new XmlBeanSerializerModifier());\ncontext.addBeanDeserializerModifier(new XmlBeanDeserializerModifier(_cfgNameForTextElement));\n\n// as well as AnnotationIntrospector\ncontext.insertAnnotationIntrospector(_constructIntrospector());\n\n// and finally inform XmlFactory about overrides, if need be:\nif (_cfgNameForTextElement != FromXmlParser.DEFAULT_UNNAMED_TEXT_PROPERTY) {\nXmlMapper m = (XmlMapper) context.getOwner();\nm.setXMLTextElementName(_cfgNameForTextElement);\n}\n\n/* Usually this would be the first call; but here anything added will\n* be stuff user may has added, so do it afterwards instead.\n*/\nsuper.setupModule(context);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlModule:_constructIntrospector()Lcom/fasterxml/jackson/databind/AnnotationIntrospector;",
                                    "method_body": "protected AnnotationIntrospector _constructIntrospector() {\nreturn new JacksonXmlAnnotationIntrospector(_cfgDefaultUseWrapper);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.PackageVersion:<clinit>()V",
                                    "method_body": "public final static Version VERSION = VersionUtil.parseVersion(\n\"2.7.0-rc4-SNAPSHOT\", \"com.fasterxml.jackson.dataformat\", \"jackson-dataformat-xml\");\n\n@Override\npublic Version version() {\nreturn VERSION;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter:<init>()V",
                                    "method_body": "public void writeIndentation(JsonGenerator g, int level) throws IOException;\n\npublic void writeIndentation(XMLStreamWriter2 sw, int level) throws XMLStreamException;\n\n/**\n* @return True if indenter is considered inline (does not add linefeeds),\n*   false otherwise\n*/\npublic boolean isInline();\n}\n\n/*\n/**********************************************************\n/* Configuration\n/**********************************************************\n*/\n\n/**\n* By default, let's use only spaces to separate array values.\n*/\nprotected Indenter _arrayIndenter = new FixedSpaceIndenter();\n\n/**\n* By default, let's use linefeed-adding indenter for separate\n* object entries. We'll further configure indenter to use\n* system-specific linefeeds, and 2 spaces per level (as opposed to,\n* say, single tabs)\n*/\nprotected Indenter _objectIndenter = new Lf2SpacesIndenter();\n\n// // // Config, other white space configuration\n\n/**\n* By default we will add spaces around colons used to\n* separate object fields and values.\n* If disabled, will not use spaces around colon.\n*/\nprotected boolean _spacesInObjectEntries = true;\n\n/*\n/**********************************************************\n/* State\n/**********************************************************\n*/\n\n/**\n* Number of open levels of nesting. Used to determine amount of\n* indentation to use.\n*/\nprotected transient int _nesting = 0;\n\n/**\n* Marker flag set on start element, and cleared if an end element\n* is encountered. Used for suppressing indentation to allow empty\n* elements.\n*\n* @since 2.3.0\n*/\nprotected transient boolean _justHadStartElement;\n\n/*\n/**********************************************************\n/* Life-cycle (construct, configure)\n/**********************************************************\n*/\n\npublic DefaultXmlPrettyPrinter() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter$FixedSpaceIndenter:<init>()V",
                                    "method_body": "public FixedSpaceIndenter() { }\npublic FixedSpaceIndenter() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter$Lf2SpacesIndenter:<init>()V",
                                    "method_body": "public Lf2SpacesIndenter() { }\npublic Lf2SpacesIndenter() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter$Lf2SpacesIndenter:<clinit>()V",
                                    "method_body": "final static int SPACE_COUNT = 64;\nfinal static char[] SPACES = new char[SPACE_COUNT];\nstatic {\nArrays.fill(SPACES, ' ');\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>()V",
                                    "method_body": "public XmlFactory() { this(null, null, null); }\npublic XmlFactory() { this(null, null, null); }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>(Lcom/fasterxml/jackson/core/ObjectCodec;Ljavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;)V",
                                    "method_body": "public XmlFactory(ObjectCodec oc, XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n{\nthis(oc, DEFAULT_XML_PARSER_FEATURE_FLAGS, DEFAULT_XML_GENERATOR_FEATURE_FLAGS,\nxmlIn, xmlOut, null);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>(Lcom/fasterxml/jackson/core/ObjectCodec;IILjavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;Ljava/lang/String;)V",
                                    "method_body": "protected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\nXMLInputFactory xmlIn, XMLOutputFactory xmlOut,\nString nameForTextElem)\n{\nsuper(oc);\n_xmlParserFeatures = xpFeatures;\n_xmlGeneratorFeatures = xgFeatures;\n_cfgNameForTextElement = nameForTextElem;\nif (xmlIn == null) {\nxmlIn = XMLInputFactory.newInstance();\n}\nif (xmlOut == null) {\nxmlOut = XMLOutputFactory.newInstance();\n}\n_initFactories(xmlIn, xmlOut);\n_xmlInputFactory = xmlIn;\n_xmlOutputFactory = xmlOut;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<clinit>()V",
                                    "method_body": "public final static String FORMAT_NAME_XML = \"XML\";\n\n/**\n* Bitfield (set of flags) of all parser features that are enabled\n* by default.\n*/\nfinal static int DEFAULT_XML_PARSER_FEATURE_FLAGS = FromXmlParser.Feature.collectDefaults();\n\n/**\n* Bitfield (set of flags) of all generator features that are enabled\n* by default.\n*/\nfinal static int DEFAULT_XML_GENERATOR_FEATURE_FLAGS = ToXmlGenerator.Feature.collectDefaults();\n\n/*\n/**********************************************************\n/* Configuration\n/**********************************************************\n*/\n\nprotected int _xmlParserFeatures;\n\nprotected int _xmlGeneratorFeatures;\n\n// non-final for setters (why are they needed again?)\nprotected transient XMLInputFactory _xmlInputFactory;\n\nprotected transient XMLOutputFactory _xmlOutputFactory;\n\nprotected String _cfgNameForTextElement;\n\n/*\n/**********************************************************\n/* Factory construction, configuration\n/**********************************************************\n*/\n\n/**\n* Default constructor used to create factory instances.\n* Creation of a factory instance is a light-weight operation,\n* but it is still a good idea to reuse limited number of\n* factory instances (and quite often just a single instance):\n* factories are used as context for storing some reused\n* processing objects (such as symbol tables parsers use)\n* and this reuse only works within context of a single\n* factory instance.\n*/\npublic XmlFactory() { this(null, null, null); }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_initFactories(Ljavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;)V",
                                    "method_body": "protected void _initFactories(XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n{\n// Better ensure namespaces get built properly, so:\nxmlOut.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\n// and for parser, force coalescing as well (much simpler to use)\nxmlIn.setProperty(XMLInputFactory.IS_COALESCING, Boolean.TRUE);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:createParser(Ljava/lang/String;)Lcom/fasterxml/jackson/core/JsonParser;",
                                    "method_body": "public JsonParser createParser(String content) throws IOException {\nReader r = new StringReader(content);\nIOContext ctxt = _createContext(r, true);\nif (_inputDecorator != null) {\nr = _inputDecorator.decorate(ctxt, r);\n}\nreturn _createParser(r, ctxt);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_createParser(Ljava/io/Reader;Lcom/fasterxml/jackson/core/io/IOContext;)Lcom/fasterxml/jackson/dataformat/xml/deser/FromXmlParser;",
                                    "method_body": "protected FromXmlParser _createParser(Reader r, IOContext ctxt) throws IOException\n{\nXMLStreamReader sr;\ntry {\nsr = _xmlInputFactory.createXMLStreamReader(r);\nsr = _initializeXmlReader(sr);\n} catch (XMLStreamException e) {\nreturn StaxUtil.throwXmlAsIOException(e);\n}\nFromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n_objectCodec, sr);\nif (_cfgNameForTextElement != null) {\nxp.setXMLTextElementName(_cfgNameForTextElement);\n}\nreturn xp;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_initializeXmlReader(Ljavax/xml/stream/XMLStreamReader;)Ljavax/xml/stream/XMLStreamReader;",
                                    "method_body": "protected final XMLStreamReader _initializeXmlReader(XMLStreamReader sr) throws IOException, XMLStreamException\n{\n// for now, nothing to do... except let's find the root element\nwhile (sr.next() != XMLStreamConstants.START_ELEMENT) {\n;\n}\nreturn sr;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature:<clinit>()V",
                                    "method_body": "public final static String DEFAULT_UNNAMED_TEXT_PROPERTY = \"\";\n\n/**\n* Enumeration that defines all togglable features for XML parsers.\n* None defined so far (2.6), so just a placeholder.\n*/\npublic enum Feature implements FormatFeature\n{\n;\n\nfinal boolean _defaultState;\nfinal int _mask;\n\n/**\n* Method that calculates bit set (flags) of all features that\n* are enabled by default.\n*/\npublic static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}\n\nprivate Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}\n\n@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public int getMask() { return _mask; }\n@Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature:collectDefaults()I",
                                    "method_body": "public static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:<init>(Ljava/lang/String;IZ)V",
                                    "method_body": "private Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:<clinit>()V",
                                    "method_body": "protected final static String DEFAULT_UNKNOWN_ELEMENT = \"unknown\";\n\n/**\n* Enumeration that defines all togglable extra XML-specific features\n*/\npublic enum Feature implements FormatFeature\n{\n/**\n* Feature that controls whether XML declaration should be written before\n* when generator is initialized (true) or not (false)\n*/\nWRITE_XML_DECLARATION(false),\n\n/**\n* Feature that controls whether output should be done as XML 1.1; if so,\n* certain aspects may differ from default (1.0) processing: for example,\n* XML declaration will be automatically added (regardless of setting\n* <code>WRITE_XML_DECLARATION</code>) as this is required for reader to\n* know to use 1.1 compliant handling. XML 1.1 can be used to allow quoted\n* control characters (Ascii codes 0 through 31) as well as additional linefeeds\n* and name characters.\n*/\nWRITE_XML_1_1(false)\n;\n\nfinal boolean _defaultState;\nfinal int _mask;\n\n/**\n* Method that calculates bit set (flags) of all features that\n* are enabled by default.\n*/\npublic static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}\n\nprivate Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}\n\n@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public int getMask() { return _mask; }\n@Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:collectDefaults()I",
                                    "method_body": "public static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:enabledByDefault()Z",
                                    "method_body": "@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public boolean enabledByDefault() { return _defaultState; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:<init>(Lcom/fasterxml/jackson/dataformat/xml/util/XmlRootNameLookup;)V",
                                    "method_body": "public XmlSerializerProvider(XmlRootNameLookup rootNames)\n{\nsuper();\n_rootNameLookup = rootNames;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\n/**\n* If all we get to serialize is a null, there's no way to figure out\n* expected root name; so let's just default to something like \"&lt;null>\"...\n*/\nprotected final static QName ROOT_NAME_FOR_NULL = new QName(\"null\");\n\nprotected final XmlRootNameLookup _rootNameLookup;\n\npublic XmlSerializerProvider(XmlRootNameLookup rootNames)\n{\nsuper();\n_rootNameLookup = rootNames;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.XmlRootNameLookup:<init>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\n/**\n* For efficient operation, let's try to minimize number of times we\n* need to introspect root element name to use.\n*<p>\n* Note: changed to <code>transient</code> for 2.3; no point in serializing such\n* state\n*/\nprotected final transient LRUMap<ClassKey,QName> _rootNames = new LRUMap<ClassKey,QName>(40, 200);\n\npublic XmlRootNameLookup() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerModifier:<init>()V",
                                    "method_body": "public XmlBeanSerializerModifier() { }\npublic XmlBeanSerializerModifier() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlBeanDeserializerModifier:<init>(Ljava/lang/String;)V",
                                    "method_body": "public XmlBeanDeserializerModifier(String nameForTextValue)\n{\n_cfgNameForTextValue = nameForTextValue;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlBeanDeserializerModifier:updateProperties(Lcom/fasterxml/jackson/databind/DeserializationConfig;Lcom/fasterxml/jackson/databind/BeanDescription;Ljava/util/List;)Ljava/util/List;",
                                    "method_body": "public List<BeanPropertyDefinition> updateProperties(DeserializationConfig config,\nBeanDescription beanDesc, List<BeanPropertyDefinition> propDefs)\n{\nfinal AnnotationIntrospector intr = config.getAnnotationIntrospector();\nint changed = 0;\n\nfor (int i = 0, propCount = propDefs.size(); i < propCount; ++i) {\nBeanPropertyDefinition prop = propDefs.get(i);\nAnnotatedMember acc = prop.getPrimaryMember();\n// should not be null, but just in case:\nif (acc == null) {\ncontinue;\n}\n/* First: handle \"as text\"? Such properties\n* are exposed as values of 'unnamed' fields; so one way to\n* map them is to rename property to have name \"\"... (and\n* hope this does not break other parts...)\n*/\nBoolean b = AnnotationUtil.findIsTextAnnotation(intr, acc);\nif (b != null && b.booleanValue()) {\n// unwrapped properties will appear as 'unnamed' (empty String)\nBeanPropertyDefinition newProp = prop.withSimpleName(_cfgNameForTextValue);\nif (newProp != prop) {\npropDefs.set(i, newProp);\n}\ncontinue;\n}\n// second: do we need to handle wrapping (for Lists)?\nPropertyName wrapperName = prop.getWrapperName();\n\nif (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\nString localName = wrapperName.getSimpleName();\nif ((localName != null && localName.length() > 0)\n&& !localName.equals(prop.getName())) {\n// make copy-on-write as necessary\nif (changed == 0) {\npropDefs = new ArrayList<BeanPropertyDefinition>(propDefs);\n}\n++changed;\npropDefs.set(i, prop.withSimpleName(localName));\ncontinue;\n}\n// otherwise unwrapped; needs handling but later on\n}\n}\nreturn propDefs;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlBeanDeserializerModifier:modifyDeserializer(Lcom/fasterxml/jackson/databind/DeserializationConfig;Lcom/fasterxml/jackson/databind/BeanDescription;Lcom/fasterxml/jackson/databind/JsonDeserializer;)Lcom/fasterxml/jackson/databind/JsonDeserializer;",
                                    "method_body": "public JsonDeserializer<?> modifyDeserializer(DeserializationConfig config,\nBeanDescription beanDesc, JsonDeserializer<?> deser0)\n{\nif (!(deser0 instanceof BeanDeserializerBase)) {\nreturn deser0;\n}\n/* 17-Aug-2013, tatu: One important special case first: if we have one \"XML Text\"\n* property, it may be exposed as VALUE_STRING token (depending on whether any attribute\n* values are exposed): and to deserialize from that, we need special handling unless POJO\n* has appropriate single-string creator method.\n*/\nBeanDeserializerBase deser = (BeanDeserializerBase) deser0;\n\n// Heuristics are bit tricky; but for now let's assume that if POJO\n// can already work with VALUE_STRING, it's ok and doesn't need extra support\nif (!deser.getValueInstantiator().canCreateFromString()) {\nSettableBeanProperty textProp = _findSoleTextProp(config, deser.properties());\nif (textProp != null) {\nreturn new XmlTextDeserializer(deser, textProp);\n}\n}\nreturn new WrapperHandlingDeserializer(deser);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlBeanDeserializerModifier:_findSoleTextProp(Lcom/fasterxml/jackson/databind/DeserializationConfig;Ljava/util/Iterator;)Lcom/fasterxml/jackson/databind/deser/SettableBeanProperty;",
                                    "method_body": "private SettableBeanProperty _findSoleTextProp(DeserializationConfig config,\nIterator<SettableBeanProperty> propIt)\n{\nfinal AnnotationIntrospector ai = config.getAnnotationIntrospector();\nSettableBeanProperty textProp = null;\nwhile (propIt.hasNext()) {\nSettableBeanProperty prop = propIt.next();\nAnnotatedMember m = prop.getMember();\nif (m != null) {\n// Ok, let's use a simple check: we should have renamed it earlier so:\nPropertyName n = prop.getFullName();\nif (_cfgNameForTextValue.equals(n.getSimpleName())) {\n// should we verify we only got one?\ntextProp = prop;\ncontinue;\n}\n// as-attribute are ok as well\nBoolean b = AnnotationUtil.findIsAttributeAnnotation(ai, m);\nif (b != null && b.booleanValue()) {\ncontinue;\n}\n}\n// Otherwise, it's something else; no go\nreturn null;\n}\nreturn textProp;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:<init>(Z)V",
                                    "method_body": "public JacksonXmlAnnotationIntrospector(boolean defaultUseWrapper) {\n_cfgDefaultUseWrapper = defaultUseWrapper;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:findWrapperName(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Lcom/fasterxml/jackson/databind/PropertyName;",
                                    "method_body": "public PropertyName findWrapperName(Annotated ann)\n{\nJacksonXmlElementWrapper w = ann.getAnnotation(JacksonXmlElementWrapper.class);\nif (w != null) {\n// Special case: wrapping explicitly blocked?\nif (!w.useWrapping()) {\nreturn PropertyName.NO_NAME;\n}\n// also: need to ensure we use marker:\nString localName = w.localName();\nif (localName == null || localName.length() == 0) {\nreturn PropertyName.USE_DEFAULT;\n}\nreturn PropertyName.construct(w.localName(), w.namespace());\n}\n/* 09-Sep-2012, tatu: In absence of configurating we need to use our\n*   default settings...\n*/\nif (_cfgDefaultUseWrapper) {\nreturn PropertyName.USE_DEFAULT;\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:isOutputAsAttribute(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Ljava/lang/Boolean;",
                                    "method_body": "public Boolean isOutputAsAttribute(Annotated ann)\n{\nJacksonXmlProperty prop = ann.getAnnotation(JacksonXmlProperty.class);\nif (prop != null) {\nreturn prop.isAttribute() ? Boolean.TRUE : Boolean.FALSE;\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:isOutputAsText(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Ljava/lang/Boolean;",
                                    "method_body": "public Boolean isOutputAsText(Annotated ann)\n{\nJacksonXmlText prop = ann.getAnnotation(JacksonXmlText.class);\nif (prop != null) {\nreturn prop.value() ? Boolean.TRUE : Boolean.FALSE;\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:findNameForDeserialization(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Lcom/fasterxml/jackson/databind/PropertyName;",
                                    "method_body": "public PropertyName findNameForDeserialization(Annotated a)\n{\nPropertyName name = _findXmlName(a);\nif (name == null) {\nname = super.findNameForDeserialization(a);\nif (name == null) {\nif (a.hasAnnotation(JacksonXmlText.class)) {\nreturn PropertyName.USE_DEFAULT;\n}\n}\n}\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:_findXmlName(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Lcom/fasterxml/jackson/databind/PropertyName;",
                                    "method_body": "protected PropertyName _findXmlName(Annotated a)\n{\nJacksonXmlProperty pann = a.getAnnotation(JacksonXmlProperty.class);\nif (pann != null) {\nreturn PropertyName.construct(pann.localName(), pann.namespace());\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:<init>(Lcom/fasterxml/jackson/core/io/IOContext;IILcom/fasterxml/jackson/core/ObjectCodec;Ljavax/xml/stream/XMLStreamReader;)V",
                                    "method_body": "public FromXmlParser(IOContext ctxt, int genericParserFeatures, int xmlFeatures,\nObjectCodec codec, XMLStreamReader xmlReader)\n{\nsuper(genericParserFeatures);\n_formatFeatures = xmlFeatures;\n_ioContext = ctxt;\n_objectCodec = codec;\n_parsingContext = XmlReadContext.createRootContext(-1, -1);\n// and thereby start a scope\n_nextToken = JsonToken.START_OBJECT;\n_xmlTokens = new XmlTokenStream(xmlReader, ctxt.getSourceReference());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:addVirtualWrapping(Ljava/util/Set;)V",
                                    "method_body": "public void addVirtualWrapping(Set<String> namesToWrap)\n{\n/* 17-Sep-2012, tatu: Not 100% sure why, but this is necessary to avoid\n*   problems with Lists-in-Lists properties\n*/\nString name = _xmlTokens.getLocalName();\nif (name != null && namesToWrap.contains(name)) {\n_xmlTokens.repeatStartElement();\n}\n_namesToWrap = namesToWrap;\n_parsingContext.setNamesToWrap(namesToWrap);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:getCurrentName()Ljava/lang/String;",
                                    "method_body": "public String getCurrentName() throws IOException\n{\n// start markers require information from parent\nString name;\nif (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\nXmlReadContext parent = _parsingContext.getParent();\nname = parent.getCurrentName();\n} else {\nname = _parsingContext.getCurrentName();\n}\n// sanity check\nif (name == null) {\nthrow new IllegalStateException(\"Missing name, in state: \"+_currToken);\n}\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:close()V",
                                    "method_body": "public void close() throws IOException\n{\nif (!_closed) {\n_closed = true;\ntry {\nif (_ioContext.isResourceManaged() || isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)) {\n_xmlTokens.closeCompletely();\n} else {\n_xmlTokens.close();\n}\n} finally {\n// as per [JACKSON-324], do in finally block\n// Also, internal buffer(s) can now be released as well\n_releaseBuffers();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:getParsingContext()Lcom/fasterxml/jackson/dataformat/xml/deser/XmlReadContext;",
                                    "method_body": "public XmlReadContext getParsingContext() {\nreturn _parsingContext;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:isExpectedStartArrayToken()Z",
                                    "method_body": "public boolean isExpectedStartArrayToken()\n{\nJsonToken t = _currToken;\nif (t == JsonToken.START_OBJECT) {\n_currToken = JsonToken.START_ARRAY;\n// Ok: must replace current context with array as well\n_parsingContext.convertToArray();\n//System.out.println(\" isExpectedArrayStart: OBJ->Array, wraps now: \"+_parsingContext.getNamesToWrap());\n// And just in case a field name was to be returned, wipe it\n_nextToken = null;\n// and last thing, [dataformat-xml#33], better ignore attributes\n_xmlTokens.skipAttributes();\nreturn true;\n}\n//System.out.println(\" isExpectedArrayStart?: t=\"+t);\nreturn (t == JsonToken.START_ARRAY);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:getText()Ljava/lang/String;",
                                    "method_body": "public String getText() throws IOException\n{\nif (_currToken == null) {\nreturn null;\n}\nswitch (_currToken) {\ncase FIELD_NAME:\nreturn getCurrentName();\ncase VALUE_STRING:\nreturn _currText;\ndefault:\nreturn _currToken.asString();\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:_releaseBuffers()V",
                                    "method_body": "protected void _releaseBuffers() throws IOException {\n// anything we can/must release? Underlying parser should do all of it, for now?\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:<init>(Lcom/fasterxml/jackson/dataformat/xml/deser/XmlReadContext;III)V",
                                    "method_body": "public XmlReadContext(XmlReadContext parent, int type, int lineNr, int colNr)\n{\nsuper();\n_type = type;\n_parent = parent;\n_lineNr = lineNr;\n_columnNr = colNr;\n_index = -1;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:createRootContext(II)Lcom/fasterxml/jackson/dataformat/xml/deser/XmlReadContext;",
                                    "method_body": "public static XmlReadContext createRootContext(int lineNr, int colNr) {\nreturn new XmlReadContext(null, TYPE_ROOT, lineNr, colNr);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:createChildObjectContext(II)Lcom/fasterxml/jackson/dataformat/xml/deser/XmlReadContext;",
                                    "method_body": "public final XmlReadContext createChildObjectContext(int lineNr, int colNr)\n{\nXmlReadContext ctxt = _child;\nif (ctxt == null) {\n_child = ctxt = new XmlReadContext(this, TYPE_OBJECT, lineNr, colNr);\nreturn ctxt;\n}\nctxt.reset(TYPE_OBJECT, lineNr, colNr);\nreturn ctxt;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:getCurrentName()Ljava/lang/String;",
                                    "method_body": "public final String getCurrentName() { return _currentName; }\npublic final String getCurrentName() { return _currentName; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:getParent()Lcom/fasterxml/jackson/dataformat/xml/deser/XmlReadContext;",
                                    "method_body": "public final XmlReadContext getParent() { return _parent; }\npublic final XmlReadContext getParent() { return _parent; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:setCurrentName(Ljava/lang/String;)V",
                                    "method_body": "public void setCurrentName(String name) {\n_currentName = name;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:setNamesToWrap(Ljava/util/Set;)V",
                                    "method_body": "public void setNamesToWrap(Set<String> namesToWrap) {\n_namesToWrap = namesToWrap;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:getNamesToWrap()Ljava/util/Set;",
                                    "method_body": "public Set<String> getNamesToWrap() {\nreturn _namesToWrap;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:convertToArray()V",
                                    "method_body": "protected void convertToArray() {\n_type = TYPE_ARRAY;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:<init>(Ljavax/xml/stream/XMLStreamReader;Ljava/lang/Object;)V",
                                    "method_body": "public XmlTokenStream(XMLStreamReader xmlReader, Object sourceRef)\n{\n_sourceReference = sourceRef;\n// Let's ensure we point to START_ELEMENT...\nif (xmlReader.getEventType() != XMLStreamConstants.START_ELEMENT) {\nthrow new IllegalArgumentException(\"Invalid XMLStreamReader passed: should be pointing to START_ELEMENT (\"\n+XMLStreamConstants.START_ELEMENT+\"), instead got \"+xmlReader.getEventType());\n}\n_xmlReader = Stax2ReaderAdapter.wrapIfNecessary(xmlReader);\n_currentState = XML_START_ELEMENT;\n_localName = _xmlReader.getLocalName();\n_namespaceURI = _xmlReader.getNamespaceURI();\n_attributeCount = _xmlReader.getAttributeCount();\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:next()I",
                                    "method_body": "public int next() throws IOException\n{\nif (_repeatElement != 0) {\nreturn (_currentState = _handleRepeatElement());\n}\ntry {\nreturn _next();\n} catch (XMLStreamException e) {\nStaxUtil.throwXmlAsIOException(e);\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:getText()Ljava/lang/String;",
                                    "method_body": "public String getText() { return _textValue; }\npublic String getText() { return _textValue; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:getLocalName()Ljava/lang/String;",
                                    "method_body": "public String getLocalName() { return _localName; }\npublic String getLocalName() { return _localName; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:closeCompletely()V",
                                    "method_body": "public void closeCompletely() throws IOException\n{\ntry {\n_xmlReader.closeCompletely();\n} catch (XMLStreamException e) {\nStaxUtil.throwXmlAsIOException(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:repeatStartElement()V",
                                    "method_body": "protected void repeatStartElement()\n{\n//System.out.println(\" -> repeatStartElement for \"+_localName);\n// sanity check: can only be used when just returned START_ELEMENT:\nif (_currentState != XML_START_ELEMENT) {\nthrow new IllegalStateException(\"Current state not XML_START_ELEMENT (\"\n+XML_START_ELEMENT+\") but \"+_currentState);\n}\n// Important: add wrapper, to keep track...\nif (_currentWrapper == null) {\n_currentWrapper = ElementWrapper.matchingWrapper(_currentWrapper, _localName, _namespaceURI);\n} else {\n_currentWrapper = ElementWrapper.matchingWrapper(_currentWrapper.getParent(), _localName, _namespaceURI);\n}\n_repeatElement = REPLAY_START_DUP;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:skipAttributes()V",
                                    "method_body": "protected void skipAttributes()\n{\nif (_currentState == XML_ATTRIBUTE_NAME) {\n_attributeCount = 0;\n_currentState = XML_START_ELEMENT;\n} else if (_currentState == XML_START_ELEMENT) {\n/* 06-Jan-2012, tatu: As per [#47] it looks like we should NOT do anything\n*   in this particular case, because it occurs when original element had\n*   no attributes and we now point to the first child element.\n*/\n//              _attributeCount = 0;\n} else if (_currentState == XML_TEXT) {\n; // nothing to do... is it even legal?\n} else {\nthrow new IllegalStateException(\"Current state not XML_START_ELEMENT or XML_ATTRIBUTE_NAME (\"\n+XML_START_ELEMENT+\") but \"+_currentState);\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:_next()I",
                                    "method_body": "private final int _next() throws XMLStreamException\n{\nswitch (_currentState) {\ncase XML_ATTRIBUTE_VALUE:\n++_nextAttributeIndex;\n// fall through\ncase XML_START_ELEMENT: // attributes to return?\nif (_nextAttributeIndex < _attributeCount) {\n_localName = _xmlReader.getAttributeLocalName(_nextAttributeIndex);\n_namespaceURI = _xmlReader.getAttributeNamespace(_nextAttributeIndex);\n_textValue = _xmlReader.getAttributeValue(_nextAttributeIndex);\nreturn (_currentState = XML_ATTRIBUTE_NAME);\n}\n// otherwise need to find START/END_ELEMENT or text\nString text = _collectUntilTag();\n// If it's START_ELEMENT, ignore any text\nif (_xmlReader.getEventType() == XMLStreamReader.START_ELEMENT) {\nreturn _initStartElement();\n}\n// For END_ELEMENT we will return text, if any\nif (text != null) {\n_textValue = text;\nreturn (_currentState = XML_TEXT);\n}\nreturn _handleEndElement();\ncase XML_ATTRIBUTE_NAME:\n// if we just returned name, will need to just send value next\nreturn (_currentState = XML_ATTRIBUTE_VALUE);\ncase XML_TEXT:\n// text is always followed by END_ELEMENT\nreturn _handleEndElement();\ncase XML_END:\nreturn XML_END;\n//            throw new IllegalStateException(\"No more XML tokens available (end of input)\");\n}\n\n// Ok: must be END_ELEMENT; see what tag we get (or end)\nswitch (_skipUntilTag()) {\ncase XMLStreamConstants.END_DOCUMENT:\nreturn (_currentState = XML_END);\ncase XMLStreamConstants.END_ELEMENT:\nreturn _handleEndElement();\n}\n// START_ELEMENT...\nreturn _initStartElement();\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:_collectUntilTag()Ljava/lang/String;",
                                    "method_body": "private final String _collectUntilTag() throws XMLStreamException\n{\nString text = null;\nwhile (true) {\nswitch (_xmlReader.next()) {\ncase XMLStreamConstants.START_ELEMENT:\ncase XMLStreamConstants.END_ELEMENT:\ncase XMLStreamConstants.END_DOCUMENT:\nreturn text;\n// note: SPACE is ignorable (and seldom seen), not to be included\ncase XMLStreamConstants.CHARACTERS:\ncase XMLStreamConstants.CDATA:\nif (text == null) {\ntext = _xmlReader.getText();\n} else { // can be optimized in future, if need be:\ntext += _xmlReader.getText();\n}\nbreak;\ndefault:\n// any other type (proc instr, comment etc) is just ignored\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:_skipUntilTag()I",
                                    "method_body": "private final int _skipUntilTag() throws XMLStreamException\n{\nwhile (_xmlReader.hasNext()) {\nint type;\nswitch (type = _xmlReader.next()) {\ncase XMLStreamConstants.START_ELEMENT:\ncase XMLStreamConstants.END_ELEMENT:\ncase XMLStreamConstants.END_DOCUMENT:\nreturn type;\ndefault:\n// any other type (proc instr, comment etc) is just ignored\n}\n}\nthrow new IllegalStateException(\"Expected to find a tag, instead reached end of input\");\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:_initStartElement()I",
                                    "method_body": "private final int _initStartElement() throws XMLStreamException\n{\nfinal String ns = _xmlReader.getNamespaceURI();\nfinal String localName = _xmlReader.getLocalName();\n_attributeCount = _xmlReader.getAttributeCount();\n_nextAttributeIndex = 0;\n\n/* Support for virtual wrapping: in wrapping, may either\n* create a new wrapper scope (if in sub-tree, or matches\n* wrapper element itself), or implicitly close existing\n* scope.\n*/\nif (_currentWrapper != null) {\nif (_currentWrapper.matchesWrapper(localName, ns)) {\n_currentWrapper = _currentWrapper.intermediateWrapper();\n} else {\n// implicit end is more interesting:\n_localName = _currentWrapper.getWrapperLocalName();\n_namespaceURI = _currentWrapper.getWrapperNamespace();\n_currentWrapper = _currentWrapper.getParent();\n//System.out.println(\" START_ELEMENT (\"+localName+\") not matching '\"+_localName+\"'; add extra XML-END-ELEMENT!\");\n// Important! We also need to restore the START_ELEMENT, so:\n_nextLocalName = localName;\n_nextNamespaceURI = ns;\n_repeatElement = REPLAY_START_DELAYED;\nreturn (_currentState = XML_END_ELEMENT);\n}\n}\n_localName = localName;\n_namespaceURI = ns;\nreturn (_currentState = XML_START_ELEMENT);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:_handleRepeatElement()I",
                                    "method_body": "protected int _handleRepeatElement() throws IOException\n{\nint type = _repeatElement;\n_repeatElement = 0;\nif (type == REPLAY_START_DUP) {\n//System.out.println(\"handleRepeat for START_ELEMENT: \"+_localName+\" (\"+_xmlReader.getLocalName()+\")\");\n// important: add the virtual element second time, but not with name to match\n_currentWrapper = _currentWrapper.intermediateWrapper();\nreturn XML_START_ELEMENT;\n}\nif (type == REPLAY_END) {\n//System.out.println(\"handleRepeat for END_ELEMENT: \"+_localName+\" (\"+_xmlReader.getLocalName()+\")\");\n_localName = _xmlReader.getLocalName();\n_namespaceURI = _xmlReader.getNamespaceURI();\nif (_currentWrapper != null) {\n_currentWrapper = _currentWrapper.getParent();\n}\nreturn XML_END_ELEMENT;\n}\nif (type == REPLAY_START_DELAYED) {\nif (_currentWrapper != null) {\n_currentWrapper = _currentWrapper.intermediateWrapper();\n}\n_localName = _nextLocalName;\n_namespaceURI = _nextNamespaceURI;\n_nextLocalName = null;\n_nextNamespaceURI = null;\n\n//System.out.println(\"handleRepeat for START_DELAYED: \"+_localName+\" (\"+_xmlReader.getLocalName()+\")\");\n\nreturn XML_START_ELEMENT;\n}\nthrow new IllegalStateException(\"Unrecognized type to repeat: \"+type);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:_handleEndElement()I",
                                    "method_body": "private final int _handleEndElement()\n{\nif (_currentWrapper != null) {\nElementWrapper w = _currentWrapper;\n// important: if we close the scope, must duplicate END_ELEMENT as well\nif (w.isMatching()) {\n_repeatElement = REPLAY_END;\n_localName = w.getWrapperLocalName();\n_namespaceURI = w.getWrapperNamespace();\n_currentWrapper = _currentWrapper.getParent();\n//System.out.println(\" IMPLICIT requestRepeat of END_ELEMENT '\"+_localName);\n} else {\n_currentWrapper = _currentWrapper.getParent();\n}\n}\nreturn (_currentState = XML_END_ELEMENT);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$1:<clinit>()V",
                                    "method_body": "public JsonToken nextToken() throws IOException\n{\n_binaryValue = null;\nif (_nextToken != null) {\nJsonToken t = _nextToken;\n_currToken = t;\n_nextToken = null;\nswitch (t) {\ncase START_OBJECT:\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nbreak;\ncase START_ARRAY:\n_parsingContext = _parsingContext.createChildArrayContext(-1, -1);\nbreak;\ncase END_OBJECT:\ncase END_ARRAY:\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nbreak;\ncase FIELD_NAME:\n_parsingContext.setCurrentName(_xmlTokens.getLocalName());\nbreak;\ndefault: // VALUE_STRING, VALUE_NULL\n// should be fine as is?\n}\nreturn t;\n}\nint token = _xmlTokens.next();\n\n// Need to have a loop just because we may have to eat/convert\n// a start-element that indicates an array element.\nwhile (token == XmlTokenStream.XML_START_ELEMENT) {\n// If we thought we might get leaf, no such luck\nif (_mayBeLeaf) {\n// leave _mayBeLeaf set, as we start a new context\n_nextToken = JsonToken.FIELD_NAME;\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\nif (_parsingContext.inArray()) {\n// Yup: in array, so this element could be verified; but it won't be\n// reported anyway, and we need to process following event.\ntoken = _xmlTokens.next();\n_mayBeLeaf = true;\ncontinue;\n}\nString name = _xmlTokens.getLocalName();\n_parsingContext.setCurrentName(name);\n\n// Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n// Couple of ways to do it; but start by making _xmlTokens replay the thing...\nif (_namesToWrap != null && _namesToWrap.contains(name)) {\n_xmlTokens.repeatStartElement();\n}\n\n_mayBeLeaf = true;\n// Ok: in array context we need to skip reporting field names.\n// But what's the best way to find next token?\nreturn (_currToken = JsonToken.FIELD_NAME);\n}\n\n// Ok; beyond start element, what do we get?\nswitch (token) {\ncase XmlTokenStream.XML_END_ELEMENT:\n// Simple, except that if this is a leaf, need to suppress end:\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n//    expose as empty Object, not null\nreturn (_currToken = JsonToken.VALUE_NULL);\n}\n_currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nreturn _currToken;\n\ncase XmlTokenStream.XML_ATTRIBUTE_NAME:\n// If there was a chance of leaf node, no more...\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n_nextToken = JsonToken.FIELD_NAME;\n_currText = _xmlTokens.getText();\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\n_parsingContext.setCurrentName(_xmlTokens.getLocalName());\nreturn (_currToken = JsonToken.FIELD_NAME);\ncase XmlTokenStream.XML_ATTRIBUTE_VALUE:\n_currText = _xmlTokens.getText();\nreturn (_currToken = JsonToken.VALUE_STRING);\ncase XmlTokenStream.XML_TEXT:\n_currText = _xmlTokens.getText();\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n/* One more refinement (pronunced like \"hack\") is that if\n* we had an empty String (or all white space), and we are\n* deserializing an array, we better hide the empty text.\n*/\n// Also: must skip following END_ELEMENT\n_xmlTokens.skipEndElement();\nif (_parsingContext.inArray()) {\nif (_isEmpty(_currText)) {\n// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n//    expose as empty Object, not null (or, worse, as used to\n//    be done, by swallowing the token)\n_currToken = JsonToken.END_ARRAY;\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nreturn _currToken;\n}\n}\nreturn (_currToken = JsonToken.VALUE_STRING);\n} else {\n// [dataformat-xml#177]: empty text may also need to be skipped\nif (_parsingContext.inObject()\n&& (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n_currToken = JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nreturn _currToken;\n}\n}\n// If not a leaf (or otherwise ignorable), need to transform into property...\n_parsingContext.setCurrentName(_cfgNameForTextElement);\n_nextToken = JsonToken.VALUE_STRING;\nreturn (_currToken = JsonToken.FIELD_NAME);\ncase XmlTokenStream.XML_END:\nreturn (_currToken = null);\n}\n\n// should never get here\n_throwInternal();\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.AnnotationUtil:findIsAttributeAnnotation(Lcom/fasterxml/jackson/databind/AnnotationIntrospector;Lcom/fasterxml/jackson/databind/introspect/AnnotatedMember;)Ljava/lang/Boolean;",
                                    "method_body": "public static Boolean findIsAttributeAnnotation(AnnotationIntrospector ai,\nAnnotatedMember prop)\n{\nfor (AnnotationIntrospector intr : ai.allIntrospectors()) {\nif (intr instanceof XmlAnnotationIntrospector) {\nBoolean b = ((XmlAnnotationIntrospector) intr).isOutputAsAttribute(prop);\nif (b != null) {\nreturn b;\n}\n} else  if (intr instanceof JaxbAnnotationIntrospector) {\nBoolean b = ((JaxbAnnotationIntrospector) intr).isOutputAsAttribute(prop);\nif (b != null) {\nreturn b;\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.AnnotationUtil:findIsTextAnnotation(Lcom/fasterxml/jackson/databind/AnnotationIntrospector;Lcom/fasterxml/jackson/databind/introspect/AnnotatedMember;)Ljava/lang/Boolean;",
                                    "method_body": "public static Boolean findIsTextAnnotation(AnnotationIntrospector ai,\nAnnotatedMember prop)\n{\nfor (AnnotationIntrospector intr : ai.allIntrospectors()) {\nif (intr instanceof XmlAnnotationIntrospector) {\nBoolean b = ((XmlAnnotationIntrospector) intr).isOutputAsText(prop);\nif (b != null) {\nreturn b;\n}\n} else  if (intr instanceof JaxbAnnotationIntrospector) {\nBoolean b = ((JaxbAnnotationIntrospector) intr).isOutputAsText(prop);\nif (b != null) {\nreturn b;\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.WrapperHandlingDeserializer:<init>(Lcom/fasterxml/jackson/databind/deser/BeanDeserializerBase;)V",
                                    "method_body": "public WrapperHandlingDeserializer(BeanDeserializerBase delegate) {\nthis(delegate, null);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.WrapperHandlingDeserializer:<init>(Lcom/fasterxml/jackson/databind/deser/BeanDeserializerBase;Ljava/util/Set;)V",
                                    "method_body": "public WrapperHandlingDeserializer(BeanDeserializerBase delegate, Set<String> namesToWrap)\n{\nsuper(delegate);\n_namesToWrap = namesToWrap;\n_type = delegate.getValueType();\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.WrapperHandlingDeserializer:createContextual(Lcom/fasterxml/jackson/databind/DeserializationContext;Lcom/fasterxml/jackson/databind/BeanProperty;)Lcom/fasterxml/jackson/databind/JsonDeserializer;",
                                    "method_body": "public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\nBeanProperty property)\nthrows JsonMappingException\n{\n// !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n//    out for 2.5 just to increase compatibility slightly with 2.4 databind\n/*\nJavaType vt = _type;\nif (vt == null) {\nvt = ctxt.constructType(_delegatee.handledType());\n}\nJsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n*/\n\nJsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\nBeanDeserializerBase newDelegatee = _verifyDeserType(del);\n\n// Let's go through the properties now...\nIterator<SettableBeanProperty> it = newDelegatee.properties();\nHashSet<String> unwrappedNames = null;\nwhile (it.hasNext()) {\nSettableBeanProperty prop = it.next();\n/* First things first: only consider array/Collection types\n* (not perfect check, but simplest reasonable check)\n*/\nJavaType type = prop.getType();\nif (!TypeUtil.isIndexedType(type)) {\ncontinue;\n}\nPropertyName wrapperName = prop.getWrapperName();\n// skip anything with wrapper (should work as is)\nif (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\ncontinue;\n}\nif (unwrappedNames == null) {\nunwrappedNames = new HashSet<String>();\n}\n// not optimal; should be able to use PropertyName...\nunwrappedNames.add(prop.getName());\n}\n// Ok: if nothing to take care of, just return the delegatee...\nif (unwrappedNames == null) {\nreturn newDelegatee;\n}\n// Otherwise, create the thing that can deal with virtual wrapping\nreturn new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.WrapperHandlingDeserializer:deserialize(Lcom/fasterxml/jackson/core/JsonParser;Lcom/fasterxml/jackson/databind/DeserializationContext;)Ljava/lang/Object;",
                                    "method_body": "public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n{\n_configureParser(jp);\nreturn _delegatee.deserialize(jp,  ctxt);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.WrapperHandlingDeserializer:_configureParser(Lcom/fasterxml/jackson/core/JsonParser;)V",
                                    "method_body": "protected final void _configureParser(JsonParser jp) throws IOException\n{\n/* 19-Aug-2013, tatu: Although we should not usually get called with\n*   parser of other types, there are some cases where this may happen:\n*   specifically, during structural value conversions.\n*/\nif (jp instanceof FromXmlParser) {\n((FromXmlParser) jp).addVirtualWrapping(_namesToWrap);\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.WrapperHandlingDeserializer:_verifyDeserType(Lcom/fasterxml/jackson/databind/JsonDeserializer;)Lcom/fasterxml/jackson/databind/deser/BeanDeserializerBase;",
                                    "method_body": "protected BeanDeserializerBase _verifyDeserType(JsonDeserializer<?> deser)\n{\nif (!(deser instanceof BeanDeserializerBase)) {\nthrow new IllegalArgumentException(\"Can not change delegate to be of type \"\n+deser.getClass().getName());\n}\nreturn (BeanDeserializerBase) deser;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.TypeUtil:isIndexedType(Lcom/fasterxml/jackson/databind/JavaType;)Z",
                                    "method_body": "public static boolean isIndexedType(JavaType type)\n{\nif (type.isContainerType()) {\nClass<?> cls = type.getRawClass();\n// One special case; byte[] will be serialized as base64-encoded String, not real array, so:\n// (actually, ditto for char[]; thought to be a String)\nif (cls == byte[].class || cls == char[].class) {\nreturn false;\n}\n// issue#5: also, should not add wrapping for Maps\nif (Map.class.isAssignableFrom(cls)) {\nreturn false;\n}\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.ElementWrapper:<init>(Lcom/fasterxml/jackson/dataformat/xml/deser/ElementWrapper;Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "private ElementWrapper(ElementWrapper parent,\nString wrapperLocalName, String wrapperNamespace)\n{\n_parent = parent;\n_wrapperName = wrapperLocalName;\n_wrapperNamespace = (wrapperNamespace == null) ? \"\" : wrapperNamespace;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.ElementWrapper:matchingWrapper(Lcom/fasterxml/jackson/dataformat/xml/deser/ElementWrapper;Ljava/lang/String;Ljava/lang/String;)Lcom/fasterxml/jackson/dataformat/xml/deser/ElementWrapper;",
                                    "method_body": "public static ElementWrapper matchingWrapper(ElementWrapper parent,\nString wrapperLocalName, String wrapperNamespace)\n{\nreturn new ElementWrapper(parent, wrapperLocalName, wrapperNamespace);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.ElementWrapper:intermediateWrapper()Lcom/fasterxml/jackson/dataformat/xml/deser/ElementWrapper;",
                                    "method_body": "public ElementWrapper intermediateWrapper() {\nreturn new ElementWrapper(this, null, null);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.ElementWrapper:isMatching()Z",
                                    "method_body": "public boolean isMatching() { return _wrapperName != null; }\npublic boolean isMatching() { return _wrapperName != null; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.ElementWrapper:getWrapperLocalName()Ljava/lang/String;",
                                    "method_body": "public String getWrapperLocalName() { return _wrapperName; }\npublic String getWrapperLocalName() { return _wrapperName; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.ElementWrapper:getWrapperNamespace()Ljava/lang/String;",
                                    "method_body": "public String getWrapperNamespace() { return _wrapperNamespace; }\npublic String getWrapperNamespace() { return _wrapperNamespace; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.ElementWrapper:getParent()Lcom/fasterxml/jackson/dataformat/xml/deser/ElementWrapper;",
                                    "method_body": "public ElementWrapper getParent() { return _parent; }\npublic ElementWrapper getParent() { return _parent; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:setDefaultUseWrapper(Z)Lcom/fasterxml/jackson/dataformat/xml/XmlMapper;",
                                    "method_body": "public XmlMapper setDefaultUseWrapper(boolean state) {\n// ser and deser configs should usually have the same introspector, so:\nAnnotationIntrospector ai0 = getDeserializationConfig().getAnnotationIntrospector();\nfor (AnnotationIntrospector ai : ai0.allIntrospectors()) {\nif (ai instanceof XmlAnnotationIntrospector) {\n((XmlAnnotationIntrospector) ai).setDefaultUseWrapper(state);\n}\n}\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:setDefaultUseWrapper(Z)V",
                                    "method_body": "public void setDefaultUseWrapper(boolean b) {\n_cfgDefaultUseWrapper = b;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:_isEmpty(Ljava/lang/String;)Z",
                                    "method_body": "protected boolean _isEmpty(String str)\n{\nint len = (str == null) ? 0 : str.length();\nif (len > 0) {\nfor (int i = 0; i < len; ++i) {\nif (str.charAt(i) > ' ') {\nreturn false;\n}\n}\n}\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:skipEndElement()V",
                                    "method_body": "public void skipEndElement() throws IOException\n{\nint type = next();\nif (type != XML_END_ELEMENT) {\nthrow new IOException(\"Expected END_ELEMENT, got event of type \"+type);\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 2,
                    "tests": [
                        {
                            "test_name": "com.fasterxml.jackson.dataformat.xml.misc.XmlTextTest.testMixedContent",
                            "test_body": "public void testMixedContent() throws Exception\n{\nWindSpeed result = MAPPER.readValue(\"<windSpeed units='kt'> 27 <radius>20</radius></windSpeed>\",\nWindSpeed.class);\nassertEquals(27, result.value);\nassertNotNull(result.radius);\nassertEquals(20, result.radius.value);\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<init>(Lcom/fasterxml/jackson/dataformat/xml/JacksonXmlModule;)V",
                                    "method_body": "public XmlMapper(JacksonXmlModule module) {\nthis(new XmlFactory(), module);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<init>(Lcom/fasterxml/jackson/dataformat/xml/XmlFactory;Lcom/fasterxml/jackson/dataformat/xml/JacksonXmlModule;)V",
                                    "method_body": "public XmlMapper(XmlFactory xmlFactory, JacksonXmlModule module)\n{\n/* Need to override serializer provider (due to root name handling);\n* deserializer provider fine as is\n*/\nsuper(xmlFactory, new XmlSerializerProvider(new XmlRootNameLookup()), null);\n_xmlModule = module;\n// but all the rest is done via Module interface!\nif (module != null) {\nregisterModule(module);\n}\n// 19-May-2015, tatu: Must ensure we use XML-specific indenter\n_serializationConfig = _serializationConfig.withDefaultPrettyPrinter(DEFAULT_XML_PRETTY_PRINTER);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\nprotected final static JacksonXmlModule DEFAULT_XML_MODULE = new JacksonXmlModule();\n\nprotected final static DefaultXmlPrettyPrinter DEFAULT_XML_PRETTY_PRINTER = new DefaultXmlPrettyPrinter();\n\n// need to hold on to module instance just in case copy() is used\nprotected final JacksonXmlModule _xmlModule;\n\n/*\n/**********************************************************\n/* Life-cycle: construction, configuration\n/**********************************************************\n*/\n\npublic XmlMapper() {\nthis(new XmlFactory());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlModule:<init>()V",
                                    "method_body": "public JacksonXmlModule()\n{\nsuper(\"JackxonXmlModule\", PackageVersion.VERSION);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlModule:setupModule(Lcom/fasterxml/jackson/databind/Module$SetupContext;)V",
                                    "method_body": "public void setupModule(SetupContext context)\n{\n// Need to modify BeanDeserializer, BeanSerializer that are used\ncontext.addBeanSerializerModifier(new XmlBeanSerializerModifier());\ncontext.addBeanDeserializerModifier(new XmlBeanDeserializerModifier(_cfgNameForTextElement));\n\n// as well as AnnotationIntrospector\ncontext.insertAnnotationIntrospector(_constructIntrospector());\n\n// and finally inform XmlFactory about overrides, if need be:\nif (_cfgNameForTextElement != FromXmlParser.DEFAULT_UNNAMED_TEXT_PROPERTY) {\nXmlMapper m = (XmlMapper) context.getOwner();\nm.setXMLTextElementName(_cfgNameForTextElement);\n}\n\n/* Usually this would be the first call; but here anything added will\n* be stuff user may has added, so do it afterwards instead.\n*/\nsuper.setupModule(context);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlModule:setDefaultUseWrapper(Z)V",
                                    "method_body": "public void setDefaultUseWrapper(boolean state) {\n_cfgDefaultUseWrapper = state;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlModule:_constructIntrospector()Lcom/fasterxml/jackson/databind/AnnotationIntrospector;",
                                    "method_body": "protected AnnotationIntrospector _constructIntrospector() {\nreturn new JacksonXmlAnnotationIntrospector(_cfgDefaultUseWrapper);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.PackageVersion:<clinit>()V",
                                    "method_body": "public final static Version VERSION = VersionUtil.parseVersion(\n\"2.8.0.rc2-SNAPSHOT\", \"com.fasterxml.jackson.dataformat\", \"jackson-dataformat-xml\");\n\n@Override\npublic Version version() {\nreturn VERSION;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter:<init>()V",
                                    "method_body": "public void writeIndentation(JsonGenerator g, int level) throws IOException;\n\npublic void writeIndentation(XMLStreamWriter2 sw, int level) throws XMLStreamException;\n\n/**\n* @return True if indenter is considered inline (does not add linefeeds),\n*   false otherwise\n*/\npublic boolean isInline();\n}\n\n/*\n/**********************************************************\n/* Configuration\n/**********************************************************\n*/\n\n/**\n* By default, let's use only spaces to separate array values.\n*/\nprotected Indenter _arrayIndenter = new FixedSpaceIndenter();\n\n/**\n* By default, let's use linefeed-adding indenter for separate\n* object entries. We'll further configure indenter to use\n* system-specific linefeeds, and 2 spaces per level (as opposed to,\n* say, single tabs)\n*/\nprotected Indenter _objectIndenter = new Lf2SpacesIndenter();\n\n// // // Config, other white space configuration\n\n/**\n* By default we will add spaces around colons used to\n* separate object fields and values.\n* If disabled, will not use spaces around colon.\n*/\nprotected boolean _spacesInObjectEntries = true;\n\n/*\n/**********************************************************\n/* State\n/**********************************************************\n*/\n\n/**\n* Number of open levels of nesting. Used to determine amount of\n* indentation to use.\n*/\nprotected transient int _nesting = 0;\n\n/**\n* Marker flag set on start element, and cleared if an end element\n* is encountered. Used for suppressing indentation to allow empty\n* elements.\n*\n* @since 2.3.0\n*/\nprotected transient boolean _justHadStartElement;\n\n/*\n/**********************************************************\n/* Life-cycle (construct, configure)\n/**********************************************************\n*/\n\npublic DefaultXmlPrettyPrinter() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter$FixedSpaceIndenter:<init>()V",
                                    "method_body": "public FixedSpaceIndenter() { }\npublic FixedSpaceIndenter() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter$Lf2SpacesIndenter:<init>()V",
                                    "method_body": "public Lf2SpacesIndenter() { }\npublic Lf2SpacesIndenter() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter$Lf2SpacesIndenter:<clinit>()V",
                                    "method_body": "final static int SPACE_COUNT = 64;\nfinal static char[] SPACES = new char[SPACE_COUNT];\nstatic {\nArrays.fill(SPACES, ' ');\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>()V",
                                    "method_body": "public XmlFactory() { this(null, null, null); }\npublic XmlFactory() { this(null, null, null); }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>(Lcom/fasterxml/jackson/core/ObjectCodec;Ljavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;)V",
                                    "method_body": "public XmlFactory(ObjectCodec oc, XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n{\nthis(oc, DEFAULT_XML_PARSER_FEATURE_FLAGS, DEFAULT_XML_GENERATOR_FEATURE_FLAGS,\nxmlIn, xmlOut, null);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>(Lcom/fasterxml/jackson/core/ObjectCodec;IILjavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;Ljava/lang/String;)V",
                                    "method_body": "protected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\nXMLInputFactory xmlIn, XMLOutputFactory xmlOut,\nString nameForTextElem)\n{\nsuper(oc);\n_xmlParserFeatures = xpFeatures;\n_xmlGeneratorFeatures = xgFeatures;\n_cfgNameForTextElement = nameForTextElem;\nif (xmlIn == null) {\nxmlIn = XMLInputFactory.newInstance();\n// as per [dataformat-xml#190], disable external entity expansion by default\nxmlIn.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\n}\nif (xmlOut == null) {\nxmlOut = XMLOutputFactory.newInstance();\n}\n_initFactories(xmlIn, xmlOut);\n_xmlInputFactory = xmlIn;\n_xmlOutputFactory = xmlOut;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<clinit>()V",
                                    "method_body": "public final static String FORMAT_NAME_XML = \"XML\";\n\n/**\n* Bitfield (set of flags) of all parser features that are enabled\n* by default.\n*/\nfinal static int DEFAULT_XML_PARSER_FEATURE_FLAGS = FromXmlParser.Feature.collectDefaults();\n\n/**\n* Bitfield (set of flags) of all generator features that are enabled\n* by default.\n*/\nfinal static int DEFAULT_XML_GENERATOR_FEATURE_FLAGS = ToXmlGenerator.Feature.collectDefaults();\n\n/*\n/**********************************************************\n/* Configuration\n/**********************************************************\n*/\n\nprotected int _xmlParserFeatures;\n\nprotected int _xmlGeneratorFeatures;\n\n// non-final for setters (why are they needed again?)\nprotected transient XMLInputFactory _xmlInputFactory;\n\nprotected transient XMLOutputFactory _xmlOutputFactory;\n\nprotected String _cfgNameForTextElement;\n\n/*\n/**********************************************************\n/* Factory construction, configuration\n/**********************************************************\n*/\n\n/**\n* Default constructor used to create factory instances.\n* Creation of a factory instance is a light-weight operation,\n* but it is still a good idea to reuse limited number of\n* factory instances (and quite often just a single instance):\n* factories are used as context for storing some reused\n* processing objects (such as symbol tables parsers use)\n* and this reuse only works within context of a single\n* factory instance.\n*/\npublic XmlFactory() { this(null, null, null); }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_initFactories(Ljavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;)V",
                                    "method_body": "protected void _initFactories(XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n{\n// Better ensure namespaces get built properly, so:\nxmlOut.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\n// and for parser, force coalescing as well (much simpler to use)\nxmlIn.setProperty(XMLInputFactory.IS_COALESCING, Boolean.TRUE);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:createParser(Ljava/lang/String;)Lcom/fasterxml/jackson/core/JsonParser;",
                                    "method_body": "public JsonParser createParser(String content) throws IOException {\nReader r = new StringReader(content);\nIOContext ctxt = _createContext(r, true);\nif (_inputDecorator != null) {\nr = _inputDecorator.decorate(ctxt, r);\n}\nreturn _createParser(r, ctxt);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_createParser(Ljava/io/Reader;Lcom/fasterxml/jackson/core/io/IOContext;)Lcom/fasterxml/jackson/dataformat/xml/deser/FromXmlParser;",
                                    "method_body": "protected FromXmlParser _createParser(Reader r, IOContext ctxt) throws IOException\n{\nXMLStreamReader sr;\ntry {\nsr = _xmlInputFactory.createXMLStreamReader(r);\nsr = _initializeXmlReader(sr);\n} catch (XMLStreamException e) {\nreturn StaxUtil.throwXmlAsIOException(e);\n}\nFromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n_objectCodec, sr);\nif (_cfgNameForTextElement != null) {\nxp.setXMLTextElementName(_cfgNameForTextElement);\n}\nreturn xp;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_initializeXmlReader(Ljavax/xml/stream/XMLStreamReader;)Ljavax/xml/stream/XMLStreamReader;",
                                    "method_body": "protected final XMLStreamReader _initializeXmlReader(XMLStreamReader sr) throws IOException, XMLStreamException\n{\n// for now, nothing to do... except let's find the root element\nwhile (sr.next() != XMLStreamConstants.START_ELEMENT) {\n;\n}\nreturn sr;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature:<clinit>()V",
                                    "method_body": "public final static String DEFAULT_UNNAMED_TEXT_PROPERTY = \"\";\n\n/**\n* Enumeration that defines all togglable features for XML parsers.\n* None defined so far (2.6), so just a placeholder.\n*/\npublic enum Feature implements FormatFeature\n{\n;\n\nfinal boolean _defaultState;\nfinal int _mask;\n\n/**\n* Method that calculates bit set (flags) of all features that\n* are enabled by default.\n*/\npublic static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}\n\nprivate Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}\n\n@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public int getMask() { return _mask; }\n@Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature:collectDefaults()I",
                                    "method_body": "public static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:<init>(Ljava/lang/String;IZ)V",
                                    "method_body": "private Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:<clinit>()V",
                                    "method_body": "protected final static String DEFAULT_UNKNOWN_ELEMENT = \"unknown\";\n\n/**\n* Enumeration that defines all togglable extra XML-specific features\n*/\npublic enum Feature implements FormatFeature\n{\n/**\n* Feature that controls whether XML declaration should be written before\n* when generator is initialized (true) or not (false)\n*/\nWRITE_XML_DECLARATION(false),\n\n/**\n* Feature that controls whether output should be done as XML 1.1; if so,\n* certain aspects may differ from default (1.0) processing: for example,\n* XML declaration will be automatically added (regardless of setting\n* <code>WRITE_XML_DECLARATION</code>) as this is required for reader to\n* know to use 1.1 compliant handling. XML 1.1 can be used to allow quoted\n* control characters (Ascii codes 0 through 31) as well as additional linefeeds\n* and name characters.\n*/\nWRITE_XML_1_1(false)\n;\n\nfinal boolean _defaultState;\nfinal int _mask;\n\n/**\n* Method that calculates bit set (flags) of all features that\n* are enabled by default.\n*/\npublic static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}\n\nprivate Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}\n\n@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public int getMask() { return _mask; }\n@Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:collectDefaults()I",
                                    "method_body": "public static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:enabledByDefault()Z",
                                    "method_body": "@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public boolean enabledByDefault() { return _defaultState; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:<init>(Lcom/fasterxml/jackson/dataformat/xml/util/XmlRootNameLookup;)V",
                                    "method_body": "public XmlSerializerProvider(XmlRootNameLookup rootNames)\n{\nsuper();\n_rootNameLookup = rootNames;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\n/**\n* If all we get to serialize is a null, there's no way to figure out\n* expected root name; so let's just default to something like \"&lt;null>\"...\n*/\nprotected final static QName ROOT_NAME_FOR_NULL = new QName(\"null\");\n\nprotected final XmlRootNameLookup _rootNameLookup;\n\npublic XmlSerializerProvider(XmlRootNameLookup rootNames)\n{\nsuper();\n_rootNameLookup = rootNames;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.XmlRootNameLookup:<init>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\n/**\n* For efficient operation, let's try to minimize number of times we\n* need to introspect root element name to use.\n*<p>\n* Note: changed to <code>transient</code> for 2.3; no point in serializing such\n* state\n*/\nprotected final transient LRUMap<ClassKey,QName> _rootNames = new LRUMap<ClassKey,QName>(40, 200);\n\npublic XmlRootNameLookup() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerModifier:<init>()V",
                                    "method_body": "public XmlBeanSerializerModifier() { }\npublic XmlBeanSerializerModifier() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlBeanDeserializerModifier:<init>(Ljava/lang/String;)V",
                                    "method_body": "public XmlBeanDeserializerModifier(String nameForTextValue)\n{\n_cfgNameForTextValue = nameForTextValue;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlBeanDeserializerModifier:updateProperties(Lcom/fasterxml/jackson/databind/DeserializationConfig;Lcom/fasterxml/jackson/databind/BeanDescription;Ljava/util/List;)Ljava/util/List;",
                                    "method_body": "public List<BeanPropertyDefinition> updateProperties(DeserializationConfig config,\nBeanDescription beanDesc, List<BeanPropertyDefinition> propDefs)\n{\nfinal AnnotationIntrospector intr = config.getAnnotationIntrospector();\nint changed = 0;\n\nfor (int i = 0, propCount = propDefs.size(); i < propCount; ++i) {\nBeanPropertyDefinition prop = propDefs.get(i);\nAnnotatedMember acc = prop.getPrimaryMember();\n// should not be null, but just in case:\nif (acc == null) {\ncontinue;\n}\n/* First: handle \"as text\"? Such properties\n* are exposed as values of 'unnamed' fields; so one way to\n* map them is to rename property to have name \"\"... (and\n* hope this does not break other parts...)\n*/\nBoolean b = AnnotationUtil.findIsTextAnnotation(intr, acc);\nif (b != null && b.booleanValue()) {\n// unwrapped properties will appear as 'unnamed' (empty String)\nBeanPropertyDefinition newProp = prop.withSimpleName(_cfgNameForTextValue);\nif (newProp != prop) {\npropDefs.set(i, newProp);\n}\ncontinue;\n}\n// second: do we need to handle wrapping (for Lists)?\nPropertyName wrapperName = prop.getWrapperName();\n\nif (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\nString localName = wrapperName.getSimpleName();\nif ((localName != null && localName.length() > 0)\n&& !localName.equals(prop.getName())) {\n// make copy-on-write as necessary\nif (changed == 0) {\npropDefs = new ArrayList<BeanPropertyDefinition>(propDefs);\n}\n++changed;\npropDefs.set(i, prop.withSimpleName(localName));\ncontinue;\n}\n// otherwise unwrapped; needs handling but later on\n}\n}\nreturn propDefs;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlBeanDeserializerModifier:modifyDeserializer(Lcom/fasterxml/jackson/databind/DeserializationConfig;Lcom/fasterxml/jackson/databind/BeanDescription;Lcom/fasterxml/jackson/databind/JsonDeserializer;)Lcom/fasterxml/jackson/databind/JsonDeserializer;",
                                    "method_body": "public JsonDeserializer<?> modifyDeserializer(DeserializationConfig config,\nBeanDescription beanDesc, JsonDeserializer<?> deser0)\n{\nif (!(deser0 instanceof BeanDeserializerBase)) {\nreturn deser0;\n}\n/* 17-Aug-2013, tatu: One important special case first: if we have one \"XML Text\"\n* property, it may be exposed as VALUE_STRING token (depending on whether any attribute\n* values are exposed): and to deserialize from that, we need special handling unless POJO\n* has appropriate single-string creator method.\n*/\nBeanDeserializerBase deser = (BeanDeserializerBase) deser0;\n\n// Heuristics are bit tricky; but for now let's assume that if POJO\n// can already work with VALUE_STRING, it's ok and doesn't need extra support\nif (!deser.getValueInstantiator().canCreateFromString()) {\nSettableBeanProperty textProp = _findSoleTextProp(config, deser.properties());\nif (textProp != null) {\nreturn new XmlTextDeserializer(deser, textProp);\n}\n}\nreturn new WrapperHandlingDeserializer(deser);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlBeanDeserializerModifier:_findSoleTextProp(Lcom/fasterxml/jackson/databind/DeserializationConfig;Ljava/util/Iterator;)Lcom/fasterxml/jackson/databind/deser/SettableBeanProperty;",
                                    "method_body": "private SettableBeanProperty _findSoleTextProp(DeserializationConfig config,\nIterator<SettableBeanProperty> propIt)\n{\nfinal AnnotationIntrospector ai = config.getAnnotationIntrospector();\nSettableBeanProperty textProp = null;\nwhile (propIt.hasNext()) {\nSettableBeanProperty prop = propIt.next();\nAnnotatedMember m = prop.getMember();\nif (m != null) {\n// Ok, let's use a simple check: we should have renamed it earlier so:\nPropertyName n = prop.getFullName();\nif (_cfgNameForTextValue.equals(n.getSimpleName())) {\n// should we verify we only got one?\ntextProp = prop;\ncontinue;\n}\n// as-attribute are ok as well\nBoolean b = AnnotationUtil.findIsAttributeAnnotation(ai, m);\nif (b != null && b.booleanValue()) {\ncontinue;\n}\n}\n// Otherwise, it's something else; no go\nreturn null;\n}\nreturn textProp;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:<init>(Z)V",
                                    "method_body": "public JacksonXmlAnnotationIntrospector(boolean defaultUseWrapper) {\n_cfgDefaultUseWrapper = defaultUseWrapper;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:findWrapperName(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Lcom/fasterxml/jackson/databind/PropertyName;",
                                    "method_body": "public PropertyName findWrapperName(Annotated ann)\n{\nJacksonXmlElementWrapper w = ann.getAnnotation(JacksonXmlElementWrapper.class);\nif (w != null) {\n// Special case: wrapping explicitly blocked?\nif (!w.useWrapping()) {\nreturn PropertyName.NO_NAME;\n}\n// also: need to ensure we use marker:\nString localName = w.localName();\nif (localName == null || localName.length() == 0) {\nreturn PropertyName.USE_DEFAULT;\n}\nreturn PropertyName.construct(w.localName(), w.namespace());\n}\n/* 09-Sep-2012, tatu: In absence of configurating we need to use our\n*   default settings...\n*/\nif (_cfgDefaultUseWrapper) {\nreturn PropertyName.USE_DEFAULT;\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:isOutputAsAttribute(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Ljava/lang/Boolean;",
                                    "method_body": "public Boolean isOutputAsAttribute(Annotated ann)\n{\nJacksonXmlProperty prop = ann.getAnnotation(JacksonXmlProperty.class);\nif (prop != null) {\nreturn prop.isAttribute() ? Boolean.TRUE : Boolean.FALSE;\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:isOutputAsText(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Ljava/lang/Boolean;",
                                    "method_body": "public Boolean isOutputAsText(Annotated ann)\n{\nJacksonXmlText prop = ann.getAnnotation(JacksonXmlText.class);\nif (prop != null) {\nreturn prop.value() ? Boolean.TRUE : Boolean.FALSE;\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:findNameForDeserialization(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Lcom/fasterxml/jackson/databind/PropertyName;",
                                    "method_body": "public PropertyName findNameForDeserialization(Annotated a)\n{\nPropertyName name = _findXmlName(a);\nif (name == null) {\nname = super.findNameForDeserialization(a);\nif (name == null) {\nif (a.hasAnnotation(JacksonXmlText.class)) {\nreturn PropertyName.USE_DEFAULT;\n}\n}\n}\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:_findXmlName(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Lcom/fasterxml/jackson/databind/PropertyName;",
                                    "method_body": "protected PropertyName _findXmlName(Annotated a)\n{\nJacksonXmlProperty pann = a.getAnnotation(JacksonXmlProperty.class);\nif (pann != null) {\nreturn PropertyName.construct(pann.localName(), pann.namespace());\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:<init>(Lcom/fasterxml/jackson/core/io/IOContext;IILcom/fasterxml/jackson/core/ObjectCodec;Ljavax/xml/stream/XMLStreamReader;)V",
                                    "method_body": "protected String _cfgNameForTextElement = DEFAULT_UNNAMED_TEXT_PROPERTY;\n\n/*\n/**********************************************************\n/* Configuration\n/**********************************************************\n*/\n\n/**\n* Bit flag composed of bits that indicate which\n* {@link FromXmlParser.Feature}s"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:getCurrentName()Ljava/lang/String;",
                                    "method_body": "public String getCurrentName() throws IOException\n{\n// start markers require information from parent\nString name;\nif (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\nXmlReadContext parent = _parsingContext.getParent();\nname = parent.getCurrentName();\n} else {\nname = _parsingContext.getCurrentName();\n}\n// sanity check\nif (name == null) {\nthrow new IllegalStateException(\"Missing name, in state: \"+_currToken);\n}\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:close()V",
                                    "method_body": "public void close() throws IOException\n{\nif (!_closed) {\n_closed = true;\ntry {\nif (_ioContext.isResourceManaged() || isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)) {\n_xmlTokens.closeCompletely();\n} else {\n_xmlTokens.close();\n}\n} finally {\n// as per [JACKSON-324], do in finally block\n// Also, internal buffer(s) can now be released as well\n_releaseBuffers();\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:getParsingContext()Lcom/fasterxml/jackson/dataformat/xml/deser/XmlReadContext;",
                                    "method_body": "public XmlReadContext getParsingContext() {\nreturn _parsingContext;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:nextToken()Lcom/fasterxml/jackson/core/JsonToken;",
                                    "method_body": "public JsonToken nextToken() throws IOException\n{\n_binaryValue = null;\nif (_nextToken != null) {\nJsonToken t = _nextToken;\n_currToken = t;\n_nextToken = null;\nswitch (t) {\ncase START_OBJECT:\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nbreak;\ncase START_ARRAY:\n_parsingContext = _parsingContext.createChildArrayContext(-1, -1);\nbreak;\ncase END_OBJECT:\ncase END_ARRAY:\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nbreak;\ncase FIELD_NAME:\n_parsingContext.setCurrentName(_xmlTokens.getLocalName());\nbreak;\ndefault: // VALUE_STRING, VALUE_NULL\n// should be fine as is?\n}\nreturn t;\n}\nint token = _xmlTokens.next();\n\n// Need to have a loop just because we may have to eat/convert\n// a start-element that indicates an array element.\nwhile (token == XmlTokenStream.XML_START_ELEMENT) {\n// If we thought we might get leaf, no such luck\nif (_mayBeLeaf) {\n// leave _mayBeLeaf set, as we start a new context\n_nextToken = JsonToken.FIELD_NAME;\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\nif (_parsingContext.inArray()) {\n// Yup: in array, so this element could be verified; but it won't be\n// reported anyway, and we need to process following event.\ntoken = _xmlTokens.next();\n_mayBeLeaf = true;\ncontinue;\n}\nString name = _xmlTokens.getLocalName();\n_parsingContext.setCurrentName(name);\n\n// Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n// Couple of ways to do it; but start by making _xmlTokens replay the thing...\nif (_namesToWrap != null && _namesToWrap.contains(name)) {\n_xmlTokens.repeatStartElement();\n}\n\n_mayBeLeaf = true;\n// Ok: in array context we need to skip reporting field names.\n// But what's the best way to find next token?\nreturn (_currToken = JsonToken.FIELD_NAME);\n}\n\n// Ok; beyond start element, what do we get?\nwhile (true) {\nswitch (token) {\ncase XmlTokenStream.XML_END_ELEMENT:\n// Simple, except that if this is a leaf, need to suppress end:\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\nif (_parsingContext.inArray()) {\n// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n//    expose as empty Object, not null\n_nextToken = JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\nreturn (_currToken = JsonToken.VALUE_NULL);\n}\n_currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nreturn _currToken;\n\ncase XmlTokenStream.XML_ATTRIBUTE_NAME:\n// If there was a chance of leaf node, no more...\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n_nextToken = JsonToken.FIELD_NAME;\n_currText = _xmlTokens.getText();\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\n_parsingContext.setCurrentName(_xmlTokens.getLocalName());\nreturn (_currToken = JsonToken.FIELD_NAME);\ncase XmlTokenStream.XML_ATTRIBUTE_VALUE:\n_currText = _xmlTokens.getText();\nreturn (_currToken = JsonToken.VALUE_STRING);\ncase XmlTokenStream.XML_TEXT:\n_currText = _xmlTokens.getText();\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n// One more refinement (pronunced like \"hack\") is that if\n// we had an empty String (or all white space), and we are\n// deserializing an array, we better hide the empty text.\n// Also: must skip following END_ELEMENT\n_xmlTokens.skipEndElement();\nif (_parsingContext.inArray()) {\nif (_isEmpty(_currText)) {\n// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n//    expose as empty Object, not null (or, worse, as used to\n//    be done, by swallowing the token)\n_nextToken = JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\n}\nreturn (_currToken = JsonToken.VALUE_STRING);\n} else {\n// [dataformat-xml#177]: empty text may also need to be skipped\n// but... [dataformat-xml#191]: looks like we can't short-cut, must\n// loop over again\nif (_parsingContext.inObject()) {\nif ((_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\ntoken = _xmlTokens.next();\ncontinue;\n}\n}\n}\n// If not a leaf (or otherwise ignorable), need to transform into property...\n_parsingContext.setCurrentName(_cfgNameForTextElement);\n_nextToken = JsonToken.VALUE_STRING;\nreturn (_currToken = JsonToken.FIELD_NAME);\ncase XmlTokenStream.XML_END:\nreturn (_currToken = null);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:getText()Ljava/lang/String;",
                                    "method_body": "public String getText() throws IOException\n{\nif (_currToken == null) {\nreturn null;\n}\nswitch (_currToken) {\ncase FIELD_NAME:\nreturn getCurrentName();\ncase VALUE_STRING:\nreturn _currText;\ndefault:\nreturn _currToken.asString();\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:_releaseBuffers()V",
                                    "method_body": "protected void _releaseBuffers() throws IOException {\n// anything we can/must release? Underlying parser should do all of it, for now?\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:<init>(Lcom/fasterxml/jackson/dataformat/xml/deser/XmlReadContext;III)V",
                                    "method_body": "public XmlReadContext(XmlReadContext parent, int type, int lineNr, int colNr)\n{\nsuper();\n_type = type;\n_parent = parent;\n_lineNr = lineNr;\n_columnNr = colNr;\n_index = -1;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:createRootContext(II)Lcom/fasterxml/jackson/dataformat/xml/deser/XmlReadContext;",
                                    "method_body": "public static XmlReadContext createRootContext(int lineNr, int colNr) {\nreturn new XmlReadContext(null, TYPE_ROOT, lineNr, colNr);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:createChildObjectContext(II)Lcom/fasterxml/jackson/dataformat/xml/deser/XmlReadContext;",
                                    "method_body": "public final XmlReadContext createChildObjectContext(int lineNr, int colNr)\n{\nXmlReadContext ctxt = _child;\nif (ctxt == null) {\n_child = ctxt = new XmlReadContext(this, TYPE_OBJECT, lineNr, colNr);\nreturn ctxt;\n}\nctxt.reset(TYPE_OBJECT, lineNr, colNr);\nreturn ctxt;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:getCurrentName()Ljava/lang/String;",
                                    "method_body": "public final String getCurrentName() { return _currentName; }\npublic final String getCurrentName() { return _currentName; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:getParent()Lcom/fasterxml/jackson/dataformat/xml/deser/XmlReadContext;",
                                    "method_body": "public final XmlReadContext getParent() { return _parent; }\npublic final XmlReadContext getParent() { return _parent; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:setCurrentName(Ljava/lang/String;)V",
                                    "method_body": "public void setCurrentName(String name) {\n_currentName = name;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:getNamesToWrap()Ljava/util/Set;",
                                    "method_body": "public Set<String> getNamesToWrap() {\nreturn _namesToWrap;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:<init>(Ljavax/xml/stream/XMLStreamReader;Ljava/lang/Object;)V",
                                    "method_body": "public final static int XML_START_ELEMENT = 1;\npublic final static int XML_END_ELEMENT = 2;\npublic final static int XML_ATTRIBUTE_NAME = 3;\npublic final static int XML_ATTRIBUTE_VALUE = 4;\npublic final static int XML_TEXT = 5;\npublic final static int XML_END = 6;\n\n// // // token replay states\n\nprivate final static int REPLAY_START_DUP = 1;\nprivate final static int REPLAY_END = 2;\nprivate final static int REPLAY_START_DELAYED = 3;\n\n/*\n/**********************************************************************\n/* Configuration\n/**********************************************************************\n*/\n\nfinal protected XMLStreamReader2 _xmlReader;\n\nfinal protected Object _sourceReference;\n\n/*\n/**********************************************************************\n/* Parsing state\n/**********************************************************************\n*/\n\nprotected int _currentState;\n\nprotected int _attributeCount;\n\n/**\n* If true we have a START_ELEMENT with mixed text\n*\n* @since 2.8\n*/\n\n/**\n* Index of the next attribute of the current START_ELEMENT\n* to return (as field name and value pair), if any; -1\n* when no attributes to return\n*/\nprotected int _nextAttributeIndex = 0;\n\nprotected String _localName;\n\nprotected String _namespaceURI;\n\nprotected String _textValue;\n\n/*\n/**********************************************************************\n/* State for handling virtual wrapping\n/**********************************************************************\n*/\n\n/**\n* Flag used to indicate that given element should be \"replayed\".\n*/\nprotected int _repeatElement;\n\n/**\n* Wrapping state, if any active (null if none)\n*/\nprotected ElementWrapper _currentWrapper;\n\n/**\n* In cases where we need to 'inject' a virtual END_ELEMENT, we may also\n* need to restore START_ELEMENT afterwards; if so, this is where names\n* are held.\n*/\nprotected String _nextLocalName;\nprotected String _nextNamespaceURI;\n\n/*\n/**********************************************************************\n/* Life-cycle\n/**********************************************************************\n*/\n\npublic XmlTokenStream(XMLStreamReader xmlReader, Object sourceRef)\n{\n_sourceReference = sourceRef;\n// Let's ensure we point to START_ELEMENT...\nif (xmlReader.getEventType() != XMLStreamConstants.START_ELEMENT) {\nthrow new IllegalArgumentException(\"Invalid XMLStreamReader passed: should be pointing to START_ELEMENT (\"\n+XMLStreamConstants.START_ELEMENT+\"), instead got \"+xmlReader.getEventType());\n}\n_xmlReader = Stax2ReaderAdapter.wrapIfNecessary(xmlReader);\n_currentState = XML_START_ELEMENT;\n_localName = _xmlReader.getLocalName();\n_namespaceURI = _xmlReader.getNamespaceURI();\n_attributeCount = _xmlReader.getAttributeCount();\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:next()I",
                                    "method_body": "public int next() throws IOException\n{\nif (_repeatElement != 0) {\nreturn (_currentState = _handleRepeatElement());\n}\ntry {\nreturn _next();\n} catch (XMLStreamException e) {\nStaxUtil.throwXmlAsIOException(e);\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:skipEndElement()V",
                                    "method_body": "public void skipEndElement() throws IOException\n{\nint type = next();\nif (type != XML_END_ELEMENT) {\nthrow new IOException(\"Expected END_ELEMENT, got event of type \"+type);\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:getText()Ljava/lang/String;",
                                    "method_body": "public String getText() { return _textValue; }\npublic String getText() { return _textValue; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:getLocalName()Ljava/lang/String;",
                                    "method_body": "public String getLocalName() { return _localName; }\npublic String getLocalName() { return _localName; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:closeCompletely()V",
                                    "method_body": "public void closeCompletely() throws IOException\n{\ntry {\n_xmlReader.closeCompletely();\n} catch (XMLStreamException e) {\nStaxUtil.throwXmlAsIOException(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:_next()I",
                                    "method_body": "private final int _next() throws XMLStreamException\n{\nswitch (_currentState) {\ncase XML_ATTRIBUTE_VALUE:\n++_nextAttributeIndex;\n// fall through\ncase XML_START_ELEMENT: // attributes to return?\nif (_nextAttributeIndex < _attributeCount) {\n_localName = _xmlReader.getAttributeLocalName(_nextAttributeIndex);\n_namespaceURI = _xmlReader.getAttributeNamespace(_nextAttributeIndex);\n_textValue = _xmlReader.getAttributeValue(_nextAttributeIndex);\nreturn (_currentState = XML_ATTRIBUTE_NAME);\n}\n// otherwise need to find START/END_ELEMENT or text\nString text = _collectUntilTag();\n// If we have no/all-whitespace text followed by START_ELEMENT, ignore text\nif (_xmlReader.getEventType() == XMLStreamReader.START_ELEMENT) {\nreturn _initStartElement();\n}\n// For END_ELEMENT we will return text, if any\nif (text != null) {\n_textValue = text;\nreturn (_currentState = XML_TEXT);\n}\nreturn _handleEndElement();\n\ncase XML_ATTRIBUTE_NAME:\n// if we just returned name, will need to just send value next\nreturn (_currentState = XML_ATTRIBUTE_VALUE);\ncase XML_TEXT:\n// mixed text with other elements\n// text followed by END_ELEMENT\nreturn _handleEndElement();\ncase XML_END:\nreturn XML_END;\n//            throw new IllegalStateException(\"No more XML tokens available (end of input)\");\n}\n\n// Ok: must be END_ELEMENT; see what tag we get (or end)\nswitch (_skipUntilTag()) {\ncase XMLStreamConstants.END_DOCUMENT:\nreturn (_currentState = XML_END);\ncase XMLStreamConstants.END_ELEMENT:\nreturn _handleEndElement();\n}\n// START_ELEMENT...\nreturn _initStartElement();\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:_collectUntilTag()Ljava/lang/String;",
                                    "method_body": "private final String _collectUntilTag() throws XMLStreamException\n{\nString text = null;\nwhile (true) {\nswitch (_xmlReader.next()) {\ncase XMLStreamConstants.START_ELEMENT:\ncase XMLStreamConstants.END_ELEMENT:\ncase XMLStreamConstants.END_DOCUMENT:\nreturn text;\n// note: SPACE is ignorable (and seldom seen), not to be included\ncase XMLStreamConstants.CHARACTERS:\ncase XMLStreamConstants.CDATA:\nif (text == null) {\ntext = _xmlReader.getText();\n} else { // can be optimized in future, if need be:\ntext += _xmlReader.getText();\n}\nbreak;\ndefault:\n// any other type (proc instr, comment etc) is just ignored\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:_skipUntilTag()I",
                                    "method_body": "private final int _skipUntilTag() throws XMLStreamException\n{\nwhile (_xmlReader.hasNext()) {\nint type;\nswitch (type = _xmlReader.next()) {\ncase XMLStreamConstants.START_ELEMENT:\ncase XMLStreamConstants.END_ELEMENT:\ncase XMLStreamConstants.END_DOCUMENT:\nreturn type;\ndefault:\n// any other type (proc instr, comment etc) is just ignored\n}\n}\nthrow new IllegalStateException(\"Expected to find a tag, instead reached end of input\");\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:_initStartElement()I",
                                    "method_body": "private final int _initStartElement() throws XMLStreamException\n{\nfinal String ns = _xmlReader.getNamespaceURI();\nfinal String localName = _xmlReader.getLocalName();\n_attributeCount = _xmlReader.getAttributeCount();\n_nextAttributeIndex = 0;\n\n/* Support for virtual wrapping: in wrapping, may either\n* create a new wrapper scope (if in sub-tree, or matches\n* wrapper element itself), or implicitly close existing\n* scope.\n*/\nif (_currentWrapper != null) {\nif (_currentWrapper.matchesWrapper(localName, ns)) {\n_currentWrapper = _currentWrapper.intermediateWrapper();\n} else {\n// implicit end is more interesting:\n_localName = _currentWrapper.getWrapperLocalName();\n_namespaceURI = _currentWrapper.getWrapperNamespace();\n_currentWrapper = _currentWrapper.getParent();\n//System.out.println(\" START_ELEMENT (\"+localName+\") not matching '\"+_localName+\"'; add extra XML-END-ELEMENT!\");\n// Important! We also need to restore the START_ELEMENT, so:\n_nextLocalName = localName;\n_nextNamespaceURI = ns;\n_repeatElement = REPLAY_START_DELAYED;\nreturn (_currentState = XML_END_ELEMENT);\n}\n}\n_localName = localName;\n_namespaceURI = ns;\nreturn (_currentState = XML_START_ELEMENT);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:_handleEndElement()I",
                                    "method_body": "private final int _handleEndElement()\n{\nif (_currentWrapper != null) {\nElementWrapper w = _currentWrapper;\n// important: if we close the scope, must duplicate END_ELEMENT as well\nif (w.isMatching()) {\n_repeatElement = REPLAY_END;\n_localName = w.getWrapperLocalName();\n_namespaceURI = w.getWrapperNamespace();\n_currentWrapper = _currentWrapper.getParent();\n//System.out.println(\" IMPLICIT requestRepeat of END_ELEMENT '\"+_localName);\n} else {\n_currentWrapper = _currentWrapper.getParent();\n}\n}\nreturn (_currentState = XML_END_ELEMENT);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$1:<clinit>()V",
                                    "method_body": "public JsonToken nextToken() throws IOException\n{\n_binaryValue = null;\nif (_nextToken != null) {\nJsonToken t = _nextToken;\n_currToken = t;\n_nextToken = null;\nswitch (t) {\ncase START_OBJECT:\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nbreak;\ncase START_ARRAY:\n_parsingContext = _parsingContext.createChildArrayContext(-1, -1);\nbreak;\ncase END_OBJECT:\ncase END_ARRAY:\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nbreak;\ncase FIELD_NAME:\n_parsingContext.setCurrentName(_xmlTokens.getLocalName());\nbreak;\ndefault: // VALUE_STRING, VALUE_NULL\n// should be fine as is?\n}\nreturn t;\n}\nint token = _xmlTokens.next();\n\n// Need to have a loop just because we may have to eat/convert\n// a start-element that indicates an array element.\nwhile (token == XmlTokenStream.XML_START_ELEMENT) {\n// If we thought we might get leaf, no such luck\nif (_mayBeLeaf) {\n// leave _mayBeLeaf set, as we start a new context\n_nextToken = JsonToken.FIELD_NAME;\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\nif (_parsingContext.inArray()) {\n// Yup: in array, so this element could be verified; but it won't be\n// reported anyway, and we need to process following event.\ntoken = _xmlTokens.next();\n_mayBeLeaf = true;\ncontinue;\n}\nString name = _xmlTokens.getLocalName();\n_parsingContext.setCurrentName(name);\n\n// Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n// Couple of ways to do it; but start by making _xmlTokens replay the thing...\nif (_namesToWrap != null && _namesToWrap.contains(name)) {\n_xmlTokens.repeatStartElement();\n}\n\n_mayBeLeaf = true;\n// Ok: in array context we need to skip reporting field names.\n// But what's the best way to find next token?\nreturn (_currToken = JsonToken.FIELD_NAME);\n}\n\n// Ok; beyond start element, what do we get?\nwhile (true) {\nswitch (token) {\ncase XmlTokenStream.XML_END_ELEMENT:\n// Simple, except that if this is a leaf, need to suppress end:\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\nif (_parsingContext.inArray()) {\n// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n//    expose as empty Object, not null\n_nextToken = JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\nreturn (_currToken = JsonToken.VALUE_NULL);\n}\n_currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nreturn _currToken;\n\ncase XmlTokenStream.XML_ATTRIBUTE_NAME:\n// If there was a chance of leaf node, no more...\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n_nextToken = JsonToken.FIELD_NAME;\n_currText = _xmlTokens.getText();\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\n_parsingContext.setCurrentName(_xmlTokens.getLocalName());\nreturn (_currToken = JsonToken.FIELD_NAME);\ncase XmlTokenStream.XML_ATTRIBUTE_VALUE:\n_currText = _xmlTokens.getText();\nreturn (_currToken = JsonToken.VALUE_STRING);\ncase XmlTokenStream.XML_TEXT:\n_currText = _xmlTokens.getText();\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n// One more refinement (pronunced like \"hack\") is that if\n// we had an empty String (or all white space), and we are\n// deserializing an array, we better hide the empty text.\n// Also: must skip following END_ELEMENT\n_xmlTokens.skipEndElement();\nif (_parsingContext.inArray()) {\nif (_isEmpty(_currText)) {\n// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n//    expose as empty Object, not null (or, worse, as used to\n//    be done, by swallowing the token)\n_nextToken = JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\n}\nreturn (_currToken = JsonToken.VALUE_STRING);\n} else {\n// [dataformat-xml#177]: empty text may also need to be skipped\n// but... [dataformat-xml#191]: looks like we can't short-cut, must\n// loop over again\nif (_parsingContext.inObject()) {\nif ((_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\ntoken = _xmlTokens.next();\ncontinue;\n}\n}\n}\n// If not a leaf (or otherwise ignorable), need to transform into property...\n_parsingContext.setCurrentName(_cfgNameForTextElement);\n_nextToken = JsonToken.VALUE_STRING;\nreturn (_currToken = JsonToken.FIELD_NAME);\ncase XmlTokenStream.XML_END:\nreturn (_currToken = null);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.AnnotationUtil:findIsAttributeAnnotation(Lcom/fasterxml/jackson/databind/AnnotationIntrospector;Lcom/fasterxml/jackson/databind/introspect/AnnotatedMember;)Ljava/lang/Boolean;",
                                    "method_body": "public static Boolean findIsAttributeAnnotation(AnnotationIntrospector ai,\nAnnotatedMember prop)\n{\nfor (AnnotationIntrospector intr : ai.allIntrospectors()) {\nif (intr instanceof XmlAnnotationIntrospector) {\nBoolean b = ((XmlAnnotationIntrospector) intr).isOutputAsAttribute(prop);\nif (b != null) {\nreturn b;\n}\n} else  if (intr instanceof JaxbAnnotationIntrospector) {\nBoolean b = ((JaxbAnnotationIntrospector) intr).isOutputAsAttribute(prop);\nif (b != null) {\nreturn b;\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.AnnotationUtil:findIsTextAnnotation(Lcom/fasterxml/jackson/databind/AnnotationIntrospector;Lcom/fasterxml/jackson/databind/introspect/AnnotatedMember;)Ljava/lang/Boolean;",
                                    "method_body": "public static Boolean findIsTextAnnotation(AnnotationIntrospector ai,\nAnnotatedMember prop)\n{\nfor (AnnotationIntrospector intr : ai.allIntrospectors()) {\nif (intr instanceof XmlAnnotationIntrospector) {\nBoolean b = ((XmlAnnotationIntrospector) intr).isOutputAsText(prop);\nif (b != null) {\nreturn b;\n}\n} else  if (intr instanceof JaxbAnnotationIntrospector) {\nBoolean b = ((JaxbAnnotationIntrospector) intr).isOutputAsText(prop);\nif (b != null) {\nreturn b;\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.WrapperHandlingDeserializer:<init>(Lcom/fasterxml/jackson/databind/deser/BeanDeserializerBase;)V",
                                    "method_body": "public WrapperHandlingDeserializer(BeanDeserializerBase delegate) {\nthis(delegate, null);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.WrapperHandlingDeserializer:<init>(Lcom/fasterxml/jackson/databind/deser/BeanDeserializerBase;Ljava/util/Set;)V",
                                    "method_body": "public WrapperHandlingDeserializer(BeanDeserializerBase delegate, Set<String> namesToWrap)\n{\nsuper(delegate);\n_namesToWrap = namesToWrap;\n_type = delegate.getValueType();\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.WrapperHandlingDeserializer:createContextual(Lcom/fasterxml/jackson/databind/DeserializationContext;Lcom/fasterxml/jackson/databind/BeanProperty;)Lcom/fasterxml/jackson/databind/JsonDeserializer;",
                                    "method_body": "public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\nBeanProperty property)\nthrows JsonMappingException\n{\n// !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n//    out for 2.5 just to increase compatibility slightly with 2.4 databind\n/*\nJavaType vt = _type;\nif (vt == null) {\nvt = ctxt.constructType(_delegatee.handledType());\n}\nJsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n*/\n\nJsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\nBeanDeserializerBase newDelegatee = _verifyDeserType(del);\n\n// Let's go through the properties now...\nIterator<SettableBeanProperty> it = newDelegatee.properties();\nHashSet<String> unwrappedNames = null;\nwhile (it.hasNext()) {\nSettableBeanProperty prop = it.next();\n/* First things first: only consider array/Collection types\n* (not perfect check, but simplest reasonable check)\n*/\nJavaType type = prop.getType();\nif (!TypeUtil.isIndexedType(type)) {\ncontinue;\n}\nPropertyName wrapperName = prop.getWrapperName();\n// skip anything with wrapper (should work as is)\nif (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\ncontinue;\n}\nif (unwrappedNames == null) {\nunwrappedNames = new HashSet<String>();\n}\n// not optimal; should be able to use PropertyName...\nunwrappedNames.add(prop.getName());\n}\n// Ok: if nothing to take care of, just return the delegatee...\nif (unwrappedNames == null) {\nreturn newDelegatee;\n}\n// Otherwise, create the thing that can deal with virtual wrapping\nreturn new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.WrapperHandlingDeserializer:_verifyDeserType(Lcom/fasterxml/jackson/databind/JsonDeserializer;)Lcom/fasterxml/jackson/databind/deser/BeanDeserializerBase;",
                                    "method_body": "protected BeanDeserializerBase _verifyDeserType(JsonDeserializer<?> deser)\n{\nif (!(deser instanceof BeanDeserializerBase)) {\nthrow new IllegalArgumentException(\"Can not change delegate to be of type \"\n+deser.getClass().getName());\n}\nreturn (BeanDeserializerBase) deser;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.TypeUtil:isIndexedType(Lcom/fasterxml/jackson/databind/JavaType;)Z",
                                    "method_body": "public static boolean isIndexedType(JavaType type)\n{\nif (type.isContainerType()) {\nClass<?> cls = type.getRawClass();\n// One special case; byte[] will be serialized as base64-encoded String, not real array, so:\n// (actually, ditto for char[]; thought to be a String)\nif (cls == byte[].class || cls == char[].class) {\nreturn false;\n}\n// issue#5: also, should not add wrapping for Maps\nif (Map.class.isAssignableFrom(cls)) {\nreturn false;\n}\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTextDeserializer:<init>(Lcom/fasterxml/jackson/databind/deser/BeanDeserializerBase;Lcom/fasterxml/jackson/databind/deser/SettableBeanProperty;)V",
                                    "method_body": "public XmlTextDeserializer(BeanDeserializerBase delegate, SettableBeanProperty prop)\n{\nsuper(delegate);\n_xmlTextProperty = prop;\n_xmlTextPropertyIndex = prop.getPropertyIndex();\n_valueInstantiator = delegate.getValueInstantiator();\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTextDeserializer:<init>(Lcom/fasterxml/jackson/databind/deser/BeanDeserializerBase;I)V",
                                    "method_body": "public XmlTextDeserializer(BeanDeserializerBase delegate, int textPropIndex)\n{\nsuper(delegate);\n_xmlTextPropertyIndex = textPropIndex;\n_valueInstantiator = delegate.getValueInstantiator();\n_xmlTextProperty = delegate.findProperty(textPropIndex);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTextDeserializer:createContextual(Lcom/fasterxml/jackson/databind/DeserializationContext;Lcom/fasterxml/jackson/databind/BeanProperty;)Lcom/fasterxml/jackson/databind/JsonDeserializer;",
                                    "method_body": "public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\nBeanProperty property)\nthrows JsonMappingException\n{\nreturn new XmlTextDeserializer(_verifyDeserType(_delegatee), _xmlTextPropertyIndex);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTextDeserializer:deserialize(Lcom/fasterxml/jackson/core/JsonParser;Lcom/fasterxml/jackson/databind/DeserializationContext;)Ljava/lang/Object;",
                                    "method_body": "public Object deserialize(JsonParser jp, DeserializationContext ctxt)\nthrows IOException, JsonProcessingException\n{\nif (jp.getCurrentToken() == JsonToken.VALUE_STRING) {\nObject bean = _valueInstantiator.createUsingDefault(ctxt);\n_xmlTextProperty.deserializeAndSet(jp, ctxt, bean);\nreturn bean;\n}\nreturn _delegatee.deserialize(jp,  ctxt);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTextDeserializer:_verifyDeserType(Lcom/fasterxml/jackson/databind/JsonDeserializer;)Lcom/fasterxml/jackson/databind/deser/BeanDeserializerBase;",
                                    "method_body": "protected BeanDeserializerBase _verifyDeserType(JsonDeserializer<?> deser)\n{\nif (!(deser instanceof BeanDeserializerBase)) {\nthrow new IllegalArgumentException(\"Can not change delegate to be of type \"\n+deser.getClass().getName());\n}\nreturn (BeanDeserializerBase) deser;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 3,
                    "tests": [
                        {
                            "test_name": "com.fasterxml.jackson.dataformat.xml.stream.XmlParserNextXxxTest.testXmlAttributesWithNextTextValue",
                            "test_body": "public void testXmlAttributesWithNextTextValue() throws Exception\n{\nfinal String XML = \"<data max=\\\"7\\\" offset=\\\"9\\\"/>\";\nFromXmlParser xp = (FromXmlParser) _xmlFactory.createParser(new StringReader(XML));\n// First: verify handling without forcing array handling:\nassertToken(JsonToken.START_OBJECT, xp.nextToken()); // <data>\nassertToken(JsonToken.FIELD_NAME, xp.nextToken()); // <max>\nassertEquals(\"max\", xp.getCurrentName());\nassertEquals(\"7\", xp.nextTextValue());\nassertToken(JsonToken.FIELD_NAME, xp.nextToken()); // <offset>\nassertEquals(\"offset\", xp.getCurrentName());\nassertEquals(\"offset\", xp.getText());\nassertEquals(\"9\", xp.nextTextValue());\nassertEquals(\"9\", xp.getText());\nassertToken(JsonToken.END_OBJECT, xp.nextToken()); // </data>\nxp.close();\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>()V",
                                    "method_body": "public XmlFactory() { this(null, null, null); }\npublic XmlFactory() { this(null, null, null); }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>(Lcom/fasterxml/jackson/core/ObjectCodec;Ljavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;)V",
                                    "method_body": "public XmlFactory(ObjectCodec oc, XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n{\nthis(oc, DEFAULT_XML_PARSER_FEATURE_FLAGS, DEFAULT_XML_GENERATOR_FEATURE_FLAGS,\nxmlIn, xmlOut, null);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>(Lcom/fasterxml/jackson/core/ObjectCodec;IILjavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;Ljava/lang/String;)V",
                                    "method_body": "protected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\nXMLInputFactory xmlIn, XMLOutputFactory xmlOut,\nString nameForTextElem)\n{\nsuper(oc);\n_xmlParserFeatures = xpFeatures;\n_xmlGeneratorFeatures = xgFeatures;\n_cfgNameForTextElement = nameForTextElem;\nif (xmlIn == null) {\nxmlIn = XMLInputFactory.newInstance();\n// as per [dataformat-xml#190], disable external entity expansion by default\nxmlIn.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\n}\nif (xmlOut == null) {\nxmlOut = XMLOutputFactory.newInstance();\n}\n_initFactories(xmlIn, xmlOut);\n_xmlInputFactory = xmlIn;\n_xmlOutputFactory = xmlOut;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<clinit>()V",
                                    "method_body": "public final static String FORMAT_NAME_XML = \"XML\";\n\n/**\n* Bitfield (set of flags) of all parser features that are enabled\n* by default.\n*/\nfinal static int DEFAULT_XML_PARSER_FEATURE_FLAGS = FromXmlParser.Feature.collectDefaults();\n\n/**\n* Bitfield (set of flags) of all generator features that are enabled\n* by default.\n*/\nfinal static int DEFAULT_XML_GENERATOR_FEATURE_FLAGS = ToXmlGenerator.Feature.collectDefaults();\n\n/*\n/**********************************************************\n/* Configuration\n/**********************************************************\n*/\n\nprotected int _xmlParserFeatures;\n\nprotected int _xmlGeneratorFeatures;\n\n// non-final for setters (why are they needed again?)\nprotected transient XMLInputFactory _xmlInputFactory;\n\nprotected transient XMLOutputFactory _xmlOutputFactory;\n\nprotected String _cfgNameForTextElement;\n\n/*\n/**********************************************************\n/* Factory construction, configuration\n/**********************************************************\n*/\n\n/**\n* Default constructor used to create factory instances.\n* Creation of a factory instance is a light-weight operation,\n* but it is still a good idea to reuse limited number of\n* factory instances (and quite often just a single instance):\n* factories are used as context for storing some reused\n* processing objects (such as symbol tables parsers use)\n* and this reuse only works within context of a single\n* factory instance.\n*/\npublic XmlFactory() { this(null, null, null); }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_initFactories(Ljavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;)V",
                                    "method_body": "protected void _initFactories(XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n{\n// Better ensure namespaces get built properly, so:\nxmlOut.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\n// and for parser, force coalescing as well (much simpler to use)\nxmlIn.setProperty(XMLInputFactory.IS_COALESCING, Boolean.TRUE);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_createParser(Ljava/io/Reader;Lcom/fasterxml/jackson/core/io/IOContext;)Lcom/fasterxml/jackson/dataformat/xml/deser/FromXmlParser;",
                                    "method_body": "protected FromXmlParser _createParser(Reader r, IOContext ctxt) throws IOException\n{\nXMLStreamReader sr;\ntry {\nsr = _xmlInputFactory.createXMLStreamReader(r);\nsr = _initializeXmlReader(sr);\n} catch (XMLStreamException e) {\nreturn StaxUtil.throwXmlAsIOException(e);\n}\nFromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n_objectCodec, sr);\nif (_cfgNameForTextElement != null) {\nxp.setXMLTextElementName(_cfgNameForTextElement);\n}\nreturn xp;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_initializeXmlReader(Ljavax/xml/stream/XMLStreamReader;)Ljavax/xml/stream/XMLStreamReader;",
                                    "method_body": "protected final XMLStreamReader _initializeXmlReader(XMLStreamReader sr) throws IOException, XMLStreamException\n{\n// for now, nothing to do... except let's find the root element\nwhile (sr.next() != XMLStreamConstants.START_ELEMENT) {\n;\n}\nreturn sr;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature:<clinit>()V",
                                    "method_body": "public final static String DEFAULT_UNNAMED_TEXT_PROPERTY = \"\";\n\n/**\n* Enumeration that defines all togglable features for XML parsers.\n* None defined so far (2.6), so just a placeholder.\n*/\npublic enum Feature implements FormatFeature\n{\n;\n\nfinal boolean _defaultState;\nfinal int _mask;\n\n/**\n* Method that calculates bit set (flags) of all features that\n* are enabled by default.\n*/\npublic static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}\n\nprivate Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}\n\n@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public int getMask() { return _mask; }\n@Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature:collectDefaults()I",
                                    "method_body": "public static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:<init>(Ljava/lang/String;IZ)V",
                                    "method_body": "private Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:<clinit>()V",
                                    "method_body": "protected final static String DEFAULT_UNKNOWN_ELEMENT = \"unknown\";\n\n/**\n* Enumeration that defines all togglable extra XML-specific features\n*/\npublic enum Feature implements FormatFeature\n{\n/**\n* Feature that controls whether XML declaration should be written before\n* when generator is initialized (true) or not (false)\n*/\nWRITE_XML_DECLARATION(false),\n\n/**\n* Feature that controls whether output should be done as XML 1.1; if so,\n* certain aspects may differ from default (1.0) processing: for example,\n* XML declaration will be automatically added (regardless of setting\n* <code>WRITE_XML_DECLARATION</code>) as this is required for reader to\n* know to use 1.1 compliant handling. XML 1.1 can be used to allow quoted\n* control characters (Ascii codes 0 through 31) as well as additional linefeeds\n* and name characters.\n*/\nWRITE_XML_1_1(false)\n;\n\nfinal boolean _defaultState;\nfinal int _mask;\n\n/**\n* Method that calculates bit set (flags) of all features that\n* are enabled by default.\n*/\npublic static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}\n\nprivate Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}\n\n@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public int getMask() { return _mask; }\n@Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:collectDefaults()I",
                                    "method_body": "public static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:enabledByDefault()Z",
                                    "method_body": "@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public boolean enabledByDefault() { return _defaultState; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:<init>(Lcom/fasterxml/jackson/core/io/IOContext;IILcom/fasterxml/jackson/core/ObjectCodec;Ljavax/xml/stream/XMLStreamReader;)V",
                                    "method_body": "public FromXmlParser(IOContext ctxt, int genericParserFeatures, int xmlFeatures,\nObjectCodec codec, XMLStreamReader xmlReader)\n{\nsuper(genericParserFeatures);\n_formatFeatures = xmlFeatures;\n_ioContext = ctxt;\n_objectCodec = codec;\n_parsingContext = XmlReadContext.createRootContext(-1, -1);\n// and thereby start a scope\n_nextToken = JsonToken.START_OBJECT;\n_xmlTokens = new XmlTokenStream(xmlReader, ctxt.getSourceReference());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:getCurrentName()Ljava/lang/String;",
                                    "method_body": "public String getCurrentName() throws IOException\n{\n// start markers require information from parent\nString name;\nif (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\nXmlReadContext parent = _parsingContext.getParent();\nname = parent.getCurrentName();\n} else {\nname = _parsingContext.getCurrentName();\n}\n// sanity check\nif (name == null) {\nthrow new IllegalStateException(\"Missing name, in state: \"+_currToken);\n}\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:nextToken()Lcom/fasterxml/jackson/core/JsonToken;",
                                    "method_body": "public JsonToken nextToken() throws IOException\n{\n_binaryValue = null;\nif (_nextToken != null) {\nJsonToken t = _nextToken;\n_currToken = t;\n_nextToken = null;\nswitch (t) {\ncase START_OBJECT:\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nbreak;\ncase START_ARRAY:\n_parsingContext = _parsingContext.createChildArrayContext(-1, -1);\nbreak;\ncase END_OBJECT:\ncase END_ARRAY:\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nbreak;\ncase FIELD_NAME:\n_parsingContext.setCurrentName(_xmlTokens.getLocalName());\nbreak;\ndefault: // VALUE_STRING, VALUE_NULL\n// should be fine as is?\n}\nreturn t;\n}\nint token = _xmlTokens.next();\n\n// Need to have a loop just because we may have to eat/convert\n// a start-element that indicates an array element.\nwhile (token == XmlTokenStream.XML_START_ELEMENT) {\n// If we thought we might get leaf, no such luck\nif (_mayBeLeaf) {\n// leave _mayBeLeaf set, as we start a new context\n_nextToken = JsonToken.FIELD_NAME;\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\nif (_parsingContext.inArray()) {\n// Yup: in array, so this element could be verified; but it won't be\n// reported anyway, and we need to process following event.\ntoken = _xmlTokens.next();\n_mayBeLeaf = true;\ncontinue;\n}\nString name = _xmlTokens.getLocalName();\n_parsingContext.setCurrentName(name);\n\n// Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n// Couple of ways to do it; but start by making _xmlTokens replay the thing...\nif (_namesToWrap != null && _namesToWrap.contains(name)) {\n_xmlTokens.repeatStartElement();\n}\n\n_mayBeLeaf = true;\n// Ok: in array context we need to skip reporting field names.\n// But what's the best way to find next token?\nreturn (_currToken = JsonToken.FIELD_NAME);\n}\n\n// Ok; beyond start element, what do we get?\nwhile (true) {\nswitch (token) {\ncase XmlTokenStream.XML_END_ELEMENT:\n// Simple, except that if this is a leaf, need to suppress end:\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\nif (_parsingContext.inArray()) {\n// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n//    expose as empty Object, not null\n_nextToken = JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\nreturn (_currToken = JsonToken.VALUE_NULL);\n}\n_currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nreturn _currToken;\n\ncase XmlTokenStream.XML_ATTRIBUTE_NAME:\n// If there was a chance of leaf node, no more...\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n_nextToken = JsonToken.FIELD_NAME;\n_currText = _xmlTokens.getText();\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\n_parsingContext.setCurrentName(_xmlTokens.getLocalName());\nreturn (_currToken = JsonToken.FIELD_NAME);\ncase XmlTokenStream.XML_ATTRIBUTE_VALUE:\n_currText = _xmlTokens.getText();\nreturn (_currToken = JsonToken.VALUE_STRING);\ncase XmlTokenStream.XML_TEXT:\n_currText = _xmlTokens.getText();\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n// One more refinement (pronunced like \"hack\") is that if\n// we had an empty String (or all white space), and we are\n// deserializing an array, we better hide the empty text.\n// Also: must skip following END_ELEMENT\n_xmlTokens.skipEndElement();\nif (_parsingContext.inArray()) {\nif (_isEmpty(_currText)) {\n// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n//    expose as empty Object, not null (or, worse, as used to\n//    be done, by swallowing the token)\n_nextToken = JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\n}\nreturn (_currToken = JsonToken.VALUE_STRING);\n} else {\n// [dataformat-xml#177]: empty text may also need to be skipped\n// but... [dataformat-xml#191]: looks like we can't short-cut, must\n// loop over again\nif (_parsingContext.inObject()) {\nif ((_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\ntoken = _xmlTokens.next();\ncontinue;\n}\n}\n}\n// If not a leaf (or otherwise ignorable), need to transform into property...\n_parsingContext.setCurrentName(_cfgNameForTextElement);\n_nextToken = JsonToken.VALUE_STRING;\nreturn (_currToken = JsonToken.FIELD_NAME);\ncase XmlTokenStream.XML_END:\nreturn (_currToken = null);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:nextTextValue()Ljava/lang/String;",
                                    "method_body": "public String nextTextValue() throws IOException\n{\n_binaryValue = null;\nif (_nextToken != null) {\nJsonToken t = _nextToken;\n_currToken = t;\n_nextToken = null;\n\n// expected case; yes, got a String\nif (t == JsonToken.VALUE_STRING) {\nreturn _currText;\n}\n_updateState(t);\nreturn null;\n}\n\nint token = _xmlTokens.next();\n\n// mostly copied from 'nextToken()'\nwhile (token == XmlTokenStream.XML_START_ELEMENT) {\nif (_mayBeLeaf) {\n_nextToken = JsonToken.FIELD_NAME;\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n_currToken = JsonToken.START_OBJECT;\nreturn null;\n}\nif (_parsingContext.inArray()) {\ntoken = _xmlTokens.next();\n_mayBeLeaf = true;\ncontinue;\n}\nString name = _xmlTokens.getLocalName();\n_parsingContext.setCurrentName(name);\nif (_namesToWrap != null && _namesToWrap.contains(name)) {\n_xmlTokens.repeatStartElement();\n}\n_mayBeLeaf = true;\n_currToken = JsonToken.FIELD_NAME;\nreturn null;\n}\n\n// Ok; beyond start element, what do we get?\nswitch (token) {\ncase XmlTokenStream.XML_END_ELEMENT:\nif (_mayBeLeaf) {\n// NOTE: this is different from nextToken() -- produce \"\", NOT null\n_mayBeLeaf = false;\n_currToken = JsonToken.VALUE_STRING;\nreturn (_currText = \"\");\n}\n_currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nbreak;\ncase XmlTokenStream.XML_ATTRIBUTE_NAME:\n// If there was a chance of leaf node, no more...\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n_nextToken = JsonToken.FIELD_NAME;\n_currText = _xmlTokens.getText();\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n_currToken = JsonToken.START_OBJECT;\n} else {\n_parsingContext.setCurrentName(_xmlTokens.getLocalName());\n_currToken = JsonToken.FIELD_NAME;\n}\nbreak;\ncase XmlTokenStream.XML_ATTRIBUTE_VALUE:\n_currText = _xmlTokens.getText();\n_currToken = JsonToken.VALUE_STRING;\nbreak;\ncase XmlTokenStream.XML_TEXT:\n_currText = _xmlTokens.getText();\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n// Also: must skip following END_ELEMENT\n_xmlTokens.skipEndElement();\n\n// NOTE: this is different from nextToken() -- NO work-around\n// for otherwise empty List/array\n_currToken = JsonToken.VALUE_STRING;\nreturn _currText;\n}\n// If not a leaf, need to transform into property...\n_parsingContext.setCurrentName(_cfgNameForTextElement);\n_nextToken = JsonToken.VALUE_STRING;\n_currToken = JsonToken.FIELD_NAME;\nbreak;\ncase XmlTokenStream.XML_END:\n_currToken = null;\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:<init>(Lcom/fasterxml/jackson/dataformat/xml/deser/XmlReadContext;III)V",
                                    "method_body": "public XmlReadContext(XmlReadContext parent, int type, int lineNr, int colNr)\n{\nsuper();\n_type = type;\n_parent = parent;\n_lineNr = lineNr;\n_columnNr = colNr;\n_index = -1;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:createRootContext(II)Lcom/fasterxml/jackson/dataformat/xml/deser/XmlReadContext;",
                                    "method_body": "public static XmlReadContext createRootContext(int lineNr, int colNr) {\nreturn new XmlReadContext(null, TYPE_ROOT, lineNr, colNr);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:createChildObjectContext(II)Lcom/fasterxml/jackson/dataformat/xml/deser/XmlReadContext;",
                                    "method_body": "public final XmlReadContext createChildObjectContext(int lineNr, int colNr)\n{\nXmlReadContext ctxt = _child;\nif (ctxt == null) {\n_child = ctxt = new XmlReadContext(this, TYPE_OBJECT, lineNr, colNr);\nreturn ctxt;\n}\nctxt.reset(TYPE_OBJECT, lineNr, colNr);\nreturn ctxt;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:getCurrentName()Ljava/lang/String;",
                                    "method_body": "public final String getCurrentName() { return _currentName; }\npublic final String getCurrentName() { return _currentName; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:setCurrentName(Ljava/lang/String;)V",
                                    "method_body": "public void setCurrentName(String name) {\n_currentName = name;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:<init>(Ljavax/xml/stream/XMLStreamReader;Ljava/lang/Object;)V",
                                    "method_body": "public XmlTokenStream(XMLStreamReader xmlReader, Object sourceRef)\n{\n_sourceReference = sourceRef;\n// Let's ensure we point to START_ELEMENT...\nif (xmlReader.getEventType() != XMLStreamConstants.START_ELEMENT) {\nthrow new IllegalArgumentException(\"Invalid XMLStreamReader passed: should be pointing to START_ELEMENT (\"\n+XMLStreamConstants.START_ELEMENT+\"), instead got \"+xmlReader.getEventType());\n}\n_xmlReader = Stax2ReaderAdapter.wrapIfNecessary(xmlReader);\n_currentState = XML_START_ELEMENT;\n_localName = _xmlReader.getLocalName();\n_namespaceURI = _xmlReader.getNamespaceURI();\n_attributeCount = _xmlReader.getAttributeCount();\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:next()I",
                                    "method_body": "public int next() throws IOException\n{\nif (_repeatElement != 0) {\nreturn (_currentState = _handleRepeatElement());\n}\ntry {\nreturn _next();\n} catch (XMLStreamException e) {\nStaxUtil.throwXmlAsIOException(e);\nreturn -1;\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:getText()Ljava/lang/String;",
                                    "method_body": "public String getText() { return _textValue; }\npublic String getText() { return _textValue; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:getLocalName()Ljava/lang/String;",
                                    "method_body": "public String getLocalName() { return _localName; }\npublic String getLocalName() { return _localName; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:_next()I",
                                    "method_body": "private final int _next() throws XMLStreamException\n{\nswitch (_currentState) {\ncase XML_ATTRIBUTE_VALUE:\n++_nextAttributeIndex;\n// fall through\ncase XML_START_ELEMENT: // attributes to return?\nif (_nextAttributeIndex < _attributeCount) {\n_localName = _xmlReader.getAttributeLocalName(_nextAttributeIndex);\n_namespaceURI = _xmlReader.getAttributeNamespace(_nextAttributeIndex);\n_textValue = _xmlReader.getAttributeValue(_nextAttributeIndex);\nreturn (_currentState = XML_ATTRIBUTE_NAME);\n}\n// otherwise need to find START/END_ELEMENT or text\nString text = _collectUntilTag();\n// If it's START_ELEMENT, ignore any text\nif (_xmlReader.getEventType() == XMLStreamReader.START_ELEMENT) {\nreturn _initStartElement();\n}\n// For END_ELEMENT we will return text, if any\nif (text != null) {\n_textValue = text;\nreturn (_currentState = XML_TEXT);\n}\nreturn _handleEndElement();\ncase XML_ATTRIBUTE_NAME:\n// if we just returned name, will need to just send value next\nreturn (_currentState = XML_ATTRIBUTE_VALUE);\ncase XML_TEXT:\n// text is always followed by END_ELEMENT\nreturn _handleEndElement();\ncase XML_END:\nreturn XML_END;\n//            throw new IllegalStateException(\"No more XML tokens available (end of input)\");\n}\n\n// Ok: must be END_ELEMENT; see what tag we get (or end)\nswitch (_skipUntilTag()) {\ncase XMLStreamConstants.END_DOCUMENT:\nreturn (_currentState = XML_END);\ncase XMLStreamConstants.END_ELEMENT:\nreturn _handleEndElement();\n}\n// START_ELEMENT...\nreturn _initStartElement();\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$1:<clinit>()V",
                                    "method_body": "public JsonToken nextToken() throws IOException\n{\n_binaryValue = null;\nif (_nextToken != null) {\nJsonToken t = _nextToken;\n_currToken = t;\n_nextToken = null;\nswitch (t) {\ncase START_OBJECT:\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nbreak;\ncase START_ARRAY:\n_parsingContext = _parsingContext.createChildArrayContext(-1, -1);\nbreak;\ncase END_OBJECT:\ncase END_ARRAY:\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nbreak;\ncase FIELD_NAME:\n_parsingContext.setCurrentName(_xmlTokens.getLocalName());\nbreak;\ndefault: // VALUE_STRING, VALUE_NULL\n// should be fine as is?\n}\nreturn t;\n}\nint token = _xmlTokens.next();\n\n// Need to have a loop just because we may have to eat/convert\n// a start-element that indicates an array element.\nwhile (token == XmlTokenStream.XML_START_ELEMENT) {\n// If we thought we might get leaf, no such luck\nif (_mayBeLeaf) {\n// leave _mayBeLeaf set, as we start a new context\n_nextToken = JsonToken.FIELD_NAME;\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\nif (_parsingContext.inArray()) {\n// Yup: in array, so this element could be verified; but it won't be\n// reported anyway, and we need to process following event.\ntoken = _xmlTokens.next();\n_mayBeLeaf = true;\ncontinue;\n}\nString name = _xmlTokens.getLocalName();\n_parsingContext.setCurrentName(name);\n\n// Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n// Couple of ways to do it; but start by making _xmlTokens replay the thing...\nif (_namesToWrap != null && _namesToWrap.contains(name)) {\n_xmlTokens.repeatStartElement();\n}\n\n_mayBeLeaf = true;\n// Ok: in array context we need to skip reporting field names.\n// But what's the best way to find next token?\nreturn (_currToken = JsonToken.FIELD_NAME);\n}\n\n// Ok; beyond start element, what do we get?\nwhile (true) {\nswitch (token) {\ncase XmlTokenStream.XML_END_ELEMENT:\n// Simple, except that if this is a leaf, need to suppress end:\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\nif (_parsingContext.inArray()) {\n// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n//    expose as empty Object, not null\n_nextToken = JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\nreturn (_currToken = JsonToken.VALUE_NULL);\n}\n_currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nreturn _currToken;\n\ncase XmlTokenStream.XML_ATTRIBUTE_NAME:\n// If there was a chance of leaf node, no more...\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n_nextToken = JsonToken.FIELD_NAME;\n_currText = _xmlTokens.getText();\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\n_parsingContext.setCurrentName(_xmlTokens.getLocalName());\nreturn (_currToken = JsonToken.FIELD_NAME);\ncase XmlTokenStream.XML_ATTRIBUTE_VALUE:\n_currText = _xmlTokens.getText();\nreturn (_currToken = JsonToken.VALUE_STRING);\ncase XmlTokenStream.XML_TEXT:\n_currText = _xmlTokens.getText();\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n// One more refinement (pronunced like \"hack\") is that if\n// we had an empty String (or all white space), and we are\n// deserializing an array, we better hide the empty text.\n// Also: must skip following END_ELEMENT\n_xmlTokens.skipEndElement();\nif (_parsingContext.inArray()) {\nif (_isEmpty(_currText)) {\n// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n//    expose as empty Object, not null (or, worse, as used to\n//    be done, by swallowing the token)\n_nextToken = JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\n}\nreturn (_currToken = JsonToken.VALUE_STRING);\n} else {\n// [dataformat-xml#177]: empty text may also need to be skipped\n// but... [dataformat-xml#191]: looks like we can't short-cut, must\n// loop over again\nif (_parsingContext.inObject()) {\nif ((_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\ntoken = _xmlTokens.next();\ncontinue;\n}\n}\n}\n// If not a leaf (or otherwise ignorable), need to transform into property...\n_parsingContext.setCurrentName(_cfgNameForTextElement);\n_nextToken = JsonToken.VALUE_STRING;\nreturn (_currToken = JsonToken.FIELD_NAME);\ncase XmlTokenStream.XML_END:\nreturn (_currToken = null);\n}\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 4,
                    "tests": [
                        {
                            "test_name": "com.fasterxml.jackson.dataformat.xml.misc.RootNameTest.testDynamicRootName",
                            "test_body": "public void testDynamicRootName() throws IOException\n{\nString xml;\nObjectWriter w = _xmlMapper.writer().withRootName(\"rudy\");\nxml = w.writeValueAsString(new StringBean(\"foo\"));\nassertEquals(\"<rudy><text>foo</text></rudy>\", xml);\nxml = w.writeValueAsString(new StringBean(null));\nassertEquals(\"<rudy><text/></rudy>\", xml);\n// and even with null will respect configured root name\nxml = w.writeValueAsString(null);\nassertEquals(\"<rudy/>\", xml);\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<init>()V",
                                    "method_body": "public XmlMapper() {\nthis(new XmlFactory());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<init>(Lcom/fasterxml/jackson/dataformat/xml/XmlFactory;)V",
                                    "method_body": "public XmlMapper(XmlFactory xmlFactory) {\nthis(xmlFactory, DEFAULT_XML_MODULE);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<init>(Lcom/fasterxml/jackson/dataformat/xml/XmlFactory;Lcom/fasterxml/jackson/dataformat/xml/JacksonXmlModule;)V",
                                    "method_body": "public XmlMapper(XmlFactory xmlFactory, JacksonXmlModule module)\n{\n/* Need to override serializer provider (due to root name handling);\n* deserializer provider fine as is\n*/\nsuper(xmlFactory, new XmlSerializerProvider(new XmlRootNameLookup()), null);\n_xmlModule = module;\n// but all the rest is done via Module interface!\nif (module != null) {\nregisterModule(module);\n}\n// 19-May-2015, tatu: Must ensure we use XML-specific indenter\n_serializationConfig = _serializationConfig.withDefaultPrettyPrinter(DEFAULT_XML_PRETTY_PRINTER);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\nprotected final static JacksonXmlModule DEFAULT_XML_MODULE = new JacksonXmlModule();\n\nprotected final static DefaultXmlPrettyPrinter DEFAULT_XML_PRETTY_PRINTER = new DefaultXmlPrettyPrinter();\n\n// need to hold on to module instance just in case copy() is used\nprotected final JacksonXmlModule _xmlModule;\n\n/*\n/**********************************************************\n/* Life-cycle: construction, configuration\n/**********************************************************\n*/\n\npublic XmlMapper() {\nthis(new XmlFactory());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlModule:<init>()V",
                                    "method_body": "public JacksonXmlModule()\n{\nsuper(\"JacksonXmlModule\", PackageVersion.VERSION);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlModule:setupModule(Lcom/fasterxml/jackson/databind/Module$SetupContext;)V",
                                    "method_body": "public void setupModule(SetupContext context)\n{\n// Need to modify BeanDeserializer, BeanSerializer that are used\ncontext.addBeanSerializerModifier(new XmlBeanSerializerModifier());\ncontext.addBeanDeserializerModifier(new XmlBeanDeserializerModifier(_cfgNameForTextElement));\n\n// as well as AnnotationIntrospector\ncontext.insertAnnotationIntrospector(_constructIntrospector());\n\n// and finally inform XmlFactory about overrides, if need be:\nif (_cfgNameForTextElement != FromXmlParser.DEFAULT_UNNAMED_TEXT_PROPERTY) {\nXmlMapper m = (XmlMapper) context.getOwner();\nm.setXMLTextElementName(_cfgNameForTextElement);\n}\n\n/* Usually this would be the first call; but here anything added will\n* be stuff user may has added, so do it afterwards instead.\n*/\nsuper.setupModule(context);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlModule:_constructIntrospector()Lcom/fasterxml/jackson/databind/AnnotationIntrospector;",
                                    "method_body": "protected AnnotationIntrospector _constructIntrospector() {\nreturn new JacksonXmlAnnotationIntrospector(_cfgDefaultUseWrapper);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.PackageVersion:<clinit>()V",
                                    "method_body": "public final static Version VERSION = VersionUtil.parseVersion(\n\"2.8.5-SNAPSHOT\", \"com.fasterxml.jackson.dataformat\", \"jackson-dataformat-xml\");\n\n@Override\npublic Version version() {\nreturn VERSION;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter:<init>()V",
                                    "method_body": "public void writeIndentation(JsonGenerator g, int level) throws IOException;\n\npublic void writeIndentation(XMLStreamWriter2 sw, int level) throws XMLStreamException;\n\n/**\n* @return True if indenter is considered inline (does not add linefeeds),\n*   false otherwise\n*/\npublic boolean isInline();\n}\n\n/*\n/**********************************************************\n/* Configuration\n/**********************************************************\n*/\n\n/**\n* By default, let's use only spaces to separate array values.\n*/\nprotected Indenter _arrayIndenter = new FixedSpaceIndenter();\n\n/**\n* By default, let's use linefeed-adding indenter for separate\n* object entries. We'll further configure indenter to use\n* system-specific linefeeds, and 2 spaces per level (as opposed to,\n* say, single tabs)\n*/\nprotected Indenter _objectIndenter = new Lf2SpacesIndenter();\n\n// // // Config, other white space configuration\n\n/**\n* By default we will add spaces around colons used to\n* separate object fields and values.\n* If disabled, will not use spaces around colon.\n*/\nprotected boolean _spacesInObjectEntries = true;\n\n/*\n/**********************************************************\n/* State\n/**********************************************************\n*/\n\n/**\n* Number of open levels of nesting. Used to determine amount of\n* indentation to use.\n*/\nprotected transient int _nesting = 0;\n\n/**\n* Marker flag set on start element, and cleared if an end element\n* is encountered. Used for suppressing indentation to allow empty\n* elements.\n*\n* @since 2.3.0\n*/\nprotected transient boolean _justHadStartElement;\n\n/*\n/**********************************************************\n/* Life-cycle (construct, configure)\n/**********************************************************\n*/\n\npublic DefaultXmlPrettyPrinter() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter$FixedSpaceIndenter:<init>()V",
                                    "method_body": "public FixedSpaceIndenter() { }\npublic FixedSpaceIndenter() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter$Lf2SpacesIndenter:<init>()V",
                                    "method_body": "public Lf2SpacesIndenter() { }\npublic Lf2SpacesIndenter() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter$Lf2SpacesIndenter:<clinit>()V",
                                    "method_body": "final static int SPACE_COUNT = 64;\nfinal static char[] SPACES = new char[SPACE_COUNT];\nstatic {\nArrays.fill(SPACES, ' ');\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>()V",
                                    "method_body": "public XmlFactory() { this(null, null, null); }\npublic XmlFactory() { this(null, null, null); }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>(Lcom/fasterxml/jackson/core/ObjectCodec;Ljavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;)V",
                                    "method_body": "public XmlFactory(ObjectCodec oc, XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n{\nthis(oc, DEFAULT_XML_PARSER_FEATURE_FLAGS, DEFAULT_XML_GENERATOR_FEATURE_FLAGS,\nxmlIn, xmlOut, null);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>(Lcom/fasterxml/jackson/core/ObjectCodec;IILjavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;Ljava/lang/String;)V",
                                    "method_body": "protected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\nXMLInputFactory xmlIn, XMLOutputFactory xmlOut,\nString nameForTextElem)\n{\nsuper(oc);\n_xmlParserFeatures = xpFeatures;\n_xmlGeneratorFeatures = xgFeatures;\n_cfgNameForTextElement = nameForTextElem;\nif (xmlIn == null) {\nxmlIn = XMLInputFactory.newInstance();\n// as per [dataformat-xml#190], disable external entity expansion by default\nxmlIn.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\n// and ditto wrt [dataformat-xml#211], SUPPORT_DTD\nxmlIn.setProperty(XMLInputFactory.SUPPORT_DTD, Boolean.FALSE);\n}\nif (xmlOut == null) {\nxmlOut = XMLOutputFactory.newInstance();\n}\n_initFactories(xmlIn, xmlOut);\n_xmlInputFactory = xmlIn;\n_xmlOutputFactory = xmlOut;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<clinit>()V",
                                    "method_body": "public final static String FORMAT_NAME_XML = \"XML\";\n\n/**\n* Bitfield (set of flags) of all parser features that are enabled\n* by default.\n*/\nfinal static int DEFAULT_XML_PARSER_FEATURE_FLAGS = FromXmlParser.Feature.collectDefaults();\n\n/**\n* Bitfield (set of flags) of all generator features that are enabled\n* by default.\n*/\nfinal static int DEFAULT_XML_GENERATOR_FEATURE_FLAGS = ToXmlGenerator.Feature.collectDefaults();\n\n/*\n/**********************************************************\n/* Configuration\n/**********************************************************\n*/\n\nprotected int _xmlParserFeatures;\n\nprotected int _xmlGeneratorFeatures;\n\n// non-final for setters (why are they needed again?)\nprotected transient XMLInputFactory _xmlInputFactory;\n\nprotected transient XMLOutputFactory _xmlOutputFactory;\n\nprotected String _cfgNameForTextElement;\n\n/*\n/**********************************************************\n/* Factory construction, configuration\n/**********************************************************\n*/\n\n/**\n* Default constructor used to create factory instances.\n* Creation of a factory instance is a light-weight operation,\n* but it is still a good idea to reuse limited number of\n* factory instances (and quite often just a single instance):\n* factories are used as context for storing some reused\n* processing objects (such as symbol tables parsers use)\n* and this reuse only works within context of a single\n* factory instance.\n*/\npublic XmlFactory() { this(null, null, null); }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_initFactories(Ljavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;)V",
                                    "method_body": "protected void _initFactories(XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n{\n// Better ensure namespaces get built properly, so:\nxmlOut.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\n// and for parser, force coalescing as well (much simpler to use)\nxmlIn.setProperty(XMLInputFactory.IS_COALESCING, Boolean.TRUE);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:createGenerator(Ljava/io/Writer;)Lcom/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator;",
                                    "method_body": "public ToXmlGenerator createGenerator(Writer out) throws IOException\n{\nreturn new ToXmlGenerator(_createContext(out, false),\n_generatorFeatures, _xmlGeneratorFeatures,\n_objectCodec, _createXmlWriter(out));\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_createXmlWriter(Ljava/io/Writer;)Ljavax/xml/stream/XMLStreamWriter;",
                                    "method_body": "protected XMLStreamWriter _createXmlWriter(Writer w) throws IOException\n{\ntry {\nreturn _initializeXmlWriter(_xmlOutputFactory.createXMLStreamWriter(w));\n} catch (XMLStreamException e) {\nreturn StaxUtil.throwXmlAsIOException(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_initializeXmlWriter(Ljavax/xml/stream/XMLStreamWriter;)Ljavax/xml/stream/XMLStreamWriter;",
                                    "method_body": "protected final XMLStreamWriter _initializeXmlWriter(XMLStreamWriter sw) throws IOException, XMLStreamException\n{\n// And just for Sun Stax parser (JDK default), seems that we better define default namespace\n// (Woodstox doesn't care) -- otherwise it'll add unnecessary odd declaration\nsw.setDefaultNamespace(\"\");\nreturn sw;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature:<clinit>()V",
                                    "method_body": "public final static String DEFAULT_UNNAMED_TEXT_PROPERTY = \"\";\n\n/**\n* Enumeration that defines all togglable features for XML parsers.\n* None defined so far (2.6), so just a placeholder.\n*/\npublic enum Feature implements FormatFeature\n{\n;\n\nfinal boolean _defaultState;\nfinal int _mask;\n\n/**\n* Method that calculates bit set (flags) of all features that\n* are enabled by default.\n*/\npublic static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}\n\nprivate Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}\n\n@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public int getMask() { return _mask; }\n@Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature:collectDefaults()I",
                                    "method_body": "public static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:<init>(Ljava/lang/String;IZ)V",
                                    "method_body": "private Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:<clinit>()V",
                                    "method_body": "protected final static String DEFAULT_UNKNOWN_ELEMENT = \"unknown\";\n\n/**\n* Enumeration that defines all togglable extra XML-specific features\n*/\npublic enum Feature implements FormatFeature\n{\n/**\n* Feature that controls whether XML declaration should be written before\n* when generator is initialized (true) or not (false)\n*/\nWRITE_XML_DECLARATION(false),\n\n/**\n* Feature that controls whether output should be done as XML 1.1; if so,\n* certain aspects may differ from default (1.0) processing: for example,\n* XML declaration will be automatically added (regardless of setting\n* <code>WRITE_XML_DECLARATION</code>) as this is required for reader to\n* know to use 1.1 compliant handling. XML 1.1 can be used to allow quoted\n* control characters (Ascii codes 0 through 31) as well as additional linefeeds\n* and name characters.\n*/\nWRITE_XML_1_1(false)\n;\n\nfinal boolean _defaultState;\nfinal int _mask;\n\n/**\n* Method that calculates bit set (flags) of all features that\n* are enabled by default.\n*/\npublic static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}\n\nprivate Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}\n\n@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public int getMask() { return _mask; }\n@Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:collectDefaults()I",
                                    "method_body": "public static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:enabledByDefault()Z",
                                    "method_body": "@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public boolean enabledByDefault() { return _defaultState; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:getMask()I",
                                    "method_body": "@Override public int getMask() { return _mask; }\n@Override public int getMask() { return _mask; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:enabledIn(I)Z",
                                    "method_body": "@Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n@Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:<init>(Lcom/fasterxml/jackson/dataformat/xml/util/XmlRootNameLookup;)V",
                                    "method_body": "public XmlSerializerProvider(XmlRootNameLookup rootNames)\n{\nsuper();\n_rootNameLookup = rootNames;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:<init>(Lcom/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider;Lcom/fasterxml/jackson/databind/SerializationConfig;Lcom/fasterxml/jackson/databind/ser/SerializerFactory;)V",
                                    "method_body": "public XmlSerializerProvider(XmlSerializerProvider src,\nSerializationConfig config, SerializerFactory f)\n{\nsuper(src, config, f);\n_rootNameLookup  = src._rootNameLookup;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\n/**\n* If all we get to serialize is a null, there's no way to figure out\n* expected root name; so let's just default to something like \"&lt;null>\"...\n*/\nprotected final static QName ROOT_NAME_FOR_NULL = new QName(\"null\");\n\nprotected final XmlRootNameLookup _rootNameLookup;\n\npublic XmlSerializerProvider(XmlRootNameLookup rootNames)\n{\nsuper();\n_rootNameLookup = rootNames;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:createInstance(Lcom/fasterxml/jackson/databind/SerializationConfig;Lcom/fasterxml/jackson/databind/ser/SerializerFactory;)Lcom/fasterxml/jackson/databind/ser/DefaultSerializerProvider;",
                                    "method_body": "public DefaultSerializerProvider createInstance(SerializationConfig config,\nSerializerFactory jsf) {\nreturn new XmlSerializerProvider(this, config, jsf);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:serializeValue(Lcom/fasterxml/jackson/core/JsonGenerator;Ljava/lang/Object;)V",
                                    "method_body": "public void serializeValue(JsonGenerator gen, Object value) throws IOException\n{\nif (value == null) {\n_serializeXmlNull(gen);\nreturn;\n}\nfinal Class<?> cls = value.getClass();\nfinal boolean asArray;\nfinal ToXmlGenerator xgen = _asXmlGenerator(gen);\nif (xgen == null) { // called by convertValue()\nasArray = false;\n} else {\nQName rootName = _rootNameFromConfig();\nif (rootName == null) {\nrootName = _rootNameLookup.findRootName(cls, _config);\n}\n_initWithRootName(xgen, rootName);\nasArray = TypeUtil.isIndexedType(cls);\nif (asArray) {\n_startRootArray(xgen, rootName);\n}\n}\n\n// From super-class implementation\nfinal JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\ntry {\nser.serialize(value, gen, this);\n} catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\nthrow ioe;\n} catch (Exception e) { // but wrap RuntimeExceptions, to get path information\nString msg = e.getMessage();\nif (msg == null) {\nmsg = \"[no message for \"+e.getClass().getName()+\"]\";\n}\nthrow JsonMappingException.from(gen, msg, e);\n}\n// end of super-class implementation\n\nif (asArray) {\ngen.writeEndObject();\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:_serializeXmlNull(Lcom/fasterxml/jackson/core/JsonGenerator;)V",
                                    "method_body": "protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n{\n// 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n//    configured root name...\nif (jgen instanceof ToXmlGenerator) {\n_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n}\nsuper.serializeValue(jgen, null);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:_initWithRootName(Lcom/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator;Ljavax/xml/namespace/QName;)V",
                                    "method_body": "protected void _initWithRootName(ToXmlGenerator xgen, QName rootName) throws IOException\n{\n/* 28-Nov-2012, tatu: We should only initialize the root\n*  name if no name has been set, as per [dataformat-xml#42],\n*  to allow for custom serializers to work.\n*/\nif (!xgen.setNextNameIfMissing(rootName)) {\n// however, if we are root, we... insist\nif (xgen.inRoot()) {\nxgen.setNextName(rootName);\n}\n}\nxgen.initGenerator();\nString ns = rootName.getNamespaceURI();\n/* [dataformat-xml#26] If we just try writing root element with namespace,\n* we will get an explicit prefix. But we'd rather use the default\n* namespace, so let's try to force that.\n*/\nif (ns != null && ns.length() > 0) {\ntry {\nxgen.getStaxWriter().setDefaultNamespace(ns);\n} catch (XMLStreamException e) {\nStaxUtil.throwXmlAsIOException(e);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:_rootNameFromConfig()Ljavax/xml/namespace/QName;",
                                    "method_body": "protected QName _rootNameFromConfig()\n{\nPropertyName name = _config.getFullRootName();\nif (name == null) {\nreturn null;\n}\nString ns = name.getNamespace();\nif (ns == null || ns.isEmpty()) {\nreturn new QName(name.getSimpleName());\n}\nreturn new QName(ns, name.getSimpleName());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:_asXmlGenerator(Lcom/fasterxml/jackson/core/JsonGenerator;)Lcom/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator;",
                                    "method_body": "protected ToXmlGenerator _asXmlGenerator(JsonGenerator gen)\nthrows JsonMappingException\n{\n// [Issue#71]: When converting, we actually get TokenBuffer, which is fine\nif (!(gen instanceof ToXmlGenerator)) {\n// but verify\nif (!(gen instanceof TokenBuffer)) {\nthrow JsonMappingException.from(gen,\n\"XmlMapper does not with generators of type other than ToXmlGenerator; got: \"+gen.getClass().getName());\n}\nreturn null;\n}\nreturn (ToXmlGenerator) gen;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.XmlRootNameLookup:<init>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\n/**\n* For efficient operation, let's try to minimize number of times we\n* need to introspect root element name to use.\n*<p>\n* Note: changed to <code>transient</code> for 2.3; no point in serializing such\n* state\n*/\nprotected final transient LRUMap<ClassKey,QName> _rootNames = new LRUMap<ClassKey,QName>(40, 200);\n\npublic XmlRootNameLookup() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerModifier:<init>()V",
                                    "method_body": "public XmlBeanSerializerModifier() { }\npublic XmlBeanSerializerModifier() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerModifier:changeProperties(Lcom/fasterxml/jackson/databind/SerializationConfig;Lcom/fasterxml/jackson/databind/BeanDescription;Ljava/util/List;)Ljava/util/List;",
                                    "method_body": "public List<BeanPropertyWriter> changeProperties(SerializationConfig config,\nBeanDescription beanDesc, List<BeanPropertyWriter> beanProperties)\n{\nfinal AnnotationIntrospector intr = config.getAnnotationIntrospector();\nfor (int i = 0, len = beanProperties.size(); i < len; ++i) {\nBeanPropertyWriter bpw = beanProperties.get(i);\nfinal AnnotatedMember member = bpw.getMember();\nString ns = AnnotationUtil.findNamespaceAnnotation(intr, member);\nBoolean isAttribute = AnnotationUtil.findIsAttributeAnnotation(intr, member);\nBoolean isText = AnnotationUtil.findIsTextAnnotation(intr, member);\nBoolean isCData = AnnotationUtil.findIsCDataAnnotation(intr, member);\nbpw.setInternalSetting(XmlBeanSerializerBase.KEY_XML_INFO,\nnew XmlInfo(isAttribute, ns, isText, isCData));\n\n// Actually: if we have a Collection type, easiest place to add wrapping would be here...\n//  or: let's also allow wrapping of \"untyped\" (Object): assuming it is a dynamically\n//   typed Collection...\nif (!TypeUtil.isIndexedType(bpw.getType())) {\ncontinue;\n}\nPropertyName wrappedName = PropertyName.construct(bpw.getName(), ns);\nPropertyName wrapperName = bpw.getWrapperName();\n\n// first things first: no wrapping?\nif (wrapperName == null || wrapperName == PropertyName.NO_NAME) {\ncontinue;\n}\n// no local name? Just double the wrapped name for wrapper\nString localName = wrapperName.getSimpleName();\nif (localName == null || localName.length() == 0) {\nwrapperName = wrappedName;\n}\nbeanProperties.set(i, new XmlBeanPropertyWriter(bpw, wrapperName, wrappedName));\n}\nreturn beanProperties;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerModifier:modifySerializer(Lcom/fasterxml/jackson/databind/SerializationConfig;Lcom/fasterxml/jackson/databind/BeanDescription;Lcom/fasterxml/jackson/databind/JsonSerializer;)Lcom/fasterxml/jackson/databind/JsonSerializer;",
                                    "method_body": "public JsonSerializer<?> modifySerializer(SerializationConfig config,\nBeanDescription beanDesc, JsonSerializer<?> serializer)\n{\n/* First things first: we can only handle real BeanSerializers; question\n* is, what to do if it's not one: throw exception or bail out?\n* For now let's do latter.\n*/\nif (!(serializer instanceof BeanSerializerBase)) {\nreturn serializer;\n}\nreturn new XmlBeanSerializer((BeanSerializerBase) serializer);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlBeanDeserializerModifier:<init>(Ljava/lang/String;)V",
                                    "method_body": "public XmlBeanDeserializerModifier(String nameForTextValue)\n{\n_cfgNameForTextValue = nameForTextValue;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:<init>(Z)V",
                                    "method_body": "public JacksonXmlAnnotationIntrospector(boolean defaultUseWrapper) {\n_cfgDefaultUseWrapper = defaultUseWrapper;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:findWrapperName(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Lcom/fasterxml/jackson/databind/PropertyName;",
                                    "method_body": "public PropertyName findWrapperName(Annotated ann)\n{\nJacksonXmlElementWrapper w = ann.getAnnotation(JacksonXmlElementWrapper.class);\nif (w != null) {\n// Special case: wrapping explicitly blocked?\nif (!w.useWrapping()) {\nreturn PropertyName.NO_NAME;\n}\n// also: need to ensure we use marker:\nString localName = w.localName();\nif (localName == null || localName.length() == 0) {\nreturn PropertyName.USE_DEFAULT;\n}\nreturn PropertyName.construct(w.localName(), w.namespace());\n}\n/* 09-Sep-2012, tatu: In absence of configurating we need to use our\n*   default settings...\n*/\nif (_cfgDefaultUseWrapper) {\nreturn PropertyName.USE_DEFAULT;\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:findNamespace(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Ljava/lang/String;",
                                    "method_body": "public String findNamespace(Annotated ann)\n{\nJacksonXmlProperty prop = ann.getAnnotation(JacksonXmlProperty.class);\nif (prop != null) {\nreturn prop.namespace();\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:isOutputAsAttribute(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Ljava/lang/Boolean;",
                                    "method_body": "public Boolean isOutputAsAttribute(Annotated ann)\n{\nJacksonXmlProperty prop = ann.getAnnotation(JacksonXmlProperty.class);\nif (prop != null) {\nreturn prop.isAttribute() ? Boolean.TRUE : Boolean.FALSE;\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:isOutputAsText(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Ljava/lang/Boolean;",
                                    "method_body": "public Boolean isOutputAsText(Annotated ann)\n{\nJacksonXmlText prop = ann.getAnnotation(JacksonXmlText.class);\nif (prop != null) {\nreturn prop.value() ? Boolean.TRUE : Boolean.FALSE;\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:isOutputAsCData(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Ljava/lang/Boolean;",
                                    "method_body": "public Boolean isOutputAsCData(Annotated ann) {\nJacksonXmlCData prop = ann.getAnnotation(JacksonXmlCData.class);\nif (prop != null) {\nreturn prop.value() ? Boolean.TRUE : Boolean.FALSE;\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:findNameForSerialization(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Lcom/fasterxml/jackson/databind/PropertyName;",
                                    "method_body": "public PropertyName findNameForSerialization(Annotated a)\n{\nPropertyName name = _findXmlName(a);\nif (name == null) {\nname = super.findNameForSerialization(a);\nif (name == null) {\nif (a.hasAnnotation(JacksonXmlText.class)) {\nreturn PropertyName.USE_DEFAULT;\n}\n}\n}\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:findNameForDeserialization(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Lcom/fasterxml/jackson/databind/PropertyName;",
                                    "method_body": "public PropertyName findNameForDeserialization(Annotated a)\n{\nPropertyName name = _findXmlName(a);\nif (name == null) {\nname = super.findNameForDeserialization(a);\nif (name == null) {\nif (a.hasAnnotation(JacksonXmlText.class)) {\nreturn PropertyName.USE_DEFAULT;\n}\n}\n}\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:_findXmlName(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Lcom/fasterxml/jackson/databind/PropertyName;",
                                    "method_body": "protected PropertyName _findXmlName(Annotated a)\n{\nJacksonXmlProperty pann = a.getAnnotation(JacksonXmlProperty.class);\nif (pann != null) {\nreturn PropertyName.construct(pann.localName(), pann.namespace());\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.AnnotationUtil:findNamespaceAnnotation(Lcom/fasterxml/jackson/databind/AnnotationIntrospector;Lcom/fasterxml/jackson/databind/introspect/AnnotatedMember;)Ljava/lang/String;",
                                    "method_body": "public static String findNamespaceAnnotation(AnnotationIntrospector ai,\nAnnotatedMember prop)\n{\nfor (AnnotationIntrospector intr : ai.allIntrospectors()) {\nif (intr instanceof XmlAnnotationIntrospector) {\nString ns = ((XmlAnnotationIntrospector) intr).findNamespace(prop);\nif (ns != null) {\nreturn ns;\n}\n} else  if (intr instanceof JaxbAnnotationIntrospector) {\nString ns = ((JaxbAnnotationIntrospector) intr).findNamespace(prop);\nif (ns != null) {\nreturn ns;\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.AnnotationUtil:findIsAttributeAnnotation(Lcom/fasterxml/jackson/databind/AnnotationIntrospector;Lcom/fasterxml/jackson/databind/introspect/AnnotatedMember;)Ljava/lang/Boolean;",
                                    "method_body": "public static Boolean findIsAttributeAnnotation(AnnotationIntrospector ai,\nAnnotatedMember prop)\n{\nfor (AnnotationIntrospector intr : ai.allIntrospectors()) {\nif (intr instanceof XmlAnnotationIntrospector) {\nBoolean b = ((XmlAnnotationIntrospector) intr).isOutputAsAttribute(prop);\nif (b != null) {\nreturn b;\n}\n} else  if (intr instanceof JaxbAnnotationIntrospector) {\nBoolean b = ((JaxbAnnotationIntrospector) intr).isOutputAsAttribute(prop);\nif (b != null) {\nreturn b;\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.AnnotationUtil:findIsTextAnnotation(Lcom/fasterxml/jackson/databind/AnnotationIntrospector;Lcom/fasterxml/jackson/databind/introspect/AnnotatedMember;)Ljava/lang/Boolean;",
                                    "method_body": "public static Boolean findIsTextAnnotation(AnnotationIntrospector ai,\nAnnotatedMember prop)\n{\nfor (AnnotationIntrospector intr : ai.allIntrospectors()) {\nif (intr instanceof XmlAnnotationIntrospector) {\nBoolean b = ((XmlAnnotationIntrospector) intr).isOutputAsText(prop);\nif (b != null) {\nreturn b;\n}\n} else  if (intr instanceof JaxbAnnotationIntrospector) {\nBoolean b = ((JaxbAnnotationIntrospector) intr).isOutputAsText(prop);\nif (b != null) {\nreturn b;\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.AnnotationUtil:findIsCDataAnnotation(Lcom/fasterxml/jackson/databind/AnnotationIntrospector;Lcom/fasterxml/jackson/databind/introspect/AnnotatedMember;)Ljava/lang/Boolean;",
                                    "method_body": "public static Boolean findIsCDataAnnotation(AnnotationIntrospector ai,\nAnnotatedMember prop)\n{\nfor (AnnotationIntrospector intr : ai.allIntrospectors()) {\nif (intr instanceof XmlAnnotationIntrospector) {\nBoolean b = ((XmlAnnotationIntrospector) intr).isOutputAsCData(prop);\nif (b != null) {\nreturn b;\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.TypeUtil:isIndexedType(Lcom/fasterxml/jackson/databind/JavaType;)Z",
                                    "method_body": "public static boolean isIndexedType(JavaType type)\n{\nif (type.isContainerType()) {\nClass<?> cls = type.getRawClass();\n// One special case; byte[] will be serialized as base64-encoded String, not real array, so:\n// (actually, ditto for char[]; thought to be a String)\nif (cls == byte[].class || cls == char[].class) {\nreturn false;\n}\n// issue#5: also, should not add wrapping for Maps\nif (Map.class.isAssignableFrom(cls)) {\nreturn false;\n}\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.TypeUtil:isIndexedType(Ljava/lang/Class;)Z",
                                    "method_body": "public static boolean isIndexedType(Class<?> cls)\n{\nreturn (cls.isArray() && cls != byte[].class && cls != char[].class)\n|| Collection.class.isAssignableFrom(cls);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:<init>(Lcom/fasterxml/jackson/core/io/IOContext;IILcom/fasterxml/jackson/core/ObjectCodec;Ljavax/xml/stream/XMLStreamWriter;)V",
                                    "method_body": "public ToXmlGenerator(IOContext ctxt, int stdFeatures, int xmlFeatures,\nObjectCodec codec, XMLStreamWriter sw)\n{\nsuper(stdFeatures, codec);\n_formatFeatures = xmlFeatures;\n_ioContext = ctxt;\n_originalXmlWriter = sw;\n_xmlWriter = Stax2WriterAdapter.wrapIfNecessary(sw);\n_stax2Emulation = (_xmlWriter != sw);\n_xmlPrettyPrinter = (_cfgPrettyPrinter instanceof XmlPrettyPrinter) ?\n(XmlPrettyPrinter) _cfgPrettyPrinter : null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:initGenerator()V",
                                    "method_body": "public void initGenerator()  throws IOException\n{\nif (_initialized) {\nreturn;\n}\n_initialized = true;\ntry {\nif (Feature.WRITE_XML_1_1.enabledIn(_formatFeatures)) {\n_xmlWriter.writeStartDocument(\"UTF-8\", \"1.1\");\n} else if (Feature.WRITE_XML_DECLARATION.enabledIn(_formatFeatures)) {\n_xmlWriter.writeStartDocument(\"UTF-8\", \"1.0\");\n} else {\nreturn;\n}\n// as per [dataformat-xml#172], try adding indentation\nif (_xmlPrettyPrinter != null) {\n// ... but only if it is likely to succeed:\nif (!_stax2Emulation) {\n_xmlPrettyPrinter.writePrologLinefeed(_xmlWriter);\n}\n}\n} catch (XMLStreamException e) {\nStaxUtil.throwXmlAsIOException(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:setNextIsAttribute(Z)V",
                                    "method_body": "public void setNextIsAttribute(boolean isAttribute)\n{\n_nextIsAttribute = isAttribute;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:setNextName(Ljavax/xml/namespace/QName;)V",
                                    "method_body": "public final void setNextName(QName name)\n{\n_nextName = name;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:setNextNameIfMissing(Ljavax/xml/namespace/QName;)Z",
                                    "method_body": "public final boolean setNextNameIfMissing(QName name)\n{\nif (_nextName == null) {\n_nextName = name;\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:writeFieldName(Ljava/lang/String;)V",
                                    "method_body": "public final void writeFieldName(String name) throws IOException\n{\nif (_writeContext.writeFieldName(name) == JsonWriteContext.STATUS_EXPECT_VALUE) {\n_reportError(\"Can not write a field name, expecting a value\");\n}\n// Should this ever get called?\nString ns = (_nextName == null) ? \"\" : _nextName.getNamespaceURI();\nsetNextName(new QName(ns, name));\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:writeStartObject()V",
                                    "method_body": "public final void writeStartObject() throws IOException\n{\n_verifyValueWrite(\"start an object\");\n_writeContext = _writeContext.createChildObjectContext();\nif (_cfgPrettyPrinter != null) {\n_cfgPrettyPrinter.writeStartObject(this);\n} else {\n_handleStartObject();\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:writeEndObject()V",
                                    "method_body": "public final void writeEndObject() throws IOException\n{\nif (!_writeContext.inObject()) {\n_reportError(\"Current context not Object but \"+_writeContext.typeDesc());\n}\n_writeContext = _writeContext.getParent();\nif (_cfgPrettyPrinter != null) {\n// as per [Issue#45], need to suppress indentation if only attributes written:\nint count = _nextIsAttribute ? 0 : _writeContext.getEntryCount();\n_cfgPrettyPrinter.writeEndObject(this, count);\n} else {\n_handleEndObject();\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:_handleStartObject()V",
                                    "method_body": "public final void _handleStartObject() throws IOException\n{\nif (_nextName == null) {\nhandleMissingName();\n}\n// Need to keep track of names to make Lists work correctly\n_elementNameStack.addLast(_nextName);\ntry {\n_xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n} catch (XMLStreamException e) {\nStaxUtil.throwXmlAsIOException(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:_handleEndObject()V",
                                    "method_body": "public final void _handleEndObject() throws IOException\n{\n// We may want to repeat same element, so:\nif (_elementNameStack.isEmpty()) {\nthrow new JsonGenerationException(\"Can not write END_ELEMENT without open START_ELEMENT\", this);\n}\n_nextName = _elementNameStack.removeLast();\ntry {\n// note: since attributes don't nest, can only have one attribute active, so:\n_nextIsAttribute = false;\n_xmlWriter.writeEndElement();\n// [databind-xml#172]: possibly also need indentation\nif (_elementNameStack.isEmpty() && (_xmlPrettyPrinter != null)) {\n// ... but only if it is likely to succeed:\nif (!_stax2Emulation) {\n_xmlPrettyPrinter.writePrologLinefeed(_xmlWriter);\n}\n}\n} catch (XMLStreamException e) {\nStaxUtil.throwXmlAsIOException(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:writeFieldName(Lcom/fasterxml/jackson/core/SerializableString;)V",
                                    "method_body": "public void writeFieldName(SerializableString name) throws IOException\n{\nwriteFieldName(name.getValue());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:writeString(Ljava/lang/String;)V",
                                    "method_body": "public void writeString(String text) throws IOException\n{\n_verifyValueWrite(\"write String value\");\nif (_nextName == null) {\nhandleMissingName();\n}\ntry {\nif (_nextIsAttribute) { // must write attribute name and value with one call\n_xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), text);\n} else if (checkNextIsUnwrapped()) {\n// [Issue#56] Should figure out how to prevent indentation for end element\n//   but for now, let's just make sure structure is correct\n//if (_xmlPrettyPrinter != null) { ... }\nif(_nextIsCData) {\n_xmlWriter.writeCData(text);\n} else {\n_xmlWriter.writeCharacters(text);\n}\n} else if (_xmlPrettyPrinter != null) {\n_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n_nextName.getNamespaceURI(), _nextName.getLocalPart(),\ntext, _nextIsCData);\n} else {\n_xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\nif(_nextIsCData) {\n_xmlWriter.writeCData(text);\n} else {\n_xmlWriter.writeCharacters(text);\n}\n_xmlWriter.writeEndElement();\n}\n} catch (XMLStreamException e) {\nStaxUtil.throwXmlAsIOException(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:writeNull()V",
                                    "method_body": "public void writeNull() throws IOException\n{\n_verifyValueWrite(\"write null value\");\nif (_nextName == null) {\nhandleMissingName();\n}\n// !!! TODO: proper use of 'xsd:isNil' ?\ntry {\nif (_nextIsAttribute) {\n/* With attributes, best just leave it out, right? (since there's no way\n* to use 'xsi:nil')\n*/\n} else if (checkNextIsUnwrapped()) {\n// as with above, best left unwritten?\n} else {\nif (_xmlPrettyPrinter != null) {\n_xmlPrettyPrinter.writeLeafNullElement(_xmlWriter,\n_nextName.getNamespaceURI(), _nextName.getLocalPart());\n} else {\n_xmlWriter.writeEmptyElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n}\n}\n} catch (XMLStreamException e) {\nStaxUtil.throwXmlAsIOException(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:_verifyValueWrite(Ljava/lang/String;)V",
                                    "method_body": "protected final void _verifyValueWrite(String typeMsg) throws IOException\n{\nint status = _writeContext.writeValue();\nif (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n_reportError(\"Can not \"+typeMsg+\", expecting field name\");\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:close()V",
                                    "method_body": "public void close() throws IOException\n{\n//        boolean wasClosed = _closed;\nsuper.close();\n\n// First: let's see that we still have buffers...\nif (isEnabled(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT)) {\ntry {\nwhile (true) {\n/* 28-May-2016, tatu: To work around incompatibility introduced by\n*     `jackson-core` 2.8 where return type of `getOutputContext()`\n*     changed, let's do direct access here.\n*/\n//                    JsonStreamContext ctxt = getOutputContext();\nJsonStreamContext ctxt = _writeContext;\nif (ctxt.inArray()) {\nwriteEndArray();\n} else if (ctxt.inObject()) {\nwriteEndObject();\n} else {\nbreak;\n}\n}\n} catch (ArrayIndexOutOfBoundsException e) {\n/* 29-Nov-2010, tatu: Stupid, stupid SJSXP doesn't do array checks, so we get\n*   hit by this as a collateral problem in some cases. Yuck.\n*/\nthrow new JsonGenerationException(e, this);\n}\n}\ntry {\nif (_ioContext.isResourceManaged() || isEnabled(JsonGenerator.Feature.AUTO_CLOSE_TARGET)) {\n_xmlWriter.closeCompletely();\n} else {\n_xmlWriter.close();\n}\n} catch (XMLStreamException e) {\nStaxUtil.throwXmlAsIOException(e);\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:checkNextIsUnwrapped()Z",
                                    "method_body": "protected boolean checkNextIsUnwrapped()\n{\nif (_nextIsUnwrapped) {\n_nextIsUnwrapped = false;\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerBase:<init>(Lcom/fasterxml/jackson/databind/ser/std/BeanSerializerBase;)V",
                                    "method_body": "public XmlBeanSerializerBase(BeanSerializerBase src)\n{\nsuper(src);\n\n/* Then make sure attributes are sorted before elements, keep track\n* of how many there are altogether\n*/\nint attrCount = 0;\nfor (BeanPropertyWriter bpw : _props) {\nif (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\nattrCount = _orderAttributesFirst(_props, _filteredProps);\nbreak;\n}\n}\n_attributeCount = attrCount;\n\n// also: pre-compute need, if any, for CDATA handling:\nBitSet cdata = null;\nfor (int i = 0, len = _props.length; i < len; ++i) {\nBeanPropertyWriter bpw = _props[i];\nif (_isCData(bpw)) {\nif (cdata == null) {\ncdata = new BitSet(len);\n}\ncdata.set(i);\n}\n}\n_cdata = cdata;\n\n// And then collect namespace information\n_xmlNames = new QName[_props.length];\nint textIndex = -1;\nfor (int i = 0, len = _props.length; i < len; ++i) {\nBeanPropertyWriter bpw = _props[i];\nXmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\nString ns = null;\nif (info != null) {\nns = info.getNamespace();\nif (textIndex < 0 && info.isText()) {\ntextIndex = i;\n}\n}\n_xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n}\n_textPropertyIndex = textIndex;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerBase:<clinit>()V",
                                    "method_body": "public final static String KEY_XML_INFO = new String(\"xmlInfo\");\n\n/**\n* Number of attributes to write; these will have been ordered to be the first\n* properties to write.\n*/\nprotected final int _attributeCount;\n\n/**\n* Index of \"text value\" property we have, if any; can have at most\n* one such property.\n*/\nprotected final int _textPropertyIndex;\n\n/**\n* Array that contains namespace URIs associated with properties, if any;\n* null if no namespace definitions have been assigned\n*/\nprotected final QName[] _xmlNames;\n\n/**\n* Optional set of indexes of properties that should be serialized as CDATA,\n* instead of regular XML text segment. Left as null in cases where none of\n* element values are to be written in such a way.\n*/\nprotected final BitSet _cdata;\n\npublic XmlBeanSerializerBase(BeanSerializerBase src)\n{\nsuper(src);\n\n/* Then make sure attributes are sorted before elements, keep track\n* of how many there are altogether\n*/\nint attrCount = 0;\nfor (BeanPropertyWriter bpw : _props) {\nif (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\nattrCount = _orderAttributesFirst(_props, _filteredProps);\nbreak;\n}\n}\n_attributeCount = attrCount;\n\n// also: pre-compute need, if any, for CDATA handling:\nBitSet cdata = null;\nfor (int i = 0, len = _props.length; i < len; ++i) {\nBeanPropertyWriter bpw = _props[i];\nif (_isCData(bpw)) {\nif (cdata == null) {\ncdata = new BitSet(len);\n}\ncdata.set(i);\n}\n}\n_cdata = cdata;\n\n// And then collect namespace information\n_xmlNames = new QName[_props.length];\nint textIndex = -1;\nfor (int i = 0, len = _props.length; i < len; ++i) {\nBeanPropertyWriter bpw = _props[i];\nXmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\nString ns = null;\nif (info != null) {\nns = info.getNamespace();\nif (textIndex < 0 && info.isText()) {\ntextIndex = i;\n}\n}\n_xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n}\n_textPropertyIndex = textIndex;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerBase:serializeFields(Ljava/lang/Object;Lcom/fasterxml/jackson/core/JsonGenerator;Lcom/fasterxml/jackson/databind/SerializerProvider;)V",
                                    "method_body": "protected void serializeFields(Object bean, JsonGenerator gen0, SerializerProvider provider)\nthrows IOException\n{\n// 19-Aug-2013, tatu: During 'convertValue()', need to skip\nif (!(gen0 instanceof ToXmlGenerator)) {\nsuper.serializeFields(bean, gen0, provider);\nreturn;\n}\n\nfinal ToXmlGenerator xgen = (ToXmlGenerator) gen0;\nfinal BeanPropertyWriter[] props;\nif (_filteredProps != null && provider.getActiveView() != null) {\nprops = _filteredProps;\n} else {\nprops = _props;\n}\n\nfinal int attrCount = _attributeCount;\nfinal boolean isAttribute = xgen._nextIsAttribute;\nif (attrCount > 0) {\nxgen.setNextIsAttribute(true);\n}\nfinal int textIndex = _textPropertyIndex;\nfinal QName[] xmlNames = _xmlNames;\nint i = 0;\nfinal BitSet cdata = _cdata;\n\ntry {\nfor (final int len = props.length; i < len; ++i) {\n// 28-jan-2014, pascal: we don't want to reset the attribute flag if we are an unwrapping serializer\n// that started with nextIsAttribute to true because all properties should be unwrapped as attributes too.\nif (i == attrCount && !(isAttribute && isUnwrappingSerializer())) {\nxgen.setNextIsAttribute(false);\n}\n// also: if this is property to write as text (\"unwrap\"), need to:\nif (i == textIndex) {\nxgen.setNextIsUnwrapped(true);\n}\nxgen.setNextName(xmlNames[i]);\nBeanPropertyWriter prop = props[i];\nif (prop != null) { // can have nulls in filtered list\nif ((cdata != null) && cdata.get(i)) {\nxgen.setNextIsCData(true);\nprop.serializeAsField(bean, xgen, provider);\nxgen.setNextIsCData(false);\n} else {\nprop.serializeAsField(bean, xgen, provider);\n}\n}\n// Reset to avoid next value being written as unwrapped,\n// for example when property is suppressed\nif (i == textIndex) {\nxgen.setNextIsUnwrapped(false);\n}\n}\nif (_anyGetterWriter != null) {\n// For [#117]: not a clean fix, but with @JsonTypeInfo, we'll end up\n// with accidental attributes otherwise\nxgen.setNextIsAttribute(false);\n_anyGetterWriter.getAndSerialize(bean, xgen, provider);\n}\n} catch (Exception e) {\nString name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\nwrapAndThrow(provider, e, bean, name);\n} catch (StackOverflowError e) { // Bit tricky, can't do more calls as stack is full; so:\nJsonMappingException mapE = JsonMappingException.from(gen0,\n\"Infinite recursion (StackOverflowError)\");\nString name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\nmapE.prependPath(new JsonMappingException.Reference(bean, name));\nthrow mapE;\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerBase:_isAttribute(Lcom/fasterxml/jackson/databind/ser/BeanPropertyWriter;)Z",
                                    "method_body": "protected static boolean _isAttribute(BeanPropertyWriter bpw)\n{\nXmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\nreturn (info != null) && info.isAttribute();\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerBase:_isCData(Lcom/fasterxml/jackson/databind/ser/BeanPropertyWriter;)Z",
                                    "method_body": "protected static boolean _isCData(BeanPropertyWriter bpw)\n{\nXmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\nreturn (info != null) && info.isCData();\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.XmlInfo:<init>(Ljava/lang/Boolean;Ljava/lang/String;Ljava/lang/Boolean;Ljava/lang/Boolean;)V",
                                    "method_body": "public XmlInfo(Boolean isAttribute, String ns, Boolean isText, Boolean isCData)\n{\n_isAttribute = (isAttribute == null) ? false : isAttribute.booleanValue();\n_namespace = (ns == null) ? \"\" : ns;\n_isText = (isText == null) ? false : isText.booleanValue();\n_isCData = (isCData == null) ? false : isCData.booleanValue();\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.XmlInfo:getNamespace()Ljava/lang/String;",
                                    "method_body": "public String getNamespace() { return _namespace; }\npublic String getNamespace() { return _namespace; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.XmlInfo:isAttribute()Z",
                                    "method_body": "public boolean isAttribute() { return _isAttribute; }\npublic boolean isAttribute() { return _isAttribute; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.XmlInfo:isText()Z",
                                    "method_body": "public boolean isText() { return _isText; }\npublic boolean isText() { return _isText; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.XmlInfo:isCData()Z",
                                    "method_body": "public boolean isCData() { return _isCData; }\npublic boolean isCData() { return _isCData; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializer:<init>(Lcom/fasterxml/jackson/databind/ser/std/BeanSerializerBase;)V",
                                    "method_body": "public XmlBeanSerializer(BeanSerializerBase src) {\nsuper(src);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializer:serialize(Ljava/lang/Object;Lcom/fasterxml/jackson/core/JsonGenerator;Lcom/fasterxml/jackson/databind/SerializerProvider;)V",
                                    "method_body": "public void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException\n{\nif (_objectIdWriter != null) {\n_serializeWithObjectId(bean, jgen, provider, true);\nreturn;\n}\njgen.writeStartObject();\nif (_propertyFilterId != null) {\nserializeFieldsFiltered(bean, jgen, provider);\n} else {\nserializeFields(bean, jgen, provider);\n}\njgen.writeEndObject();\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 5,
                    "tests": [
                        {
                            "test_name": "com.fasterxml.jackson.dataformat.xml.MapperCopyTest.testCopyWith",
                            "test_body": "public void testCopyWith() throws Exception\n{\nXmlMapper xmlMapper = newMapper();\nfinal ObjectMapper xmlMapperNoAnno = xmlMapper.copy()\n.disable(MapperFeature.USE_ANNOTATIONS)\n.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);\nString xml1 = xmlMapper.writeValueAsString(new Pojo282());\nString xml2 = xmlMapperNoAnno.writeValueAsString(new Pojo282());\nif (!xml1.contains(\"AnnotatedName\")) {\nfail(\"Should use name 'AnnotatedName', xml = \"+xml1);\n}\nif (!xml2.contains(\"Pojo282\")\n|| xml2.contains(\"AnnotatedName\")) {\nfail(\"Should NOT use name 'AnnotatedName' but 'Pojo282', xml = \"+xml1);\n}\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<init>()V",
                                    "method_body": "public XmlMapper() {\nthis(new XmlFactory());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<init>(Lcom/fasterxml/jackson/dataformat/xml/XmlFactory;)V",
                                    "method_body": "public XmlMapper(XmlFactory xmlFactory) {\nthis(xmlFactory, DEFAULT_XML_MODULE);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<init>(Lcom/fasterxml/jackson/dataformat/xml/XmlFactory;Lcom/fasterxml/jackson/dataformat/xml/JacksonXmlModule;)V",
                                    "method_body": "public XmlMapper(XmlFactory xmlFactory, JacksonXmlModule module)\n{\n/* Need to override serializer provider (due to root name handling);\n* deserializer provider fine as is\n*/\nsuper(xmlFactory, new XmlSerializerProvider(new XmlRootNameLookup()), null);\n_xmlModule = module;\n// but all the rest is done via Module interface!\nif (module != null) {\nregisterModule(module);\n}\n// 19-May-2015, tatu: Must ensure we use XML-specific indenter\n_serializationConfig = _serializationConfig.withDefaultPrettyPrinter(DEFAULT_XML_PRETTY_PRINTER);\n// 21-Jun-2017, tatu: Seems like there are many cases in XML where ability to coerce empty\n//    String into `null` (where it otherwise is an error) is very useful.\nenable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<init>(Lcom/fasterxml/jackson/dataformat/xml/XmlMapper;)V",
                                    "method_body": "protected XmlMapper(XmlMapper src) {\nsuper(src);\n_xmlModule = src._xmlModule;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\nprotected final static JacksonXmlModule DEFAULT_XML_MODULE = new JacksonXmlModule();\n\nprotected final static DefaultXmlPrettyPrinter DEFAULT_XML_PRETTY_PRINTER = new DefaultXmlPrettyPrinter();\n\n// need to hold on to module instance just in case copy() is used\nprotected final JacksonXmlModule _xmlModule;\n\n/*\n/**********************************************************\n/* Life-cycle: construction, configuration\n/**********************************************************\n*/\n\npublic XmlMapper() {\nthis(new XmlFactory());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:copy()Lcom/fasterxml/jackson/dataformat/xml/XmlMapper;",
                                    "method_body": "public XmlMapper copy()\n{\n_checkInvalidCopy(XmlMapper.class);\nreturn new XmlMapper(this);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlModule:<init>()V",
                                    "method_body": "public JacksonXmlModule()\n{\nsuper(\"JacksonXmlModule\", PackageVersion.VERSION);\nXmlStringDeserializer deser = new XmlStringDeserializer();\naddDeserializer(String.class, deser);\naddDeserializer(CharSequence.class, deser);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlModule:setupModule(Lcom/fasterxml/jackson/databind/Module$SetupContext;)V",
                                    "method_body": "public void setupModule(SetupContext context)\n{\n// Need to modify BeanDeserializer, BeanSerializer that are used\ncontext.addBeanSerializerModifier(new XmlBeanSerializerModifier());\ncontext.addBeanDeserializerModifier(new XmlBeanDeserializerModifier(_cfgNameForTextElement));\n\n// as well as AnnotationIntrospector\ncontext.insertAnnotationIntrospector(_constructIntrospector());\n\n// and finally inform XmlFactory about overrides, if need be:\nif (_cfgNameForTextElement != FromXmlParser.DEFAULT_UNNAMED_TEXT_PROPERTY) {\nXmlMapper m = (XmlMapper) context.getOwner();\nm.setXMLTextElementName(_cfgNameForTextElement);\n}\n\n// Usually this would be the first call; but here anything added will\n// be stuff user may has added, so do it afterwards instead.\nsuper.setupModule(context);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlModule:_constructIntrospector()Lcom/fasterxml/jackson/databind/AnnotationIntrospector;",
                                    "method_body": "protected AnnotationIntrospector _constructIntrospector() {\nreturn new JacksonXmlAnnotationIntrospector(_cfgDefaultUseWrapper);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.PackageVersion:<clinit>()V",
                                    "method_body": "public final static Version VERSION = VersionUtil.parseVersion(\n\"2.9.6-SNAPSHOT\", \"com.fasterxml.jackson.dataformat\", \"jackson-dataformat-xml\");\n\n@Override\npublic Version version() {\nreturn VERSION;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlStringDeserializer:<init>()V",
                                    "method_body": "public XmlStringDeserializer() { super(String.class); }\npublic XmlStringDeserializer() { super(String.class); }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter:<init>()V",
                                    "method_body": "public void writeIndentation(JsonGenerator g, int level) throws IOException;\n\npublic void writeIndentation(XMLStreamWriter2 sw, int level) throws XMLStreamException;\n\n/**\n* @return True if indenter is considered inline (does not add linefeeds),\n*   false otherwise\n*/\npublic boolean isInline();\n}\n\n/*\n/**********************************************************\n/* Configuration\n/**********************************************************\n*/\n\n/**\n* By default, let's use only spaces to separate array values.\n*/\nprotected Indenter _arrayIndenter = new FixedSpaceIndenter();\n\n/**\n* By default, let's use linefeed-adding indenter for separate\n* object entries. We'll further configure indenter to use\n* system-specific linefeeds, and 2 spaces per level (as opposed to,\n* say, single tabs)\n*/\nprotected Indenter _objectIndenter = new Lf2SpacesIndenter();\n\n// // // Config, other white space configuration\n\n/**\n* By default we will add spaces around colons used to\n* separate object fields and values.\n* If disabled, will not use spaces around colon.\n*/\nprotected boolean _spacesInObjectEntries = true;\n\n/*\n/**********************************************************\n/* State\n/**********************************************************\n*/\n\n/**\n* Number of open levels of nesting. Used to determine amount of\n* indentation to use.\n*/\nprotected transient int _nesting = 0;\n\n/**\n* Marker flag set on start element, and cleared if an end element\n* is encountered. Used for suppressing indentation to allow empty\n* elements.\n*\n* @since 2.3\n*/\nprotected transient boolean _justHadStartElement;\n\n/*\n/**********************************************************\n/* Life-cycle (construct, configure)\n/**********************************************************\n*/\n\npublic DefaultXmlPrettyPrinter() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter:<init>(Lcom/fasterxml/jackson/dataformat/xml/util/DefaultXmlPrettyPrinter;)V",
                                    "method_body": "public void writeIndentation(JsonGenerator g, int level) throws IOException;\n\npublic void writeIndentation(XMLStreamWriter2 sw, int level) throws XMLStreamException;\n\n/**\n* @return True if indenter is considered inline (does not add linefeeds),\n*   false otherwise\n*/\npublic boolean isInline();\n}\n\n/*\n/**********************************************************\n/* Configuration\n/**********************************************************\n*/\n\n/**\n* By default, let's use only spaces to separate array values.\n*/\nprotected Indenter _arrayIndenter = new FixedSpaceIndenter();\n\n/**\n* By default, let's use linefeed-adding indenter for separate\n* object entries. We'll further configure indenter to use\n* system-specific linefeeds, and 2 spaces per level (as opposed to,\n* say, single tabs)\n*/\nprotected Indenter _objectIndenter = new Lf2SpacesIndenter();\n\n// // // Config, other white space configuration\n\n/**\n* By default we will add spaces around colons used to\n* separate object fields and values.\n* If disabled, will not use spaces around colon.\n*/\nprotected boolean _spacesInObjectEntries = true;\n\n/*\n/**********************************************************\n/* State\n/**********************************************************\n*/\n\n/**\n* Number of open levels of nesting. Used to determine amount of\n* indentation to use.\n*/\nprotected transient int _nesting = 0;\n\n/**\n* Marker flag set on start element, and cleared if an end element\n* is encountered. Used for suppressing indentation to allow empty\n* elements.\n*\n* @since 2.3\n*/\nprotected transient boolean _justHadStartElement;\n\n/*\n/**********************************************************\n/* Life-cycle (construct, configure)\n/**********************************************************\n*/\n\npublic DefaultXmlPrettyPrinter() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter$FixedSpaceIndenter:<init>()V",
                                    "method_body": "public FixedSpaceIndenter() { }\npublic FixedSpaceIndenter() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter$Lf2SpacesIndenter:<init>()V",
                                    "method_body": "public Lf2SpacesIndenter() { }\npublic Lf2SpacesIndenter() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter$Lf2SpacesIndenter:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\nfinal static String SYSTEM_LINE_SEPARATOR;\nstatic {\nString lf = null;\ntry {\nlf = System.getProperty(\"line.separator\");\n} catch (Throwable t) { } // access exception?\nSYSTEM_LINE_SEPARATOR = (lf == null) ? \"\\n\" : lf;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>()V",
                                    "method_body": "public XmlFactory() { this(null, null, null); }\npublic XmlFactory() { this(null, null, null); }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>(Lcom/fasterxml/jackson/core/ObjectCodec;Ljavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;)V",
                                    "method_body": "public XmlFactory(ObjectCodec oc, XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n{\nthis(oc, DEFAULT_XML_PARSER_FEATURE_FLAGS, DEFAULT_XML_GENERATOR_FEATURE_FLAGS,\nxmlIn, xmlOut, null);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>(Lcom/fasterxml/jackson/core/ObjectCodec;IILjavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;Ljava/lang/String;)V",
                                    "method_body": "protected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\nXMLInputFactory xmlIn, XMLOutputFactory xmlOut,\nString nameForTextElem)\n{\nsuper(oc);\n_xmlParserFeatures = xpFeatures;\n_xmlGeneratorFeatures = xgFeatures;\n_cfgNameForTextElement = nameForTextElem;\nif (xmlIn == null) {\nxmlIn = XMLInputFactory.newInstance();\n// as per [dataformat-xml#190], disable external entity expansion by default\nxmlIn.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\n// and ditto wrt [dataformat-xml#211], SUPPORT_DTD\nxmlIn.setProperty(XMLInputFactory.SUPPORT_DTD, Boolean.FALSE);\n}\nif (xmlOut == null) {\nxmlOut = XMLOutputFactory.newInstance();\n}\n_initFactories(xmlIn, xmlOut);\n_xmlInputFactory = xmlIn;\n_xmlOutputFactory = xmlOut;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>(Lcom/fasterxml/jackson/dataformat/xml/XmlFactory;Lcom/fasterxml/jackson/core/ObjectCodec;)V",
                                    "method_body": "protected XmlFactory(XmlFactory src, ObjectCodec oc)\n{\nsuper(src, oc);\n_xmlParserFeatures = src._xmlParserFeatures;\n_xmlGeneratorFeatures = src._xmlGeneratorFeatures;\n_cfgNameForTextElement = src._cfgNameForTextElement;\n_xmlInputFactory = src._xmlInputFactory;\n_xmlOutputFactory = src._xmlOutputFactory;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<clinit>()V",
                                    "method_body": "public final static String FORMAT_NAME_XML = \"XML\";\n\n/**\n* Bitfield (set of flags) of all parser features that are enabled\n* by default.\n*/\nfinal static int DEFAULT_XML_PARSER_FEATURE_FLAGS = FromXmlParser.Feature.collectDefaults();\n\n/**\n* Bitfield (set of flags) of all generator features that are enabled\n* by default.\n*/\nfinal static int DEFAULT_XML_GENERATOR_FEATURE_FLAGS = ToXmlGenerator.Feature.collectDefaults();\n\n/*\n/**********************************************************\n/* Configuration\n/**********************************************************\n*/\n\nprotected int _xmlParserFeatures;\n\nprotected int _xmlGeneratorFeatures;\n\n// non-final for setters (why are they needed again?)\nprotected transient XMLInputFactory _xmlInputFactory;\n\nprotected transient XMLOutputFactory _xmlOutputFactory;\n\nprotected String _cfgNameForTextElement;\n\n/*\n/**********************************************************\n/* Factory construction, configuration\n/**********************************************************\n*/\n\n/**\n* Default constructor used to create factory instances.\n* Creation of a factory instance is a light-weight operation,\n* but it is still a good idea to reuse limited number of\n* factory instances (and quite often just a single instance):\n* factories are used as context for storing some reused\n* processing objects (such as symbol tables parsers use)\n* and this reuse only works within context of a single\n* factory instance.\n*/\npublic XmlFactory() { this(null, null, null); }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_initFactories(Ljavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;)V",
                                    "method_body": "protected void _initFactories(XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n{\n// Better ensure namespaces get built properly, so:\nxmlOut.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\n// and for parser, force coalescing as well (much simpler to use)\nxmlIn.setProperty(XMLInputFactory.IS_COALESCING, Boolean.TRUE);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:copy()Lcom/fasterxml/jackson/dataformat/xml/XmlFactory;",
                                    "method_body": "public XmlFactory copy() {\n_checkInvalidCopy(XmlFactory.class);\nreturn new XmlFactory(this, null);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:createGenerator(Ljava/io/Writer;)Lcom/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator;",
                                    "method_body": "public ToXmlGenerator createGenerator(Writer out) throws IOException\n{\nreturn new ToXmlGenerator(_createContext(out, false),\n_generatorFeatures, _xmlGeneratorFeatures,\n_objectCodec, _createXmlWriter(out));\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_createXmlWriter(Ljava/io/Writer;)Ljavax/xml/stream/XMLStreamWriter;",
                                    "method_body": "protected XMLStreamWriter _createXmlWriter(Writer w) throws IOException\n{\nXMLStreamWriter sw;\ntry {\nsw = _xmlOutputFactory.createXMLStreamWriter(w);\n} catch (XMLStreamException e) {\nreturn StaxUtil.throwAsGenerationException(e, null);\n}\nreturn _initializeXmlWriter(sw);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_initializeXmlWriter(Ljavax/xml/stream/XMLStreamWriter;)Ljavax/xml/stream/XMLStreamWriter;",
                                    "method_body": "protected final XMLStreamWriter _initializeXmlWriter(XMLStreamWriter sw) throws IOException\n{\n// And just for Sun Stax parser (JDK default), seems that we better define default namespace\n// (Woodstox doesn't care) -- otherwise it'll add unnecessary odd declaration\ntry {\nsw.setDefaultNamespace(\"\");\n} catch (XMLStreamException e) {\nreturn StaxUtil.throwAsGenerationException(e, null);\n}\nreturn sw;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature:<init>(Ljava/lang/String;IZ)V",
                                    "method_body": "private Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature:<clinit>()V",
                                    "method_body": "public final static String DEFAULT_UNNAMED_TEXT_PROPERTY = \"\";\n\n/**\n* Enumeration that defines all togglable features for XML parsers.\n*/\npublic enum Feature implements FormatFeature\n{\n/**\n* Feature that indicates whether XML Empty elements (ones where there are\n* no separate start and end tages, but just one tag that ends with \"/>\")\n* are exposed as {@link JsonToken#VALUE_NULL}) or not. If they are not\n* returned as `null` tokens, they will be returned as {@link JsonToken#VALUE_STRING}\n* tokens with textual value of \"\" (empty String).\n*<p>\n* Default setting is `true` for backwards compatibility.\n*\n* @since 2.9\n*/\nEMPTY_ELEMENT_AS_NULL(true)\n;\n\nfinal boolean _defaultState;\nfinal int _mask;\n\n/**\n* Method that calculates bit set (flags) of all features that\n* are enabled by default.\n*/\npublic static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}\n\nprivate Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}\n\n@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public int getMask() { return _mask; }\n@Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature:collectDefaults()I",
                                    "method_body": "public static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature:enabledByDefault()Z",
                                    "method_body": "@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public boolean enabledByDefault() { return _defaultState; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature:getMask()I",
                                    "method_body": "@Override public int getMask() { return _mask; }\n@Override public int getMask() { return _mask; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:<init>(Ljava/lang/String;IZ)V",
                                    "method_body": "private Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:<clinit>()V",
                                    "method_body": "protected final static String DEFAULT_UNKNOWN_ELEMENT = \"unknown\";\n\n/**\n* Enumeration that defines all togglable extra XML-specific features\n*/\npublic enum Feature implements FormatFeature\n{\n/**\n* Feature that controls whether XML declaration should be written before\n* when generator is initialized (true) or not (false)\n*/\nWRITE_XML_DECLARATION(false),\n\n/**\n* Feature that controls whether output should be done as XML 1.1; if so,\n* certain aspects may differ from default (1.0) processing: for example,\n* XML declaration will be automatically added (regardless of setting\n* <code>WRITE_XML_DECLARATION</code>) as this is required for reader to\n* know to use 1.1 compliant handling. XML 1.1 can be used to allow quoted\n* control characters (Ascii codes 0 through 31) as well as additional linefeeds\n* and name characters.\n*/\nWRITE_XML_1_1(false)\n;\n\nfinal boolean _defaultState;\nfinal int _mask;\n\n/**\n* Method that calculates bit set (flags) of all features that\n* are enabled by default.\n*/\npublic static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}\n\nprivate Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}\n\n@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public int getMask() { return _mask; }\n@Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:collectDefaults()I",
                                    "method_body": "public static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:enabledByDefault()Z",
                                    "method_body": "@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public boolean enabledByDefault() { return _defaultState; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:getMask()I",
                                    "method_body": "@Override public int getMask() { return _mask; }\n@Override public int getMask() { return _mask; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:enabledIn(I)Z",
                                    "method_body": "@Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n@Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:<init>(Lcom/fasterxml/jackson/dataformat/xml/util/XmlRootNameLookup;)V",
                                    "method_body": "public XmlSerializerProvider(XmlRootNameLookup rootNames)\n{\nsuper();\n_rootNameLookup = rootNames;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:<init>(Lcom/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider;Lcom/fasterxml/jackson/databind/SerializationConfig;Lcom/fasterxml/jackson/databind/ser/SerializerFactory;)V",
                                    "method_body": "public XmlSerializerProvider(XmlSerializerProvider src,\nSerializationConfig config, SerializerFactory f)\n{\nsuper(src, config, f);\n_rootNameLookup  = src._rootNameLookup;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:<init>(Lcom/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider;)V",
                                    "method_body": "protected XmlSerializerProvider(XmlSerializerProvider src) {\nsuper(src);\n// 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n//    root name lookup as that may link back to diff version, configuration\n_rootNameLookup = src._rootNameLookup;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 1L;\n\n/**\n* If all we get to serialize is a null, there's no way to figure out\n* expected root name; so let's just default to something like \"&lt;null>\"...\n*/\nprotected final static QName ROOT_NAME_FOR_NULL = new QName(\"null\");\n\nprotected final XmlRootNameLookup _rootNameLookup;\n\npublic XmlSerializerProvider(XmlRootNameLookup rootNames)\n{\nsuper();\n_rootNameLookup = rootNames;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:copy()Lcom/fasterxml/jackson/databind/ser/DefaultSerializerProvider;",
                                    "method_body": "public DefaultSerializerProvider copy() {\nreturn new XmlSerializerProvider(this);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:createInstance(Lcom/fasterxml/jackson/databind/SerializationConfig;Lcom/fasterxml/jackson/databind/ser/SerializerFactory;)Lcom/fasterxml/jackson/databind/ser/DefaultSerializerProvider;",
                                    "method_body": "public DefaultSerializerProvider createInstance(SerializationConfig config,\nSerializerFactory jsf) {\nreturn new XmlSerializerProvider(this, config, jsf);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:serializeValue(Lcom/fasterxml/jackson/core/JsonGenerator;Ljava/lang/Object;)V",
                                    "method_body": "public void serializeValue(JsonGenerator gen, Object value) throws IOException\n{\nif (value == null) {\n_serializeXmlNull(gen);\nreturn;\n}\nfinal Class<?> cls = value.getClass();\nfinal boolean asArray;\nfinal ToXmlGenerator xgen = _asXmlGenerator(gen);\nif (xgen == null) { // called by convertValue()\nasArray = false;\n} else {\nQName rootName = _rootNameFromConfig();\nif (rootName == null) {\nrootName = _rootNameLookup.findRootName(cls, _config);\n}\n_initWithRootName(xgen, rootName);\nasArray = TypeUtil.isIndexedType(cls);\nif (asArray) {\n_startRootArray(xgen, rootName);\n}\n}\n\n// From super-class implementation\nfinal JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\ntry {\nser.serialize(value, gen, this);\n} catch (Exception e) { // but wrap RuntimeExceptions, to get path information\nthrow _wrapAsIOE(gen, e);\n}\n// end of super-class implementation\n\nif (asArray) {\ngen.writeEndObject();\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:_initWithRootName(Lcom/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator;Ljavax/xml/namespace/QName;)V",
                                    "method_body": "protected void _initWithRootName(ToXmlGenerator xgen, QName rootName) throws IOException\n{\n/* 28-Nov-2012, tatu: We should only initialize the root\n*  name if no name has been set, as per [dataformat-xml#42],\n*  to allow for custom serializers to work.\n*/\nif (!xgen.setNextNameIfMissing(rootName)) {\n// however, if we are root, we... insist\nif (xgen.inRoot()) {\nxgen.setNextName(rootName);\n}\n}\nxgen.initGenerator();\nString ns = rootName.getNamespaceURI();\n/* [dataformat-xml#26] If we just try writing root element with namespace,\n* we will get an explicit prefix. But we'd rather use the default\n* namespace, so let's try to force that.\n*/\nif (ns != null && ns.length() > 0) {\ntry {\nxgen.getStaxWriter().setDefaultNamespace(ns);\n} catch (XMLStreamException e) {\nStaxUtil.throwAsGenerationException(e, xgen);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:_rootNameFromConfig()Ljavax/xml/namespace/QName;",
                                    "method_body": "protected QName _rootNameFromConfig()\n{\nPropertyName name = _config.getFullRootName();\nif (name == null) {\nreturn null;\n}\nString ns = name.getNamespace();\nif (ns == null || ns.isEmpty()) {\nreturn new QName(name.getSimpleName());\n}\nreturn new QName(ns, name.getSimpleName());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:_asXmlGenerator(Lcom/fasterxml/jackson/core/JsonGenerator;)Lcom/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator;",
                                    "method_body": "protected ToXmlGenerator _asXmlGenerator(JsonGenerator gen)\nthrows JsonMappingException\n{\n// [Issue#71]: When converting, we actually get TokenBuffer, which is fine\nif (!(gen instanceof ToXmlGenerator)) {\n// but verify\nif (!(gen instanceof TokenBuffer)) {\nthrow JsonMappingException.from(gen,\n\"XmlMapper does not with generators of type other than ToXmlGenerator; got: \"+gen.getClass().getName());\n}\nreturn null;\n}\nreturn (ToXmlGenerator) gen;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.XmlRootNameLookup:<init>()V",
                                    "method_body": "public XmlRootNameLookup() { }\npublic XmlRootNameLookup() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.XmlRootNameLookup:findRootName(Ljava/lang/Class;Lcom/fasterxml/jackson/databind/cfg/MapperConfig;)Ljavax/xml/namespace/QName;",
                                    "method_body": "public QName findRootName(Class<?> rootType, MapperConfig<?> config)\n{\nClassKey key = new ClassKey(rootType);\nQName name;\nsynchronized (_rootNames) {\nname = _rootNames.get(key);\n}\nif (name != null) {\nreturn name;\n}\nname = _findRootName(rootType, config);\nsynchronized (_rootNames) {\n_rootNames.put(key, name);\n}\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.XmlRootNameLookup:_findRootName(Ljava/lang/Class;Lcom/fasterxml/jackson/databind/cfg/MapperConfig;)Ljavax/xml/namespace/QName;",
                                    "method_body": "protected QName _findRootName(Class<?> rootType, MapperConfig<?> config)\n{\nBeanDescription beanDesc = config.introspectClassAnnotations(rootType);\nAnnotationIntrospector intr = config.getAnnotationIntrospector();\nAnnotatedClass ac = beanDesc.getClassInfo();\nString localName = null;\nString ns = null;\n\nPropertyName root = intr.findRootName(ac);\nif (root != null) {\nlocalName = root.getSimpleName();\nns = root.getNamespace();\n}\n// No answer so far? Let's just default to using simple class name\nif (localName == null || localName.length() == 0) {\n// Should we strip out enclosing class tho? For now, nope:\n// one caveat: array simple names end with \"[]\"; also, \"$\" needs replacing\nlocalName = StaxUtil.sanitizeXmlTypeName(rootType.getSimpleName());\nreturn new QName(\"\", localName);\n}\n// Otherwise let's see if there's namespace, too (if we are missing it)\nif (ns == null || ns.length() == 0) {\nns = findNamespace(intr, ac);\n}\nif (ns == null) { // some QName impls barf on nulls...\nns = \"\";\n}\nreturn new QName(ns, localName);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.XmlRootNameLookup:findNamespace(Lcom/fasterxml/jackson/databind/AnnotationIntrospector;Lcom/fasterxml/jackson/databind/introspect/AnnotatedClass;)Ljava/lang/String;",
                                    "method_body": "private String findNamespace(AnnotationIntrospector ai, AnnotatedClass ann)\n{\nfor (AnnotationIntrospector intr : ai.allIntrospectors()) {\nif (intr instanceof XmlAnnotationIntrospector) {\nString ns = ((XmlAnnotationIntrospector) intr).findNamespace(ann);\nif (ns != null) {\nreturn ns;\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerModifier:<init>()V",
                                    "method_body": "public XmlBeanSerializerModifier() { }\npublic XmlBeanSerializerModifier() { }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerModifier:changeProperties(Lcom/fasterxml/jackson/databind/SerializationConfig;Lcom/fasterxml/jackson/databind/BeanDescription;Ljava/util/List;)Ljava/util/List;",
                                    "method_body": "public List<BeanPropertyWriter> changeProperties(SerializationConfig config,\nBeanDescription beanDesc, List<BeanPropertyWriter> beanProperties)\n{\nfinal AnnotationIntrospector intr = config.getAnnotationIntrospector();\nfor (int i = 0, len = beanProperties.size(); i < len; ++i) {\nBeanPropertyWriter bpw = beanProperties.get(i);\nfinal AnnotatedMember member = bpw.getMember();\nString ns = AnnotationUtil.findNamespaceAnnotation(intr, member);\nBoolean isAttribute = AnnotationUtil.findIsAttributeAnnotation(intr, member);\nBoolean isText = AnnotationUtil.findIsTextAnnotation(intr, member);\nBoolean isCData = AnnotationUtil.findIsCDataAnnotation(intr, member);\nbpw.setInternalSetting(XmlBeanSerializerBase.KEY_XML_INFO,\nnew XmlInfo(isAttribute, ns, isText, isCData));\n\n// Actually: if we have a Collection type, easiest place to add wrapping would be here...\n//  or: let's also allow wrapping of \"untyped\" (Object): assuming it is a dynamically\n//   typed Collection...\nif (!TypeUtil.isIndexedType(bpw.getType())) {\ncontinue;\n}\nPropertyName wrappedName = PropertyName.construct(bpw.getName(), ns);\nPropertyName wrapperName = bpw.getWrapperName();\n\n// first things first: no wrapping?\nif (wrapperName == null || wrapperName == PropertyName.NO_NAME) {\ncontinue;\n}\n// no local name? Just double the wrapped name for wrapper\nString localName = wrapperName.getSimpleName();\nif (localName == null || localName.length() == 0) {\nwrapperName = wrappedName;\n}\nbeanProperties.set(i, new XmlBeanPropertyWriter(bpw, wrapperName, wrappedName));\n}\nreturn beanProperties;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerModifier:modifySerializer(Lcom/fasterxml/jackson/databind/SerializationConfig;Lcom/fasterxml/jackson/databind/BeanDescription;Lcom/fasterxml/jackson/databind/JsonSerializer;)Lcom/fasterxml/jackson/databind/JsonSerializer;",
                                    "method_body": "public JsonSerializer<?> modifySerializer(SerializationConfig config,\nBeanDescription beanDesc, JsonSerializer<?> serializer)\n{\n/* First things first: we can only handle real BeanSerializers; question\n* is, what to do if it's not one: throw exception or bail out?\n* For now let's do latter.\n*/\nif (!(serializer instanceof BeanSerializerBase)) {\nreturn serializer;\n}\nreturn new XmlBeanSerializer((BeanSerializerBase) serializer);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlBeanDeserializerModifier:<init>(Ljava/lang/String;)V",
                                    "method_body": "public XmlBeanDeserializerModifier(String nameForTextValue)\n{\n_cfgNameForTextValue = nameForTextValue;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:<init>(Z)V",
                                    "method_body": "public JacksonXmlAnnotationIntrospector(boolean defaultUseWrapper) {\n_cfgDefaultUseWrapper = defaultUseWrapper;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:findWrapperName(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Lcom/fasterxml/jackson/databind/PropertyName;",
                                    "method_body": "public PropertyName findWrapperName(Annotated ann)\n{\nJacksonXmlElementWrapper w = ann.getAnnotation(JacksonXmlElementWrapper.class);\nif (w != null) {\n// Special case: wrapping explicitly blocked?\nif (!w.useWrapping()) {\nreturn PropertyName.NO_NAME;\n}\n// also: need to ensure we use marker:\nString localName = w.localName();\nif (localName == null || localName.length() == 0) {\nreturn PropertyName.USE_DEFAULT;\n}\nreturn PropertyName.construct(w.localName(), w.namespace());\n}\n/* 09-Sep-2012, tatu: In absence of configurating we need to use our\n*   default settings...\n*/\nif (_cfgDefaultUseWrapper) {\nreturn PropertyName.USE_DEFAULT;\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:findRootName(Lcom/fasterxml/jackson/databind/introspect/AnnotatedClass;)Lcom/fasterxml/jackson/databind/PropertyName;",
                                    "method_body": "public PropertyName findRootName(AnnotatedClass ac)\n{\nJacksonXmlRootElement root = ac.getAnnotation(JacksonXmlRootElement.class);\nif (root != null) {\nString local = root.localName();\nString ns = root.namespace();\n\nif (local.length() == 0 && ns.length() == 0) {\nreturn PropertyName.USE_DEFAULT;\n}\nreturn new PropertyName(local, ns);\n}\nreturn super.findRootName(ac);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:findNamespace(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Ljava/lang/String;",
                                    "method_body": "public String findNamespace(Annotated ann)\n{\nJacksonXmlProperty prop = ann.getAnnotation(JacksonXmlProperty.class);\nif (prop != null) {\nreturn prop.namespace();\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:isOutputAsAttribute(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Ljava/lang/Boolean;",
                                    "method_body": "public Boolean isOutputAsAttribute(Annotated ann)\n{\nJacksonXmlProperty prop = ann.getAnnotation(JacksonXmlProperty.class);\nif (prop != null) {\nreturn prop.isAttribute() ? Boolean.TRUE : Boolean.FALSE;\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:isOutputAsText(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Ljava/lang/Boolean;",
                                    "method_body": "public Boolean isOutputAsText(Annotated ann)\n{\nJacksonXmlText prop = ann.getAnnotation(JacksonXmlText.class);\nif (prop != null) {\nreturn prop.value() ? Boolean.TRUE : Boolean.FALSE;\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:isOutputAsCData(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Ljava/lang/Boolean;",
                                    "method_body": "public Boolean isOutputAsCData(Annotated ann) {\nJacksonXmlCData prop = ann.getAnnotation(JacksonXmlCData.class);\nif (prop != null) {\nreturn prop.value() ? Boolean.TRUE : Boolean.FALSE;\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:findNameForSerialization(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Lcom/fasterxml/jackson/databind/PropertyName;",
                                    "method_body": "public PropertyName findNameForSerialization(Annotated a)\n{\nPropertyName name = _findXmlName(a);\nif (name == null) {\nname = super.findNameForSerialization(a);\nif (name == null) {\nif (a.hasAnnotation(JacksonXmlText.class)) {\nreturn PropertyName.USE_DEFAULT;\n}\n}\n}\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:_findXmlName(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Lcom/fasterxml/jackson/databind/PropertyName;",
                                    "method_body": "protected PropertyName _findXmlName(Annotated a)\n{\nJacksonXmlProperty pann = a.getAnnotation(JacksonXmlProperty.class);\nif (pann != null) {\nreturn PropertyName.construct(pann.localName(), pann.namespace());\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.AnnotationUtil:findNamespaceAnnotation(Lcom/fasterxml/jackson/databind/AnnotationIntrospector;Lcom/fasterxml/jackson/databind/introspect/AnnotatedMember;)Ljava/lang/String;",
                                    "method_body": "public static String findNamespaceAnnotation(AnnotationIntrospector ai,\nAnnotatedMember prop)\n{\nfor (AnnotationIntrospector intr : ai.allIntrospectors()) {\nif (intr instanceof XmlAnnotationIntrospector) {\nString ns = ((XmlAnnotationIntrospector) intr).findNamespace(prop);\nif (ns != null) {\nreturn ns;\n}\n} else  if (intr instanceof JaxbAnnotationIntrospector) {\nString ns = ((JaxbAnnotationIntrospector) intr).findNamespace(prop);\nif (ns != null) {\nreturn ns;\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.AnnotationUtil:findIsAttributeAnnotation(Lcom/fasterxml/jackson/databind/AnnotationIntrospector;Lcom/fasterxml/jackson/databind/introspect/AnnotatedMember;)Ljava/lang/Boolean;",
                                    "method_body": "public static Boolean findIsAttributeAnnotation(AnnotationIntrospector ai,\nAnnotatedMember prop)\n{\nfor (AnnotationIntrospector intr : ai.allIntrospectors()) {\nif (intr instanceof XmlAnnotationIntrospector) {\nBoolean b = ((XmlAnnotationIntrospector) intr).isOutputAsAttribute(prop);\nif (b != null) {\nreturn b;\n}\n} else  if (intr instanceof JaxbAnnotationIntrospector) {\nBoolean b = ((JaxbAnnotationIntrospector) intr).isOutputAsAttribute(prop);\nif (b != null) {\nreturn b;\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.AnnotationUtil:findIsTextAnnotation(Lcom/fasterxml/jackson/databind/AnnotationIntrospector;Lcom/fasterxml/jackson/databind/introspect/AnnotatedMember;)Ljava/lang/Boolean;",
                                    "method_body": "public static Boolean findIsTextAnnotation(AnnotationIntrospector ai,\nAnnotatedMember prop)\n{\nfor (AnnotationIntrospector intr : ai.allIntrospectors()) {\nif (intr instanceof XmlAnnotationIntrospector) {\nBoolean b = ((XmlAnnotationIntrospector) intr).isOutputAsText(prop);\nif (b != null) {\nreturn b;\n}\n} else  if (intr instanceof JaxbAnnotationIntrospector) {\nBoolean b = ((JaxbAnnotationIntrospector) intr).isOutputAsText(prop);\nif (b != null) {\nreturn b;\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.AnnotationUtil:findIsCDataAnnotation(Lcom/fasterxml/jackson/databind/AnnotationIntrospector;Lcom/fasterxml/jackson/databind/introspect/AnnotatedMember;)Ljava/lang/Boolean;",
                                    "method_body": "public static Boolean findIsCDataAnnotation(AnnotationIntrospector ai,\nAnnotatedMember prop)\n{\nfor (AnnotationIntrospector intr : ai.allIntrospectors()) {\nif (intr instanceof XmlAnnotationIntrospector) {\nBoolean b = ((XmlAnnotationIntrospector) intr).isOutputAsCData(prop);\nif (b != null) {\nreturn b;\n}\n}\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.TypeUtil:isIndexedType(Lcom/fasterxml/jackson/databind/JavaType;)Z",
                                    "method_body": "public static boolean isIndexedType(JavaType type)\n{\nif (type.isContainerType()) {\nClass<?> cls = type.getRawClass();\n// One special case; byte[] will be serialized as base64-encoded String, not real array, so:\n// (actually, ditto for char[]; thought to be a String)\nif (cls == byte[].class || cls == char[].class) {\nreturn false;\n}\n// Also, should not add wrapping for Maps\n// [dataformat-xml#220]: nor map-like (Scala Map) types\nif (type.isMapLikeType()) {\nreturn false;\n}\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.TypeUtil:isIndexedType(Ljava/lang/Class;)Z",
                                    "method_body": "public static boolean isIndexedType(Class<?> cls)\n{\nreturn (cls.isArray() && cls != byte[].class && cls != char[].class)\n|| Collection.class.isAssignableFrom(cls);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:<init>(Lcom/fasterxml/jackson/core/io/IOContext;IILcom/fasterxml/jackson/core/ObjectCodec;Ljavax/xml/stream/XMLStreamWriter;)V",
                                    "method_body": "public ToXmlGenerator(IOContext ctxt, int stdFeatures, int xmlFeatures,\nObjectCodec codec, XMLStreamWriter sw)\n{\nsuper(stdFeatures, codec);\n_formatFeatures = xmlFeatures;\n_ioContext = ctxt;\n_originalXmlWriter = sw;\n_xmlWriter = Stax2WriterAdapter.wrapIfNecessary(sw);\n_stax2Emulation = (_xmlWriter != sw);\n_xmlPrettyPrinter = (_cfgPrettyPrinter instanceof XmlPrettyPrinter) ?\n(XmlPrettyPrinter) _cfgPrettyPrinter : null;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:initGenerator()V",
                                    "method_body": "public void initGenerator()  throws IOException\n{\nif (_initialized) {\nreturn;\n}\n_initialized = true;\ntry {\nif (Feature.WRITE_XML_1_1.enabledIn(_formatFeatures)) {\n_xmlWriter.writeStartDocument(\"UTF-8\", \"1.1\");\n} else if (Feature.WRITE_XML_DECLARATION.enabledIn(_formatFeatures)) {\n_xmlWriter.writeStartDocument(\"UTF-8\", \"1.0\");\n} else {\nreturn;\n}\n// as per [dataformat-xml#172], try adding indentation\nif (_xmlPrettyPrinter != null) {\n// ... but only if it is likely to succeed:\nif (!_stax2Emulation) {\n_xmlPrettyPrinter.writePrologLinefeed(_xmlWriter);\n}\n}\n} catch (XMLStreamException e) {\nStaxUtil.throwAsGenerationException(e, this);\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:setNextIsAttribute(Z)V",
                                    "method_body": "public void setNextIsAttribute(boolean isAttribute)\n{\n_nextIsAttribute = isAttribute;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:setNextName(Ljavax/xml/namespace/QName;)V",
                                    "method_body": "public final void setNextName(QName name)\n{\n_nextName = name;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:setNextNameIfMissing(Ljavax/xml/namespace/QName;)Z",
                                    "method_body": "public final boolean setNextNameIfMissing(QName name)\n{\nif (_nextName == null) {\n_nextName = name;\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:writeFieldName(Ljava/lang/String;)V",
                                    "method_body": "public final void writeFieldName(String name) throws IOException\n{\nif (_writeContext.writeFieldName(name) == JsonWriteContext.STATUS_EXPECT_VALUE) {\n_reportError(\"Can not write a field name, expecting a value\");\n}\n// Should this ever get called?\nString ns = (_nextName == null) ? \"\" : _nextName.getNamespaceURI();\nsetNextName(new QName(ns, name));\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:writeStartObject()V",
                                    "method_body": "public final void writeStartObject() throws IOException\n{\n_verifyValueWrite(\"start an object\");\n_writeContext = _writeContext.createChildObjectContext();\nif (_cfgPrettyPrinter != null) {\n_cfgPrettyPrinter.writeStartObject(this);\n} else {\n_handleStartObject();\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:writeEndObject()V",
                                    "method_body": "public final void writeEndObject() throws IOException\n{\nif (!_writeContext.inObject()) {\n_reportError(\"Current context not Object but \"+_writeContext.typeDesc());\n}\n_writeContext = _writeContext.getParent();\nif (_cfgPrettyPrinter != null) {\n// as per [Issue#45], need to suppress indentation if only attributes written:\nint count = _nextIsAttribute ? 0 : _writeContext.getEntryCount();\n_cfgPrettyPrinter.writeEndObject(this, count);\n} else {\n_handleEndObject();\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:_handleStartObject()V",
                                    "method_body": "public final void _handleStartObject() throws IOException\n{\nif (_nextName == null) {\nhandleMissingName();\n}\n// Need to keep track of names to make Lists work correctly\n_elementNameStack.addLast(_nextName);\ntry {\n_xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n} catch (XMLStreamException e) {\nStaxUtil.throwAsGenerationException(e, this);\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:_handleEndObject()V",
                                    "method_body": "public final void _handleEndObject() throws IOException\n{\n// We may want to repeat same element, so:\nif (_elementNameStack.isEmpty()) {\nthrow new JsonGenerationException(\"Can not write END_ELEMENT without open START_ELEMENT\", this);\n}\n_nextName = _elementNameStack.removeLast();\ntry {\n// note: since attributes don't nest, can only have one attribute active, so:\n_nextIsAttribute = false;\n_xmlWriter.writeEndElement();\n// [databind-xml#172]: possibly also need indentation\nif (_elementNameStack.isEmpty() && (_xmlPrettyPrinter != null)) {\n// ... but only if it is likely to succeed:\nif (!_stax2Emulation) {\n_xmlPrettyPrinter.writePrologLinefeed(_xmlWriter);\n}\n}\n} catch (XMLStreamException e) {\nStaxUtil.throwAsGenerationException(e, this);\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:writeFieldName(Lcom/fasterxml/jackson/core/SerializableString;)V",
                                    "method_body": "public void writeFieldName(SerializableString name) throws IOException\n{\nwriteFieldName(name.getValue());\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:writeNumber(I)V",
                                    "method_body": "public void writeNumber(int i) throws IOException\n{\n_verifyValueWrite(\"write number\");\nif (_nextName == null) {\nhandleMissingName();\n}\ntry {\nif (_nextIsAttribute) {\n_xmlWriter.writeIntAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), i);\n} else if (checkNextIsUnwrapped()) {\n// should we consider pretty-printing or not?\n_xmlWriter.writeInt(i);\n} else {\nif (_xmlPrettyPrinter != null) {\n_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n_nextName.getNamespaceURI(), _nextName.getLocalPart(),\ni);\n} else {\n_xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n_xmlWriter.writeInt(i);\n_xmlWriter.writeEndElement();\n}\n}\n} catch (XMLStreamException e) {\nStaxUtil.throwAsGenerationException(e, this);\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:_verifyValueWrite(Ljava/lang/String;)V",
                                    "method_body": "protected final void _verifyValueWrite(String typeMsg) throws IOException\n{\nint status = _writeContext.writeValue();\nif (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n_reportError(\"Can not \"+typeMsg+\", expecting field name\");\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:close()V",
                                    "method_body": "public void close() throws IOException\n{\n//        boolean wasClosed = _closed;\nsuper.close();\n\n// First: let's see that we still have buffers...\nif (isEnabled(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT)) {\ntry {\nwhile (true) {\n/* 28-May-2016, tatu: To work around incompatibility introduced by\n*     `jackson-core` 2.8 where return type of `getOutputContext()`\n*     changed, let's do direct access here.\n*/\n//                    JsonStreamContext ctxt = getOutputContext();\nJsonStreamContext ctxt = _writeContext;\nif (ctxt.inArray()) {\nwriteEndArray();\n} else if (ctxt.inObject()) {\nwriteEndObject();\n} else {\nbreak;\n}\n}\n} catch (ArrayIndexOutOfBoundsException e) {\n/* 29-Nov-2010, tatu: Stupid, stupid SJSXP doesn't do array checks, so we get\n*   hit by this as a collateral problem in some cases. Yuck.\n*/\nthrow new JsonGenerationException(e, this);\n}\n}\ntry {\nif (_ioContext.isResourceManaged() || isEnabled(JsonGenerator.Feature.AUTO_CLOSE_TARGET)) {\n_xmlWriter.closeCompletely();\n} else {\n_xmlWriter.close();\n}\n} catch (XMLStreamException e) {\nStaxUtil.throwAsGenerationException(e, this);\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:checkNextIsUnwrapped()Z",
                                    "method_body": "protected boolean checkNextIsUnwrapped()\n{\nif (_nextIsUnwrapped) {\n_nextIsUnwrapped = false;\nreturn true;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerBase:<init>(Lcom/fasterxml/jackson/databind/ser/std/BeanSerializerBase;)V",
                                    "method_body": "public XmlBeanSerializerBase(BeanSerializerBase src)\n{\nsuper(src);\n\n/* Then make sure attributes are sorted before elements, keep track\n* of how many there are altogether\n*/\nint attrCount = 0;\nfor (BeanPropertyWriter bpw : _props) {\nif (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\nattrCount = _orderAttributesFirst(_props, _filteredProps);\nbreak;\n}\n}\n_attributeCount = attrCount;\n\n// also: pre-compute need, if any, for CDATA handling:\nBitSet cdata = null;\nfor (int i = 0, len = _props.length; i < len; ++i) {\nBeanPropertyWriter bpw = _props[i];\nif (_isCData(bpw)) {\nif (cdata == null) {\ncdata = new BitSet(len);\n}\ncdata.set(i);\n}\n}\n_cdata = cdata;\n\n// And then collect namespace information\n_xmlNames = new QName[_props.length];\nint textIndex = -1;\nfor (int i = 0, len = _props.length; i < len; ++i) {\nBeanPropertyWriter bpw = _props[i];\nXmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\nString ns = null;\nif (info != null) {\nns = info.getNamespace();\nif (textIndex < 0 && info.isText()) {\ntextIndex = i;\n}\n}\n_xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n}\n_textPropertyIndex = textIndex;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerBase:<clinit>()V",
                                    "method_body": "public final static String KEY_XML_INFO = new String(\"xmlInfo\");\n\n/**\n* Number of attributes to write; these will have been ordered to be the first\n* properties to write.\n*/\nprotected final int _attributeCount;\n\n/**\n* Index of \"text value\" property we have, if any; can have at most\n* one such property.\n*/\nprotected final int _textPropertyIndex;\n\n/**\n* Array that contains namespace URIs associated with properties, if any;\n* null if no namespace definitions have been assigned\n*/\nprotected final QName[] _xmlNames;\n\n/**\n* Optional set of indexes of properties that should be serialized as CDATA,\n* instead of regular XML text segment. Left as null in cases where none of\n* element values are to be written in such a way.\n*/\nprotected final BitSet _cdata;\n\npublic XmlBeanSerializerBase(BeanSerializerBase src)\n{\nsuper(src);\n\n/* Then make sure attributes are sorted before elements, keep track\n* of how many there are altogether\n*/\nint attrCount = 0;\nfor (BeanPropertyWriter bpw : _props) {\nif (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\nattrCount = _orderAttributesFirst(_props, _filteredProps);\nbreak;\n}\n}\n_attributeCount = attrCount;\n\n// also: pre-compute need, if any, for CDATA handling:\nBitSet cdata = null;\nfor (int i = 0, len = _props.length; i < len; ++i) {\nBeanPropertyWriter bpw = _props[i];\nif (_isCData(bpw)) {\nif (cdata == null) {\ncdata = new BitSet(len);\n}\ncdata.set(i);\n}\n}\n_cdata = cdata;\n\n// And then collect namespace information\n_xmlNames = new QName[_props.length];\nint textIndex = -1;\nfor (int i = 0, len = _props.length; i < len; ++i) {\nBeanPropertyWriter bpw = _props[i];\nXmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\nString ns = null;\nif (info != null) {\nns = info.getNamespace();\nif (textIndex < 0 && info.isText()) {\ntextIndex = i;\n}\n}\n_xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n}\n_textPropertyIndex = textIndex;\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerBase:serializeFields(Ljava/lang/Object;Lcom/fasterxml/jackson/core/JsonGenerator;Lcom/fasterxml/jackson/databind/SerializerProvider;)V",
                                    "method_body": "protected void serializeFields(Object bean, JsonGenerator gen0, SerializerProvider provider)\nthrows IOException\n{\n// 19-Aug-2013, tatu: During 'convertValue()', need to skip\nif (!(gen0 instanceof ToXmlGenerator)) {\nsuper.serializeFields(bean, gen0, provider);\nreturn;\n}\nfinal ToXmlGenerator xgen = (ToXmlGenerator) gen0;\nfinal BeanPropertyWriter[] props;\nif (_filteredProps != null && provider.getActiveView() != null) {\nprops = _filteredProps;\n} else {\nprops = _props;\n}\n\nfinal int attrCount = _attributeCount;\nfinal boolean isAttribute = xgen._nextIsAttribute;\nif (attrCount > 0) {\nxgen.setNextIsAttribute(true);\n}\nfinal int textIndex = _textPropertyIndex;\nfinal QName[] xmlNames = _xmlNames;\nint i = 0;\nfinal BitSet cdata = _cdata;\n\ntry {\nfor (final int len = props.length; i < len; ++i) {\n// 28-jan-2014, pascal: we don't want to reset the attribute flag if we are an unwrapping serializer\n// that started with nextIsAttribute to true because all properties should be unwrapped as attributes too.\nif (i == attrCount && !(isAttribute && isUnwrappingSerializer())) {\nxgen.setNextIsAttribute(false);\n}\n// also: if this is property to write as text (\"unwrap\"), need to:\nif (i == textIndex) {\nxgen.setNextIsUnwrapped(true);\n}\nxgen.setNextName(xmlNames[i]);\nBeanPropertyWriter prop = props[i];\nif (prop != null) { // can have nulls in filtered list\nif ((cdata != null) && cdata.get(i)) {\nxgen.setNextIsCData(true);\nprop.serializeAsField(bean, xgen, provider);\nxgen.setNextIsCData(false);\n} else {\nprop.serializeAsField(bean, xgen, provider);\n}\n}\n// Reset to avoid next value being written as unwrapped,\n// for example when property is suppressed\nif (i == textIndex) {\nxgen.setNextIsUnwrapped(false);\n}\n}\nif (_anyGetterWriter != null) {\n// For [#117]: not a clean fix, but with @JsonTypeInfo, we'll end up\n// with accidental attributes otherwise\nxgen.setNextIsAttribute(false);\n_anyGetterWriter.getAndSerialize(bean, xgen, provider);\n}\n} catch (Exception e) {\nString name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\nwrapAndThrow(provider, e, bean, name);\n} catch (StackOverflowError e) { // Bit tricky, can't do more calls as stack is full; so:\nJsonMappingException mapE = JsonMappingException.from(gen0,\n\"Infinite recursion (StackOverflowError)\");\nString name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\nmapE.prependPath(new JsonMappingException.Reference(bean, name));\nthrow mapE;\n}\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerBase:_isAttribute(Lcom/fasterxml/jackson/databind/ser/BeanPropertyWriter;)Z",
                                    "method_body": "protected static boolean _isAttribute(BeanPropertyWriter bpw)\n{\nXmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\nreturn (info != null) && info.isAttribute();\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerBase:_isCData(Lcom/fasterxml/jackson/databind/ser/BeanPropertyWriter;)Z",
                                    "method_body": "protected static boolean _isCData(BeanPropertyWriter bpw)\n{\nXmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\nreturn (info != null) && info.isCData();\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.XmlInfo:<init>(Ljava/lang/Boolean;Ljava/lang/String;Ljava/lang/Boolean;Ljava/lang/Boolean;)V",
                                    "method_body": "public XmlInfo(Boolean isAttribute, String ns, Boolean isText, Boolean isCData)\n{\n_isAttribute = (isAttribute == null) ? false : isAttribute.booleanValue();\n_namespace = (ns == null) ? \"\" : ns;\n_isText = (isText == null) ? false : isText.booleanValue();\n_isCData = (isCData == null) ? false : isCData.booleanValue();\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.XmlInfo:getNamespace()Ljava/lang/String;",
                                    "method_body": "public String getNamespace() { return _namespace; }\npublic String getNamespace() { return _namespace; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.XmlInfo:isAttribute()Z",
                                    "method_body": "public boolean isAttribute() { return _isAttribute; }\npublic boolean isAttribute() { return _isAttribute; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.XmlInfo:isText()Z",
                                    "method_body": "public boolean isText() { return _isText; }\npublic boolean isText() { return _isText; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.util.XmlInfo:isCData()Z",
                                    "method_body": "public boolean isCData() { return _isCData; }\npublic boolean isCData() { return _isCData; }"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializer:<init>(Lcom/fasterxml/jackson/databind/ser/std/BeanSerializerBase;)V",
                                    "method_body": "public XmlBeanSerializer(BeanSerializerBase src) {\nsuper(src);\n}"
                                },
                                {
                                    "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializer:serialize(Ljava/lang/Object;Lcom/fasterxml/jackson/core/JsonGenerator;Lcom/fasterxml/jackson/databind/SerializerProvider;)V",
                                    "method_body": "public void serialize(Object bean, JsonGenerator g, SerializerProvider provider) throws IOException\n{\nif (_objectIdWriter != null) {\n_serializeWithObjectId(bean, g, provider, true);\nreturn;\n}\ng.writeStartObject();\nif (_propertyFilterId != null) {\nserializeFieldsFiltered(bean, g, provider);\n} else {\nserializeFields(bean, g, provider);\n}\ng.writeEndObject();\n}"
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}